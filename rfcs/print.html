<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Amaranth RFC Book</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/img-color-scheme.css">

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="0001-aggregate-data-structures.html">0001-aggregate-data-structures</a></li><li class="chapter-item expanded "><a href="0002-interfaces.html">0002-interfaces</a></li><li class="chapter-item expanded "><a href="0003-enumeration-shapes.html">0003-enumeration-shapes</a></li><li class="chapter-item expanded "><a href="0004-const-castable-exprs.html">0004-const-castable-exprs</a></li><li class="chapter-item expanded "><a href="0005-remove-const-normalize.html">0005-remove-const-normalize</a></li><li class="chapter-item expanded "><a href="0006-stdlib-crc.html">0006-stdlib-crc</a></li><li class="chapter-item expanded "><a href="0008-aggregate-extensibility.html">0008-aggregate-extensibility</a></li><li class="chapter-item expanded "><a href="0009-const-init-shape-castable.html">0009-const-init-shape-castable</a></li><li class="chapter-item expanded "><a href="0010-move-repl-to-value.html">0010-move-repl-to-value</a></li><li class="chapter-item expanded "><a href="0015-lifting-shape-castables.html">0015-lifting-shape-castables</a></li><li class="chapter-item expanded "><a href="0016-soc-csr-regs.html">0016-soc-csr-regs</a></li><li class="chapter-item expanded "><a href="0017-remove-log2-int.html">0017-remove-log2-int</a></li><li class="chapter-item expanded "><a href="0018-reorganize-vendor-platforms.html">0018-reorganize-vendor-platforms</a></li><li class="chapter-item expanded "><a href="0019-remove-scheduler.html">0019-remove-scheduler</a></li><li class="chapter-item expanded "><a href="0020-deprecate-non-fwft-fifos.html">0020-deprecate-non-fwft-fifos</a></li><li class="chapter-item expanded "><a href="0021-patch-releases.html">0021-patch-releases</a></li><li class="chapter-item expanded "><a href="0022-valuecastable-shape.html">0022-valuecastable-shape</a></li><li class="chapter-item expanded "><a href="0027-simulator-testbenches.html">0027-simulator-testbenches</a></li><li class="chapter-item expanded "><a href="0028-override-value-operators.html">0028-override-value-operators</a></li><li class="chapter-item expanded "><a href="0030-component-metadata.html">0030-component-metadata</a></li><li class="chapter-item expanded "><a href="0031-enumeration-type-safety.html">0031-enumeration-type-safety</a></li><li class="chapter-item expanded "><a href="0034-interface-rename.html">0034-interface-rename</a></li><li class="chapter-item expanded "><a href="0035-shapelike-valuelike.html">0035-shapelike-valuelike</a></li><li class="chapter-item expanded "><a href="0036-async-testbench-functions.html">0036-async-testbench-functions</a></li><li class="chapter-item expanded "><a href="0037-make-signature-immutable.html">0037-make-signature-immutable</a></li><li class="chapter-item expanded "><a href="0038-component-signature-immutability.html">0038-component-signature-immutability</a></li><li class="chapter-item expanded "><a href="0039-empty-case.html">0039-empty-case</a></li><li class="chapter-item expanded "><a href="0040-arbitrary-memory-shape.html">0040-arbitrary-memory-shape</a></li><li class="chapter-item expanded "><a href="0042-const-from-shape-castable.html">0042-const-from-shape-castable</a></li><li class="chapter-item expanded "><a href="0043-rename-reset-to-init.html">0043-rename-reset-to-init</a></li><li class="chapter-item expanded "><a href="0045-lib-memory.html">0045-lib-memory</a></li><li class="chapter-item expanded "><a href="0046-shape-range-1.html">0046-shape-range-1</a></li><li class="chapter-item expanded "><a href="0049-soc-gpio-peripheral.html">0049-soc-gpio-peripheral</a></li><li class="chapter-item expanded "><a href="0050-print.html">0050-print</a></li><li class="chapter-item expanded "><a href="0051-const-from-bits.html">0051-const-from-bits</a></li><li class="chapter-item expanded "><a href="0052-choice.html">0052-choice</a></li><li class="chapter-item expanded "><a href="0053-ioport.html">0053-ioport</a></li><li class="chapter-item expanded "><a href="0054-read-port-init.html">0054-read-port-init</a></li><li class="chapter-item expanded "><a href="0055-lib-io.html">0055-lib-io</a></li><li class="chapter-item expanded "><a href="0056-mem-wide.html">0056-mem-wide</a></li><li class="chapter-item expanded "><a href="0057-single-field-shortcut.html">0057-single-field-shortcut</a></li><li class="chapter-item expanded "><a href="0058-valuecastable-format.html">0058-valuecastable-format</a></li><li class="chapter-item expanded "><a href="0059-no-domain-upwards-propagation.html">0059-no-domain-upwards-propagation</a></li><li class="chapter-item expanded "><a href="0061-minimal-streams.html">0061-minimal-streams</a></li><li class="chapter-item expanded "><a href="0062-memory-data.html">0062-memory-data</a></li><li class="chapter-item expanded "><a href="0063-remove-lib-coding.html">0063-remove-lib-coding</a></li><li class="chapter-item expanded "><a href="0065-format-struct-enum.html">0065-format-struct-enum</a></li><li class="chapter-item expanded "><a href="0066-simulation-time.html">0066-simulation-time</a></li><li class="chapter-item expanded "><a href="0069-simulation-port.html">0069-simulation-port</a></li><li class="chapter-item expanded "><a href="0070-soc-memory-map-names.html">0070-soc-memory-map-names</a></li><li class="chapter-item expanded "><a href="0071-enumview-matches.html">0071-enumview-matches</a></li><li class="chapter-item expanded "><a href="0073-stricter-connections.html">0073-stricter-connections</a></li><li class="chapter-item expanded "><a href="0076-amaranth-boards-versioning-policy.html">0076-amaranth-boards-versioning-policy</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Amaranth RFC Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/amaranth-lang/rfcs" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="amaranth-rfcs---rfc-book"><a class="header" href="#amaranth-rfcs---rfc-book">Amaranth RFCs - <a href="https://amaranth-lang.org/rfcs/">RFC Book</a></a></h1>
<p>The &quot;RFC&quot; (request for comments) process is intended to provide a consistent and controlled path for changes to Amaranth (such as new features) so that all stakeholders can be confident about the direction of the project.</p>
<p>Many changes, including bug fixes and documentation improvements can be implemented and reviewed via the normal GitHub pull request workflow.</p>
<p>Some changes though are &quot;substantial&quot;, and we ask that these be put through a bit of a design process and produce a consensus among the Amaranth community.</p>
<p>The responsibility for evolving an Amaranth &quot;subsystem&quot; (a clearly defined part of the Amaranth project) lies on a subsystem maintainer. The assignment of maintainers to subsystems is:</p>
<ul>
<li><strong>Core</strong>: Catherine <a href="https://github.com/whitequark">@whitequark</a>
<ul>
<li>The &quot;core&quot; subsystem includes the HDL frontend, backend, and simulator, as well as the build and platform systems.</li>
<li>This covers the <a href="https://github.com/amaranth-lang/amaranth">amaranth-lang/amaranth</a> repository and the <code>amaranth</code> Python package.</li>
</ul>
</li>
<li><strong>SoC</strong>: Jean-Fran√ßois <a href="https://github.com/jfng">@jfng</a>
<ul>
<li>The &quot;SoC&quot; subsystem includes the SoC infrastructure.</li>
<li>This covers the <a href="https://github.com/amaranth-lang/amaranth-soc">amaranth-lang/amaranth-soc</a> repository and the <code>amaranth_soc</code> Python package.</li>
</ul>
</li>
<li>Other repositories and Python packages are not currently covered by the RFC process and changes are implemented on an ad-hoc basis.</li>
</ul>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ul>
<li><a href="introduction.html#amaranth-rfcs">Opening</a></li>
<li><a href="introduction.html#table-of-contents">Table of Contents</a></li>
<li><a href="introduction.html#when-you-need-to-follow-this-process">When you need to follow this process</a></li>
<li><a href="introduction.html#before-creating-an-rfc">Before creating an RFC</a></li>
<li><a href="introduction.html#what-the-process-is">What the process is</a></li>
<li><a href="introduction.html#the-rfc-life-cycle">The RFC life-cycle</a></li>
<li><a href="introduction.html#reviewing-rfcs">Reviewing RFCs</a></li>
<li><a href="introduction.html#merging-an-rfc">Merging an RFC</a></li>
<li><a href="introduction.html#implementing-an-rfc">Implementing an RFC</a></li>
<li><a href="introduction.html#acknowledgements">Acknowledgements</a></li>
<li><a href="introduction.html#license">License</a></li>
</ul>
<h2 id="when-you-need-to-follow-this-process"><a class="header" href="#when-you-need-to-follow-this-process">When you need to follow this process</a></h2>
<p>You need to follow this process if you intend to make &quot;substantial&quot; changes to any of the subsystems listed above.</p>
<p>What constitutes a &quot;substantial&quot; change is evolving based on community norms and varies depending on what part of the ecosystem you are proposing to change, but may include the following:</p>
<ul>
<li>Any semantic or syntactic change to the language (<code>amaranth.hdl</code>) that is not a bugfix.</li>
<li>Behavioral changes to the standard library (<code>amaranth.lib</code>).</li>
<li>Behavioral changes to the simulator interface (<code>amaranth.sim</code>).</li>
<li>Behavioral changes to the toolchain interface (<code>amaranth.vendor</code>).</li>
</ul>
<p>Some changes do not require an RFC:</p>
<ul>
<li>Rephrasing, reorganizing, refactoring, or otherwise &quot;changing shape does not change meaning&quot;.</li>
<li>Additions that strictly improve objective, numerical quality criteria (warning removal, speedup, better platform coverage, handling more errors, etc.)</li>
</ul>
<p>If you submit a pull request to implement a new feature without going through the RFC process, it may be closed with a polite request to submit an RFC first. When in doubt, please open an issue to discuss the feature first and the subsystem maintainer will say if the change requires an RFC or not.</p>
<h2 id="before-creating-an-rfc"><a class="header" href="#before-creating-an-rfc">Before creating an RFC</a></h2>
<p>A hastily-proposed RFC can hurt its chances of acceptance. Low quality proposals, proposals for previously-rejected features, or those that don't fit into the near-term roadmap, may be quickly rejected, which can be demotivating for the unprepared contributor. Laying some groundwork ahead of the RFC can make the process smoother.</p>
<p>Although there is no single way to prepare for submitting an RFC, it is generally a good idea to pursue feedback from other project developers beforehand, to ascertain that the RFC may be desirable; having a consistent impact on the project requires concerted effort toward consensus-building.</p>
<p>The most common preparations for writing and submitting an RFC include talking the idea over on our IRC channel, <a href="https://web.libera.chat/#amaranth-lang">#amaranth-lang at libera.chat</a>, or opening an issue on the corresponding repository to gather feedback.</p>
<h2 id="what-the-process-is"><a class="header" href="#what-the-process-is">What the process is</a></h2>
<p>In short, to get a major feature added to Amaranth, one must first get the RFC merged into the RFC repository as a markdown file. At that point the RFC is &quot;active&quot; and may be implemented with the goal of eventual inclusion into Amaranth.</p>
<ul>
<li>Fork the RFC repository.</li>
<li>Copy 0000-template.md to text/0000-my-feature.md (where &quot;my-feature&quot; is descriptive). Don't assign an RFC number yet; This is going to be the PR number and we'll rename the file accordingly if the RFC is accepted.</li>
<li>Fill in the RFC. Put care into the details: RFCs that do not present convincing motivation, demonstrate lack of understanding of the design's impact, or are disingenuous about the drawbacks or alternatives tend to be poorly-received.</li>
<li>Submit a pull request. As a pull request the RFC will receive design feedback from the larger community, and the author should be prepared to revise it in response.</li>
<li>Now that your RFC has an open pull request, use the issue number of the PR to update your 0000- prefix to that number.</li>
<li>Build consensus and integrate feedback. RFCs that have broad support are much more likely to make progress than those that don't receive any comments. Feel free to reach out to the RFC assignee in particular to get help identifying stakeholders and obstacles.</li>
<li>RFCs rarely go through this process unchanged, especially as alternatives and drawbacks are shown. You can make edits, big and small, to the RFC to clarify or change the design, but make changes as new commits to the pull request, and leave a comment on the pull request explaining your changes. Specifically, do not squash or rebase commits after they are visible on the pull request.</li>
<li>At some point, the subsystem maintainer will make a decision on the disposition for the RFC (merge, close, or postpone).
<ul>
<li>This step is taken when enough of the tradeoffs have been discussed that the subsystem maintainer is in a position to make a decision. That does not require consensus amongst all participants in the RFC thread (which is usually impossible). However, the argument supporting the disposition on the RFC needs to have already been clearly articulated, and there should not be a strong consensus against that position.</li>
</ul>
</li>
</ul>
<h2 id="the-rfc-life-cycle"><a class="header" href="#the-rfc-life-cycle">The RFC life-cycle</a></h2>
<p>Once an RFC becomes &quot;active&quot; then authors may implement it and submit the feature as a pull request to the corresponding repository. Being &quot;active&quot; is not a rubber stamp, and in particular still does not mean the feature will ultimately be merged; it does mean that in principle all the major stakeholders have agreed to the feature and are amenable to merging it.</p>
<p>Furthermore, the fact that a given RFC has been accepted and is &quot;active&quot; implies nothing about what priority is assigned to its implementation, nor does it imply anything about whether a developer has been assigned the task of implementing the feature. While it is not necessary that the author of the RFC also write the implementation, it is by far the most effective way to see an RFC through to completion: authors should not expect that other project developers will take on responsibility for implementing their accepted feature.</p>
<p>Modifications to &quot;active&quot; RFCs can be done in follow-up pull requests. We strive to write each RFC in a manner that it will reflect the final design of the feature; but the nature of the process means that we cannot expect every merged RFC to actually reflect what the end result will be at the time of the next major release.</p>
<p>In general, once accepted, RFCs should not be substantially changed. Only very minor changes should be submitted as amendments. More substantial changes should be new RFCs, with a note added to the original RFC. Exactly what counts as a &quot;very minor change&quot; is up to the subsystem maintainers to decide.</p>
<h2 id="reviewing-rfcs"><a class="header" href="#reviewing-rfcs">Reviewing RFCs</a></h2>
<p>While the RFC pull request is up, the subsystem maintainers may schedule meetings with the author and/or relevant stakeholders to discuss the issues in greater detail, and the topic may be discussed at weekly meetings. In either case a summary from the meeting will be posted back to the RFC pull request.</p>
<p>The subsystem maintainer makes final decisions about RFCs after the benefits and drawbacks are well understood. These decisions can be made at any time, but the subsystem maintainer will regularly issue decisions. When a decision is made, the RFC pull request will either be merged or closed. In either case, if the reasoning is not clear from the discussion in thread, the subsystem maintainer will add a comment describing the rationale for the decision.</p>
<h2 id="merging-an-rfc"><a class="header" href="#merging-an-rfc">Merging an RFC</a></h2>
<p>Once the decision is made to merge an RFC, the text must be prepared first. To do this:</p>
<ul>
<li>Update the RFC text to reflect any changes that had to be made to achieve consensus.</li>
<li>Ensure that the &quot;Unresolved questions&quot; section does not have any unanswered questions.</li>
<li>Create a tracking issue in the relevant repository.</li>
<li>Fill in the RFC header fields (start date, RFC PR, tracking issue).</li>
<li>Rename the RFC filename to include the number of the RFC PR instead of <code>0000</code>.
<ul>
<li>This step can be done either as a part of the merge commit in the next step, or by the RFC author right after submitting the PR.</li>
</ul>
</li>
<li>Merge the RFC PR with the commit message &quot;RFC #NNNN: Title of the RFC&quot;.
<ul>
<li>This step can only be done by someone with the write access to the RFC repository.</li>
</ul>
</li>
</ul>
<h2 id="implementing-an-rfc"><a class="header" href="#implementing-an-rfc">Implementing an RFC</a></h2>
<p>Some accepted RFCs represent vital features that need to be implemented right away. Other accepted RFCs can represent features that can wait until some arbitrary developer feels like doing the work. Every accepted RFC has an associated issue tracking its implementation in the corresponding repository.</p>
<p>The author of an RFC is not obligated to implement it. Of course, the RFC author (like any other developer) is welcome to post an implementation for review after the RFC has been accepted.</p>
<p>If you are interested in working on the implementation for an &quot;active&quot; RFC, but cannot determine if someone else is already working on it, feel free to ask (e.g. by leaving a comment on the associated issue).</p>
<h2 id="rfc-postponement"><a class="header" href="#rfc-postponement">RFC Postponement</a></h2>
<p>Some RFC pull requests are tagged with the &quot;postponed&quot; label when they are closed (as part of the rejection process). An RFC closed with &quot;postponed&quot; is marked as such because we want neither to think about evaluating the proposal nor about implementing the described feature until some time in the future, and we believe that we can afford to wait until then to do so. Postponed pull requests may be re-opened when the time is right. We don't have any formal process for that, you should ask the subsystem maintainer.</p>
<p>Usually an RFC pull request marked as &quot;postponed&quot; has already passed an informal first round of evaluation, namely the round of &quot;do we think we would ever possibly consider making this change, as outlined in the RFC pull request, or some semi-obvious variation of it.&quot; (When the answer to the latter question is &quot;no&quot;, then the appropriate response is to close the RFC, not postpone it.)</p>
<h2 id="acknowledgements"><a class="header" href="#acknowledgements">Acknowledgements</a></h2>
<p>The process described in this document is based on the <a href="https://github.com/rust-lang/rfcs">Rust RFC process</a>. It has been simplified to match the needs of the much smaller Amaranth community; in particular, policy (including the RFC process itself) is not currently defined through the RFC process.</p>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>This repository is licensed under the <a href="LICENSE.txt">MIT license</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2023-02-14</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/1">amaranth-lang/rfcs#1</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth/issues/748">amaranth-lang/amaranth#748</a></li>
</ul>
<h1 id="aggregate-data-structure-library"><a class="header" href="#aggregate-data-structure-library">Aggregate data structure library</a></h1>
<blockquote>
<p><strong>Amendments</strong>
The behavior described in this RFC was updated by <a href="0008-aggregate-extensibility.html">RFC #8</a>, <a href="0009-const-init-shape-castable.html">RFC #9</a>, and <a href="0015-lifting-shape-castables.html">RFC #15</a>.</p>
</blockquote>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>Add a rich set of standard library classes for accessing hierarchical aggregate data an idiomatic way, to fill one of the two major use cases of <code>Record</code> while avoiding its downsides.</p>
<p>See also <a href="0002-interfaces.html">RFC #2</a>.</p>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<p>Amaranth has a single data storage primitive: <code>Signal</code>. A <code>Signal</code> can be referenced on the left hand and the right hand side of an assignment, and so can be its slices. Although a signal serves the role of a numeric and bit container type fine, designs often include signals used as bit containers whose individual bits are named and have unique meanings. A mechanism that allows referring to such bit fields by name is essential.</p>
<p>Currently, the role of this mechanism is served by <code>Record</code>. However, <code>Record</code> has multiple major drawbacks:</p>
<ol>
<li>
<p><code>Record</code> attempts to do too much: it is both a mechanism for <em>controlling representation</em> (including implicitly casting a record to a value) and a mechanism for <em>defining interfaces</em> (specifying signal directions and facilitating connections between records).</p>
<p>These mechanisms should be defined separately, since the only aspect they have in common is using a container class that consists of multiple named fields. Conflating the two mechanisms constraints the design space, making addressing the other drawbacks impossible, and the ill-defined scope encourages bugs in downstream code.</p>
</li>
<li>
<p><code>Record</code> has limited composability: records can only be nested within each other. Practical designs (in particular, implementations of protocols) use data with complex representation beyond nested sequences of fields: these include overlaid sequences of fields (where interpretation alternates based on some discriminant) and arrays of fields (where a field can be indexed by a non-constant), where any individual field can have a complex representation itself.</p>
<p><code>Record</code> is structured as a sequence of <code>Signal</code>s, which is a part of its API. As such, it cannot support overlaid fields, and implementing support for arrays of fields is challenging.</p>
</li>
<li>
<p><code>Record</code> has limited introspectability: while its <code>layout</code> member can be accessed to enumerate its fields, the results do not include field boundaries, and the types of the returned shape-castable objects are preserved only as an implementation detail. <code>Layout</code> objects themselves are also not shape-castable.</p>
<p><code>Record</code> and <code>Layout</code> are structured as a sequence of <code>Signal</code>s rather than a view into an underlying bit container, which is reflected in its API. Thus, <code>Layout</code> does not fit into Amaranth's data model, which concerns individual values.</p>
</li>
<li>
<p><code>Record</code> comes with its own storage: while its <code>fields</code> argument can be used to substitute the signals that individual fields are pointing to (in an awkward and error-prone way), it is still a collection of <code>Signal</code>s. Using <code>Record</code> to impose structure on an existing <code>Value</code> requires a <code>Module</code> and a combinatorial assignment. This is an unnecessary complication, especially in helper functions.</p>
</li>
<li>
<p><code>Record</code> does not play well with Python's type annotations. Amaranth developers often inherit from <code>Record</code> as well as <code>Layout</code>, but in both cases the class definition syntax is usually little more than a way to define a callable returning a <code>Record</code> with a specific layout, and provides no benefits for IDE users.</p>
</li>
<li>
<p><code>Record</code> reserves a lot of names, including commonly used names like <code>connect</code>, <code>any</code>, <code>all</code>, and <code>matches</code>. Conversely, it defines a lot of arithmetic methods that are rarely if ever used on field containers.</p>
</li>
<li>
<p><code>Layout</code>'s DSL is very amorphous. It passes around variable length tuples. The second element of these tuples (the shape) can be another <code>Layout</code>, which is neither a shape nor a shape-castable object.</p>
</li>
<li>
<p>Neither <code>Record</code> nor <code>Layout</code> allow defining fields whose shapes are arbitrary <code>ShapeCastable</code> classes.</p>
</li>
</ol>
<p>Since these drawbacks are entrenched in the public API and heavily restrict usefulness of <code>Record</code> as a mechanism for specifying data representation, a new mechanism must replace it.</p>
<h2 id="overview-and-examples"><a class="header" href="#overview-and-examples">Overview and examples</a></h2>
<p>This section shows a bird's eye view of the new syntax and behavior proposed in this RFC. The detailed design is described afterwards.</p>
<pre><code class="language-python">from amaranth import *
from amaranth.lib import data


# Declaring a simple structure:
class Float32(data.Struct):
    fraction: unsigned(23)
    exponent: unsigned(8)
    sign: unsigned(1)


# Defining a signal with the structure above:
flt_a = Float32()

# Reinterpreting an existing value with the same structure:
flt_b = Float32(Const(0b00111110001000000000000000000000, 32))

# Referencing and updating structure fields by name:
with m.If(flt_b.fraction &gt; 0):
    m.d.comb += [
        flt_a.sign.eq(1),
        flt_a.exponent.eq(127)
    ]


# Declaring a simple union, referencing an existing structure:
class FloatOrInt32(data.Union):
    float: Float32
    int: signed(32)


# Using the union to bitcast an IEEE754 value from an integer:
f_or_i = FloatOrInt32()
is_sub_1 = Signal()
m.d.comb += [
    f_or_i.int.eq(0x41C80000),
    is_sub_1.eq(f_or_i.float.exponent &lt; 127) # =&gt; 1
]


class Op(enum.Enum):
  ADD = 0
  SUB = 1


# Programmatically declaring a structure layout:
adder_op_layout = data.StructLayout({
    &quot;op&quot;: Op,
    &quot;a&quot;: Float32,
    &quot;b&quot;: Float32
})

# Using the layout defined above to define appropriately sized storage...
adder_op_storage = Signal(adder_op_layout)
len(adder_op_storage) # =&gt; 65

# ... and wrap it for the fields to be accessible.
adder_op = data.View(adder_op_layout, adder_op_storage)
m.d.comb += [
    adder_op.op.eq(Op.SUB),
    adder_op.a.eq(flt_a),
    adder_op.b.eq(flt_b)
]
</code></pre>
<h2 id="detailed-design"><a class="header" href="#detailed-design">Detailed design</a></h2>
<p>This RFC proposes a number of language and library additions:</p>
<ul>
<li>Adding a <code>ShapeCastable</code> interface, similar to <code>ValueCastable</code>;</li>
<li>Adding classes that hierarchically describe representation of aggregate values: named field containers with non-overlapping fields (structs), named field containers with overlapping fields (unions), and indexed field containers (arrays);</li>
<li>Adding a wrapper class that accepts a <code>Value</code> (or a <code>ValueCastable</code> object) and provides accessors that slice it according to the corresponding aggregate representation;</li>
<li>Adding an ergonomic and IDE-compatible interface for building descriptions of non-parametric layouts of aggregate values.</li>
</ul>
<h3 id="user-defined-shape-castable-objects"><a class="header" href="#user-defined-shape-castable-objects">User-defined shape-castable objects</a></h3>
<p><code>ShapeCastable</code> is an interface for defining <code>Shape</code>-like values outside of the core Amaranth language. It is functionally identical to <code>ValueCastable</code>, and could be used like:</p>
<pre><code class="language-python">from amaranth import *


class Layout(ShapeCastable):
    def __init__(self, fields):
        self.fields = fields

    def as_shape(self):
        return unsigned(sum(len(field) for field in self.fields))
</code></pre>
<h3 id="value-layout-descriptions"><a class="header" href="#value-layout-descriptions">Value layout descriptions</a></h3>
<p>Aggregate value layouts are represented using two classes: <code>amaranth.lib.data.Field</code> and <code>amaranth.lib.data.Layout</code>:</p>
<ul>
<li>A <code>Field(shape_castable, offset=0)</code> object describes a field of the given shape starting at bit number <code>offset</code> of the aggregate value.</li>
<li>A <code>Layout()</code> object describes an abstract aggregate value. It can be iterated, returning <code>(name, field)</code> or <code>(index, field)</code> pairs; or indexed (<code>__getitem__</code>) by the name or index of the field. It has a <code>.size</code> in bits, determined by the type of the layout, and is shape-castable, being converted to <code>unsigned(layout.size())</code>.
<ul>
<li>A <code>StructLayout(members={&quot;name&quot;: shape_castable})</code> object describes an aggregate value with non-overlapping named fields (struct). The fields are placed at offsets such that they immediately follow one another, from least significant to most significant.</li>
<li>A <code>UnionLayout(members={&quot;name&quot;: shape_castable})</code> object describes an aggregate value with overlapping named fields (union). The fields are placed at offset 0.</li>
<li>An <code>ArrayLayout(element=shape_castable, length=1)</code> object describes an aggregate value with indexed fields (array). The fields all have identical shape and are placed at offsets such that they immediately follow one another, from least significant to most significant.</li>
<li>A <code>FlexibleLayout(fields={&quot;name&quot;: field, 0: field}, size=16)</code> object describes a aggregate value with fields arbitrarily placed within its bounds.</li>
</ul>
</li>
</ul>
<p>The representation of a discriminated union could be programmatically constructed as follows:</p>
<pre><code class="language-python">import enum
from amaranth.lib import data


class Kind(enum.Enum):
    ONE_SIGNED = 0
    TWO_UNSIGNED = 1


layout = data.StructLayout({
    &quot;kind&quot;: Kind,
    &quot;value&quot;: data.UnionLayout({
        &quot;one_signed&quot;: signed(2),
        &quot;two_unsigned&quot;: data.ArrayLayout(unsigned(1), 2)
    })
})
</code></pre>
<h3 id="aggregate-value-access"><a class="header" href="#aggregate-value-access">Aggregate value access</a></h3>
<p>Aggregate values are manipulated through the <code>amaranth.lib.data.View</code> class. A <code>View(layout, value_castable)</code> object wraps a value-castable object (which may be a valid assignment target) and provides access to fields according to the layout. A view is itself value-castable, being converted to the object it's wrapping. If the view is wrapping a valid assignment target, then the accessors also return a valid assignment target.</p>
<p>Fields can be accessed using either <code>__getitem__</code> (for both named and indexed fields) or <code>__getattr__</code> (for named fields). To avoid name collisions when using <code>__getattr__</code> to access fields, views do not define any non-reserved attributes of their own except for the <code>.as_value()</code> casting method. Field names starting with <code>_</code> are reserved as attribute names and and can only be accessed using the <code>view[&quot;name&quot;]</code> indexing syntax.</p>
<p>When a view is used to access a field whose shape is an ordinary <code>Shape</code> object, the accessor returns a <code>Value</code> of the corresponding shape that slices the viewed object.</p>
<p>When a view is used to access a field whose shape is an aggregate value layout, the accessor returns another <code>View</code> with this layout, wrapping the slice of the viewed object. For fields that have any other shape-castable object set as their shape, the behavior is the same as for the <code>Shape</code> case.</p>
<p>Views that have an <code>ArrayLayout</code> as their layout can be indexed with a <code>Value</code>. In this case, the viewed object is sliced with <code>Value.word_select</code>.</p>
<p>A signal can be manipulated with its structure viewed as the discriminated union defined above as follows:</p>
<pre><code class="language-python"># creates an unsigned(3) signal by shape-casting `layout`
sig = Signal(layout)
view = data.View(layout, sig)

# if the second argument is omitted, a signal with the right shape is created internally;
# the line below is equivlent to the two lines above
view = data.View(layout)

m = Module()
m.d.comb += [
    view.kind.eq(Kind.TWO_UNSIGNED),
    view.value.two_unsigned[0].eq(1),
]
</code></pre>
<h3 id="ergonomic-layout-definition"><a class="header" href="#ergonomic-layout-definition">Ergonomic layout definition</a></h3>
<p>Rather than using the underlying <code>StructLayout</code> and <code>UnionLayout</code> classes, struct and union layouts can be defined using the Python class definition syntax, with the shapes of the members specified using the <a href="https://peps.python.org/pep-0526/">PEP 526</a> variable annotations:</p>
<pre><code class="language-python">class SomeVariant(data.Struct):
    class Value(data.Union):
        one_signed: signed(2)
        two_unsigned: data.ArrayLayout(unsigned(1), 2)

    kind: Kind
    value: Value


# this class can be used in the same way as a `data.View` without needing to specify the layout:
view2 = SomeVariant()
m.d.comb += [
    view2.kind.eq(Kind.ONE_SIGNED),
    view2.value.eq(view.value)
]
</code></pre>
<p>When they refer to other structures or unions defined in the same way, the variable annotations are also valid <a href="https://peps.python.org/pep-0484/">PEP 484</a> type hints, and will be used by IDEs to derive types of properties and expressions. Otherwise, the annotations will be opaque to IDEs or type checkers, but are still useful for a human reader.</p>
<p>The classes defined in this way are shape-castable and can be used anywhere a shape or a aggregate value layout is accepted:</p>
<pre><code class="language-python">sig2 = Signal(SomeVariant)
layout2 = data.StructLayout({
    &quot;ready&quot;: unsigned(1),
    &quot;payload&quot;: SomeVariant
})
</code></pre>
<p><strong>Implementation note:</strong> This can be achieved by using a custom metaclass for <code>Struct</code> and <code>Union</code> that inherits from <code>ShapeCastable</code>.</p>
<p>If an explicit <code>Layout</code> object is nevertheless needed (e.g. for introspection), it can be extracted from the class using <code>Layout.cast</code>:</p>
<pre><code class="language-python">layout == data.Layout.cast(SomeVariant) # =&gt; True
</code></pre>
<p>Conversely, the shape-castable object defining the layout of a <code>View</code> (which might be a <code>Layout</code> subclass or a <code>Struct</code>/<code>Union</code> subclass) can be extracted from the view using <code>Layout.of</code>:</p>
<pre><code class="language-python">SomeVariant is data.Layout.of(view2) # =&gt; True
</code></pre>
<h3 id="advanced-usage-parametric-layouts"><a class="header" href="#advanced-usage-parametric-layouts">Advanced usage: Parametric layouts</a></h3>
<p>The ergonomic definitions using the <code>Struct</code> and <code>Union</code> base classes are concise and integrated with Python type annotations. However, they cannot be used if the layout of an aggregate value is parameterized. In this case, a class with similar functionality can be defined in a more explicit way:</p>
<pre><code class="language-python">class Stream8b10b(data.View):
    data: Signal
    ctrl: Signal

    def __init__(self, value=None, *, width: int):
        super().__init__(data.StructLayout({
            &quot;data&quot;: unsigned(8 * width),
            &quot;ctrl&quot;: unsigned(width)
        }), value)


len(Stream8b10b(width=1).data) # =&gt; 8
len(Stream8b10b(width=4).data) # =&gt; 32
</code></pre>
<p>Since the parametric class name itself does not have a fixed layout, it cannot be used with <code>Layout.cast</code>. Similarly, the type annotations cannot include specific field widths; they are included only to indicate the presence of a corresponding attribute to IDEs and type checkers.</p>
<h3 id="structure-field-ordering"><a class="header" href="#structure-field-ordering">Structure field ordering</a></h3>
<p>The fields of a structure layout object are ordered from least significant to most significant:</p>
<pre><code class="language-python">float32_layout = data.StructLayout({
    &quot;fraction&quot;: unsigned(23),   # bits  0..22
    &quot;exponent&quot;: unsigned(8),    # bits 23..30
    &quot;sign&quot;: unsigned(1)         # bit  31
})

class Float32(data.Struct):
    fraction: unsigned(23)      # bits  0..22
    exponent: unsigned(8)       # bits 23..30
    sign: unsigned(1)           # bit  31
</code></pre>
<p>In other words, the following identity holds:</p>
<pre><code class="language-python">float32_storage = Signal(float32_layout)
float32 = data.View(float32_layout, float32_storage)

float32_storage == Cat(float32.fraction, float32_layout.exponent, float32.sign)
</code></pre>
<h3 id="customizing-the-automatically-created-signal"><a class="header" href="#customizing-the-automatically-created-signal">Customizing the automatically created <code>Signal</code></a></h3>
<p>When a view is instantiated without an explicit view target, it creates a <code>Signal</code> with a shape matching the view layout. The <code>View</code> constructor accepts all of the <code>Signal</code> constructor keyword arguments and passes them along; the <code>reset=</code> argument accepts a struct or an array (according to the type of the layout):</p>
<pre><code class="language-python">flt_neg_reset = data.View(float32_layout, reset={&quot;sign&quot;: 1})

flt_reset_less = Float32(reset_less=True)
</code></pre>
<h2 id="drawbacks"><a class="header" href="#drawbacks">Drawbacks</a></h2>
<p>This feature introduces a language-level concept, shape-castable objects, increasing language complexity.</p>
<p>This feature introduces a finely grained hierarchy of 5 similar and related classes for describing layouts.</p>
<h2 id="alternatives"><a class="header" href="#alternatives">Alternatives</a></h2>
<p>Do nothing. <code>Record</code> will continue to be used alongside the continued proliferation of ad-hoc implementations of similar functionality.</p>
<p>Remove <code>ArrayLayout</code> from this proposal. The array functionality is niche and introduces the complexity of handling by-index accessors alongside by-name ones.</p>
<p>Remove <code>ArrayLayout</code>, <code>UnionLayout</code>, and <code>FlexibleLayout</code> from this proposal. Their functionality is less commonly used than that of <code>StructLayout</code> and introduces the substantial complexity of handling fields at arbitrary offsets. (This would make <code>amaranth.lib.data</code> useless for slicing CSRs in Amaranth SoC.) This change would bring this proposal close to the original <code>PackedStruct</code> proposal discussed in https://github.com/amaranth-lang/amaranth/issues/342.</p>
<p>Combine the <code>Layout</code> and all of its derivative classes into a single <code>Layout(fields={&quot;name&quot;: Field(...), 0: Field(...)})</code> class that provides a superset of the functionality. This simplifies the API, but makes introspection of aggregate layouts very difficult and can be inefficient if large arrays are used. In this case, factory methods of the <code>Layout</code> class would be provided for more convenient construction of regular struct, union, and array layouts.</p>
<p>Remove <code>Struct</code> and <code>Union</code> annotation-driven definition syntax. This makes the API simpler, less redundant, and with fewer corner cases, also avoiding the use of variable annotations that are not valid PEP 484 type hints, at the cost of a continued jarring experience for IDE users.</p>
<p>Include a more concise and less visually noisy way to build <code>StructLayout</code> and <code>UnionLayout</code> objects (or their equivalents) using a builder pattern. This may make the syntax slightly nicer, though the RFC author could not come up with anything that would actually be such.</p>
<h2 id="bikeshedding"><a class="header" href="#bikeshedding">Bikeshedding</a></h2>
<p>The names of the <code>Field</code>, <code>*Layout</code>, and <code>View</code> classes could be changed to something better.</p>
<ul>
<li><code>IrregularLayout</code> was renamed to <code>FlexibleLayout</code>.</li>
</ul>
<h2 id="future-work"><a class="header" href="#future-work">Future work</a></h2>
<p>This feature could be improved in several ways that are not in scope of this RFC:</p>
<ul>
<li><code>StructLayout</code>, <code>UnionLayout</code>, and <code>ArrayLayout</code> could be extended to generate layouts with padding at the end (for structs and unions) or between elements (for arrays). Currently this requires the use of a <code>FlexibleLayout</code>.</li>
<li><code>StructLayout</code> could be extended to accept a list of fields in addition to a map of field names to values. In this case, it would represent an aggregate value with non-overlapping indexed fields (tuple).</li>
<li><code>Struct</code> and/or <code>StructLayout</code> could be extended to treat certain reserved field names (e.g. <code>&quot;_1&quot;</code>, <code>&quot;_2&quot;</code>, ...) as designating padding bits. In this case, the offset of the following fields would be adjusted, and the fields with such names would not appear in the layout.</li>
<li><code>Struct</code> and/or <code>StructLayout</code> could be extended to treat certain reserved field names (e.g. <code>&quot;_&quot;</code> for <code>Struct</code> and <code>None</code> for <code>StructLayout</code>) as designating an anonymous inner aggregate. In this case, the members of the anonymous inner aggregate would be possible to access as if they were the members of the outer aggregate.</li>
<li>The automatic wrapping of accessed aggregate fields done by <code>View</code> could be extended to call a user-specified cast function rather than hard-coding a check for whether the shape is a <code>Layout</code>. This would allow seamless inclusion of user-defined value-castable types in aggregates.</li>
<li>The <a href="https://peps.python.org/pep-0484/">PEP 484</a> generics could be used to define layouts parametric over field shapes, using type annotations alone. Since Python does not have type-level integers, layouts parametric over field sizes would still need to be defined explicitly.</li>
<li>The struct, union, and enum support could be used as the building blocks to implement first-class discriminated unions. Discriminated unions will also benefit from tuples, described above. (<a href="https://github.com/amaranth-lang/amaranth/issues/693#issuecomment-1089322514">Suggestion</a> by @lachlansneff.)</li>
</ul>
<h2 id="acknowledgements-1"><a class="header" href="#acknowledgements-1">Acknowledgements</a></h2>
<p><a href="https://github.com/modwizcode">@modwizcode</a>, <a href="https://github.com/Kaucasus">@Kaucasus</a>, and <a href="https://github.com/lachlansneff">@lachlansneff</a> provided valuable feedback while this RFC was being drafted.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2023-08-22</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/2">amaranth-lang/rfcs#2</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth/issues/872">amaranth-lang/amaranth#872</a></li>
</ul>
<h1 id="interface-definition-library-rfc"><a class="header" href="#interface-definition-library-rfc">Interface definition library RFC</a></h1>
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<p>Add standard ways of declaring that a component of a design conforms to a particular interface and connecting components with complementary interfaces together, to fill the other of the two major use cases of <code>Record</code> while avoiding its downsides.</p>
<p>See also <a href="0001-aggregate-data-structures.html">RFC #1</a>.</p>
<h2 id="motivation-1"><a class="header" href="#motivation-1">Motivation</a></h2>
<p>Digital designs are composed of densely packed components that communicate with each other using well-defined interfaces. Mechanisms to denote the boundary of a component, to ensure that a component complies to a specified interface, and to make reliable connections between components are essential.</p>
<p>Currently, Amaranth provides none of these mechanisms. A component implemented in Amaranth, however well-defined conceptually, has no more external structure than a loose collection of <code>Signal</code>s assigned to its attributes; and whether any one of them is a part of the interface or the implementation is up to a guess. Even when an interface is described using <code>amaranth.hdl.rec.Layout</code>, such a description cannot be used to verify even the simplest aspects of compliance, such as presence of fields. Although building components by composing smaller components together is ubiquitous, <code>amaranth.hdl.rec.Layout</code> is not able to compose their interface with the same ease. Connecting components using <code>amaranth.hdl.rec.Record.connect</code> is difficult enough that it sees very little use.</p>
<p>Originally, <code>Record</code> was aimed at solving many of these issues. However, it has multiple major drawbacks:</p>
<ol>
<li>
<p><code>Record</code> attempts to do too much: it is both a mechanism for <em>controlling representation</em> (including implicitly casting a record to a value) and a mechanism for <em>defining interfaces</em> (specifying signal directions and facilitating connections between records).</p>
<p>These mechanisms should be defined separately, since the only aspect they have in common is using a container class that consists of multiple named fields. Conflating the two mechanisms constraints the design space, making addressing the other drawbacks impossible, and the ill-defined scope encourages bugs in downstream code.</p>
</li>
<li>
<p><code>Record</code>'s model of signal directions is too complex. Because it attempts to model both aggregates with controlled representation and interfaces with defined directionality, every signal can have one of the three directions, the third option being non-directed. While this can be applied in a robust way--<a href="https://github.com/chipsalliance/firrtl-spec/releases/latest/download/spec.pdf">FIRRTL</a> has only one aggregate type that it uses for both purposes--this gives rise to a large combination of features and requires handling many edge cases.</p>
</li>
<li>
<p><code>Record</code>'s model of signal directions is too limited. The two static directionalities it has are the confusingly named &quot;fanout&quot; and &quot;fanin&quot;, which really mean &quot;from initiator to target&quot; and &quot;from target to initiator&quot;. This is insufficient to describe common, straightforward interactions such as two components exchanging streams of data across pairs of identical, complementary endpoints.</p>
</li>
<li>
<p><code>Record</code>s are hard to customize. Records create and hold their signals, only providing the caller with an ability to place caller-created signals into individual fields. Signals often need adjustments: primarily setting a reset value or adding a decoder, but sometimes adding attributes or renaming. These adjustments must be performed at the record creation site, which is burdensome.</p>
</li>
<li>
<p><code>Record</code> fields can be (apart from sub-records) only plain signals. In many cases, an interface between components carries structured data rather than opaque bit vectors. It is not possible to define inner structure for record fields other than through a sub-record, and using a sub-record for this means that an application-specific endpoint that defines such structure cannot be connected to a generic endpoint that does not.</p>
</li>
<li>
<p><code>Record</code>s are hard to compose. The natural way to define a record is to call the <code>Record</code> constructor with a layout, but this creates the entire layout hierarchy unless parts of it are replaced; and it requires having the layout of the result in advance.</p>
</li>
<li>
<p><code>Record.connect</code> determines the direction of data flow that it will create by the relative position of the interfaces being connected, with <code>x.connect(y)</code> and <code>y.connect(x)</code> having the oposite polarity of assignments. However, the direction of data flow is defined by the component that exposes the interface. Thus, every call of <code>Record.connect</code> can be done in one of the two very similar ways, one of which is always wrong.</p>
</li>
<li>
<p><code>Record.connect</code> uses wired-OR to gather the &quot;fanin&quot; signals, a feature that exists so that it could be used to connect e.g. Wishbone endpoints together without additional gateware. The assumption that the response signals of inactive endpoints will remain all-zero is, generally, unsound.</p>
</li>
<li>
<p><code>Record.connect</code> manages connections between interfaces with optional signals at the call site using an include/exclude mechanism. However, the semantics of the non-implemented optional signals are a property of the interface, not the connection.</p>
</li>
<li>
<p><code>Record</code> and <code>rec.Layout</code> are often used as base classes. The <code>Record.like</code> facility, frequently used because of the poor ergonomics of <code>rec.Layout</code>, loses this information and returns an instance of the base class; <code>rec.Layout</code> does the same when indexed. As a result, there is little value in defining methods and attributes on the subclass, and <code>Record</code> subclasses are little more than a callable computing a layout.</p>
</li>
<li>
<p>Due to the limitations of <code>Record</code>, one might define a plain Python class that exposes compatible attributes. An instance of such a class cannot be compared to a known <code>rec.Layout</code> nor can it be embedded in another <code>Record</code>.</p>
</li>
<li>
<p><code>Record</code> is value-castable and implements the <code>.eq()</code> protocol. Although useful when all fields are non-directional, using <code>.eq()</code> instead of <code>.connect()</code> when connecting directional interfaces is, generally, unsound. It also reserves commonly used names such as <code>any</code>, <code>all</code>, and <code>matches</code>, and implements arithmetic operations that are rarely if ever used on field containers.</p>
</li>
<li>
<p><code>rec.Layout</code>'s DSL is very amorphous. It passes around variable length tuples. The second element of these tuples (the shape) can be another <code>rec.Layout</code>, which is neither a shape nor a shape-castable object.</p>
</li>
</ol>
<p>Since these drawbacks are entrenched in the public API and make <code>Record</code> nearly useless for defining interfaces, a new mechanism must replace it.</p>
<h2 id="outline-of-the-design-space"><a class="header" href="#outline-of-the-design-space">Outline of the design space</a></h2>
<p>Although some HDLs and IRs (Migen, Chisel, FIRRTL, ...) choose to use the same basic aggregate data type to represent <em>structured data</em> and <em>directional interfaces</em>, these mechanisms are in direct conflict. Complex forms of structured data, such as unions, are incompatible with associating directionality independently with every leaf member; and the non-directional nature of stored data requires complicated and error-prone rules when it can become a part of a directional connection.</p>
<p>Amaranth, instead, opts to include two superficially similar mechanisms for defining and accessing hierarchical aggregate data: <code>amaranth.lib.data</code> (RFC #1) and <code>amaranth.lib.wiring</code> (this RFC). <code>amaranth.lib.data</code> provides <em>data views</em> that reinterpret bit containers as complex aggregates, and entirely avoids directionality. <code>amaranth.lib.wiring</code> provides <em>signatures</em> that give a concrete shape to signals at component boundaries, and always treats them as directional.</p>
<p>When connections are made strictly between an output and a correspondingly named input, interfaces gain a dualistic nature: every connection is made between two interfaces whose port directions are the inverse of each other, and which are identical otherwise. To describe interfaces without repeating oneself, then, one has to pick an arbitrarily preferred directionality (and stick with it). Many interfaces are asymmetric, with data flowing from a source to a sink, or transactions issued from an initiator to a target. Amaranth picks the <em>source</em> or <em>initiator</em> perspective; an interface, examined in isolation, defines as outputs the signals that would be outputs of an initiator (and inputs of a target). Then, when an interface with true (non-flipped) directionality describes a component's output, the same interface with inverse (flipped) directionality symmetrically describes an input.</p>
<p>To eliminate the major usability issues with <code>Record.connect</code>, the interface connection mechanism assigns no precedence to interfaces and has no effect on signal directionality; whether a signal is an input or an output depends only on the interface itself. A connection is only made from an output to a matching input, and any other combination is rejected with a diagnostic. This way, connecting a pair of interfaces always leads to the same outcome, regardless of their order.</p>
<p>The choice to always treat interface signals as directional and to make their directionality dependent only on the interface itself leaves only one aspect of the design open: when and how interface directionality is flipped. The decisions that determine it affect both ergonomics and soundness. <code>Record.connect</code> in effect gives the programmer an option to flip directionality even when it would create an illegal connection. Conversely, <code>rec.Layout</code> provides no such affordance, even though it is necessary for composing components.</p>
<p>To facilitate composing components, the interface's directionality is flipped when it is used as an input, whether a top-level input of a component, or as a constituent of a larger interface. This way, the existing mechanism of annotating the directionality of an interface signal or a module port transparently handles interface composition.</p>
<h2 id="guide-level-explanation"><a class="header" href="#guide-level-explanation">Guide-level explanation</a></h2>
<p>Amaranth designs are made out of components (Python classes implementing <code>Elaboratable</code>) whose attributes include signals. These signals have directions: &quot;in&quot; signals are sampled by the component, while &quot;out&quot; signals are driven by it, or left at their reset value, and are provided to be sampled by other components.</p>
<p>At the moment, these directions are completely informal, and described in the documentation and/or in the signal name as an <code>i_</code> or <code>o_</code> prefix (to make it clearer what the direction is at the point of use, or to disambiguate the ports that would otherwise have identical name):</p>
<pre><code class="language-python">class SequenceSource(Elaboratable):
    &quot;&quot;&quot;
    Ports
    -----
    data : Signal(width), out
    ready : Signal(1), in
    valid : Signal(1), out
    &quot;&quot;&quot;
    def __init__(self, width=16):
        self.data = Signal(width)
        self.ready = Signal()
        self.valid = Signal(reset=1)

    def elaborate(self, platform):
        m = Module()
        with m.If(self.ready):
            m.d.sync += self.data.eq(self.data + 1)
        return m
</code></pre>
<p>The <code>SequenceSource</code> component is implemented as a simple counter producing values for an <em>output stream</em> that is connected to some other component consuming them. On each clock tick, if the consumer is <em>ready</em>, it samples the <em>data</em> (the counter value), and simultaneously with that, the producer advances the data to the next item (the incremented value). Since there is always a next item available and it is ready for consumption on the next clock cycle, the stream always contains <em>valid</em> results.</p>
<blockquote>
<p><strong>Note</strong>
It is not, in general, possible to infer the directions of the signals from the implementation‚Äîhere, <code>ready</code> and <code>valid</code> have different directions and different intended uses, but they look similar to the Amaranth implementation since they are both undriven in the component.</p>
</blockquote>
<p>This RFC proposes a way of describing signal directions that can be applied to any Python object. In addition to elaboratables, it includes Python objects that are used to group together signals with a similar purpose, such as those that are parts of a bus.</p>
<p>To describe signal directions, only a single addition is needed: the <code>signature</code> property:</p>
<pre><code class="language-python">from amaranth.lib.wiring import Signature, In, Out


class SequenceSource(Elaboratable):
    ...

    signature = Signature({
        &quot;data&quot;: Out(16),
        &quot;ready&quot;: In(1),
        &quot;valid&quot;: Out(1)
    })
</code></pre>
<p>Consider another component that is consuming these values:</p>
<pre><code class="language-python">class NumberSink(Elaboratable):
    ...

    def elaborate(self):
        m = Module()
        processing = Signal()
        m.d.comb += self.ready.eq(~processing)
        with m.If(self.valid &amp; ~processing):
            m.d.sync += processing.eq(1)
        with m.Elif(processing):
            ... # process it somehow

    signature = Signature({
        &quot;data&quot;: In(16),
        &quot;ready&quot;: Out(1),
        &quot;valid&quot;: In(1)
    })
</code></pre>
<p>Currently, the only way (given the tools provided by the language and the standard library) to connect the <em>output stream</em> of the <code>SequenceSource</code> to the <em>input stream</em> of the <code>NumberSink</code> is to do this signal-wise:</p>
<pre><code class="language-python">m = Module()
m.submodules.source = source = SequenceSource()
m.submodules.sink = sink = NumberSink()
m.d.comb += [
    sink.data.eq(source.data),
    source.ready.eq(sink.ready),
    sink.valid.eq(source.valid)
]
</code></pre>
<p>This is tedious, verbose, and error-prone. It is possible to define an application-specific function abstracting this operation, and many applications do, but something this universal should be defined on the language level.</p>
<p>This RFC introduces a way to describe interfaces (collections of directional signals; more on this later) and a single operation: <em>connecting</em>. The code above now transforms into:</p>
<pre><code class="language-python">from amaranth.lib.wiring import connect


m = Module()
m.submodules.source = source = SequenceSource()
m.submodules.sink = sink = NumberSink()
connect(m, sink, source)
</code></pre>
<p>The order of arguments to <code>connect</code> does not matter as the directionality is defined by the components themselves. It could just as well be written as:</p>
<pre><code class="language-python">connect(m, source, sink)
</code></pre>
<p>However, this approach still has flaws. Most importantly, the signature for <code>SequenceSource</code> and <code>NumberSink</code> is written twice, but their <code>signature</code> is exactly the same except that the direction is flipped: <code>In</code> members become <code>Out</code>, and vice versa. To avoid error-prone repetition here, the signature can be defined once:</p>
<pre><code class="language-python">Stream16BitSignature = Signature({
    &quot;data&quot;: Out(16),
    &quot;ready&quot;: In(1),
    &quot;valid&quot;: Out(1)
})
</code></pre>
<p>and then used twice, for both the source and the sink:</p>
<pre><code class="language-python">class SequenceSource(Elaboratable):
    ...

    signature = Stream16BitSignature

class NumberSink(Elaboratable):
    ...

    signature = Stream16BitSignature.flip()
</code></pre>
<p>The <code>Signature.flip()</code> method returns a <em>flipped signature object</em>: a signature object whose members have inverse direction but which is otherwise identical.</p>
<p>Since this approach has reusable signatures defined with a specific direction, it is necessary to make an arbitrary choice: pick the kind of object whose signature will use the non-flipped directions. This RFC picks the object that is the <em>source of data</em> (for stream-like interfaces), the <em>transaction initiator</em> (for bus-like interfaces), and so on to use non-flipped directions by convention.</p>
<p>Although some duplication was eliminated, some more remains: currently, it is necessary to define a stream signature for every kind of stream (a stream of 16-bit values, a stream of RGB colors, and so on). It is possible to define a reusable stream signature by inheriting from the <code>Signature</code> class:</p>
<pre><code class="language-python">class StreamSignature(Signature):
    def __init__(self, payload_shape):
        super().__init__({
            &quot;payload&quot;: Out(payload_shape),
            &quot;ready&quot;: In(1),
            &quot;valid&quot;: Out(1)
        })
</code></pre>
<p>The elaboratables above can then be defined as:</p>
<pre><code class="language-python">class SequenceSource(Elaboratable):
    ...

    signature = StreamSignature(16)

class NumberSink(Elaboratable):
    ...

    signature = StreamSignature(16).flip()
</code></pre>
<p>Usually, elaboratables have more than one interface. For example, a very simple DSP block could sink a stream of signed numbers, take their absolute value, and source a stream of unsigned numbers. It would then have a pair of <code>ready</code>, <code>valid</code>, and <code>payload</code> signals each: one for the input steam, and another for the output stream.</p>
<p>To handle this case, signature's members can be signatures themselves. These members also have directionality; an <code>Out</code> signature leaves the directionality of its members unchanged, while an <code>In</code> signature flips it. The signature method of the processing block could be defined as:</p>
<pre><code class="language-python">class AbsoluteProcessor(Elaboratable):
    ...

    signature = Signature({
        &quot;i&quot;: In(StreamSignature(signed(16))),
        &quot;o&quot;: Out(StreamSignature(unsigned(16)))
    })
</code></pre>
<p>To be compliant with this signature, an <code>AbsoluteProcessor</code> instance must have an <code>i</code> attribute compliant with a <code>StreamSignature(signed(16)).flip()</code>, and an <code>o</code> attribute compliant with a <code>StreamSignature(unsigned(16))</code>. These could be defined manually:</p>
<pre><code class="language-python">class AbsoluteProcessor(Elaboratable):
    def __init__(self):
        self.i = object()
        self.i.payload = Signal(signed(16))
        self.i.ready = Signal()
        self.i.valid = Signal()
        self.i.signature = StreamSignature(signed(16)).flip()

        self.o = object()
        self.o.payload = Signal(unsigned(16))
        self.o.ready = Signal()
        self.o.valid = Signal()
        self.o.signature = StreamSignature(unsigned(16))

    ...
</code></pre>
<p>Once more, to reduce error-prone repetition, the <code>Signature</code> class offers a way to define objects just like the ones created above, making the complete definition be:</p>
<pre><code class="language-python">class AbsoluteProcessor(Elaboratable):
    def __init__(self):
        self.i = StreamSignature(signed(16)).flip().create()
        self.o = StreamSignature(unsigned(16)).create()

    signature = Signature({
        &quot;i&quot;: In(StreamSignature(signed(16))),
        &quot;o&quot;: Out(StreamSignature(unsigned(16)))
    })

    ...
</code></pre>
<p><code>Signature</code> subclasses can also override the <code>create</code> method to add functionality not present in the base class. For example, a signature for a bus such as Wishbone or AXI could return an instance of a class rather than a simple <code>object()</code>, and include attributes indicating which optional features of the bus are enabled.</p>
<p>However, since the interface of <code>AbsoluteProcessor</code> as a whole can itself be described as a signature, it is possible to further shorten it by deriving from <code>component.Component</code> instead of <code>Elaboratable</code>, in which case the attributes will be filled in from the signature automatically:</p>
<pre><code class="language-python">from amaranth.lib.wiring import Component


class AbsoluteProcessor(Component):
    signature = Signature({
        &quot;i&quot;: In(StreamSignature(signed(16))),
        &quot;o&quot;: Out(StreamSignature(unsigned(16)))
    })

    def elaborate(self):
        m = Module()
        with m.If(self.i.payload &gt; 0):
            m.d.comb += self.o.payload.eq(self.i.payload)
        with m.Else():
            # Does not overflow, since -(-32768) [least signed(16)] is less
            # than 65536 [greatest unsigned(16)].
            m.d.comb += self.o.payload.eq(-self.i.payload)
        return m
</code></pre>
<p>Python variable annotations can also be used in cases like the above, where the signature is the same for every instance of the class (i.e. the component is not parameterized during creation):</p>
<pre><code class="language-python">class AbsoluteProcessor(Component):
    i: In(StreamSignature(signed(16)))
    o: Out(StreamSignature(unsigned(16)))

    def elaborate(self):
        m = Module()
        with m.If(self.i.payload &gt; 0):
            m.d.comb += self.o.payload.eq(self.i.payload)
        with m.Else():
            # Does not overflow, since -(-32768) [least signed(16)] is less
            # than 65536 [greatest unsigned(16)].
            m.d.comb += self.o.payload.eq(-self.i.payload)
        return m
</code></pre>
<p>All of the import statements in the code examples above can be replaced with:</p>
<pre><code class="language-python">from amaranth.lib.wiring import *
</code></pre>
<h2 id="reference-level-explanation"><a class="header" href="#reference-level-explanation">Reference-level explanation</a></h2>
<p>This RFC proposes a number of library additions:</p>
<ul>
<li>Adding classes that describe a hierarchy of Amaranth objects (an elaboratable object and the objects containing its interface signals) and ease instantiating such hierarchies.</li>
<li>Adding a function that connects such hierarchies to each other.</li>
</ul>
<p>It also introduces a number of technical terms:</p>
<ul>
<li>A <em>component</em> is an Amaranth elaboratable object.</li>
<li>An <em>interface</em> (a concept) is a shared boundary across which several Amaranth components exchange data. It is comprised of a set of signals and the invairants that govern their use.</li>
<li>An <em>interface object</em> (an implementation of the concept) a Python object that includes:
<ol>
<li>attributes whose value is an Amaranth value-castable, or another interface;</li>
<li>a <code>signature</code> attribute whose value is a <em>signature</em> that is <em>compliant</em> with this object;</li>
<li>a description of the invariants applying to its use (in form of documentation, testbenches, formal tests, etc.).</li>
</ol>
</li>
<li>A <em>signature</em> is a <code>Signature</code> instance describing requirements applicable to a hierarchy of interace objects.</li>
<li>A <em>signature member</em> is a <code>Member</code> instance describing requirements applicable to a single attribute of an interface object. Two kinds of signature members exist: port members (requiring the value of the attribute to be a <code>Signal</code>), and interface members (requiring the value of the attribute to be another interface object).</li>
<li>An object is <em>compliant</em> with a signature (therefore making it an interface object) if every member of the signature corresponds to an attribute of the object whose value fits the requirements.</li>
</ul>
<p>A single elaboratable object will often have several interfaces; e.g. a peripheral can have a CSR and/or Wishbone bus interface, and a pin interface. However, the elaboratable object itself can be an interface object as well, which makes it easy to convert it to Verilog and use standalone since its signature defines the ports the Verilog module needs to have.</p>
<h3 id="interface-description"><a class="header" href="#interface-description">Interface description</a></h3>
<p>Interfaces are described using an enumeration, <code>amaranth.lib.wiring.Flow</code>, and two classes, <code>amaranth.lib.wiring.Member</code> and <code>amaranth.lib.wiring.Signature</code>:</p>
<ul>
<li>
<p><code>Flow</code> is an enumeration with two values, <code>In</code> and <code>Out</code>.</p>
<ul>
<li><code>Flow.__call__(arg, **kwargs)</code> forwards to <code>Member(self, arg, **kwargs)</code>.
<ul>
<li>Thus, <code>Out(unsigned(16), reset=0x1234)</code> is a shorthand for <code>Member(Flow.Out, unsigned(16), reset=0x1234)</code>.</li>
</ul>
</li>
<li><code>flow.flip()</code> flips the value from <code>In</code> to <code>Out</code> and back.</li>
</ul>
</li>
<li>
<p>A <code>Member(flow, ...)</code> object describes a part of an interface. It is immutable.</p>
<ul>
<li>A <code>Member(flow, shape_castable, reset=reset_value)</code> object describes a port with the given shape and flow direction. The returned <code>Member</code> object has:
<ul>
<li>the <code>.flow</code> property be <code>flow</code>;</li>
<li>the <code>.is_port</code> property be <code>True</code>;</li>
<li>the <code>.is_signature</code> property be <code>False</code>;</li>
<li>the <code>.shape</code> property be <code>shape_castable</code>;</li>
<li>the <code>.reset</code> property be <code>reset_value</code>;</li>
<li>the <code>.signature</code> property raise <code>TypeError</code>;</li>
<li>the <code>.dimensions</code> property be <code>()</code>.</li>
</ul>
</li>
<li>A <code>Member(flow, signature)</code> object describes a constituent interface with the given flow direction. If <code>flow</code> is <code>Flow.In</code>, then the actual flow of every port recursively described by <code>signature</code> is the reverse of the stated direction. The returned <code>Member</code> object has:
<ul>
<li>the <code>.flow</code> property be <code>flow</code>;</li>
<li>the <code>.is_port</code> property be <code>False</code>;</li>
<li>the <code>.is_signature</code> property be <code>True</code>;</li>
<li>the <code>.shape</code> property raise <code>TypeError</code>;</li>
<li>the <code>.reset</code> property raise <code>TypeError</code>;</li>
<li>the <code>.signature</code> property return <code>signature</code> if <code>flow</code> is <code>Out</code>, <code>signature.flip()</code> if <code>flow</code> is <code>In</code>.</li>
<li>the <code>.dimensions</code> property be <code>()</code>.</li>
</ul>
</li>
<li><code>member.array(*dimensions)</code> returns a new <code>Member</code> object whose <code>.dimensions</code> property is <code>dimensions</code>, which is any amount of non-negative numbers, and all other properties are the same as those of <code>member</code>. Calling <code>.array()</code> on a member with dimensions prepends the new dimensions before the old ones, for composability.</li>
<li><code>member.flip()</code> returns a new <code>Member</code> object whose <code>.flow</code> property is <code>~member.flow</code>, and all other properties are the same as those of <code>member</code>.</li>
</ul>
</li>
<li>
<p>A <code>Signature(...)</code> object describes an interface comprised of named members: ports and nested interfaces (which themselves are described using signature objects).</p>
<p>The <code>Signature</code> class can be derived from. Instances of <code>Signature</code> itself are termed <em>anonymous signatures</em>, and instances of derived classes are <em>named signatures</em>.</p>
<ul>
<li>A <code>Signature({&quot;name&quot;: Member(...)})</code> object can be constructed from a name to member mapping.</li>
<li><code>signature.members</code> is a mutable mapping that can be used to alter the description of a non-frozen signature.
<ul>
<li><code>signature.members += {...}</code> adds members from the given mapping to <code>signature.members</code> if the names being added are not already used. Raises <code>NameError</code> otherwise.</li>
</ul>
</li>
<li><code>signature.freeze()</code> (or <code>signature.members.freeze()</code>) prevents any further modifications of <code>signature</code> (and in particular <code>signature.members</code>), enabling the caller to rely on a particular layout. It is applied recursively to constituent interfaces.
<ul>
<li>It returns <code>self</code> to aid assignments in class definition like:
<pre><code class="language-python">class X:
    signature = Signature({
        ...
    }).freeze()
</code></pre>
</li>
</ul>
</li>
<li><code>signature.flip()</code> returns a signature where every member is <code>member.flip()</code>ped. The exact object returned is a proxy object that overrides the methods and attributes defined here such that the flow is flipped, and otherwise forwards attribute accesses untouched. That is, <code>signature.x = &lt;value&gt;</code> and <code>signature.flip().x = &lt;value&gt;</code> both define an attribute on the original <code>signature</code> object, and never on the proxy object alone. When calling method <code>signature.f</code> as <code>signature.flip().f</code>, <code>self</code> is the flipped signature.</li>
<li><code>signature.flatten(object)</code> returns an iterator yielding a <code>path, member, value</code> tuples for each of the ports recursively contained in the signature, where:
<ul>
<li><code>path</code> is a tuple of strings or integers indicating the sequence of attribute or index accesses that were used to retrieve <code>value</code> from <code>object</code></li>
<li><code>member</code> is the port member corresponding to <code>value</code>, with the flow flipped as appropriate</li>
<li><code>value</code> is a value-castable object corresponding to the port (usually but not always a <code>Signal</code>)</li>
</ul>
</li>
<li><code>signature.is_compliant(object)</code> checks whether an arbitrary Python object is compliant with this signature. To be compliant with a signature:
<ul>
<li>for every member of the signature, the object must have a corresponding attribute</li>
<li>if the member is a port, the attribute value must be a value-castable such that <code>Value.cast(object.attr)</code> method returns a <code>Signal</code> or a <code>Const</code> that has the same width and signedness, and for signals, is not reset-less and has the same reset value as the member
<ul>
<li>a warning may be emitted if the <code>.shape</code> of the member and the <code>.shape()</code> of <code>object.attr</code> are not equal</li>
</ul>
</li>
<li>if the member is an interface, the attribute value must be compliant with the signature of the member</li>
<li>if the member's <code>dimensions</code> are <code>(p, q, ...)</code>, the requirements below hold instead for every result of indexing the attribute value with <code>[i][j]...</code> where <code>i in range(p)</code>, <code>j in range(q)</code>, ...</li>
</ul>
</li>
<li><code>signature.members.create()</code> creates a dictionary of members from it. This is a helper method for the common part of <code>signature.create()</code>. For every member of the signature, the dictionary contains a value equal to:
<ul>
<li>If the member is a port, <code>Signal(member.shape, reset=member.reset)</code>.</li>
<li>If the member is a signature, <code>member.signature.create()</code> for <code>Out</code> members, and <code>member.signature.flip().create()</code> for <code>In</code> members.</li>
</ul>
</li>
<li><code>signature.create()</code> creates an interface object from this signature. To do this, it calls the constructor of <code>Interface</code> described below. This method is expected to be routinely overridden in <code>Signature</code> subclasses to instantiate subclasses of <code>Interface</code>.</li>
</ul>
</li>
</ul>
<p>All of the methods that can be called on <code>signature</code> can be called on the object returned by <code>signature.flip()</code>, and <code>self</code> in that case is <code>signature.flip()</code>. This means that in a method defined on a subclass of <code>Signature</code>, <code>self</code> can be an instance of that type, or an instance of a different type, <code>FlippedSignature</code>, which implements the flipping behavior. In the rare case where it is useful to determine which one it is, it is possible to use <code>type(self) is amaranth.lib.wiring.FlippedSignature</code>.</p>
<p>Any object can be an interface object if it has the appropriate <code>signature</code> property. However, an <code>amaranth.lib.wiring.Interface</code> class is introduced, serving two purposes: instantiating interfaces from an anonymous signature, and serving as a convenient base class for custom interface classes. The <code>Interface</code> class implements only the <code>__init__()</code> method, accepting a signature as a parameter. It assigns <code>self.signature</code> to be that signature, and for each item in <code>signature.members.create()</code> it creates a corresponding attribute on <code>self</code>.</p>
<h3 id="interface-connection"><a class="header" href="#interface-connection">Interface connection</a></h3>
<p>Interface objects may be connected to each other using the <code>amaranth.lib.wiring.connect(m, *objects)</code> free function.</p>
<p>This function connects interface objects that satisfy the following requirements:</p>
<ul>
<li>The set of members (considered by their paths) is exactly the same for each of the objects.</li>
<li>For each given path, all members are either signature members or port members.</li>
<li>For each given path where all members are port members, the width of every member with the same path is equal, though the exact types of the objects returned by the <code>.shape</code> property may differ.</li>
<li>For each given path where all members are port members, the reset values of all members with the same path must match.</li>
<li>For each given path where all members are port members, exactly one member has an <code>Out</code> flow.</li>
</ul>
<p>If the <code>In</code> port member is a signal, it is connected to the <code>Out</code> port member with the same path as follows:</p>
<pre><code class="language-python">m.d.comb += input_port.eq(output_port)
</code></pre>
<p>If the <code>In</code> port member is a constant, no connection is actually made. The <code>Out</code> port member with the same path (if any) must be a constant with the same value.</p>
<h3 id="forwarding-interfaces"><a class="header" href="#forwarding-interfaces">Forwarding interfaces</a></h3>
<p>In some cases, an outer elaboratable object creates an inner elaboratable object and exposes an interface of the inner object as its own:</p>
<pre><code class="language-python">class Outer(Component):
    bus: Out(BusSignature())

    def __init__(self):
        super().__init__()

        self.inner = Inner()

    def elaborate(self, platform):
        m = Module()
        m.d.comb += [
            self.inner.bus.addr.eq(self.bus.addr),
            self.inner.bus.w_data.eq(self.bus.w_data),
            self.bus.r_data.eq(self.inner.bus.r_data),
            # ...
        ]
        return m


class Inner(Component):
    bus: Out(BusSignature())

    ...
</code></pre>
<p>In this case, <code>amaranth.lib.wiring.connect(...)</code> won't help, since an output needs to be connected to an output, and an input to an input.</p>
<p>An additional function <code>amaranth.lib.wiring.flipped(obj)</code> is added to assist in this case. It returns a proxy object <code>obj_flipped</code> where <code>obj_flipped.signature</code> equals <code>obj.signature.flip()</code>, and everything else is forwarded identically otherwise. So, the <code>Outer.elaborate</code> method can be rewritten as:</p>
<pre><code class="language-python">class Outer(Component):
    bus: Out(BusSignature())

    def __init__(self):
        super().__init__()

        self.inner = Inner()

    def elaborate(self, platform):
        m = Module()
        connect(m, flipped(self.bus), self.inner.bus)
        return m
</code></pre>
<h3 id="component-definition"><a class="header" href="#component-definition">Component definition</a></h3>
<p>This RFC in effect introduces a particular kind of elaboratable object: one that has a signature. While connecting an elaboratable as a whole (as opposed to its sub-interfaces) will rarely, if ever, happen, it is still convenient to have an elaboratable define its signature, for three reasons:</p>
<ol>
<li>It is a declaration of intent, separating the signals that are purposefully a part of its interface from ones that just happen to be assigned to attributes, and stating their direction;</li>
<li>It simplifies and standardizes assignment of the interface attributes, making the <code>signature</code> property the single source of truth for the module's interface;</li>
<li>It makes it easy to convert a single standalone elaboratable to Verilog.</li>
</ol>
<p>To this end, a class <code>amaranth.lib.wiring.Component</code> is introduced:</p>
<ul>
<li><code>Component.__init__</code> (typically called as <code>super().__init__()</code>) updates <code>self.__dict__</code> with the result of <code>self.signature.members.create()</code>. (If there is a name conflict, it raises an error.)</li>
<li><code>Component.signature</code> collects PEP 526 variable annotations in the class's method resolution order chain up to <code>Component</code>, if any, and returns a signature object constructed from these, or raises an error otherwise. The signature object is created per-instance, not per-class, so that it can be safely mutated if this is a part of the workflow.</li>
</ul>
<h2 id="alternatives-and-rationale"><a class="header" href="#alternatives-and-rationale">Alternatives and rationale</a></h2>
<ul>
<li>
<p>Do nothing. <code>Record</code> will continue to be used alongside the continued proliferation of ad-hoc implementations of similar functionality, and continue to impair the use of Amaranth components together.</p>
</li>
<li>
<p>Replace the <code>amaranth.lib.wiring.connect</code> free function with a function <code>amaranth.hdl.dsl.Module.connect</code>.</p>
<ul>
<li>It is not a function on <code>amaranth.hdl.dsl.Module</code> to avoid privileging the standard interface library over any other library that may be written downstream. At the moment nothing in <code>amaranth.lib</code> is special in any way other than its name, and preserving this is valuable to the author.</li>
</ul>
</li>
</ul>
<h2 id="naming-questions"><a class="header" href="#naming-questions">Naming questions</a></h2>
<ul>
<li>Should <code>amaranth.lib.wiring</code> be called something else, like <code>amaranth.lib.bus</code> or <code>amaranth.lib.component</code>?
<ul>
<li>bus is short, but not every interface is a bus interface; component (or module, really) puts too much emphasis on the things being interfaced, rather than the interfaces (@jfng)</li>
<li>i wouldn't want the bus keyword to already be taken in my namespaces (@jfng)</li>
<li>I guess my point is mostly that bus is not the opposite of data, but wiring is (@whitequark)</li>
<li>I don't like how long &quot;component&quot; is (@whitequark)</li>
</ul>
</li>
<li>Should <code>Signature.compatible</code> be named something else, like <code>Signature.is_implemented_by</code>, <code>Signature.is_compliant</code>, <code>Signature.complies_with</code>?
<ul>
<li><code>Signature.compatible</code> misses an <code>is_</code> and does not look like a query method (@jfng)</li>
<li>I mean, &quot;compatible&quot; could mean that two signatures could be connected together. when checking if an object is compliant to a signature, directions also matters (@zyp)</li>
<li><code>Signature.complies_with</code> reverses subject and object (@zyp)</li>
<li><code>Signature.is_implemented_by</code> is verbose (@jfng)</li>
</ul>
</li>
<li>Should <code>amaranth.lib.wiring.forward</code> be named something else, like <code>amaranth.lib.wiring.forwarded</code> or <code>amaranth.lib.wiring.forwarding</code> or <code>amaranth.lib.wiring.flip</code> or <code>amaranth.lib.wiring.transpose</code> or <code>amaranth.lib.wiring.transpose</code> or <code>amaranth.lib.wiring.inner</code>?
<ul>
<li>having two essentially unrelated operations called <code>flip</code> when one is already confusing is too much (@whitequark)</li>
<li>reflective programming is a thing (@zyp)</li>
<li>inner(inner(interface)) to flip it back to the original wouldn't make much sense (@zyp)</li>
</ul>
</li>
</ul>
<h2 id="future-work-1"><a class="header" href="#future-work-1">Future work</a></h2>
<ul>
<li>One-to-many connections between interfaces are currently provided only with a fan-out topology: a single interface with output members only can be connected with multiple interfaces with input members only. This avoids the question of what to do with an input that must be driven by multiple outputs. The interface library could be enriched by adding a small amount of fixed fan-in topologies, e.g. wired-OR and wired-AND, specified as a <code>Member()</code> constructor parameter that must match between all of the respective members.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2023-02-27</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/3">amaranth-lang/rfcs#3</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth/issues/756">amaranth-lang/amaranth#756</a></li>
</ul>
<h1 id="enumeration-shapes"><a class="header" href="#enumeration-shapes">Enumeration shapes</a></h1>
<blockquote>
<p><strong>Amendments</strong>
The behavior described in this RFC was updated by <a href="0004-const-castable-exprs.html">RFC #4</a>.</p>
</blockquote>
<h2 id="summary-2"><a class="header" href="#summary-2">Summary</a></h2>
<p>Allow explicitly specifying shape for enumerations as an alternative to implicitly inferring it.</p>
<h2 id="motivation-2"><a class="header" href="#motivation-2">Motivation</a></h2>
<p>Hardware development includes a lot of enumerated values, so first class support for enumerations is important, and so is integration with the standard Python mechanisms for specifying enumerations.</p>
<p>Amaranth accepts <code>enum.Enum</code> subclasses anywhere a shape is expected, and <code>enum.Enum</code> instances anywhere a value is expected:</p>
<pre><code class="language-python">&gt;&gt;&gt; from amaranth import *
&gt;&gt;&gt; from enum import Enum
&gt;&gt;&gt; class Kind(Enum):
...     MUL = 0
...     ADD = 1
...     SUB = 2
...
&gt;&gt;&gt; Shape.cast(Kind)
unsigned(2)
&gt;&gt;&gt; Value.cast(Kind.SUB)
(const 2'd2)
</code></pre>
<p>However, this does not cover an important use case: a enumeration where many values are reserved. For example, if the <code>Kind</code> enumeration above may need to be extended in the future, it would be necessary to reserve space for additional values, which may require additional storage bits. Right now there is no way to specify that <code>Kind</code> should be cast to e.g. <code>unsigned(4)</code>.</p>
<h2 id="guide-level-explanation-1"><a class="header" href="#guide-level-explanation-1">Guide-level explanation</a></h2>
<p>The Amaranth standard library module, <code>amaranth.lib.enum</code> can be used as a drop-in replacement for the Python standard library <code>enum</code> module. It exports the same classes as the ones provided by Python's <code>enum</code> (namely <code>Enum</code>, <code>Flag</code>, <code>IntEnum</code>, and <code>IntFlag</code>) and provides the same functionality, adding the possibility of specifying a shape for the enumeration when it is defined:</p>
<pre><code class="language-python">&gt;&gt;&gt; from amaranth.lib.enum import Enum
&gt;&gt;&gt; class Kind(Enum, shape=unsigned(4)):
...    MUL = 0
...    ADD = 1
...    SUB = 2
...
&gt;&gt;&gt; Shape.cast(Kind)
unsigned(4)
&gt;&gt;&gt; Value.cast(Kind.SUB)
(const 4'd2)
</code></pre>
<p>If the <code>shape=</code> keyword argument is not specified, the enumeration is treated exactly the same as the corresponding standard Python class.</p>
<p>If the values specified for the members are not representable with the explicitly provided shape, a warning is emitted:</p>
<pre><code class="language-python">&gt;&gt;&gt; class Funct3(Enum, shape=unsigned(3)):
...     SUB = 8
...
&lt;stdin&gt;:1: RuntimeWarning: Value of enumeration member &lt;Funct3.SUB: 8&gt; will be truncated to enumeration shape unsigned(3)
&gt;&gt;&gt; class Funct3(Enum, shape=unsigned(3)):
...     SUB = -1
...
&lt;stdin&gt;:1: RuntimeWarning: Value of enumeration member &lt;Funct3.SUB: -1&gt; is signed, but enumeration shape is unsigned(3)
</code></pre>
<p>A shape that is specified for a base class will be inherited in subclasses:</p>
<pre><code class="language-python">&gt;&gt;&gt; class Enum3(Enum, shape=unsigned(3)): pass
...
&gt;&gt;&gt; class Funct3(Enum3):
...     SUB = 2
...
&gt;&gt;&gt; Shape.cast(Funct3)
unsigned(3)
</code></pre>
<p>If a enumeration without an explicitly defined shape is used in a concatenation, a warning is emitted:</p>
<pre><code class="language-python">&gt;&gt;&gt; class Kind(Enum):
...     ADD = 1
...
&gt;&gt;&gt; Cat(Kind.ADD)
&lt;stdin&gt;:1: SyntaxWarning: Argument #1 of Cat() is an enumeration Kind.ADD without a defined shape used in bit vector context; define the enumeration by inheriting from the class in amaranth.lib.enum and specifying the 'shape=' keyword argument
(cat (const 1'd1))
</code></pre>
<h2 id="reference-level-explanation-1"><a class="header" href="#reference-level-explanation-1">Reference-level explanation</a></h2>
<p>The Amaranth standard library module, <code>amaranth.lib.enum</code>, exports all of the public names of the Python standard library <code>enum</code> module. The <code>EnumMeta</code> class adds the functionality for storing and casting to shapes, and inherits from <code>ShapeCastable</code>. The <code>Enum</code>, <code>Flag</code>, <code>IntEnum</code>, and <code>IntFlag</code> classes in this module derive from <code>enum.Enum</code>, <code>enum.Flag</code>, <code>enum.IntEnum</code>, and <code>enum.IntFlag</code> respectively, and use <code>amaranth.lib.enum.EnumMeta</code> as their metaclass, which makes subclasses of <code>amaranth.lib.enum.Enum</code>, etc be instances of <code>ShapeCastable</code>.</p>
<p>When a new <code>amaranth.lib.enum.Enum</code> subclass is defined, <code>amaranth.lib.enum.EnumMeta.__new__</code> checks that the enumeration members are valid (currently, Amaranth requires these to be integers), and if the <code>shape=</code> argument is provided, stores it in an internal attribute. Importantly, the attribute is only set if the argument is provided, making it possible to distinguish these cases later. It also checks that all of the members can be represented by the given shape.</p>
<p>When an <code>amaranth.lib.enum.Enum</code> subclass is cast to a shape, if the internal attribute is set, the shape in it is returned. Otherwise it is cast to a shape using exactly the same logic as what <code>Shape.cast</code> uses for <code>enum.Enum</code> subclasses.</p>
<p>When an instance of a <code>enum.Enum</code> subclass is used in a concatenation, and it is not an instance of <code>ShapeCastable</code>, or if it lacks the <code>_amaranth_shape_</code> attribute, a warning is emitted. This approach avoids a circular dependency between <code>amaranth.hdl.ast</code> and <code>amaranth.lib.enum</code>.</p>
<h2 id="drawbacks-1"><a class="header" href="#drawbacks-1">Drawbacks</a></h2>
<ul>
<li>Introducing a new standard library module increases the API surface.</li>
<li>The names of enumeration base classes are the same as the standard library enumeration base classes, which may be confusing.</li>
<li>Deriving from a different class requires changes to the enumeration at its point of definition, meaning that it is not possible to annotate a enum that comes from an external library with an Amaranth shape.</li>
</ul>
<h2 id="rationale-and-alternatives"><a class="header" href="#rationale-and-alternatives">Rationale and alternatives</a></h2>
<p>Ultimately, this feature boils down to defining an internal variable on an enum, which is then used by <code>Shape.cast</code> and other core Amaranth code. There are a few possible options for doing this.</p>
<ol>
<li>
<p>Special class variable:</p>
<pre><code class="language-python">class SomeEnum(enum.Enum):
    _amaranth_shape_ = unsigned(4)
</code></pre>
</li>
<li>
<p>Class decorator:</p>
<pre><code class="language-python">@amaranth.shape(unsigned(4))
class SomeEnum(enum.Enum):
</code></pre>
</li>
<li>
<p>Class keyword argument (this proposal):</p>
<pre><code class="language-python">class SomeEnum(amaranth.lib.enum.Enum, shape=unsigned(4)):
</code></pre>
</li>
</ol>
<p>Alternative (1) has the following drawbacks:</p>
<ul>
<li>It is not possible to check that the enumeration members can be represented by the specified shape at the point of definition.</li>
<li>It exposes what should be an implementation detail to the user.</li>
<li>The documentation for the standard <code>enum</code> module does not specify whether it's OK to use <code>_sunder_</code> names for one's own purposes, but it would have to be a part of the stable API.</li>
</ul>
<p>Its advantages are:</p>
<ul>
<li>No additional methods or classes in the API surface.</li>
<li><code>_amaranth_shape_</code> makes it immediately clear what's going on.</li>
<li>The variable can be defined on any enum, even an external one.</li>
</ul>
<p>Alternative (2) has the following drawbacks:</p>
<ul>
<li>It's not clear where the <code>shape</code> decorator should be. It can only be applied to enums, but there's no enum-specific namespace in Amaranth core to put it into.</li>
<li><code>SomeEnum</code> would inherit from the standard <code>Enum</code> class and therefore <code>isinstance(SomeEnum, ShapeCastable)</code> would be <code>False</code> unless <code>ShapeCastable.__instancecheck__</code> is overridden to fix that.</li>
</ul>
<p>Its advantages are:</p>
<ul>
<li>The decorator can be applied to an external enum.</li>
</ul>
<p>Alternative (3) has the drawbacks specified above, and the following advantages:</p>
<ul>
<li><code>isinstance(SomeEnum, ShapeCastable)</code> naturally works.</li>
<li>As a consequence, no additional code is required in the core language. All of the functionality necessary for the feature to work lives in <code>amaranth.lib.enum</code>.</li>
<li>The <code>shape</code> argument matches <code>Signal(shape=)</code> (even though no one uses the keyword form) and works the way one would naturally expect.</li>
<li>Uses of <code>import enum</code> can be transparently replaced with <code>from amaranth.lib import enum</code> without updating the call sites, making the migration as easy as the other alternatives.</li>
</ul>
<h2 id="prior-art"><a class="header" href="#prior-art">Prior art</a></h2>
<p>None.</p>
<h2 id="unresolved-questions"><a class="header" href="#unresolved-questions">Unresolved questions</a></h2>
<p>None.</p>
<h2 id="future-possibilities"><a class="header" href="#future-possibilities">Future possibilities</a></h2>
<p>None.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2023-02-07</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/4">amaranth-lang/rfcs#4</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth/issues/755">amaranth-lang/amaranth#755</a></li>
</ul>
<h1 id="const-castable-expressions"><a class="header" href="#const-castable-expressions">Const-castable expressions</a></h1>
<h2 id="summary-3"><a class="header" href="#summary-3">Summary</a></h2>
<p>Define a subset of expressions that are &quot;const-castable&quot; and accept them in contexts where currently only integers and enumerations with integer values are accepted.</p>
<h2 id="motivation-3"><a class="header" href="#motivation-3">Motivation</a></h2>
<p>In certain contexts, Amaranth requires a constant to be used. These contexts are: <code>with m.Case(...):</code>, <code>Value.matches(...)</code>, and the value of an enumeration member that is being cast to a value.</p>
<p>Currently, only integers and enumeration members with integer values are considered constants. However, this is too limiting. For example, when developing a CPU, one might want to define control signals for several functional units and combine them into instructions, or conversely, match an instruction against a combination of control signals:</p>
<pre><code class="language-python">class Func(Enum):
    ADD = 0
    SUB = 1

class Src(Enum):
    MEM = 0
    REG = 1

class Instr(Enum):
    ADD  = Cat(Func.ADD, Src.MEM)
    ADDI = Cat(Func.ADD, Src.REG)
    ...

with m.Switch(instr):
    with m.Case(Cat(Func.ADD, Src.MEM)):
        ...
</code></pre>
<p>Currently, all of these cases would produce syntax errors.</p>
<p>There is a private <code>Value._as_const</code> method. It is not used internally, however Amaranth developers have started using it due to unmet needs. Removing it without providing a replacement would be disruptive, and will result in downstream codebases defining their own equivalent.</p>
<h2 id="guide-level-explanation-2"><a class="header" href="#guide-level-explanation-2">Guide-level explanation</a></h2>
<p>In any context where a constant is accepted (<code>with m.Case(...):</code>, <code>Value.matches(...)</code>, and the value of an enumeration member), a &quot;const-castable&quot; expression can be used. The following expressions are const-castable:</p>
<ul>
<li><code>int</code>;</li>
<li><code>Const</code>;</li>
<li><code>Cat</code> where all operands are const-castable;</li>
<li>instance of a <code>Enum</code> subclass where the value is const-castable.</li>
</ul>
<p>A const-castable expression can be converted to a <code>Const</code> using <code>Const.cast</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; Const.cast(1)
(const 1'd1)
&gt;&gt;&gt; Const.cast(Cat(1, 0, 1))
(const 3'd5)
&gt;&gt;&gt; Const.cast(Cat(Func.ADD, Src.REG))
(const 2'd2)
</code></pre>
<h2 id="reference-level-explanation-2"><a class="header" href="#reference-level-explanation-2">Reference-level explanation</a></h2>
<p>The <code>Const.cast</code> static method casts its argument to a value and examines it. If it is a <code>Const</code>, it is returned. If it is a const-castable expression, the operands are recursively cast to constants, and the expression is evaluated.</p>
<p>The list of const-castable expressions is:</p>
<ul>
<li><code>Cat</code></li>
</ul>
<p>The <code>m.Case(...)</code> (through the <code>Switch()</code> constructor) and <code>Value.matches(...)</code> methods accept two kinds of operands: const-castable expressions, or a string containing a bit pattern (a sequence of <code>0</code>, <code>1</code>, or <code>-</code> meaning a wildcard).</p>
<p>The <code>Shape.cast</code> method accepts enumerations where all members have const-castable expressions as their values. The shape of an enumeration is a shape with the smallest width that can represent the value of any enumeration member.</p>
<p><a href="0003-enumeration-shapes.html">RFC 3</a>: The <code>EnumMeta.__new__</code> method accepts enumerations where all members have const-castable expressions as their values. The value of each member is the value of the constant resulting from casting the user-provided expression.</p>
<h2 id="drawbacks-2"><a class="header" href="#drawbacks-2">Drawbacks</a></h2>
<ul>
<li>A new language-level concept makes it harder to learn the language.
<ul>
<li>Most developers already have an intuitive understanding of which expressions are const-castable.</li>
</ul>
</li>
<li><code>Const.cast</code> shadows an existing <code>Value.cast</code> method since <code>Const</code> inherits from <code>Value</code>.
<ul>
<li>No one is calling <code>Value.cast</code> through the <code>Const.cast</code> binding.</li>
<li><code>Const.cast</code> has a compatible interface (it returns a <code>Value</code>) and performs a similar function (it calls <code>Value.cast</code> first). However, it's not Liskov-compatible.</li>
</ul>
</li>
</ul>
<h2 id="rationale-and-alternatives-1"><a class="header" href="#rationale-and-alternatives-1">Rationale and alternatives</a></h2>
<p>Alternatives:</p>
<ol>
<li>Do not add this functionality. Developers will define their own const-casting functions, continue to rely on the undocumented and private <code>._as_const()</code> method, or use other workarounds.</li>
<li>Make <code>._as_const()</code> public (i.e. rename it to <code>.as_const()</code>).</li>
<li>Add a new <code>Const.cast</code> method (this option).</li>
</ol>
<p>Alternatives (2) and (3) both introduce a new language-level concept, the only difference is in the interface that is used to access it.</p>
<p>Alternative (3) fits the language better: <code>Value.cast</code> takes something value-castable and returns a <code>Value</code>, <code>Shape.cast</code> takes something shape-castable and returns a <code>Shape</code>, so <code>Const.cast</code> is a logical addition in that it takes something const-castable and returns a <code>Const</code>.</p>
<h2 id="prior-art-1"><a class="header" href="#prior-art-1">Prior art</a></h2>
<p>Rust and C++ provide functionality (<code>const fn</code> and <code>constexpr</code> respectively) for performing computation at compile time, restricted to a strict subset of the full language. In particular, it can be used to initialize constants, which makes it similar to the functionality proposed here.</p>
<p>One challenge these languages face is the question of how large the subset should be. Rust in particular started off heavily restricting <code>const fn</code>, where it did not have any control flow. The functionality was gradually introduced later as needed.</p>
<h2 id="unresolved-questions-1"><a class="header" href="#unresolved-questions-1">Unresolved questions</a></h2>
<p>None.</p>
<h2 id="future-possibilities-1"><a class="header" href="#future-possibilities-1">Future possibilities</a></h2>
<p>Expanding the set of const-castable expressions to include arbitrary arithmetic operations. This RFC limits it to the most requested expression, <code>Cat</code>. This simplifies implementation and reduces the likelihood of introducing bugs in the constant evaluation code, most of which would be almost never used.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2023-02-07</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/5">amaranth-lang/rfcs#5</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth/issues/754">amaranth-lang/amaranth#754</a></li>
</ul>
<h1 id="remove-constnormalize"><a class="header" href="#remove-constnormalize">Remove <code>Const.normalize</code></a></h1>
<h2 id="summary-4"><a class="header" href="#summary-4">Summary</a></h2>
<p>Remove <code>Const.normalize(value, shape)</code>.</p>
<h2 id="motivation-4"><a class="header" href="#motivation-4">Motivation</a></h2>
<p>From the name it is not clear what it is supposed to achieve (it's truncation and inversion according to the shape) and it does not check types of arguments.</p>
<p>We already have <code>Const(value, shape).value</code> and most developers should be aware of it. Having <code>Const.normalize(value, shape)</code> as well provides no benefit over the former. It's also longer.</p>
<h2 id="explanation"><a class="header" href="#explanation">Explanation</a></h2>
<p>The <code>Const.normalize</code> method is deprecated (with the suggestion to use <code>Const().value</code>) and removed.</p>
<h2 id="drawbacks-3"><a class="header" href="#drawbacks-3">Drawbacks</a></h2>
<ul>
<li>Churn.</li>
</ul>
<h2 id="rationale-and-alternatives-2"><a class="header" href="#rationale-and-alternatives-2">Rationale and alternatives</a></h2>
<p>We could keep it. Removing it reduces the API surface and makes the language a bit more elegant.</p>
<h2 id="prior-art-2"><a class="header" href="#prior-art-2">Prior art</a></h2>
<p>None.</p>
<h2 id="unresolved-questions-2"><a class="header" href="#unresolved-questions-2">Unresolved questions</a></h2>
<p>None.</p>
<h2 id="future-possibilities-2"><a class="header" href="#future-possibilities-2">Future possibilities</a></h2>
<p>None.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2023-05-31</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/0006">amaranth-lang/rfcs#0006</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth/issues/681">amaranth-lang/amaranth#681</a></li>
</ul>
<h1 id="crc-generator"><a class="header" href="#crc-generator">CRC generator</a></h1>
<h2 id="summary-5"><a class="header" href="#summary-5">Summary</a></h2>
<p>Add a cyclic redundancy check (CRC) generator to the Amaranth standard library.</p>
<h2 id="motivation-5"><a class="header" href="#motivation-5">Motivation</a></h2>
<p>Computing CRCs is a common requirement in hardware designs as they are used
by a range of communication and storage protocols to detect errors and thereby
ensure data integrity. Because of the standard structure and typical set of
variations used by CRCs, it is readily possible to provide a general-purpose
CRC generator in the standard library which should cover the majority of use
cases efficiently.</p>
<p>See the <a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">Wikipedia page on CRCs</a> for more background and use cases.</p>
<h2 id="guide-level-explanation-3"><a class="header" href="#guide-level-explanation-3">Guide-level explanation</a></h2>
<p>The Amaranth standard library includes a generator for a cyclic redundancy
check (CRC) module, which can be used to compute and/or validate most common
CRCs used by transmission and storage protocols.</p>
<p>There are many different CRC algorithms in use, but they can almost all be
described by the following parameters:</p>
<ul>
<li>The bit width of the CRC, commonly (but not always) a power of 2,</li>
<li>The generator polynomial, represented as an integer where each bit is a 0 or
1 term in a binary-valued polynomial with as many terms as the CRC width,</li>
<li>The initial value of the CRC register, commonly non-zero to allow detection
of additional 0-valued data words at the start of a message,</li>
<li>Whether to process input words least- or most-significant-bit first,
allowing the CRC processing order to match the transmission or storage order
of the data bits,</li>
<li>Whether to flip the final output so that its least-significant-bit becomes
the most-significant bit, set for the same reason as reflecting the input
when the CRC value will also be transmitted or stored with a certain bit
order,</li>
<li>What value, if any, to XOR the output bits with before using the CRC value,
often used to invert all bits of the output.</li>
</ul>
<p>This set of parameters is commonly known as the Williams or Rocksoft model. For
more information, refer to <a href="http://www.ross.net/crc/download/crc_v3.txt">&quot;A Painless Guide to CRC Error Detection Algorithms&quot;</a>.</p>
<p>For a list of parameters to use for standard CRCs, refer to:</p>
<ul>
<li><a href="https://reveng.sourceforge.io/crc-catalogue/all.htm">reveng</a>'s catalogue, which uses the same parameterisation</li>
<li><a href="http://crcmod.sourceforge.net/crcmod.predefined.html">crcmod</a>'s predefined list, but remove the leading <code>1</code> from the
polynomials, XOR the &quot;Init-value&quot; with &quot;XOR-out&quot; to obtain <code>initial_crc</code>,
and where <code>Reversed</code> is <code>True</code>, set both <code>ref_in</code> <strong>and</strong>
<code>ref_out</code> to <code>True</code>.</li>
<li><a href="https://users.ece.cmu.edu/~koopman/crc/">CRC Zoo</a>, which only lists polynomials; use the &quot;explicit +1&quot; form but
remove the leading <code>1</code>.</li>
</ul>
<p>The CRC algorithms described in the <a href="https://reveng.sourceforge.io/crc-catalogue/all.htm">reveng</a> catalogue are also available
in the Amaranth standard library in the <code>crc.catalog</code> module.</p>
<p>In Amaranth, the <code>crc.Algorithm</code> class holds the parameters that describe a
CRC algorithm:</p>
<ul>
<li><code>crc_width</code>: the bit width of the CRC</li>
<li><code>polynomial</code>: the generator polynomial of the CRC, excluding an implicit
leading 1 for the &quot;x^n&quot; term</li>
<li><code>initial_crc</code>: the initial value of the CRC, loaded when computation of a
new CRC begins</li>
<li><code>reflect_input</code>: if True, input words are bit-reversed so that the least
significant bit is processed first</li>
<li><code>reflect_output</code>: if True, the final output is bit-reversed so that its
least-significant bit becomes the most-significant bit of output</li>
<li><code>xor_output</code>: a value to XOR the output with</li>
</ul>
<p>The <code>crc.Algorithm</code> class may be constructed manually, but for many
commonly used CRC algorithms a predefined instance is available in
the <code>crc.catalog</code> module.</p>
<p>To fully define a CRC computation, the width of input data words to the CRC
must also be specified. This is commonly 8 for processing byte-wise data,
but can be any length greater than 0. The combination of a <code>crc.Algorithm</code>
and the <code>data_width</code> makes a <code>crc.Parameters</code> instance, for example:</p>
<pre><code class="language-python">from amaranth.lib import crc
algo = crc.Algorithm(crc_width=8, polynomial=0x2f, initial_crc=0xff,
                     reflect_input=False, reflect_output=False,
                     xor_output=0xff)
params1 = algo(data_width=8)
params2 = crc.catalog.CRC8_AUTOSAR(data_width=8)
</code></pre>
<p>If not specified, the data width defaults to 8 bits.</p>
<p>The <code>crc.Parameters</code> class can be used to compute CRCs in software with its
<code>compute()</code> method, which is passed an iterable of integer data words and
returns the resulting CRC value.</p>
<pre><code class="language-python">from amaranth.lib import crc
params = crc.catalog.CRC8_AUTOSAR()
assert params.compute(b&quot;123456789&quot;) == 0xdf
</code></pre>
<p>To generate a hardware CRC module, either call <code>create()</code> on <code>crc.Parameters</code>
or manually construct a <code>crc.Processor</code>:</p>
<pre><code class="language-python">from amaranth.lib import crc
algo = crc.Algorithm(crc_width=8, polynomial=0x2f, initial_crc=0xff,
                     reflect_input=False, reflect_output=False,
                     xor_output=0xff)
params = algo(data_width=8)
crc1 = m.submodules.crc1 = crc.Processor(params)
crc2 = m.submodules.crc2 = crc.Catalog.CRC8_AUTOSAR().create()
</code></pre>
<p>The <code>crc.Processor</code> module begins computation of a new CRC whenever its <code>start</code>
input is asserted. Input on <code>data</code> is processed whenever <code>valid</code> is asserted,
which may occur in the same clock cycle as <code>start</code>. The updated CRC value is
available on the <code>crc</code> output on the clock cycle after <code>valid</code>.</p>
<p>With the data width set to 1, a traditional bit-serial CRC is implemented
for the given polynomial in a Galois-type shift register. For larger values
of data width, a similar architecture computes every new bit of the CRC in
parallel.</p>
<p>The <code>match_detected</code> output signal may be used to validate data that contains a
trailing CRC. If the most recently processed word(s) form a valid CRC for all
the data processed since <code>start</code>, the CRC register will always contain a fixed
value which can be computed in advance, and the <code>match_detected</code> output
indicates whether the CRC register currently contains this value.</p>
<h2 id="reference-level-explanation-3"><a class="header" href="#reference-level-explanation-3">Reference-level explanation</a></h2>
<p>The proposed new interface is:</p>
<ul>
<li>A <code>crc.Algorithm</code> class which holds the parameters for a CRC algorithm,
all of which are passed to the constructor:
<ul>
<li><code>crc_width</code>: bit width of the CRC register</li>
<li><code>polynomial</code>: generator polynomial for CRC algorithm</li>
<li><code>initial_crc</code>: initial value of CRC at start of computation</li>
<li><code>reflect_input</code>: if True, input words are bit-reversed</li>
<li><code>reflect_output</code>: if True, output values are bit-reversed</li>
<li><code>xor_output</code>: value to XOR the CRC value with at output</li>
</ul>
</li>
<li><code>crc.Algorithm</code> implements <code>__call__(data_width=)</code> which is used to create
a <code>crc.Parameters</code> instance with the specified data width.</li>
<li>A <code>crc.Parameters</code> class which is constructed using a <code>crc.Algorithm</code> and
a <code>data_width</code>.</li>
<li><code>crc.Parameters</code> has the following methods:
<ul>
<li><code>compute(data)</code> performs a software CRC computation on <code>data</code>, an
iterable of input data words, and returns the CRC value</li>
<li><code>create()</code> returns a <code>crc.Processor</code> instance preconfigured to use
these parameters</li>
<li><code>residue()</code> returns the residue value for these parameters, which is
the value left in the CRC register after processing an entire valid
codeword (data followed by its own valid CRC)</li>
<li><code>algorithm()</code> returns an <code>crc.Algorithm</code> with the same settings as
this <code>crc.Parameters</code> instance</li>
</ul>
</li>
<li>A <code>crc.Processor</code> class which inherits from <code>Elaboratable</code> and implements
the hardware generator</li>
<li>A <code>crc.catalog</code> module which contains instances of <code>crc.Algorithm</code></li>
</ul>
<p>The hardware implementation uses the property that CRCs are linear, and so the
new value of any bit of the CRC register can be found as a linear combination
of the current state and all the input bits. By expressing the CRC computation
as a linear system like this, we can then determine the boolean equation used
to update each bit of the CRC in parallel. A software CRC calculator is
implemented in Python in order to find these logic equations.</p>
<p>The proposed CRC generator is already implemented and available in <a href="https://github.com/amaranth-lang/amaranth/pull/681">PR 681</a>.
The docstrings and comments in it should explain its operation to a suitably
technical level of detail.</p>
<h2 id="drawbacks-4"><a class="header" href="#drawbacks-4">Drawbacks</a></h2>
<p>Users could always write their own CRC or use an external library; Amaranth
does not need to provide one for them. However, since it's a very common
requirement that we can satisfy efficiently for a lot of users, it seems
reasonable to include in the standard library.</p>
<h2 id="rationale-and-alternatives-3"><a class="header" href="#rationale-and-alternatives-3">Rationale and alternatives</a></h2>
<p>As far as I'm aware, the method here is the optimal technique for generating
the logic equations required for this combinatorial CRC generation.</p>
<p>One alternative to the combinatorial logic equations is to store intermediate
values in a lookup table; the table needs to contain a CRC-sized value for
every possible input value, and then the computation required is reduced to a
table lookup, an XOR, and some bit shifts. For single-byte words this approach
may be practical, but it is unlikely to be worthwhile with 16- or 32-bit words.
Additionally, the table approach generally requires a latency of 2 cycles (one
extra to perform the table lookup). It's possible this would give better timing
in some circumstances, but at the cost of block RAM resources and latency.</p>
<h2 id="prior-art-3"><a class="header" href="#prior-art-3">Prior art</a></h2>
<p>The specification chosen for the CRC parameters is a popular de-facto standard,
and importantly the <a href="https://reveng.sourceforge.io/crc-catalogue/all.htm">reveng</a> catalogue lists suitable parameters for a wide
range of standard CRCs.</p>
<p>This particular implementation was written in 2020 and is extracted (with
permission) from a proprietary codebase, where it is used to generate a
variety of CRCs on FPGAs.</p>
<p>One early public example of using Amaranth to generate CRCs is from
<a href="https://gitlab.com/harmoninstruments/harmon-instruments-open-hdl/-/blob/master/Ethernet/CRC.py">Harmon Instruments</a>, also in 2020, which has a similar construction
but does not support the full set of CRC parameters.</p>
<p>In general, I found many examples of implementations of <em>specific</em> CRCs in
other HDLs, but few for generic generators. There are many software libraries
for generating CRCs in most programming languages, but as they are not
generating hardware their implementation details are not as relevant - small
table lookups are popular as the tradeoffs there tend to favour word-at-a-time
computations.</p>
<h2 id="unresolved-questions-3"><a class="header" href="#unresolved-questions-3">Unresolved questions</a></h2>
<ul>
<li>No outstanding unresolved questions.</li>
</ul>
<h2 id="future-possibilities-3"><a class="header" href="#future-possibilities-3">Future possibilities</a></h2>
<ul>
<li>
<p>The data interface uses <code>start</code>, <code>data</code>, and <code>valid</code> signals.
Eventually, this could be replaced with a Stream, once they are finalised.</p>
</li>
<li>
<p>Currently the entire input data word must be valid together; there is no
support for masking some bits off. In particular, such a feature could be
useful for wide data paths where the underlying CRC computation is byte-wise,
for example a 128-bit-wide data stream from a 10GbE MAC where the Ethernet
FCS must be computed over individual bytes. However, the implementation
complexity is high, the use cases seem more niche, and such a feature could
be added in a backwards-compatible later revision.</p>
</li>
<li>
<p>The software CRC computation only supports computing over an entire
set of data. It would be possible to offer an API to permit incremental
updates and finalisation.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2023-05-11</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/8">amaranth-lang/rfcs#8</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth/issues/772">amaranth-lang/amaranth#772</a></li>
</ul>
<h1 id="aggregate-data-structure-extensibility"><a class="header" href="#aggregate-data-structure-extensibility">Aggregate data structure extensibility</a></h1>
<h2 id="summary-6"><a class="header" href="#summary-6">Summary</a></h2>
<p>Provide well-defined extension points for the aggregate data structure library.</p>
<h2 id="motivation-6"><a class="header" href="#motivation-6">Motivation</a></h2>
<p><a href="0001-aggregate-data-structures.html">RFC 1</a> introduces the aggregate data structure library, which allows using any shape-castable object as the shape of a field. Layouts do not consider the specific type of the shape-castable object. However, views do, and depending on whether it's a layout, a subclass of an aggregate class (<code>Struct</code> or <code>Union</code>), or any other shape-castable object, behavior differs:</p>
<pre><code class="language-python">&gt;&gt;&gt; from amaranth import *
&gt;&gt;&gt; from amaranth.lib.data import *
&gt;&gt;&gt; class S(Struct):
...     x: unsigned(1)
...
&gt;&gt;&gt; layout = StructLayout({
...     &quot;a&quot;: unsigned(1),
...     &quot;b&quot;: ArrayLayout(unsigned(2), 4),
...     &quot;c&quot;: S
... })
...
&gt;&gt;&gt; View(layout).a
(slice (sig $signal) 0:1)
&gt;&gt;&gt; View(layout).b
&lt;amaranth.lib.data.View object at 0x7f53e46934c0&gt;
&gt;&gt;&gt; View(layout).c
&lt;__main__.S object at 0x7f53e4693a30&gt;
</code></pre>
<p>At the moment this behavior is not well-defined and it special-cases the aggregate classes defined in <code>amaranth.lib.data</code>.</p>
<h2 id="guide-level-explanation-4"><a class="header" href="#guide-level-explanation-4">Guide-level explanation</a></h2>
<p>Any shape-castable object can be used as the shape of a field in a layout. This includes another layout. If the object is a callable (provides a <code>__call__</code> method), then when a view is accessed, the <code>__call__</code> method will be called with a single argument, the slice of the underlying value, which will be returned by the view. A <code>Layout</code> is a callable that constructs a <code>View</code> from itself and the value.</p>
<h2 id="reference-level-explanation-4"><a class="header" href="#reference-level-explanation-4">Reference-level explanation</a></h2>
<p>The <code>Layout</code> class has a method <code>__call__</code>. <code>layout(value)</code> is equivalent to <code>View(layout, value)</code>.</p>
<p>The <code>View.__getitem__</code> method (and by extension <code>View.__getattr__</code>), after extracting a <code>field</code> from the layout, attempts to call <code>field.shape.__call__(value_slice)</code>, where <code>value_slice</code> is the slice of the underlying value corresponding to the field. If there is no such method, it iteratively calls <code>as_shape()</code> on <code>field.shape</code> or the result of the previous call to <code>as_shape()</code> until an object is returned that has a <code>__call__</code> method, or until an instance of <code>Shape</code> is returned.</p>
<h2 id="drawbacks-5"><a class="header" href="#drawbacks-5">Drawbacks</a></h2>
<ul>
<li>The syntax may be confusing.
<ul>
<li>Using <code>__call__</code> to implement construction is a widespread pattern in Python. Moreover, <code>Struct</code> and <code>Union</code> are classes, whose <code>__call__</code> method forwards to <code>__new__</code>, so implementing this behavior would remove the special case for aggregate base classes without additional code.</li>
</ul>
</li>
</ul>
<h2 id="rationale-and-alternatives-4"><a class="header" href="#rationale-and-alternatives-4">Rationale and alternatives</a></h2>
<p>This design is, as far as the author knows, the smallest possible addition that provides the largest possible extensibility and removes all special casing of aggregate base classes. That it requires no additional functionality to be implemented on the aggregate base classes indicates that it fits well into the existing design.</p>
<p>Alternatives:</p>
<ul>
<li>Do not do this.</li>
</ul>
<h2 id="prior-art-4"><a class="header" href="#prior-art-4">Prior art</a></h2>
<p>None.</p>
<h2 id="unresolved-questions-4"><a class="header" href="#unresolved-questions-4">Unresolved questions</a></h2>
<p>None.</p>
<h2 id="future-possibilities-4"><a class="header" href="#future-possibilities-4">Future possibilities</a></h2>
<p>None.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2023-05-11</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/9">amaranth-lang/rfcs#9</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth/issues/771">amaranth-lang/amaranth#771</a></li>
</ul>
<h1 id="constant-initialization-for-shape-castable-objects"><a class="header" href="#constant-initialization-for-shape-castable-objects">Constant initialization for shape-castable objects</a></h1>
<h2 id="summary-7"><a class="header" href="#summary-7">Summary</a></h2>
<p>Add an extension point to shape-castable objects, for converting constant initializers (typically Python literals) to Amaranth constant expressions.</p>
<h2 id="motivation-7"><a class="header" href="#motivation-7">Motivation</a></h2>
<p><a href="0001-aggregate-data-structures.html">RFC 1</a> specifies that the <code>reset=</code> argument of a <code>View</code> accepts structured data:</p>
<pre><code class="language-python">flt_neg_reset = data.View(float32_layout, reset={&quot;sign&quot;: 1})
</code></pre>
<p>This structured data is internally turned into an integer constant that is supplied to <code>Signal(reset=)</code>. This mechanism is not exposed to Amaranth developers. However, this creates a clear unmet need, since at the moment there is no way to turn a layout and a field-to-value mapping into a constant integer for use elsewhere.</p>
<p>For example, if a signal is created manually and not through the <code>View</code>, this will not work despite looking reasonable (the layout is shape-castable and can be supplied to <code>Signal</code>):</p>
<pre><code class="language-python">flt_neg_reset_signal = Signal(float32_layout, reset={&quot;sign&quot;: 1})
</code></pre>
<h2 id="guide-level-explanation-5"><a class="header" href="#guide-level-explanation-5">Guide-level explanation</a></h2>
<p>Shape-castable objects must, in addition to the mandatory <code>.as_shape()</code> method, implement a mandatory <code>.const(value)</code> method to define how a constant initializer (the reset value of a <code>Signal</code> or <code>View</code>) is converted to an Amaranth constant.</p>
<p>This method is defined by shape-castable objects to convert arbitrary Python objects into Amaranth constants. For example, if a shape-castable object has complex internal structure, it can accept a dictionary with the values to be filled into various bits of this structure. If <code>Shape</code> implemented <code>ShapeCastable</code>, the method would be defined as <code>def const(self, value): return Const(value, self)</code>.</p>
<p>The value returned by this method can be a <code>Const</code> or a value-castable object whose <code>.as_value()</code> will return a <code>Const</code>.</p>
<p>This method can also be directly called by the developer to construct a constant using a given shape-castable object.</p>
<h2 id="reference-level-explanation-5"><a class="header" href="#reference-level-explanation-5">Reference-level explanation</a></h2>
<p>A method <code>def const(self, obj):</code> is added on <code>ShapeCastable</code>.</p>
<p>The <code>Signal(shape, reset=)</code> constructor is changed so that if <code>isinstance(shape, ShapeCastable)</code>, then <code>shape.const(reset)</code> is used instead of <code>reset</code>.</p>
<p>The <code>.const()</code> instance method is implemented on <code>Layout</code> to accept a <code>Sequence</code> or <code>Mapping</code> instance and returns a <code>View</code> over a <code>Const</code> with a bit pattern that has the fields set to the given values. Overlapping fields are written in the order of iteration of the input. If the field shape is a shape-castable object, then the value for that field is computed using <code>Const.cast(value, field.shape)</code>.</p>
<p>The <code>.const()</code> method is implemented on the metaclass of <code>Struct</code> and <code>Union</code> as <code>return View(self, self.as_shape().const(obj))</code>.</p>
<p>The <code>View(..., reset=)</code> constructor is changed to pass <code>reset</code> through to the <code>Signal()</code> constructor.</p>
<h2 id="drawbacks-6"><a class="header" href="#drawbacks-6">Drawbacks</a></h2>
<ul>
<li>Additional method on <code>ShapeCastable</code>.
<ul>
<li>It was clear from the beginning that this functionality will likely be necessary, and we are unlikely to ever add more.</li>
</ul>
</li>
<li>The <code>reset=</code> argument becomes dependently typed.</li>
</ul>
<h2 id="rationale-and-alternatives-5"><a class="header" href="#rationale-and-alternatives-5">Rationale and alternatives</a></h2>
<p>Given:</p>
<pre><code class="language-python">class Point(Struct):
    x: 16
    y: 16
</code></pre>
<p>it is clear that there needs to be some way to go from <code>{&quot;x&quot;: 123, &quot;y&quot;: 456}</code> to <code>Cat(C(123, 16), C(456, 16))</code> without manually writing out the concatenation.</p>
<p>There are two main options for this:</p>
<ol>
<li>Implement a new method, such that <code>Point.const({&quot;x&quot;: 123, &quot;y&quot;: 456})</code> returns a constant of some kind (either an <code>int</code> or a <code>Const</code> or a constant-castable expression).</li>
<li>Implement an additional <code>.__init__()</code> override, such that <code>Point({&quot;x&quot;: 123, &quot;y&quot;: 456})</code> returns a view that has a constant-castable expression as its target.</li>
</ol>
<p>Option (1) has the benefit of making it clear when downstream code is creating a constant (and expects an argument where the nested data must all be constant), and of minimizing useless wrapping/unwrapping of views that would otherwise happen. It is an explicit type conversion (from a literal to <code>Const</code>).</p>
<p>Option (2) avoids introducing new names. It is an implicit type conversion (from a literal to a view, which in this case is <code>Point</code>).</p>
<p>In the end, option (1) seems preferable here since implicit type conversions are easy to unintentionally misuse. It also avoids any clashes with proposed RFC 8.</p>
<h2 id="prior-art-5"><a class="header" href="#prior-art-5">Prior art</a></h2>
<p>None.</p>
<h2 id="unresolved-questions-5"><a class="header" href="#unresolved-questions-5">Unresolved questions</a></h2>
<p>None.</p>
<h2 id="future-possibilities-5"><a class="header" href="#future-possibilities-5">Future possibilities</a></h2>
<p>None.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2023-05-11</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/10">amaranth-lang/rfcs#10</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth/issues/770">amaranth-lang/amaranth#770</a></li>
</ul>
<h1 id="move-repl-to-valuereplicate"><a class="header" href="#move-repl-to-valuereplicate">Move <code>Repl</code> to <code>Value.replicate</code></a></h1>
<h2 id="summary-8"><a class="header" href="#summary-8">Summary</a></h2>
<p>Replace the standalone <code>Repl(value, count)</code> node with <code>value.replicate(count)</code>.</p>
<h2 id="motivation-8"><a class="header" href="#motivation-8">Motivation</a></h2>
<p><code>Repl</code> is a <a href="https://github.com/search?q=%2F%5CbRepl%5Cb%2F+amaranth+language%3Apython&amp;type=code">rarely used</a> construct (it's mostly useful for manual sign extension).</p>
<p>It is currently a first-class entity that has its own AST node and a name in the prelude, mostly for historical reasons (<code>Repl(v, n)</code> is analogous to Verilog's <code>{x{n}}</code>).</p>
<p><code>Repl</code> does not need to be a first-class entity; <code>Repl(x, n)</code> is almost exactly equivalent to <code>Cat(x for x in range(n))</code>. It especially does not need a name in the prelude.</p>
<h2 id="guide-level-explanation-6"><a class="header" href="#guide-level-explanation-6">Guide-level explanation</a></h2>
<p>Use of <code>Repl</code> is deprecated. To replicate a value multiple times, use <code>value.replicate()</code>.</p>
<h2 id="reference-level-explanation-6"><a class="header" href="#reference-level-explanation-6">Reference-level explanation</a></h2>
<p>Direct use of <code>Repl</code> is deprecated. Its implementation is replaced with <code>def Repl(value, count): return Value.cast(value).replicate(count)</code>.</p>
<p>A function <code>Value.replicate(count)</code> is added. It is implemented as <code>Cat(value for _ in range(count))</code>. The <code>Repl</code> AST node is removed.</p>
<h2 id="drawbacks-7"><a class="header" href="#drawbacks-7">Drawbacks</a></h2>
<ul>
<li>Churn.</li>
<li>The proposed implementation makes <code>Value.replicate</code> valid on left-hand side of assignment, with potentially surprising behavior. However, this can be handled by prohibiting multiple assignment to the same bit of a signal in general.</li>
</ul>
<h2 id="rationale-and-alternatives-6"><a class="header" href="#rationale-and-alternatives-6">Rationale and alternatives</a></h2>
<p>Rationale:</p>
<ul>
<li>Fewer names in the prelude is always good.</li>
<li>Unlike with <code>Cat</code> (where <code>Cat()</code> makes sense), <code>Repl</code> does not make sense as a standalone node any more than <code>Part</code> does (and we do not currently export <code>Part</code>).</li>
<li>Despite existing by analogy with <code>{x{n}}</code>, it is currently turned into a concatenation before it reaches the Verilog backend <em>anyway</em>, and any future work will have to reconstruct replication from concatenation in any case.</li>
<li><code>Repl</code> being a dedicated node complicates AST processing for no reason.</li>
</ul>
<p>Alternatives:</p>
<ul>
<li>Do not do this.</li>
</ul>
<h2 id="prior-art-6"><a class="header" href="#prior-art-6">Prior art</a></h2>
<p>None.</p>
<h2 id="unresolved-questions-6"><a class="header" href="#unresolved-questions-6">Unresolved questions</a></h2>
<p>None.</p>
<h2 id="future-possibilities-6"><a class="header" href="#future-possibilities-6">Future possibilities</a></h2>
<ul>
<li>The Verilog backend currently bitblasts what could be a replication. We could detect these and convert them to replications proper.</li>
<li>We could detect code like <code>Cat(x, x).eq(0b11)</code> and warn or reject it.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2023-05-15</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/15">amaranth-lang/rfcs#15</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth/issues/784">amaranth-lang/amaranth#784</a></li>
</ul>
<h1 id="lifting-shape-castable-objects"><a class="header" href="#lifting-shape-castable-objects">Lifting shape-castable objects</a></h1>
<h2 id="summary-9"><a class="header" href="#summary-9">Summary</a></h2>
<p>Make <code>Signal(shape_castable, ...)</code> return <code>shape_castable(Signal(shape_castable.as_shape(), ...))</code>.</p>
<h2 id="motivation-9"><a class="header" href="#motivation-9">Motivation</a></h2>
<p>When Amaranth was a very new language, it did not have any facilities for ascribing type information to data. It had shapes (width and signedness), and it had special handling for <code>range()</code> in the shape position, as well as enumerations. Back then it made sense to have <code>Signal</code>, the single way to define new storage of any kind, to only operate on values (numbers / bit containers).</p>
<p>Today the situation is completely different. Amaranth has first-class support for enumerations in the standard library as well as the standard range of data structures (structs, unions, arrays) via <a href="0001-aggregate-data-structures.html">RFC 1</a> and <a href="0003-enumeration-shapes.html">RFC 3</a>. It provides extensibility through <a href="0008-aggregate-extensibility.html">RFC 8</a> and <a href="0009-const-init-shape-castable.html">RFC 9</a>. Using the existing hooks alone it is possible to extend Amaranth with rich numeric types (fixed-point, complex, potentially even floating-point), and some of these are very likely to end up in the standard library.</p>
<p>All of this new functionality internally wraps a <code>Value</code>. It is so common and useful to initialize e.g. a struct view with a fresh <code>Signal</code> that <code>data.View</code> reexports all of the arguments of the <code>Signal</code> constructors and automatically constructs a <code>Signal</code> if no view target is provided. This works, but ties the two together more than would be ideal, and requires every similar facility to reimplement the functionality itself. What is worse is that it seems to be quite confusing to programmers, since it's not apparent that calling <code>data.View(foo_layout)</code> internally creates a <code>Signal</code>. Furthermore, people want to call <code>Signal(foo_layout)</code> to construct some storage for <code>foo_layout</code>, and that works (<code>foo_layout</code> is shape-castable), but does the wrong thing: the returned object is a <code>Signal</code>, not a <code>data.View</code>.</p>
<p>It would make teaching a lot easier if we could draw an equivalence between a <code>Signal</code> and a variable in a general purpose programming language, and between its shape and a type in a general purpose programming language. Then, no matter what shape-castable object it is, the way to make some storage is <code>Signal(x)</code>. It will also simplify the internals a fair bit.</p>
<p>This change wasn't practical before <a href="0008-aggregate-extensibility.html">RFC 8</a> and <a href="0009-const-init-shape-castable.html">RFC 9</a> laid the groundwork for it, but now it is an obvious extension.</p>
<h2 id="guide-level-explanation-7"><a class="header" href="#guide-level-explanation-7">Guide-level explanation</a></h2>
<p>To include state in a design, use the <code>Signal(shape)</code> constructor, where <code>shape</code> describes the bit layout and possible operations on that state. The <code>reset=</code> argument and the returned value depend on the <code>shape</code> that is provided. If it is <code>signed(N)</code> or <code>unsigned(N)</code> or a built-in enumeration or a <code>range</code>, then a plain <code>Value</code> is returned, and the <code>reset=</code> argument accepts a number, an enumeration member, or a constant. If it is a <code>data.Layout</code>, then a <code>data.View</code> is returned, and the <code>reset=</code> argument accepts a sequence or a mapping, potentially nested for nested layouts. Other shape-castable classes will have their own behavior.</p>
<blockquote>
<p><strong>Warning</strong>
The existing syntax for creating a <code>View</code> with a new <code>Signal</code> underlying it will be removed immediately (it has never been in a release) to resolve an ambiguity over the semantics of <code>__call__</code>.</p>
</blockquote>
<h2 id="reference-level-explanation-7"><a class="header" href="#reference-level-explanation-7">Reference-level explanation</a></h2>
<p>A method <code>def __call__(self, value):</code> is added on <code>ShapeCastable</code>. It must return <code>Value</code> or a <code>ValueCastable</code> instance with the right shape. (Such a method is opportunistically used by <code>data.View</code> for nested views since <a href="0008-aggregate-extensibility.html">RFC 8</a>, however this RFC makes it mandatory for all shape-castable objects.)</p>
<p>The <code>Signal.__call__(shape, ...)</code> method is overridden (on the metaclass) to consider <code>shape</code>. First, a <code>signal</code> is constructed normally with all of the arguments. Afterwards, if <code>shape</code> is a <code>ShapeCastable</code> instance, then <code>shape(signal)</code> is returned. Otherwise <code>signal</code> is returned.</p>
<h2 id="drawbacks-8"><a class="header" href="#drawbacks-8">Drawbacks</a></h2>
<ul>
<li>Increase in language complexity.</li>
<li>More metaclasses.
<ul>
<li><code>Signal</code> is a final class so this is unlikely to go wrong.</li>
</ul>
</li>
<li>A <code>Signal()</code> constructor sometimes returning non-<code>Signal</code> objects can be confusing.</li>
</ul>
<h2 id="rationale-and-alternatives-7"><a class="header" href="#rationale-and-alternatives-7">Rationale and alternatives</a></h2>
<p>There are several arguments in favor of the design:</p>
<ul>
<li>It does not de facto introduce any new methods on protocols, since <code>ShapeCastable.__call__</code> is expected to be implemented by essentially everyone after <a href="0008-aggregate-extensibility.html">RFC 8</a>.</li>
<li>It does not introduce new complexity to <code>Signal.__init__</code>; the logic for handling non-integer reset exists since <a href="0009-const-init-shape-castable.html">RFC 9</a>.</li>
<li>It eliminates unnecessary coupling between <code>data.View</code> (and other similar facilities) and <code>Signal()</code>.</li>
<li>It is a natural extension of the language and has clear parallels to the notion of variables in other languages.</li>
<li>It has been repeatedly requested by users, almost every time someone became familiar with the aggregate data structure design.</li>
</ul>
<p>All of these points are compelling but the last one perhaps the most. The author did not find it a stark enough necessity to introduce themselves but it does seem to be one.</p>
<p>Alternatives:</p>
<ul>
<li>Do not do this. The status quo is acceptable.</li>
</ul>
<h2 id="prior-art-7"><a class="header" href="#prior-art-7">Prior art</a></h2>
<p>This RFC brings the semantics of <code>Signal</code> to be very close to semantics of typed variables in other languages.</p>
<p>&quot;Lifting&quot; in the title of this RFC refers to a <a href="https://wiki.haskell.org/Lifting">concept in functional programming</a> of the same name where a higher order function (<code>Signal</code>, here) is used to generalize an operation over a set of other functions (<code>data.View</code> and other shape-castable objects that implement the <code>__call__</code> protocol, here).</p>
<h2 id="unresolved-questions-7"><a class="header" href="#unresolved-questions-7">Unresolved questions</a></h2>
<ul>
<li>How does this interact with typechecking?
<ul>
<li>This is a straightforward higher order function so it's probably fine.</li>
</ul>
</li>
</ul>
<h2 id="future-possibilities-7"><a class="header" href="#future-possibilities-7">Future possibilities</a></h2>
<p>This RFC is the final one in a chain that started with <a href="0001-aggregate-data-structures.html">RFC 1</a>.</p>
<p>Enumerations and ranges could be adjusted such that something other than <code>Value</code> is returned. This creates backwards compatibility concerns though.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2024-02-02</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/16">amaranth-lang/rfcs#16</a></li>
<li>Amaranth SoC Issue: <a href="https://github.com/amaranth-lang/amaranth-soc/issues/68">amaranth-lang/amaranth-soc#68</a></li>
</ul>
<h1 id="csr-register-definition-rfc"><a class="header" href="#csr-register-definition-rfc">CSR register definition RFC</a></h1>
<h2 id="summary-10"><a class="header" href="#summary-10">Summary</a></h2>
<p>Add primitives to define CSR registers.</p>
<h2 id="motivation-10"><a class="header" href="#motivation-10">Motivation</a></h2>
<p>The Amaranth SoC library support for CSRs currently consists of bus primitives behind which multiple registers can be gathered.</p>
<p>Its current notion of a CSR register is limited to the <code>csr.Element</code> class, which provides an interface between a register and a CSR bus. The information we have about a register is limited to its width and access mode (necessary to determine the layout of <code>csr.Element</code>), in addition to its name and address. This information can then be aggregated by walking through the memory map of a SoC, to generate header files (and documentation, etc) for use by firmware.</p>
<p>However, amaranth-soc lacks the notion of register fields. The CSR bus acts as a transport and isn't concerned about fields. Peripherals often expose their functionality using multiple fields of a register, and initiators (e.g. a CPU running firmware) need to be aware of them.</p>
<p>In addition, users must currently implement their own register primitives, which adds boilerplate.</p>
<p>This RFC aims to add a standard implementation of a CSR register, while building upon the existing infrastructure.</p>
<h2 id="guide-level-explanation-8"><a class="header" href="#guide-level-explanation-8">Guide-level explanation</a></h2>
<p>Currently, the implementation of a CSR register is left to the user, as amaranth-soc only requires the use of <code>csr.Element</code> as its interface:</p>
<pre><code class="language-python3">class UARTPeripheral(Elaboratable):
    def __init__(self):
        self._phy = AsyncSerial(divisor=int(100e6//115200), data_width=8)

        self._divisor = csr.Element(self._phy.divisor.width, &quot;rw&quot;)
        self._rx_rdy  = csr.Element(1, &quot;r&quot;)
        self._rx_err  = csr.Element(1, &quot;r&quot;)

        self._csr_mux = csr.Multiplexer(addr_width=4, data_width=32)
        self._csr_mux.add(self._divisor)
        self._csr_mux.add(self._rx_rdy)
        self._csr_mux.add(self._rx_err)

        self.bus = self._csr_mux.bus

    def elaborate(self, platform):
        m = Module()
        m.submodules.phy     = self._phy
        m.submodules.csr_mux = self._csr_mux

        m.d.comb += self._divisor.r_data.eq(self._phy.divisor)

        with m.If(self._divisor.w_stb):
            m.d.sync += self._phy.divisor.eq(self._divisor.w_data)

        # ...

        return m
</code></pre>
<p>This RFC adds register primitives to amaranth-soc, which are defined by subclassing <code>csr.Register</code>:</p>
<pre><code class="language-python3">class UARTPeripheral(wiring.Component):
    # A register with a parameterized width and reset value:
    class Divisor(csr.Register, access=&quot;rw&quot;):
        def __init__(self, *, width, reset):
            super().__init__({
                &quot;divisor&quot;: csr.Field(csr.action.RW, width, reset=reset),
            })

    # A simple register, with reserved fields:
    class RxStatus(csr.Register, access=&quot;r&quot;):
        rdy : csr.Field(csr.action.R,       unsigned(1))
        _0  : csr.Field(csr.action.ResRAW0, unsigned(3))
        err : csr.Field(csr.action.R,       unsigned(1))
        _1  : csr.Field(csr.action.ResRAW0, unsigned(3))

    class RxData(csr.Register, access=&quot;r&quot;):
        data : csr.Field(csr.action.R, unsigned(8))

    def __init__(self, *, divisor):
        self._phy = AsyncSerial(divisor=int(100e6//115200), data_width=8)

        regs = csr.Builder(addr_width=4, data_width=8)

        self._divisor = regs.add(&quot;divisor&quot;, self.Divisor(width=bits_for(divisor), reset=divisor))

        with regs.Cluster(&quot;rx&quot;):
            self._rx_status = regs.add(&quot;status&quot;, self.RxStatus(), offset=3)
            self._rx_data   = regs.add(&quot;data&quot;,   self.RxData(),   offset=4)

        self._bridge = csr.Bridge(regs.as_memory_map())

        super().__init__({
            &quot;bus&quot;: In(csr.Signature(addr_width=4, data_width=8))
        })
        self.bus.memory_map = self._bridge.bus.memory_map

    def elaborate(self, platform):
        m = Module()

        m.submodules.phy    = self._phy
        m.submodules.bridge = self._bridge

        m.submodules.rx_fifo = rx_fifo = SyncFIFOBuffered(width=8 + 1, depth=16)

        m.d.comb += [
            # Reading a field from the peripheral side:
            self._phy.divisor.eq(self.divisor.f.divisor.data),

            rx_fifo.w_en  .eq(self._phy.rx.rdy),
            rx_fifo.w_data.eq(Cat(self._phy.rx.data, self._phy.rx.err)),
            self._phy.rx.ack.eq(rx_fifo.w_rdy),

            # Writing to a field from the peripheral side:
            self._rx_status.f.rdy.r_data.eq(rx_fifo.r_rdy),
            self._rx_status.f.err.r_data.eq(rx_fifo.r_data[-1]),

            # Consuming data from a FIFO, as a side-effect from a bus read:
            self._rx_data.f.data.r_data.eq(rx_fifo.r_data[:8]),
            rx_fifo.r_en.eq(self._rx_data.f.data.r_stb),
        ]

        return m
</code></pre>
<h3 id="register-definitions"><a class="header" href="#register-definitions">Register definitions</a></h3>
<p>The fields of a <code>Register</code> instance can be defined in two different ways:</p>
<ul>
<li>using <a href="https://peps.python.org/pep-0526/">PEP 526</a> variable annotations.</li>
<li>by calling <code>Register.__init__()</code> with a non-default <code>fields</code> argument.</li>
</ul>
<p>Variable annotations are suitable for simple use-cases, whereas overriding <code>Register.__init__()</code> allows field definitions to be parameterized.</p>
<pre><code class="language-python3">class UARTPeripheral(Elaboratable):
    class Divisor(csr.Register, access=&quot;rw&quot;):
        def __init__(self, *, width, reset):
            super().__init__({
                &quot;divisor&quot;: csr.Field(csr.action.RW, width, reset=reset),
            })

    class RxStatus(csr.Register, access=&quot;r&quot;):
        rdy : csr.Field(csr.action.R,       unsigned(1))
        _0  : csr.Field(csr.action.ResRAW0, unsigned(3))
        err : csr.Field(csr.action.R,       unsigned(1))
        _1  : csr.Field(csr.action.ResRAW0, unsigned(3))

    class RxData(csr.Register, access=&quot;r&quot;):
        data : csr.Field(csr.action.R, unsigned(8))

    ...
</code></pre>
<h3 id="field-access-and-ownership"><a class="header" href="#field-access-and-ownership">Field access and ownership</a></h3>
<p>The <code>csr.action</code> class definitions differ by their access mode.</p>
<p>For example, <code>csr.action.R</code> describes a field that is:</p>
<ul>
<li><em>read-only</em> from the point-of-view of a <em>bus initiator</em> (such as a CPU);</li>
<li><em>read/write</em> from the point-of-view of the peripheral;</li>
</ul>
<p>Whereas <code>csr.action.RW</code> describes a field that is:</p>
<ul>
<li><em>read/write</em> from the point-of-view of a CPU</li>
<li><em>read-only</em> from the point-of-view of the peripheral</li>
</ul>
<p>In this RFC, write access is defined by ownership. A register field can only be written to by its owner(s). For example:</p>
<ul>
<li>a <code>csr.action.R</code> field is owned by the peripheral;</li>
<li>a <code>csr.action.RW</code> field is owned by the bus initiator.</li>
</ul>
<p>In the <code>UARTPeripheral</code> example above, each register field has a single owner. This effectively removes the possibility of a write conflict between a CPU and the peripheral.</p>
<p>Otherwise, in case of shared ownership, deciding which transaction has precedence is context-dependent.</p>
<h3 id="flag-fields"><a class="header" href="#flag-fields">Flag fields</a></h3>
<p>Flag fields may be writable by both the bus initiator and the peripheral. Flag fields are distinct from other kinds of fields, as each bit may be set or cleared independently of others.</p>
<p>This RFC provides two types of flag:</p>
<ul>
<li><code>csr.action.RW1C</code> (read/write-one-to-clear) flags may be used when a peripheral needs to notify a CPU of a condition (e.g. an error or a pending interrupt). The CPU clears the flag to acknowledge it. If a write conflict occurs, setting the bit from the peripheral side would have precedence.</li>
<li><code>csr.action.RW1S</code> (read/write-one-to-set) flags may be used for self-clearing bits, such as the enable bit of a one-shot timer. When the counter reaches its maximum value, it would automatically disable itself by clearing the enable bit. If a write conflict occurs, setting the bit from the CPU side would have precedence.</li>
</ul>
<p>A use case that involves both <code>RW1C</code> and <code>RW1S</code> fields would be a register driving an array of GPIO pins. Their values may be set or cleared by a CPU. In a multitasked environment, a read-modify-write transaction would require locking to insure atomicity; whereas having two fields (<code>RW1S</code> and <code>RW1C</code>) targeting the same flags allows a CPU to set or clear any of them in a single write transaction.</p>
<h3 id="reserved-fields"><a class="header" href="#reserved-fields">Reserved fields</a></h3>
<p>Reserved fields may be defined to provide placeholders for past, future or undocumented functions.</p>
<p>This RFC provides four types of reserved fields:</p>
<ul>
<li><code>csr.action.ResRAW0</code> (read-any/write-zero)</li>
<li><code>csr.action.ResRAWL</code> (read-any/write-last)</li>
<li><code>csr.action.ResR0WA</code> (read-zero/write-any)</li>
<li><code>csr.action.ResR0W0</code> (read-zero/write-zero)</li>
</ul>
<h4 id="example-use-cases-for-reserved-fields"><a class="header" href="#example-use-cases-for-reserved-fields">Example use cases for reserved fields</a></h4>
<h5 id="one-time-programmable-fuse"><a class="header" href="#one-time-programmable-fuse">One-Time Programmable fuse</a></h5>
<ul>
<li>Field type: <code>ResRAW0</code> (read-any/write-zero)</li>
<li>Reads return the fuse state. Writing 1 will blow the fuse.</li>
</ul>
<h5 id="reserved-for-future-use-as-value"><a class="header" href="#reserved-for-future-use-as-value">Reserved for future use (as value)</a></h5>
<ul>
<li>Field type: <code>ResRAWL</code> (read-any/write-last)</li>
<li>Software drivers need to be aware of such fields, to ensure forward compatibility of software binaries with future silicon versions.</li>
<li>Software drivers are assumed to access such fields by setting up an atomic read-modify-write transaction.</li>
<li>The value returned by reads (and written back) must have defined semantics (e.g. a no-op) that can be relied upon in future silicon versions.</li>
</ul>
<h5 id="reserved-for-future-use-as-flag"><a class="header" href="#reserved-for-future-use-as-flag">Reserved for future use (as flag)</a></h5>
<ul>
<li>Field type: <code>ResRAW0</code> (read-any/write-zero)</li>
<li>Software drivers need to be aware of such fields, to ensure forward compatibility of software binaries with future silicon versions.</li>
<li>Software drivers do not need a read-modify-write transaction to write these fields.</li>
<li>Software drivers should ignore the value returned by reads.</li>
<li>Writing a value of 0 is a no-op for <code>RW1C</code> and <code>RW1S</code> flags, if implemented by future silicon versions.</li>
</ul>
<h5 id="defined-but-deprecated"><a class="header" href="#defined-but-deprecated">Defined, but deprecated</a></h5>
<ul>
<li>Field type: <code>ResR0WA</code> (read-zero/write-any)</li>
<li>Such fields may be used as placeholders for phased out fields from previous silicon versions. They are required for backward compatibility with existing software binaries.</li>
<li>The value of 0 returned by reads (and written back) must have defined semantics (e.g. a no-op).</li>
</ul>
<h5 id="defined-but-unimplemented"><a class="header" href="#defined-but-unimplemented">Defined, but unimplemented</a></h5>
<ul>
<li>Field type: <code>ResR0W0</code> (read-zero/write-zero)</li>
<li>Such fields may be used to provide variants of a peripheral IP, and facilitate code re-use in software drivers.</li>
<li>For example on STM32F0x SoCs, the CR1.CKD field (clock divider ratio) is read/write in the &quot;general-purpose&quot; timer TIM14 , but always reads 0 in the &quot;basic&quot; timer TIM6.</li>
</ul>
<h3 id="accessing-register-fields-from-peripherals"><a class="header" href="#accessing-register-fields-from-peripherals">Accessing register fields from peripherals</a></h3>
<pre><code class="language-python3">class UARTPeripheral(Elaboratable):
    ...

    def elaborate(self, platform):
        ...

        m.d.comb += [
            self._phy.divisor.eq(self._divisor.f.divisor.data),

            ...

            self._rx_status.f.rdy.r_data.eq(rx_fifo.r_rdy),
            self._rx_status.f.err.r_data.eq(rx_fifo.r_data[-1]),

            self._rx_data.f.data.r_data.eq(rx_fifo.r_data[:8]),
            rx_fifo.r_en.eq(self._rx_data.f.data.r_stb),
        ]

        ...
</code></pre>
<p>From the peripheral side, fields are exposed by the <code>&lt;reg&gt;.f</code> attribute of the <code>csr.Register</code> they belong to.</p>
<h5 id="access-strobes"><a class="header" href="#access-strobes">Access strobes</a></h5>
<p>Peripherals can sample access strobes of <code>csr.action.R</code> and <code>csr.action.W</code> fields to perform side-effects:</p>
<ul>
<li><code>&lt;reg&gt;.f.&lt;field&gt;.r_stb</code> is asserted when the register is read from the CSR bus (i.e. it is hardwired to <code>&lt;reg&gt;.element.r_stb</code>);</li>
<li><code>&lt;reg&gt;.f.&lt;field&gt;.w_stb</code> is asserted when the register is written by the CSR bus (i.e. it is hardwired to <code>&lt;reg&gt;.element.w_stb</code>).</li>
</ul>
<h5 id="data"><a class="header" href="#data">Data</a></h5>
<ul>
<li><code>&lt;reg&gt;.f.&lt;field&gt;.w_data</code> is driven by the register if the field is write-only by the bus (i.e. <code>W</code>), and hardwired to a slice of <code>&lt;reg&gt;.element.w_data</code>.</li>
<li><code>&lt;reg&gt;.f.&lt;field&gt;.r_data</code> is driven by the peripheral if the field is read-only by the bus (i.e. <code>R</code>), and hardwired to a slice of <code>&lt;reg&gt;.element.r_data</code>.</li>
<li><code>&lt;reg&gt;.f.&lt;field&gt;.data</code> is driven by the register (with the value held in its storage), if the field is read-write for the bus (i.e. <code>RW</code>, <code>RW1C</code>, <code>RW1S</code>). It is updated one clock cycle after <code>&lt;reg&gt;.element.w_stb</code> is high (on the <code>sync</code> clock domain by default).</li>
<li><code>&lt;reg&gt;.f.&lt;field&gt;.set</code> is driven by the peripheral to set bits of a field that can be cleared by the bus (i.e. <code>RW1C</code>).</li>
<li><code>&lt;reg&gt;.f.&lt;field&gt;.clear</code> is driven by the peripheral to clear bits of a field that can be set by the bus (i.e. <code>RW1S</code>).</li>
</ul>
<h3 id="building-registers"><a class="header" href="#building-registers">Building registers</a></h3>
<p>The <code>csr.Builder</code> provides fine-grained control over the address space occupied by the CSR registers of a peripheral. Registers may be organized into a hierarchy of clusters and arrays, which can be composed together (e.g. into an array of clusters, a multi-dimensional array, etc).</p>
<p>For example, an (artificially simplified) interrupt controller could use a 2-dimensional array of registers:</p>
<pre><code class="language-python3">regs = csr.Builder(addr_width=csr_addr_width, data_width=32, granularity=8):

# For each CPU core and each group of 32 interrupts, add two registers: &quot;IE&quot; and &quot;IP&quot;.
for i in range(nb_cpu_cores):
    with regs.Index(i):
        for j in range(ceil(nb_intr_sources / 32)):
            with regs.Index(j):
                self.ie[i][j] = regs.add(&quot;IE&quot;, self.IE(width=32))
                self.ip[i][j] = regs.add(&quot;IP&quot;, self.IP(width=32))
</code></pre>
<p><code>regs.as_memory_map()</code> will create a <code>MemoryMap</code> containing those registers, which can be passed to a <code>csr.Bridge</code> to expose them over a CSR bus.</p>
<h2 id="reference-level-explanation-8"><a class="header" href="#reference-level-explanation-8">Reference-level explanation</a></h2>
<h3 id="fields"><a class="header" href="#fields">Fields</a></h3>
<h4 id="csrregfieldportaccess"><a class="header" href="#csrregfieldportaccess"><code>csr.reg.FieldPort.Access</code></a></h4>
<p>The <code>FieldPort.Access</code> enum defines the supported access modes of a field, with:</p>
<ul>
<li>the following values: <code>R</code>, <code>W</code>, <code>RW</code> and <code>NC</code> (not connected);</li>
<li>a <code>.readable(self)</code> method, which returns <code>True</code> if <code>self</code> is <code>R</code> or <code>RW</code>;</li>
<li>a <code>.writable(self)</code> method, which returns <code>True</code> if <code>self</code> is <code>W</code> or <code>RW</code>.</li>
</ul>
<h4 id="csrregfieldport"><a class="header" href="#csrregfieldport"><code>csr.reg.FieldPort</code></a></h4>
<p>The <code>FieldPort</code> class describes the interface between a register field and the register itself, with:</p>
<ul>
<li>a <code>.__init__(self, shape, access)</code> constructor, where <code>shape</code> is a shape-castable and <code>access</code> is a <code>FieldPort.Access</code> value;</li>
<li>a <code>.shape</code> property;</li>
<li>a <code>.access</code> property;</li>
</ul>
<h4 id="csrregfieldportsignature"><a class="header" href="#csrregfieldportsignature"><code>csr.reg.FieldPort.Signature</code></a></h4>
<p>The <code>FieldPort.Signature</code> class describes the signature of a <code>FieldPort</code>, with:</p>
<ul>
<li>a <code>.__init__(self, shape, access)</code> constructor, where <code>shape</code> is a shape-castable and <code>access</code> is a <code>FieldPort.Access</code> value;</li>
<li>a <code>.shape</code> property;</li>
<li>a <code>.access</code> property;</li>
<li>a <code>.create(self, path=None, src_loc_at=0)</code> method that returns a compatible <code>FieldPort</code> object;</li>
<li>a <code>.__eq__(self, other)</code> method that returns <code>True</code> if both <code>self</code> and <code>other</code> have the same shape and access mode.</li>
</ul>
<h5 id="signature-members"><a class="header" href="#signature-members">Signature members</a></h5>
<p>The members of a <code>FieldPort.Signature</code> are defined as follows:</p>
<pre><code class="language-python3">{
    &quot;r_data&quot;: In(self.shape),
    &quot;r_stb&quot;:  Out(1),
    &quot;w_data&quot;: In(self.shape),
    &quot;w_stb&quot;:  Out(1)
}
</code></pre>
<p>The access mode of a <code>FieldPort.Signature</code> has no influence on its members (e.g. <code>w_data</code> and <code>w_stb</code> are present even if <code>access.writable()</code> returns <code>False</code>).</p>
<h4 id="csrregfieldaction"><a class="header" href="#csrregfieldaction"><code>csr.reg.FieldAction</code></a></h4>
<p>The <code>FieldAction</code> class is a <code>Component</code> subclass implementing the behavior of a register field, with:</p>
<ul>
<li>a <code>.__init__(self, shape, access, members=()</code> constructor, where:
<ul>
<li><code>shape</code> is a shape-castable;</li>
<li><code>access</code> is a <code>FieldPort.Access</code> value;</li>
<li><code>members</code> is an iterable of key/value pairs, where keys are strings and values are signature members.</li>
</ul>
</li>
<li>a <code>.signature</code> property, that returns a <code>Signature</code> with the following members:</li>
</ul>
<pre><code class="language-python3">{
    &quot;port&quot;: In(FieldPort.Signature(shape, access)),
    **members
}
</code></pre>
<p>where <code>shape</code>, <code>access</code> and <code>members</code> are provided in <code>.__init__()</code>.</p>
<h4 id="csrregfield"><a class="header" href="#csrregfield"><code>csr.reg.Field</code></a></h4>
<p>The <code>Field</code> class serves as a factory for builtin or user-defined <code>FieldAction</code>s, with:</p>
<ul>
<li>a <code>.__init__(self, action_cls, *args, **kwargs)</code> constructor, where:
<ul>
<li><code>action_cls</code> is a <code>FieldAction</code> subclass;</li>
<li><code>*args</code> and <code>**kwargs</code> are arguments passed to <code>action_cls.__init__()</code>;</li>
</ul>
</li>
<li>a <code>.create(self)</code> method that returns <code>action_cls(*args, **kwargs)</code>.</li>
</ul>
<h4 id="csrregfieldactionmap"><a class="header" href="#csrregfieldactionmap"><code>csr.reg.FieldActionMap</code></a></h4>
<p>The <code>FieldActionMap</code> class describes an immutable mapping of <code>FieldAction</code> objects, with:</p>
<ul>
<li>a <code>.__init__(self, fields)</code> constructor, where <code>fields</code> is a dict of strings to either <code>Field</code> objects, nested dicts or lists;</li>
<li>a <code>.__getitem__(self, key)</code> method to lookup a field instance by name, without recursion;</li>
<li>a <code>.__getattr__(self, name)</code> method to lookup a field instance by name, without recursion and excluding fields whose name start with <code>&quot;_&quot;</code>;</li>
<li>a <code>.flatten(self)</code> method that yields for each field, a tuple containing its path (as a tuple of names or indices) and its instance.</li>
</ul>
<p>A <code>FieldActionMap</code> contains instances of the fields given in <code>__init__()</code>:</p>
<ul>
<li><code>Field</code> objects are instantiated as <code>FieldAction</code> by calling <code>Field.create()</code>;</li>
<li><code>dict</code> objects are instantiated as <code>FieldActionMap</code>;</li>
<li><code>list</code> objects  are instantiated as <code>FieldActionArray</code>.</li>
</ul>
<p>A <code>FieldActionMap</code> preserves the iteration order of its fields, from least significant to most significant.</p>
<h4 id="csrregfieldactionarray"><a class="header" href="#csrregfieldactionarray"><code>csr.reg.FieldActionArray</code></a></h4>
<p>The <code>FieldActionArray</code> class describes an immutable sequence of <code>FieldAction</code> objects, with:</p>
<ul>
<li>a <code>.__init__(self, fields)</code> constructor, where <code>fields</code> is a list of either <code>Field</code> objects, nested dicts or lists;</li>
<li>a <code>.__getitem__(self, key)</code> method to lookup a field instance by index, without recursion;</li>
<li>a <code>.flatten(self)</code> method that yields for each field, a tuple containing its path (as a tuple of names or indices) and its instance.</li>
</ul>
<p>A <code>FieldActionArray</code> contains instances of the fields given in <code>__init__()</code>:</p>
<ul>
<li><code>Field</code> objects are instantiated as <code>FieldAction</code> by calling <code>Field.create()</code>;</li>
<li><code>dict</code> objects are instantiated as <code>FieldActionMap</code>;</li>
<li><code>list</code> objects  are instantiated as <code>FieldActionArray</code>.</li>
</ul>
<p>A <code>FieldActionArray</code> preserves the iteration order of its fields, from least significant to most significant.</p>
<h3 id="built-in-field-actions"><a class="header" href="#built-in-field-actions">Built-in field actions</a></h3>
<h4 id="csractionr"><a class="header" href="#csractionr"><code>csr.action.R</code></a></h4>
<p>The <code>csr.action.R</code> class describes a read-only <code>FieldAction</code>, with:</p>
<ul>
<li>a <code>.__init__(self, shape)</code> constructor, where <code>shape</code> is a shape-castable;</li>
<li>a <code>.signature</code> property, that returns a <code>Signature</code> with the following members:</li>
</ul>
<pre><code class="language-python3">{
    &quot;port&quot;:   In(FieldPort.Signature(shape, access=&quot;r&quot;)),
    &quot;r_data&quot;: In(shape),
    &quot;r_stb&quot;:  Out(unsigned(1)),
}
</code></pre>
<ul>
<li>a <code>.elaborate(self, platform)</code> method, where <code>self.r_data</code> and <code>self.r_stb</code> are connected to <code>self.port.r_data</code> and <code>self.port.r_stb</code>.</li>
</ul>
<h4 id="csractionw"><a class="header" href="#csractionw"><code>csr.action.W</code></a></h4>
<p>The <code>csr.action.W</code> class describes a write-only <code>FieldAction</code>, with:</p>
<ul>
<li>a <code>.__init__(self, shape)</code> constructor, where <code>shape</code> is a shape-castable.</li>
<li>a <code>.signature</code> property, that returns a <code>Signature</code> with the following members:</li>
</ul>
<pre><code class="language-python3">{
    &quot;port&quot;:   In(FieldPort.Signature(shape, access=&quot;w&quot;)),
    &quot;w_data&quot;: Out(shape),
    &quot;w_stb&quot;:  Out(unsigned(1)),
}
</code></pre>
<ul>
<li>a <code>.elaborate(self, platform)</code> method, where <code>self.port.w_data</code> and <code>self.port.w_stb</code> are connected to <code>self.w_data</code> and <code>self.port.w_stb</code>.</li>
</ul>
<h4 id="csractionrw"><a class="header" href="#csractionrw"><code>csr.action.RW</code></a></h4>
<p>The <code>csr.action.RW</code> class describes a read-write <code>FieldAction</code>, with:</p>
<ul>
<li>a <code>.__init__(self, shape, reset=0)</code> constructor, where <code>shape</code> is a shape-castable and <code>reset</code> is a const-castable defining the reset value of internal storage;</li>
<li>a <code>.reset</code> property;</li>
<li>a <code>.signature</code> property, that returns a <code>Signature</code> with the following members:</li>
</ul>
<pre><code class="language-python3">{
    &quot;port&quot;: In(FieldPort.Signature(shape, access=&quot;rw&quot;)),
    &quot;data&quot;: Out(shape)
}
</code></pre>
<ul>
<li>a <code>.elaborate(self, platform)</code> method, where <code>self.port.w_data</code> is used to synchronously write internal storage. Storage output is connected to <code>self.data</code> and <code>self.port.r_data</code>.</li>
</ul>
<h4 id="csractionrw1c"><a class="header" href="#csractionrw1c"><code>csr.action.RW1C</code></a></h4>
<p>The <code>csr.action.RW1C</code> class describes a read-write <code>FieldAction</code>, with:</p>
<ul>
<li>a <code>.__init__(self, shape, reset=0)</code> constructor, where <code>shape</code> is a shape-castable and <code>reset</code> is a const-castable defining the reset value of internal storage.</li>
<li>a <code>.reset</code> property;</li>
<li>a <code>.signature</code> property, that returns a <code>Signature</code> with the following members:</li>
</ul>
<pre><code class="language-python3">{
    &quot;port&quot;: In(FieldPort.Signature(shape, access=&quot;rw&quot;)),
    &quot;data&quot;: Out(shape),
    &quot;set&quot;:  In(shape)
}
</code></pre>
<ul>
<li>a <code>.elaborate(self, platform)</code> method, where high bits in <code>self.port.w_data</code> and <code>self.port.set</code> are used to synchronously clear and set internal storage, respectively. Storage output is connected to <code>self.data</code> and <code>self.port.r_data</code>.</li>
</ul>
<h4 id="csractionrw1s"><a class="header" href="#csractionrw1s"><code>csr.action.RW1S</code></a></h4>
<p>The <code>csr.action.RW1S</code> class describes a read-write <code>FieldAction</code>, with:</p>
<ul>
<li>a <code>.__init__(self, shape, reset=0)</code> constructor, where <code>shape</code> is a shape-castable and <code>reset</code> is a const-castable defining the reset value of internal storage;</li>
<li>a <code>.reset</code> property;</li>
<li>a <code>.signature</code> property, that returns a <code>Signature</code> with the following members:</li>
</ul>
<pre><code class="language-python3">{
    &quot;port&quot;:  In(FieldPort.Signature(shape, access=&quot;rw&quot;)),
    &quot;data&quot;:  Out(shape),
    &quot;clear&quot;: In(shape)
}
</code></pre>
<ul>
<li>a <code>.elaborate(self, platform)</code> method, where high bits in <code>self.port.w_data</code> and <code>self.port.clear</code> are used to synchronously set and clear internal storage, respectively. Storage output is connected to <code>self.data</code> and <code>self.port.r_data</code>.</li>
</ul>
<h3 id="built-in-reserved-field-actions"><a class="header" href="#built-in-reserved-field-actions">Built-in reserved field actions</a></h3>
<h4 id="csractionresraw0-csractionresrawl-csractionresr0wa-csractionresr0w0"><a class="header" href="#csractionresraw0-csractionresrawl-csractionresr0wa-csractionresr0w0"><code>csr.action.ResRAW0</code>, <code>csr.action.ResRAWL</code>, <code>csr.action.ResR0WA</code>, <code>csr.action.ResR0W0</code></a></h4>
<p>These classes describe a reserved <code>FieldAction</code>, with:</p>
<ul>
<li>a <code>.__init__(self, shape)</code> constructor, where <code>shape</code> is a shape-castable;</li>
<li>a <code>.signature</code> property, that returns a <code>Signature</code> with the following members:</li>
</ul>
<pre><code class="language-python3">{
    &quot;port&quot;:  In(FieldPort.Signature(shape, access=&quot;nc&quot;)),
}
</code></pre>
<ul>
<li>a <code>.elaborate(self, platform)</code> method, that returns an empty <code>Module()</code>.</li>
</ul>
<h3 id="registers"><a class="header" href="#registers">Registers</a></h3>
<h4 id="csrregregister"><a class="header" href="#csrregregister"><code>csr.reg.Register</code></a></h4>
<p>The <code>csr.reg.Register</code> class describes a CSR register <code>Component</code>, with:</p>
<ul>
<li>a <code>.__init_subclass__(cls, access=None, **kwargs)</code> class method, where <code>access</code> is either a <code>csr.Element.Access</code> value, or <code>None</code>.</li>
<li>a <code>.__init__(self, fields=None, access=None)</code> constructor, where:
<ul>
<li><code>fields</code> is either:
<ul>
<li>a <code>dict</code> that will be instantiated as a <code>FieldActionMap</code>;</li>
<li>a <code>list</code> that will be instantiated as a <code>FieldActionArray</code>;</li>
<li><code>None</code>; in this case a <code>FieldActionMap</code> is instantiated from <code>Field</code> objects in variable annotations.</li>
</ul>
</li>
<li><code>access</code> is either a <code>csr.Element.Access</code> value, or <code>None</code>.</li>
</ul>
</li>
<li>a <code>.fields</code> property, returning a <code>FieldActionMap</code> or a <code>FieldActionArray</code>;</li>
<li>a <code>.f</code> property, as a shorthand to <code>self.fields</code>;</li>
<li>a <code>.__iter__(self)</code> method, as a shorthand to <code>self.fields.flatten()</code>;</li>
<li>a <code>.signature</code> property, that returns a <code>Signature</code> with the following members:</li>
</ul>
<pre><code class="language-python3">{
    &quot;element&quot;: Out(Element.Signature(width, access))
}
</code></pre>
<p>where <code>width</code> is the total width of the register, i.e. <code>sum(Shape.cast(f.port.shape).width for _, f in self</code>.</p>
<ul>
<li>a <code>.elaborate(self, platform)</code> method, that connects fields to slices of <code>self.element</code>, depending on their access mode;</li>
</ul>
<h5 id="element-access-mode"><a class="header" href="#element-access-mode">Element access mode</a></h5>
<p>The <code>access</code> parameter must be provided in <code>__init_subclass__()</code> or <code>__init__()</code>. A <code>ValueError</code> is raised in <code>__init__()</code> if:</p>
<ul>
<li><code>access</code> is provided in neither method;</li>
<li><code>access</code> is provided in both methods with different values.</li>
</ul>
<h4 id="csrregbuilder"><a class="header" href="#csrregbuilder"><code>csr.reg.Builder</code></a></h4>
<p>The <code>csr.reg.Builder</code> class can build a <code>MemoryMap</code> from a group of <code>csr.Register</code> objects, with:</p>
<ul>
<li>
<p>a <code>.__init__(self, *, addr_width, data_width, granularity=8, name=None)</code> constructor that:</p>
<ul>
<li>raises a <code>TypeError</code> if <code>addr_width</code>, <code>data_width</code> and <code>granularity</code> are not positive integers;</li>
<li>raises a <code>ValueError</code> if <code>granularity</code> is not a divisor of <code>data_width</code>.</li>
</ul>
</li>
<li>
<p><code>.addr_width</code>, <code>.data_width</code>, <code>.granularity</code> and <code>.name</code> properties;</p>
</li>
<li>
<p>a <code>.freeze(self)</code> method, which renders the visible state of the <code>csr.Builder</code> immutable;</p>
</li>
<li>
<p>a <code>.add(self, name, register, *, offset=None)</code> method, which:</p>
<ul>
<li>adds <code>register</code> to the builder;</li>
<li>returns <code>register</code>;</li>
<li>raises a <code>ValueError</code> if <code>self</code> is frozen;</li>
<li>raises a <code>TypeError</code> if <code>register</code> is not a <code>Register</code> object;</li>
<li>raises a <code>ValueError</code> if <code>register</code> is already present;</li>
<li>raises a <code>TypeError</code> if <code>name</code> is not a non-empty string;</li>
<li>raises a <code>ValueError</code> if <code>name</code> is already assigned to another register or <code>Cluster</code>.</li>
<li>raises a <code>TypeError</code> if <code>offset</code> is neither a positive integer or 0;</li>
<li>raises a <code>ValueError</code> if <code>offset</code> is not word-aligned (i.e. a multiple of <code>self.data_width // self.granularity</code>);</li>
</ul>
</li>
<li>
<p>a <code>.Cluster(self, name)</code> context manager method, which:</p>
<ul>
<li>upon entry, creates a scope where registers added by <code>self.add()</code> are assigned to a cluster named <code>name</code>;</li>
<li>raises a <code>ValueError</code> if <code>self</code> is frozen;</li>
<li>raises a <code>TypeError</code> if <code>name</code> is not a non-empty string;</li>
<li>raises a <code>ValueError</code> if <code>name</code> is already assigned to another register or <code>Cluster</code>;</li>
</ul>
</li>
<li>
<p>a <code>.Index(self, index)</code> context manager method, which:</p>
<ul>
<li>upon entry, creates a scope where registers added by <code>self.add()</code> are assigned to an array index <code>index</code>;</li>
<li>raises a <code>ValueError</code> if <code>self</code> is frozen;</li>
<li>raises a <code>TypeError</code> if <code>index</code> is neither a positive integer or 0;</li>
<li>raises a <code>ValueError</code> if <code>index</code> is already assigned to another <code>Index</code>;</li>
</ul>
</li>
<li>
<p>a <code>.as_memory_map(self)</code> method, that converts <code>self</code> into a <code>MemoryMap</code>. <code>self.freeze()</code> is implicitly called as a side-effect.</p>
</li>
</ul>
<h3 id="csr-bus-primitives"><a class="header" href="#csr-bus-primitives">CSR bus primitives</a></h3>
<h4 id="changes-to-memorymemorymap"><a class="header" href="#changes-to-memorymemorymap">Changes to <code>memory.MemoryMap</code></a></h4>
<p><code>MemoryMap.add_resource(self, resource, *, name, size, addr=None, alignment=None)</code> now requires <code>resource</code> to be a <code>wiring.Component</code> object.</p>
<h4 id="changes-to-csrbusmultiplexer"><a class="header" href="#changes-to-csrbusmultiplexer">Changes to <code>csr.bus.Multiplexer</code></a></h4>
<p><code>Multiplexer</code> instances are now created from a caller-provided <code>MemoryMap</code>, instead of creating and populating one itself.</p>
<ul>
<li>replace <code>.__init__(self, addr_width, data_width, alignment, name)</code> with <code>.__init__(memory_map)</code>, that:
<ul>
<li>raises a <code>TypeError</code> if <code>memory_map</code> is not a <code>MemoryMap</code> object;</li>
<li>raises a <code>ValueError</code> if <code>memory_map</code> has windows.</li>
<li>raises a <code>TypeError</code> if <code>memory_map</code> has resources that are not <code>wiring.Component</code> objects with the following signature:</li>
</ul>
</li>
</ul>
<pre><code class="language-python3">{
    &quot;element&quot;: Out(csr.Element.Signature(...)),
    # additional members are allowed
}
</code></pre>
<ul>
<li>remove the <code>.align_to(self, alignment)</code> method;</li>
<li>remove the <code>.add(self, elem, name, addr=None, alignment=None)</code> method.</li>
</ul>
<h4 id="csrregbridge"><a class="header" href="#csrregbridge"><code>csr.reg.Bridge</code></a></h4>
<p>The <code>csr.reg.Bridge</code> class describes a <code>wiring.Component</code> that mediates access between a CSR bus and a group of <code>csr.Register</code>s, with:</p>
<ul>
<li>a <code>.__init__(self, memory_map)</code> constructor, that:
<ul>
<li>freezes and assigns <code>memory_map</code> to <code>self.bus.memory_map</code>;</li>
<li>raises a <code>TypeError</code> if <code>memory_map</code> is not a <code>MemoryMap</code> object;</li>
<li>raises a <code>ValueError</code> if <code>memory_map</code> has windows.</li>
<li>raises a <code>TypeError</code> if <code>memory_map</code> has resources that are not <code>csr.Register</code> objects;</li>
</ul>
</li>
<li>a <code>.signature</code> property, that returns a <code>wiring.Signature</code> with the following members:</li>
</ul>
<pre><code class="language-python3">{
    &quot;bus&quot;: In(csr.Signature(addr_width=memory_map.addr_width, data_width=memory_map.data_width))
}
</code></pre>
<ul>
<li>a <code>.elaborate(self, platform)</code> method, that instantiates a <code>csr.Multiplexer</code> submodule and connects its bus interface to <code>self.bus</code>. The registers in <code>self.bus.memory_map</code> are added as submodules.</li>
</ul>
<h2 id="drawbacks-9"><a class="header" href="#drawbacks-9">Drawbacks</a></h2>
<ul>
<li>While this RFC attempts to provide escape hatches to allow users to circumvent some or all of the proposed API, it is possible that common use-cases may be complicated or impossible to implement, due to the author's oversight.</li>
</ul>
<h2 id="rationale-and-alternatives-8"><a class="header" href="#rationale-and-alternatives-8">Rationale and alternatives</a></h2>
<ul>
<li>The existing CSR infrastructure already guarantees that a CSR access completes atomically. This RFC builds upon it by reasoning in terms of atomic transactions: it identifies scenarios where a write-conflict may happen, and either prevents it (e.g. by restricting a field to a single owner) or defines clear precedence rules.</li>
<li>The absence of <code>csr.action.RW0S</code> and <code>csr.action.RW0C</code> is voluntary, to allow a write of 0 to be no-op.</li>
<li>Alternatively, do nothing. This maximises user freedom, at the cost of boilerplate. A proliferation of downstream CSR register implementations would prevent amaranth-soc's BSP generator from gathering register fields to generate safe accessors and documentation.</li>
</ul>
<h2 id="prior-art-8"><a class="header" href="#prior-art-8">Prior art</a></h2>
<p>The Rocket Chip Generator has a <a href="https://github.com/chipsalliance/rocket-chip/tree/master/src/main/scala/regmapper">register API</a> that supports some use-cases of this RFC:</p>
<ul>
<li>Each field of a register is a component with its own interface and access mode.</li>
<li>Reserved fields are neither readable nor writable.</li>
<li>A field is created as a <code>RegField</code> instance with separate <code>RegWriteFn</code> and <code>RegReadFn</code> functions implementing its behavior, whereas a <code>csr.FieldAction</code> in this RFC implements both.</li>
<li>Its <code>RegField.rwReg</code> built-in has the same write latency as <code>csr.action.RW</code>, but differs by having users provide the register storage.</li>
<li>Its <code>RegField.w1ToClear</code> built-in has the same behavior as <code>csr.action.RW1C</code> (besides the previous point). The peripheral side can only set bits and has precedence in case of set/clear conflicts.</li>
</ul>
<h2 id="unresolved-questions-8"><a class="header" href="#unresolved-questions-8">Unresolved questions</a></h2>
<ul>
<li>What conventions should we follow when documenting CSR registers ?</li>
</ul>
<h2 id="future-possibilities-8"><a class="header" href="#future-possibilities-8">Future possibilities</a></h2>
<p>The notion of ownership in CSR registers can be expanded throughout the entire SoC (interconnect primitives, peripherals, events, etc).</p>
<p>Having an explicit model of ownership across the amaranth-soc library could allow us to provide strong safety guarantees against some concurrency hazards (e.g. two CPU cores writing to the same peripheral).</p>
<h2 id="acknowledgements-2"><a class="header" href="#acknowledgements-2">Acknowledgements</a></h2>
<p>@whitequark, @zyp, @tpwrules, @galibert and @Fatsie provided valuable feedback while this RFC was being drafted.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2024-01-08</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/17">amaranth-lang/rfcs#17</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth/issues/1025">amaranth-lang/amaranth#1025</a></li>
</ul>
<h1 id="remove-log2_int"><a class="header" href="#remove-log2_int">Remove <code>log2_int</code></a></h1>
<h2 id="summary-11"><a class="header" href="#summary-11">Summary</a></h2>
<p>Replace <code>log2_int</code> with two functions: <code>ceil_log2</code> and <code>exact_log2</code>.</p>
<h2 id="motivation-11"><a class="header" href="#motivation-11">Motivation</a></h2>
<p><code>log2_int</code> is a helper function that was copied from Migen in the early days of Amaranth.</p>
<p>It behaves like so:</p>
<ul>
<li><code>n</code> must be an integer, and a power-of-2 unless <code>need_pow2</code> is <code>False</code>;</li>
<li>if <code>n == 0</code>, it returns <code>0</code>;</li>
<li>if <code>n != 0</code>, it returns <code>(n - 1).bit_length()</code>.</li>
</ul>
<h4 id="differences-with-mathlog2"><a class="header" href="#differences-with-mathlog2">Differences with <code>math.log2</code></a></h4>
<p>In practice, <code>log2_int</code> differs from <code>math.log2</code> in the following ways:</p>
<ol>
<li>its implementation is restricted to integers only;</li>
<li>if <code>need_pow2</code> is false, the result is rounded up to the nearest integer;</li>
<li>it doesn't raise an exception for <code>n == 0</code>;</li>
<li>if <code>need_pow2</code> is false, it doesn't raise an exception for <code>n &lt; 0</code>.</li>
</ol>
<h4 id="observations"><a class="header" href="#observations">Observations</a></h4>
<ul>
<li><em>1)</em> is a desirable property; coercing integers into floating-point numbers is fraught with peril, as the latter have limited precision.</li>
<li><em>2)</em> has common use-cases in digital design, such as address decoders.</li>
<li><em>3)</em> and <em>4)</em> are misleading at best. Despite being advertised as a logarithm, <code>log2_int</code> doesn't exclude 0 or negative integers from its domain.</li>
</ul>
<h2 id="guide-level-explanation-9"><a class="header" href="#guide-level-explanation-9">Guide-level explanation</a></h2>
<p>Amaranth provides two log2 functions for integer arithmetic:</p>
<ul>
<li><code>ceil_log2(n)</code>, where <code>n</code> is assumed to be any non-negative integer</li>
<li><code>exact_log2(n)</code>, where <code>n</code> is assumed to be an integer power-of-2</li>
</ul>
<p>For example:</p>
<pre><code class="language-python3">ceil_log2(8) # 3
ceil_log2(5) # 3
ceil_log2(4) # 2

exact_log2(8) # 3
exact_log2(5) # raises a ValueError
exact_log2(4) # 2
</code></pre>
<h2 id="reference-level-explanation-9"><a class="header" href="#reference-level-explanation-9">Reference-level explanation</a></h2>
<p>Use of the <code>log2_int</code> function is deprecated.</p>
<p>A <code>ceil_log2(n)</code> function is added, that:</p>
<ul>
<li>returns the integer log2 of the smallest power-of-2 greater than or equal to <code>n</code>;</li>
<li>raises a <code>TypeError</code> if <code>n</code> is not an integer;</li>
<li>raises a <code>ValueError</code> if <code>n</code> is lesser than 0.</li>
</ul>
<p>An <code>exact_log2(n)</code> function is added, that:</p>
<ul>
<li>returns the integer log2 of <code>n</code>;</li>
<li>raises a <code>TypeError</code> if <code>n</code> is not an integer;</li>
<li>raises a <code>ValueError</code> if <code>n</code> is not a power-of-two.</li>
</ul>
<h2 id="drawbacks-10"><a class="header" href="#drawbacks-10">Drawbacks</a></h2>
<p>This is a breaking change.</p>
<h2 id="rationale-and-alternatives-9"><a class="header" href="#rationale-and-alternatives-9">Rationale and alternatives</a></h2>
<p>The following alternatives have been considered:</p>
<ol>
<li>Do nothing. Callers of <code>log2_int</code> may still need to restrict its domain to positive integers.</li>
<li>Restrict <code>log2_int</code> to positive integers. Downstream code relying on the previous behavior may silently break.</li>
<li>Remove <code>log2_int</code>, and use <code>math.log2</code> as replacement:
<ul>
<li><code>log2_int(n)</code> would be replaced with <code>math.log2(n)</code></li>
<li><code>log2_int(n, need_pow2=False)</code> would be replaced with <code>math.ceil(math.log2(n))</code></li>
</ul>
</li>
</ol>
<p>Option <em>3)</em> will give incorrect results, as <code>n</code> is coerced from <code>int</code> to <code>float</code>:</p>
<pre><code>&gt;&gt;&gt; log2_int((1 &lt;&lt; 64) + 1, need_pow2=False)
65
&gt;&gt;&gt; math.ceil(math.log2((1 &lt;&lt; 64) + 1))
64
</code></pre>
<h2 id="prior-art-9"><a class="header" href="#prior-art-9">Prior art</a></h2>
<p>None.</p>
<h2 id="unresolved-questions-9"><a class="header" href="#unresolved-questions-9">Unresolved questions</a></h2>
<p>None.</p>
<h2 id="future-possibilities-9"><a class="header" href="#future-possibilities-9">Future possibilities</a></h2>
<p>None.</p>
<h2 id="acknowledgements-3"><a class="header" href="#acknowledgements-3">Acknowledgements</a></h2>
<p><a href="https://github.com/wanda-phi">@wanda-phi</a> provided valuable feedback while this RFC was being drafted.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2023-08-22</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/18">amaranth-lang/rfcs#18</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth/issues/873">amaranth-lang/amaranth#873</a></li>
</ul>
<h1 id="reorganize-vendor-platforms"><a class="header" href="#reorganize-vendor-platforms">Reorganize vendor platforms</a></h1>
<h2 id="summary-12"><a class="header" href="#summary-12">Summary</a></h2>
<p>Update <code>amaranth.vendor</code> namespace so that instead of:</p>
<pre><code class="language-python">from amaranth.vendor.lattice_ecp5 import LatticeECP5Platform
</code></pre>
<p>you would write:</p>
<pre><code class="language-python">from amaranth.vendor import LatticeECP5Platform
</code></pre>
<h2 id="motivation-12"><a class="header" href="#motivation-12">Motivation</a></h2>
<p>Vendor names are ever-changing. Xilinx was bought by AMD and the brand has been phased out. Altera was bought by Intel and the brand has been phased out. SiliconBlue has been bought by Lattice (a long time ago) and the brand has <em>long</em> been phased out but still remains as &quot;SB&quot; in <code>SB_LUT</code> primitive name.</p>
<p>In addition, we attempt to group FPGA families into a single file, like <code>vendor.lattice_machxo2_3l</code> that has been renamed from <code>vendor.lattice_machxo2</code>. This will likely include another FPGA family as soon as it becomes available.</p>
<p>By tying module (and file) names to brand names we create churn. Every Amaranth release so far has included renaming of both platform class names and module names. This causes additional downstream breakage and annoys designers using Amaranth.</p>
<h2 id="guide-level-explanation-10"><a class="header" href="#guide-level-explanation-10">Guide-level explanation</a></h2>
<p>To target your FPGA-based project for a particular FPGA family, import the platform class corresponding to the FPGA family from <code>amaranth.vendor</code>, e.g.:</p>
<pre><code class="language-python">from amaranth.vendor import LatticeECP5Platform
</code></pre>
<h2 id="reference-level-explanation-10"><a class="header" href="#reference-level-explanation-10">Reference-level explanation</a></h2>
<p>All of the <code>amaranth.vendor.name</code> modules are renamed to <code>amaranth.vendor._internal_name</code>.</p>
<p>Python allows <code>__getattr__</code> to be present in modules:</p>
<pre><code>$ cat &gt;x.py
def __getattr__(self, name):
    return f&quot;__getattr__({name!r})&quot;
$ python
&gt;&gt;&gt; from x import abc
&gt;&gt;&gt; abc
&quot;__getattr__('abc')&quot;
</code></pre>
<p>This allows us to make all the platform classes be present as-if they were defined in the <code>amaranth.vendor</code> modules, while retaining all of the benefits of having them in their own <code>amaranth.vendor._internal_name</code> module, such as lazy loading.</p>
<h2 id="drawbacks-11"><a class="header" href="#drawbacks-11">Drawbacks</a></h2>
<ul>
<li>Churn.</li>
<li>A somewhat unusual loading mechanism could cause confusion.</li>
</ul>
<h2 id="rationale-and-alternatives-10"><a class="header" href="#rationale-and-alternatives-10">Rationale and alternatives</a></h2>
<p>Decoupling marketing/brand names from technical names is increasingly important as Amaranth evolves and supports more FPGA families. It allows us to maintain any internal hierarchy we want without it having any impact on downstream code, which solely operates on names imported from <code>amaranth.vendor</code>.</p>
<h2 id="prior-art-10"><a class="header" href="#prior-art-10">Prior art</a></h2>
<p>None.</p>
<h2 id="unresolved-questions-10"><a class="header" href="#unresolved-questions-10">Unresolved questions</a></h2>
<p>None.</p>
<h2 id="future-possibilities-10"><a class="header" href="#future-possibilities-10">Future possibilities</a></h2>
<p>None.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2023-08-22</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/19">amaranth-lang/rfcs#19</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth/issues/874">amaranth-lang/amaranth#874</a></li>
</ul>
<h1 id="remove-amaranthlibscheduler"><a class="header" href="#remove-amaranthlibscheduler">Remove <code>amaranth.lib.scheduler</code></a></h1>
<h2 id="summary-13"><a class="header" href="#summary-13">Summary</a></h2>
<p>Remove <code>amaranth.lib.scheduler</code> and the only class <code>RoundRobin</code> in it.</p>
<h2 id="motivation-13"><a class="header" href="#motivation-13">Motivation</a></h2>
<p>This module is not used in the sole place for which it was added (Amaranth SoC), it is not especially useful, and it has not undergone proper community review when it was added.</p>
<h2 id="guide-level-explanation-11"><a class="header" href="#guide-level-explanation-11">Guide-level explanation</a></h2>
<p>The module <code>amaranth.lib.scheduler</code> and the sole class <code>RoundRobin</code> in it is removed. To continue using it, copy the contents of the module into your own project.</p>
<h2 id="reference-level-explanation-11"><a class="header" href="#reference-level-explanation-11">Reference-level explanation</a></h2>
<p>The class <code>amaranth.lib.scheduler.RoundRobin</code> is deprecated in Amaranth 0.4 and removed in Amaranth 0.5.</p>
<h2 id="drawbacks-12"><a class="header" href="#drawbacks-12">Drawbacks</a></h2>
<ul>
<li>Churn.</li>
</ul>
<h2 id="rationale-and-alternatives-11"><a class="header" href="#rationale-and-alternatives-11">Rationale and alternatives</a></h2>
<ul>
<li>This module is out of place in the standard library.</li>
<li>It has not seen much use and is trivially implemented outside of it.</li>
<li>Downstream consumers tend to inline the logic anyway.</li>
<li>It does not seem like there would be any other uses for the <code>amaranth.lib.scheduler</code> module since any other scheduling algorithm would be more closely tied to the consumer.</li>
</ul>
<h2 id="unresolved-questions-11"><a class="header" href="#unresolved-questions-11">Unresolved questions</a></h2>
<p>None.</p>
<h2 id="future-possibilities-11"><a class="header" href="#future-possibilities-11">Future possibilities</a></h2>
<p>None.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2023-08-22</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/20">amaranth-lang/rfcs#20</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth/issues/875">amaranth-lang/amaranth#875</a></li>
</ul>
<h1 id="deprecate-non-fwft-fifos"><a class="header" href="#deprecate-non-fwft-fifos">Deprecate non-FWFT FIFOs</a></h1>
<h2 id="summary-14"><a class="header" href="#summary-14">Summary</a></h2>
<p>Deprecate non-first-word-fall-through FIFOs.</p>
<h2 id="motivation-14"><a class="header" href="#motivation-14">Motivation</a></h2>
<p>Currently, FIFOs in <code>amaranth.lib.fifo</code> have two incompatible interfaces: FWFT (first word fallthrough) and non-FWFT. The incompatibility concerns only the read half. FWFT FIFOs have <code>r_data</code> valid when <code>r_rdy</code> is asserted. Non-FWFT FIFOs have <code>r_data</code> valid only after strobing <code>r_en</code>, if the FIFO was empty previously.</p>
<p>Non-FWFT interface is awkward and is essentially never used. It is a holdover from Migen and its implementation details that was included for compatibility. There are three downsides to having it:</p>
<ol>
<li>Having non-FWFT FIFOs requires every consumer of the FIFO interface to check for <code>fwft</code> when interacting with the FIFO and either asserting that it is <code>True</code>, or adding a code path to handle it. No one does this.</li>
<li>The FWFT interface is directly compatible with streams and allows us to add e.g. <code>r_stream</code> and <code>w_stream</code> to existing FIFOs without adding a wrapper such as <code>stream.FIFO</code>. It also makes any custom FIFOs defined downstream of Amaranth stream-enabled.</li>
<li>The notion of FWFT vs non-FWFT FIFOs is confusing and difficult to understand. E.g. the author of this RFC wrote both <code>lib.fifo</code> and the Glasgow FIFO code, and she misused the <code>fwft</code> argument in the latter.</li>
</ol>
<h2 id="guide-level-and-reference-level-explanation"><a class="header" href="#guide-level-and-reference-level-explanation">Guide-level and reference-level explanation</a></h2>
<p>In the next version, instantiating <code>SyncFIFO(fwft=False)</code> emits a deprecation warning. In addition, <code>FIFOInterface</code>'s <code>fwft</code> parameter now defaults to <code>True</code>. Other FIFOs have no non-FWFT variant in the first place.</p>
<p>In the version after that, there is no way to instantiate <code>SyncFIFO(fwft=False)</code>. The feature and all references to it are removed in their entirety.</p>
<h2 id="implementation-considerations"><a class="header" href="#implementation-considerations">Implementation considerations</a></h2>
<p>At the moment, <code>SyncFIFOBuffered</code> is implemented as a register in the output of <code>SyncFIFO(fwft=False)</code>. The implementation will need to be rewritten.</p>
<h2 id="drawbacks-13"><a class="header" href="#drawbacks-13">Drawbacks</a></h2>
<ul>
<li>Churn.</li>
<li>There will be no alternative to <code>SyncFIFO(fwft=False)</code>.</li>
</ul>
<h2 id="rationale-and-alternatives-12"><a class="header" href="#rationale-and-alternatives-12">Rationale and alternatives</a></h2>
<ul>
<li>It is feasible to extract <code>SyncFIFO(fwft=False)</code> into its own module that may be used by downstream code that needs non-FWFT FIFOs. It would not implement <code>FIFOInterface</code>.
<ul>
<li>There is no reason the <code>SyncFIFO</code> class could not be copied into downstream code as it is.</li>
</ul>
</li>
<li>It is possible to wrap FIFOs in the stream library in a way that ensures only FWFT FIFOs are used.
<ul>
<li>Let's not create pointless wrappers.</li>
</ul>
</li>
</ul>
<h2 id="prior-art-11"><a class="header" href="#prior-art-11">Prior art</a></h2>
<p>Not relevant.</p>
<h2 id="unresolved-questions-12"><a class="header" href="#unresolved-questions-12">Unresolved questions</a></h2>
<p>None.</p>
<h2 id="future-possibilities-12"><a class="header" href="#future-possibilities-12">Future possibilities</a></h2>
<p>This RFC primarily exists to enable better stream interface integration.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2023-08-22</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/21">amaranth-lang/rfcs#21</a></li>
</ul>
<h1 id="patch-releases"><a class="header" href="#patch-releases">Patch releases</a></h1>
<h2 id="summary-15"><a class="header" href="#summary-15">Summary</a></h2>
<p>Change Amaranth versioning from <code>major.minor</code> to <code>major.minor.patch</code> after version 0.4, and define the backport policy for patch releases.</p>
<h2 id="motivation-15"><a class="header" href="#motivation-15">Motivation</a></h2>
<p>Amaranth 0.3 was released on 2021-12-16; almost two years ago. Several important bugs have been fixed in <code>main</code> since, most notably depending on a version of <code>Jinja2</code> that is no longer installable. At the moment the policy is to issue only <code>major.minor</code> releases, which was OK in the early days but no longer fits the project.</p>
<p>We should change the policy that is used for the next Amaranth release and later ones.</p>
<h2 id="explanation-1"><a class="header" href="#explanation-1">Explanation</a></h2>
<p>Amaranth feature releases all have the version of <code>major.minor.0</code>. The policy for these releases is unchanged and is tied to our two-step process for making breaking changes.</p>
<p>In addition to these releases, Amaranth now has bug-fix releases with the <code>major.minor.patch</code> versions. These are intended to address the need of the community to have bugs fixed before a next feature release can be made, and the policy is designed to minimize developer time spent on them.</p>
<p>Bug-fix releases are made when all of the following conditions are satisfied:</p>
<ul>
<li>There is an issue that is fixed in the <code>main</code> branch.</li>
<li>A member of the community requests this issue to be fixed in a point release.</li>
<li>It is possible to fix the issue such that there is a high degree of confidence that the change will not break existing code using Amaranth with a <code>~=major.minor</code> version constraint.</li>
<li>A community member steps up to backport the fix to the release branch.
<ul>
<li>This could be one of the Amaranth maintainers, or anyone else. Amaranth maintainers have no obligation to back-port any fix.</li>
</ul>
</li>
</ul>
<h2 id="drawbacks-14"><a class="header" href="#drawbacks-14">Drawbacks</a></h2>
<p>This creates additional work for maintainers.</p>
<h2 id="rationale-and-alternatives-13"><a class="header" href="#rationale-and-alternatives-13">Rationale and alternatives</a></h2>
<ul>
<li>It would be possible to backport all feasible fixes as a policy.
<ul>
<li>This would significantly increase maintainer workload.</li>
</ul>
</li>
<li>It is possible to keep the current policy.
<ul>
<li>Because we do not control all of the upstream dependencies (including Python), this seems untenable.</li>
</ul>
</li>
</ul>
<h2 id="prior-art-12"><a class="header" href="#prior-art-12">Prior art</a></h2>
<p>Rust has an even stricter bug-fix release policy: the Rust project only issues patch releases in cases of security issues, widespread miscompilations, or unintentional breaking changes.</p>
<h2 id="unresolved-questions-13"><a class="header" href="#unresolved-questions-13">Unresolved questions</a></h2>
<p>Should Amaranth SoC adopt the same policy?</p>
<h2 id="future-possibilities-13"><a class="header" href="#future-possibilities-13">Future possibilities</a></h2>
<p>Eventually, Amaranth may gain release engineers who will maintain long-living release branches.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2023-08-22</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/22">amaranth-lang/rfcs#22</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth/issues/876">amaranth-lang/amaranth#876</a></li>
</ul>
<h1 id="define-valuecastableshape"><a class="header" href="#define-valuecastableshape">Define <code>ValueCastable.shape()</code></a></h1>
<h2 id="summary-16"><a class="header" href="#summary-16">Summary</a></h2>
<p>Require value-castable objects to have a method that returns their high-level shape.</p>
<h2 id="motivation-16"><a class="header" href="#motivation-16">Motivation</a></h2>
<p><a href="0015-lifting-shape-castables.html">RFC #15</a> advanced the extensibility of the language significantly, but broke constructs like <code>Signal.like(Signal(data.StructLayout(...)))</code>. In addition, not having a well-defined point for returning the high-level shape (i.e. a shape-castable object from which this value-castable object was creaed rather than a <code>Shape</code> instance) causes workarounds such as <code>data.Layout.of</code> to be added to the language and standard library.</p>
<h2 id="explanation-2"><a class="header" href="#explanation-2">Explanation</a></h2>
<p>The <code>ValueCastable</code> interface has a method <code>.shape()</code>. This method returns a shape-castable object. Where possibe, this object should, when passed to <code>Signal</code>, create a value-castable object of the same type.</p>
<p><code>amaranth.lib.data.Layout.of</code> is removed immediately.</p>
<h2 id="drawbacks-15"><a class="header" href="#drawbacks-15">Drawbacks</a></h2>
<ul>
<li>Increased API surface area
<ul>
<li>At one point a commitment was made that the only method <code>ValueCastable</code> will ever define will be <code>as_value</code>. However, radical changes to the language such as <a href="0015-lifting-shape-castables.html">RFC #15</a> make it reasonable to revisit this.</li>
</ul>
</li>
</ul>
<h2 id="rationale-and-alternatives-14"><a class="header" href="#rationale-and-alternatives-14">Rationale and alternatives</a></h2>
<p>This change is the minimal possible one that fixes the problem systemically. Some minor variations in the design are possible:</p>
<ul>
<li>Instead of requiring <code>shape()</code> to be defined (which is a breaking change), this method can be added optionally in the next release and be required in the release after that.
<ul>
<li>This is difficult to do with <code>ValueCastable</code> and will require workarounds both in the core language implementation and in downstream code that operates on <code>ValueCastable</code> objects.</li>
<li><code>ValueCastable</code> is not very widely used yet and the breakage will likely be minimal.</li>
</ul>
</li>
</ul>
<h2 id="prior-art-13"><a class="header" href="#prior-art-13">Prior art</a></h2>
<p>It is typical for a programming language to have a way of retrieving the type of a value. The mechanism being added here is equivalent.</p>
<h2 id="unresolved-questions-14"><a class="header" href="#unresolved-questions-14">Unresolved questions</a></h2>
<p>None.</p>
<h2 id="future-possibilities-14"><a class="header" href="#future-possibilities-14">Future possibilities</a></h2>
<p>None.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2024-02-05</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/27">amaranth-lang/rfcs#27</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth/issues/1082">amaranth-lang/amaranth#1082</a></li>
</ul>
<h1 id="testbench-processes-for-the-simulator"><a class="header" href="#testbench-processes-for-the-simulator">Testbench processes for the simulator</a></h1>
<blockquote>
<p><strong>Amendments</strong>
This RFC was amended on 2024-02-12 to deprecate <code>add_sync_process</code> rather than <code>add_process</code>, for two reasons:</p>
<ol>
<li><code>add_process</code> encompasses anything <code>add_sync_process</code> can do, but there is functionality that is quite difficult to do with <code>add_sync_process</code>, such as behavioral implementation of a DDR flop.</li>
<li><code>add_sync_process</code> relies on argument-less <code>yield</code>, which has no equivalent with <code>await ...</code> syntax that is desired in the future.</li>
</ol>
</blockquote>
<h2 id="summary-17"><a class="header" href="#summary-17">Summary</a></h2>
<p>The existing <code>Simulator.add_sync_process</code> method causes the process function to observe the design in a state before combinational settling, something that is actively unhelpful in testbenches. A new <code>Simulator.add_testbench</code> method will only return control to the process function after combinational settling.</p>
<h2 id="motivation-17"><a class="header" href="#motivation-17">Motivation</a></h2>
<p>Consider the following code:</p>
<pre><code class="language-python">from amaranth import *
from amaranth.sim import Simulator


class DUT(Elaboratable):
    def __init__(self):
        self.out  = Signal()
        self.outn = Signal()

    def elaborate(self, platform):
        m = Module()
        m.d.sync += self.outn.eq(~self.out)
        return m


dut = DUT()
def testbench():
    yield dut.out.eq(1)
    yield
    print((yield dut.out))
    print((yield dut.outn))

sim = Simulator(dut)
sim.add_clock(1e-6)
sim.add_sync_process(testbench)
sim.run()
</code></pre>
<p>This code prints:</p>
<pre><code>1
1
</code></pre>
<p>While this result is sensible in a behavioral implementation of an elaboratable (where observing the state of the outputs of combinational cells before they transition to the new state is required for such an implementation to function as a drop-in replacement for a register transfer level one), it is not something a testbench should ever print; it clearly contradicts the netlist. Because there are no alternatives to using <code>add_sync_process</code>, testbenches (where such result is completely inappropriate) keep using it, and Amaranth designers are left to sprinkle <code>yield</code> over the testbenches until the result works.</p>
<p>In addition to the direct impact of this issue, it also prevents building reusable abstractions, including something as simple as <code>yield from fifo.read()</code>, since in order to work for back-to-back reads that would first have to <code>yield Settle()</code> to observe the updated value of <code>fifo.r_rdy</code>, which isn't appropriate for a function in the standard library as it changes the observable behavior (and thus breaks the abstraction).</p>
<h2 id="guide-level-explanation-12"><a class="header" href="#guide-level-explanation-12">Guide-level explanation</a></h2>
<p>The code example above is rewritten as:</p>
<pre><code class="language-python">dut = DUT()
def testbench():
    yield dut.out.eq(1)
    yield Tick()
    print((yield dut.out))
    print((yield dut.outn))

sim = Simulator(dut)
sim.add_clock(1e-6)
sim.add_testbench(testbench)
sim.run()
</code></pre>
<p>When run, it prints:</p>
<pre><code>1
0
</code></pre>
<p>Existing testbenches can be ported to use <code>Simulator.add_testbench</code> by removing extraneous <code>yield</code> or <code>yield Settle()</code> calls (and, in some cases, shifting other <code>yield</code> calls around).</p>
<p>Reusable abstractions can be built by defining generator functions on interfaces or components.</p>
<h3 id="guidance-on-simulator-modalities"><a class="header" href="#guidance-on-simulator-modalities">Guidance on simulator modalities</a></h3>
<p>There are two main simulator modalities: <code>add_testbench</code> and <code>add_process</code>. They have completely disjoint purposes:</p>
<ul>
<li><code>add_testbench</code> is used for testing logic (asynchronous or synchronous). It is not used for behavioral replacement of synchronous logic.</li>
<li><code>add_process</code> is used for behavioral replacement of synchronous logic. It is not for testing logic (except for legacy code), and a deprecation warning is shown when <code>yield Settle()</code> is executed in such a process.</li>
</ul>
<p>Example of using <code>add_testbench</code> to test combinatorial logic:</p>
<pre><code class="language-python">m = Module()
m.d.comb += a.eq(~b)

def testbench():
    yield b.eq(1)
    print((yield a)) # =&gt; 0

sim = Simulator(m)
# No clock is required
sim.add_testbench(testbench)
sim.run()
</code></pre>
<p>Example of using <code>add_testbench</code> to test synchronous logic:</p>
<pre><code class="language-python">m = Module()
m.d.sync += a.eq(~b)

def testbench():
    yield b.eq(1)
    yield Tick() # same as Tick(&quot;sync&quot;)
    print((yield a)) # =&gt; 0

sim = Simulator(m)
sim.add_clock(1e-6)
sim.add_testbench(testbench)
sim.run()
</code></pre>
<p>Example of using <code>add_process</code> to replace the flop above, and <code>add_testbench</code> to test the flop:</p>
<pre><code class="language-python">m = Module()

def flop():
    while True:
        yield b.eq(~(yield a))
        yield Tick()

def testbench():
    yield b.eq(1)
    yield Tick() # same as Tick(&quot;sync&quot;)
    print((yield a)) # =&gt; 0

sim = Simulator(m)
sim.add_clock(1e-6)
sim.add_process(flop)
sim.add_testbench(testbench)
sim.run()
</code></pre>
<h3 id="why-not-replace-add_process-with-add_testbench-entirely"><a class="header" href="#why-not-replace-add_process-with-add_testbench-entirely">Why not replace <code>add_process</code> with <code>add_testbench</code> entirely?</a></h3>
<p>It is not possible to use <code>add_testbench</code> processes that drive signals in a race-free way. Consider this (behaviorally defined) circuit:</p>
<pre><code class="language-python">x = Signal(reset=1)
y = Signal()

def proc_flop():
    yield Tick()
    yield y.eq(x)

def proc2():
    yield Tick()
    xv = yield x
    yv = yield y
    print(f&quot;proc2 x={xv} y={yv}&quot;)

def proc3():
    yield Tick()
    yv = yield y
    xv = yield x
    print(f&quot;proc3 x={xv} y={yv}&quot;)
</code></pre>
<p>If these processes are added using <code>add_testbench</code>, the output is:</p>
<pre><code>proc3 x=1 y=0
proc2 x=1 y=1
</code></pre>
<p>If they are added using <code>add_process</code>, the output is:</p>
<pre><code>proc2 x=1 y=0
proc3 x=1 y=0
</code></pre>
<p>Clearly, if <code>proc2</code> and <code>proc3</code> are other flops in the circuit, perhaps performing a computation on <code>x</code> and <code>y</code>, they must be simulated using <code>add_process</code>.</p>
<h2 id="reference-level-explanation-12"><a class="header" href="#reference-level-explanation-12">Reference-level explanation</a></h2>
<p>A new <code>Simulator.add_testbench(process)</code> is added. This function schedules <code>process</code> similarly to <code>add_process</code>, except that before returning control to the coroutine <code>process</code> it performs the equivalent of <code>yield Settle()</code>.</p>
<p><code>add_sync_process</code> and <code>Settle</code> are deprecated and removed in a future version.</p>
<h2 id="drawbacks-16"><a class="header" href="#drawbacks-16">Drawbacks</a></h2>
<ul>
<li>Churn.</li>
<li>Testbench processes can race with each other, and it is not trivial to use multiple testbench processes in a design in a race-free way.
<ul>
<li>Processes using <code>Settle</code> can race as well.</li>
</ul>
</li>
</ul>
<h2 id="rationale-and-alternatives-15"><a class="header" href="#rationale-and-alternatives-15">Rationale and alternatives</a></h2>
<p>The motivating issue has no known alternative resolution besides introducing this (or a very similar) API. The status quo has proved deeply unsatisfactory over many years, and the <code>add_testbench</code> process has been trialed in 2020 and found usable.</p>
<h2 id="prior-art-14"><a class="header" href="#prior-art-14">Prior art</a></h2>
<p>Other simulators experience similar challenges with event scheduling. In Verilog, this is one of the reasons for the use of blocking assignment <code>=</code>. Where the decision of the scheduling primitive is left to the point of use (rather than the point of declaration, as proposed in this RFC) it leads to complexity in teaching the concept.</p>
<h2 id="unresolved-questions-15"><a class="header" href="#unresolved-questions-15">Unresolved questions</a></h2>
<p>None.</p>
<h2 id="future-possibilities-15"><a class="header" href="#future-possibilities-15">Future possibilities</a></h2>
<p>In the standard library, <code>fifo.read()</code> and <code>fifo.write()</code> functions could be defined that aid in testing designs with FIFOs. Such functions will only work correctly within testbench processes.</p>
<p>As it is, every such helper function would have to take a <code>domain</code> argument, which can quickly get out of hand. We have <code>DomainRenamer</code> in the RTL sub-language and we may want to have something like that in the simulation sub-language. (@zyp)</p>
<p>A new <code>add_comb_process</code> function could be added, to replace combinatorial logic. This function would have to accept a list of all signals driven by the process, so that combinatorial loops could be detected. (The demand for this has not been high; as of right now, this is not possible anyway.)</p>
<p>The existing <code>add_process</code> function could accept a list of all signals driven by the process. This could aid in error detection, especially as CXXRTL is integrated into the design, because if a simulator process is driving a signal at the same time as an RTL process, a silent race condition occurs.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2023-10-30</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/0028">amaranth-lang/rfcs#0028</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth/issues/0929">amaranth-lang/amaranth#0929</a></li>
</ul>
<h1 id="allow-overriding-value-operators"><a class="header" href="#allow-overriding-value-operators">Allow overriding Value operators</a></h1>
<h2 id="summary-18"><a class="header" href="#summary-18">Summary</a></h2>
<p>Allow overriding binary <code>Value</code> operators with reflected operators in a value-castable type.</p>
<h2 id="motivation-18"><a class="header" href="#motivation-18">Motivation</a></h2>
<p>A value-castable type can define operators that return another value-castable.
However, if the left side operand is a <code>Value</code>, its operator will be called first, casting the right side operand to a plain <code>Value</code>.
This creates a mismatch in behavior depending on the type and order of operands.</p>
<p>As an example, consider the multiplication of a fixed point value-castable with an integral type:</p>
<pre><code>&gt;&gt;&gt; Q(7).const(0.5) * 255
(fixedpoint Q8.7 (* (const 8'sd64) (const 8'd255)))
&gt;&gt;&gt; 255 * Q(7).const(0.5)
(fixedpoint Q8.7 (* (const 8'sd64) (const 8'd255)))
&gt;&gt;&gt; Q(7).const(0.5) * C(255)
(fixedpoint Q8.7 (* (const 8'sd64) (const 8'd255)))
&gt;&gt;&gt; C(255) * Q(7).const(0.5)
(* (const 8'd255) (const 8'sd64))
</code></pre>
<h2 id="explanation-3"><a class="header" href="#explanation-3">Explanation</a></h2>
<p>When a binary <code>Value</code> operator is called with a value-castable <code>other</code>, check whether the value-castable implements the reflected variant of the operator first and defer to it when present.</p>
<h2 id="drawbacks-17"><a class="header" href="#drawbacks-17">Drawbacks</a></h2>
<p>Extra logic required around every <code>Value</code> operator.</p>
<h2 id="prior-art-15"><a class="header" href="#prior-art-15">Prior art</a></h2>
<p>This is standard behavior for inheritance in <a href="https://docs.python.org/3/reference/datamodel.html#emulating-numeric-types">Python</a>:</p>
<blockquote>
<p>Note: If the right operand‚Äôs type is a subclass of the left operand‚Äôs type and that subclass provides a different implementation of the reflected method for the operation, this method will be called before the left operand‚Äôs non-reflected method. This behavior allows subclasses to override their ancestors‚Äô operations.</p>
</blockquote>
<p>We don't get this behavior automatically because <code>Value</code> is not an ancestor of <code>ValueCastable</code>, but it would make sense for it to behave as it were.</p>
<h2 id="rationale-and-alternatives-16"><a class="header" href="#rationale-and-alternatives-16">Rationale and alternatives</a></h2>
<p>As an alternative, <code>Value</code> and <code>ValueCastable</code> could be rearchitected so that <code>ValueCastable</code> inherits from either <code>Value</code> or a common base that implements the <code>Value</code> operators.
This would make Python do the right thing w.r.t. operator overriding, but is a larger change with more potential for undesirable consequences.</p>
<h2 id="unresolved-questions-16"><a class="header" href="#unresolved-questions-16">Unresolved questions</a></h2>
<p>None.</p>
<h2 id="future-possibilities-16"><a class="header" href="#future-possibilities-16">Future possibilities</a></h2>
<p><code>Value.eq()</code> could in the same manner check for and defer to a <code>.req()</code> method, i.e. reflected <code>.eq()</code>, to allow a value-castable to override how assignment from it to a <code>Value</code> is handled.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2024-01-22</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/30">amaranth-lang/rfcs#30</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth/issues/1047">amaranth-lang/amaranth#1047</a></li>
</ul>
<h1 id="component-metadata-rfc"><a class="header" href="#component-metadata-rfc">Component metadata RFC</a></h1>
<h2 id="summary-19"><a class="header" href="#summary-19">Summary</a></h2>
<p>Add support for JSON-based introspection of an Amaranth component, describing its interface and properties.</p>
<h2 id="motivation-19"><a class="header" href="#motivation-19">Motivation</a></h2>
<p>Introspection of components is an inherent feature of Amaranth. As Python objects, they make use of attributes to:</p>
<ul>
<li>expose the ports that compose their interface.</li>
<li>communicate other kinds of metadata, such as behavioral properties or safety invariants.</li>
</ul>
<p>Multiple tools may consume parts of this metadata at different points in time. While the ports of an interface must be known at build time, other properties (such as a bus memory map) may be used afterwards to operate or verify the design.</p>
<p>However, in a mixed HDL design, components implemented in other HDLs require ad-hoc integration:</p>
<ul>
<li>their netlist must be consulted in order to know their signature.</li>
<li>each port must be connected individually (whereas Amaranth components can use <code>connect()</code> on compatible interfaces).</li>
<li>there is no mechanism to pass metadata besides instance parameters and attributes. Any information produced by the instance itself cannot be easily passed to its parent.</li>
</ul>
<p>This RFC proposes a JSON-based format to describe and exchange component metadata. While building upon the concepts of <a href="https://github.com/amaranth-lang/rfcs/blob/main/text/0002-interfaces.md">RFC 2</a>, this metadata format tries to avoid making assumptions about its consumers (which could be other HDL frontends, block diagram design tools, etc).</p>
<h2 id="guide-level-explanation-13"><a class="header" href="#guide-level-explanation-13">Guide-level explanation</a></h2>
<h3 id="component-metadata"><a class="header" href="#component-metadata">Component metadata</a></h3>
<p>An <code>amaranth.lib.wiring.Component</code> can provide metadata about itself, represented as a JSON object. This metadata contains a hierarchical description of every port of its interface.</p>
<p>The following example defines an <code>AsyncSerial</code> component, and outputs its metadata:</p>
<pre><code class="language-python3">from amaranth import *
from amaranth.lib.data import StructLayout
from amaranth.lib.wiring import In, Out, Signature, Component


class AsyncSerialSignature(Signature):
    def __init__(self, divisor_reset, divisor_bits, data_bits, parity):
        self.data_bits = data_bits
        self.parity    = parity

        super().__init__({
            &quot;divisor&quot;: In(divisor_bits, reset=divisor_reset),

            &quot;rx_data&quot;: Out(data_bits),
            &quot;rx_err&quot;:  Out(StructLayout({&quot;overflow&quot;: 1, &quot;frame&quot;: 1, &quot;parity&quot;: 1})),
            &quot;rx_rdy&quot;:  Out(1),
            &quot;rx_ack&quot;:  In(1),
            &quot;rx_i&quot;:    In(1),

            &quot;tx_data&quot;: In(data_bits),
            &quot;tx_rdy&quot;:  Out(1),
            &quot;tx_ack&quot;:  In(1),
            &quot;tx_o&quot;:    Out(1),
        })


class AsyncSerial(Component):
    def __init__(self, *, divisor_reset, divisor_bits, data_bits=8, parity=&quot;none&quot;):
        super().__init__(AsyncSerialSignature(divisor_reset, divisor_bits, data_bits, parity))


if __name__ == &quot;__main__&quot;:
    import json
    from amaranth.utils import bits_for

    divisor = int(100e6 // 115200)
    serial = AsyncSerial(divisor_reset=divisor, divisor_bits=bits_for(divisor), data_bits=8, parity=&quot;none&quot;)

    print(json.dumps(serial.metadata.as_json(), indent=4))
</code></pre>
<p>The <code>.metadata</code> property of a <code>Component</code> returns a <code>ComponentMetadata</code> instance describing that component. In the above example, <code>serial.metadata.as_json()</code> converts this metadata into a JSON object, which is then printed:</p>
<pre><code class="language-json">{
    &quot;interface&quot;: {
        &quot;members&quot;: {
            &quot;divisor&quot;: {
                &quot;type&quot;: &quot;port&quot;,
                &quot;name&quot;: &quot;divisor&quot;,
                &quot;dir&quot;: &quot;in&quot;,
                &quot;width&quot;: 10,
                &quot;signed&quot;: false,
                &quot;reset&quot;: &quot;868&quot;
            },
            &quot;rx_ack&quot;: {
                &quot;type&quot;: &quot;port&quot;,
                &quot;name&quot;: &quot;rx_ack&quot;,
                &quot;dir&quot;: &quot;in&quot;,
                &quot;width&quot;: 1,
                &quot;signed&quot;: false,
                &quot;reset&quot;: &quot;0&quot;
            },
            &quot;rx_data&quot;: {
                &quot;type&quot;: &quot;port&quot;,
                &quot;name&quot;: &quot;rx_data&quot;,
                &quot;dir&quot;: &quot;out&quot;,
                &quot;width&quot;: 8,
                &quot;signed&quot;: false,
                &quot;reset&quot;: &quot;0&quot;
            },
            &quot;rx_err&quot;: {
                &quot;type&quot;: &quot;port&quot;,
                &quot;name&quot;: &quot;rx_err&quot;,
                &quot;dir&quot;: &quot;out&quot;,
                &quot;width&quot;: 3,
                &quot;signed&quot;: false,
                &quot;reset&quot;: &quot;0&quot;
            },
            &quot;rx_i&quot;: {
                &quot;type&quot;: &quot;port&quot;,
                &quot;name&quot;: &quot;rx_i&quot;,
                &quot;dir&quot;: &quot;in&quot;,
                &quot;width&quot;: 1,
                &quot;signed&quot;: false,
                &quot;reset&quot;: &quot;0&quot;
            },
            &quot;rx_rdy&quot;: {
                &quot;type&quot;: &quot;port&quot;,
                &quot;name&quot;: &quot;rx_rdy&quot;,
                &quot;dir&quot;: &quot;out&quot;,
                &quot;width&quot;: 1,
                &quot;signed&quot;: false,
                &quot;reset&quot;: &quot;0&quot;
            },
            &quot;tx_ack&quot;: {
                &quot;type&quot;: &quot;port&quot;,
                &quot;name&quot;: &quot;tx_ack&quot;,
                &quot;dir&quot;: &quot;in&quot;,
                &quot;width&quot;: 1,
                &quot;signed&quot;: false,
                &quot;reset&quot;: &quot;0&quot;
            },
            &quot;tx_data&quot;: {
                &quot;type&quot;: &quot;port&quot;,
                &quot;name&quot;: &quot;tx_data&quot;,
                &quot;dir&quot;: &quot;in&quot;,
                &quot;width&quot;: 8,
                &quot;signed&quot;: false,
                &quot;reset&quot;: &quot;0&quot;
            },
            &quot;tx_o&quot;: {
                &quot;type&quot;: &quot;port&quot;,
                &quot;name&quot;: &quot;tx_o&quot;,
                &quot;dir&quot;: &quot;out&quot;,
                &quot;width&quot;: 1,
                &quot;signed&quot;: false,
                &quot;reset&quot;: &quot;0&quot;
            },
            &quot;tx_rdy&quot;: {
                &quot;type&quot;: &quot;port&quot;,
                &quot;name&quot;: &quot;tx_rdy&quot;,
                &quot;dir&quot;: &quot;out&quot;,
                &quot;width&quot;: 1,
                &quot;signed&quot;: false,
                &quot;reset&quot;: &quot;0&quot;
            }
        },
        &quot;annotations&quot;: {}
    }
}
</code></pre>
<p>The <code>[&quot;interface&quot;][&quot;annotations&quot;]</code> object, which is empty here, is explained in the next section.</p>
<h3 id="annotations"><a class="header" href="#annotations">Annotations</a></h3>
<p>Users can attach arbitrary annotations to an <code>amaranth.lib.wiring.Signature</code>, which are automatically collected into the metadata of components using this signature.</p>
<p>An <code>Annotation</code> class has a name (e.g. <code>&quot;org.amaranth-lang.amaranth-soc.memory-map&quot;</code>) and a <a href="https://json-schema.org">JSON schema</a> defining the structure of its instances. To continue our <code>AsyncSerial</code> example, we add an annotation to <code>AsyncSerialSignature</code> that will allow us to describe a <a href="https://en.wikipedia.org/wiki/8-N-1">8-N-1</a> configuration:</p>
<pre><code class="language-python3">class AsyncSerialAnnotation(Annotation):
    schema = {
        &quot;$schema&quot;: &quot;https://json-schema.org/draft/2020-12/schema&quot;,
        &quot;$id&quot;: &quot;https://example.com/schema/foo/1.0/serial.json&quot;,
        &quot;type&quot;: &quot;object&quot;,
        &quot;properties&quot;: {
            &quot;data_bits&quot;: {
                &quot;type&quot;: &quot;integer&quot;,
                &quot;minimum&quot;: 0,
            },
            &quot;parity&quot;: {
                &quot;enum&quot;: [ &quot;none&quot;, &quot;mark&quot;, &quot;space&quot;, &quot;even&quot;, &quot;odd&quot; ],
            },
        },
        &quot;additionalProperties&quot;: False,
        &quot;required&quot;: [
            &quot;data_bits&quot;,
            &quot;parity&quot;,
        ],
    }

    def __init__(self, origin):
        assert isinstance(origin, AsyncSerialSignature)
        self.origin = origin

    def as_json(self):
        instance = {
            &quot;data_bits&quot;: self.origin.data_bits,
            &quot;parity&quot;: self.origin.parity,
        }
        self.validate(instance)
        return instance
</code></pre>
<p>We can attach annotations to a <code>Signature</code> subclass by overriding its <code>.annotations()</code> method:</p>
<pre><code class="language-python3">class AsyncSerialSignature(Signature):
    # ...

    def annotations(self, obj):
        return (*super().annotations(obj), AsyncSerialAnnotation(self))
</code></pre>
<p>In this case, <code>AsyncSerialAnnotation</code> depends on immutable metadata attached to <code>AsyncSerialSignature</code> (<code>.data_bits</code> and <code>.parity</code>).</p>
<p>The JSON object returned by <code>serial.metadata.as_json()</code> will now use this annotation:</p>
<pre><code class="language-json">{
    &quot;interface&quot;: {
        &quot;members&quot;: {
            &quot;divisor&quot;: {
                &quot;type&quot;: &quot;port&quot;,
                &quot;name&quot;: &quot;divisor&quot;,
                &quot;dir&quot;: &quot;in&quot;,
                &quot;width&quot;: 10,
                &quot;signed&quot;: false,
                &quot;reset&quot;: &quot;868&quot;
            },
            &quot;rx_ack&quot;: {
                &quot;type&quot;: &quot;port&quot;,
                &quot;name&quot;: &quot;rx_ack&quot;,
                &quot;dir&quot;: &quot;in&quot;,
                &quot;width&quot;: 1,
                &quot;signed&quot;: false,
                &quot;reset&quot;: &quot;0&quot;
            },
            &quot;rx_data&quot;: {
                &quot;type&quot;: &quot;port&quot;,
                &quot;name&quot;: &quot;rx_data&quot;,
                &quot;dir&quot;: &quot;out&quot;,
                &quot;width&quot;: 8,
                &quot;signed&quot;: false,
                &quot;reset&quot;: &quot;0&quot;
            },
            &quot;rx_err&quot;: {
                &quot;type&quot;: &quot;port&quot;,
                &quot;name&quot;: &quot;rx_err&quot;,
                &quot;dir&quot;: &quot;out&quot;,
                &quot;width&quot;: 3,
                &quot;signed&quot;: false,
                &quot;reset&quot;: &quot;0&quot;
            },
            &quot;rx_i&quot;: {
                &quot;type&quot;: &quot;port&quot;,
                &quot;name&quot;: &quot;rx_i&quot;,
                &quot;dir&quot;: &quot;in&quot;,
                &quot;width&quot;: 1,
                &quot;signed&quot;: false,
                &quot;reset&quot;: &quot;0&quot;
            },
            &quot;rx_rdy&quot;: {
                &quot;type&quot;: &quot;port&quot;,
                &quot;name&quot;: &quot;rx_rdy&quot;,
                &quot;dir&quot;: &quot;out&quot;,
                &quot;width&quot;: 1,
                &quot;signed&quot;: false,
                &quot;reset&quot;: &quot;0&quot;
            },
            &quot;tx_ack&quot;: {
                &quot;type&quot;: &quot;port&quot;,
                &quot;name&quot;: &quot;tx_ack&quot;,
                &quot;dir&quot;: &quot;in&quot;,
                &quot;width&quot;: 1,
                &quot;signed&quot;: false,
                &quot;reset&quot;: &quot;0&quot;
            },
            &quot;tx_data&quot;: {
                &quot;type&quot;: &quot;port&quot;,
                &quot;name&quot;: &quot;tx_data&quot;,
                &quot;dir&quot;: &quot;in&quot;,
                &quot;width&quot;: 8,
                &quot;signed&quot;: false,
                &quot;reset&quot;: &quot;0&quot;
            },
            &quot;tx_o&quot;: {
                &quot;type&quot;: &quot;port&quot;,
                &quot;name&quot;: &quot;tx_o&quot;,
                &quot;dir&quot;: &quot;out&quot;,
                &quot;width&quot;: 1,
                &quot;signed&quot;: false,
                &quot;reset&quot;: &quot;0&quot;
            },
            &quot;tx_rdy&quot;: {
                &quot;type&quot;: &quot;port&quot;,
                &quot;name&quot;: &quot;tx_rdy&quot;,
                &quot;dir&quot;: &quot;out&quot;,
                &quot;width&quot;: 1,
                &quot;signed&quot;: false,
                &quot;reset&quot;: &quot;0&quot;
            }
        },
        &quot;annotations&quot;: {
            &quot;https://example.com/schema/foo/1.0/serial.json&quot;: {
                &quot;data_bits&quot;: 8,
                &quot;parity&quot;: &quot;none&quot;
            }
        }
    }
}
</code></pre>
<h4 id="annotation-schema-urls"><a class="header" href="#annotation-schema-urls">Annotation schema URLs</a></h4>
<p>An <code>Annotation</code> schema must have a <code>&quot;$id&quot;</code> property, which holds an URL that serves as its unique identifier. The following convention is required for the <code>&quot;$id&quot;</code> of schemas hosted at https://amaranth-lang.org, and suggested otherwise:</p>
<p><code>&lt;protocol&gt;://&lt;domain&gt;/schema/&lt;package&gt;/&lt;version&gt;/&lt;path&gt;.json</code></p>
<p>where:</p>
<ul>
<li><code>&lt;domain&gt;</code> is a domain name registered to the person or entity defining the annotation;</li>
<li><code>&lt;package&gt;</code> is the name of the Python package providing the <code>Annotation</code> subclass;</li>
<li><code>&lt;version&gt;</code> is the version of the aforementioned package;</li>
<li><code>&lt;path&gt;</code> is a non-empty string.</li>
</ul>
<p>For example:</p>
<ul>
<li>&quot;https://amaranth-lang.org/schema/amaranth/0.5/fifo.json&quot;;</li>
<li>&quot;https://amaranth-lang.org/schema/amaranth-soc/0.1/memory-map.json&quot;.</li>
</ul>
<p>Changes to schema definitions hosted at https://amaranth-lang.org should follow the <a href="https://github.com/amaranth-lang/rfcs">RFC process</a>.</p>
<h2 id="reference-level-explanation-13"><a class="header" href="#reference-level-explanation-13">Reference-level explanation</a></h2>
<h3 id="annotations-1"><a class="header" href="#annotations-1">Annotations</a></h3>
<ul>
<li>add an <code>Annotation</code> base class to <code>amaranth.lib.meta</code>, with:
<ul>
<li>a <code>.schema</code> &quot;abstract&quot; class attribute, which must be a JSON schema, as a dict.</li>
<li>a <code>.__init_subclass__()</code> class method, which raises an exception if:
<ul>
<li><code>.schema</code> does not comply with the <a href="https://json-schema.org/specification-links#2020-12">2020-12 draft</a> of the JSON Schema specification.</li>
</ul>
</li>
</ul>
<ul>
<li>a <code>.origin</code> attribute, which returns the Python object described by an annotation instance.</li>
</ul>
<ul>
<li>a <code>.validate()</code> class method, which takes a JSON instance as argument. An exception is raised if the instance does not comply with the schema.</li>
<li>a <code>.as_json()</code> abstract method, which must return a JSON instance, as a dict. This instance must be compliant with <code>.schema</code>, i.e. <code>self.validate(self.as_json())</code> must succeed.</li>
</ul>
</li>
</ul>
<p>The following changes are made to <code>amaranth.lib.wiring</code>:</p>
<ul>
<li>add a <code>.annotations(self, obj)</code> method to <code>Signature</code>, which returns an empty tuple. If overriden, it must return an iterable of <code>Annotation</code> objects. <code>obj</code> is an interface object that complies with this signature, i.e. <code>self.is_compliant(obj)</code> must succeed.</li>
</ul>
<h3 id="component-metadata-1"><a class="header" href="#component-metadata-1">Component metadata</a></h3>
<p>The following changes are made to <code>amaranth.lib.wiring</code>:</p>
<ul>
<li>add a <code>ComponentMetadata</code> class, with:
<ul>
<li>a <code>.schema</code> class attribute, which returns a JSON schema of component metadata. Its definition is detailed <a href="0030-component-metadata.html#component-metadata-schema">below</a>.</li>
<li>a <code>.validate()</code> class method, which takes a JSON instance as argument. An exception is raised if the instance does not comply with the schema.</li>
<li><code>.__init__()</code> takes a <code>Component</code> object as parameter.</li>
<li>a <code>.origin</code> attribute, which returns the component object given in <code>.__init__()</code>.</li>
<li>a <code>.as_json()</code> method, which returns a JSON instance of <code>.origin</code> that complies with <code>.schema</code>. It is populated by iterating over the component's interface and annotations.</li>
</ul>
</li>
<li>add a <code>.metadata</code> property to <code>Component</code>, which returns <code>ComponentMetadata(self)</code>.</li>
</ul>
<h4 id="component-metadata-schema"><a class="header" href="#component-metadata-schema">Component metadata schema</a></h4>
<pre><code class="language-python3">class ComponentMetadata(Annotation):
    schema = {
        &quot;$schema&quot;: &quot;https://json-schema.org/draft/2020-12/schema&quot;,
        &quot;$id&quot;: &quot;https://amaranth-lang.org/schema/amaranth/0.5/component.json&quot;,
        &quot;type&quot;: &quot;object&quot;,
        &quot;properties&quot;: {
            &quot;interface&quot;: {
                &quot;type&quot;: &quot;object&quot;,
                &quot;properties&quot;: {
                    &quot;members&quot;: {
                        &quot;type&quot;: &quot;object&quot;,
                        &quot;patternProperties&quot;: {
                            &quot;^[A-Za-z][0-9A-Za-z_]*$&quot;: {
                                &quot;oneOf&quot;: [
                                    {
                                        &quot;type&quot;: &quot;object&quot;,
                                        &quot;properties&quot;: {
                                            &quot;type&quot;: {
                                                &quot;enum&quot;: [&quot;port&quot;],
                                            },
                                            &quot;name&quot;: {
                                                &quot;type&quot;: &quot;string&quot;,
                                                &quot;pattern&quot;: &quot;^[A-Za-z][A-Za-z0-9_]*$&quot;,
                                            },
                                            &quot;dir&quot;: {
                                                &quot;enum&quot;: [&quot;in&quot;, &quot;out&quot;],
                                            },
                                            &quot;width&quot;: {
                                                &quot;type&quot;: &quot;integer&quot;,
                                                &quot;minimum&quot;: 0,
                                            },
                                            &quot;signed&quot;: {
                                                &quot;type&quot;: &quot;boolean&quot;,
                                            },
                                            &quot;reset&quot;: {
                                                &quot;type&quot;: &quot;string&quot;,
                                                &quot;pattern&quot;: &quot;^[+-]?[0-9]+$&quot;,
                                            },
                                        },
                                        &quot;additionalProperties&quot;: False,
                                        &quot;required&quot;: [
                                            &quot;type&quot;,
                                            &quot;name&quot;,
                                            &quot;dir&quot;,
                                            &quot;width&quot;,
                                            &quot;signed&quot;,
                                            &quot;reset&quot;,
                                        ],
                                    },
                                    {
                                        &quot;type&quot;: &quot;object&quot;,
                                        &quot;properties&quot;: {
                                            &quot;type&quot;: {
                                                &quot;enum&quot;: [&quot;interface&quot;],
                                            },
                                            &quot;members&quot;: {
                                                &quot;$ref&quot;: &quot;#/properties/interface/properties/members&quot;,
                                            },
                                            &quot;annotations&quot;: {
                                                &quot;type&quot;: &quot;object&quot;,
                                            },
                                        },
                                        &quot;additionalProperties&quot;: False,
                                        &quot;required&quot;: [
                                            &quot;type&quot;,
                                            &quot;members&quot;,
                                            &quot;annotations&quot;,
                                        ],
                                    },
                                ],
                            },
                        },
                        &quot;additionalProperties&quot;: False,
                    },
                    &quot;annotations&quot;: {
                        &quot;type&quot;: &quot;object&quot;,
                    },
                },
                &quot;additionalProperties&quot;: False,
                &quot;required&quot;: [
                    &quot;members&quot;,
                    &quot;annotations&quot;,
                ],
            },
        },
        &quot;additionalProperties&quot;: False,
        &quot;required&quot;: [
            &quot;interface&quot;,
        ]
    }

    # ...
</code></pre>
<p>Reset values are serialized to strings (e.g. &quot;-1&quot;), because JSON can only represent integers up to 2^53.</p>
<h2 id="drawbacks-18"><a class="header" href="#drawbacks-18">Drawbacks</a></h2>
<ul>
<li>Developers need to learn the JSON Schema language to define annotations.</li>
<li>An annotation schema URL may point to a non-existent domain, despite being well formatted.</li>
<li>Handling backward-incompatible changes in new versions of an annotation is left to its consumers.</li>
</ul>
<h2 id="rationale-and-alternatives-17"><a class="header" href="#rationale-and-alternatives-17">Rationale and alternatives</a></h2>
<ul>
<li>As an alternative, do nothing; let tools and downstream libraries provide non-interoperable mechanisms to introspect components to and from Amaranth designs.</li>
<li>Usage of this feature is entirely optional. It has a limited impact on the <code>amaranth.lib.wiring</code>, by reserving only two attributes: <code>Signature.annotations</code> and <code>Component.metadata</code>.</li>
<li>JSON schema is an IETF standard that is well supported across tools and programming languages.</li>
<li>This metadata format can be translated into other formats, such as <a href="https://www.accellera.org/downloads/standards/ip-xact">IP-XACT</a>.</li>
</ul>
<h2 id="unresolved-questions-17"><a class="header" href="#unresolved-questions-17">Unresolved questions</a></h2>
<ul>
<li>The clock and reset ports of a component are omitted from this metadata format. Currently, the clock domains of an Amaranth component are only known at elaboration, whereas this RFC requires metadata to be accessible at any time. While this is a significant limitation for multi-clock components, single-clock components may be assumed to have a positive edge clock <code>&quot;clk&quot;</code> and a synchronous reset <code>&quot;rst&quot;</code>. Support for arbitrary clock domains should be introduced in later RFCs.</li>
<li>Annotating individual ports of an interface is out of the scope of this RFC. Port annotations may be useful to describe non-trivial signal shapes, and introduced in a later RFC.</li>
</ul>
<h2 id="future-possibilities-17"><a class="header" href="#future-possibilities-17">Future possibilities</a></h2>
<p>While this RFC can apply to any Amaranth component, one of its motivating use cases is the ability to export the interface and behavioral properties of SoC peripherals in various formats, such as SVD.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2023-11-27</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/31">amaranth-lang/rfcs#31</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth/issues/972">amaranth-lang/amaranth#972</a></li>
</ul>
<h1 id="enumeration-type-safety"><a class="header" href="#enumeration-type-safety">Enumeration type safety</a></h1>
<h2 id="summary-20"><a class="header" href="#summary-20">Summary</a></h2>
<p>Make Amaranth <code>Enum</code> and <code>Flag</code> use a custom <code>ValueCastable</code> view class, enforcing type safety.</p>
<h2 id="motivation-20"><a class="header" href="#motivation-20">Motivation</a></h2>
<p>Python <code>Enum</code> provides an opaque wrapper over the underlying enum values,
providing type safety and guarding against improper usage in arithmetic
operations:</p>
<pre><code class="language-pycon">&gt;&gt;&gt; from enum import Enum
&gt;&gt;&gt; class EnumA(Enum):
...     A = 0
...     B = 1
...
&gt;&gt;&gt; EnumA.A + 1
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: unsupported operand type(s) for +: 'EnumA' and 'int'
</code></pre>
<p>Likewise, <code>Flag</code> values can be used in bitwise operations, but only within
their own type:</p>
<pre><code class="language-pycon">&gt;&gt;&gt; from enum import Flag
&gt;&gt;&gt; class FlagA(Flag):
...     A = 1
...     B = 2
... 
&gt;&gt;&gt; class FlagB(Flag):
...     C = 1
...     D = 2
... 
&gt;&gt;&gt; FlagA.A | FlagA.B
&lt;FlagA.A|B: 3&gt;
&gt;&gt;&gt; FlagA.A | FlagB.C
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: unsupported operand type(s) for |: 'FlagA' and 'FlagB'
</code></pre>
<p>However, these safety properties are not currently enforced by Amaranth
on enum-typed signals:</p>
<pre><code class="language-pycon">&gt;&gt;&gt; from amaranth import *
&gt;&gt;&gt; from amaranth.lib.enum import *
&gt;&gt;&gt; class FlagA(Flag):
...     A = 1
...     B = 2
... 
&gt;&gt;&gt; class FlagB(Flag):
...     C = 1
...     D = 2
... 
&gt;&gt;&gt; a = Signal(FlagA)
&gt;&gt;&gt; b = Signal(FlagB)
&gt;&gt;&gt; a | b
(| (sig a) (sig b))
</code></pre>
<h2 id="guide-level-explanation-14"><a class="header" href="#guide-level-explanation-14">Guide-level explanation</a></h2>
<p>Like in Python, <code>Enum</code> and <code>Flag</code> subclasses are considered strongly-typed,
while <code>IntEnum</code> and <code>IntFlag</code> are weakly-typed. Enum-typed Amaranth values
with strong typing are manipulated through <code>amaranth.lib.enum.EnumView</code>
and <code>amaranth.lib.enum.FlagView</code> classes, which wrap an underlying <code>Value</code>
in a type-safe container that only allows a small subset of operations.
For weakly-typed enums, <code>Value</code> is used directly, providing full
interchangeability with other values.</p>
<p>An <code>EnumView</code> or a <code>FlagView</code> can be obtained by:</p>
<ul>
<li>Creating an enum-typed signal (<code>a = Signal(MyEnum)</code>)</li>
<li>Explicitly casting a value to the enum type (<code>MyEnum(value)</code>)</li>
</ul>
<p>The operations available on <code>EnumView</code> and <code>FlagView</code> include:</p>
<ul>
<li>Comparing for equality to another view of the same enum type (<code>a == b</code> and <code>a != b</code>)</li>
<li>Assigning to or from a value</li>
<li>Converting to a plain value via <code>Value.cast</code></li>
</ul>
<p>The operations additionally available on <code>FlagView</code> include:</p>
<ul>
<li>Binary bitwise operations with another <code>FlagView</code> of the same type
(<code>a | b</code>, <code>a &amp; b</code>, <code>a ^ b</code>)</li>
<li>Bitwise inversion (<code>~a</code>)</li>
</ul>
<p>A custom subclass of <code>EnumView</code> or <code>FlagView</code> can be used for a given enum
type if so desired, by using the <code>view_class</code> keyword parameter on enum
creation.</p>
<h2 id="reference-level-explanation-14"><a class="header" href="#reference-level-explanation-14">Reference-level explanation</a></h2>
<p><code>amaranth.lib.enum.EnumView</code> is a <code>ValueCastable</code> subclass.  The following
operations are defined on it:</p>
<ul>
<li><code>EnumView(enum, value_castable)</code>: creates the view</li>
<li><code>shape()</code>: returns the underlying enum</li>
<li><code>as_value()</code>: returns the underlying value</li>
<li><code>eq(value_castable)</code>: delegates to <code>eq</code> on the underlying value</li>
<li><code>__eq__</code> and <code>__ne__</code>: if the other argument is an <code>EnumView</code> of the same
enum type or a value of the enum type, delegates to the corresponding
<code>Value</code> operator; otherwise, raises a <code>TypeError</code></li>
<li>All binary arithmetic, bitwise, and remaining comparison operators: raise
a <code>TypeError</code> (to override the implementation provided by <code>Value</code> in case
of an operation between <code>EnumView</code> and <code>Value</code>)</li>
</ul>
<p><code>amaranth.lib.enum.FlagView</code> is a subclass of <code>EnumView</code>.  The following
additional operations are defined on it:</p>
<ul>
<li><code>__and__</code>, <code>__or__</code>, <code>__xor__</code>: if the other argument is a <code>FlagView</code>
of the same enum type or a value of the enum type, delegates to the
corresponding <code>Value</code> operator and wraps the result in <code>FlagView</code>;
otherwise, raises a <code>TypeError</code></li>
<li><code>__invert__</code>: inverts all bits in this value corresponding to actually
defined flags in the underlying enum type, then wraps the result in
<code>FlagView</code></li>
</ul>
<p>The behavior of <code>EnumMeta.__call__</code> when called on a value-castable
is changed as follows:</p>
<ul>
<li>If the enum has been created with a <code>view_class</code>, the value-castable
is wrapped in the given class</li>
<li>Otherwise, if the enum type is a subclass of <code>IntEnum</code> or <code>IntFlag</code>, the
value-castable is returned as a plain <code>Value</code></li>
<li>Otherwise, if the enum type is a subclass of <code>Flag</code>, the value-castable
is wrapped in <code>FlagView</code></li>
<li>Otherwise, the value-castable is wrapped in <code>EnumView</code></li>
</ul>
<p>The behavior of <code>EnumMeta.const</code> is modified to go through the same logic.</p>
<h2 id="drawbacks-19"><a class="header" href="#drawbacks-19">Drawbacks</a></h2>
<p>This proposal increases language complexity, and is not consistent with
eg. how <code>amaranth.lib.data.View</code> operates (which has much more lax type
checking).</p>
<h2 id="rationale-and-alternatives-18"><a class="header" href="#rationale-and-alternatives-18">Rationale and alternatives</a></h2>
<p>Do nothing. Operations on mismatched types will continue to be silently
allowed.</p>
<p>Equality could work more like Python equality (always returning false
for mismatched types).</p>
<p>Assignment could be made strongly-typed as well (with corresponding hook
added to <code>Value</code>).</p>
<h2 id="prior-art-16"><a class="header" href="#prior-art-16">Prior art</a></h2>
<p>This feature directly parallels the differences between Python's
<code>Enum</code>/<code>Flag</code> and <code>IntEnum</code>/<code>IntFlag</code>.</p>
<h2 id="unresolved-questions-18"><a class="header" href="#unresolved-questions-18">Unresolved questions</a></h2>
<p>Instead of having an extension point via <code>view_class</code>, we could instead
automatically forward all otherwise unknown methods to the underlying enum
class, providing it the <code>EnumView</code> as <code>self</code>.</p>
<h2 id="future-possibilities-18"><a class="header" href="#future-possibilities-18">Future possibilities</a></h2>
<p>None.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2023-12-04</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/34">amaranth-lang/rfcs#34</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth/issues/985">amaranth-lang/amaranth#985</a></li>
</ul>
<h1 id="rename-amaranthlibwiringinterface-to-pureinterface"><a class="header" href="#rename-amaranthlibwiringinterface-to-pureinterface">Rename <code>amaranth.lib.wiring.Interface</code> to <code>PureInterface</code></a></h1>
<h2 id="summary-21"><a class="header" href="#summary-21">Summary</a></h2>
<p>The <code>Interface</code> class in <code>amaranth.lib.wiring</code> is renamed to <code>PureInterface</code>, to avoid the impression that it is used for <em>all</em> interfaces.</p>
<h2 id="motivation-21"><a class="header" href="#motivation-21">Motivation</a></h2>
<p>The current naming of the <code>Interface</code> class wrongly suggests that it is the base class to be used for all interfaces, and that <code>isinstance(foo, Interface)</code> is a valid check for an interface. However, this is in stark contrast to how <code>lib.wiring</code> works: any object can be an interface, as long as it has a <code>signature</code> property and compliant members. This misleads users (and, on at least two occasions, amaranth developers), making them write buggy code.</p>
<p>Additionally, the naming makes spoken language ambiguous in a bad way, as it is impossible to tell apart &quot;an interface&quot; and &quot;an Interface&quot;.</p>
<p>Therefore, this RFC proposes to rename <code>Interface</code> to something more specific and reflecting its function.</p>
<h2 id="guide-level-explanation-15"><a class="header" href="#guide-level-explanation-15">Guide-level explanation</a></h2>
<p>The <code>Interface</code> class in <code>amaranth.lib.wiring</code> is renamed to <code>PureInterface</code>.</p>
<h2 id="reference-level-explanation-15"><a class="header" href="#reference-level-explanation-15">Reference-level explanation</a></h2>
<p>The <code>Interface</code> class in <code>amaranth.lib.wiring</code> is renamed to <code>PureInterface</code>.</p>
<h2 id="drawbacks-20"><a class="header" href="#drawbacks-20">Drawbacks</a></h2>
<p>Minor churn.</p>
<h2 id="rationale-and-alternatives-19"><a class="header" href="#rationale-and-alternatives-19">Rationale and alternatives</a></h2>
<p>The new name is, of course, subject to bikeshedding. The names that have been proposed are:</p>
<ul>
<li><code>PureInterface</code></li>
<li><code>BareInterface</code></li>
</ul>
<h2 id="prior-art-17"><a class="header" href="#prior-art-17">Prior art</a></h2>
<p>None.</p>
<h2 id="unresolved-questions-19"><a class="header" href="#unresolved-questions-19">Unresolved questions</a></h2>
<p>None.</p>
<h2 id="future-possibilities-19"><a class="header" href="#future-possibilities-19">Future possibilities</a></h2>
<p>The name <code>Interface</code> that has just been freed up can be reused for an ABC-like class representing all valid interfaces.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2023-12-04</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/35">amaranth-lang/rfcs#35</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth/issues/986">amaranth-lang/amaranth#986</a></li>
</ul>
<h1 id="add-shapelike-valuelike"><a class="header" href="#add-shapelike-valuelike">Add <code>ShapeLike</code>, <code>ValueLike</code></a></h1>
<h2 id="summary-22"><a class="header" href="#summary-22">Summary</a></h2>
<p>Two special classes are added to the language: <code>ShapeLike</code> and <code>ValueLike</code>. They cannot be constructed, but can be used to determine with <code>isinstance</code> and <code>issubclass</code> to determine whether something can be cast to <code>Shape</code> or a <code>Value</code>, respectively.</p>
<h2 id="motivation-22"><a class="header" href="#motivation-22">Motivation</a></h2>
<p>As it stands, we have multiple types of objects that can be used as shapes (<code>Shape</code>, <code>ShapeCastable</code>, <code>int</code>, <code>range</code>, <code>EnumMeta</code>) and values (<code>Value</code>, <code>ValueCastable</code>, <code>int</code>, <code>Enum</code>). These types have no common superclass, so there's no easy way to check if an object can be used as a shape or a value, save for actually calling <code>Shape.cast</code> or <code>Value.cast</code>. Introducing <code>ShapeLike</code> and <code>ValueLike</code> provides an idiomatic way to perform such a check.</p>
<p>Additionally, when type annotations are in use, there is currently no simple type that can be used for an argument that takes an arbitrary shape- or value-castable object. These new classes provide such a simple type.</p>
<h2 id="guide-level-explanation-16"><a class="header" href="#guide-level-explanation-16">Guide-level explanation</a></h2>
<p>In Amaranth, multiple types of objects can be cast to shapes:</p>
<ul>
<li>actual <code>Shape</code> objects</li>
<li><code>ShapeCastable</code> objects</li>
<li>non-negative integers</li>
<li><code>range</code> objects</li>
<li><code>Enum</code> subclasses with const-castable values</li>
</ul>
<p>To check whether an object is of a type that can be cast to a shape, <code>isinstance(obj, ShapeLike)</code> can be used. To check whether a type can be, in general, cast to a shape, <code>issubclass(cls, ShapeLike)</code> can be used.</p>
<p>Likewise, multiple types of objects can be cast to values:</p>
<ul>
<li>actual <code>Value</code> objects</li>
<li><code>ValueCastable</code> objects</li>
<li>integers</li>
<li>values of <code>Enum</code> subclasses with const-castable values</li>
</ul>
<p>To check whether an object is of a type that can be cast to a value, <code>isinstance(obj, ValueLike)</code> can be used. To check whether a type can be, in general, cast to a value, <code>issubclass(cls, ValueLike)</code> can be used.</p>
<h2 id="reference-level-explanation-16"><a class="header" href="#reference-level-explanation-16">Reference-level explanation</a></h2>
<p>A <code>ShapeLike</code> class is provided. It cannot be constructed, and can only be used with <code>isinstance</code> and <code>issubclass</code>, which are overriden by a custom metaclass.</p>
<p><code>issubclass(cls, ShapeLike)</code> returns <code>True</code> for:</p>
<ul>
<li><code>Shape</code></li>
<li><code>ShapeCastable</code> and its subclasses</li>
<li><code>int</code> and its subclasses</li>
<li><code>range</code> and its subclasses</li>
<li><code>enum.EnumMeta</code> and its subclasses</li>
</ul>
<p><code>isinstance(obj, ShapeLike)</code> returns <code>True</code> for:</p>
<ul>
<li>instances of <code>Shape</code></li>
<li>instances of <code>ShapeCastable</code> and its subclasses</li>
<li>non-negative <code>int</code> values (and <code>int</code> subclasses)</li>
<li><code>enum.Enum</code> subclasses where every value is a <code>ValueLike</code></li>
</ul>
<p>Similarly, a <code>ValueLike</code> class is provided.</p>
<p><code>issubclass(cls, ValueLike)</code> returns <code>True</code> for:</p>
<ul>
<li><code>Value</code> and its subclasses</li>
<li><code>ValueCastable</code> and its subclasses</li>
<li><code>int</code> and its subclasses</li>
<li><code>enum.Enum</code> subclasses where every value is a <code>ValueLike</code></li>
</ul>
<p><code>isinstance(obj, ValueLike)</code> returns <code>True</code> iff <code>issubclass(type(obj), ValueLike)</code> returns <code>True</code>.</p>
<h2 id="drawbacks-21"><a class="header" href="#drawbacks-21">Drawbacks</a></h2>
<p>More moving parts in the language.</p>
<p><code>isinstance(obj, ShapeLike)</code> does not actually guarantee that <code>Shape.cast(obj)</code> will succeed ‚Äî the instance check looks only at surface-level information, and an exception can still be thrown. <code>issubclass(cls, ShapeLike)</code> is, by necessity, even more inaccurate.</p>
<h2 id="rationale-and-alternatives-20"><a class="header" href="#rationale-and-alternatives-20">Rationale and alternatives</a></h2>
<p>There are many ways to implement the instance and subclass checks, some more precise (and complex) than others. The semantics described above are a compromise.</p>
<p>For <code>isinstance</code>, a simple variant would be to just try <code>Shape.cast</code> or <code>Value.cast</code> and see if it raises an exception. However, this will sometimes result in <code>isinstance(MyShapeCastable(), ShapeLike)</code> returning <code>False</code>, which may be very unintuitive and hide bugs.</p>
<p>The check for a valid shape-castable enum described above is an approximation ‚Äî the actual logic used requires all values of an enum to be <em>const</em>-castable, not just value-castable. However, there is no way to check this without actually invoking <code>Value.cast</code> on the enum members.</p>
<h2 id="prior-art-18"><a class="header" href="#prior-art-18">Prior art</a></h2>
<p>Python has the concept of abstract base classes, such as <code>collections.abc.Sequence</code>, which can be used for subclass checking even if they are not actual superclasses of the types involved. <code>ShapeLike</code> and <code>ValueLike</code> are effectively ABCs, though they do not use the actual ABC machinery (due to having custom logic in instance checking).</p>
<h2 id="unresolved-questions-20"><a class="header" href="#unresolved-questions-20">Unresolved questions</a></h2>
<ul>
<li>Should the exact details of the instance and subclass checks be changed?</li>
</ul>
<h2 id="future-possibilities-20"><a class="header" href="#future-possibilities-20">Future possibilities</a></h2>
<p>A similar ABC-like class has been proposed for <code>lib.wiring</code> interfaces.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2024-03-18</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/36">amaranth-lang/rfcs#36</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth/issues/1213">amaranth-lang/amaranth#1213</a></li>
</ul>
<h1 id="async-testbench-functions"><a class="header" href="#async-testbench-functions">Async testbench functions</a></h1>
<h2 id="summary-23"><a class="header" href="#summary-23">Summary</a></h2>
<p>Introduce an improved simulator testbench interface using <code>async</code>/<code>await</code> style coroutines.</p>
<h2 id="motivation-23"><a class="header" href="#motivation-23">Motivation</a></h2>
<p>For the purpose of writing a testbench, an <code>async</code> function will read more naturally than a generator function, especially when calling subfunctions/methods.</p>
<p>A more expressive way to specify trigger/wait conditions allows the condition checking to be offloaded to the simulator engine, only returning control to the testbench process when it has work to do.</p>
<p>Passing a simulator context to the testbench function provides a convenient place to gather all simulator operations.</p>
<h2 id="guide-level-explanation-17"><a class="header" href="#guide-level-explanation-17">Guide-level explanation</a></h2>
<p>As an example, let's consider a simple stream interface with <code>valid</code>, <code>ready</code> and <code>data</code> members.
We can then implement <code>stream_send()</code> and <code>stream_recv()</code> functions like this:</p>
<pre><code class="language-python">async def stream_recv(sim, stream):
    sim.set(stream.ready, 1)
    value = await sim.tick().sample(stream.data).until(stream.valid)
    sim.set(stream.ready, 0)
    return value

async def stream_send(sim, stream, value):
    sim.set(stream.data, value)
    sim.set(stream.valid, 1)
    await sim.tick().until(stream.ready)
    sim.set(stream.valid, 0)
</code></pre>
<p><code>sim.get()</code> and <code>sim.set()</code> replaces the existing operations <code>yield signal</code> and <code>yield signal.eq()</code> respectively.</p>
<p><code>sim.tick()</code> replaces the existing <code>Tick()</code>. It returns a trigger object that either can be awaited directly, or made conditional through <code>.until()</code>. Values of signals can be captured using <code>.sample()</code>, which is used to sample the interface members at the active edge of the clock. This approach makes these functions robust in presence of combinational feedback or concurrent use in multiple testbench processes.</p>
<blockquote>
<p><strong>Note</strong>
This simplified example does not include any way of specifying the clock domain of the interface and as such is only directly applicable to single domain simulations.
A way to attach clock domain information to interfaces is desireable, but out of scope for this RFC.</p>
</blockquote>
<p>Using this stream interface, let's consider a colorspace converter accepting a stream of RGB values and outputting a stream of YUV values:</p>
<pre><code class="language-python">class RGBToYUVConverter(Component):
    input: In(StreamSignature(RGB888))
    output: Out(StreamSignature(YUV888))
</code></pre>
<p>A testbench could then look like this:</p>
<pre><code class="language-python">async def test_rgb(sim, r, g, b):
    rgb = {'r': r, 'g': g, 'b': b}
    await stream_send(sim, dut.input, rgb)
    yuv = await stream_recv(sim, dut.output)

    print(rgb, yuv)

async def testbench(sim):
    await test_rgb(sim, 0, 0, 0)
    await test_rgb(sim, 255, 0, 0)
    await test_rgb(sim, 0, 255, 0)
    await test_rgb(sim, 0, 0, 255)
    await test_rgb(sim, 255, 255, 255)
</code></pre>
<p>Since <code>stream_send()</code> and <code>stream_recv()</code> invokes <code>sim.get()</code> and <code>sim.set()</code> that in turn will invoke the appropriate value conversions for a value castable (here <code>data.View</code>), it is general enough to work for streams with arbitrary shapes.</p>
<p><code>Tick()</code> and <code>Delay()</code> are replaced by <code>sim.tick()</code> and <code>sim.delay()</code> respectively.
In addition, <code>sim.changed()</code> and <code>sim.edge()</code> is introduced that allows creating triggers from arbitrary signals.</p>
<p><code>sim.tick()</code> return a domain trigger object that can be made conditional through <code>.until()</code> or repeated through <code>.repeat()</code>. Arbitrary expressions may be sampled at the active edge of the domain clock using <code>.sample()</code>.</p>
<p><code>sim.delay()</code>, <code>sim.changed()</code> and <code>sim.edge()</code> return a combinable trigger object that can be used to add additional triggers.</p>
<p><code>Active()</code> and <code>Passive()</code> are replaced by an <code>background=False</code> keyword argument to <code>.add_testbench()</code>.
Processes created through <code>.add_process()</code> are always created as background processes.
To allow a background process to ensure an operation is finished before end of simulation, <code>sim.critical()</code> is introduced, which is used as a context manager:</p>
<pre><code class="language-python">async def packet_reader(sim, stream):
    while True:
        # Wait until stream has valid data.
        await sim.tick().until(stream.valid)

        # Ensure simulation doesn't end in the middle of a packet.
        async with sim.critical():
            packet = await stream.read_packet()
            print('Received packet:', packet.hex(' '))
</code></pre>
<p>When a combinable trigger object is awaited, it'll return the value(s) of the trigger(s), and it can also be used as an async generator to repeatedly await the same trigger.
Multiple triggers can be combined.
Consider the following examples:</p>
<p>Combinational adder as a process:</p>
<pre><code class="language-python">a = Signal(); b = Signal(); o = Signal()
async def adder(sim):
    async for a_val, b_val in sim.changed(a, b):
        sim.set(o, a_val + b_val)
sim.add_process(adder)
</code></pre>
<p>DDR IO buffer as a process:</p>
<pre><code class="language-python">clk = Signal(); o = Signal(2); pin = Signal()
async def ddr_buffer(sim):
    while True: # could be extended to pre-capture next `o` on posedge
        await sim.negedge(clk)
        sim.set(pin, o[0])
        await sim.posedge(clk)
        sim.set(pin, o[1])
sim.add_process(ddr_buffer)
</code></pre>
<p>Flop with configurable edge reset and posedge clock as a process:</p>
<pre><code class="language-python">clk = Signal(); rst = Signal(); d = Signal(); q = Signal()
def dff(rst_edge):
    async def process(sim):
        async for clk_hit, rst_hit in sim.posedge(clk).edge(rst, rst_edge):
            sim.set(q, 0 if rst_hit else d)
    return process
sim.add_process(dff(rst_edge=0))
</code></pre>
<h2 id="reference-level-explanation-17"><a class="header" href="#reference-level-explanation-17">Reference-level explanation</a></h2>
<p>The following <code>Simulator</code> methods have their signatures updated:</p>
<ul>
<li><code>add_process(process)</code></li>
<li><code>add_testbench(process, *, background=False)</code></li>
</ul>
<p>Both methods are updated to accept an async function passed as <code>process</code>.
The async function must accept an argument <code>sim</code>, which will be passed a simulator context.
(Argument name is just convention, will be passed positionally.)</p>
<p>The usage model of the two kinds of processes are:</p>
<ul>
<li>Processes are added with <code>add_process()</code> for the sole purpose of simulating a part of the netlist with behavioral Python code.
<ul>
<li>Typically such a process will consist of a top-level <code>async for values in sim.tick().sample(...):</code> or <code>async for values in sim.changed(...)</code>, but this is not a requirement.</li>
<li>Such processes may only wait on signals, via <code>sim.tick()</code>, <code>sim.changed()</code>, and <code>sim.edge()</code>. They cannot advance simulation time via <code>sim.delay()</code>.</li>
<li>In these processes, <code>sim.get()</code> is not available; values of signals may only be obtained by awaiting on triggers.
<code>sim.set(x, y)</code> may be used to propagate the value of <code>y</code> without reading it.</li>
<li>The function passed to <code>add_process()</code> must be idempotent: applying it multiple times to the same simulation state and with same local variable values must produce the same effect each time.
Provided that, the outcome of running such a process is deterministic regardless of the order of their execution.</li>
</ul>
</li>
<li>Processes are added with <code>add_testbench()</code> for any other purpose, including but not limited to: providing a stimulus, performing I/O, displaying state, asserting outcomes, and so on.
<ul>
<li>Such a process may be a simple linear function, use a top-level loop, or have arbitrarily complex structure.</li>
<li>Such processes may wait on signals as well as advance simulation time.</li>
<li>In these processes, <code>sim.get(x)</code> is available and returns the most current value of <code>x</code> (after all pending combinatorial propagation finishes).</li>
<li>The function passed to <code>add_testbench()</code> may have arbitrary side effects.
These processes are scheduled in an unspecified order that may not be deterministic, and no mechanisms are provided to recover determinism of outcomes.</li>
<li>When waiting on signals, e.g. via <code>sim.tick()</code>, the requested expressions are sampled before the processes added with <code>add_process()</code> and RTL processes perform combinatorial propagation. However, execution continues only after all pending combinatorial propagation finishes.</li>
</ul>
</li>
</ul>
<p>The following concurrency guarantees are provided:</p>
<ul>
<li>Async processes registered with <code>add_testbench</code> may be preempted by:
<ul>
<li>Any other process when calling <code>await ...</code>.</li>
<li>A process registered with <code>add_process</code> (or an RTL process) when calling <code>sim.set()</code> or <code>sim.memory_write()</code>. In this case, control is returned to the same testbench after combinational settling.</li>
</ul>
</li>
<li>Async processes registered with <code>add_process</code> may be preempted by:
<ul>
<li>Any other process when calling <code>await ...</code>.</li>
</ul>
</li>
<li>Legacy processes follow the same rules as async processes, with the exception of:
<ul>
<li>A legacy process may not be preempted when calling <code>yield x:ValueLike</code> or <code>yield x:Assign</code>.</li>
</ul>
</li>
<li>Once running, a process continues to execute until it terminates or is preempted.</li>
</ul>
<p>The new optional named argument <code>background</code> registers the testbench as a background process when true.
Processes created through <code>add_process</code> are always registered as background processes (except when registering legacy non-async generator functions).</p>
<p>The simulator context has the following methods:</p>
<ul>
<li><code>get(expr: Value) -&gt; int</code></li>
<li><code>get(expr: ValueCastable) -&gt; any</code>
<ul>
<li>Returns the value of <code>expr</code>.
When <code>expr</code> is a value-castable, and its <code>shape()</code> is a <code>ShapeCastable</code>, the value will be converted through the shape's <code>.from_bits()</code>.
Otherwise, a plain integer is returned.
This function is not available in processes created through <code>add_process</code>.</li>
</ul>
</li>
<li><code>set(expr: Value, value: ConstLike)</code></li>
<li><code>set(expr: ValueCastable, value: any)</code>
<ul>
<li>Set <code>expr</code> to <code>value</code>.
When <code>expr</code> is a value-castable, and its <code>shape()</code> is a <code>ShapeCastable</code>, the value will be converted through the shape's <code>.const()</code>.
Otherwise, it must be a const-castable <code>ValueLike</code>.
When used in a process created through <code>add_testbench</code>, it may execute RTL processes and processes created through <code>add_process</code>.</li>
</ul>
</li>
<li><code>memory_read(instance: MemoryIdentity, address: int)</code>
<ul>
<li>Read the value from <code>address</code> in <code>instance</code>.
This function is not available in processes created through <code>add_process</code>.</li>
</ul>
</li>
<li><code>memory_write(instance: MemoryIdentity, address: int, value: int, mask:int = None)</code>
<ul>
<li>Write <code>value</code> to <code>address</code> in <code>instance</code>. If <code>mask</code> is given, only the corresponding bits are written.
Like <code>MemoryInstance</code>, these two functions are an internal interface that will be usually only used via <code>lib.Memory</code>.
When used in a process created through <code>add_testbench</code>, it may execute RTL processes and processes created through <code>add_process</code>.
It comes without a stability guarantee.</li>
</ul>
</li>
<li><code>tick(domain=&quot;sync&quot;, *, context=None)</code>
<ul>
<li>Create a domain trigger object for advancing simulation until the next active edge of the <code>domain</code> clock.
When an elaboratable is passed to <code>context</code>, <code>domain</code> will be resolved from its perspective.</li>
<li>If <code>domain</code> is asynchronously reset while this is being awaited, <code>amaranth.sim.AsyncReset</code> is raised.</li>
</ul>
</li>
<li><code>delay(interval: float)</code>
<ul>
<li>Create a combinable trigger object for advancing simulation by <code>interval</code> seconds.
This function is not available in processes created through <code>add_process</code>.</li>
</ul>
</li>
<li><code>changed(*signals)</code>
<ul>
<li>Create a combinable trigger object for advancing simulation until any signal in <code>signals</code> changes.</li>
</ul>
</li>
<li><code>edge(signal, value: int)</code>
<ul>
<li>Create a combinable trigger object for advancing simulation until <code>signal</code> is changed to <code>value</code>.
<code>signal</code> must be a 1-bit signal or a 1-bit slice of a signal.
Valid values for <code>value</code> are <code>1</code> for rising edge and <code>0</code> for falling edge.</li>
</ul>
</li>
<li><code>posedge(signal)</code></li>
<li><code>negedge(signal)</code>
<ul>
<li>Aliases for <code>edge(signal, 1)</code> and <code>edge(signal, 0)</code> respectively.</li>
</ul>
</li>
<li><code>critical()</code>
<ul>
<li>Context manager.
If the current process is a background process, <code>async with sim.critical():</code> makes it a non-background process for the duration of the statement.</li>
</ul>
</li>
</ul>
<p>A domain trigger object is immutable and has the following methods:</p>
<ul>
<li><code>__await__()</code>
<ul>
<li>Advance simulation and return the value(s) of the sampled expression(s). Values are returned in the same order as the expressions were added.</li>
</ul>
</li>
<li><code>__aiter__()</code>
<ul>
<li>Return an async generator that is equivalent to repeatedly awaiting the trigger object in an infinite loop.</li>
<li>The async generator yields value(s) of the sampled expression(s).</li>
</ul>
</li>
<li><code>sample(*expressions)</code>
<ul>
<li>Create a new trigger object by copying the current object and appending the expressions to be sampled.</li>
</ul>
</li>
<li><code>until(condition)</code>
<ul>
<li>Repeat the trigger until <code>condition</code> is true.
<code>condition</code> is an arbitrary Amaranth expression.
The return value is an unspecified awaitable with <code>await</code> as the only defined operation.
It is only awaitable once and returns the value(s) of the sampled expression(s) at the last time the trigger was repeated.</li>
<li>Example implementation (without error checking):
<pre><code class="language-python">async def until(self, condition):
    while True:
        *values, done = await self.sample(condition)
        if done:
          return values
</code></pre>
</li>
</ul>
</li>
<li><code>repeat(times: int)</code>
<ul>
<li>Repeat the trigger <code>times</code> times.
Valid values are <code>times &gt; 0</code>.
The return value is an unspecified awaitable with <code>await</code> as the only defined operation.
It is only awaitable once and returns the value(s) of the sampled expression(s) at the last time the trigger was repeated.</li>
<li>Example implementation (without error checking):
<pre><code class="language-python">async def repeat(self, times):
    values = None
    for _ in range(times):
        values = await self
    return values
</code></pre>
</li>
</ul>
</li>
</ul>
<p>A combinable trigger object is immutable and has the following methods:</p>
<ul>
<li><code>__await__()</code>
<ul>
<li>Advance simulation and return the value(s) of the trigger(s).
<ul>
<li><code>delay</code> and <code>edge</code> triggers return <code>True</code> when they are hit, otherwise <code>False</code>.</li>
<li><code>changed</code> triggers return the current value of the signals they are monitoring.</li>
<li>At least one of the triggers hit will be reflected in the return value.
In case of multiple triggers occuring at the same time step, it is unspecified which of these will show up in the return value beyond ‚Äúat least one‚Äù.</li>
</ul>
</li>
</ul>
</li>
<li><code>__aiter__()</code>
<ul>
<li>Return an async generator that is equivalent to repeatedly awaiting the trigger object in an infinite loop.</li>
<li>The async generator yields value(s) of the trigger(s).</li>
</ul>
</li>
<li><code>delay(interval: float)</code></li>
<li><code>changed(*signals)</code></li>
<li><code>edge(signal, value)</code></li>
<li><code>posedge(signal)</code></li>
<li><code>negedge(signal)</code>
<ul>
<li>Create a new trigger object by copying the current object and appending another trigger.</li>
<li>Awaiting the returned trigger object pauses the process until the first of the combined triggers hit, i.e. the triggers are combined using OR semantics.</li>
</ul>
</li>
</ul>
<p><code>Tick()</code>, <code>Delay()</code>, <code>Active()</code> and <code>Passive()</code> as well as the ability to pass generator coroutines as <code>process</code> are deprecated and removed in a future version.</p>
<h2 id="drawbacks-22"><a class="header" href="#drawbacks-22">Drawbacks</a></h2>
<ul>
<li>Increase in API surface area and complexity.</li>
<li>Churn.</li>
</ul>
<h2 id="rationale-and-alternatives-21"><a class="header" href="#rationale-and-alternatives-21">Rationale and alternatives</a></h2>
<p><code>sim.get()</code> is not available in processes created with <code>add_process()</code> to simplify the user interface and eliminate the possibility of misusing a helper function by calling it from the wrong type of process.</p>
<ul>
<li>Most helper functions will be implemented using <code>await sim.tick().sample(...)</code>, mirroring the structure of the gateware they are driving. These functions may be safely called from either processes added with <code>add_testbench()</code> or with <code>add_process()</code> since the semantics of <code>await sim.tick()</code> is the same between them.</li>
<li>Some helper functions will be using <code>sim.get(val)</code>, and will only be callable from processes added with <code>add_testbench()</code>, raising an error otherwise. In the legacy interface, the semantics of <code>yield val</code> changes depending on the type of the process, potentially leading to extremely confusing behavior. This is not possible in the async interface.</li>
</ul>
<p>Alternatives:</p>
<ul>
<li>Do nothing. Keep the existing interface, add <code>Changed()</code> alongside <code>Delay()</code> and <code>Tick()</code>, expand <code>Tick()</code> to add sampling, use <code>yield from</code> when calling functions.</li>
</ul>
<h2 id="prior-art-19"><a class="header" href="#prior-art-19">Prior art</a></h2>
<p>Other python libraries like <a href="https://docs.cocotb.org/en/stable/coroutines.html">cocotb</a> that originally used generator based coroutines have also moved to <code>async</code>/<code>await</code> style coroutines.</p>
<h2 id="unresolved-questions-21"><a class="header" href="#unresolved-questions-21">Unresolved questions</a></h2>
<ul>
<li>Is there really a need to ban <code>sim.delay()</code> from processes added with <code>add_process()</code>?
<ul>
<li>The value of <code>add_process()</code> is in ensuring that multiple processes waiting on the same trigger will modify simulation state deterministically no matter which order they run. Multiple processes waiting on a specific point in time using <code>sim.delay()</code> does not appear a common case.</li>
<li><code>sim.delay()</code> in processes added with <code>add_process()</code> may unduly complicate implementation, since timeline advancement then can raise readiness of two kinds of processes instead of one. It is also likely to cause issues with CXXRTL integration.</li>
<li><code>sim.delay()</code> in processes added with <code>add_process()</code> is useful to implement delay and phase shift blocks. However, these can be implemented in processes added with <code>add_testbench()</code> with no loss of functionality, as such blocks do not need delta cycle accurate synchronization with others on the same trigger.</li>
</ul>
</li>
</ul>
<h2 id="future-possibilities-21"><a class="header" href="#future-possibilities-21">Future possibilities</a></h2>
<ul>
<li>Add simulation helper methods to standard interfaces where it makes sense.
<ul>
<li>This includes <code>lib.memory.Memory</code>.</li>
</ul>
</li>
<li>There is a desire for a <code>sim.time()</code> method that returns the current simulation time, but it needs a suitable return type to represent seconds with femtosecond resolution and that is out of the scope for this RFC.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2023-12-11</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/37">amaranth-lang/rfcs#37</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth/issues/995">amaranth-lang/amaranth#995</a></li>
</ul>
<h1 id="make-signature-immutable"><a class="header" href="#make-signature-immutable">Make <code>Signature</code> immutable</a></h1>
<h2 id="summary-24"><a class="header" href="#summary-24">Summary</a></h2>
<p>Remove mutability from <code>amaranth.lib.wiring.Signature</code>.</p>
<h2 id="motivation-24"><a class="header" href="#motivation-24">Motivation</a></h2>
<p>At the time of writing, <code>Signature</code> allows limited mutability: members can be added, but not removed or changed; and a signature may be frozen, preventing further mutation.</p>
<p>The intent behind this feature was unfortunately never explicitly described. I (Catherine) came up with it, to cover the following case: suppose an interface without certain features needs to be connected to an interface with such features. For example, a Wishbone initiator that does not handle errors needs to be connected to a Wishbone decoder that does. In this case, a method on the Wishbone initiator's interface could be used to add a dummy <code>err</code> output, which will always remain at its reset value, zero.</p>
<p>This intent was never realized as the feature was never actually used by Amaranth SoC. In addition, it turned out to be problematic when combined with variable annotations. Consider this class definition:</p>
<pre><code class="language-py">class SomeInitiator(wiring.Component):
    bus: Out(wishbone.Interface(...))
</code></pre>
<p>In this case, only one instance of <code>wishbone.Interface</code> is created. Mutating this instance would be unsound, since it would affect every instance of the component and not just the one for that particular one, and when this causes issues this would be very difficult to debug.</p>
<p>The presence of this feature encouraged adding other mutable objects to <code>Signature</code> subclasses, such as memory maps. That is also unsound, for similar reasons. Because memory maps in Amaranth SoC can also be frozen, considerable additional complexity was introduced since piecewise freezing was now possible.</p>
<p>Because freezing was defined as a property of the signature members dictionary, overloading <code>Signature.freeze</code> was meaningless: it would be possible, in rare but legal cases, to have a signature frozen without <code>freeze</code> being called for that signature, leaving any additional objects that should have been frozen mutable.</p>
<p>The <code>wiring.connect</code> function also supports constants as both inputs and outputs, where a constant input can be connected to a constant output provided their values match. This behavior is also suited for implementing optional features (where the absence of an optional feature means the corresponding ports are fixed at a constant value), and does not pose any hazards.</p>
<h2 id="guide-level-and-reference-level-explanation-1"><a class="header" href="#guide-level-and-reference-level-explanation-1">Guide-level and reference-level explanation</a></h2>
<p>The <code>SignatureMembers.freeze</code>, <code>SignatureMembers.frozen</code>, <code>Signature.freeze</code>, <code>Signature.frozen</code>, <code>FlippedSignatureMembers.freeze</code>, <code>FlippedSignatureMembers.frozen</code>, <code>FlippedSignature.freeze</code>, <code>FlippedSignature.frozen</code>, <code>SignatureMembers.__iadd__</code>, <code>SignatureMembers.__setitem__</code>, <code>FlippedSignatureMembers.__iadd__</code>, <code>FlippedSignatureMembers.__setitem__</code> methods and properties are removed.</p>
<p><code>SignatureMembers</code> becomes an immutable mapping.</p>
<p><code>Signature</code> becomes immutable. Subclasses of <code>Signature</code> are required to ensure any additional methods or properties do not allow mutation.</p>
<h2 id="drawbacks-23"><a class="header" href="#drawbacks-23">Drawbacks</a></h2>
<p>The author is not aware of anyone actually using this feature.</p>
<h2 id="rationale-and-alternatives-22"><a class="header" href="#rationale-and-alternatives-22">Rationale and alternatives</a></h2>
<p>An alternative to this proposal would be to automatically freeze any signature that is used in <code>wiring.Component</code> variable annotations. This does not address similar hazards, such as the case of a user-defined constant <code>SomeSignature = Signature({...})</code>, which is also a legitimate way to define a signature that does not require parameterization. It also would not address hazards associated with interior mutability.</p>
<h2 id="prior-art-20"><a class="header" href="#prior-art-20">Prior art</a></h2>
<p>None seems applicable. Mutation of interface definitions is uncommon in first place (excluding languages where everything is mutable, like Python).</p>
<h2 id="unresolved-questions-22"><a class="header" href="#unresolved-questions-22">Unresolved questions</a></h2>
<ul>
<li>Should <em>all</em> interior mutability be prohibited? At the moment it is not completely clear where memory maps should be attached, and requiring no interior mutability would mean it cannot be <code>Signature</code> no matter what. Interior mutability could be left to specific <code>Signature</code> subclasses instead on an experimental basis, and prohibited later if it turns out to be a bad idea.</li>
</ul>
<h2 id="future-possibilities-22"><a class="header" href="#future-possibilities-22">Future possibilities</a></h2>
<p>Reintroducing mutability of <code>Signature</code> after it has been removed will be unfeasible due to expectation of immutability being baked in widely in downstream code. Once we commit to this RFC we will have to commit to it effectively forever.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2023-12-11</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/38">amaranth-lang/rfcs#38</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth/issues/996">amaranth-lang/amaranth#996</a></li>
</ul>
<h1 id="componentsignature-immutability"><a class="header" href="#componentsignature-immutability"><code>Component.signature</code> immutability</a></h1>
<h2 id="summary-25"><a class="header" href="#summary-25">Summary</a></h2>
<p>Clearly define the contract for <code>amaranth.lib.wiring.Component.signature</code>: an <code>amaranth.lib.wiring.Signature</code> object is assigned in the constructor to the read-only property <code>.signature</code>.</p>
<h2 id="motivation-25"><a class="header" href="#motivation-25">Motivation</a></h2>
<p>It is important that the signature of an interface object never change. <code>connect</code> relies on the signature to check that the connection being made is valid; if the signature changes after the connection is made (intentionally or accidentally), the design would silently break in a difficult to debug ways. For an ASIC this may mean a respin.</p>
<p>Right now, the guidance for the case where the default behavior of <code>Component.signature</code> is insufficient (i.e. for parametric components) and the generation of the signature must be customized, is to override the <code>signature</code> property, or to assign <code>self.signature =</code> in the constructor. This is clearly wrong: both of these approaches can easily result in the signature changing after construction of the component.</p>
<p>Moreover, at the moment, the implementation of the <code>Component.signature</code> property creates a new <code>Signature</code> object every time it is called. If the identity of the <code>Signature</code> object is important (i.e. if it has interior mutability, which is currently the case in Amaranth SoC), this is unsound. (It is unlikely, though not impossible, that this implementation would return an object with different members.)</p>
<h2 id="guide-level-explanation-18"><a class="header" href="#guide-level-explanation-18">Guide-level explanation</a></h2>
<p>To define a simple component whose signature does not change, use variable annotations:</p>
<pre><code class="language-python">class SimpleComponent(wiring.Component):
    en: In(1)
    data: Out(8)
</code></pre>
<p>To define a component whose signature is parameterized by constructor arguments, call the superclass constructor with the signature that should be applied to the component:</p>
<pre><code class="language-python">class ParametricComponent(wiring.Component):
    def __init__(self, data_width):
        super().__init__({
            &quot;en&quot;: In(1),
            &quot;data&quot;: Out(data_width)
        })
</code></pre>
<p>Do not override the <code>signature</code> property, as both Amaranth and third-party code relies on the fact that it is assigned in the constructor and never changes.</p>
<h2 id="reference-level-explanation-18"><a class="header" href="#reference-level-explanation-18">Reference-level explanation</a></h2>
<p>The constructor of <code>Component</code> is updated to take one argument: <code>def __init__(self, signature=None)</code>.</p>
<ul>
<li>If the <code>signature</code> argument is not provided, the signature is derived from class variable annotations, as in RFC 2, and assigned to an internal attribute.</li>
<li>If the <code>signature</code> argument is provided, it is type-checked/type-cast and assigned to the internal attribute.
<ul>
<li>If a <code>Signature</code> is provided as a value, it is used as-is.</li>
<li>If a <code>dict</code> is provided, it is cast by calling <code>wiring.Signature(signature)</code>.</li>
<li>No other types are accepted.</li>
</ul>
</li>
</ul>
<p>If both the <code>signature</code> argument is provided and variable annotations are present, the constructor raises a <code>TypeError</code>. This is to guard against accidentally passing a <code>Signature</code> as an argument when constructing a component that is not parametric. (If this behavior is undesirable for some reason, it is always possible to implement a constructor that does not pass superclasses' constructor, and redefine the <code>signature</code> property, but this should be done as last resort only. We should cleary document that the <code>signature</code> property should return the exact same value at all times for any given <code>Component</code> instance.)</p>
<p>The <code>signature</code> property is redefined to return the value of this internal attribute.</p>
<p>No access to this attribute is provided besides the means above, and the name of the attribute is not defined in the documentation.</p>
<p>After assigning the internal attribute, the constructor creates the members as in RFC 2.</p>
<h2 id="drawbacks-24"><a class="header" href="#drawbacks-24">Drawbacks</a></h2>
<p>None. This properly enforces an invariant that is already relied upon.</p>
<h2 id="rationale-and-alternatives-23"><a class="header" href="#rationale-and-alternatives-23">Rationale and alternatives</a></h2>
<p>Some other behaviors were considered for <code>Component</code>: those which would made <code>signature</code> a class attribute, assigned in <code>__init_subclass__</code>. However, this option would leave the <code>signature</code> attribute mutable (as class-level properties are not reasonably supported in Python), which is undesirable, and significantly complicated the case of signatures with interior mutability.</p>
<h2 id="unresolved-questions-23"><a class="header" href="#unresolved-questions-23">Unresolved questions</a></h2>
<p>None.</p>
<h2 id="future-possibilities-23"><a class="header" href="#future-possibilities-23">Future possibilities</a></h2>
<p>None.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2024-01-08</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/39">amaranth-lang/rfcs#39</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth/issues/1021">amaranth-lang/amaranth#1021</a></li>
</ul>
<h1 id="change-semantics-of-no-argument-mcase"><a class="header" href="#change-semantics-of-no-argument-mcase">Change semantics of no-argument <code>m.Case()</code></a></h1>
<h2 id="summary-26"><a class="header" href="#summary-26">Summary</a></h2>
<p>Change the semantics of <code>with m.Case():</code> (without any arguments) from always-true conditional to always-false conditional. Likewise, change <code>value.matches()</code> from returning <code>C(1)</code> to returning <code>C(0)</code>.</p>
<h2 id="motivation-26"><a class="header" href="#motivation-26">Motivation</a></h2>
<p>Currently, <code>with m.Case():</code> results in an always-true conditional, and <code>value.matches()</code> likewise returns a const-1 value. However, this is not consistent with what would be expected from extrapolating the non-empty case.</p>
<p>In all non-empty cases, the semantics are equivalent to an OR of equality comparisons with all specified values:</p>
<p><code>value.matches(1, 2, 3) =def= (value == 1) | (value == 2) | (value == 3)</code></p>
<p><code>value.matches(1, 2, 3) =def= Const(0) | (value == 1) | (value == 2) | (value == 3)</code></p>
<p>Extrapolating from this, one would expect <code>value.matches()</code> to be the empty OR, ie. <code>Const(0)</code>.</p>
<p>It is unlikely that any manually written code will rely on this, but this can be a dangerous trap for machine-generated code that doesn't take the empty case into account.</p>
<h2 id="guide-level-explanation-19"><a class="header" href="#guide-level-explanation-19">Guide-level explanation</a></h2>
<p>The semantics of <code>m.Case()</code> change from always matching to never matching. Likewise, the semantics of <code>value.matches()</code> change from always-1 to always-0. The change is committed to the current <code>main</code> branch and will be included in Amaranth 0.5.</p>
<p>Amaranth 0.4.1 is released with the old semantics, but a deprecation warning is emitted whenever <code>m.Case()</code> or <code>value.matches()</code> is used.</p>
<h2 id="reference-level-explanation-19"><a class="header" href="#reference-level-explanation-19">Reference-level explanation</a></h2>
<p>See above.</p>
<h2 id="drawbacks-25"><a class="header" href="#drawbacks-25">Drawbacks</a></h2>
<p>Obviously backwards-incompatible, changes the semantics of a language construct to the direct opposite.</p>
<h2 id="rationale-and-alternatives-24"><a class="header" href="#rationale-and-alternatives-24">Rationale and alternatives</a></h2>
<p>It is unlikely anyone actually uses <code>value.matches()</code> directly, since this is just a constant. For generated code, the current semantics is much more likely to be a bug that intended behavior.</p>
<p>For <code>m.Case()</code> the situation is similar: it is redundant with <code>m.Default()</code>, which should be used instead. It is somewhat possible that there is code out there written by someone who didn't know about <code>m.Default()</code> and ended up using <code>m.Case()</code> instead (the official documentation didn't include either for a long time). This code will need to be fixed.</p>
<p>An alternative, if the empty case is deemed too confusing or insufficiently useful, is to make the semantics a hard error instead.</p>
<h2 id="prior-art-21"><a class="header" href="#prior-art-21">Prior art</a></h2>
<p>The current behavior is likely taken directly from RTLIL, which exhibits a similar inconsistency.</p>
<h2 id="unresolved-questions-24"><a class="header" href="#unresolved-questions-24">Unresolved questions</a></h2>
<p>Should we include more warnings about the change? This RFC proposes a warning in the 0.4.1 release, but this will never be seen by someone always using amaranth from git main.</p>
<h2 id="future-possibilities-24"><a class="header" href="#future-possibilities-24">Future possibilities</a></h2>
<p>None.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2024-01-22</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/40">amaranth-lang/rfcs#40</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth/issues/1048">amaranth-lang/amaranth#1048</a></li>
</ul>
<h1 id="arbitrary-memory-shapes"><a class="header" href="#arbitrary-memory-shapes">Arbitrary <code>Memory</code> shapes</a></h1>
<blockquote>
<p><strong>Obsoleted by</strong>
This RFC is obsoleted by <a href="0045-lib-memory.html">RFC 45</a>.</p>
</blockquote>
<h2 id="summary-27"><a class="header" href="#summary-27">Summary</a></h2>
<p>Extend <code>Memory</code> to support arbitrary element shapes.</p>
<h2 id="motivation-27"><a class="header" href="#motivation-27">Motivation</a></h2>
<p><code>Memory</code> currently only supports plain unsigned elements, with the width set by the <code>width</code> argument.
Extending this to allow arbitrary shapes eliminates the need for manual conversion when used to store signed data and value-castables.</p>
<h2 id="guide-level-explanation-20"><a class="header" href="#guide-level-explanation-20">Guide-level explanation</a></h2>
<p>The <code>width</code> argument to <code>Memory()</code> is replaced with <code>shape</code>, accepting anything that is <code>ShapeLike</code>.
Since a plain bit width is <code>ShapeLike</code>, this is a direct superset of existing functionality.</p>
<p>If <code>shape</code> is shape-castable, each element passed to the <code>init</code> argument is passed through <code>shape.const()</code>.</p>
<p>Example:</p>
<pre><code class="language-python">RGB = StructLayout({&quot;r&quot;: 8, &quot;g&quot;: 8, &quot;b&quot;: 8})

palette = Memory(shape = RGB, depth = 16, init = [
    {&quot;r&quot;: 0, &quot;g&quot;: 0, &quot;b&quot;: 0},
    {&quot;r&quot;: 255, &quot;g&quot;: 0, &quot;b&quot;: 0},
    # ...
])
</code></pre>
<h2 id="reference-level-explanation-20"><a class="header" href="#reference-level-explanation-20">Reference-level explanation</a></h2>
<p><code>Memory.__init__()</code> gets a new <code>shape</code> argument, accepting any <code>ShapeLike</code>.</p>
<p>The <code>width</code> argument to <code>Memory.__init__()</code> deprecated and removed in a later Amaranth version. Passing both <code>width</code> and <code>shape</code> is an error.</p>
<p>The <code>Memory.shape</code> attribute is added.</p>
<p>The <code>Memory.width</code> attribute is made a read-only wrapper for <code>Shape.cast(self.shape).width</code>.</p>
<p>The <code>Memory.depth</code> attribute is made read-only.</p>
<p><code>ReadPort.data</code> and <code>WritePort.data</code> are updated to be <code>Signal(memory.shape)</code>.</p>
<p><code>WritePort.__init__()</code> raises an exception if <code>granularity</code> is specified and <code>shape</code> is not an unsigned <code>Shape</code>.</p>
<p><code>DummyPort.__init__()</code> gets a new <code>data_shape</code> argument. <code>data_width</code> is deprecated and removed in a later Amaranth version.</p>
<h2 id="drawbacks-26"><a class="header" href="#drawbacks-26">Drawbacks</a></h2>
<p>Churn.</p>
<h2 id="rationale-and-alternatives-25"><a class="header" href="#rationale-and-alternatives-25">Rationale and alternatives</a></h2>
<ul>
<li>This could also be accomplished by adding a wrapper around <code>Memory</code>.
<ul>
<li>A wrapper would result in more code to maintain than simply updating <code>Memory</code>, since both the memory object itself and the port objects would have to be wrapped.</li>
</ul>
</li>
</ul>
<h2 id="prior-art-22"><a class="header" href="#prior-art-22">Prior art</a></h2>
<p>Being able to make a <code>Memory</code> with an arbitrary element shape is analogous to being able to make an array with an arbitrary element type in any high level programming language.</p>
<h2 id="unresolved-questions-25"><a class="header" href="#unresolved-questions-25">Unresolved questions</a></h2>
<p>None.</p>
<h2 id="future-possibilities-25"><a class="header" href="#future-possibilities-25">Future possibilities</a></h2>
<ul>
<li>
<p>Once <code>Memory</code> is extended to support arbitrary shapes, it is natural that higher level constructs building on <code>Memory</code> like FIFOs gets the same treatment.</p>
</li>
<li>
<p><code>granularity</code> could later be allowed to be used with other kinds of shapes.</p>
<ul>
<li>This is desirable for e.g. <code>lib.data.ArrayLayout</code>, but is not currently possible since <code>Memory</code> lives in <code>hdl.mem</code>, and <code>hdl</code> can't depend on <code>lib</code>.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2024-02-05</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/42">amaranth-lang/rfcs#42</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth/issues/1084">amaranth-lang/amaranth#1084</a></li>
</ul>
<h1 id="const-from-shape-castable"><a class="header" href="#const-from-shape-castable"><code>Const</code> from shape-castable</a></h1>
<h2 id="summary-28"><a class="header" href="#summary-28">Summary</a></h2>
<p>Allow passing a shape-castable to <code>Const</code>.</p>
<h2 id="motivation-28"><a class="header" href="#motivation-28">Motivation</a></h2>
<p>We currently have two incompatible syntaxes for making a constant, depending on whether it's made from a <code>Shape</code> or a shape-castable.
The former uses <code>Const(value, shape)</code>, while the latter requires <code>shape.const(value)</code>.</p>
<p>Making <code>Const</code> accept shape-castables means we'll have a syntax that works for all shape-likes, reducing the need to special case for shape-castables.</p>
<h2 id="guide--and-reference-level-explanation"><a class="header" href="#guide--and-reference-level-explanation">Guide- and reference-level explanation</a></h2>
<p><code>Const(value, shape)</code> checks whether <code>shape</code> is a shape-castable and returns <code>shape.const(value)</code> when this is the case.</p>
<h2 id="drawbacks-27"><a class="header" href="#drawbacks-27">Drawbacks</a></h2>
<ul>
<li>A <code>Const()</code> constructor sometimes returning non-<code>Const</code> objects can be confusing.
<ul>
<li><code>Signal()</code> already behaves this way.</li>
</ul>
</li>
</ul>
<h2 id="rationale-and-alternatives-26"><a class="header" href="#rationale-and-alternatives-26">Rationale and alternatives</a></h2>
<ul>
<li>This is consistent with how <code>Signal()</code> handles shape-castables.</li>
</ul>
<p>Alternatives:</p>
<ul>
<li>Do not do this. Require code that makes constants from a passed shape-like to check whether it got passed a shape-castable or not and pick the appropriate syntax.</li>
</ul>
<h2 id="prior-art-23"><a class="header" href="#prior-art-23">Prior art</a></h2>
<p><a href="0015-lifting-shape-castables.html">RFC #15</a> added the equivalent behavior to <code>Signal()</code>.</p>
<h2 id="unresolved-questions-26"><a class="header" href="#unresolved-questions-26">Unresolved questions</a></h2>
<p>None.</p>
<h2 id="future-possibilities-26"><a class="header" href="#future-possibilities-26">Future possibilities</a></h2>
<p>None.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2024-02-12</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/43">amaranth-lang/rfcs#43</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth/issues/1110">amaranth-lang/amaranth#1110</a></li>
</ul>
<h1 id="rename-reset-to-init"><a class="header" href="#rename-reset-to-init">Rename <code>reset=</code> to <code>init=</code></a></h1>
<h2 id="summary-29"><a class="header" href="#summary-29">Summary</a></h2>
<p>Rename the <code>reset=</code> keyword argument to <code>init=</code> in <code>Signal()</code>, <code>In()</code>, <code>Out()</code>, <code>Memory()</code>, etc.</p>
<h2 id="motivation-29"><a class="header" href="#motivation-29">Motivation</a></h2>
<p>The value specified by the <code>reset=</code> keyword argument is called an &quot;initial value&quot; in our language guide, never a &quot;reset value&quot;, because when the signal is driven combinatorially, it does not get <em>reset</em> to that value (as it holds no state), but rather <em>initialized</em> to that value whenever the value of the signal is computed.</p>
<p>Calling it a &quot;reset value&quot; (even implicitly, by the name of the keyword argument) makes teaching Amaranth more difficult and is a point of confusion. All of our documentation already has to carefully avoid calling it a &quot;reset value&quot;, and similarly, any Amaranth experts would have to avoid that in speech. Tutorial authors <a href="https://github.com/RobertBaruch/amaranth-tutorial/blob/6a7ebe9cb3b904177df876df01552099e89c031f/3_modules.md#resetdefault-values-for-signals">have to call it out explicitly</a>.</p>
<p><code>Memory</code> already does not have a <code>reset=</code> argument or accessor; it uses <code>init=</code>. <code>Memory</code> should be consistent with <code>Signal</code>.</p>
<h2 id="guide-level-explanation-21"><a class="header" href="#guide-level-explanation-21">Guide-level explanation</a></h2>
<p>All instances of <code>reset=</code> keyword argument in Amaranth are changed to use <code>init=</code>. <code>reset_less=</code>, <code>async_reset=</code>, etc remain as they are. Using <code>reset=</code> raises a deprecation warning but continues working for a long time, perhaps Amaranth 1.0.</p>
<h2 id="reference-level-explanation-21"><a class="header" href="#reference-level-explanation-21">Reference-level explanation</a></h2>
<p>The following entry points have their <code>reset=</code> argument and attribute changed to <code>init=</code>:</p>
<ul>
<li><code>Signal(reset=)</code></li>
<li><code>Signal.like(reset=)</code></li>
<li><code>with m.FSM(reset=):</code></li>
<li><code>FFSynchronizer(reset=)</code></li>
<li><code>Member(reset=)</code> (which handles <code>In(reset=)</code>, <code>Out(reset=)</code>)</li>
</ul>
<p>Specifically:</p>
<ul>
<li>At most one of <code>init=</code> and <code>reset=</code> keyword arguments are accepted. Using <code>reset=</code> prints a deprecation warning. The semantics is exactly the same.</li>
<li>Wherever there was an accessible <code>.reset</code> attribute, a getter and a setter are provided that read/write <code>.init</code>.</li>
<li>No specific deprecation timeline is established, unlike with many other features. We could do this, perhaps, in two years, or by Amaranth 1.0.</li>
</ul>
<h2 id="drawbacks-28"><a class="header" href="#drawbacks-28">Drawbacks</a></h2>
<p>Churn.</p>
<h2 id="rationale-and-alternatives-27"><a class="header" href="#rationale-and-alternatives-27">Rationale and alternatives</a></h2>
<p>The primary alternative is to not do this. Amaranth is steadily gaining popularity, so the earlier we do it the better.</p>
<p>There are no good alternatives to the <code>init=</code> name, especially given our already written documentation and its use for <code>Memory</code>.</p>
<h2 id="prior-art-24"><a class="header" href="#prior-art-24">Prior art</a></h2>
<p>Verilog has <code>initial x = 1;</code>, though that does not result in a reset being inferred.</p>
<h2 id="unresolved-questions-27"><a class="header" href="#unresolved-questions-27">Unresolved questions</a></h2>
<p>When exactly do we remove <code>reset=</code>? It seems valuable to do it as late as possible to minimize breakage of lightly maintained Amaranth code.</p>
<h2 id="future-possibilities-27"><a class="header" href="#future-possibilities-27">Future possibilities</a></h2>
<p>None.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2024-02-05</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/45">amaranth-lang/rfcs#45</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth/issues/1083">amaranth-lang/amaranth#1083</a></li>
</ul>
<h1 id="move-hdlmemory-to-libmemory"><a class="header" href="#move-hdlmemory-to-libmemory">Move <code>hdl.Memory</code> to <code>lib.Memory</code></a></h1>
<blockquote>
<p><strong>Obsoletes</strong>
This RFC is functionally a superset of, and obsoletes, <a href="0040-arbitrary-memory-shape.html">RFC 40</a>.</p>
</blockquote>
<h2 id="summary-30"><a class="header" href="#summary-30">Summary</a></h2>
<p>Move <code>amaranth.hdl.Memory</code> to <code>amaranth.lib.Memory</code>, enabling it to interoperate with the rest of standard library; while we're at it, fix transparency handling.</p>
<h2 id="motivation-30"><a class="header" href="#motivation-30">Motivation</a></h2>
<p>In most ways, a <code>Memory</code> is a normal elaboratable: it has ports, it lowers to a kind of fragment, it can be added as a submodule<sup class="footnote-reference"><a href="#1">1</a></sup>, it has behavior that can be completely expressed in terms of an array of <code>Signal</code>s (which is also how its simulation is internally implemented). However, because it exists in <code>amaranth.hdl</code> and not <code>amaranth.lib</code>, its ports cannot be interface objects, it cannot have a signature and be a component, its lowering cannot be customized, and its behavior cannot include recognizing <code>lib.data</code> shapes. Each of these facts has concrete repercussions:</p>
<ul>
<li>Amaranth SoC would like to have a <code>Memory</code> as a resource in <code>MemoryMap</code>, but this is not possible as it's not a component.</li>
<li><code>DummyPort</code> should morally be a <code>PureInterface</code> object created from a <code>PortSignature</code>, but is its own thing. (It predates <a href="0002-interfaces.html">RFC 2</a>, md would not be able to use it even if it didn't.)</li>
<li>One has to trust that (a) Yosys memory handling core (between RTLIL and Verilog) is correct and (b) the backend toolchain memory technology mapping code (from Verilog) is correct. This is not a given and both open source and proprietary toolchain components have had bugs related to memory mapping, working around which at the time requires very invasive changes rather than using a custom lowering or a replacement component. Vivado in particular has longstanding issues around LUTRAM read port inference.</li>
<li>ASIC flows often support SRAM only in the form of pre-compiled black boxes, without any support for inference. Similarly, handling this case currently requires invasive changes to the code, and is especially difficult in case of standard library FIFOs that are included in third party code, where there is no option besides patching or forking that third party code.
<ul>
<li>For a long time, SPRAM on iCE40 was only supported in the same way when Yosys was used for synthesis, and the workaround for that was universally considered burdensome.<sup class="footnote-reference"><a href="#2">2</a></sup></li>
</ul>
</li>
<li>Memories with large amounts of write ports are useful in out-of-order CPUs, yet aren't supported by any of the toolchains Amaranth can work with. <a href="https://tomverbeure.github.io/2019/08/03/Multiport-Memories.html">Techniques exist</a> to translate memories with any amounts of read and write ports to ones that can be technology mapped by most toolchains, but at the moment it is burdensome to switch between the simulation primitive (which doesn't limit the amount of write ports) and the synthesis lowering.</li>
<li><a href="0040-arbitrary-memory-shape.html">RFC 40</a> had to back out a part of the proposal that was accepted during the vote (special treatment for <code>amaranth.lib.data.ArrayLayout</code>) after it was discovered that it would require a forbidden dependency.</li>
</ul>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Due to historical reasons related to the memory representation in RTLIL, Amaranth had instructed designers to add memory ports as submodules, but at the time of writing adding either the <code>Memory</code> itself or its ports works.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>SPRAM inference still does not work for Amaranth code, due to Amaranth not supporting uninitialized memories. That will be addressed by another RFC.</p>
</div>
<h2 id="guide-level-explanation-22"><a class="header" href="#guide-level-explanation-22">Guide-level explanation</a></h2>
<p><code>amaranth.lib.memory.Memory</code> is a subclass of <code>amaranth.lib.wiring.Component</code>.</p>
<p><code>amaranth.lib.memory.ReadPort</code> and <code>.WritePort</code> are interface objects; their signature classes are <code>amaranth.lib.memory.ReadPort.Signature</code> and <code>.WritePort.Signature</code> respectively, following Amaranth SoC conventions. The read and write port <code>domain</code> is a parameter of the interface object. The read port <code>transparent_for</code> is a parameter of the interface object, and contains a list of <code>WritePort</code> objects. The write port <code>granularity</code> is a parameter of the signature.</p>
<p><code>amaranth.hdl.Memory</code>, <code>.ReadPort</code>, <code>.WritePort</code>, and <code>.DummyPort</code> are deprecated and removed. During the deprecation period they lower to <code>amaranth.lib.memory</code> primitives.</p>
<p>The <code>transparent=</code> parameter of <code>Memory.read_port()</code> is deprecated and removed. During the deprecation period, <code>transparent=True</code> preserves existing behavior.</p>
<p>A new <code>amaranth.hdl.MemoryInstance</code> primitive is added that is lowered by the backend to an appropriate two-dimensional array construct. The interface of this primitive is public but can be changed without notice (although reasonable care will be taken to not break code that relies on it). This primitive exists to fulfill the contract of <code>amaranth.lib</code> (which cannot depend on private Amaranth interfaces) and should not be used whenever it is possible to use <code>amaranth.lib.Memory</code> instead.</p>
<h2 id="reference-level-explanation-22"><a class="header" href="#reference-level-explanation-22">Reference-level explanation</a></h2>
<p>A new module <code>amaranth.lib.memory</code> is added.</p>
<h3 id="memory-ports"><a class="header" href="#memory-ports">Memory ports</a></h3>
<p>Two new signatures are added:</p>
<ul>
<li><code>amaranth.lib.memory.ReadPort.Signature(addr_width, shape)</code>, with members:
<ul>
<li><code>addr: In(addr_width)</code></li>
<li><code>data: Out(shape)</code></li>
<li><code>en: In(1, reset=1)</code></li>
</ul>
</li>
<li><code>amaranth.lib.memory.WritePort.Signature(addr_width, shape, granularity=data_width)</code>, with members:
<ul>
<li><code>addr: In(addr_width)</code></li>
<li><code>data: In(shape)</code></li>
<li><code>en: In(en_width, reset=~0)</code></li>
</ul>
</li>
</ul>
<p>The constructor <code>WritePort.Signature</code> ensures that at least one of the following requirements holds:</p>
<ul>
<li><code>granularity is None</code>, in which case <code>en_width = 1</code>, or</li>
<li><code>shape == unsigned(data_width)</code>, in which case <code>en_width</code> is chosen such that <code>granularity * en_width == data_width</code>, or</li>
<li><code>shape == amaranth.lib.data.ArrayLayout(_, elem_count)</code>, in which case <code>en_width</code> is chosen such that <code>granularity * en_width == elem_count</code>.</li>
</ul>
<p>These signatures create two new interface objects:</p>
<ul>
<li><code>amaranth.lib.memory.ReadPort(signature, *, memory, domain, transparent_for)</code>, where <code>transparent_for</code> is an iterable of write ports (which is converted to <code>tuple</code> and stored).</li>
<li><code>amaranth.lib.memory.WritePort(signature, *, memory, domain)</code></li>
</ul>
<p>These signatures and interface objects are fully introspectable: all of the construction parameters are available as read-only attributes. The interface objects may be created with <code>memory=None</code> to make a stub that can be used in simulation in place of an actual read port.</p>
<h3 id="memory-component"><a class="header" href="#memory-component">Memory component</a></h3>
<p>A new component is added:</p>
<ul>
<li><code>amaranth.lib.memory.Memory(*, shape, depth, init, attrs=None)</code>, with methods:
<ul>
<li><code>.read_port(*, domain=&quot;sync&quot;, transparent_for=())</code>, which creates a <code>ReadPort</code> instance with a signature whose <code>addr_width=ceil_log2(self.depth)</code>. If <code>domain == &quot;comb&quot;</code>, the <code>.en</code> of the returned port is tied off to a constant 1, so as to avoid creating a latch.</li>
<li><code>.write_port(*, domain=&quot;sync&quot;, granularity=None)</code>, which creates a <code>WritePort</code> instance with a signature whose <code>addr_width=ceil_log2(self.depth)</code>. <code>domain</code> cannot be <code>&quot;comb&quot;</code>, so as to avoid creating an array of latches.</li>
</ul>
</li>
</ul>
<p>This component is introspectable: the construction parameters <code>shape</code> and <code>depth</code> are available as read-only attributes; <code>attrs</code> is exposed in the usual way, and the ports added by the <code>read_port</code> and <code>write_port</code> methods are available via the <code>.r_ports</code> and <code>.w_ports</code> read-only attributes.</p>
<p>The <code>init</code> parameter is mandatory; if it is acceptable to initialize the memory with the default value for <code>shape</code> (typically zero) then <code>init=[]</code> should be used. The provided sequence is used to fill in the first <code>len(init)</code> elements of the initializer, and the default value for <code>shape</code> is used for the rest. When support for indeterminate values is added to Amaranth at a later point, the <code>init</code> argument will become optional, and not providing <code>init</code> or providing <code>init=None</code> will leave the memory filled with indeterminate values.<sup class="footnote-reference"><a href="#3">3</a></sup></p>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p>Currently, Amaranth requires every memory to be initialized. This usually works on the FPGA (not in case of iCE40 SPRAM mentioned above), but only at first boot. It does not work (results in a memory filled with indeterminate values, if it has a write port) after an FPGA design is reset, and it does not work at all on ASIC SRAMs. So this is really a special case that became the general one through historical accident. It is highly desirable to lift this restriction but it cannot be done until Amaranth has a concept of an indeterminate value, and its simulator (as well as, likely, CXXRTL) can compute propagation of such values.</p>
</div>
<p>The value of the <code>init</code> parameter, cast to a <code>Memory.Init(*, shape, depth)</code> (name TBD) container is available as the <code>init</code> read-write attribute. This container implements the <code>MutableSequence</code> protocol. The length of this container is always <code>depth</code>. The values that are retrieved by <code>__getitem__</code> are the same as those stored by <code>__setitem__</code> or via the constructor parameter, or <code>None</code> if they were not stored. When a value that is not castable to <code>shape</code> is stored, the appropriate exception is propagated. Assigning to out of bounds indices raises <code>IndexError</code>.</p>
<p>The existing <code>amaranth.hdl.Memory.__getitem__</code> interface is provided on <code>amaranth.lib.memory.Memory</code> with exactly the same semantics as before, which is not defined in this RFC. It is expected that an upcoming RFC addressing async function interface for the simulator will deprecate it.</p>
<p>The signature of <code>amaranth.lib.memory.Memory</code> is always empty because the ports are added using an imperative API. If desired to use with <code>verilog.convert</code>, ports may be manually enumerated, or a wrapper component may be used that has a declarative API.</p>
<p>When <code>amaranth.lib.memory.Memory</code> is elaborated, and the platform has a <code>get_memory</code> function, the <code>Memory.elaborate</code> function returns <code>platform.get_memory(self)</code>, as is customary for standard library components.</p>
<p>Inheriting from <code>amaranth.lib.memory.Memory</code> is allowed, with the restriction that only <code>elaborate</code> can be overridden. Combinations of ports that are illegal for a given target can be rejected during elaboration, but not earlier.</p>
<h3 id="memory-instance"><a class="header" href="#memory-instance">Memory instance</a></h3>
<p>A new class is added as a backend for <code>amaranth.lib.memory.Memory</code>:</p>
<ul>
<li><code>amaranth.hdl.MemoryInstance(*, width, depth, init=None, attrs=None, src_loc=None)</code>, with methods:
<ul>
<li><code>.read_port(*, domain, addr, data, en, transparent_for)</code>, which adds a read port
<ul>
<li><code>addr</code> and <code>en</code> must be value-like</li>
<li><code>data</code> must be an lvalue value-like (with the same validity rules as <code>Instance</code> output ports)</li>
<li><code>transparent_for</code> must be a list of write port indices that this read port should be transparent with</li>
</ul>
</li>
<li><code>.write_port(*, domain, addr, data, en)</code>, which adds a write port and returns a port index, which is an opaque integer
<ul>
<li><code>addr</code>, <code>data</code>, <code>en</code> must be value-like</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>A <code>MemoryInstance</code> is essentially a special low-level HDL construct that will be lowered to native memory representation in the target language. It serves as the default backend for <code>Memory</code> if the platform doesn't supply its own lowering. Due to its nature as a low-level primitive, it provides no introspection support. It can be used as a submodule in the same way as <code>Elaboratable</code> and <code>Instance</code>.</p>
<h3 id="notes"><a class="header" href="#notes">Notes</a></h3>
<p>The usual <code>src_loc_at=</code> parameters are added where appropriate.</p>
<h2 id="drawbacks-29"><a class="header" href="#drawbacks-29">Drawbacks</a></h2>
<ul>
<li>Churn.</li>
<li>An internal interface <code>amaranth.hdl.MemoryInstance</code> becomes perma-unstable public, increasing support burden and potential fragility.</li>
<li>Having the signature of <code>amaranth.lib.memory.Memory</code> be always empty is pretty weird.</li>
</ul>
<h2 id="rationale-and-alternatives-28"><a class="header" href="#rationale-and-alternatives-28">Rationale and alternatives</a></h2>
<p>We could simply not do this and continue to suffer the consequences.</p>
<p>Either more (see &quot;Future possibilities&quot; below) or fewer (see the changes to transparency) features could be integrated into this particular proposal.</p>
<p>The signature of <code>amaranth.lib.memory.Memory</code> could contain all of its ports members. This would violate the current (as of 2024-01) explicitly stated contract of <code>wiring.Component</code> given the builder-style interface. The contract could perhaps be relaxed to say that <code>.signature</code> should only be idempotent, rather than fixed after construction.</p>
<ul>
<li>This isn't possible to solve by making the <code>w_ports</code> member have dimensionality because write ports are non-homogeneous (they can have different granularity).
<ul>
<li>If <code>ratio=</code> is added (see &quot;Future possibilities&quot; below) then this will also apply to <code>r_ports</code> too.</li>
</ul>
</li>
<li>A solution not involving dimensionality would be to have a <code>__getattr__</code> handler matching on <code>r&quot;[rw]_port_\d+&quot;</code> and forwarding to <code>r_ports</code> or <code>w_ports</code>.</li>
</ul>
<p>A much better solution to the same problem is to have a wrapper <code>amaranth.lib.memory.DeclarativeMemory(*, shape, depth, read_ports=1, write_ports=1, ...)</code> (naming TBD) that has a non-empty signature instantiated in the constructor (without any violation of the <code>wiring.Component</code> contract). This wrapper will also be much more valuable in all the likely use cases of <code>verilog.convert(Memory(...))</code>, as the declarative port count based interface is compatible with including it in a Verilog design (via <code>connect_rpc</code>, generated by Amaranth CLI, integrated via FuseSoC, etc), while the imperative builder based interface is not.</p>
<ul>
<li>The declarative interface could allow configuring granularity only for all write ports at once, solving the issue with non-homogeneous ports.
<ul>
<li>There is probably no way to provide <code>ratio=</code> through such an interface.</li>
</ul>
</li>
</ul>
<p>Regarding naming:</p>
<ul>
<li>Having <code>XPort</code> and <code>XPort.Signature</code> follows the current Amaranth SoC convention. An alternative would be to have <code>XPortSignature</code>, but this doesn't really have any benefits and requires importing more names in the relatively rare case where ports and their signatures are used explicitly.</li>
<li><code>r_ports</code> and <code>w_ports</code> follow the naming scheme of <code>lib.fifo</code>.</li>
</ul>
<h2 id="prior-art-25"><a class="header" href="#prior-art-25">Prior art</a></h2>
<p>This proposal mostly builds on the original <code>amaranth.hdl.mem</code> design, which itself builds on the old Yosys memory cell design. This redesign incorporates lessons learned from the Yosys memory cell redesign, and should handle (with features from &quot;Future possibilities&quot; incorporated) nearly any practical memory configuration that can be synthesized to a synchronous SRAM array.</p>
<h2 id="resolved-questions"><a class="header" href="#resolved-questions">Resolved questions</a></h2>
<ul>
<li>Should the signature be empty, or should it contain ports?
<ul>
<li>If it should contain ports: Should <code>lib.wiring</code> be amended to support non-homogeneous arrays, or should a workaround be applied for this specific case?
<ul>
<li>A workaround is easy to do in a reasonably backwards-compatible way here, but this might come up more generally in things like AXI interconnect.</li>
</ul>
</li>
<li>We decided that the signature should be empty.</li>
</ul>
</li>
<li>Should the granularity for <code>ArrayLayout</code> shapes work the way it's described, or some other way?
<ul>
<li>We decided that this behavior is OK.</li>
</ul>
</li>
<li>How exactly should this proposal work in simulation? Right now <code>Memory.__getitem__(index: int)</code> returns an unspecified assignable value that can only be used in simulation. It's been a frequent source of issues when someone tried to synthesize it.
<ul>
<li>The <code>amaranth.hdl.MemoryInstance</code> class could provide a <code>__getitem__</code> implementation returning an unspecified non-value-like proxy class that is a valid simulator command. In this case, <code>Memory</code> subclasses that lower to something else in simulation would have to provide their own <code>__getitem__</code> override matching their lowering.</li>
<li>We decided to leave simulation behavior unspecified in this RFC.</li>
</ul>
</li>
</ul>
<h2 id="future-possibilities-28"><a class="header" href="#future-possibilities-28">Future possibilities</a></h2>
<p>The following work is expected to be done very shortly after this RFC is accepted:</p>
<ul>
<li>The error-prone <code>amaranth.lib.memory.Memory.__getitem__</code> interface is deprecated and replaced with one that mirrors the interface used in async testbenches for signals.</li>
</ul>
<p>Yosys and the new IR support several new features, the support for which can be added in a backwards-compatible way:</p>
<ul>
<li>Memory ports can be &quot;wide&quot;, i.e. have their data width be a multiple of the memory width. This allows defining asymmetric memories, which are especially useful for lane count converting async FIFOs. This feature can be supported by adding a <code>ratio=</code> parameter to <code>Memory.read_port()</code> and <code>.write_port()</code>, which causes the returned signature to have <code>ratio</code> fewer address bits and a factor of <code>1 &lt;&lt; ratio</code> more data bits.</li>
<li>The output register of a synchronous read port can have its initial value set and a reset input connected. This feature can be supported by adding a <code>reset_less=True</code> parameter to <code>ReadPort.Signature</code> and a <code>reset=</code> (or, after RFC 43, <code>init=</code>) parameter to <code>ReadPort</code>. If <code>reset_less=False</code>, the read port output register is reset by the domain reset signal. (At the moment it is not reset at all.)</li>
</ul>
<p>The following other options can be explored:</p>
<ul>
<li>At the time, memories have an empty signature, to combine the imperative builder based interface with the requirements placed by <code>wiring.Component</code>. This means that passing an <code>amaranth.lib.memory.Memory</code> to <code>verilog.convert</code> produces a useless module with no ports (unless <code>ports=</code> is used explicitly). Although niche, this becomes much more useful when memories can have custom lowering.</li>
<li>Alternatively to the previous item, new component with a (slightly more limited) declarative port count based interface could be added instead, to address a need for integrating Amaranth's custom lowering with Verilog designs.</li>
<li>At the time there is no way to pass a memory to <code>VCDWriter(traces=)</code>. This limitation may be lifted.</li>
<li>To aid simulation access to memories, <code>amaranth.hdl.MemoryInstance</code>'s interface may be extended to convey the identity of any particular memory in presence of fragment transformers.
<ul>
<li>Eventually, fragment rewriting itself should go, at which point the identity of the <code>MemoryInstance</code> itself will become usable.</li>
</ul>
</li>
<li>Support for uninitialized memories will be added in a future RFC.</li>
</ul>
<h2 id="acknowledgements-4"><a class="header" href="#acknowledgements-4">Acknowledgements</a></h2>
<p>@wanda-phi and @jfng provided valuable feedback during drafting of this proposal.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2024-02-05</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/46">amaranth-lang/rfcs#46</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth/issues/1081">amaranth-lang/amaranth#1081</a></li>
</ul>
<h1 id="change-shapecastrange1-to-unsigned0"><a class="header" href="#change-shapecastrange1-to-unsigned0">Change <code>Shape.cast(range(1))</code> to <code>unsigned(0)</code></a></h1>
<h2 id="summary-31"><a class="header" href="#summary-31">Summary</a></h2>
<p>Change <code>Shape.cast(range(1))</code> to return <code>unsigned(0)</code> instead of <code>unsigned(1)</code>.</p>
<h2 id="motivation-31"><a class="header" href="#motivation-31">Motivation</a></h2>
<p>Currently, <code>Shape.cast(range(1))</code> returns <code>unsigned(1)</code>. This is inconsistent with the expectation that casting <code>range</code> to a shape will return the minimal shape capable of representing all elements of that range, which is clearly <code>unsigned(0)</code>.</p>
<p>This behavior is an accidental result of using <code>bits_for</code> internally to determine required width for both endpoints, which returns <code>1</code> for an input of <code>0</code>.</p>
<p>The behavior introduces edge cases in unexpected places. For example, one may expect that <code>Memory(depth=depth).read_port().addr.width == ceil_log2(depth)</code>. This is currently false for <code>depth</code> of 1 for no particularly good reason.</p>
<h2 id="guide-level-explanation-23"><a class="header" href="#guide-level-explanation-23">Guide-level explanation</a></h2>
<p><code>Shape.cast(range(1))</code> is changed to return <code>unsigned(0)</code>. The same applies to any other range whose only element is <code>0</code>, like <code>Shape.cast(range(0, 2, 2))</code>.</p>
<p>Arguably, this change requires a negative amount of exlanation, since it removes an edge case and brings the behavior into alignment with the language reference.</p>
<h2 id="reference-level-explanation-23"><a class="header" href="#reference-level-explanation-23">Reference-level explanation</a></h2>
<p>See above.</p>
<h2 id="drawbacks-30"><a class="header" href="#drawbacks-30">Drawbacks</a></h2>
<p>This is a minor backwards compatibility hazard.</p>
<h2 id="rationale-and-alternatives-29"><a class="header" href="#rationale-and-alternatives-29">Rationale and alternatives</a></h2>
<p>The change itself is simple enough that it cannot really be done any other way.</p>
<p>It would be possible to introduce a compatibility warning to the 0.4 branch. However, a <code>range()</code> signal having a shape that's slightly too large is unlikely to cause problems in the first place, so the warning would cause a mass of false positives without a nice way to turn it off.</p>
<h2 id="prior-art-26"><a class="header" href="#prior-art-26">Prior art</a></h2>
<p>None.</p>
<h2 id="unresolved-questions-28"><a class="header" href="#unresolved-questions-28">Unresolved questions</a></h2>
<p>None.</p>
<h2 id="future-possibilities-29"><a class="header" href="#future-possibilities-29">Future possibilities</a></h2>
<p>The <code>bits_for</code> function, which led to this issue in the first place, could be deprecated and removed from public interface to avoid introducing similar problems to external code. Otherwise, it should at the very least be documented and loudly call out this special case.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2024-03-08</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/49">amaranth-lang/rfcs#49</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth-soc/issues/77">amaranth-lang/amaranth-soc#77</a></li>
</ul>
<h1 id="gpio-peripheral-rfc"><a class="header" href="#gpio-peripheral-rfc">GPIO peripheral RFC</a></h1>
<h2 id="summary-32"><a class="header" href="#summary-32">Summary</a></h2>
<p>Add a SoC peripheral to control GPIO pins.</p>
<h2 id="motivation-32"><a class="header" href="#motivation-32">Motivation</a></h2>
<p><a href="https://en.wikipedia.org/wiki/General-purpose_input/output">GPIOs</a> are useful for a wide range of scenarios, such as driving external circuitry or acting as fallback for unimplemented/misbehaving peripherals in early iterations of a design.</p>
<p>Amaranth SoC seems like an appropriate place for a GPIO peripheral, which depends on features that are already provided by the library. Due to its relative simplicity, it is also a good candidate for using the recent CSR register API in realistic conditions.</p>
<h2 id="guide-level-explanation-24"><a class="header" href="#guide-level-explanation-24">Guide-level explanation</a></h2>
<h3 id="usage"><a class="header" href="#usage">Usage</a></h3>
<pre><code class="language-python3">from amaranth import *
from amaranth.lib import wiring
from amaranth.lib.wiring import connect

from amaranth_soc import csr
from amaranth_soc import gpio


class MySoC(wiring.Component):
    def elaborate(self, platform):
        m = Module()

        # ...

        # Use a GPIO peripheral to control four LEDs:

        m.submodules.led_gpio = led_gpio = gpio.Peripheral(pin_count=4, addr_width=8, data_width=8)

        for n in range(4):
            connect(m, led_gpio.pins[n], platform.request(&quot;led&quot;, n, dir=&quot;io&quot;))

        # Add the peripheral to a CSR bus decoder:

        m.submodules.csr_decoder = csr_decoder = csr.Decoder(addr_width=31, data_width=8)

        csr_decoder.add(led_gpio.bus, addr=0x1000)

        # ...

        return m
</code></pre>
<h3 id="overview"><a class="header" href="#overview">Overview</a></h3>
<p>The following figure is a simplified diagram of the peripheral. CSR registers are on the left-hand side, a single pin is on the right side:</p>
<img src="./0049-soc-gpio-peripheral/overview.svg">
<h3 id="registers-1"><a class="header" href="#registers-1">Registers</a></h3>
<h4 id="mode-readwrite"><a class="header" href="#mode-readwrite">Mode (read/write)</a></h4>
<p><img src="./0049-soc-gpio-peripheral/reg-mode.svg"
     alt="bf([
         {name: 'pin_0', bits: 2, attr: 'RW'},
         {name: 'pin_1', bits: 2, attr: 'RW'},
         {name: 'pin_2', bits: 2, attr: 'RW'},
         {name: 'pin_3', bits: 2, attr: 'RW'},
     ], {bits: 8})"></p>
<p>Each <code>Mode.pin_x</code> field can hold the following values:</p>
<pre><code class="language-python3">class Mode(enum.Enum, shape=unsigned(2)):
    INPUT_ONLY = 0b00
    PUSH_PULL  = 0b01
    OPEN_DRAIN = 0b10
    ALTERNATE  = 0b11
</code></pre>
<p>Each <code>Mode.pin_x</code> field resets to <code>INPUT_ONLY</code>.</p>
<p>If <code>Mode.pin_x</code> is <code>INPUT_ONLY</code>:</p>
<ul>
<li><code>pins[x].oe</code> is 0.</li>
<li><code>pins[x].o</code> is connected to <code>Output.pin_x</code>.</li>
<li><code>Input.pin_x</code> is connected to <code>pins[x].i</code>.</li>
<li><code>alt_mode[x]</code> is 0.</li>
</ul>
<p>If <code>Mode.pin_x</code> is <code>PUSH_PULL</code>:</p>
<ul>
<li><code>pins[x].oe</code> is 1.</li>
<li><code>pins[x].o</code> is conencted to <code>Output.pin_x</code>.</li>
<li><code>Input.pin_x</code> is connected to <code>pins[x].i</code>.</li>
<li><code>alt_mode[x]</code> is 0.</li>
</ul>
<p>If <code>Mode.pin_x</code> is <code>OPEN_DRAIN</code>:</p>
<ul>
<li><code>pins[x].oe</code> is connected to <code>~Output.pin_x</code>.</li>
<li><code>pins[x].o</code> is 0.</li>
<li><code>Input.pin_x</code> is connected to <code>pins[x].i</code>.</li>
<li><code>alt_mode[x]</code> is 0.</li>
</ul>
<p>If <code>Mode.pin_x</code> is <code>ALTERNATE</code>:</p>
<ul>
<li><code>pins[x].oe</code> is 0.</li>
<li><code>pins[x].o</code> is connected to <code>Output.pin_x</code>.</li>
<li><code>Input.pin_x</code> is connected to <code>pins[x].i</code>.</li>
<li><code>alt_mode[x]</code> is 1.</li>
</ul>
<p>When <code>alt_mode[x]</code> is 1, a component connected to the GPIO peripheral (such as a pin multiplexer) may assign implementation-specific functions to <code>Input.pin_x</code> and <code>Output.pin_x</code>.</p>
<h4 id="input-read-only"><a class="header" href="#input-read-only">Input (read-only)</a></h4>
<p><img src="./0049-soc-gpio-peripheral/reg-input.svg"
     alt="bf([
         {name: 'pin_0', bits: 1, attr: 'R'},
         {name: 'pin_1', bits: 1, attr: 'R'},
         {name: 'pin_2', bits: 1, attr: 'R'},
         {name: 'pin_3', bits: 1, attr: 'R'},
     ], {bits: 4})"></p>
<p>The number of synchronization stages between <code>pins[x].i</code> and <code>Input.pin_x</code> is defined by the <code>input_stages</code> parameter, which defaults to 2. Synchronization is done on rising edges of <code>ClockSignal(&quot;sync&quot;)</code>.</p>
<h4 id="output-readwrite"><a class="header" href="#output-readwrite">Output (read/write)</a></h4>
<p><img src="./0049-soc-gpio-peripheral/reg-output.svg"
     alt="bf([
         {name: 'pin_0', bits: 1, attr: 'RW'},
         {name: 'pin_1', bits: 1, attr: 'RW'},
         {name: 'pin_2', bits: 1, attr: 'RW'},
         {name: 'pin_3', bits: 1, attr: 'RW'},
     ], {bits: 4})"></p>
<p>Each <code>Output.pin_x</code> field resets to 0.</p>
<h4 id="setclr-write-only"><a class="header" href="#setclr-write-only">SetClr (write-only)</a></h4>
<p><img src="./0049-soc-gpio-peripheral/reg-setclr.svg"
     alt="bf([
         {name: 'pin_0', bits: 2, attr: 'W'},
         {name: 'pin_1', bits: 2, attr: 'W'},
         {name: 'pin_2', bits: 2, attr: 'W'},
         {name: 'pin_3', bits: 2, attr: 'W'},
     ], {bits: 8})"></p>
<ul>
<li>Writing <code>0b01</code> to <code>SetClr.pin_x</code> sets <code>Output.pin_x</code>.</li>
<li>Writing <code>0b10</code> to <code>SetClr.pin_x</code> clears <code>Output.pin_x</code>.</li>
<li>Writing <code>0b00</code> or <code>0b11</code> to <code>SetClr.pin_x</code> has no effect.</li>
</ul>
<h2 id="reference-level-explanation-24"><a class="header" href="#reference-level-explanation-24">Reference-level explanation</a></h2>
<h3 id="amaranth_socgpiopinsignature"><a class="header" href="#amaranth_socgpiopinsignature"><code>amaranth_soc.gpio.PinSignature</code></a></h3>
<p>The <code>gpio.PinSignature</code> class is a <code>wiring.Signature</code> describing the interface between the GPIO peripheral and a single pin.</p>
<p>The members of a <code>gpio.PinSignature</code> are defined as follows:</p>
<pre><code class="language-python3">{
    &quot;i&quot;: In(unsigned(1)),
    &quot;o&quot;: Out(unsigned(1)),
    &quot;oe&quot;: Out(unsigned(1)),
}
</code></pre>
<h3 id="amaranth_socgpioperipheral"><a class="header" href="#amaranth_socgpioperipheral"><code>amaranth_soc.gpio.Peripheral</code></a></h3>
<p>The <code>gpio.Peripheral</code> class is a <code>wiring.Component</code> implementing a GPIO controller, with:</p>
<ul>
<li>a <code>.__init__(self, *, pin_count, addr_width, data_width, name=None, input_stages=2)</code> constructor, where:
<ul>
<li><code>pin_count</code> is a non-negative integer.</li>
<li><code>input_stages</code> is a non-negative integer.</li>
<li><code>addr_width</code>, <code>data_width</code> and <code>name</code> are passed to a <code>csr.Builder</code></li>
</ul>
</li>
<li>a <code>.signature</code> property, that returns a <code>wiring.Signature</code> with the following members:</li>
</ul>
<pre><code class="language-python3">{
    &quot;bus&quot;: In(csr.Signature(addr_width, data_width)),
    &quot;pins&quot;: Out(gpio.PinSignature()).array(pin_count),
    &quot;alt_mode&quot;: Out(unsigned(pin_count)),
}
</code></pre>
<ul>
<li>a <code>.elaborate(self, platform)</code> method, that connects each pin in <code>self.pins</code> to its associated fields in the registers exposed by <code>self.bus</code>.</li>
</ul>
<h2 id="drawbacks-31"><a class="header" href="#drawbacks-31">Drawbacks</a></h2>
<p>While existing implementations (such as STM32 GPIOs) have features like pin multiplexing and configurable pull-up/down resistors, in the proposed design, those would have to be implemented in a separate component.</p>
<h2 id="rationale-and-alternatives-30"><a class="header" href="#rationale-and-alternatives-30">Rationale and alternatives</a></h2>
<p>The proposed design moves platform-specific details outside of its scope, which:</p>
<ul>
<li>reduces the amount of non-portable code to maintain, while allowing implementation freedom for users needing it.</li>
<li>avoids introducing dependencies on upstream APIs that are deprecated or expected to evolve soon (such as <code>amaranth.build</code>).</li>
</ul>
<p>As an alternative:</p>
<ul>
<li>do not host any peripheral in amaranth-soc and always develop them downstream.</li>
<li>include a pin multiplexer inside the GPIO peripheral.</li>
</ul>
<h2 id="prior-art-27"><a class="header" href="#prior-art-27">Prior art</a></h2>
<p>While they can be found in most microcontollers, the design of GPIOs in STM32 has inspired part of this RFC.</p>
<h2 id="unresolved-questions-29"><a class="header" href="#unresolved-questions-29">Unresolved questions</a></h2>
<ul>
<li>
<p><del>Should we support synchronizing a pin input on falling edges of the clock ?</del> (@whitequark) Users can synchronize pin inputs on falling edges by instantiating a <code>gpio.Peripheral</code> with <code>input_stages=0</code>, and providing their own synchronization mechanism.</p>
</li>
<li>
<p>What is our policy for backward-compatible extensions of the peripheral ? (@whitequark) If or when we add registers for new optional features, such as pull-ups, switchable schmitt triggers, switchable output driver strengths, etc, each register will always reside at the same fixed (for a given pin count) address regardless of which features are enabled, and each of these registers will be all-0s after reset, where such all-0s value will provide behavior identical to the behavior of the peripheral without the optional feature. Slots in the address space will never be reallocated with a different meaning once allocated upstream in Amaranth SoC.</p>
<ul>
<li>This will be important to industry users caring about forward and cross-family/cross-configuration compatibility.</li>
<li>In a perfect world this would be our policy for every peripheral. Realistically, we'll only be able to provide this strongest guarantee for only a subset of peripherals.</li>
</ul>
</li>
</ul>
<h2 id="future-possibilities-30"><a class="header" href="#future-possibilities-30">Future possibilities</a></h2>
<ul>
<li>Implement a pin multiplexer peripheral, that can be composed with this one to allow reusing other pins of a SoC as GPIOs.</li>
<li>Add support for interrupts.</li>
</ul>
<h2 id="acknowledgements-5"><a class="header" href="#acknowledgements-5">Acknowledgements</a></h2>
<p>@whitequark and @tpwrules provided valuable feedback while this RFC was being drafted.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2024-03-04</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/50">amaranth-lang/rfcs#50</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth/issues/1186">amaranth-lang/amaranth#1186</a></li>
</ul>
<h1 id="print-statement-and-string-formatting"><a class="header" href="#print-statement-and-string-formatting"><code>Print</code> statement and string formatting</a></h1>
<h2 id="summary-33"><a class="header" href="#summary-33">Summary</a></h2>
<p>A <code>Print</code> statement is added, providing for simulation-time printing. A <code>Format</code> object, based on Python format strings, is added to support the <code>Print</code> statement. The existing <code>Assert</code>, <code>Assume</code>, and <code>Cover</code> statements are modified to make use of <code>Format</code> functionality as well.</p>
<h2 id="motivation-33"><a class="header" href="#motivation-33">Motivation</a></h2>
<p>This functionality has been requested multiple times, for debugging purposes. While debug printing can be provided externally via Python testbenches, having it as a statement allows it to be embedded directly into the module, without having to carefully plumb the required state into the simulator process. Since it can be passed to yosys, it is also usable for cross-language simulation.</p>
<h2 id="guide-level-explanation-25"><a class="header" href="#guide-level-explanation-25">Guide-level explanation</a></h2>
<p>A <code>Print</code> statement can be used to print design state during simulation:</p>
<pre><code>ctr = Signal(16)
m.d.sync += [
    ctr.eq(ctr + 1),
    Print(&quot;counter:&quot;, ctr),
]
</code></pre>
<pre><code>counter: 0
counter: 1
counter: 2
...
</code></pre>
<p>The <code>Print</code> statement is modeled after Python's <code>print</code> function and likewise supports <code>sep=</code> and <code>end=</code> keyword arguments.</p>
<p>For more advanced formatting, <code>Print</code> can be paired with <code>Format</code>, which corresponds to Python string formatting and uses a subset of the same syntax:</p>
<pre><code>ctr = Signal(16)
m.d.sync += [
    ctr.eq(ctr + 1),
    Print(Format(&quot;Counter: {ctr:04x}&quot;, ctr=ctr)),
]
</code></pre>
<pre><code>...
Counter: fffe
Counter: ffff
Counter: 0000
Counter: 0001
Counter: 0002
...
</code></pre>
<p>The <code>Format</code> functionality supports printing <code>Value</code>s as integers, in <code>b</code>, <code>d</code>, <code>o</code>, <code>x</code>, <code>X</code> format types, with most of the relevant formatting options. The <code>c</code> format, which prints the <code>Value</code> treating it as a Unicode code pointer, is also supported.</p>
<p>In addition, the Amaranth-specific <code>s</code> format is supported, which prints a <code>Value</code> as a Verilog-style string (but with opposite byte ordering to Verilog): the <code>Value</code> is treated as a string of octets starting from LSB, any NUL bytes are trimmed, and the octets are interpreted as UTF-8.</p>
<p>Formatting <code>ValueCastable</code> is not supported, and is left for a future RFC. Formatting anything other than <code>Value</code> and <code>ValueCastable</code> will be done at elaboration time by defering to normal Python string formatting.</p>
<p>The <code>Assert</code>, <code>Assume</code>, and <code>Cover</code> statements are extended to take an optional message (which can be a <code>Format</code> object) that will be printed when the statement is triggered:</p>
<pre><code>m.d.sync += Assert(ctr &lt; 10, message=Format(&quot;ctr value {} is out of bounds&quot;, ctr))
</code></pre>
<pre><code>assertion failed at foo.py:13: ctr value 17 is out of bounds
</code></pre>
<p>When message is not included, <code>Assert</code> and <code>Assume</code> will get a default message, while <code>Cover</code> will execute silently.</p>
<p>The <code>Print</code>, <code>Assert</code>, <code>Assume</code>, and <code>Cover</code> statements are supported in the Python simulator, in CXXRTL simulator, and (to the best of target language's ability) in Verilog output.</p>
<p>In pysim, <code>Print</code> prints to standard output. <code>Assert</code> and <code>Assume</code> will throw an <code>AssertionError</code> when the test is false, with the formatted message included in the exception message. The <code>Cover</code> statement prints the message to standard output together with its source location, and the actual coverage tracking functionality is not implemented yet.</p>
<p>While <code>Assert</code> executes identically to <code>Assume</code> (with the exception of failure message), <code>Assert</code> is meant for checking post-conditions, while <code>Assume</code> is meant for checking pre-conditions.</p>
<h2 id="reference-level-explanation-25"><a class="header" href="#reference-level-explanation-25">Reference-level explanation</a></h2>
<h3 id="format-objects"><a class="header" href="#format-objects"><code>Format</code> objects</a></h3>
<p>A new class is introduced for the formatting functionality:</p>
<ul>
<li><code>amaranth.hdl.Format(format_string, /, *args, **kwargs)</code></li>
</ul>
<p>The format string uses exactly the same format string grammar as <code>str.format</code>. Any arguments that are not <code>Value</code> or <code>ValueCastable</code> will be formatted immediately when the <code>Format</code> object is constructed and essentially inlined into the format string. Any <code>ValueCastable</code> arguments are an error (as a placeholder for a future RFC which will specify <code>ValueCastable</code> formatting). Any <code>Value</code> arguments will be stored, to be formatted at simulation time.</p>
<p>For <code>Value</code>, the following subset of standard format specifiers is supported:</p>
<ul>
<li>fill character: supported</li>
<li>alignment: <code>&lt;</code>, <code>&gt;</code>, <code>=</code> (but <em>not</em> <code>^</code>)</li>
<li>sign: <code>-</code>, <code>+</code>, <code> </code></li>
<li><code>#</code> and <code>0</code> options: supported</li>
<li>width: supported, but must be an elaboration-time constant (ie. cannot be another <code>Value</code>)</li>
<li>grouping option: <code>_</code> is supported, <code>,</code> is <em>not</em> supported</li>
<li>type:
<ul>
<li><code>b</code>, <code>c</code>, <code>d</code>, <code>o</code>, <code>x</code>, <code>X</code>: supported, with Python semantics</li>
<li><code>s</code>: the corresponding <code>Value</code> must be a multiple of 8 bits wide; the value is converted into an UTF-8 string LSB-first, any 0 bytes present in the string are removed, and the result is printed as a string</li>
</ul>
</li>
</ul>
<p>Two <code>Format</code> objects can be concatenated together with the <code>+</code> operator.</p>
<p>The <code>Format</code> class is added to the prelude.</p>
<h3 id="the-print-statement"><a class="header" href="#the-print-statement">The <code>Print</code> statement</a></h3>
<p>A <code>Print</code> statement is added:</p>
<ul>
<li><code>amaranth.hdl.Print(*args, sep=&quot; &quot;, end=&quot;\n&quot;)</code></li>
</ul>
<p>Any argument that is not a <code>Format</code> instance will be implicitly converted by wrapping it in <code>Format(&quot;{}&quot;, arg)</code>.</p>
<p>When the statement is executed in simulation, all <code>Format</code> objects will be evaluated to strings, the results will be joined together with the <code>sep</code> argument, the <code>end</code> argument will be appended at the end, and the resulting string will be printed directly to standard output.</p>
<p>A <code>Print</code> statement is considered active iff all <code>If</code>, <code>Case</code>, and <code>State</code> constructs in which it is contained are active.</p>
<p><code>Print</code> statements contained in <code>comb</code> domains will be executed:</p>
<ul>
<li>at the beginning of the simulation, if active at that point</li>
<li>whenever they become active after being previously inactive</li>
<li>whenever any referenced <code>Value</code> changes while they are active</li>
</ul>
<p><code>Print</code> statements contained in non-<code>comb</code> domains will be executed whenever they are active on the relevant clock edge.</p>
<p>The <code>Print</code> statement is added to the prelude.</p>
<h3 id="assert-assume-cover"><a class="header" href="#assert-assume-cover"><code>Assert</code>, <code>Assume</code>, <code>Cover</code></a></h3>
<p>The statements become:</p>
<ul>
<li><code>amaranth.hdl.Assert(test, message=None)</code></li>
<li><code>amaranth.hdl.Assume(test, message=None)</code></li>
<li><code>amaranth.hdl.Cover(test, message=None)</code></li>
</ul>
<p>The <code>name</code> argument is deprecated and removed.</p>
<p>The <code>message</code> argument can be either <code>None</code>, a string, or a <code>Format</code> object. If it is a string, it's equivalent to passing <code>Format(&quot;{}&quot;, s)</code>.</p>
<p>Whenever an <code>Assert</code> or <code>Assume</code> is active and <code>test</code> evaluates to false, the simulator throws an <code>AssertionError</code> and includes the formatted <code>message</code>, if any, in the payload.</p>
<p>Whenever a <code>Cover</code> is active and <code>test</code> evaluates to true, and the <code>Cover</code> has a message attached, the formatted message is printed to standard output along with the source location.</p>
<p>The <code>Assert</code> statement is added to the prelude. The <code>Assume</code> and <code>Cover</code> statements need to be imported manually from <code>amaranth.hdl</code>. Their old location in <code>amaranth.asserts</code> is deprecated.</p>
<h3 id="miscellaneous"><a class="header" href="#miscellaneous">Miscellaneous</a></h3>
<p>To guard against accidentally using plain Python formatting, an implementation of <code>__format__</code> is added to <code>Value</code> that always raises a <code>TypeError</code> with a message directing the user to <code>Format</code>. If the old behavior of printing the AST serialization is desired for some reason, <code>&quot;{value!r}&quot;</code> can still be used.</p>
<h2 id="drawbacks-32"><a class="header" href="#drawbacks-32">Drawbacks</a></h2>
<p>This is some quite complex functionality. It cannot be fully represented in Verilog output, since Verilog is quite limitted in its formatting capabilities.</p>
<p>It is not fully clear what <code>Assume</code> and especially <code>Cover</code> semantics should be, and they are very much formal verification oriented.</p>
<p>Unfortunately the <code>f&quot;&quot;</code> syntax is not supported. The hacks that would be necessary to make this work are too horrifying even for the authors of this RFC.</p>
<h2 id="rationale-and-alternatives-31"><a class="header" href="#rationale-and-alternatives-31">Rationale and alternatives</a></h2>
<p>The design follows Python prior art, not leaving much space for discussion. The exact subset of supported format specifiers is, of course, to be bikeshedded.</p>
<p>The <code>s</code> format specifier is included to provide a way to implement data-dependent string printing, eg. for printing an enum value. It is expected this may be used for lowering future <code>ValueCastable</code> printing.</p>
<p>Signals that are enum-typed could get special default formatting. However, this will be solved by future <code>ValueCastable</code> hooks for Amaranth enums.</p>
<h2 id="prior-art-28"><a class="header" href="#prior-art-28">Prior art</a></h2>
<p>The design of <code>Print</code>, <code>Format</code> and <code>Assert</code> closely follows Python, as much as is easily possible.</p>
<p>The <code>s</code> format specifier is based directly on Verilog strings.</p>
<p>The <code>Print</code> statement corresponds and synthesizes to RTLIL <code>$print</code> cell, aligning closely to its capabilities.</p>
<p>The <code>Print</code> statement is loosely modelled on Verilog's <code>$display</code> and related task. The <code>Assert</code>, <code>Assume</code>, and <code>Cover</code> statements are loosely based on corresponding SystemVerilog statements.</p>
<h2 id="unresolved-questions-30"><a class="header" href="#unresolved-questions-30">Unresolved questions</a></h2>
<ul>
<li>What exact format specifiers should be supported?</li>
</ul>
<h2 id="future-possibilities-31"><a class="header" href="#future-possibilities-31">Future possibilities</a></h2>
<p><code>ValueCastable</code> formatting can and should be implemented by an extension hook on the <code>ValueCastable</code> class.</p>
<p><code>Format</code> could be made into a (non-synthesizable) <code>Value</code> itself, corresponding to <code>$sformat</code> in Verilog. This would be useful for creating more complex formatting for <code>ValueCastables</code>.</p>
<p>Some kind of output redirection or output hook could be implemented in pysim.</p>
<p>Likewise, a hook for assertion failure could be desirable.</p>
<p>Actual coverage tracking could be implemented in pysim for <code>Cover</code>.</p>
<p>More exotic formatting could be useful (eg. for the proposed fixed point numbers).</p>
<p>Some way to print the current simulation time could be useful.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: (fill me in with today's date, 2024-03-04)</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/51">amaranth-lang/rfcs#51</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth/issues/1187">amaranth-lang/amaranth#1187</a></li>
</ul>
<h1 id="add-shapecastablefrom_bits-and-amaranthlibdataconst"><a class="header" href="#add-shapecastablefrom_bits-and-amaranthlibdataconst">Add <code>ShapeCastable.from_bits</code> and <code>amaranth.lib.data.Const</code></a></h1>
<h2 id="summary-34"><a class="header" href="#summary-34">Summary</a></h2>
<p>A new user-definable method is added to <code>ShapeCastable</code>: <code>from_bits(bits: int)</code>. It is used to convert constants into user-defined types, for example when a user-typed value is read in simulation.</p>
<p>A new type is added: <code>amaranth.lib.data.Const</code>. It is used as the return type of <code>Layout.from_bits</code>. <code>Layout.const</code> is also changed to return it instead of <code>View</code>.</p>
<h2 id="motivation-34"><a class="header" href="#motivation-34">Motivation</a></h2>
<p>The current Amaranth model provides a useful set of primitives for manipulating opaque signals and values of custom types, via <code>ShapeCastable</code> and <code>ValueCastable</code>.  However, there is little support for manipulating constants of custom types.</p>
<p>This is reasonable, as Amaranth mostly deals with elaborating a design hierarchy that operates on symbolic values that won't have actual values assigned before the circuit is operational. However,  this need comes up in the Amaranth simulator, where the values have to be actually materialized.</p>
<p>Specifically, the simulator requires two operations to usefully support <code>ValueCastable</code> expressions:</p>
<ol>
<li>Conversion from user-facing constant value to raw bits, used when a <code>ValueCastable</code> experession is set to a value, or a cell of <code>ShapeCastable</code>-typed <code>Memory</code> is written by a user process. This need is already covered by the existing <code>ShapeCastable.const</code>.</li>
<li>Conversion from raw bits to user-facing constant value, used when a <code>ValueCastable</code> expression is requested, or a cell of <code>ShapeCastable</code>-type <code>Memory</code> is read by a user process. This need will be covered by the proposed <code>from_bits</code> method.</li>
</ol>
<p>For <code>amaranth.lib.enum</code>, the implementation of <code>from_bits</code> is trival: the value is looked up in the enum, and the enum value is returned. However, we have no good type to return from <code>from_bits</code> for <code>amaranth.lib.data</code>. Thus, a new <code>lib.data.Const</code> class is proposed.</p>
<h2 id="guide-level-explanation-26"><a class="header" href="#guide-level-explanation-26">Guide-level explanation</a></h2>
<p>A new method is added to <code>ShapeCastable</code>: <code>from_bits(bits: int)</code>, which, given a constant, interprets the constant as a value of the given <code>ShapeCastable</code> and returns an arbitrary Python value. The returned value must be round-trippable back to the original constant via <code>ShapeCastable.const</code>. This method will be used whenever there is a need to translate a raw bit pattern through a <code>ShapeCastable</code>, such as when reading a <code>ShapeCastable</code>-typed value in simulation.</p>
<pre><code>&gt;&gt;&gt; class Abc(amaranth.lib.enum.Enum, shape=unsigned(2)):
...     X = 0
...     Y = 1
...     Z = 2
... 
&gt;&gt;&gt; Abc.from_bits(2)
&lt;Abc.Z: 2&gt;
</code></pre>
<p>To support this functionality in <code>amaranth.lib.data</code>, a new <code>lib.data.Const</code> class is added, which wraps a constant. Like <code>View</code>, this class provides attribute-based and indexing-based access to <code>Layout</code> fields. However, when a field is accessed, <code>lib.data.Const</code> returns a raw int value (for plain <code>Shape</code>-typed fields), or calls <code>from_bits</code> on the underlying bit pattern (for <code>ShapeCastable</code> fields). The class is also <code>ValueCastable</code>.</p>
<pre><code>&gt;&gt;&gt; class Def(amaranth.lib.data.Struct):
...     a: Abc
...     b: unsigned(2)
... 
&gt;&gt;&gt; a = Def.from_bits(9)
&gt;&gt;&gt; a
Const(StructLayout({'a': &lt;enum 'Abc'&gt;, 'b': unsigned(2)}), 9)
&gt;&gt;&gt; a.a
&lt;Abc.Y: 1&gt;
&gt;&gt;&gt; a.b
2
</code></pre>
<p>Since it is a better fit, the return type of <code>Layout.const</code> is changed to <code>lib.data.Const</code>.</p>
<h2 id="reference-level-explanation-26"><a class="header" href="#reference-level-explanation-26">Reference-level explanation</a></h2>
<p>A new method is added on <code>ShapeCastable</code>: <code>from_bits(bits: int)</code>. The default implementation raises an error. A warning is raised when this method is not overriden in a subclass. The warning will become a hard error in Amaranth 0.6.</p>
<p>The argument to the method must be an <code>int</code> that is a valid constant value of the <code>ShapeCastable</code>'s underlying shape.</p>
<p>The method must return something acceptable to the <code>const</code> method on the same <code>ShapeCastable</code>, and the value must round-trip, that is:</p>
<pre><code># assume `bits` is an int that is a valid const of `shape_castable.as_shape()`
value = shape_castable.const(shape_castable.from_bits(bits)).as_value()
assert isinstance(value, Const)
assert value.value == bits
</code></pre>
<p>It is recommended, but not strictly required, that the returned value is a <code>ValueLike</code>.</p>
<p>The <code>sim.get</code> method in the upcoming RFC 36 will call this method when called on a <code>ValueCastable</code> with a custom shape. The <code>sim.set</code> method will likewise call <code>ShapeCastable.const</code>.</p>
<p>A <code>from_bits</code> implementation is added onto <code>amaranth.lib.enum.EnumMeta</code>. If the given bit pattern has a corresponding enum value, the enum value is returned. Otherwise, the argument is returned unchanged.</p>
<p>A new class is added:</p>
<ul>
<li><code>amaranth.lib.data.Const(layout, bits: int)</code>: bits must be a valid constant of the underlying shape; derives from <code>ValueCastable</code>
<ul>
<li><code>shape()</code>: returns the underlying shape</li>
<li><code>as_value()</code>: returns <code>Const(bits, len(layout))</code></li>
<li><code>__getitem__</code>:
<ul>
<li>resolves the field like <code>View.__getitem__</code></li>
<li>extracts the corresponding field from <code>bits</code></li>
<li>if the field is a <code>ShapeCastable</code>, returns the result of calling its <code>from_bits</code> with the extracted value</li>
<li>otherwise, returns the raw field value as an <code>int</code></li>
</ul>
</li>
<li><code>__getattr__</code>: resolves the field like <code>View.__getattr__</code>, then proceeds as above</li>
<li><code>__eq__</code> and <code>__ne__</code>:
<ul>
<li>if the other value is a <code>lib.data.Const</code> with the same layout, compares the underlying <code>bits</code> and returns a Python <code>bool</code></li>
<li>if the other value is a <code>View</code> with the same layout, delegates to <code>Value.__eq__</code> (and thus returns a 1-bit <code>Value</code>)</li>
<li>otherwise, raises <code>TypeError</code></li>
</ul>
</li>
<li>all other operators: raises <code>TypeError</code> (to prevent the default <code>Value</code> operator implementations)</li>
</ul>
</li>
</ul>
<p>A <code>from_bits</code> implementation is added to <code>Layout</code>, <code>Struct</code>, and <code>Union</code>. It returns a <code>lib.data.Const</code> instance.</p>
<p><code>Layout.const</code>, <code>Struct.const</code>, and <code>Union.const</code> are changed to return a <code>lib.data.Const</code> of matching layout. They are also changed to accept such constants if given, and return them unchanged.</p>
<h2 id="drawbacks-33"><a class="header" href="#drawbacks-33">Drawbacks</a></h2>
<p>Adds an extra hook onto <code>ShapeCastable</code> that everyone must implement. However, it is not clear how this could be avoided.</p>
<p>When a <code>Struct</code> (or <code>Union</code>) is involved, <code>isinstance(sim.get(my_struct_signal), MyStruct)</code> will be false. This could be avoided by horrifying metaclass hacks, but it's unclear if it's a good idea.</p>
<p>The change to <code>Layout.const</code> etc is not fully backwards-compatible. It is believed that this is not much of an issue, since its main user is <code>Signal</code> <code>init=</code> argument, for which it doesn't matter.</p>
<h2 id="rationale-and-alternatives-32"><a class="header" href="#rationale-and-alternatives-32">Rationale and alternatives</a></h2>
<p>The proposed design of <code>from_bits</code> is essentially the minimal interface needed to support the needs of simulation. Additionally, it is designed so that it can be called essentially recursively by aggregate <code>ShapeCastable</code>s, such as <code>Layout</code>.</p>
<p>An alternative (proposed originally by RFC 36) would be to let <code>ValueCastable</code> implement <code>get</code>/<code>set</code> methods for simulation. However, this has obvious drawbacks:</p>
<ul>
<li>two methods needed per <code>ShapeCastable</code></li>
<li>doesn't work for reading or writing memories, as they don't have underlying signals</li>
<li>when the value is an aggregate, there's no obvious way to delegate to construct the values of fields</li>
</ul>
<p>The <code>lib.data.Const</code> design closely follows <code>View</code>. An alternative would be for <code>from_bits</code> to return a list or dict of fields (recursively processed by <code>from_bits</code>), paralleling the accepted argument format of <code>const</code>. However, this results in inferior user experience.</p>
<p><code>lib.data.Const</code> conceivably could be made mutable, providing <code>__setattr__</code> / <code>__setitem__</code> in the future. However, Amaranth tries to avoid mutable data types, and it was felt that keeping it explicitly immutable was the best way forward. Its main use is believed to be simulation, and in simulation one can just call <code>sim.set()</code> on the <code>View</code> field directly if needed. Outside of simulation, we can add a <code>.like()</code>-like constructor for <code>lib.data.Const</code> to modify some fields of the aggregate.</p>
<h2 id="prior-art-29"><a class="header" href="#prior-art-29">Prior art</a></h2>
<p>The author believes user-defined types usually come in three parts:</p>
<ul>
<li>a <code>ShapeCastable</code>, ie. the type itself</li>
<li>a <code>ValueCastable</code> proxying arbitrary <code>Value</code>s</li>
<li>a class representing constant values of the type</li>
</ul>
<p>For enums, these correspond to <code>EnumMeta</code>, <code>EnumView</code>, and the <code>Enum</code> itself. For plain values, they correspond to <code>Shape</code>, <code>Value</code>, and <code>int</code>. The proposed RFC 41 likewise includes <code>fixed.Shape</code>, <code>fixed.Value</code>, and <code>fixed.Const</code>.</p>
<p>The first half of this RFC provides a generic way to construct the third part from a bit pattern. The second half of this RFC fills the missing third part for <code>amaranth.lib.data</code>.</p>
<h2 id="unresolved-questions-31"><a class="header" href="#unresolved-questions-31">Unresolved questions</a></h2>
<p>None.</p>
<h2 id="future-possibilities-32"><a class="header" href="#future-possibilities-32">Future possibilities</a></h2>
<p>The <code>lib.data.Const</code> class can be expanded in functionality:</p>
<ul>
<li>alternative constructors could be added, to let user create and manipulate const struct-typed values</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2024-07-01</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/52">amaranth-lang/rfcs#52</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth/issues/1445">amaranth-lang/amaranth#1445</a></li>
</ul>
<h1 id="add-amaranthhdlchoice-a-pattern-based-value-multiplexer"><a class="header" href="#add-amaranthhdlchoice-a-pattern-based-value-multiplexer">Add <code>amaranth.hdl.Choice</code>, a pattern-based <code>Value</code> multiplexer</a></h1>
<h2 id="summary-35"><a class="header" href="#summary-35">Summary</a></h2>
<p>A new type of expression is added: <code>amaranth.hdl.Choice</code>. It is essentially a variant of <code>m.Switch</code>
that returns a <code>Value</code> using the same patterns as <code>m.Case</code> for selection.</p>
<h2 id="motivation-35"><a class="header" href="#motivation-35">Motivation</a></h2>
<p>We currently have several multiplexer primitives:</p>
<ul>
<li><code>Mux</code>, selecting from two values</li>
<li><code>Array</code> indexing, selecting from multiple values by a simple index</li>
<li><code>.bit_select</code> and <code>.word_select</code>, selecting from slices of a single value by a simple index</li>
<li><code>m.Switch</code> together with combinatorial assignment to an intermediate <code>Signal</code>, selecting from multiple values by pattern matching</li>
</ul>
<p>It is, however, not possible to select from multiple values by pattern matching without using an intermediate <code>Signal</code> and assignment (which can be a problem in contexts where a <code>Module</code> is not available). This RFC aims to close this hole.</p>
<p>This feature is generally useful and has been on the roadmap for a while. The immediate impulse for writing this RFC was using this functionality to implement string formatting for <code>lib.enum</code> values.</p>
<h2 id="guide-level-explanation-27"><a class="header" href="#guide-level-explanation-27">Guide-level explanation</a></h2>
<p>The <code>Choice</code> expression can be used to select from among several values via pattern matching:</p>
<pre><code class="language-py">abc = Signal(8)
a = Signal(8)
b = Signal(8)
sel = Signal(4)
m.d.comb += abc.eq(Choice(sel)
    # any pattern or tuple of patterns usable in `Value.matches` or `m.Case` is valid as key
    .case(1, a)
    .case(2, b)
    .case((3, 4), a + b)
    .case(&quot;11--&quot;,  a - b)
    .case((&quot;10--&quot;, &quot;011-&quot;), a * b)
    .default(13)
)
</code></pre>
<p>is equivalent to writing:</p>
<pre><code class="language-py">with m.Switch(sel):
    with m.Case(1):
        m.d.comb += abc.eq(a)
    with m.Case(2):
        m.d.comb += abc.eq(b)
    with m.Case(3, 4):
        m.d.comb += abc.eq(a + b)
    with m.Case(&quot;11--&quot;):
        m.d.comb += abc.eq(a - b)
    with m.Case(&quot;10--&quot;, &quot;011-&quot;):
        m.d.comb += abc.eq(a * b)
    with m.Default():
        m.d.comb += abc.eq(13)
</code></pre>
<p><code>Choice</code> can also be used on the left-hand side of an assignment:</p>
<pre><code class="language-py">a = Signal(8)
b = Signal(8)
c = Signal(8)
d = Signal(8)
sel = Signal(2)
m.d.sync += (Choice(sel)
    .case(0, a)
    .case(1, b)
    .case(2, c)
    .default(d)
    .eq(0))
</code></pre>
<p>which is equivalent to:</p>
<pre><code class="language-py">with m.Switch(sel):
    with m.Case(0):
        m.d.sync += a.eq(0)
    with m.Case(1):
        m.d.sync += b.eq(0)
    with m.Case(2):
        m.d.sync += c.eq(0)
    with m.Default():
        m.d.sync += d.eq(0)
</code></pre>
<p>If <code>default=</code> is not used, the default value is 0 when on right-hand side, and no assignment happens when on left-hand side.</p>
<p>In addition, <code>Mux</code> becomes assignable if the second and third argument are both assignable.</p>
<h2 id="reference-level-explanation-27"><a class="header" href="#reference-level-explanation-27">Reference-level explanation</a></h2>
<p>A new expression type is added:</p>
<ul>
<li><code>amaranth.hdl.Choice(sel: ValueLike)</code>: creates a new <code>Choice</code> expression with no cases
<ul>
<li><code>.case(self, patterns: int | str | tuple[int | str], value: ValueLike) -&gt; Choice</code>: creates a new <code>Choice</code> based on this one, adding anoter case to it</li>
<li><code>.default(self, value: ValueLike) -&gt; Choice</code>: creates a new <code>Choice</code> based on this one, adding a default case to it</li>
</ul>
</li>
</ul>
<p>The expression evaluates <code>sel</code>, then matches it to <code>patterns</code> of every <code>.case()</code> in turn. If a match is found, the expression evaluates to the corresponding <code>value</code> of the first found match. If no match is found, the expression evaluates to the <code>value</code> of <code>.default()</code>, or to <code>Cat()</code> with no arguments if no <code>.default()</code> was used. The expression is assignable if all <code>.case()</code> values and <code>.default()</code> value (if any) are assignable.</p>
<p>Neither <code>.case()</code> nor <code>.default()</code> can be called on a <code>Choice</code> that already has a <code>.default()</code>.</p>
<p>The shape of the expression is determined as follows:</p>
<ul>
<li>if all <code>value</code> arguments are <code>ShapeCastable</code>, and it is the same <code>ShapeCastable</code> for all of them (as determined by <code>__eq__</code> on the <code>ShapeCastable</code>), the resulting value is transformed through <code>ShapeCastable.__call__</code> of that shape-castable</li>
<li>if all <code>value</code> arguments have a plain <code>Shape</code>, the minimum shape that can represent the shapes of all <code>cases</code> values and <code>default</code> (ie. determined the same as for <code>Array</code> proxy or <code>Mux</code> tree).</li>
<li>otherwise, an exception is raised</li>
</ul>
<p>The default when <code>.default()</code> is not specified is <code>Cat()</code> to ensure the correct semantics for assignment (ie. discarding the assigned value). This also happens to provide the default 0 when on right-hand side.</p>
<p><code>Choice</code> is also added to the Amaranth prelude.</p>
<p>In addition, the existing <code>Mux</code> expression is made valid on the left-hand side of an assignment, as if it was lowered as follows:</p>
<pre><code class="language-py">def Mux(sel, val1, val0):
    return Choice(sel).case(0, val0).default(val1)
</code></pre>
<p><code>ArrayProxy</code> (ie. the type currently returned by <code>Array</code> indexing) is changed from a native <code>Value</code> to a <code>ValueCastable</code> that lowers to <code>Choice</code> (removing the odd case where we can currently build an invaid <code>Value</code>). To avoid problems with lowering the out-of-bounds case, the value returned for out-of-bounds <code>Array</code> accesses is changed to 0.</p>
<p><code>__eq__</code> is added to the <code>ShapeCastable</code> protocol and documented (we already have suitable implementations in <code>lib.data</code> and <code>lib.enum</code>).</p>
<h2 id="drawbacks-34"><a class="header" href="#drawbacks-34">Drawbacks</a></h2>
<p>The language gets slightly more complex.</p>
<h2 id="rationale-and-alternatives-33"><a class="header" href="#rationale-and-alternatives-33">Rationale and alternatives</a></h2>
<p>The core functionality is fairly obvious. However, the syntax is not. Other possibilities include:</p>
<ul>
<li>
<p><code>*args</code> (or perhaps iterable) of <code>(key, value)</code> tuples:</p>
<pre><code class="language-py">Choices(sel,
    (1, a),
    (2, b),
    ((3, 4), c),
    (&quot;11--&quot;, d),
    default=e
)
</code></pre>
</li>
<li>
<p>*args of newly-defined <code>amaranth.hdl.Case</code> object (not to be confused with <code>m.Case</code>):</p>
<pre><code class="language-py">Choices(sel,
    Case(1, a),
    Case(2, b),
    Case((3, 4), c),
    Case(&quot;11--&quot;, d),
    default=e,
)
</code></pre>
</li>
</ul>
<p>The syntax proposed has been selected to have extension space (in the form of keyword arguments) for e.g. optional guard conditions.</p>
<h2 id="prior-art-30"><a class="header" href="#prior-art-30">Prior art</a></h2>
<p>This feature is inspired by Rust <code>match</code> construct.</p>
<h2 id="unresolved-questions-32"><a class="header" href="#unresolved-questions-32">Unresolved questions</a></h2>
<p>The name is subject to bikeshed. An obvious alternative is <code>Match</code>, though this RFC avoids using this name, as it suggests much more advanced pattern matching (with variable capture) than is currently available.</p>
<h2 id="future-possibilities-33"><a class="header" href="#future-possibilities-33">Future possibilities</a></h2>
<p>Optional guard conditions could be added to <code>Choice</code> and <code>m.Switch</code> cases (like Rust's <code>if</code> guards on <code>match</code> branches).</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2024-03-11</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/53">amaranth-lang/rfcs#53</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth/issues/1195">amaranth-lang/amaranth#1195</a></li>
</ul>
<h1 id="low-level-io-primitives"><a class="header" href="#low-level-io-primitives">Low-level I/O primitives</a></h1>
<h2 id="summary-36"><a class="header" href="#summary-36">Summary</a></h2>
<p>A new first-class concept is introduced to the language, I/O ports, representing top-level ports in synthesis flows. I/O ports can be obtained from the platform, or can be manually constructed by the user in raw Verilog flows that don't use a supported platform.</p>
<p>I/O ports can be connected to <code>Instance</code> ports. This becomes the only thing that can be connected to <code>Instance</code> ports with <code>io</code> directionality.</p>
<p>A new <code>IOBufferInstance</code> primitive is introduced that can consume an I/O port without involving vendor-specific cells.</p>
<h2 id="motivation-36"><a class="header" href="#motivation-36">Motivation</a></h2>
<p>The current process for creating top-level ports is rather roundabout and involves the platform calling into multiple private APIs:</p>
<ol>
<li>The user calls <code>platform.request</code>, which information about the requested pin, and returns an interface object.
<ol>
<li>A <code>Signal</code> for the raw port is created and stored on the platform, together with metadata.</li>
<li>If raw port is requested (<code>dir='-'</code>), that signal is returned (in a wrapper object).</li>
<li>Otherwise, an I/O buffer primitive is instantiated that drives the raw port, and the returned interface contains signals controlling that buffer. Depending on the platform, this could be either a vendor-specific cell (via <code>Instance</code>) or a generic tristate buffer (via <code>IOBufferInstance</code>, which is currently a private API).</li>
</ol>
</li>
<li>The hierarchy is elaborated via <code>Fragment.get</code>.</li>
<li>Platform performs first half of design preparation via private <code>Fragment</code> APIs (domains are resolved, missing domains are created).</li>
<li>Platform installs all instantiated I/O buffers into the elaborated hierarchy and gathers all top-level port signals.</li>
<li>Platform finishes design preparation via more private APIs, then calls RTLIL or Verilog backend.</li>
<li>Platform uses the gathered list of top-level ports to create a constraint file.</li>
</ol>
<p>If the <code>io</code> directionality is involved, the top-level port is a cursed kind of <code>Signal</code> that doesn't follow the usual rules:</p>
<ul>
<li>it effectively has two drivers (the <code>Instance</code> or <code>IOBufferInstance</code> and the external world)</li>
<li>on the Amaranth side, it can only be connected to at most one <code>Instance</code> or <code>IOBufferInstance</code> (ie. it cannot be peeked at)</li>
</ul>
<p>This proposal aims to:</p>
<ul>
<li>provide a platform-independent way to instantiate and use top-level ports</li>
<li>significantly reduce the amount of private APIs used in platform code</li>
<li>provide a stricter model of I/O ports, no longer overloading <code>Signal</code></li>
</ul>
<h2 id="scope-and-roadmap"><a class="header" href="#scope-and-roadmap">Scope and roadmap</a></h2>
<p>The proposal is only about low-level primitives implemented in <code>amaranth.hdl</code>. It is to be followed with:</p>
<ol>
<li>Another RFC proposing generic I/O buffer components with platform hooks in <code>lib.io</code>.</li>
<li>Overhaul of the platform API (as of now undetermined).</li>
</ol>
<h2 id="guide-level-explanation-28"><a class="header" href="#guide-level-explanation-28">Guide-level explanation</a></h2>
<h3 id="ioports-and-their-use"><a class="header" href="#ioports-and-their-use"><code>IOPort</code>s and their use</a></h3>
<p>When creating a synthesizable top-level design with Amaranth, top-level ports are represented by the <code>IOPort</code> class. If you're not using the Amaranth platform machinery, you can instantiate a top-level port like this:</p>
<pre><code class="language-py">abc = IOPort(8, name=&quot;abc&quot;) # The port is 8 bits wide.
</code></pre>
<p>If a platform is in use, <code>IOPort</code>s should be requested via <code>platform.request</code> instead of created manually ‚Äî the platform will associate its own metadata with ports.</p>
<p>To actually use such a port from a design, you need to instantiate an I/O buffer:</p>
<pre><code class="language-py">abc_o = Signal(8)
abc_i = Signal(8)
abc_oe = Signal()
m.submodules += IOBufferInstance(abc, i=abc_i, o=abc_o, oe=abc_oe)
# abc_o and abc_oe can now be written to drive the port, abc_i can be read to determine the state of the port.
</code></pre>
<p>This automatically creates an <code>inout</code> port on the design. You can also create an <code>output</code> port by skipping the <code>i=</code> argument, or an <code>input</code> port by skipping the <code>o=</code> and <code>oe=</code> arguments.</p>
<p>If the <code>o=</code> argument is passed, but <code>oe=</code> is not, a default of <code>oe=Const(1)</code> is assumed.</p>
<p>Alternatively, <code>IOPort</code>s can be connected directly to <code>Instance</code> ports:</p>
<pre><code class="language-py"># Equivalent to the above, using Xilinx IOBUF cells.
for i in range(8):
    m.submodules += Instance(&quot;IOBUF&quot;,
        i_I=abc_o[i],
        i_T=~abc_oe,
        o_O=abc_i[i],
        io_IO=abc[i],
    )
</code></pre>
<p>Just like values, <code>IOPort</code>s can be sliced with normal Python indexing and concatenated with <code>Cat</code>.</p>
<p><code>IOPort</code>s can only be consumed by <code>IOBufferInstance</code> and <code>Instance</code> ports ‚Äî they cannot be used as plain values. Every <code>IOPort</code> bit can be consumed at most once.</p>
<p>Only <code>IOPort</code>s (and their slices or concatenations) can be connected to <code>Instance</code> ports with <code>io</code> directionality. Ports with <code>i</code> and <code>o</code> directionalities can be connected to both <code>IOPort</code>s and plain <code>Value</code>s.</p>
<h3 id="general-note-on-top-level-ports"><a class="header" href="#general-note-on-top-level-ports">General note on top-level ports</a></h3>
<p>Amaranth provides many ways of specifying top-level ports, to be used as appropriate for the design:</p>
<ol>
<li>For a top-level synthesizable design using a platform, ports are created by <code>platform.request</code> which either returns a raw <code>IOPort</code> or immediately wraps it in an I/O buffer.</li>
<li>For a top-level synthesizable design without using a platform, <code>IOPort</code>s can be created manually as above.</li>
<li>For a partial synthesizable design (to be used with eg. a Verilog top level), the top elaboratable can be a <code>lib.wiring.Component</code>, and the ports will be automatically derived from its signature + any unresolved domains.</li>
<li>For a partial synthesizable design without using <code>lib.wiring.Component</code>, the list of signals to be used as top-level ports can be specified out-of-band to the backend via the <code>ports=</code> argument.</li>
<li>For simulation, top-level ports are not used at all.</li>
</ol>
<h2 id="reference-level-explanation-28"><a class="header" href="#reference-level-explanation-28">Reference-level explanation</a></h2>
<h3 id="ioport-and-iovalue"><a class="header" href="#ioport-and-iovalue"><code>IOPort</code> and <code>IOValue</code></a></h3>
<p>Two public classes are added to the language:</p>
<ul>
<li><code>amaranth.hdl.IOValue</code>: represents a top-level port, or a slice or concatenation thereof. Analogous to <code>Value</code>. No public constructor.
<ul>
<li><code>__len__(self)</code>: returns the width of this value in bits. I/O values have no shape or signedness, only width.</li>
<li><code>__getitem__(self, index: int | slice)</code>: like slicing on values, returns an <code>IOValue</code> subclass.</li>
<li><code>metadata</code>: a read-only attribute returning a tuple of platform-specific objects; the tuple has one element per bit.</li>
<li><code>cast(obj)</code> (class method): converts the given object to <code>IOValue</code>, or raises an exception; the only non-<code>IOValue</code> object that can be passed is a 0-length <code>Value</code>, as per below.</li>
</ul>
</li>
<li><code>amaranth.hdl.IOPort(width, *, name, attrs={}, metadata=None)</code>: represents a top-level port. A subclass of <code>IOValue</code>. Analogous to <code>Signal</code>.
<ul>
<li><code>metadata</code> is an opaque field on the port that is not used in any way by the HDL core, and can be used by the platform to hold arbitrary data. It is normally used to store associated constraints to be emitted to the constraint file. The value can be either a tuple of arbitrary Python objects with length equal to <code>width</code>, or <code>None</code>, in which case an all-<code>None</code> tuple of the right width will be filled in.</li>
</ul>
</li>
</ul>
<p>The <code>Cat</code> function is changed to work on <code>IOValue</code>s in addition to plain <code>Value</code>s:</p>
<ul>
<li>all arguments to <code>Cat</code> must be of the same kind (either all <code>Value</code>s or all <code>IOValue</code>s)</li>
<li>the result is the same kind as the arguments</li>
<li>if no arguments at all are passed, the result is a <code>Value</code></li>
</ul>
<p>When <code>IOValue</code>s are sliced, the <code>metadata</code> attribute of the slicing result is likewise sliced in the same way from the source value. The same applies for concatenations.</p>
<p>As a special allowance to avoid problems in generated code, <code>Cat()</code> (empty concatenation, which is defined to be a <code>Value</code>) is also allowed wherever an <code>IOValue</code> is allowed.</p>
<h3 id="iobufferinstance"><a class="header" href="#iobufferinstance"><code>IOBufferInstance</code></a></h3>
<p>A new public class is added to the language:</p>
<ul>
<li><code>amaranth.hdl.IOBufferInstance(port, *, i=None, o=None, oe=None)</code></li>
</ul>
<p>The <code>port</code> argument must be an <code>IOValue</code>.</p>
<p>The <code>i</code> argument is used for the input half of the buffer. If <code>None</code>, the buffer is output-only. Otherwise, it must be an assignable <code>Value</code> of the same width as the <code>port</code>. Like for <code>Instance</code> outputs, the allowed kinds of <code>Value</code>s are <code>*Signal</code>s and slices or concatenations thereof.</p>
<p>The <code>o</code> argument is used for the output half of the buffer. If <code>None</code>, the buffer is input-only. Otherwise, it must be a <code>Value</code> of the same width as the <code>port</code>.</p>
<p>The <code>oe</code> argument is the output enable. If <code>o</code> is <code>None</code>, <code>oe</code> must also be <code>None</code>. Otherwise, it must be either a 1-bit <code>Value</code> or <code>None</code> (which is equivalent to <code>Const(1)</code>).</p>
<p>At least one of <code>i</code> or <code>o</code> must be specified.</p>
<p>The <code>IOBufferInstance</code>s are included in the hierarchy as submodules in the same way as <code>Instance</code> and <code>MemoryInstance</code>.</p>
<h3 id="instance"><a class="header" href="#instance"><code>Instance</code></a></h3>
<p>The rules for instance ports are changed as follows:</p>
<ol>
<li><code>io</code> ports can only be connected to <code>IOValue</code>s.</li>
<li><code>o</code> ports can be connected to either <code>IOValue</code>s or assignable <code>Value</code>s. Like now, acceptable <code>Value</code>s are limitted to <code>*Signal</code>s and their slices and concatenations.</li>
<li><code>i</code> ports can be connected to either <code>IOValue</code>s or <code>Value</code>s.</li>
</ol>
<p>A zero-width <code>IOValue</code> or <code>Value</code> can be connected to any port regardless of direction, and such connection is ignored.</p>
<h3 id="elaboration-notes"><a class="header" href="#elaboration-notes">Elaboration notes</a></h3>
<p>Every <code>IOPort</code> used in the design will become a top-level port in the output, with the given name (subject to the usual name deduplication).</p>
<p>If the <code>IOPort</code> is used only as an input (connected to an <code>Instance</code> port with <code>i</code> directionality, or to <code>IOBufferInstance</code> without <code>o=</code> argument), it becomes a top-level <code>input</code> port.</p>
<p>If the <code>IOPort</code> is used only as an output (connected to an <code>Instance</code> port with <code>o</code> directionality, or to <code>IOBufferInstance</code> without <code>i=</code> argument), it becomes a top-level <code>output</code> port.</p>
<p>Otherwise, it becomes an <code>inout</code> port.</p>
<p>Every bit of an <code>IOPort</code> can be used (ie. connected to <code>IOBufferInstance</code> or <code>Instance</code>) at most once.</p>
<p>After a design is elaborated, the list of all <code>IOPort</code>s used can be obtained by some mechanism out of scope of this RFC.</p>
<p>Calling <code>verilog.convert</code> or <code>rtlil.convert</code> without <code>ports</code> becomes legal. The full logic of determining top-level ports in <code>convert</code> is as follows:</p>
<ul>
<li><code>ports is not None</code>: the ports include the specified signals, all <code>IOPort</code>s in the design, and clock/reset signals of all autocreated domains</li>
<li><code>ports is None</code> and top-level is <code>Component</code>: the ports include the signature members, all <code>IOPort</code>s in the design, and clock/reset signals of all autocreated domains</li>
<li><code>ports is None</code>, top-level is not <code>Component</code>: the ports include all <code>IOPort</code>s in the design and clock/reset signals of all autocreated domains</li>
</ul>
<p>Using <code>IOPort</code>s together with other ways of creating top-level ports is not recommended.</p>
<p><code>IOPort</code>s are not supported in any way in simulation.</p>
<h3 id="platform-interfaces"><a class="header" href="#platform-interfaces">Platform interfaces</a></h3>
<p>The interface objects currently returned by <code>platform.request(dir=&quot;-&quot;)</code> are changed to have an empty signature, with the <code>io</code>, <code>p</code>, <code>n</code> attributes becoming <code>IOPort</code>s.</p>
<h2 id="drawbacks-35"><a class="header" href="#drawbacks-35">Drawbacks</a></h2>
<p>Arguably we have too many ways of creating top-level ports. However, it's not clear if we can remove any of them.</p>
<p>The empty <code>Cat()</code> hack is a minor type system wart.</p>
<h2 id="rationale-and-alternatives-34"><a class="header" href="#rationale-and-alternatives-34">Rationale and alternatives</a></h2>
<p>The change is necessary, as the I/O and platform code is a pile of hacks that needs cleanup.</p>
<p>The core <code>IOPort</code> + <code>IOValue</code> design codifies existing validity rules for <code>Instance</code> <code>io</code> ports. The <code>IOBufferInstance</code> already exists in current Amaranth as a private API used by the platforms.</p>
<p>The change of allowed arguments for <code>Instance</code> <code>io</code> ports is done without a deprecation period. It is felt that this will have a minimal impact, as the proposed change to <code>platform.request</code> with <code>dir=&quot;-&quot;</code> in RFC 55 will effectively fix the breakage for most well-formed instances of <code>io</code> port usage, and such usage is not common in the first place.</p>
<h2 id="prior-art-31"><a class="header" href="#prior-art-31">Prior art</a></h2>
<p><code>IOValue</code> system is patterned after the current <code>Value</code> system.</p>
<p>The port auto-creation essentially offloads parts of the current platform functionality into Amaranth core.</p>
<h2 id="unresolved-questions-33"><a class="header" href="#unresolved-questions-33">Unresolved questions</a></h2>
<p>Should we forbid mixing various ways of port creation?</p>
<p>Traditional name bikeshedding.</p>
<h2 id="future-possibilities-34"><a class="header" href="#future-possibilities-34">Future possibilities</a></h2>
<p>Another RFC is planned that will overhaul <code>lib.io</code>, adding generic I/O buffer components.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2024-03-18</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/54">amaranth-lang/rfcs#54</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth/issues/1212">amaranth-lang/amaranth#1212</a></li>
</ul>
<h1 id="initial-and-reset-values-on-memory-read-ports"><a class="header" href="#initial-and-reset-values-on-memory-read-ports">Initial and reset values on memory read ports</a></h1>
<h2 id="summary-37"><a class="header" href="#summary-37">Summary</a></h2>
<p>Synchronous memory read ports get initial values, just like <code>Signal</code>s.</p>
<h2 id="motivation-37"><a class="header" href="#motivation-37">Motivation</a></h2>
<p>Currently, the initial state of synchronous memory read port's data output is undefined in synthesis, making it one of the very few places in Amaranth where an undefined value can be obtained, and an unexpected one at that. This also cannot be caught with pysim, as it initializes all read ports to 0. This is easily fixable on almost all FPGA targets, as almost all FPGAs have well-defined initial values.</p>
<p>Further, the read ports on almost all FPGA targets also support a reset signal, which is currently not exposed in any way in Amaranth.</p>
<p>The hardware capabilities for yosys-supported targets are as follows:</p>
<ul>
<li>Xilinx BRAM: arbitrary initial and reset values, reset can be sync or async (except for very old FPGAs that have sync reset only)</li>
<li>Lattice, Anlogic, Gowin BRAM; Xilinx URAM, Nexus LRAM: always-zero initial and reset value, reset can be sync or async</li>
<li>Efinix, iCE40, Gatemate BRAM; iCE40 SPRAM: undefined initial value, no reset</li>
<li>LUT RAM on any target: full support (uses a normal FF to create a sync read port)</li>
</ul>
<p>Additionally, on any platform where requested initial value or reset is not natively supported by hardware, yosys will insert a FF and a mux to make it work regardless.</p>
<p>This RFC thus proposes to:</p>
<ul>
<li>close the expressiveness hole, making use of the hardware features where supported, using emulation otherwise</li>
<li>get rid of the undefined behavior</li>
</ul>
<h2 id="guide-level-explanation-29"><a class="header" href="#guide-level-explanation-29">Guide-level explanation</a></h2>
<p>Synchronous memory read ports behave in most respects like <code>Signal</code>s driven from a synchronous clock domain. As such, they have an initial value that can be set via <code>init=</code> on the constructor:</p>
<pre><code class="language-py">mem = Memory(shape=unsigned(8), depth=8, init=[])
rp = mem.read_port(domain=&quot;sync&quot;, init=13)
</code></pre>
<p>The read port's <code>data</code> signal will hold the initial value at startup and whenever a domain reset occurs. Additionally, as for <code>Signal</code>, <code>reset_less=True</code> can be specified to make the port not react to the domain reset.</p>
<h2 id="reference-level-explanation-29"><a class="header" href="#reference-level-explanation-29">Reference-level explanation</a></h2>
<p><code>lib.memory.Memory.read_port</code> and <code>lib.memory.ReadPort</code> get two new keyword-only arguments: <code>init=None</code> and <code>reset_less=False</code>. For synchronous read ports, they effectively have the same behavior as they have on <code>Signal</code> when applied to <code>port.data</code>. They become introspectable attributes on the port. If the port has <code>comb</code> domain, they cannot be changed from their default values and are meaningless.</p>
<p><code>hdl.MemoryInstance.read_port</code> likewise gets two new keyword-only arguments: <code>init=0</code> and <code>reset_less=False</code>. <code>init</code> must be an integer.</p>
<h2 id="drawbacks-36"><a class="header" href="#drawbacks-36">Drawbacks</a></h2>
<p>This is not natively supported by <em>all</em> FPGAs. While it can be reasonably cheaply emulated, in the author's experience, any amount of emulation circuitry inserted automatically by the toolchain to ensure well-defined behavior results solely in complaints.</p>
<h2 id="rationale-and-alternatives-35"><a class="header" href="#rationale-and-alternatives-35">Rationale and alternatives</a></h2>
<p>An alternative is to put <code>init</code> and <code>reset_less</code> on the signature and on the <code>port.data</code> signal instead of on the read port. However, <code>reset_less</code> is currently not supported by <code>lib.wiring</code>, and <code>is_compliant</code> will reject any signal with <code>reset_less=True</code>. This could be changed by a simple amendment to RFC 2.</p>
<h2 id="prior-art-32"><a class="header" href="#prior-art-32">Prior art</a></h2>
<p>None, or rather obvious enough.</p>
<h2 id="unresolved-questions-34"><a class="header" href="#unresolved-questions-34">Unresolved questions</a></h2>
<p>None.</p>
<h2 id="future-possibilities-35"><a class="header" href="#future-possibilities-35">Future possibilities</a></h2>
<p>A way to explicitly request undefined initial value could be added in the future, once undefined values are a well-defined concept in Amaranth.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2024-03-18</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/55">amaranth-lang/rfcs#55</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth/issues/1210">amaranth-lang/amaranth#1210</a></li>
</ul>
<h1 id="new-libio-components"><a class="header" href="#new-libio-components">New <code>lib.io</code> components</a></h1>
<h2 id="summary-38"><a class="header" href="#summary-38">Summary</a></h2>
<p>Building on RFC 2 and RFC 53, a new set of components is added to <code>lib.io</code>. The current contents of <code>lib.io</code> (<code>Pin</code> and its signature) become deprecated.</p>
<h2 id="motivation-38"><a class="header" href="#motivation-38">Motivation</a></h2>
<p>Currently, all IO buffer and register logic is instantiated in one place by <code>platform.request</code>. Per <a href="https://github.com/amaranth-lang/amaranth/issues/458">amaranth-lang/amaranth#458</a>, this has caused problems. Ideally, the act of requesting a specific I/O (user's responsibility) would be decoupled from instantiating the I/O buffer (peripherial library's responsibility).</p>
<p>Further, we currently have no standard I/O buffer components, other than the low-level <code>IOBufferInstance</code>.</p>
<h2 id="guide-level-explanation-30"><a class="header" href="#guide-level-explanation-30">Guide-level explanation</a></h2>
<p><code>IOPort</code>, introduced in RFC 53, is Amaranth's low-level IO port primitive. In <code>lib.io</code>, <code>IOPort</code>s
are wrapped in two higher-level objects: <code>SingleEndedPort</code> and <code>DifferentialPort</code>. These objects contain the raw <code>IOValue</code>s together with per-bit inversion flags. They are obtained from <code>platform.request</code>. If no platform is used, they can be constructed by the user directly, like this:</p>
<pre><code class="language-py">a = SingleEndedPort(IOPort(8, name=&quot;a&quot;)) # simple 8-bit IO port
b = SingleEndedPort(IOPort(8, name=&quot;b&quot;), invert=True) # 8-bit IO port, all bits inverted
c = SingleEndedPort(IOPort(4, name=&quot;c&quot;), invert=[False, True, False, True]) # 4-bit IO port, varying per-bit inversions
d = DifferentialPort(p=IOPort(4, name=&quot;dp&quot;), n=IOPort(4, name=&quot;dn&quot;)) # differential 4-bit IO port
</code></pre>
<p>Once a <code>*Port</code> object is obtained, whether from <code>platform.request</code> or by direct creation, it most likely needs to be passed to an I/O buffer. Amaranth provides a set of cross-platform I/O buffer components in <code>lib.io</code>.</p>
<p>For a non-registered port, the <code>lib.io.Buffer</code> can be used:</p>
<pre><code class="language-py">port = platform.request(...) # or = SingleEndedPort(,,,)
m.submodules.iob = iob = lib.io.Buffer(lib.io.Direction.Bidir, port)
m.d.comb += [
    iob.o.eq(...),
    iob.oe.eq(...),
    (...).eq(iob.i),
]
</code></pre>
<p>For an SDR registered port, the <code>lib.io.FFBuffer</code> can be used:</p>
<pre><code class="language-py">m.submodules.iob = iob = lib.io.FFBuffer(lib.io.Direction.Bidir, port, i_domain=&quot;sync&quot;, o_domain=&quot;sync&quot;)
m.d.comb += [
    iob.o.eq(...),
    iob.oe.eq(...),
    (...).eq(iob.i),
]
</code></pre>
<p>For a DDR registered port (given a supported platform), the <code>lib.io.DDRBuffer</code> can be used:</p>
<pre><code class="language-py">m.submodules.iob = iob = lib.io.DDRBuffer(lib.io.Direction.Bidir, port, i_domain=&quot;sync&quot;, o_domain=&quot;sync&quot;)
m.d.comb += [
    iob.o[0].eq(...),
    iob.o[1].eq(...),
    iob.oe.eq(...),
    (...).eq(iob.i[0]),
    (...).eq(iob.i[1]),
]
</code></pre>
<p>All of the above primitives are components with corresponding signature types. When elaborated, the primitives call a platform hook, allowing it to provide a custom implementation using vendor-specific cells. If no special support is provided by the platform, <code>Buffer</code> and <code>FFBuffer</code> provide a simple vendor-agnostic default implementation, while <code>DDRBuffer</code> raises an error when elaborated.</p>
<h2 id="reference-level-explanation-30"><a class="header" href="#reference-level-explanation-30">Reference-level explanation</a></h2>
<p>The following classes are added to <code>lib.io</code>:</p>
<ul>
<li>
<pre><code class="language-py">class Direction(enum.Enum):
    Input  = &quot;i&quot;
    Output = &quot;o&quot;
    Bidir  = &quot;io&quot;
</code></pre>
<p>Represents a port or buffer direction.</p>
</li>
<li>
<p><code>SingleEndedPort(io: IOValue, *, invert: bool | Iterable[bool]=False, direction: Direction=Direction.Bidir)</code>: represents a single ended port; the <code>invert</code> parameter is normalized to a tuple of <code>bool</code> before being stored as an attribute</p>
<ul>
<li><code>__len__(self)</code>: returns <code>len(io)</code></li>
<li><code>__getitem__(self, index: slice | int)</code>: allows slicing the object, returning another <code>SingleEndedPort</code>; requesting a single index is equivalent to requesting a one-element slice</li>
<li><code>__add__(self, other: SingleEndedPort)</code>: concatenates two ports together into a bigger <code>SingleEndedPort</code></li>
<li><code>__invert__(self)</code>: returns a new <code>SingleEndedPort</code> derived from this one by having the opposite (every element of) <code>invert</code></li>
</ul>
</li>
<li>
<p><code>DifferentialPort(p: IOValue, n: IOValue, *, invert: bool | Iterable[bool]=False, direction: Direction=Direction.Bidir)</code>: represents a differential pair; both <code>IOValue</code>s given as arguments must have equal width</p>
<ul>
<li><code>__len__(self)</code>: returns <code>len(p)</code> (which is equal to <code>len(n)</code>)</li>
<li><code>__getitem__(self, index: slice | int)</code>: allows slicing the object, returning another <code>DifferentialPort</code></li>
<li><code>__add__(self, other: DifferentialPort)</code>: concatenates two ports together into a bigger <code>DifferentialPort</code></li>
<li><code>__invert__(self)</code>: returns a new <code>DifferentialPort</code> derived from this one by having the opposite (every element of) <code>invert</code></li>
</ul>
</li>
<li>
<p><code>Buffer.Signature(direction: Direction | str, width: int)</code>: a signature for the <code>Buffer</code>; if <code>direction</code> is a string, it is converted to <code>Direction</code></p>
<ul>
<li><code>i: Out(width)</code> if <code>direction in (Direction.Input, Direction.Bidir)</code></li>
<li><code>o: In(width)</code> if <code>direction in (Direction.Output, Direction.Bidir)</code></li>
<li><code>oe: In(1, init=1)</code> if <code>direction is Direction.Output</code></li>
<li><code>oe: In(1, init=0)</code> if <code>direction is Direction.Bidir</code></li>
</ul>
</li>
<li>
<p><code>Buffer(direction: Direction | str, port: SingleEndedPort | DifferentialPort | ...)</code>: non-registered buffer, derives from <code>Component</code></p>
<ul>
<li>when elaborated, tries to return <code>platform.get_io_buffer(self)</code>; if such a function doesn't exist, lowers to <code>IOBufferInstance</code> plus optional inverters</li>
</ul>
</li>
<li>
<p><code>FFBuffer.Signature(direction: Direction | str, width: int)</code>: a signature for the <code>FFBuffer</code></p>
<ul>
<li><code>i: Out(width)</code> if <code>direction in (Direction.Input, Direction.Bidir)</code></li>
<li><code>o: In(width)</code> if <code>direction in (Direction.Output, Direction.Bidir)</code></li>
<li><code>oe: In(1, init=1)</code> if <code>direction is Direction.Output</code></li>
<li><code>oe: In(1, init=0)</code> if <code>direction is Direction.Bidir</code></li>
</ul>
</li>
<li>
<p><code>FFBuffer(direction: Direction | str, port: SingleEndedPort | DifferentialPort | ..., *, i_domain=&quot;sync&quot;, o_domain=&quot;sync&quot;)</code>: SDR registered buffer, derives from <code>Component</code></p>
<ul>
<li>when elaborated, tries to return <code>platform.get_io_buffer(self)</code>; if such a function doesn't exist, lowers to <code>IOBufferInstance</code>, plus reset-less FFs realized by <code>m.d[*_domain]</code> assignment, plus optional inverters</li>
</ul>
</li>
<li>
<p><code>DDRBuffer.Signature(direction: Direction | str, width: int)</code>: a signature for the <code>DDRBuffer</code></p>
<ul>
<li><code>i: Out(ArrayLayout(width, 2))</code> if <code>direction in (Direction.Input, Direction.Bidir)</code></li>
<li><code>o: In(ArrayLayout(width, 2))</code> if <code>direction in (Direction.Output, Direction.Bidir)</code></li>
<li><code>oe: In(1, init=1)</code> if <code>direction is Direction.Output</code></li>
<li><code>oe: In(1, init=0)</code> if <code>direction is Direction.Bidir</code></li>
</ul>
</li>
<li>
<p><code>DDRBuffer(direction: Direction | str, port: SingleEndedPort | DifferentialPort | ..., *, i_domain=&quot;sync&quot;, o_domain=&quot;sync&quot;)</code>: DDR registered buffer, derives from <code>Component</code></p>
<ul>
<li>when elaborated, tries to return <code>platform.get_io_buffer(self)</code>; if such a function doesn't exist, raises an error</li>
</ul>
</li>
</ul>
<p>All of the above classes are fully introspectable, and the constructor arguments are accessible as read-only attributes.</p>
<p>If a platform is not used, the <code>port</code> argument must be a <code>SingleEndedPort</code> or <code>DifferentialPort</code>. If a platform is used, the platform may define support for additional types. Such types must implement the same interface as <code>*Port</code> objects, that is:</p>
<ul>
<li><code>__len__</code> must provide length in bits (so that <code>*Buffer</code> can know the proper signature)</li>
<li><code>__getitem__</code> which supports slices, and where plain indices return single-bit slices</li>
<li><code>__invert__</code> that returns another port-like</li>
<li><code>direction</code> attribute that must be a <code>Direction</code></li>
</ul>
<p>If a platform is not used, and a <code>DifferentialPort</code> is used, a pseudo-differential port is effectively created.</p>
<p>The <code>direction</code> argument on <code>*Port</code> can be used to restrict valid allowed buffer directions as follows:</p>
<ul>
<li>an <code>Input</code> buffer will not accept an <code>Output</code> port</li>
<li>an <code>Output</code> buffer will not accept an <code>Input</code> port</li>
<li>a <code>Bidir</code> buffer will only accept a <code>Bidir</code> port</li>
</ul>
<p>This is validated by the <code>*Buffer</code> constructors. Custom buffer-like elaboratables that take <code>*Port</code> are likewise encouraged to perform similar checking.</p>
<p>The <code>platform.request</code> function with <code>dir=&quot;-&quot;</code> returns <code>SingleEndedPort</code> when called on single-ended ports, <code>DifferentialPort</code> when called on differential pairs. Using <code>platform.request</code> with any other <code>dir</code> becomes deprecated, in favor of having the user (or peripherial library) code explicitly instantiate <code>*Buffer</code>s. The <code>lib.io.Pin</code> interface and its signature likewise become deprecated.</p>
<h2 id="drawbacks-37"><a class="header" href="#drawbacks-37">Drawbacks</a></h2>
<p>The proposed <code>FFBuffer</code> and <code>DDRBuffer</code> interfaces have a minor problem of not actually being currently implementable in many cases, as there is no way to obtain clock signal polarity at that stage of elaboration. A solution for that needs to be proposed, whether as a private hack for the current platforms, or as an RFC.</p>
<p>Using plain domains for <code>DDRBuffer</code> has the unprecedented property of triggering logic on the opposite of active edge of the domain.</p>
<h2 id="rationale-and-alternatives-36"><a class="header" href="#rationale-and-alternatives-36">Rationale and alternatives</a></h2>
<p>The buffers have minimal functionality on purpose, to allow them to be widely supported. In particular:</p>
<ul>
<li>clock enables are not supported</li>
<li>reset is not supported</li>
<li>initial values are not supported</li>
<li><code>xdr &gt; 2</code> is not supported</li>
</ul>
<p>Such functionality can be provided by vendor-specific primitives.</p>
<h2 id="prior-art-33"><a class="header" href="#prior-art-33">Prior art</a></h2>
<p>None.</p>
<h2 id="unresolved-questions-35"><a class="header" href="#unresolved-questions-35">Unresolved questions</a></h2>
<p>None.</p>
<h2 id="future-possibilities-36"><a class="header" href="#future-possibilities-36">Future possibilities</a></h2>
<p>Vendor-specific versions of the proposed buffers can be added to the <code>vendor</code> module, allowing access to the full range of hardware functionality.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2024-03-18</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/56">amaranth-lang/rfcs#56</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth/issues/1211">amaranth-lang/amaranth#1211</a></li>
</ul>
<h1 id="asymmetric-memory-port-width"><a class="header" href="#asymmetric-memory-port-width">Asymmetric memory port width</a></h1>
<h2 id="summary-39"><a class="header" href="#summary-39">Summary</a></h2>
<p>Memory read and write ports can have varying width, allowing eg. for memories with 8-bit read path and 32-bit write path.</p>
<h2 id="motivation-39"><a class="header" href="#motivation-39">Motivation</a></h2>
<p>This is a common hardware feature. It allows for eg. having a slow but wide port in one domain, and fast but narrow port in another domain. On platforms lacking dedicated hardware support, it can often be emulated almost for free.</p>
<h2 id="guide-level-explanation-31"><a class="header" href="#guide-level-explanation-31">Guide-level explanation</a></h2>
<p>Memories can have asymmetric port width. To use that feature, instantiate the memory with the shape of the narrowest desired port, then pass the <code>aggregate</code> argument on ports that should be wider than that:</p>
<pre><code class="language-py">m.submodules.mem = mem = Memory(shape=unsigned(8), depth=4096, init=[])
# 8-bit write port
wp = mem.write_port()
# 32-bit read port
rp = mem.read_port(aggregate=4)
# Address 0x123 on rp is equivalent to addresses (0x123 * 4, 0x123 * 4 + 1, 0x123 * 4 + 2, 0x123 + 3) on wp.
# Shape of rp.data is ArrayLayout(unsigned(8), 4)
</code></pre>
<h2 id="reference-level-explanation-31"><a class="header" href="#reference-level-explanation-31">Reference-level explanation</a></h2>
<p>Both <code>lib.memory.Memory.read_port</code> and <code>lib.memory.Memory.write_port</code> have a new <code>aggregate=None</code> keyword-only argument. If <code>aggregate</code> is not <code>None</code>, the behavior is as follows:</p>
<ul>
<li><code>aggregate</code> has to be a power of two</li>
<li><code>mem.depth</code> must be divisible by <code>aggregate</code></li>
<li>the <code>shape</code> passed to the <code>*Port.Signature</code> constructor becomes <code>ArrayLayout(memory.shape, aggregate)</code></li>
<li>implied by the previous point, <code>granularity</code> on wide write ports is counted in terms of single memory row</li>
<li>the <code>addr_width</code> passed to <code>*Port.Signature</code> constructor becomes <code>ceil_log2(memory.depth // aggregate)</code></li>
</ul>
<p>The behavior of wide ports is defined by expanding them to <code>aggregate</code> narrow ports:</p>
<ul>
<li>the <code>data</code> of subport <code>i</code> is connected to <code>data[i]</code> of wide port</li>
<li>the <code>addr</code> of subport <code>i</code> is connected to <code>addr * aggregate + i</code> of wide port</li>
<li>for read ports and write ports without granularity, <code>en</code> is broadcast</li>
<li>for write ports with granularity, <code>en</code> of subport <code>i</code> is connected to <code>en[i // granularity]</code> of wide port</li>
</ul>
<p>No change is made to signature types or port types. Wide ports are recognized solely by their relation to <code>memory.shape</code>.</p>
<p>The rules for <code>MemoryInstance.read_port</code> and <code>MemoryInstance.write_port</code> change as follows:</p>
<ul>
<li>define <code>aggregate_log2 = ceil_log2(depth) - len(addr)</code>, <code>aggregate = 1 &lt;&lt; aggregate_log2</code></li>
<li><code>aggregate_log2</code> must be non-negative</li>
<li><code>depth</code> must be divisible by <code>aggregate</code></li>
<li><code>len(data)</code> must be equal to <code>width * aggregate</code></li>
<li>for write ports, one of the following must hold:
<ul>
<li><code>aggregate</code> is divisible by <code>len(en)</code></li>
<li><code>len(en)</code> is divisible by <code>aggregate</code> and <code>len(data)</code> is divisible by <code>len(en)</code></li>
</ul>
</li>
</ul>
<h2 id="drawbacks-38"><a class="header" href="#drawbacks-38">Drawbacks</a></h2>
<p>More complexity.</p>
<p>Wide write ports with sub-row write granularity cannot be expressed. However, there is no hardware that would actually natively support such a combination.</p>
<h2 id="rationale-and-alternatives-37"><a class="header" href="#rationale-and-alternatives-37">Rationale and alternatives</a></h2>
<p>The design is straightforward enough.</p>
<p>An alternative is not doing this. Yosys already has an optimization pass that recognizes wide ports from a collection of narrow ports, so this is not necessarily an expressiveness hole. However, platforms with non-yosys toolchain could still benefit from custom lowering for this case.</p>
<h2 id="prior-art-34"><a class="header" href="#prior-art-34">Prior art</a></h2>
<p>This proposal is directly based on yosys memory model.</p>
<h2 id="unresolved-questions-36"><a class="header" href="#unresolved-questions-36">Unresolved questions</a></h2>
<p>None.</p>
<h2 id="future-possibilities-37"><a class="header" href="#future-possibilities-37">Future possibilities</a></h2>
<p>Similar functionality could potentially be added to <code>lib.fifo</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2024-03-15</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/57">amaranth-lang/rfcs#57</a></li>
<li>Amaranth SoC Issue: <a href="https://github.com/amaranth-lang/amaranth-soc/issues/78">amaranth-lang/amaranth-soc#78</a></li>
</ul>
<h1 id="single-field-register-definition-and-usage-shortcut"><a class="header" href="#single-field-register-definition-and-usage-shortcut">Single-Field Register Definition and Usage Shortcut</a></h1>
<h2 id="summary-40"><a class="header" href="#summary-40">Summary</a></h2>
<p>Add a shortcut to <code>csr.Register</code> to enable easier and cleaner definition and use
of registers which contain exactly one <code>csr.Field</code>.</p>
<h2 id="motivation-40"><a class="header" href="#motivation-40">Motivation</a></h2>
<p>Currently, use of a <code>csr.Register</code> in an amaranth-soc peripheral requires creation of a map (or list) of <code>csr.Field</code>s, which actually represent the register data and control access to each part. This is commonly done by creating a <code>Register</code> subclass. Each <code>Field</code> also needs a name (or index) in the <code>Register</code>. However, many registers in peripherals only contain one field, so the extra name and subclass are unnecessary and redundant. This RFC introduces a shortcut for constructing and using a <code>Register</code> containing exactly one un-named <code>Field</code>.</p>
<h2 id="guide-level-explanation-32"><a class="header" href="#guide-level-explanation-32">Guide-level explanation</a></h2>
<p>Consider the following simple peripheral which generates a toggling signal on bits of an output corresponding to bits set in a register:</p>
<pre><code class="language-python">from amaranth import *
from amaranth.lib import wiring
from amaranth.lib.wiring import In, Out
from amaranth_soc import csr

class Toggle(wiring.Component):
    bus: In(csr.Signature(addr_width=1, data_width=32))
    toggle: Out(32)

    class Toggle(csr.Register, access=&quot;rw&quot;):
        toggle: csr.Field(csr.action.RW, 32)

    def __init__(self):
        self._toggle = Toggle()

        # ... bridge setup ...

    def elaborate(self, platform):
        m = Module()

        # ... bridge setup ...

        for i in range(32):
            with m.If(self._toggle.f.toggle.data[i]):
                m.d.sync += self.toggle[i].eq(~self.toggle[i])
            with m.Else():
                m.d.sync += self.toggle[i].eq(0)

        return m
</code></pre>
<p>The <code>toggle</code> name is used, among other ways, to name the register class, to name
the field within, and to access that field on the register instance during
elaboration.</p>
<p>This can be simplified by passing the <code>csr.Field</code> directly to the <code>csr.Register</code>
without enclosing it in a dict/list and naming/indexing it, or subclassing
<code>csr.Register</code>. This also causes the <code>.f</code> member to access that Field directly
instead of needing to provide a name/index.</p>
<p>This simplifies the design as follows, reducing clutter and redundancy:</p>
<pre><code class="language-python">from amaranth import *
from amaranth.lib import wiring
from amaranth.lib.wiring import In, Out
from amaranth_soc import csr

class Toggle(wiring.Component):
    bus: In(csr.Signature(addr_width=1, data_width=32))
    toggle: Out(32)

    def __init__(self):
        # Register can take the Field directly, eliminating the subclass
        self._toggle = csr.Register(csr.Field(csr.action.RW, 32), access=&quot;rw&quot;)

        # ... bridge setup ...

    def elaborate(self, platform):
        m = Module()

        # ... bridge setup ...

        for i in range(32):
            # FieldAction accessed directly, no need to specify `toggle` again
            with m.If(self._toggle.f.data[i]):
                m.d.sync += self.toggle[i].eq(~self.toggle[i])
            with m.Else():
                m.d.sync += self.toggle[i].eq(0)

        return m
</code></pre>
<h2 id="reference-level-explanation-32"><a class="header" href="#reference-level-explanation-32">Reference-level explanation</a></h2>
<p>(with reference to <a href="https://github.com/amaranth-lang/rfcs/blob/main/text/0016-soc-csr-regs.md">RFC #16</a>)</p>
<h4 id="csrregregister-1"><a class="header" href="#csrregregister-1"><code>csr.reg.Register</code></a></h4>
<p>The <code>csr.reg.Register</code> class describes a CSR register <code>Component</code>, with:</p>
<ul>
<li>a <code>.__init__(self, fields=None, access=None)</code> constructor, where:
<ul>
<li><code>fields</code> is either:
<ul>
<li>a <code>dict</code> that will be instantiated as a <code>FieldActionMap</code>;</li>
<li>a <code>list</code> that will be instantiated as a <code>FieldActionArray</code>;</li>
<li>a <code>Field</code> that will be instantiated as a <code>FieldAction</code>;</li>
<li><code>None</code>; in this case a <code>FieldActionMap</code> is instantiated from <code>Field</code> objects in variable annotations.</li>
</ul>
</li>
<li><code>access</code> is either a <code>csr.Element.Access</code> value, or <code>None</code>.</li>
</ul>
</li>
<li>a <code>.field</code> property, returning the instantiated <code>FieldActionMap</code>/<code>FieldActionArray</code>/<code>FieldAction</code>;</li>
<li>a <code>.f</code> property, as a shorthand to <code>self.field</code>;</li>
<li>a <code>.__iter__(self)</code> method that yields, for each contained field, a tuple containing its path (as a tuple of names or indices) and its instantiated <code>FieldAction</code>. If only a single <code>Field</code> was supplied, its path is always <code>tuple()</code>.</li>
</ul>
<h2 id="drawbacks-39"><a class="header" href="#drawbacks-39">Drawbacks</a></h2>
<ul>
<li>A novice might not understand that it's possible to create a <code>Register</code> with multiple <code>Fields</code> if exposed only to code which uses single-<code>Field</code> <code>Register</code>s.</li>
<li>There is a difference between a <code>Register</code> with one named/indexed <code>Field</code> and with one unnamed <code>Field</code>.</li>
<li>Library code will be made more confusing by having <code>fields</code> refer to possibly only one field.</li>
<li>Downstream code will have to deal with a third type of object returned by the
<code>.f</code> property which behaves unlike the current two.</li>
<li>BSP/doc generators will have to intelligently render a <code>Field</code> with an empty name and path (likely by omitting them, possibly by reusing the register's name).
<ul>
<li>An empty name is prohibited by <code>FieldActionMap</code>, so empty names are a novel
problem.</li>
<li>The register does not know its own name independently of its container, so this may be difficult in practice.</li>
</ul>
</li>
<li>Adding a second <code>Field</code> to a register created this way will break all accesses to the <code>.f</code> property and likely all BSP users (though the actual bus transactions to the first <code>Field</code> will not change).
<ul>
<li>This could be especially entertaining if the new <code>Field</code> names happen to
be the same as properties of the first <code>Field</code>'s <code>FieldAction</code>.</li>
<li>BSP users will have to change all constants/functions named after just the
register to instead use the register + the field name.</li>
</ul>
</li>
</ul>
<h2 id="rationale-and-alternatives-38"><a class="header" href="#rationale-and-alternatives-38">Rationale and alternatives</a></h2>
<ul>
<li>Simple and easily explainable change, easy to migrate code to, though no
migration is even necessary</li>
<li>Minimal change to the library's existing code</li>
<li>Nicely reduces redundant names, types, and properties</li>
<li>Not strictly necessary, not having it will just make peripheral code a little
more cluttered</li>
<li>Users could instead be taught to eliminate the subclass by passing a dict to
the <code>Register</code> constructor and assign the <code>.f</code> property of interest to a
local variable to de-clutter code</li>
</ul>
<h2 id="prior-art-35"><a class="header" href="#prior-art-35">Prior art</a></h2>
<p>AVR microcontrollers have many registers where the field name is the same as the register name, though this is not always the case for single-field registers. Application code usually uses the register name in this case and ignores the field name.</p>
<p>STM32 microcontrollers are similar, but the field name is usually a suffix of the register name, as the field name is not expected to be globally unique. However, the generated BSP files do appear to always contain the field name at least somewhere.</p>
<p>Field arrays are already in some sense anonymous, being named by an integer instead of a string.</p>
<p>More experienced input is welcomed here.</p>
<h2 id="unresolved-questions-37"><a class="header" href="#unresolved-questions-37">Unresolved questions</a></h2>
<ul>
<li><del>Should we change <code>fields</code> to <code>field</code> in the constructor and properties? This could break existing code.</del>
<ul>
<li>The property will be <code>.field</code> and the constructor will be <code>fields=</code>.</li>
</ul>
</li>
<li><del>Should we add <code>field</code> too? This would access the same object/s as <code>fields</code> and so would make available the option to use the right plurality, though it would be more code and wouldn't force it.</del>
<ul>
<li>The property will be <code>.field</code> and the constructor will be <code>fields=</code>.</li>
</ul>
</li>
<li><del>Should we force a <code>Register</code> with a single <code>Field</code> to always have that one be un-named? Would create backwards compatibility problems, but reduce ambiguity.</del>
<ul>
<li>No, would cause backwards compatibility problems, which we don't want.</li>
</ul>
</li>
<li><del>Should we go further? <code>Register</code> could take a single <code>FieldAction</code> and automatically wrap it in a <code>Field</code> (and inherit its access mode).</del>
<ul>
<li>No, unnecessarily convenient and not yet proved necessary by experience.</li>
</ul>
</li>
</ul>
<h2 id="future-possibilities-38"><a class="header" href="#future-possibilities-38">Future possibilities</a></h2>
<p>None obvious, this is a pretty small and self-contained idea.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2024-03-25</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/58">amaranth-lang/rfcs#58</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth/issues/1243">amaranth-lang/amaranth#1243</a></li>
</ul>
<h1 id="core-support-for-valuecastable-formatting"><a class="header" href="#core-support-for-valuecastable-formatting">Core support for <code>ValueCastable</code> formatting</a></h1>
<h2 id="summary-41"><a class="header" href="#summary-41">Summary</a></h2>
<p><code>Format</code> hooks are added, allowing custom formatting to be implemented for <code>ValueCastable</code>s.</p>
<p>This RFC is only about adding hook support for custom <code>ShapeCastable</code>s. Providing actual formatting implementation for <code>lib.data</code> and <code>lib.enum</code> is left for a future RFC.</p>
<h2 id="motivation-41"><a class="header" href="#motivation-41">Motivation</a></h2>
<p>Custom types, like enums and data structures, will not make immediate sense to the user when printed as raw bit patterns. However, it is often desirable to print them out with the <code>Print</code> statement. Thus, an extension point for custom formatting needs to be added to the <code>Format</code> machinery.</p>
<h2 id="guide-level-explanation-33"><a class="header" href="#guide-level-explanation-33">Guide-level explanation</a></h2>
<p><code>ShapeCastable</code> subtypes can define their own ways of formatting values by implementing the <code>format</code> hook:</p>
<pre><code class="language-py">class FixedPoint(ShapeCastable):
    ...

    def format(self, value, format_desc):
        if format_desc == &quot;b&quot;:
            # Format a fixed-point value as binary.
            return Format(&quot;{value.int:b}.{value.fract:0{fract_bits}b}}&quot;, value=value, fract_bits=len(value.fract))
        elif format_desc == &quot;x&quot;:
            # Format a fixed-point value as hexadecimal (very simplified implementation).
            assert len(value.fract) % 4 == 0
            return Format(&quot;{value.int:x}.{value.fract:0{fract_digits}x}}&quot;, value=value, fract_digits=len(value.fract) // 4)
        else:
            ...

# A fixed-point number with 8 integer and 8 fractional bits.
num = Signal(FixedPoint(8, 8))
m.d.comb += [
    num.eq(0x1234)
    Print(Format(&quot;Value in binary: {:b}&quot;, num)),
    Print(Format(&quot;Value in hexadecimal: {:x}&quot;, num)),
]
</code></pre>
<p>prints:</p>
<pre><code>Value in binary: 00010010.00110100
Value in hexadecimal: 12.34
</code></pre>
<p>However, sometimes it is also useful to print the raw value of such a signal. A shorthand is provided for that purpose:</p>
<pre><code class="language-py">m.d.comb += Print(Format(&quot;Value: {num:x} (raw: {num!v:x})&quot;, num=num))
</code></pre>
<pre><code>Value: 12.34 (raw: 1234)
</code></pre>
<h2 id="reference-level-explanation-33"><a class="header" href="#reference-level-explanation-33">Reference-level explanation</a></h2>
<p>A new overridable method is added to <code>ShapeCastable</code>:</p>
<ul>
<li><code>format(self, value: ValueCastable, format_desc: str) -&gt; Format</code></li>
</ul>
<p>When a <code>ValueCastable</code> is formatted without specifying a conversion (ie. <code>&quot;!r&quot;</code> or <code>&quot;!v&quot;</code>):</p>
<ul>
<li><code>shape()</code> is called</li>
<li>if the shape is a <code>ShapeCastable</code> and has a <code>format</code> method, the value-castable being formatted and the format descriptor (the part after <code>:</code> in <code>{}</code>, if any) are passed directly to <code>shape.format()</code>, and the result (which must be a <code>Format</code> object) is included directly in place of the format specifier</li>
<li>otherwise (the shape is a plain <code>Shape</code>, or doesn't have <code>format</code>), <code>Value.cast()</code> is called on the value-castable, and formatting proceeds as if it was a plain value</li>
</ul>
<p>A new conversion, <code>!v</code>, is added to <code>Format</code> (with syntax analogous to <code>!r</code>). When specified, the value being formatted is converted through <code>Value.cast</code> before proceeding with further formatting. It can be used to print the raw value of value-castables. It is a no-op when used with a plain <code>Value</code>.</p>
<p>An implementation of <code>__format__</code> is added to the <code>ValueCastable</code> base class that always raises a <code>TypeError</code>, directing the user to <code>Format</code> instead (like the one that already exists on plain <code>Value</code>).</p>
<h2 id="drawbacks-40"><a class="header" href="#drawbacks-40">Drawbacks</a></h2>
<p>A new reserved name, <code>format</code>, is added to <code>ShapeCastable</code>, which is intended to be a fairly slim interface.</p>
<p>The <code>__format__</code> on <code>ValueCastable</code> is the first time we have a method with an actual implementation.</p>
<h2 id="rationale-and-alternatives-39"><a class="header" href="#rationale-and-alternatives-39">Rationale and alternatives</a></h2>
<p>The <code>format</code> hook is added on <code>ShapeCastable</code> instead of <code>ValueCastable</code>. This ensures that <code>ValueCastable</code>s without a custom shape automatically get plain formatting.</p>
<p>The default behavior proposed in this RFC ensures that a formatting implementation is always available, allowing generic code to print arbitrary values without worrying about an exception. Eg. something like <code>lib.fifo</code> could use debug prints when an element is added, automatically using rich formatting for shapes with <code>format</code>, while falling back to plain integers when rich formatting is not available.</p>
<p>alternative default behaviors possible are:</p>
<ul>
<li>raise <code>TypeError</code> (disallow formatting value-castables without explicitly implemented formatting)</li>
<li>no default, require every <code>ShapeCastable</code> to implement <code>format</code> (compatibility breaking)</li>
</ul>
<p>To avoid reserving a name and interfering with user code, <code>format</code> could be renamed to <code>_amaranth_format</code>.</p>
<h2 id="prior-art-36"><a class="header" href="#prior-art-36">Prior art</a></h2>
<p>This RFC is modelled directly on the <code>__format__</code> extension point in Python.</p>
<h2 id="unresolved-questions-38"><a class="header" href="#unresolved-questions-38">Unresolved questions</a></h2>
<p>Bikeshed: what should <code>!v</code> be called? Alternatives proposed:</p>
<ul>
<li><code>!v</code> (cast to value)</li>
<li><code>!i</code> (print as integer)</li>
<li><code>!n</code> (print as number)</li>
<li><code>!R</code> (print raw)</li>
<li><code>!l</code> (lower to a value)</li>
<li><code>!av</code> (as value)</li>
</ul>
<h2 id="future-possibilities-39"><a class="header" href="#future-possibilities-39">Future possibilities</a></h2>
<p>Actual formatting will need to be implemented for <code>lib.data</code> and <code>lib.enum</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2024-03-25</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/59">amaranth-lang/rfcs#59</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth/issues/1242">amaranth-lang/amaranth#1242</a></li>
</ul>
<h1 id="get-rid-of-upwards-propagation-of-clock-domains"><a class="header" href="#get-rid-of-upwards-propagation-of-clock-domains">Get rid of upwards propagation of clock domains</a></h1>
<h2 id="summary-42"><a class="header" href="#summary-42">Summary</a></h2>
<p>Upwards propagation of clock domains is removed, <code>local=True</code> effectively becomes the default.</p>
<h2 id="motivation-42"><a class="header" href="#motivation-42">Motivation</a></h2>
<p>Currently, a clock domain created anywhere in the hierarchy is, by default, propagated everywhere within that hierarchy. The other option is marking a clock domain with <code>local=True</code>, which restricts propagation to only downwards from the point of definition.</p>
<p>The default behavior constitutes the ultimate implicit spooky action at a distance, making it hard to reason about clock domain origins in complex Amaranth design. It is also rarely used. This dangerous default should be changed to something more reasonable.</p>
<h2 id="guide-and-reference-level-explanation"><a class="header" href="#guide-and-reference-level-explanation">Guide and reference-level explanation</a></h2>
<p>In version 0.5, upwards domain propagation becomes deprecated. Any use of a domain that wouldn't be valid without upwards propagation (ie. wouldn't be valid if the domain were <code>local=True</code>) triggers a deprecation warning.</p>
<p>In version 0.6, upwards domain propagation is removed entirely. The <code>local</code> argument to <code>ClockDomain</code> constructor becomes redundant and is deprecated.</p>
<p>In version 0.7, the <code>local</code> argument is removed.</p>
<h2 id="drawbacks-41"><a class="header" href="#drawbacks-41">Drawbacks</a></h2>
<p>A little bit of churn for designs with clock generator modules.</p>
<p>When propagating a domain upwards is actually desired (eg. for clock generator modules), a workaround is now necessary to route the domain to the toplevel. The simplest way is to set an eg. <code>cd_sync</code> attribute on the module in the constructor, then do <code>m.domains.sync = clkgen.cd_sync</code> in the top-level. This has the slight disadvantage that the clock generator module cannot decide on the attributes of the clock domain (clock polarity, reset asyncness) based on the platform.</p>
<h2 id="rationale-and-alternatives-40"><a class="header" href="#rationale-and-alternatives-40">Rationale and alternatives</a></h2>
<p>The core proposal is straightforward. The main question is how to handle the usecases currently served by purposeful use of upwards domain propagation. There are three alternatives:</p>
<ol>
<li>
<p>None. Clock generator modules must export their domains through some other existing Amaranth functionality. This is the option proposed above.</p>
</li>
<li>
<p>Keep the current mechanism as-is, but make it opt-in, such by requiring <code>ClockDomain(global=True)</code>.</p>
</li>
<li>
<p>Add a mechanism to explicitly import a domain from a submodule. A draft is proposed here, for discussion purposes:</p>
<pre><code class="language-py">m.submodules.clkgen = ClockGenerator(...)
m.domains.sync = ImportedDomain(&quot;clkgen&quot;, &quot;sync&quot;) # Imports a domain defined in the submodule &quot;clkgen&quot; named &quot;sync&quot;.
</code></pre>
</li>
</ol>
<p>We feel that 1. is the best option to take, as introducing a new mechanism when a full redesign of the system is pending is likely to just result in another thing that will have to be deprecated later.</p>
<h2 id="prior-art-37"><a class="header" href="#prior-art-37">Prior art</a></h2>
<p>None.</p>
<h2 id="unresolved-questions-39"><a class="header" href="#unresolved-questions-39">Unresolved questions</a></h2>
<p>None.</p>
<h2 id="future-possibilities-40"><a class="header" href="#future-possibilities-40">Future possibilities</a></h2>
<p>The concept of &quot;private&quot; clock domains has been proposed: clock domains that don't propagate at all, including downwards.</p>
<p>It's clear that clock domain overhaul with a larger scope needs to be done. This RFC is (among other things) intended to enable such overhaul, by removing a feature likely to make it infeasible.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2024-03-25</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/61">amaranth-lang/rfcs#61</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth/issues/1244">amaranth-lang/amaranth#1244</a></li>
</ul>
<h1 id="minimal-streams"><a class="header" href="#minimal-streams">Minimal streams</a></h1>
<h2 id="summary-43"><a class="header" href="#summary-43">Summary</a></h2>
<p>Define a protocol for unidirectional communication (data streaming) with ready/valid handshaking.</p>
<h2 id="motivation-43"><a class="header" href="#motivation-43">Motivation</a></h2>
<p>Digital designs are typically built from separately designed and tested functional blocks that are composed together and perform a high-level task by exchanging data. These blocks define interfaces that typically combine a payload (e.g.: bytes or symbols received or sent via a physical interface, addresses and data on a memory bus, samples exchanged between DSP blocks) with handshaking or flow control (e.g.: whether the physical interface can accept a new symbol or has one available, whether a memory transaction is in progress, whether the DSP block has finished processing).</p>
<p>Amaranth supports specifying the structure of such interfaces with the very general <code>amaranth.lib.wiring</code> module, but the structure is only half of the story, as even the simplest flow control schemes include complex requirements, restricting not only the permissible sequences of states of flow control signals, but often also the domain from which the signals may be driven, and which signals may combinatorially depend on which other ones. A mistake in flow control circuitry is often difficult to discover (it may only manifest when used with a subset of compatible blocks and not surface in tests) and debug (waveform viewers generally do not show data dependencies so it may not be clear why a certain signal is asserted or deasserted).</p>
<p>This complexity and challenges makes it useful to standardize on specific data exchange interfaces with a simple, robust, flexible, and well-defined flow control scheme. This proposal offers one such scheme suited for unidirectional communication only. In turn, it can be used to build bidirectional communication protocols.</p>
<h2 id="guide-level-explanation-34"><a class="header" href="#guide-level-explanation-34">Guide-level explanation</a></h2>
<p>The <code>amaranth.lib.stream</code> module defines the concept of a <em>stream</em>. A stream is an <code>amaranth.lib.wiring</code> interface consisting of three port members:</p>
<ul>
<li><code>payload: Out(payload_shape)</code></li>
<li><code>valid: Out(1)</code></li>
<li><code>ready: In(1)</code></li>
</ul>
<p>The purpose of a stream is to mediate unidirectional data transfer between two components, called a <em>transmitter component</em> (which drives <code>payload</code> and <code>valid</code> members in its <em>output stream</em>, and samples <code>ready</code>) and a <em>receiver component</em> (which drives <code>ready</code> member in its <em>input stream</em>, and samples <code>payload</code> and <code>valid</code>). The directions of port members above are from the perspective of the transmitter component, as required by <code>amaranth.lib.wiring</code>. The values of every member must be fixed or change according to the same clock domain.</p>
<p>Data is transferred via the stream according to the following rules:</p>
<ol>
<li>On each cycle where both <code>valid</code> and <code>ready</code> are asserted, a transfer is performed: the contents of <code>payload</code> is conveyed from the transmitter to the receiver.</li>
<li>Once the transmitter asserts <code>valid</code>, it must not deassert it until a transfer is performed.</li>
<li>As an exception to rule (2), when the transmitter is reset it must deassert <code>valid</code>, unless it ties <code>valid</code> to <code>Const(1)</code> in the interface object.</li>
<li>Once the transmitter asserts <code>valid</code>, it must not change the contents of <code>payload</code> until a transfer is performed.</li>
<li>The transmitter must not wait for <code>ready</code> to be asserted before asserting <code>valid</code>. Any form of feedback from <code>ready</code> that causes <code>valid</code> to go from deasserted to asserted is prohibited.</li>
<li>Once the receiver asserts <code>ready</code> it may deassert it at any time.</li>
<li>The receiver may wait for <code>valid</code> to be asserted before asserting <code>ready</code>. Combinatorial feedback from <code>valid</code> to <code>ready</code> is allowed.</li>
</ol>
<p>These rules ensure that transmitters and receivers can be developed independently yet safely used together, without unduly restricting the application-specific conditions that determine assertion of <code>valid</code> and <code>ready</code>.</p>
<p>Some transmitters and receivers may be designed in a way that requires them to perform a transfer on every cycle when they are not reset. Such transmitters and receivers may (but are not required to) tie <code>valid</code> to <code>Const(1)</code>. Similarly, some transmitters and receivers may be designed without support for backpressure. Such transmitters and receivers may (but are not required to) tie <code>ready</code> to <code>Const(1)</code>.</p>
<p>If these control signals are tied to <code>Const(1)</code>, then <code>amaranth.lib.wiring.connect</code> ensures that only compatible streams are connected. For example, if the transmitter does not support backpressure (<code>ready</code> tied to <code>Const(1)</code>), it can only be connected to receivers that do not support backpressure. However, receivers that do not support backpressure can be connected to any transmitter, since the receiver would appear as an always-ready one to a transmitter that does support backpressure. Similar logic applies to <code>valid</code> when it is tied to <code>Const(1)</code>.</p>
<h2 id="reference-level-explanation-34"><a class="header" href="#reference-level-explanation-34">Reference-level explanation</a></h2>
<p>A new <code>amaranth.lib.stream</code> module is added, defining two classes: <code>Signature</code> and <code>Interface</code>:</p>
<ul>
<li><code>amaranth.lib.stream.Signature(payload_shape, *, always_valid=False, always_ready=False)</code>
<ul>
<li>with members:
<ul>
<li><code>payload: Out(payload_shape)</code></li>
<li><code>valid: Out(1)</code></li>
<li><code>ready: In(1)</code></li>
</ul>
</li>
<li>with properties:
<ul>
<li><code>always_valid: bool</code></li>
<li><code>always_ready: bool</code></li>
</ul>
</li>
<li>with methods:
<ul>
<li><code>__eq__(other)</code>: requires <code>isinstance(other, amaranth.lib.stream.Signature)</code> and all three of <code>payload_shape</code>, <code>always_valid</code>, <code>always_ready</code> to match</li>
<li><code>create()</code>: constructs an <code>amaranth.lib.stream.Interface</code></li>
</ul>
</li>
</ul>
</li>
<li><code>amaranth.lib.stream.Interface(signature, *, path=None, src_loc_at=0)</code>
<ul>
<li>with attributes:
<ul>
<li><code>.payload = Signal(payload_shape)</code></li>
<li>If <code>signature.always_valid == False</code>: <code>.valid = Signal()</code></li>
<li>If <code>signature.always_valid == True</code>:  <code>.valid = Const(1)</code></li>
<li>If <code>signature.always_ready == False</code>: <code>.ready = Signal()</code></li>
<li>If <code>signature.always_ready == True</code>:  <code>.ready = Const(1)</code></li>
</ul>
</li>
<li>with properties:
<ul>
<li><code>p</code>: alias of <code>payload</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Like other <code>amaranth.lib</code> modules, it is intended to be imported with the <code>from amaranth.lib import stream</code> statement and the classes be used with their qualified names, <code>stream.Signature</code> and <code>stream.Interface</code>.</p>
<p>There is purposefully no <code>amaranth.lib.stream.Signature.payload_shape</code> property. It is expected that a future RFC will enable construction and introspection of complex streams, and the provision of any introspection of the payload is deferred until then.</p>
<p>The <code>amaranth.lib.fifo.FIFOInterface</code> class is extended with properties:</p>
<ul>
<li><code>r_stream: stream.Interface</code>: interface adapter with <code>payload = .r_data</code>, <code>valid = .r_rdy</code>, <code>ready = .r_en</code>.</li>
<li><code>w_stream: stream.Interface</code>: interface adapter with <code>payload = .w_data</code>, <code>valid = .w_en</code>, <code>ready = .r_rdy</code>.</li>
</ul>
<h2 id="drawbacks-42"><a class="header" href="#drawbacks-42">Drawbacks</a></h2>
<p>This proposal errs heavily on the side of minimalism, making it less broadly applicable.</p>
<p>This proposal locks in two major design decisions:</p>
<ul>
<li>That <code>payload</code> is a port member, not an interface member.</li>
<li>That the stream signature always has exactly these three members.</li>
</ul>
<p>If this turns out to be a mistake, existing code relying on the guarantees provided by these decisions will break.</p>
<h2 id="rationale-and-alternatives-41"><a class="header" href="#rationale-and-alternatives-41">Rationale and alternatives</a></h2>
<h3 id="a-scope-of-this-proposal"><a class="header" href="#a-scope-of-this-proposal">A: Scope of this proposal</a></h3>
<p>Streams are one of the most highly coveted planned features. While we could choose to not provide them at all (as an external library implementation is possible), this will make Amaranth less competitive and perpetuate the status quo of every complex downstream project implementing their own, incompatible, version of streams.</p>
<p>This module is described as &quot;minimal&quot; because it is highly limited in scope. This has the desirable qualities that it is easier to implement, document, and teach; that it is more widely compatible with existing code using streams; and that it is amenable to further gradual expansion.</p>
<ul>
<li>The payload is an opaque (to the <code>amaranth.lib.stream</code> module) shape that is not given further meaning.</li>
<li>The rules of data transfer are very restrictive; in particular rules (5) and (7) ensure that the flow control is performed by the transmitter and the receiver independently.</li>
<li>No interconnect components are proposed; only a minimal viable extension for the standard FIFOs, which is likely to be used in most designs.</li>
</ul>
<p>The scope has been chosen to provide a useful implementation without delaying further work that relies on streams until every detail involved in defining fully functional streams can be agreed upon. Although it largely avoids delving into such detail, it does make some choices that will impact further work (see the <a href="0061-minimal-streams.html#drawbacks">Drawbacks</a> section). We could decide to reject this proposal in favor of one with a broader scope and make a choice informed by further design and prototyping, but this is likely to unacceptably delay other work.</p>
<h3 id="b-always-valid-and-always-ready-streams"><a class="header" href="#b-always-valid-and-always-ready-streams">B: Always-valid and always-ready streams</a></h3>
<p>Although, in general, a transmitter may produce a payload only on some cycles (communicated by <code>valid</code>) and a receiver may accept a payload only on some cycles (communicated by <code>ready</code>), there are important cases where dynamic flow control on either endpoint is undesirable, such as:</p>
<ul>
<li>A SerDes/transceiver block would typically produce a symbol and consume a symbol on each cycle, with no ability to pause transmission or reception without losing the link.</li>
<li>Similarly, a parallel ADC will produce a code on each cycle, and a parallel DAC will accept a code on each cycle.</li>
<li>When interfacing with such I/O devices, there is no need for flow control, and it should be excluded from the interconnect as it can cause significant overhead. This especially applies to the <code>ready</code> signal, which can form long combinatorial chains through the interconnect, pessimizing delay. The <code>valid</code> signal is registered, pessimizing area alone.</li>
<li>Digital signal processing blocks often perform computations at a constant rate; for example, a pipelined multiplier may accept a pair of operands each cycle, and produce a result each cycle, with a fixed latency of 5. In such blocks, accounting for bubbles in the pipeline can be complex and error-prone, while stopping the entire pipeline if the inputs are not <code>valid</code> can cause deadlocks.</li>
</ul>
<p>It appears essential to support endpoints that always assert <code>valid</code> and/or <code>ready</code>. There are several possible approaches to implementing them:</p>
<ol>
<li>Do nothing special. Assign <code>valid</code> and/or <code>ready</code> to <code>1</code> at all times.</li>
<li>Remove <code>valid</code> and/or <code>ready</code> from the signature of such streams, and treat the four kinds of streams entirely separately.</li>
<li>Remove <code>valid</code> and/or <code>ready</code> from the signature of such streams, and use subclasses to unify the four kinds of streams.</li>
<li>Set the <code>valid</code> and/or <code>ready</code> attributes to <code>Const(1)</code> and rely on <code>amaranth.lib.wiring.connect()</code> to enforce well-formedness of connections.
<ul>
<li>This is the option used in this proposal.</li>
</ul>
</li>
</ol>
<p>Option (B1) is not very useful: streams have no way to indicate an error, so data being pushed into a non-ready stream from an always-valid one will get discarded, and an always-ready stream will pull nonsense data from a non-valid stream.</p>
<p>Option (B2) is not very useful either: since there is no way to treat the four kinds of streams generically, even basic interconnect (e.g. a FIFO queue) will in effect have 16 possible instantiations, which is too high of a burden to implement and test.</p>
<p>Option (B3) would, at first glance, require the use of a complex diamond inheritance pattern (below) and adaptation functions converting one type of interface into another. Unfortunately, even that cannot be made to work, since the subtyping relationship does not capture directionality. A payload+ready+valid output stream can be connected to a payload+valid (always ready) input stream, but not vice versa; similarly, a payload+ready output stream (always valid) can be connected to a payload+ready+valid input stream, but not vice versa.</p>
<img src="./0061-minimal-streams/subtyping.svg" width="550" alt="a diagram showing node 'payload+ready+valid' subtyping node 'payload+ready', node 'payload+valid', and node 'payload'; and both node 'payload+ready' and node 'payload+valid' subtyping node 'payload'">
<p>Thus, option (B4) is the only feasible one: it does not require interface adaptation and avoids complex inheritance hierarchies in favor of a one-class solution while at the same time capturing the complex and directional subtyping relationship through the use of <code>amaranth.lib.wiring.connect()</code>. Also, since <code>connect()</code> can connect multiple streams, it is possible to broadcast a stream (connect a single transmitter to multiple receivers) with no interconnect, provided that none of the receivers require backpressure.</p>
<h3 id="c-payload-shape"><a class="header" href="#c-payload-shape">C: Payload shape</a></h3>
<p>There are three options for the payload member that are naturally possible with <code>lib.wiring</code>:</p>
<ol>
<li>Unrestricted <code>payload</code> member: a shape (port) or a signature (interface) are all valid, with no restrictions on the interface.</li>
<li><code>payload</code> member restricted to a shape (port) or a signature (interface) with only <code>Out</code> members.</li>
<li><code>payload</code> member restricted to a shape (port) only.
<ul>
<li>This is the option used in this proposal.</li>
</ul>
</li>
</ol>
<p>Option (C1) is not viable as it allows bidirectional communication to happen through the <code>payload</code> member, in contradiction to the goals of this proposal. Among other reasons, it makes streams no longer possible to pass through an async FIFO for clock domain crossing, which drastically reduces their usefulness.</p>
<p>Option (C2) does have the advantage of splitting the payload into individual signals, which are more visible in waveform diagrams and on module boundaries in Verilog. However, it has a serious drawback, which is that <code>amaranth.lib.wiring.connect()</code> will not connect a single member to multiple members. This means that streams can no longer be directly connected to the three signals made available by the existing FIFOs in <code>amaranth.lib.fifo</code>, requiring adaptation.</p>
<p>Option (C3) affords the same flexibility in the payload as option (2), without requiring stream-specific FIFOs; instead, an existing FIFO with its <code>[rw]_ack</code>, <code>[rw]_rdy</code>, <code>[rw]_data</code> signals can be connected to a stream endpoint provided that the same signals are put into an <code>amaranth.lib.wiring.PureInterface</code>, as long as the <code>[rw]_data</code> signal has the right width.</p>
<h3 id="d-omitted-features"><a class="header" href="#d-omitted-features">D: Omitted features</a></h3>
<p>This proposal intentionally omits the following features:</p>
<ol>
<li>packetization (often implemented using <code>first</code> and/or <code>last</code> control signals)</li>
<li>multiple lanes (often implemented using <code>data[n]</code> data signal coupled with <code>stb[n]</code> control signal)</li>
<li>sub-streams (often implemented using <code>id</code> and <code>dest</code> sideband signals)</li>
<li>unstructured metadata (often implemented using <code>user</code> sideband signal)</li>
</ol>
<p>Based on the prior art examined and preliminary design work, the author of this proposal believes that all of these features may be implemented in a backward-compatible manner, by embedding all of the associated information in the <code>payload</code> port member and enabling extraction of the features and their configuration from the signature of the stream. This has the advantage that not all interconnect needs to be aware of such features, and interconnect that has little ability to be enhanced by them (e.g. an async FIFO) will be compatible with them without any changes.</p>
<p>There is no <code>payload_shape</code> accessor on <code>amaranth.lib.stream.Signature</code> to allow flexibility for future expansion.</p>
<h2 id="prior-art-38"><a class="header" href="#prior-art-38">Prior art</a></h2>
<p>The two main influences on this proposal are AMBA AXI4-Stream protocol and LiteX stream functionality.</p>
<h3 id="amba-axi-stream"><a class="header" href="#amba-axi-stream">AMBA AXI-Stream</a></h3>
<p>The AMBA AXI-Stream protocol is specified in the openly available <a href="https://documentation-service.arm.com/static/64819f1516f0f201aa6b963c">ARM IHI 0051B document</a> and is similar in some respects to this proposal. <strong>The protocol described in this proposal is not compliant with the AMBA Specification nor is it intended to be compliant with the AMBA Specification.</strong> The AMBA specification is merely referenced here as a point of discussion.</p>
<p>The AMBA AXI-Stream protocol is both more specialized and more constrained than this proposal. To compare them:</p>
<ol>
<li>AXI-Stream signal <strong>TDATA</strong> must be an integer number of bytes (a multiple of 8 wide) and is recommended to be a power of 2 and cannot be zero-width. This proposal makes no such restrictions.</li>
<li>AXI-Stream allows, though does not recommend, the omission of <strong>TREADY</strong> and <strong>TVALID</strong> signals. This proposal mandates their inclusion but allows tie-off to constant 1.</li>
<li>The rules for asserting <strong>TREADY</strong> and <strong>TVALID</strong> in AXI-Stream are the same as the rules for asserting <code>ready</code> and <code>valid</code> in this proposal, except for the deassertion of <code>valid</code> during reset.</li>
<li>AXI-Stream separates the optional ancillary signals <strong>TSTRB</strong>, <strong>TKEEP</strong>, <strong>TLAST</strong>, <strong>TID</strong>, <strong>TDEST</strong>, <strong>TUSER</strong> from the primary <strong>TDATA</strong> signal. This proposal includes all of these signals under the umbrella <code>payload</code> port. Note that the AXI-Stream handshake covers both <strong>TDATA</strong> and all of the ancillary signals that are present (see figures 2-1, 2-2, 2.3); as such, it is similar to this proposal in that their treatment is similarly uniform.</li>
<li>AXI-Stream includes complex rules for merging, packing, upsizing, downsizing, interleaving, and ordering, as well as position bytes and null bytes, which are not present in this proposal and are not in its scope.</li>
<li>AXI-Stream mandates that transfers happen synchronously to the rising edge of <strong>ACLK</strong>, and specifies <strong>ARESETn</strong> to be an active low reset (synchronous or asynchronous). This proposal differs in that it allows any clock and reset expressible as an Amaranth clock domain. It is similar in that it mandates <code>valid</code> to be driven low during reset, but has a carve-out for tying <code>valid</code> to 1.</li>
<li>AXI5-Stream includes a <strong>TWAKEUP</strong> signal for power management. This signal is associated with a stream but is not subject to handshaking; it is not directly a part of the stream, even if it influences the behavior of the stream and can cause a deadlock.</li>
</ol>
<p>Although the protocol in this proposal and the AXI-Stream protocols are not interoperable, it is possible and straightforward to define components that are functionally compliant (without exceptions) with both the protocol in this proposal, making use of a subset of it, and the AMBA AXI4-Stream or AXI5-Stream protocols. Such components will require an adapter to match the AXI-Stream protocols, but the adapter will not require any logic gates.</p>
<p>The AXI4-Stream protocol is pervasively used in the industry and well regarded, and the ability to define components functionally compatibile with it is highly desirable. At the same time, some of the technical features of the AXI-Stream protocols (most importantly the restrictions on the <strong>TDATA</strong> signal, which prevent the use of arbitrary data/payload shapes), as well as the license under which it is distributed, make it unsuitable for use as-is in the Amaranth ecosystem.</p>
<h3 id="avalon-st"><a class="header" href="#avalon-st">Avalon-ST</a></h3>
<p>The Avalon-ST protocol is specified in the openly available <a href="https://cdrdv2-public.intel.com/743655/mnl_avalon_spec-683091-743655.pdf">Intel 683091(2022.09.26) document</a> (section 5) and is similar in some respects to this proposal. The Avalon-ST specification is merely referenced here as a point of discussion.</p>
<p>The Avalon-ST protocol is similar to this proposal, but includes some additional features. Note that &quot;practically&quot; below means &quot;formally the wording may be different but it is not expected that this will ever cause any incompatibility in practical use&quot;. To compare them:</p>
<ol>
<li>Avalon-ST signal <code>data</code> can carry 1 to 8192 bits, not restricted to a power of 2 or a multiple of 8, and can be omitted. Avalon-ST includes a provision for bytes, but the byte size can be any number from 1 to 512 bits. This is practically identical to this proposal.</li>
<li>Avalon-ST does not require inclusion of any of the signals, even <code>ready</code> and <code>valid</code>. This proposal mandates their inclusion but allows tie-off to constant 1.</li>
<li>The rules for asserting <code>ready</code> and <code>valid</code> in Avalon-ST when the components are configured with <code>readyLatency = readyAllowance = 0</code> are practically the same as rules for asserting <code>ready</code> and <code>valid</code> in this proposal. Some of the behavior in Avalon-ST is implicitly specified; the <code>valid</code> signal is required to be registered at the source, which defines its behavior during reset (that matches this proposal). However, the <code>readyLatency &gt; 0</code> or <code>readyAllowance &gt; 0</code> configuration has no equivalent to this proposal (or the other stream interfaces being compared).</li>
<li>Avalon-ST separates the optional ancillary signals <code>channel</code>, <code>error</code>, <code>empty</code>, <code>startofpacket</code>, <code>endofpacket</code> from the primary <code>data</code> signal. This proposal includes all of these signals under the umbrella <code>payload</code> port. Note that the Avalon-ST handshake covers both <code>data</code> and all of the ancillary signals that are present per the description of the <code>valid</code> signal in Table 17; as such, it is similar to this proposal in that their treatment is similarly uniform.</li>
<li>Avalon-ST optionally includes fairly simple routing and packetization interfaces, which are not present in this proposal and are not in its scope.</li>
<li>Avalon-ST mandates that transfers happen synchronously to the rising edge of the associated clock sink, and that the logic is reset by the associated reset sink. This proposal differs in that it allows any clock and reset expressible as an Amaranth clock domain. Avalon reset sinks are as expressive as Amaranth clock domain resets. In both this proposal and Avalon-ST, <code>valid</code> will be either tied off to 1 (in which case it's omitted from Avalon-ST) or driven low during reset.</li>
<li>Avalon-ST includes an unusual <code>error</code> signal that allows the source signal an error to the sink. Importantly, it is not useful for signaling protocol errors (e.g. overflow due to an error in <code>ready</code> signal handling by the source), since the sink either drives only a <code>ready</code> signal or nothing.</li>
</ol>
<p>The protocol in this proposal and the Avalon-ST protocol are interoperable if the Avalon-ST interface is configured with parameters <code>readyLatency = readyAllowance = 0</code> and includes <code>data</code>, <code>ready</code>, and <code>valid</code> signals only (i.e. beats, packets, or channels are not used). In addition, <code>data</code> must be renamed to <code>payload</code> and a posedge clock domain must be used in Amaranth.</p>
<p>The Avalon-ST protocol is widely used in the industry, especially in the Altera (Intel (Altera)) ecosystem, and the ability to define components interoperable with it is highly desirable. While it could be used as-is in the Amaranth ecosystem, it is valuable to reconsider whether the inclusion of some of the rarely used features is worth the support and compatibility burden, since all generic interconnect would have to be aware of them. Splitting of <code>data</code> into symbols or bytes seems particularly unnecessary.</p>
<p>The <code>readyLatency</code> and <code>readyAllowance</code> parameters allow a more efficient use of FPGA resources (registers) and while adding them at this stage seems premature, it is a useful feature and should be considered for future work. Since connecting interfaces with mismatched <code>readyLatency</code> and <code>readyAllowance</code> is disastrous (results in silent data loss), this would likely require support for matching interface parameters to <code>amaranth.lib.wiring.connect()</code>, which is not currently available. Such support must be able to take into account that interfaces are compatible if a parameter of the source is <em>equal or less than</em> of the same parameter on the sink, which is a complex relation that would require significant design work.</p>
<h3 id="litex-streams"><a class="header" href="#litex-streams">LiteX streams</a></h3>
<p>The LiteX stream protocol does not have a specification. It is described in a <a href="https://github.com/enjoy-digital/litex/wiki/Streams">very short wiki page</a> as &quot;LiteX's streams are a simplified compromise between AXI-4/Avalon-ST&quot; and is similar in some respects to this proposal. There is also <a href="https://github.com/enjoy-digital/litex/blob/master/litex/soc/interconnect/stream.py">an implementation</a> that may be used to attempt to understand the protocol.</p>
<p>The LiteX stream protocol is very similar to this proposal, but includes some additional features. To compare them:</p>
<ol>
<li>LiteX stream <code>payload</code> signal can carry unrestricted structured data, similarly to the <code>payload</code> port in this proposal. However, since it is a full Migen <code>Record</code>, it carries the same flaw as the <a href="0061-minimal-streams.html#payload-shape">option (C1)</a>, and it is easy to misuse it.</li>
<li>LiteX streams always include all of the defined signals: <code>valid</code>, <code>ready</code>, <code>first</code>, <code>last</code>, <code>payload</code>, and <code>param</code>, handling always-valid/always-ready streams the same way as <a href="0061-minimal-streams.html#always-valid-and-always-ready-streams">option (B1)</a>, and always including <a href="0061-minimal-streams.html#omitted-features">options (D1) and (D4)</a>. This proposal includes only <code>valid</code>, <code>ready</code>, and <code>payload</code>.</li>
<li>The rules for assertion of <code>ready</code> and <code>valid</code> are not documented but (given the references to AXI-Stream and Avalon-ST) may be assumed to be entirely or mostly compatible with these two protocols, and consequently this proposal.</li>
<li>LiteX streams separates ancillary signals <code>first</code>, <code>last</code>, and <code>param</code> from the primary <code>payload</code> signal. This proposal includes all of these signals under the umbrella <code>payload</code> signal, if they are implemented. The flow control rules for <code>first</code> and <code>last</code> are the same as for the <code>payload</code> signal in LiteX, but the flow control rules for <code>param</code> are different: <code>param</code> must be constant for the entire duration of a packet. (The flow control rules for <code>param</code> reference the flow control users for <code>TUSER</code> in AXI-Stream, but this is actually incorrect: unlike <code>param</code> in LiteX, <code>TUSER</code> in AXI-Stream specifies ancillary data per-byte or per-transfer, not per-packet).</li>
<li>LiteX would appear, from the examination of the signals, to include a mandatory packetization scheme, but this is not the case. Rather, any sources, sinks, or interconnect that do not support packetization ignore <code>first</code> and <code>last</code>, and those of them which do support packetization may support exclusively <code>first</code> or exclusively <code>last</code>. There is no way to indicate any of these choices mechanically.</li>
<li>LiteX streams and this proposal both reference transfers to a clock domain. However, Migen only supports posedge clocks and synchronous active-high reset.</li>
</ol>
<p>The protocol in this proposal and the LiteX stream protocol cannot be readily described as interoperable or not due to the lack of formal description and general scarcity of documentation of the LiteX stream protocol. However, so long as packetization is not involved, and the LiteX <code>param</code> record is empty, they are probably interoperable.</p>
<p>The LiteX stream protocol is used exclusively in the LiteX ecosystem. Due to the rich availability of ready-made components in this ecosystem, the ability to define components interoperable with it is desirable. However, this is challenged by the difficulty of determining the feature set supported by a particular LiteX component. The flow control rules for the LiteX <code>param</code> signal are also unusual and may require an adapter with logic gates to reliably ensure compliance of an arbitrary Amaranth stream with the LiteX rules.</p>
<p>Due to the fact that LiteX endpoints and interconnect <a href="https://github.com/amaranth-lang/amaranth/issues/317#issuecomment-899407394">often arbitrarily decide to implement or leave unimplemented any subset of the <code>first</code> and <code>last</code> signals without necessarily documenting this choice</a>, it is easy to run into data loss, deadlocks, and other confusing behavior with LiteX streams, especially as a newcomer to the ecosystem. The author of this RFC has had LiteX streams described to her as &quot;frustrating&quot;, &quot;a real source of difficulty&quot;, or in one case &quot;traumatizing&quot;. This was the driving force behind the decision to <strong>not</strong> include either <code>first</code> or <code>last</code> signals in this proposal. It was also one of the chief motivations behind <code>amaranth.lib.wiring</code> refusing to connect interfaces except in a highly restrictive manner where signals may not be arbitrarily excluded at the point of connection.</p>
<h2 id="unresolved-questions-40"><a class="header" href="#unresolved-questions-40">Unresolved questions</a></h2>
<p>None.</p>
<h2 id="future-possibilities-41"><a class="header" href="#future-possibilities-41">Future possibilities</a></h2>
<ul>
<li>A new module with FIFO queues can be added (e.g. <code>amaranth.lib.queue</code>) with largely the same functionality that are built as components and are stream-only.
<ul>
<li>This has the advantage of being less constraining. Since all of the functionality of the existing <code>amaranth.lib.fifo</code> module as of Amaranth 0.5 will be provided in it, a clean migration path is available.</li>
</ul>
</li>
<li>Streams can be extended with a mechanism to specify complex payload shape that can be introspected by interconnect.</li>
<li>Interconnect components that operate on and process such complex payloads can be added via the RFC process, such as:
<ul>
<li>Lane converters (up-converter, down-converter).
<ul>
<li><a href="0056-mem-wide.html">RFC 56</a> almost but not quite enables existing FIFO queues to serve as such.</li>
</ul>
</li>
<li>Packetizers/de-packetizers.</li>
<li>Packet based queues that allow accepting or discarding a complete packet, or discarding incomplete or corrupted packets.</li>
<li>Stream routers based on destination ID.</li>
<li>Stream aligners that ensure a packet always starts on the 0th lane, or each Nth lane (e.g. each 4th 8-bit lane, for 32-bit alignment).</li>
</ul>
</li>
<li>AXI3 or AXI4 interfaces may be added to Amaranth SoC, as these protocols are designed as a bundle of streams (address channels, data channels, and completion channel).</li>
<li>The <code>readyLatency</code> and <code>readyAllowance</code> configuration parameters of Avalon-ST may be further investigated and potentially added to streams if they turn out to be broadly useful.</li>
<li>The <code>amaranth.lib.io</code> library may be extended to add a pair of always-ready, always-valid stream interfaces to <code>FFBuffer</code> and <code>DDRBuffer</code> (one for input, one for output). In this way, the same paradigm, multi-lane bit streams, may be used to communicate at data rates anywhere from 1 kilobit/s to 1 terabit/s.</li>
</ul>
<h3 id="stream-combinators"><a class="header" href="#stream-combinators">Stream combinators</a></h3>
<p>This proposal references many desirable stream features (primarily multiple lanes and packetization) to a future RFC that will extend the existing design. In the interest of convincing the reader that such an RFC is feasible, a sketch of how such extension may look like follows.</p>
<p>The stream protocol is extended with &quot;combinators&quot;, a composable mechanism of defining the shape and behavior of the <code>payload</code> members. The <code>payload</code> argument of the <code>amaranth.lib.stream.Signature(...)</code> constructor may receive a <em>combinator</em>, which is a shape-castable object (usually a <code>data.Struct</code> subclass):</p>
<ol>
<li><code>payload=Lanes(4, lane_shape)</code>
<ul>
<li>causes the <code>payload</code> member to contain a <code>lane: ArrayLayout(lane_shape, 4)</code> field</li>
<li>an up/down-converter interconnect may, by introspection, determine whether the input and output streams are compatible and what the ratio of lanes is</li>
</ul>
</li>
<li><code>payload=Lanes(4, lane_shape, en=True)</code>
<ul>
<li>causes the <code>payload</code> member to contain a <code>lane: ArrayLayout(lane_shape, 4)</code> field and a <code>en: 4</code> field</li>
<li>by introspection, the endpoints and the interconnect is aware that some of the lanes may not contain meaningful data and discard such data during up/down-conversion or upon receipt</li>
</ul>
</li>
<li><code>payload=Packet(data_layout, first=True, last=True)</code>
<ul>
<li>causes the <code>payload</code> member to contain a <code>data: data_layout</code> field, as well as <code>first: 1</code> and <code>last: 1</code> fields</li>
<li>by introspection, the components are aware that each individual transfer may begin and/or end the packet, with packet data being uninterpreted</li>
</ul>
</li>
<li><code>payload=Packet(Lanes(4, lane_shape), first=True, last=True)</code>
<ul>
<li>causes the <code>payload</code> member to contain a <code>data: StructLayout({&quot;lane&quot;: ArrayLayout(lane_shape, 4)})</code> field, as well as <code>first: 1</code> and <code>last: 1</code> fields</li>
<li>by introspection, the components are aware that each individual transfer may begin and/or end the packet, and that each packet consists of four individual symbols</li>
</ul>
</li>
<li><code>payload=Lanes(4, Packet(data_shape, first=True, last=True))</code>
<ul>
<li>causes the <code>payload</code> member to contain a <code>lane: ArrayLayout(StructLayout({&quot;data&quot;: data_shape, &quot;first&quot;: 1, &quot;last&quot;: 1}), 4)</code> field</li>
<li>by introspection, the components are aware that each individual transfer consists of up to four individual packets, and that packets may begin or end at any symbol</li>
</ul>
</li>
</ol>
<p>Please note that the degree of configurability in the examples is illustrative of the potential of the proposed functionality and do not necessarily reflect best practices to be established. That said, example (4) follows a real-world example where a 1024-bit wide bus used in a high-throughput PCIe interconnect implementation requires support for multiple packets per transfer to meet its efficiency target.</p>
<p>Stream combinators can be defined in code downstream to Amaranth, and streams employing user-defined combinators remain usable with some standard interconnect; e.g. an async FIFO does not introspect the payload at all, and an up/down-converter only &quot;unwraps&quot; the outermost combinator, expecting to find the <code>amaranth.lib.stream.Lanes</code> combinator there, and treating the <code>lane_shape</code> shaped element as opaque.</p>
<p>The fact that <code>amaranth.lib.wiring.connect()</code> will connect any two port members with a matching name and width and compatible flows without regard to the shape of the member is concerning in light of the importance of the shape of the <code>payload</code> member of a stream. There are multiple options in handling this issue, including:</p>
<ol>
<li>Reconsidering the behavior of <code>amaranth.lib.wiring.connect()</code> so that the shape of a port member is taken into account, either to emit a warning or to raise an error.</li>
<li>Introducing additional behavior to <code>amaranth.lib.wiring.connect()</code> so that a function attached to a port member is called to check its compatibility with another port member.</li>
<li>Relying on the fact that adding a stream combinator essentially always changes the width of the <code>payload</code> member and therefore the existing width check is sufficient to catch most errors.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2024-03-25</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/62">amaranth-lang/rfcs#62</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth/issues/1241">amaranth-lang/amaranth#1241</a></li>
</ul>
<h1 id="the-memorydata-class"><a class="header" href="#the-memorydata-class">The <code>MemoryData</code> class</a></h1>
<h2 id="summary-44"><a class="header" href="#summary-44">Summary</a></h2>
<p>A new class, <code>amaranth.hdl.MemoryData</code>, is added to represent the data and identity of a memory. It is used to reference the memory in simulation.</p>
<h2 id="motivation-44"><a class="header" href="#motivation-44">Motivation</a></h2>
<p>It is commonly useful to access a memory in a simulation testbench without having to create a special port for it. This requires storing some kind of a reference to the memory on the elaboratables.</p>
<p>Currently, the object used for this is of a private <code>MemoryIdentity</code> class. It is implicitly created by <code>lib.memory.Memory</code> constructor, and passed to the private <code>_MemorySim{Read|Write}</code> objects when <code>__getitem__</code> is called.  This has a few problems:</p>
<ul>
<li>the <code>Memory</code> needs to be instantiated in the constructor of the containing elaboratable; combined with its mutability and the occasional need to defer memory port creation to <code>elaborate</code>, this results in elaboratables that break when elaborated more than once</li>
<li><code>amaranth.sim</code> currently requires a gross hack to recognize <code>Memory</code> objects in <code>traces</code></li>
<li>occasionally, it is useful to have <code>Signal</code>s that are not included in the design proper, but are used to communicate between simulator processes; it could be likewise useful with memories, but it cannot work with the current code (since the <code>MemoryIdentity</code> that the simulator gets doesn't have enough information to actually create backing storage for the memory)</li>
<li><code>MemoryIdentity</code> nor <code>MemoryInstance</code> don't contain information about the element shape, which would require further wrappers on <code>lib.Memory</code> to perform shape conversion in post-RFC 36 world</li>
</ul>
<p>The proposed <code>MemoryData</code> class:</p>
<ul>
<li>replaces <code>MemoryIdentity</code> and serves as the reference point for the simulator</li>
<li>encapsulates the memory's shape, depth, and initial value (so the simulator can use it to create backing storage)</li>
<li>in the common scenario, is created by the user in elaboratable constructor, stored as an attribute on the elaboratable, then passed to <code>Memory</code> constructor in <code>elaborate</code></li>
</ul>
<h2 id="guide-level-explanation-35"><a class="header" href="#guide-level-explanation-35">Guide-level explanation</a></h2>
<p>If the memory is to be accessible in simulation, the code to create a memory changes from:</p>
<pre><code class="language-py">m.submodules.memory = memory = Memory(shape=..., depth=..., init=...)
port = memory.read_port(...)
</code></pre>
<p>to:</p>
<pre><code class="language-py"># in __init__
self.mem_data = MemoryData(shape=..., depth=..., init=...)
# in elaborate
m.submodules.memory = memory = Memory(self.mem_data)
port = memory.read_port(...)
</code></pre>
<p>The <code>my_component.mem_data</code> object can then be used in simulation to read and write memory:</p>
<pre><code class="language-py">addr = 0x1234
row = sim.get(mem_data[addr])
row += 1
sim.set(mem_data[addr], row)
</code></pre>
<p>The old way of creating memories is still supported, though somewhat less flexible.</p>
<h2 id="reference-level-explanation-35"><a class="header" href="#reference-level-explanation-35">Reference-level explanation</a></h2>
<p>Two new classes are added:</p>
<ul>
<li><code>amaranth.hdl.MemoryData(*, shape: ShapeLike, depth: int, init: Iterable[int | Any], name=None)</code>: represents a memory's data storage. <code>name</code>, if not specified, defaults to the variable name used to store the <code>MemoryData</code>, like it does for <code>Signal</code>.
<ul>
<li><code>__getitem__(self, addr: int) -&gt; MemoryData._Row | ValueCastable</code>: creates a <code>MemoryData._Row</code> object; if <code>self.shape</code> is a <code>ShapeCastable</code>, the <code>MemoryData._Row</code> object constructed is immediately wrapped via <code>ShapeCastable.__call__</code></li>
</ul>
</li>
<li><code>amaranth.hdl.MemoryData._Row</code> (subclass of <code>Value</code>): represents a single row of <code>MemoryData</code>, has no public constructor nor operations (other than ones derived from <code>Value</code>), can only be used in simulator processes and testbenches</li>
</ul>
<p>The <code>MemoryData</code> class allows access to its constructor arguments via read-only properties.</p>
<p>The <code>lib.memory.Memory.Init</code> class is moved to <code>amaranth.hdl.MemoryData.Init</code>. It is used for the <code>init</code> property of <code>MemoryData</code>.</p>
<p>The <code>Memory</code> constructor is changed to:</p>
<ul>
<li>
<p><code>amaranth.lib.memory.Memory(data: MemoryData = None, *, shape=None, depth=None, init=None, name=None)</code></p>
<ul>
<li>either <code>data</code>, or all three of <code>shape</code>, <code>depth</code>, <code>init</code> need to be provided, but not both</li>
<li>if <code>data</code> is provided, it is used directly, and stored</li>
<li>if <code>shape</code>, <code>depth</code>, <code>init</code> (and possibly <code>name</code>) are provided, they are used to create a <code>MemoryData</code>, which is then stored</li>
</ul>
</li>
</ul>
<p>The <code>MemoryData</code> object is accessible via a new read-only <code>data</code> property on <code>Memory</code>. The existing <code>shape</code>, <code>depth</code>, <code>init</code> properties become aliases for <code>data.shape</code>, <code>data.depth</code>, <code>data.init</code>.</p>
<p><code>MemoryInstance</code> constructor is likewise changed to:</p>
<ul>
<li><code>amaranth.hdl.MemoryInstance(data: MemoryData, *, attrs={})</code></li>
</ul>
<p>The <code>sim.memory_read</code> and <code>sim.memory_write</code> methods proposed by RFC 36 are removed. Instead, the new <code>Memory._Row</code> simulation-only value is introduced, which can be passed to <code>get</code>/<code>set</code>/<code>changed</code> like any other value. Masked writes can be implemented by <code>set</code> with a slice of <code>MemoryData._Row</code>, just like for signals.</p>
<p><code>MemoryData</code> and <code>MemoryData._Row</code> instances (possibly wrapped in <code>ShapeCastable</code> for the latter) can be added to the <code>traces</code> argument when writing a VCD file with the simulator.</p>
<p>Using <code>MemoryData._Row</code> within an elaboratable results in an immediate error, even if the design is only to be used in simulation. The only place where <code>MemoryData._Row</code> is valid is within an argument to <code>sim.get</code>/<code>sim.set</code>/<code>sim.changed</code> and similar functions.</p>
<p><code>sim.edge</code> remains restricted to plain <code>Signal</code> and single-bit slices thereof. <code>MemoryData._Row</code> is not supported.</p>
<h2 id="drawbacks-43"><a class="header" href="#drawbacks-43">Drawbacks</a></h2>
<p>None.</p>
<h2 id="rationale-and-alternatives-42"><a class="header" href="#rationale-and-alternatives-42">Rationale and alternatives</a></h2>
<p><code>MemoryData</code> having <code>shape</code>, <code>depth</code>, and <code>init</code> is necessary to allow the simulator to create the underlying storage if the memory is not included in the design hierarchy, but is used to communicate between simulator processes.</p>
<h2 id="prior-art-39"><a class="header" href="#prior-art-39">Prior art</a></h2>
<p><code>MemoryData</code> is conceptually equivalent to a 2D <code>Signal</code>, for simulation purposes. It thus follows similar rules.</p>
<h2 id="unresolved-questions-41"><a class="header" href="#unresolved-questions-41">Unresolved questions</a></h2>
<p>None.</p>
<h2 id="future-possibilities-42"><a class="header" href="#future-possibilities-42">Future possibilities</a></h2>
<p>A <code>MemoryData.Slice</code> class could be added, allowing a whole range of memory addresses to be <code>get</code>/<code>set</code> at once, monitored for changes with <code>changes</code>, or added to <code>traces</code>.</p>
<p>Support for <code>__getitem__(Value)</code> could be added (currently it would be blocked on CXXRTL capabilities).</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2024-04-08</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/63">amaranth-lang/rfcs#63</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth/issues/1292">amaranth-lang/amaranth#1292</a></li>
</ul>
<h1 id="remove-amaranthlibcoding"><a class="header" href="#remove-amaranthlibcoding">Remove <code>amaranth.lib.coding</code></a></h1>
<h2 id="summary-45"><a class="header" href="#summary-45">Summary</a></h2>
<p>Remove <code>amaranth.lib.coding</code> and all classes in it.</p>
<h2 id="motivation-45"><a class="header" href="#motivation-45">Motivation</a></h2>
<p>This module has been essentially inherited from Migen and doesn't meet the bar for inclusion in Amaranth standard library. Most of the functionality included is so simple that it's essentially easier to just inline an implementation. The rest of it would be better served by a function than a module.</p>
<h2 id="guide-level-explanation-36"><a class="header" href="#guide-level-explanation-36">Guide-level explanation</a></h2>
<p>The module <code>amaranth.lib.coding</code> and all classes in it are removed. To continue using it, copy the contents of the module into your own project.</p>
<h2 id="reference-level-explanation-36"><a class="header" href="#reference-level-explanation-36">Reference-level explanation</a></h2>
<p>All classes within <code>amaranth.lib.coding</code> are deprecated in Amaranth 0.5 and removed (along with the module) in Amaranth 0.6. The Gray encoder is moved to <code>lib.fifo</code> as a private implementation detail.</p>
<h2 id="drawbacks-44"><a class="header" href="#drawbacks-44">Drawbacks</a></h2>
<ul>
<li>Churn.</li>
</ul>
<h2 id="rationale-and-alternatives-43"><a class="header" href="#rationale-and-alternatives-43">Rationale and alternatives</a></h2>
<ul>
<li>This module is out of place in the standard library.</li>
<li>It has not seen much use and is trivially implemented outside of it.</li>
<li>Downstream consumers tend to inline the logic anyway.</li>
</ul>
<h2 id="unresolved-questions-42"><a class="header" href="#unresolved-questions-42">Unresolved questions</a></h2>
<p>None.</p>
<h2 id="future-possibilities-43"><a class="header" href="#future-possibilities-43">Future possibilities</a></h2>
<p>The functionality could be brought back at a future point with a more suitable lightweight interface (as functions instead of modules), when the core language is flexible enough to support that.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2024-04-08</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/65">amaranth-lang/rfcs#65</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth/issues/1293">amaranth-lang/amaranth#1293</a></li>
</ul>
<h1 id="special-formatting-for-structures-and-enums"><a class="header" href="#special-formatting-for-structures-and-enums">Special formatting for structures and enums</a></h1>
<h2 id="summary-46"><a class="header" href="#summary-46">Summary</a></h2>
<p>Extend <code>Format</code> machinery to support structured description of aggregate and enumerated data types.</p>
<h2 id="motivation-46"><a class="header" href="#motivation-46">Motivation</a></h2>
<p>When a <code>lib.data.Layout</code>-typed signal is included in the design, it is often useful to treat it as multiple signals for debug purposes:</p>
<ul>
<li>in pysim VCD output, it is useful to have each field as its own trace</li>
<li>in RTLIL output, it is useful to include a wire for each field (in particular, for CXXRTL simulation purposes)</li>
</ul>
<p>Likewise, <code>lib.enum.Enum</code>-typed signals benefit from being marked as enum-typed in RTLIL output.</p>
<p>Currently, both of the above usecases are covered by the private <code>ShapeCastable._value_repr</code> interface. This interface has been added in a rush for the Amaranth 0.4 release as a stopgap measure, to ensure switching from <code>hdl.rec</code> to <code>lib.data</code> doesn't cause a functionality regression (<a href="https://github.com/amaranth-lang/amaranth/issues/790">amaranth-lang/amaranth#790</a>). Such forbidden coupling between <code>lib</code> and <code>hdl</code> via private interfaces is frowned upon, and the time has come to atone for our sins and create a public interface that can be used for all sorts of aggregate and enumerated data types.</p>
<p>Since both needs relate to presentation of shape-castables, we propose piggybacking the functionality on top of <code>ShapeCastable.format</code> machinery. At the same time, we propose implementing formatting for <code>lib.data</code> and <code>lib.enum</code>.</p>
<h2 id="guide-level-explanation-37"><a class="header" href="#guide-level-explanation-37">Guide-level explanation</a></h2>
<p>Shape-castables implementing enumerated types can return a <code>Format.Enum</code> instance instead of a <code>Format</code> from their <code>format</code> method:</p>
<pre><code class="language-py">class MyEnum(ShapeCastable):
    ...

    def format(self, obj, spec):
        assert spec == &quot;&quot;
        return Format.Enum(Value.cast(obj), {
            0: &quot;ABC&quot;,
            1: &quot;DEF&quot;,
            2: &quot;GHI&quot;,
        })
</code></pre>
<p>For formatting purposes, this is equivalent to:</p>
<pre><code class="language-py">class MyEnum(ShapeCastable):
    ...

    def format(self, obj, spec):
        assert spec == &quot;&quot;
        return Format(
            &quot;{:s}&quot;,
            Mux(Value.cast(obj) == 0, int.from_bytes(&quot;ABC&quot;.encode(), &quot;little&quot;),
            Mux(Value.cast(obj) == 1, int.from_bytes(&quot;DEF&quot;.encode(), &quot;little&quot;),
            Mux(Value.cast(obj) == 2, int.from_bytes(&quot;GHI&quot;.encode(), &quot;little&quot;),
            int.from_bytes(&quot;[unknown]&quot;.encode(), &quot;little&quot;)
            )))
        )
</code></pre>
<p>with the added benefit that any <code>MyEnum</code>-shaped signals will be automatically marked as enums in RTLIL output.</p>
<p>Likewise, shape-castables implementing aggregate types can return a <code>Format.Struct</code> instance instead of a <code>Format</code>:</p>
<pre><code class="language-py">class MyStruct(ShapeCastable):
    ...

    def format(self, obj, spec):
        assert spec == &quot;&quot;
        return Format.Struct({
            # Assume obj.a, obj.b, obj.c are accessors that return the struct fields as ValueLike.
            &quot;a&quot;: Format(&quot;{}&quot;, obj.a),
            &quot;b&quot;: Format(&quot;{}&quot;, obj.b),
            &quot;c&quot;: Format(&quot;{}&quot;, obj.c),
        })
</code></pre>
<p>For formatting purposes, this is equivalent to:</p>
<pre><code class="language-py">class MyStruct(ShapeCastable):
    ...

    def format(self, obj, spec):
        assert spec == &quot;&quot;
        return Format(&quot;{{a: {}, b: {}, c: {}}}&quot;, obj.a, obj.b, obj.c)
</code></pre>
<p>with the added benefit that any <code>MyStruct</code>-shaped signal will automatically have per-field traces included in VCD output and per-field wires included in RTLIL output.</p>
<p>Implementations of <code>format</code> are added as appropriate to <code>lib.enum</code> and <code>lib.data</code>, making use of the above features.</p>
<h2 id="reference-level-explanation-37"><a class="header" href="#reference-level-explanation-37">Reference-level explanation</a></h2>
<p>Three new classes are added:</p>
<ul>
<li><code>amaranth.hdl.Format.Enum(value: Value, /, variants: EnumType | dict[int, str])</code></li>
<li><code>amaranth.hdl.Format.Struct(value: Value, /, fields: dict[str, Format])</code></li>
<li><code>amaranth.hdl.Format.Array(value: Value, /, fields: list[Format])</code></li>
</ul>
<p>Instances of these classes can be used wherever a <code>Format</code> can be used:</p>
<ul>
<li>as an argument to <code>Print</code>, <code>Assert</code>, ...</li>
<li>included within another <code>Format</code> via substitution</li>
<li>returned from <code>ShapeCastable.format</code></li>
<li>as a field format within <code>Format.Struct</code> or <code>Format.Array</code></li>
</ul>
<p>When used for formatting:</p>
<ul>
<li><code>Format.Enum</code> will display as whichever string corresponds to current value of <code>value</code>, or as <code>&quot;[unknown]&quot;</code> otherwise.</li>
<li><code>Format.Struct</code> will display as <code>&quot;{a: &lt;formatted field a&gt;, b: &lt;formatted field b&gt;}&quot;</code>.</li>
<li><code>Format.Array</code> will display as <code>&quot;[&lt;formatted field 0&gt;, &lt;formatted field 1&gt;]&quot;</code></li>
</ul>
<p>Whenever a signal is created with a shape-castable as its shape, its <code>format</code> method is called with <code>spec=&quot;&quot;</code> and the result is stashed away.</p>
<p>VCD output is done as follows:</p>
<ol>
<li>When a signal or field's format is just <code>Format(&quot;{}&quot;, value)</code>: value is emitted as a bitvector to VCD.</li>
<li>Otherwise, when a signal or field's custom format is not <code>Format.Struct</code> nor <code>Format.Array</code>: the format is evaluated every time the value changes, and the result is emitted as a string to VCD</li>
<li>When the custom format is <code>Format.Struct</code> or <code>Format.Array</code>:
<ul>
<li>the <code>value</code> as a whole is emitted as a bitvector</li>
<li>each field is emitted recursively (as a separate trace, perhaps with subtraces)</li>
</ul>
</li>
</ol>
<p>RTLIL output is done as follows:</p>
<ol>
<li>When a signal or field's format is a plain <code>Format</code> and contains exactly one format specifier: a wire is created and assigned with the specifier's value.</li>
<li>When a signal or field's format is a plain <code>Format</code> that doesn't conform to the above rule: no wire is created.</li>
<li>When a signal or field's format is a <code>Format.Enum</code>: a wire is created and assigned with the format's <code>value</code>. RTLIL attributes are emitted on it, describing the enumeration values.</li>
<li>When a signal or field's format is a <code>Format.Struct</code> or <code>Format.Array</code>: a wire is created and assigned with the format's <code>value</code>, representing the struct as a whole. For every field of the aggregate, the rules are applied recursively.</li>
</ol>
<h2 id="drawbacks-45"><a class="header" href="#drawbacks-45">Drawbacks</a></h2>
<p>More language complexity.</p>
<p>A shape-castable using <code>Format.Struct</code> to mark itself as aggregate is forced to use the fixed <code>Format.Struct</code> display when formatted.</p>
<h2 id="rationale-and-alternatives-44"><a class="header" href="#rationale-and-alternatives-44">Rationale and alternatives</a></h2>
<p>This design ties together concerns of formatting with structural description. An alternative would be to have separate hooks for those, like the current <code>_value_repr</code> interface.</p>
<h2 id="prior-art-40"><a class="header" href="#prior-art-40">Prior art</a></h2>
<p>None.</p>
<h2 id="unresolved-questions-43"><a class="header" href="#unresolved-questions-43">Unresolved questions</a></h2>
<p>None.</p>
<h2 id="future-possibilities-44"><a class="header" href="#future-possibilities-44">Future possibilities</a></h2>
<p>The current <code>decoder</code> interface on <code>Signal</code> could be deprecated and retired.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2024-07-29</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/66">amaranth-lang/rfcs#66</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth/issues/1469">amaranth-lang/amaranth#0000</a></li>
</ul>
<h1 id="simulation-time"><a class="header" href="#simulation-time">Simulation time</a></h1>
<h2 id="summary-47"><a class="header" href="#summary-47">Summary</a></h2>
<p>Add a type for representing time durations (including clock periods) and simulator methods to query the elapsed time.</p>
<h2 id="motivation-47"><a class="header" href="#motivation-47">Motivation</a></h2>
<p>In <a href="0036-async-testbench-functions.html">RFC #36</a>, there were a plan to introduce a <code>.time()</code> method to query the current simulation time, but it got deferred due to the lack of a suitable return type.</p>
<p>Internally simulation time is an integer number of femtoseconds, but exposing that directly is not ergonomic and making it a <code>float</code> of seconds sacrifices precision the longer a simulation runs.</p>
<p>Also, to quote @whitequark: Time is not a number.</p>
<h2 id="guide--and-reference-level-explanation-1"><a class="header" href="#guide--and-reference-level-explanation-1">Guide- and reference-level explanation</a></h2>
<p>A new type <code>Period</code> is introduced.
It is exported from <code>amaranth.hdl</code> and also re-exported from <code>amaranth.sim</code>.
It is immutable and has a constructor accepting at most one named argument, giving the following valid forms of construction:</p>
<ul>
<li><code>Period()</code>
<ul>
<li>Constructs a zero period.</li>
</ul>
</li>
<li><code>Period(s: numbers.Real)</code></li>
<li><code>Period(ms: numbers.Real)</code></li>
<li><code>Period(us: numbers.Real)</code></li>
<li><code>Period(ns: numbers.Real)</code></li>
<li><code>Period(ps: numbers.Real)</code></li>
<li><code>Period(fs: numbers.Real)</code>
<ul>
<li>The argument will be scaled according to its SI prefix and used to calculate the closest integer femtosecond representation.</li>
</ul>
</li>
<li><code>Period(Hz: numbers.Real)</code></li>
<li><code>Period(kHz: numbers.Real)</code></li>
<li><code>Period(MHz: numbers.Real)</code></li>
<li><code>Period(GHz: numbers.Real)</code>
<ul>
<li>The argument will be scaled according to its SI prefix and its reciprocal used to calculate the closest integer femtosecond representation.</li>
<li>A value of zero will raise <code>ZeroDivisionError</code>.</li>
<li>A negative value will raise <code>ValueError</code>.</li>
</ul>
</li>
</ul>
<p>To convert it back to a number, the following properties are available:</p>
<ul>
<li><code>.seconds -&gt; float</code></li>
<li><code>.milliseconds -&gt; float</code></li>
<li><code>.microseconds -&gt; float</code></li>
<li><code>.nanoseconds -&gt; float</code></li>
<li><code>.picoseconds -&gt; float</code></li>
<li><code>.femtoseconds -&gt; int</code></li>
</ul>
<p>To calculate the reciprocal frequency, the following properties are available:</p>
<ul>
<li><code>.hertz -&gt; float</code></li>
<li><code>.kilohertz -&gt; float</code></li>
<li><code>.megahertz -&gt; float</code></li>
<li><code>.gigahertz -&gt; float</code>
<ul>
<li>Accessing these properties when the period is zero will raise <code>ZeroDivisionError</code>.</li>
<li>Accessing these properties when the period is negative will raise <code>ValueError</code>.</li>
</ul>
</li>
</ul>
<p>The following operators are defined:</p>
<ul>
<li><code>.__lt__(other: Period) -&gt; bool</code></li>
<li><code>.__le__(other: Period) -&gt; bool</code></li>
<li><code>.__eq__(other: Period) -&gt; bool</code></li>
<li><code>.__ne__(other: Period) -&gt; bool</code></li>
<li><code>.__gt__(other: Period) -&gt; bool</code></li>
<li><code>.__ge__(other: Period) -&gt; bool</code></li>
<li><code>.__hash__() -&gt; int</code></li>
<li><code>.__bool__() -&gt; bool</code></li>
<li><code>.__neg__() -&gt; Period</code></li>
<li><code>.__pos__() -&gt; Period</code></li>
<li><code>.__abs__() -&gt; Period</code></li>
<li><code>.__add__(other: Period) -&gt; Period</code></li>
<li><code>.__sub__(other: Period) -&gt; Period</code></li>
<li><code>.__mul__(other: numbers.Real) -&gt; Period</code></li>
<li><code>.__rmul__(other: numbers.Real) -&gt; Period</code></li>
<li><code>.__truediv__(other: numbers.Real) -&gt; Period</code></li>
<li><code>.__truediv__(other: Period) -&gt; float</code></li>
<li><code>.__floordiv__(other: Period) -&gt; int</code></li>
<li><code>.__mod__(other: Period) -&gt; Period</code>
<ul>
<li>Operators on <code>Period</code>s are performed on the underlying femtosecond values.</li>
<li>Operators involving <code>numbers.Real</code> operands have the result rounded back to the closest integer femtosecond representation.</li>
<li>Operators given unsupported operand combinations will return <code>NotImplemented</code>.</li>
</ul>
</li>
<li><code>.__str__() -&gt; str</code>
<ul>
<li>Equivalent to <code>.__format__(&quot;&quot;)</code></li>
</ul>
</li>
<li><code>.__format__(format_spec: str) -&gt; str</code>
<ul>
<li>The format specifier format is <code>[width][.precision][ ][unit]</code>.</li>
<li>An invalid format specifier raises <code>ValueError</code>.</li>
<li>If <code>width</code> is specified, the string is left-padded with space to at least the requested width.</li>
<li>If <code>precision</code> is specified, the requested number of decimal digits will be emitted.
Otherwise, duration units will emit as many digits required for an exact result, while frequency units will defer to default <code>float</code> formatting.</li>
<li>If a space is present in the format specifier, the formatted string will have a space between the number and the unit.</li>
<li><code>unit</code> can be specified as any of the argument names accepted by the constructor.
If a unit is not specified, the largest duration unit that has a nonzero integer part is used.
Formatting frequency units have the same restrictions and exception behavior as accessing frequency properties.</li>
</ul>
</li>
</ul>
<p><code>SimulatorContext</code> have an <code>.elapsed_time() -&gt; Period</code> method added that returns the elapsed time since start of simulation.</p>
<p>These methods that has a <code>period</code> argument currently taking seconds as a <code>float</code> are updated to take a <code>Period</code>:</p>
<ul>
<li><code>Simulator.add_clock()</code></li>
<li><code>SimulatorContext.delay()</code></li>
</ul>
<p>These methods that has a <code>frequency</code> argument currently taking Hz as a <code>float</code> are updated to take a <code>Period</code>:</p>
<ul>
<li><code>ResourceManager.add_clock_constraint()</code></li>
<li><code>Clock.__init__()</code></li>
</ul>
<p>The ability to pass seconds or Hz directly as a <code>float</code> is deprecated and removed in a future Amaranth version.</p>
<p>The <code>Clock.period</code> property is updated to return a <code>Period</code> and the <code>Clock.frequency</code> property is deprecated.</p>
<p>Consequently, <code>Platform.default_clk_frequency()</code> is also deprecated and replaced with a new method <code>Platform.default_clk_period() -&gt; Period</code>.</p>
<h2 id="drawbacks-46"><a class="header" href="#drawbacks-46">Drawbacks</a></h2>
<ul>
<li>Deprecating being able to pass seconds or Hz directly as a <code>float</code> creates churn.</li>
</ul>
<h2 id="rationale-and-alternatives-45"><a class="header" href="#rationale-and-alternatives-45">Rationale and alternatives</a></h2>
<ul>
<li>
<p><code>.add_clock()</code> is usually passed the reciprocal of a frequency, so being able to construct a <code>Period</code> from a frequency instead of a duration is useful.</p>
<ul>
<li>We could add a separate <code>Frequency</code> type, but in practice it would likely almost exclusively be used to calculate the reciprocal <code>Period</code>.</li>
</ul>
</li>
<li>
<p>Accepting a <code>numbers.Real</code> when we're converting from a number lets us pass in any standard suitable number type.</p>
</li>
<li>
<p>The supported set of operators are the ones that have meaningful and useful semantics:</p>
<ul>
<li>Comparing, adding and subtracting time periods makes sense.</li>
<li>Multiplying a time period with or dividing it by a real number scales the time period.</li>
<li>Dividing time periods gives the ratio between them.</li>
<li>Modulo of time periods is the remainder and thus still a time period.
Potentially useful to calculate the phase offset between a timestamp and a clock period.</li>
<li>Reflected operators that only accept <code>Period</code> operands are redundant and omitted.</li>
</ul>
</li>
<li>
<p><code>.elapsed_time()</code> is only available from within a testbench/process, where it is well defined.</p>
</li>
<li>
<p>Instead of named constructor arguments, we could use a classmethod for each SI prefix.
This was proposed in an earlier revision of this RFC.</p>
</li>
<li>
<p>Instead of returning <code>float</code>, we could return <code>fractions.Fraction</code> to ensure no precision loss when the number of femtoseconds is larger than the <code>float</code> significand.
This was proposed in an earlier revision of this RFC.</p>
<ul>
<li>Rounding to integer femtoseconds is already lossy and a further precision loss from converting to a <code>float</code> is negligible in most real world use cases.
For any applications requiring an exact conversion of a <code>Period</code>, the <code>.femtoseconds</code> property is always exact.</li>
</ul>
</li>
</ul>
<h2 id="prior-art-41"><a class="header" href="#prior-art-41">Prior art</a></h2>
<p>None.</p>
<h2 id="unresolved-questions-44"><a class="header" href="#unresolved-questions-44">Unresolved questions</a></h2>
<p>None.</p>
<h2 id="future-possibilities-45"><a class="header" href="#future-possibilities-45">Future possibilities</a></h2>
<p>None.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2024-07-01</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/69">amaranth-lang/rfcs#69</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth/issues/1446">amaranth-lang/amaranth#1446</a></li>
</ul>
<h1 id="add-a-libioportlike-object-usable-in-simulation"><a class="header" href="#add-a-libioportlike-object-usable-in-simulation">Add a <code>lib.io.PortLike</code> object usable in simulation</a></h1>
<h2 id="summary-48"><a class="header" href="#summary-48">Summary</a></h2>
<p>A new library I/O port object <code>lib.io.SimulationPort</code> is introduced that can be used to simulate <code>lib.io.Buffer</code> and <code>lib.io.FFBuffer</code> components.</p>
<h2 id="motivation-48"><a class="header" href="#motivation-48">Motivation</a></h2>
<p>End-to-end verification of I/O components requires simulating <code>lib.io.Buffer</code>, <code>lib.io.FFBuffer</code>, or <code>lib.io.DDRBuffer</code> objects, which is currently not possible because all defined library I/O ports (<code>lib.io.SingleEndedPort</code>, <code>lib.io.DifferentialPort</code>) require the use of unsimulatable core I/O values. Simulating these buffers can be done by adding a new library I/O port object with separate <code>i</code>, <code>o</code>, <code>oe</code> parts represented by normal <code>Signal</code>s, and modifying the lowering of <code>lib.io</code> buffer components to drive the individual parts. Simulation models could then be written using code similar to (for SPI):</p>
<pre><code class="language-python">await ctx.set(cipo_port.o, cipo_value)
_, copi_value = await ctx.posedge(sck_port.i).sample(copi_port.i)
</code></pre>
<p>This functionality is one of the last pieces required to build a library of reusable I/O interfaces, and the need for it became apparent while writing reusable I/O blocks for the Glasgow project.</p>
<h2 id="guide-level-explanation-38"><a class="header" href="#guide-level-explanation-38">Guide-level explanation</a></h2>
<p>Let's consider an I/O component, such as below, which takes several ports as its constructor argument:</p>
<pre><code class="language-python">class SPIController(wiring.Component):
    o_data: stream.Signature(8)
    i_data: stream.Signature(8)

    def __init__(self, sck_port, copi_port, cipo_port):
        self._sck_port  = sck_port
        self._copi_port = copi_port
        self._cipo_port = cipo_port

        super().__init__()

    def elaborate(self, platform):
        m = Module()

        m.submodules.sck  = sck_buffer  = io.FFBuffer(&quot;o&quot;, self._sck_port)
        m.submodules.copi = copi_buffer = io.FFBuffer(&quot;o&quot;, self._copi_port)
        m.submodules.cipo = cipo_buffer = io.FFBuffer(&quot;i&quot;, self._cipo_port)

        # ... wire it up to self.[io]_data...

        return m
</code></pre>
<p>To simulate such a component, instantiate <code>lib.io.SimulationPort</code> objects for each of the ports, and use their <code>.o</code>, <code>.oe</code>, and <code>.i</code> signals to verify the functionality:</p>
<pre><code class="language-python">sck_port  = io.SimulationPort(&quot;o&quot;, 1)
copi_port = io.SimulationPort(&quot;o&quot;, 1)
cipo_port = io.SimulationPort(&quot;i&quot;, 1)

dut = SPIController(sck_port, copi_port, cipo_port)

async def testbench_peripheral(ctx):
    &quot;&quot;&quot;Simulates behavior of an SPI peripheral. Simplified for clarity: ignores chip select.&quot;&quot;&quot;
    for copi_fixture, cipo_fixture in zip([0,1,0,1,0,1,0,1], [1,0,1,0,1,0,1,0]):
        await ctx.negedge(sck_port.o)
        ctx.set(cipo_port.i, cipo_fixture)
        _, copi_driven, copi_value = await ctx.posedge(sck_port.o).sample(copi_port.oe, copi_port.o)
        assert copi_driven == 0b1 and copi_value == copi_fixture

async def testbench_controller(ctx):
    &quot;&quot;&quot;Issues commands to the controller.&quot;&quot;&quot;
    await stream_put(ctx, dut.o_data, 0x55)
    assert (await stream_get(ctx, dut.i_data)) == 0xAA

sim = Simulator(dut)
sim.add_clock(1e-6)
sim.add_testbench(testbench_peripheral)
sim.add_testbench(testbench_controller)
sim.run()
</code></pre>
<p>Note that the peripheral testbench not only checks that the right values are being output by the I/O component, but that the port is driven (not tristated) at the time when values are sampled.</p>
<p>Note also that e.g. <code>copi_port.oe</code> is a multi-bit signal, with the same width as the port itself. This is unlike the <code>lib.io</code> buffers, whose <code>oe</code> port member is always 1-bit wide. This means that for multi-wire ports that are always fully driven or fully undriven, it is necessary to compare them with <code>0b00..0</code> or <code>0b11..1</code>, according to the width of the port.</p>
<h2 id="reference-level-explanation-38"><a class="header" href="#reference-level-explanation-38">Reference-level explanation</a></h2>
<p>The <code>amaranth.lib.io</code> module is expanded with a new subclass of <code>PortLike</code>, <code>SimulationPort(direction, width, *, invert=False)</code>:</p>
<ul>
<li><code>i</code>, <code>o</code>, <code>oe</code> are read-only properties each containing a new <code>Signal(width)</code>;</li>
<li><code>invert</code> is a property equal to the <code>invert</code> parameter normalized to a tuple of <code>width</code> elements;</li>
<li><code>direction</code> is a property equal to the <code>direction</code> parameter normalized to <code>Direction</code> enum;</li>
<li><code>len(port)</code> returns <code>width</code>;</li>
<li><code>port[...]</code> returns a new <code>SimulationPort</code> whose <code>i</code>, <code>o</code>, <code>oe</code> properties are slices of <code>port.i</code>, <code>port.o</code>, <code>port.oe</code> respectively;</li>
<li><code>~port</code> returns a new <code>SimulationPort</code> whose <code>i</code>, <code>o</code>, <code>oe</code> properties are the same as for <code>port</code> and the <code>invert</code> property has each value inverted;</li>
<li><code>port + other</code>, where <code>other</code> is a <code>SimulationPort</code>, returns a new <code>SimulationPort</code> whose <code>i</code>, <code>o</code>, <code>oe</code> properties are concatenations of the respective properties of <code>port</code> and <code>other</code>.</li>
</ul>
<p>Since this is a third <code>PortLike</code> with a compatible <code>__add__</code> implementation, and it is weird to have slicing but not concatenation, the <code>__add__</code> method is added to the <code>PortLike</code> signature, with a deprecation warning in 0.5.1 and a hard requirement in 0.6.0.</p>
<p>The <code>amaranth.lib.io.Buffer</code> component is changed to accept <code>SimulationPort</code>s and performs the following connections (with the direction checks omitted for clarity):</p>
<pre><code class="language-python">m.d.comb += [
    buffer.i.eq(Cat(Mux(oe, o, i) for oe, o, i in zip(port.oe, port.o, port.i))),
    port.o.eq(buffer.o),
    port.oe.eq(buffer.oe.replicate(len(port))),
]
</code></pre>
<p>The <code>amaranth.lib.io.FFBuffer</code> component is changed to accept <code>SimulationPort</code>s and performs the following connections (with the direction checks omitted for clarity):</p>
<pre><code class="language-python">m.d[buffer.i_domain] += [
    buffer.i.eq(Cat(Mux(oe, o, i) for oe, o, i in zip(port.oe, port.o, port.i))),
]
m.d[buffer.o_domain] += [
    port.o.eq(buffer.o),
    port.oe.eq(buffer.oe.replicate(len(port))),
]
</code></pre>
<p>The <code>amaranth.lib.io.DDRBuffer</code> component is not changed.</p>
<p>None of the <code>get_io_buffer</code> functions in the vendor platforms are changed. Thus, <code>SimulationPort</code> is not usable with any vendor platform that implements <code>get_io_buffer</code>.</p>
<p>To improve the health of the Amaranth standard I/O library (which will make heavy use of simulation port objects), the changes are back-ported to the 0.5.x release branch.</p>
<h2 id="drawbacks-47"><a class="header" href="#drawbacks-47">Drawbacks</a></h2>
<ul>
<li>Bigger API surface.</li>
<li>Another concept to keep track of.</li>
</ul>
<h2 id="rationale-and-alternatives-46"><a class="header" href="#rationale-and-alternatives-46">Rationale and alternatives</a></h2>
<p>Alternatives:</p>
<ul>
<li>The signature of the <code>SimulationPort()</code> constructor is designed to closely resemble that of <code>SingleEndedPort()</code> and <code>DifferentialPort()</code>. However, <code>SimulationPort()</code> is intended to be only constructed by the designer, and the latter two almost never are. Is it a good idea to make direction optional, in this case? Specifying the direction provides additional checks that are valuable for verification.
<ul>
<li>Alternative #0: <code>SimulationPort(width, *, invert=False, direction=Direction.Bidir)</code>. This alternative is a near-exact match to the other port-like objects, with the exception of <code>io</code> replaced by <code>width</code>.</li>
<li>Alternative #1: <code>SimulationPort(width, *, invert=False, direction)</code>. This alternative minimally changes the signature, but requires lengthy <code>direction=</code> at every call site. <strong>Currently in the RFC text.</strong></li>
<li>Alternative #2: <code>SimulationPort(width, direction, *, invert=False)</code>. This alternative is a slightly less minimal change, but does not match the ordering of arguments of signature of <code>Buffer(direction, port)</code>.</li>
<li>Alternative #3: <code>SimulationPort(direction, width, *, invert=False)</code>. This alternative differs significantly from <code>SingleEndedPort()</code> etc, but matches <code>Buffer()</code> most closely.</li>
</ul>
</li>
<li>It would be possible to make <code>SimulationPort</code> an interface object. Although the opportunities for connecting it are limited (since the signals are only synchronized to each other and not to any clock domains in the design), one can foresee the addition of a component that implements end-to-end or multi-drop buses using simulation-compatible logic, for example, to simulate multiple Amaranth components accessing a common SPI or I2C bus. In this context <code>connect</code> would be valuable.
<ul>
<li>This functionality could be prototyped out-of-tree (by wrapping <code>SimulationPort</code> or simply setting its <code>signature</code> property) and added upstream later if it proves to be useful.</li>
</ul>
</li>
<li>It would be possible to add <code>o_init</code>, <code>i_init</code>, <code>oe_init</code> to the signature for a minor usability improvement in cases where the port is never driven in simulation, but the benefit seems low and the signature becomes much more cluttered.
<ul>
<li>It is no longer possible since Amaranth 0.5 to directly set <code>.init</code> attribute of signals, so without these arguments the initial value will always be 0.</li>
</ul>
</li>
</ul>
<p>Rejected alternatives:</p>
<ul>
<li><del>Multi-bit <code>oe</code> signal is a radical departure from the rest of Amaranth, where <code>oe</code> is always single-bit. However, note the proposed RFC #68, which suggests making <code>oe</code> optionally multi-bit for <code>io.Buffer</code> etc.</del>
<ul>
<li><del>It would be possible to make <code>oe</code> a single-bit signal and to forbid slicing of <code>SimulationPort</code> objects. However, the <code>PortLike</code> interface does not currently allow this, and it would have to be changed, with generic code having to be aware of this new error.</del></li>
<li><del>It would also be possible to make <code>oe</code> a choice of multi-bit or single-bit signal during construction, similar to RFC #68.</del></li>
<li>Without multibit <code>oe</code> it is not possible to concatenate ports.</li>
</ul>
</li>
</ul>
<h2 id="prior-art-42"><a class="header" href="#prior-art-42">Prior art</a></h2>
<p>We have previously had, and deprecated, the <code>amaranth.lib.io.Pin</code> object, which is essentially the same triple of <code>i</code>, <code>o</code>, <code>oe</code>. However, in terms of its intended use (notwithstanding how it was actually used), the <code>Pin</code> object was closest to the interface created by <code>io.Buffer.Signature.create()</code>. The newly introduced <code>SimulationPort</code> is intended to represent data on the other side of the buffer than <code>Pin</code> does.</p>
<h2 id="resolved-questions-1"><a class="header" href="#resolved-questions-1">Resolved questions</a></h2>
<ul>
<li><del>What should the signature of <code>SimulationPort()</code> be?</del>
<ul>
<li>Alternative #3 (matching <code>io.Buffer</code>, etc) was decided.</li>
</ul>
</li>
</ul>
<h2 id="future-possibilities-46"><a class="header" href="#future-possibilities-46">Future possibilities</a></h2>
<ul>
<li>Add <code>DDRBuffer</code> support by using <code>port.o.eq(Mux(ClockSignal(), self.o[1], self.o[0]))</code>.
<ul>
<li>It is not yet clear if this can be safely used, or should be used, in simulations.</li>
</ul>
</li>
<li>Make <code>SimulationPort</code> an interface object.</li>
<li>Add a <code>EndToEndBus</code> (naming TBD) class connecting pairs of ports to each other and ensuring that no wire is driven twice.</li>
<li>Add a <code>OpenDrainBus</code> (naming TBD) class connecting a set of ports to each other and providing a &quot;pull-up resistor&quot; equivalent functionality.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2024-06-28</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/70">amaranth-lang/rfcs#70</a></li>
<li>Amaranth SoC Issue: <a href="https://github.com/amaranth-lang/amaranth-soc/issues/93">amaranth-lang/amaranth-soc#93</a></li>
</ul>
<h1 id="unify-the-naming-of-memorymap-resources-and-windows"><a class="header" href="#unify-the-naming-of-memorymap-resources-and-windows">Unify the naming of <code>MemoryMap</code> resources and windows</a></h1>
<h2 id="summary-49"><a class="header" href="#summary-49">Summary</a></h2>
<ul>
<li>Use a <code>MemoryMap.Name</code> class to represent resource and window names.</li>
<li>Assign window names in <code>MemoryMap.add_window()</code> instead of <code>MemoryMap.__init__()</code>.</li>
</ul>
<h2 id="motivation-49"><a class="header" href="#motivation-49">Motivation</a></h2>
<p>In a <code>MemoryMap</code>, resources (e.g. registers of a peripheral) and windows (nested memory maps) are added with similar methods: <code>MemoryMap.add_resource()</code> and <code>.add_window()</code>.</p>
<p>However, their names are handled differently:</p>
<ul>
<li>a resource name is a tuple of strings, assigned as a parameter to <code>MemoryMap.add_resource()</code>.</li>
<li>a window name is a string, assigned at the creation of the window itself (as a parameter to <code>MemoryMap.__init__()</code>).</li>
</ul>
<p>These differences add needless complexity to the API:</p>
<ul>
<li>the name of a window is only relevant from the context of the memory map to which it is added.</li>
<li>window names may also benefit from being split into tuples, in order to let consumers of the memory map (such as a BSP generator) decide their format.</li>
</ul>
<p>Additionally, support for integers in resource and window names is needed to represent indices. A BSP generator may choose to format them in a specific way (e.g. <code>&quot;foo[1]&quot;</code>).</p>
<h2 id="guide-level-explanation-39"><a class="header" href="#guide-level-explanation-39">Guide-level explanation</a></h2>
<p>Resource and window names are instances of <code>MemoryMap.Name</code>, a subclass of <code>tuple</code> which can only contain non-empty strings and non-negative integers.</p>
<p>Some examples:</p>
<pre><code class="language-python3">&gt;&gt;&gt; MemoryMap.Name((&quot;rx&quot;, &quot;status&quot;))
Name('rx', 'status')
&gt;&gt;&gt; MemoryMap.Name((&quot;uart&quot;, 0))
Name('uart', 0)
&gt;&gt;&gt; MemoryMap.Name(MemoryMap.Name((&quot;uart&quot;, 0))
Name('uart', 0)
&gt;&gt;&gt; MemoryMap.Name(&quot;foo&quot;)
Name('foo',)
</code></pre>
<h3 id="assigning-resource-names"><a class="header" href="#assigning-resource-names">Assigning resource names</a></h3>
<p>The name of a resource is given by the <code>name</code> parameter of <code>MemoryMap.add_resource()</code>. For the sake of brevity, users can pass a tuple which is implicitly cast to a <code>MemoryMap.Name</code>.</p>
<p>This example shows how names are assigned to the registers of an UART peripheral:</p>
<pre><code class="language-python3">from amaranth import *
from amaranth.lib import wiring
from amaranth.lib.wiring import In, Out

from amaranth_soc import csr
from amaranth_soc.memory import MemoryMap


class UART(wiring.Component):
    class RxConfig(csr.Register, access=&quot;rw&quot;):
        enable: csr.Field(csr.action.RW, 1)

    class RxStatus(csr.Register, access=&quot;rw&quot;):
        ready: csr.Field(csr.action.R,    1)
        error: csr.Field(csr.action.RW1C, 1)

    class RxData(csr.Register, access=&quot;r&quot;):
        def __init__(self):
            super().__init__(csr.Field(csr.action.R, 8))

    csr_bus: In(csr.Signature(addr_width=10, data_width=32))

    def __init__(self):
        super().__init__()

        memory_map = MemoryMap(addr_width=10, data_width=32)
        memory_map.add_resource(self.RxConfig(), size=1, name=(&quot;rx&quot;, &quot;config&quot;))
        memory_map.add_resource(self.RxStatus(), size=1, name=MemoryMap.Name((&quot;rx&quot;, &quot;status&quot;)))
        memory_map.add_resource(self.RxData(),   size=1, name=(&quot;rx&quot;, &quot;data&quot;))
        memory_map.freeze()

        self.csr_bus.memory_map = memory_map

    def elaborate(self, platform):
        m = Module()
        # ...
        return m
</code></pre>
<h3 id="assigning-window-names"><a class="header" href="#assigning-window-names">Assigning window names</a></h3>
<p>Similarly, the name of a window is given by the <code>name</code> parameter of <code>MemoryMap.add_window()</code>. Unlike resource names, window names are optional.</p>
<p>This example shows how names are assigned to two UART peripherals, as their memory maps are added as windows to a bus decoder memory map:</p>
<pre><code class="language-python3">class Decoder(wiring.Component):
    csr_bus: In(csr.Signature(addr_width=20, data_width=32))

    def __init__(self):
        super().__init__()
        self._subs = dict()
        self.csr_bus.memory_map = MemoryMap(addr_width=20, data_width=32)

    def add(self, sub_bus, *, name=None, addr=None):
        self._subs[sub_bus.memory_map] = sub_bus
        return self.csr_bus.memory_map.add_window(sub_bus.memory_map, name=name, addr=addr)

    def elaborate(self, platform):
        m = Module()

        with m.Switch(self.csr_bus.addr):
            for window, name, (pattern, ratio) in self.csr_bus.memory_map.window_patterns():
                sub_bus = self._subs[window]
                with m.Case(pattern):
                    pass # ... drive the subordinate bus interface

        return m


uart_0 = UART()
uart_1 = UART()

decoder = Decoder()
decoder.add(uart_0.csr_bus, name=(&quot;uart&quot;, 0))
decoder.add(uart_1.csr_bus, name=MemoryMap.Name((&quot;uart&quot;, 1)))
</code></pre>
<p>In a <code>MemoryMap</code> hierarchy, each resource is identified by a path. The path of a resource is a tuple ending with its name, preceded by the name of each window that contains it:</p>
<pre><code class="language-python3">&gt;&gt;&gt; for res_info in decoder.csr_bus.memory_map.all_resources():
...     print(res_info.path)
(Name('uart', 0), Name('rx', 'config'))
(Name('uart', 0), Name('rx', 'status'))
(Name('uart', 0), Name('rx', 'data'))
(Name('uart', 1), Name('rx', 'config'))
(Name('uart', 1), Name('rx', 'status'))
(Name('uart', 1), Name('rx', 'data'))
</code></pre>
<h2 id="reference-level-explanation-39"><a class="header" href="#reference-level-explanation-39">Reference-level explanation</a></h2>
<p>The following changes to the <code>amaranth_soc.memory</code> module are made:</p>
<ul>
<li>
<p>Add a <code>MemoryMap.Name(name, /)</code> class. It is a subclass of <code>tuple</code>, where:</p>
<ul>
<li><code>name</code> must either be a string or a tuple of strings and non-negative integers. If <code>name</code> is a string, it is implicitly converted to <code>(name,)</code>.</li>
</ul>
</li>
<li>
<p>The following changes to <code>MemoryMap</code> are made:</p>
<ul>
<li>The optional <code>name</code> parameter of <code>MemoryMap()</code> is removed.</li>
<li>The <code>MemoryMap.name</code> property is removed.</li>
<li>The <code>name</code> parameter of <code>MemoryMap.add_resource()</code> must be a <code>MemoryMap.Name</code>.</li>
<li>An optional <code>name</code> parameter is added to <code>MemoryMap.add_window()</code>, which must be a <code>MemoryMap.Name</code>.</li>
<li>The yield values of <code>MemoryMap.windows()</code> are changed to <code>window, name, (start, end, ratio)</code>.</li>
<li>The yield values of <code>MemoryMap.window_patterns()</code> are changed to <code>window, name, (pattern, ratio)</code>.</li>
</ul>
</li>
<li>
<p>The following changes to <code>ResourceInfo</code> are made:</p>
<ul>
<li>The <code>path</code> parameter of <code>ResourceInfo()</code> must be a tuple of <code>MemoryMap.Name</code> objects.</li>
</ul>
</li>
</ul>
<p>As a consequence of this proposal, the following changes are made to other modules:</p>
<ul>
<li>
<p><code>amaranth_soc.csr.bus</code> and <code>amaranth_soc.wishbone.bus</code>:</p>
<ul>
<li>The optional <code>name</code> parameter of <code>Decoder()</code> is moved to <code>Decoder.add()</code>.</li>
</ul>
</li>
<li>
<p><code>amaranth_soc.csr.reg</code>:</p>
<ul>
<li>The optional <code>name</code> parameter of <code>Builder()</code> is removed.</li>
</ul>
</li>
<li>
<p><code>amaranth_soc.csr.wishbone</code>:</p>
<ul>
<li>The optional <code>name</code> parameter of <code>WishboneCSRBridge()</code> is assigned to <code>csr_bus.memory_map</code> (instead of <code>wb_bus.memory_map</code>).</li>
</ul>
</li>
</ul>
<h2 id="drawbacks-48"><a class="header" href="#drawbacks-48">Drawbacks</a></h2>
<ul>
<li>This will break codebases that make use of window names.</li>
</ul>
<h2 id="rationale-and-alternatives-47"><a class="header" href="#rationale-and-alternatives-47">Rationale and alternatives</a></h2>
<ul>
<li>Providing a <code>MemoryMap.Name</code> class for resource and window names facilitates their validation and documentation.
<ul>
<li><del>Alternative #1: do not add a class, and use standard tuples instead. Names will have to be validated by other means.</del></li>
<li><del>Alternative #2: use <code>MemoryMap.Name</code> for resource names only. Window names remain limited to strings.</del></li>
</ul>
</li>
</ul>
<h2 id="prior-art-43"><a class="header" href="#prior-art-43">Prior art</a></h2>
<ul>
<li>Resource names became tuples of strings as a consequence of <a href="https://amaranth-lang.org/rfcs/0016-soc-csr-regs.html">RFC 16</a>. However, array indices defined with <code>csr.Builder.Index()</code> were <a href="https://github.com/amaranth-lang/amaranth-soc/issues/69">cast to strings</a> when <code>.as_memory_map()</code> was called.</li>
</ul>
<h2 id="resolved-questions-2"><a class="header" href="#resolved-questions-2">Resolved questions</a></h2>
<ul>
<li>Should we require the presence of at least one string in <code>MemoryMap.Name</code> ?
<ul>
<li>Empty names are forbidden and transparent windows (i.e. without names) must use <code>None</code> instead. Further validation is deferred to consumers of the memory map (e.g. a BSP generator).</li>
</ul>
</li>
<li>Should we specify the order between strings and integers ? In <code>csr.Builder</code>, array indices precede cluster and register names (e.g. <code>('bar', 0, 'foo')</code> could be formatted as <code>&quot;bar.foo[0]&quot;</code>).
<ul>
<li>No, this decision is left out to consumers of the memory map. They may interpret a name differently depending on what it is assigned to.</li>
</ul>
</li>
</ul>
<h2 id="future-possibilities-47"><a class="header" href="#future-possibilities-47">Future possibilities</a></h2>
<p>None.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2024-07-29</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/71">amaranth-lang/rfcs#71</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth/issues/1468">amaranth-lang/amaranth#1468</a></li>
</ul>
<h1 id="enumviewmatches"><a class="header" href="#enumviewmatches"><code>EnumView.matches</code></a></h1>
<h2 id="summary-50"><a class="header" href="#summary-50">Summary</a></h2>
<p>A <code>matches</code> method is added to <code>EnumView</code>, performing a similar function to <code>Value.matches</code>.</p>
<h2 id="motivation-50"><a class="header" href="#motivation-50">Motivation</a></h2>
<p>Amaranth currently has <code>Value.matches</code>, which checks whether a value matches any of the given patterns. An obvious application of such a feature is using it with an enumerated value. However, as it stands, <code>EnumView</code> doesn't provide a corresponding method natively, requiring a cast to <code>Value</code>. Additionally, casting the <code>EnumView</code> to <code>Value</code> erases the enumeration type, providing no protection against matching with values from the wrong type.</p>
<p>This RFC proposes to fill that gap by adding a type-safe <code>EnumView.matches</code> method.</p>
<h2 id="guide-level-explanation-40"><a class="header" href="#guide-level-explanation-40">Guide-level explanation</a></h2>
<p>The <code>EnumView.matches</code> method can be used to check whether an enumerated value belongs to a given set:</p>
<pre><code>class Color(enum.Enum, shape=3):
    BLACK = 0
    RED = 1
    GREEN = 2
    BLUE = 4
    WHITE = 7

s = Signal(Color)
m.d.comb += is_grayscale.eq(s.matches(Color.BLACK, Color.WHITE))
</code></pre>
<h2 id="reference-level-explanation-40"><a class="header" href="#reference-level-explanation-40">Reference-level explanation</a></h2>
<p>The following method is added:</p>
<ul>
<li><code>EnumView.matches(*values)</code>: equivalent to <code>self.as_value().matches(*values)</code>, but requires all <code>values</code> to be a member of the same enum as the <code>EnumView</code>, raising a <code>TypeError</code> otherwise</li>
</ul>
<h2 id="drawbacks-49"><a class="header" href="#drawbacks-49">Drawbacks</a></h2>
<ul>
<li>more moving parts in the language</li>
<li>more general pattern matching facilities have been requested on multiple occasions, which this facility could end up redundant with</li>
</ul>
<h2 id="rationale-and-alternatives-48"><a class="header" href="#rationale-and-alternatives-48">Rationale and alternatives</a></h2>
<p>The proposed functionality is an obvious extension of <code>Value.matches</code> to the <code>EnumView</code> class. The proposed typechecking is consistent with current <code>EnumView</code> behavior.</p>
<h2 id="prior-art-44"><a class="header" href="#prior-art-44">Prior art</a></h2>
<p><code>Value.matches</code>, Rust <code>matches!()</code>.</p>
<h2 id="unresolved-questions-45"><a class="header" href="#unresolved-questions-45">Unresolved questions</a></h2>
<p>None.</p>
<h2 id="future-possibilities-48"><a class="header" href="#future-possibilities-48">Future possibilities</a></h2>
<p>None for <code>EnumView</code>. However, there have been discussions of having more advanced pattern matching facilities in the language in general.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2024-09-16</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/73">amaranth-lang/rfcs#73</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth/issues/1511">amaranth-lang/amaranth#1511</a></li>
</ul>
<h1 id="stricter-connections"><a class="header" href="#stricter-connections">Stricter connections</a></h1>
<h2 id="summary-51"><a class="header" href="#summary-51">Summary</a></h2>
<p>Make it possible for <code>lib.wiring.connect()</code> to reject connections between ports with shapes that despite having equal widths are incompatible.</p>
<h2 id="motivation-51"><a class="header" href="#motivation-51">Motivation</a></h2>
<p>The primary motivating use case is to be able to prevent connecting stream interfaces with incompatible payload shapes.</p>
<h2 id="guide-level-explanation-41"><a class="header" href="#guide-level-explanation-41">Guide-level explanation</a></h2>
<p><code>lib.stream</code> defines a basic stream interface with <code>ready</code>, <code>valid</code> and <code>payload</code> members.
Additional metadata signals can be added by making the <code>payload</code> shape an aggregate.
This has the advantage that such streams can be passed through standard components like FIFOs without them having to know or care about these signals.</p>
<p>Consider how we can make a byte-wide packetized stream by defining the <code>payload</code> shape as <code>StructLayout({&quot;data&quot;: 8, &quot;last&quot;: 1})</code>.
The <code>data</code> field contains the data byte and the <code>last</code> field is a flag indicating that the current byte is the last in the packet.</p>
<p>This is not the only common way to make a packetized stream.
Instead of (or in addition to) the <code>last</code> flag, the payload could have a <code>first</code> flag, indicating that the current byte is the first in the packet.
Both are valid options with different semantics for different usecases.</p>
<p>The problem is that <code>lib.wiring.connect()</code> currently only checks that port members have matching widths, so a connection between a stream interface with <code>last</code> semantics and a stream interface with <code>first</code> semantics will not be rejected, despite being incompatible.</p>
<p>Currently, <code>lib.data.View.eq()</code> does no checks on the passed value and immediately forwards to <code>self.as_value().eq()</code>, making this legal:</p>
<pre><code class="language-python">&gt;&gt;&gt; a = Signal(StructLayout({&quot;data&quot;: 8, &quot;last&quot;: 1}))
&gt;&gt;&gt; b = Signal(StructLayout({&quot;data&quot;: 8, &quot;first&quot;: 1}))
&gt;&gt;&gt; a.eq(b)
(eq (sig a) (sig b))
</code></pre>
<p>This RFC proposes adding a check to <code>View.eq()</code> that would reject direct assignments from another aggregate data structure with a non-identical layout.
If such an assignment is desired, the other aggregate data structure can be explicitly passed through <code>Value.cast()</code> first.</p>
<p>Currently <code>lib.wiring.connect()</code> passes every signal through <code>Value.cast()</code> before assigning them.
This results in a <code>ValueCastable</code>'s <code>.eq()</code> not being called, and thereby bypassing the check proposed above.</p>
<p>This RFC proposes removing the <code>Value.cast()</code> so a <code>ValueCastable</code>'s <code>.eq()</code> will be called directly.</p>
<p>This RFC proposes updating <code>lib.enum.EnumView</code> in the same manner, for the same reason, as <code>lib.data.View</code>.</p>
<h2 id="reference-level-explanation-41"><a class="header" href="#reference-level-explanation-41">Reference-level explanation</a></h2>
<p>Modify <code>lib.wiring.connect()</code> to not pass port members through <code>Value.cast()</code>, so that a <code>ValueCastable</code>'s <code>.eq()</code> will be called, allowing it to perform compatibility checks.</p>
<ul>
<li>If a <code>ValueCastable</code> doesn't define <code>.eq()</code>, reject the assignment.</li>
</ul>
<p>Modify <code>lib.data.View.eq(other)</code> to add the following checks:</p>
<ul>
<li>If <code>other</code> is a <code>ValueCastable</code>, do <code>Layout.cast(other.shape())</code>
<ul>
<li>If a valid <code>Layout</code> is returned, reject the assignment if it doesn't match <code>self.shape()</code>.</li>
<li>If <code>Layout.cast()</code> raises, reject the assignment.</li>
</ul>
</li>
<li>Otherwise, proceed as normal.</li>
</ul>
<p>Modify <code>lib.enum.EnumView.eq(other)</code> to add the following checks:</p>
<ul>
<li>If <code>other</code> is a <code>ValueCastable</code>, reject the assignment if <code>other.shape()</code> doesn't match <code>self.shape()</code>.</li>
<li>Otherwise, proceed as normal.</li>
</ul>
<p>Rejected assignments are a warning in Amaranth 0.6 and becomes a hard error in Amaranth 0.7.</p>
<h2 id="drawbacks-50"><a class="header" href="#drawbacks-50">Drawbacks</a></h2>
<ul>
<li>
<p>Increased language complexity.</p>
</li>
<li>
<p>This will add an implied requirement for a <code>ValueCastable</code> to implement <code>.eq()</code> to be usable with <code>lib.wiring</code>. Currently a <code>ValueCastable</code> is not required to implement <code>.eq()</code> at all.</p>
<ul>
<li>We could fall back to <code>Value.cast().eq()</code> when <code>.eq()</code> is not defined.</li>
</ul>
</li>
</ul>
<h2 id="rationale-and-alternatives-49"><a class="header" href="#rationale-and-alternatives-49">Rationale and alternatives</a></h2>
<ul>
<li>Signals like <code>first</code> and <code>last</code> could be added as separate ports in the stream signature, preventing incompatible connections.
<ul>
<li>This was already discussed in <a href="0061-minimal-streams.html">RFC 61</a> and decided against.</li>
</ul>
</li>
<li>An explicit hook for checking compatibility between interfaces could be added, instead of relying on <code>.eq()</code>.
<ul>
<li>This RFC proposes picking the low-hanging fruits first, making use of already existing mechanisms.
If this is not enough, another RFC can propose an explicit hook later.</li>
</ul>
</li>
</ul>
<h2 id="prior-art-45"><a class="header" href="#prior-art-45">Prior art</a></h2>
<p><a href="0061-minimal-streams.html">RFC 61</a> already discussed the need to eventually make <code>lib.wiring.connect()</code> stricter to prevent the connection of stream interfaces with incompatible payloads.</p>
<h2 id="unresolved-questions-46"><a class="header" href="#unresolved-questions-46">Unresolved questions</a></h2>
<p>None.</p>
<h2 id="future-possibilities-49"><a class="header" href="#future-possibilities-49">Future possibilities</a></h2>
<ul>
<li>A hook can still be added to allow a signature/interface to perform an explicit compatibility check, for cases where signatures have identical members but still have metadata indicating they are incompatible.
<ul>
<li>This hook could also allow overriding the existing checks, allowing connections where interfaces are compatible despite differences in members.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: (fill in with date at which the RFC is merged, 2025-05-12)</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/76">amaranth-lang/rfcs#76</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth/issues/1595">amaranth-lang/amaranth#1595</a></li>
</ul>
<h1 id="amaranth-boards-versioning-policy"><a class="header" href="#amaranth-boards-versioning-policy"><code>amaranth-boards</code> versioning policy</a></h1>
<h2 id="summary-52"><a class="header" href="#summary-52">Summary</a></h2>
<p>Add a versioning policy for <code>amaranth-boards</code>.</p>
<h2 id="motivation-52"><a class="header" href="#motivation-52">Motivation</a></h2>
<p>Packages with direct (e.g. git) dependencies aren't allowed on PyPI, so by not publishing releases on PyPI, we're blocking downstream projects depending on <code>amaranth-boards</code> from publishing their releases on PyPi without having to do workarounds.</p>
<h2 id="explanation-4"><a class="header" href="#explanation-4">Explanation</a></h2>
<ul>
<li>Use a <code>0.x.y</code> versioning scheme.</li>
<li>Increment <code>y</code> and do a new release any time there's been done significant additions.</li>
<li>Increment <code>x</code>, reset <code>y</code> and do a new release any time there are breaking changes.</li>
</ul>
<p>A breaking change is anything that requires manual intervention for code that previously worked fine.
I.e. a change to a board file which previously had two pins incorrectly swapped would not be a breaking change; a change to names of resources across multiple boards would be.</p>
<p>This should be implemented by automatically releasing every commit to <code>main</code> whose HEAD message doesn't contain <code>[breaking change]</code> or <code>[breaking-change]</code> with a version like <code>v0.x.y</code> where <code>y</code> is the number of commits since the last breaking change, and automatically tagging every commit that does with a tag <code>v0.(x+1).0</code>.</p>
<h2 id="drawbacks-51"><a class="header" href="#drawbacks-51">Drawbacks</a></h2>
<p>None.</p>
<h2 id="rationale-and-alternatives-50"><a class="header" href="#rationale-and-alternatives-50">Rationale and alternatives</a></h2>
<p><code>amaranth-boards</code> is mainly a collection of independent board definitions where most changes consists of adding or updating definitions for one specific target.</p>
<p>Most changes will have none to limited impact on existing code, and a simple policy reducing friction for new additions and fixes is more useful than having a strict deprecation policy with regular major releases.</p>
<h2 id="prior-art-46"><a class="header" href="#prior-art-46">Prior art</a></h2>
<p>None.</p>
<h2 id="unresolved-questions-47"><a class="header" href="#unresolved-questions-47">Unresolved questions</a></h2>
<p>None.</p>
<h2 id="future-possibilities-50"><a class="header" href="#future-possibilities-50">Future possibilities</a></h2>
<p>None.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
