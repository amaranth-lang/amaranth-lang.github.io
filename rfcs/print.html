<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Amaranth RFC Book</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="0001-aggregate-data-structures.html">0001-aggregate-data-structures</a></li><li class="chapter-item expanded "><a href="0002-interfaces.html">0002-interfaces</a></li><li class="chapter-item expanded "><a href="0003-enumeration-shapes.html">0003-enumeration-shapes</a></li><li class="chapter-item expanded "><a href="0004-const-castable-exprs.html">0004-const-castable-exprs</a></li><li class="chapter-item expanded "><a href="0005-remove-const-normalize.html">0005-remove-const-normalize</a></li><li class="chapter-item expanded "><a href="0006-stdlib-crc.html">0006-stdlib-crc</a></li><li class="chapter-item expanded "><a href="0008-aggregate-extensibility.html">0008-aggregate-extensibility</a></li><li class="chapter-item expanded "><a href="0009-const-init-shape-castable.html">0009-const-init-shape-castable</a></li><li class="chapter-item expanded "><a href="0010-move-repl-to-value.html">0010-move-repl-to-value</a></li><li class="chapter-item expanded "><a href="0015-lifting-shape-castables.html">0015-lifting-shape-castables</a></li><li class="chapter-item expanded "><a href="0018-reorganize-vendor-platforms.html">0018-reorganize-vendor-platforms</a></li><li class="chapter-item expanded "><a href="0019-remove-scheduler.html">0019-remove-scheduler</a></li><li class="chapter-item expanded "><a href="0020-deprecate-non-fwft-fifos.html">0020-deprecate-non-fwft-fifos</a></li><li class="chapter-item expanded "><a href="0021-patch-releases.html">0021-patch-releases</a></li><li class="chapter-item expanded "><a href="0022-valuecastable-shape.html">0022-valuecastable-shape</a></li><li class="chapter-item expanded "><a href="0028-override-value-operators.html">0028-override-value-operators</a></li><li class="chapter-item expanded "><a href="0031-enumeration-type-safety.html">0031-enumeration-type-safety</a></li><li class="chapter-item expanded "><a href="0034-interface-rename.html">0034-interface-rename</a></li><li class="chapter-item expanded "><a href="0035-shapelike-valuelike.html">0035-shapelike-valuelike</a></li><li class="chapter-item expanded "><a href="0037-make-signature-immutable.html">0037-make-signature-immutable</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Amaranth RFC Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/amaranth-lang/rfcs" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="amaranth-rfcs---rfc-book"><a class="header" href="#amaranth-rfcs---rfc-book">Amaranth RFCs - <a href="https://amaranth-lang.org/rfcs/">RFC Book</a></a></h1>
<p>The &quot;RFC&quot; (request for comments) process is intended to provide a consistent and controlled path for changes to Amaranth (such as new features) so that all stakeholders can be confident about the direction of the project.</p>
<p>Many changes, including bug fixes and documentation improvements can be implemented and reviewed via the normal GitHub pull request workflow.</p>
<p>Some changes though are &quot;substantial&quot;, and we ask that these be put through a bit of a design process and produce a consensus among the Amaranth community.</p>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ul>
<li><a href="introduction.html#amaranth-rfcs">Opening</a></li>
<li><a href="introduction.html#table-of-contents">Table of Contents</a></li>
<li><a href="introduction.html#when-you-need-to-follow-this-process">When you need to follow this process</a></li>
<li><a href="introduction.html#before-creating-an-rfc">Before creating an RFC</a></li>
<li><a href="introduction.html#what-the-process-is">What the process is</a></li>
<li><a href="introduction.html#the-rfc-life-cycle">The RFC life-cycle</a></li>
<li><a href="introduction.html#reviewing-rfcs">Reviewing RFCs</a></li>
<li><a href="introduction.html#implementing-an-rfc">Implementing an RFC</a></li>
<li><a href="introduction.html#acknowledgements">Acknowledgements</a></li>
<li><a href="introduction.html#license">License</a></li>
</ul>
<h2 id="when-you-need-to-follow-this-process"><a class="header" href="#when-you-need-to-follow-this-process">When you need to follow this process</a></h2>
<p>You need to follow this process if you intend to make &quot;substantial&quot; changes to <a href="https://github.com/amaranth-lang/amaranth">core Amaranth language</a>. In the future you will need to follow this process for the <a href="https://github.com/amaranth-lang/amaranth-stdio">standard I/O library</a> and the <a href="https://github.com/amaranth-lang/amaranth-soc">System-on-Chip library</a> as well, but at the moment they are not covered.</p>
<p>What constitutes a &quot;substantial&quot; change is evolving based on community norms and varies depending on what part of the ecosystem you are proposing to change, but may include the following:</p>
<ul>
<li>Any semantic or syntactic change to the language (<code>amaranth.hdl</code>) that is not a bugfix.</li>
<li>Behavioral changes to the standard library (<code>amaranth.lib</code>).</li>
<li>Behavioral changes to the toolchain interface (<code>amaranth.vendor</code>).</li>
</ul>
<p>Some changes do not require an RFC:</p>
<ul>
<li>Rephrasing, reorganizing, refactoring, or otherwise &quot;changing shape does not change meaning&quot;.</li>
<li>Additions that strictly improve objective, numerical quality criteria (warning removal, speedup, better platform coverage, handling more errors, etc.)</li>
</ul>
<p>If you submit a pull request to implement a new feature without going through the RFC process, it may be closed with a polite request to submit an RFC first. When in doubt, please open an issue to discuss the feature first and one of the core maintainers will say if the change requires an RFC or not.</p>
<h2 id="before-creating-an-rfc"><a class="header" href="#before-creating-an-rfc">Before creating an RFC</a></h2>
<p>A hastily-proposed RFC can hurt its chances of acceptance. Low quality proposals, proposals for previously-rejected features, or those that don't fit into the near-term roadmap, may be quickly rejected, which can be demotivating for the unprepared contributor. Laying some groundwork ahead of the RFC can make the process smoother.</p>
<p>Although there is no single way to prepare for submitting an RFC, it is generally a good idea to pursue feedback from other project developers beforehand, to ascertain that the RFC may be desirable; having a consistent impact on the project requires concerted effort toward consensus-building.</p>
<p>The most common preparations for writing and submitting an RFC include talking the idea over on our IRC channel, <a href="https://web.libera.chat/#amaranth-lang">#amaranth-lang at libera.chat</a>, or opening an issue on the corresponding repository to gather feedback.</p>
<h2 id="what-the-process-is"><a class="header" href="#what-the-process-is">What the process is</a></h2>
<p>In short, to get a major feature added to Amaranth, one must first get the RFC merged into the RFC repository as a markdown file. At that point the RFC is &quot;active&quot; and may be implemented with the goal of eventual inclusion into Amaranth.</p>
<ul>
<li>Fork the RFC repository.</li>
<li>Copy 0000-template.md to text/0000-my-feature.md (where &quot;my-feature&quot; is descriptive). Don't assign an RFC number yet; This is going to be the PR number and we'll rename the file accordingly if the RFC is accepted.</li>
<li>Fill in the RFC. Put care into the details: RFCs that do not present convincing motivation, demonstrate lack of understanding of the design's impact, or are disingenuous about the drawbacks or alternatives tend to be poorly-received.</li>
<li>Submit a pull request. As a pull request the RFC will receive design feedback from the larger community, and the author should be prepared to revise it in response.</li>
<li>Now that your RFC has an open pull request, use the issue number of the PR to update your 0000- prefix to that number.</li>
<li>Build consensus and integrate feedback. RFCs that have broad support are much more likely to make progress than those that don't receive any comments. Feel free to reach out to the RFC assignee in particular to get help identifying stakeholders and obstacles.</li>
<li>RFCs rarely go through this process unchanged, especially as alternatives and drawbacks are shown. You can make edits, big and small, to the RFC to clarify or change the design, but make changes as new commits to the pull request, and leave a comment on the pull request explaining your changes. Specifically, do not squash or rebase commits after they are visible on the pull request.</li>
<li>At some point, a core maintainer will make a decision on the disposition for the RFC (merge, close, or postpone).
<ul>
<li>This step is taken when enough of the tradeoffs have been discussed that the core maintainer is in a position to make a decision. That does not require consensus amongst all participants in the RFC thread (which is usually impossible). However, the argument supporting the disposition on the RFC needs to have already been clearly articulated, and there should not be a strong consensus against that position.</li>
</ul>
</li>
</ul>
<h2 id="the-rfc-life-cycle"><a class="header" href="#the-rfc-life-cycle">The RFC life-cycle</a></h2>
<p>Once an RFC becomes &quot;active&quot; then authors may implement it and submit the feature as a pull request to the corresponding repository. Being &quot;active&quot; is not a rubber stamp, and in particular still does not mean the feature will ultimately be merged; it does mean that in principle all the major stakeholders have agreed to the feature and are amenable to merging it.</p>
<p>Furthermore, the fact that a given RFC has been accepted and is &quot;active&quot; implies nothing about what priority is assigned to its implementation, nor does it imply anything about whether a developer has been assigned the task of implementing the feature. While it is not necessary that the author of the RFC also write the implementation, it is by far the most effective way to see an RFC through to completion: authors should not expect that other project developers will take on responsibility for implementing their accepted feature.</p>
<p>Modifications to &quot;active&quot; RFCs can be done in follow-up pull requests. We strive to write each RFC in a manner that it will reflect the final design of the feature; but the nature of the process means that we cannot expect every merged RFC to actually reflect what the end result will be at the time of the next major release.</p>
<p>In general, once accepted, RFCs should not be substantially changed. Only very minor changes should be submitted as amendments. More substantial changes should be new RFCs, with a note added to the original RFC. Exactly what counts as a &quot;very minor change&quot; is up to the core maintainers to decide.</p>
<h2 id="reviewing-rfcs"><a class="header" href="#reviewing-rfcs">Reviewing RFCs</a></h2>
<p>While the RFC pull request is up, the core maintainers may schedule meetings with the author and/or relevant stakeholders to discuss the issues in greater detail, and the topic may be discussed at weekly meetings. In either case a summary from the meeting will be posted back to the RFC pull request.</p>
<p>A core maintainer makes final decisions about RFCs after the benefits and drawbacks are well understood. These decisions can be made at any time, but the core maintainer will regularly issue decisions. When a decision is made, the RFC pull request will either be merged or closed. In either case, if the reasoning is not clear from the discussion in thread, the core maintainer will add a comment describing the rationale for the decision.</p>
<h2 id="implementing-an-rfc"><a class="header" href="#implementing-an-rfc">Implementing an RFC</a></h2>
<p>Some accepted RFCs represent vital features that need to be implemented right away. Other accepted RFCs can represent features that can wait until some arbitrary developer feels like doing the work. Every accepted RFC has an associated issue tracking its implementation in the corresponding repository.</p>
<p>The author of an RFC is not obligated to implement it. Of course, the RFC author (like any other developer) is welcome to post an implementation for review after the RFC has been accepted.</p>
<p>If you are interested in working on the implementation for an &quot;active&quot; RFC, but cannot determine if someone else is already working on it, feel free to ask (e.g. by leaving a comment on the associated issue).</p>
<h2 id="rfc-postponement"><a class="header" href="#rfc-postponement">RFC Postponement</a></h2>
<p>Some RFC pull requests are tagged with the &quot;postponed&quot; label when they are closed (as part of the rejection process). An RFC closed with &quot;postponed&quot; is marked as such because we want neither to think about evaluating the proposal nor about implementing the described feature until some time in the future, and we believe that we can afford to wait until then to do so. Postponed pull requests may be re-opened when the time is right. We don't have any formal process for that, you should ask a core maintainer.</p>
<p>Usually an RFC pull request marked as &quot;postponed&quot; has already passed an informal first round of evaluation, namely the round of &quot;do we think we would ever possibly consider making this change, as outlined in the RFC pull request, or some semi-obvious variation of it.&quot; (When the answer to the latter question is &quot;no&quot;, then the appropriate response is to close the RFC, not postpone it.)</p>
<h2 id="acknowledgements"><a class="header" href="#acknowledgements">Acknowledgements</a></h2>
<p>The process described in this document is based on the <a href="https://github.com/rust-lang/rfcs">Rust RFC process</a>. It has been simplified to match the needs of the much smaller Amaranth community; in particular, policy (including the RFC process itself) is not currently defined through the RFC process.</p>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>This repository is licensed under the <a href="LICENSE.txt">MIT license</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2023-02-14</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/1">amaranth-lang/rfcs#1</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth/issues/748">amaranth-lang/amaranth#748</a></li>
</ul>
<h1 id="aggregate-data-structure-library"><a class="header" href="#aggregate-data-structure-library">Aggregate data structure library</a></h1>
<blockquote>
<p><strong>Amendments</strong>
The behavior described in this RFC was updated by <a href="0008-aggregate-extensibility.html">RFC #8</a>, <a href="0009-const-init-shape-castable.html">RFC #9</a>, and <a href="0015-lifting-shape-castables.html">RFC #15</a>.</p>
</blockquote>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>Add a rich set of standard library classes for accessing hierarchical aggregate data an idiomatic way, to fill one of the two major use cases of <code>Record</code> while avoiding its downsides.</p>
<p>See also <a href="0002-interfaces.html">RFC #2</a>.</p>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<p>Amaranth has a single data storage primitive: <code>Signal</code>. A <code>Signal</code> can be referenced on the left hand and the right hand side of an assignment, and so can be its slices. Although a signal serves the role of a numeric and bit container type fine, designs often include signals used as bit containers whose individual bits are named and have unique meanings. A mechanism that allows referring to such bit fields by name is essential.</p>
<p>Currently, the role of this mechanism is served by <code>Record</code>. However, <code>Record</code> has multiple major drawbacks:</p>
<ol>
<li>
<p><code>Record</code> attempts to do too much: it is both a mechanism for <em>controlling representation</em> (including implicitly casting a record to a value) and a mechanism for <em>defining interfaces</em> (specifying signal directions and facilitating connections between records).</p>
<p>These mechanisms should be defined separately, since the only aspect they have in common is using a container class that consists of multiple named fields. Conflating the two mechanisms constraints the design space, making addressing the other drawbacks impossible, and the ill-defined scope encourages bugs in downstream code.</p>
</li>
<li>
<p><code>Record</code> has limited composability: records can only be nested within each other. Practical designs (in particular, implementations of protocols) use data with complex representation beyond nested sequences of fields: these include overlaid sequences of fields (where interpretation alternates based on some discriminant) and arrays of fields (where a field can be indexed by a non-constant), where any individual field can have a complex representation itself.</p>
<p><code>Record</code> is structured as a sequence of <code>Signal</code>s, which is a part of its API. As such, it cannot support overlaid fields, and implementing support for arrays of fields is challenging.</p>
</li>
<li>
<p><code>Record</code> has limited introspectability: while its <code>layout</code> member can be accessed to enumerate its fields, the results do not include field boundaries, and the types of the returned shape-castable objects are preserved only as an implementation detail. <code>Layout</code> objects themselves are also not shape-castable.</p>
<p><code>Record</code> and <code>Layout</code> are structured as a sequence of <code>Signal</code>s rather than a view into an underlying bit container, which is reflected in its API. Thus, <code>Layout</code> does not fit into Amaranth's data model, which concerns individual values.</p>
</li>
<li>
<p><code>Record</code> comes with its own storage: while its <code>fields</code> argument can be used to substitute the signals that individual fields are pointing to (in an awkward and error-prone way), it is still a collection of <code>Signal</code>s. Using <code>Record</code> to impose structure on an existing <code>Value</code> requires a <code>Module</code> and a combinatorial assignment. This is an unnecessary complication, especially in helper functions.</p>
</li>
<li>
<p><code>Record</code> does not play well with Python's type annotations. Amaranth developers often inherit from <code>Record</code> as well as <code>Layout</code>, but in both cases the class definition syntax is usually little more than a way to define a callable returning a <code>Record</code> with a specific layout, and provides no benefits for IDE users.</p>
</li>
<li>
<p><code>Record</code> reserves a lot of names, including commonly used names like <code>connect</code>, <code>any</code>, <code>all</code>, and <code>matches</code>. Conversely, it defines a lot of arithmetic methods that are rarely if ever used on field containers.</p>
</li>
<li>
<p><code>Layout</code>'s DSL is very amorphous. It passes around variable length tuples. The second element of these tuples (the shape) can be another <code>Layout</code>, which is neither a shape nor a shape-castable object.</p>
</li>
<li>
<p>Neither <code>Record</code> nor <code>Layout</code> allow defining fields whose shapes are arbitrary <code>ShapeCastable</code> classes.</p>
</li>
</ol>
<p>Since these drawbacks are entrenched in the public API and heavily restrict usefulness of <code>Record</code> as a mechanism for specifying data representation, a new mechanism must replace it.</p>
<h2 id="overview-and-examples"><a class="header" href="#overview-and-examples">Overview and examples</a></h2>
<p>This section shows a bird's eye view of the new syntax and behavior proposed in this RFC. The detailed design is described afterwards.</p>
<pre><code class="language-python">from amaranth import *
from amaranth.lib import data


# Declaring a simple structure:
class Float32(data.Struct):
    fraction: unsigned(23)
    exponent: unsigned(8)
    sign: unsigned(1)


# Defining a signal with the structure above:
flt_a = Float32()

# Reinterpreting an existing value with the same structure:
flt_b = Float32(Const(0b00111110001000000000000000000000, 32))

# Referencing and updating structure fields by name:
with m.If(flt_b.fraction &gt; 0):
    m.d.comb += [
        flt_a.sign.eq(1),
        flt_a.exponent.eq(127)
    ]


# Declaring a simple union, referencing an existing structure:
class FloatOrInt32(data.Union):
    float: Float32
    int: signed(32)


# Using the union to bitcast an IEEE754 value from an integer:
f_or_i = FloatOrInt32()
is_sub_1 = Signal()
m.d.comb += [
    f_or_i.int.eq(0x41C80000),
    is_sub_1.eq(f_or_i.float.exponent &lt; 127) # =&gt; 1
]


class Op(enum.Enum):
  ADD = 0
  SUB = 1


# Programmatically declaring a structure layout:
adder_op_layout = data.StructLayout({
    &quot;op&quot;: Op,
    &quot;a&quot;: Float32,
    &quot;b&quot;: Float32
})

# Using the layout defined above to define appropriately sized storage...
adder_op_storage = Signal(adder_op_layout)
len(adder_op_storage) # =&gt; 65

# ... and wrap it for the fields to be accessible.
adder_op = data.View(adder_op_layout, adder_op_storage)
m.d.comb += [
    adder_op.op.eq(Op.SUB),
    adder_op.a.eq(flt_a),
    adder_op.b.eq(flt_b)
]
</code></pre>
<h2 id="detailed-design"><a class="header" href="#detailed-design">Detailed design</a></h2>
<p>This RFC proposes a number of language and library additions:</p>
<ul>
<li>Adding a <code>ShapeCastable</code> interface, similar to <code>ValueCastable</code>;</li>
<li>Adding classes that hierarchically describe representation of aggregate values: named field containers with non-overlapping fields (structs), named field containers with overlapping fields (unions), and indexed field containers (arrays);</li>
<li>Adding a wrapper class that accepts a <code>Value</code> (or a <code>ValueCastable</code> object) and provides accessors that slice it according to the corresponding aggregate representation;</li>
<li>Adding an ergonomic and IDE-compatible interface for building descriptions of non-parametric layouts of aggregate values.</li>
</ul>
<h3 id="user-defined-shape-castable-objects"><a class="header" href="#user-defined-shape-castable-objects">User-defined shape-castable objects</a></h3>
<p><code>ShapeCastable</code> is an interface for defining <code>Shape</code>-like values outside of the core Amaranth language. It is functionally identical to <code>ValueCastable</code>, and could be used like:</p>
<pre><code class="language-python">from amaranth import *


class Layout(ShapeCastable):
    def __init__(self, fields):
        self.fields = fields

    def as_shape(self):
        return unsigned(sum(len(field) for field in self.fields))
</code></pre>
<h3 id="value-layout-descriptions"><a class="header" href="#value-layout-descriptions">Value layout descriptions</a></h3>
<p>Aggregate value layouts are represented using two classes: <code>amaranth.lib.data.Field</code> and <code>amaranth.lib.data.Layout</code>:</p>
<ul>
<li>A <code>Field(shape_castable, offset=0)</code> object describes a field of the given shape starting at bit number <code>offset</code> of the aggregate value.</li>
<li>A <code>Layout()</code> object describes an abstract aggregate value. It can be iterated, returning <code>(name, field)</code> or <code>(index, field)</code> pairs; or indexed (<code>__getitem__</code>) by the name or index of the field. It has a <code>.size</code> in bits, determined by the type of the layout, and is shape-castable, being converted to <code>unsigned(layout.size())</code>.
<ul>
<li>A <code>StructLayout(members={&quot;name&quot;: shape_castable})</code> object describes an aggregate value with non-overlapping named fields (struct). The fields are placed at offsets such that they immediately follow one another, from least significant to most significant.</li>
<li>A <code>UnionLayout(members={&quot;name&quot;: shape_castable})</code> object describes an aggregate value with overlapping named fields (union). The fields are placed at offset 0.</li>
<li>An <code>ArrayLayout(element=shape_castable, length=1)</code> object describes an aggregate value with indexed fields (array). The fields all have identical shape and are placed at offsets such that they immediately follow one another, from least significant to most significant.</li>
<li>A <code>FlexibleLayout(fields={&quot;name&quot;: field, 0: field}, size=16)</code> object describes a aggregate value with fields arbitrarily placed within its bounds.</li>
</ul>
</li>
</ul>
<p>The representation of a discriminated union could be programmatically constructed as follows:</p>
<pre><code class="language-python">import enum
from amaranth.lib import data


class Kind(enum.Enum):
    ONE_SIGNED = 0
    TWO_UNSIGNED = 1


layout = data.StructLayout({
    &quot;kind&quot;: Kind,
    &quot;value&quot;: data.UnionLayout({
        &quot;one_signed&quot;: signed(2),
        &quot;two_unsigned&quot;: data.ArrayLayout(unsigned(1), 2)
    })
})
</code></pre>
<h3 id="aggregate-value-access"><a class="header" href="#aggregate-value-access">Aggregate value access</a></h3>
<p>Aggregate values are manipulated through the <code>amaranth.lib.data.View</code> class. A <code>View(layout, value_castable)</code> object wraps a value-castable object (which may be a valid assignment target) and provides access to fields according to the layout. A view is itself value-castable, being converted to the object it's wrapping. If the view is wrapping a valid assignment target, then the accessors also return a valid assignment target.</p>
<p>Fields can be accessed using either <code>__getitem__</code> (for both named and indexed fields) or <code>__getattr__</code> (for named fields). To avoid name collisions when using <code>__getattr__</code> to access fields, views do not define any non-reserved attributes of their own except for the <code>.as_value()</code> casting method. Field names starting with <code>_</code> are reserved as attribute names and and can only be accessed using the <code>view[&quot;name&quot;]</code> indexing syntax.</p>
<p>When a view is used to access a field whose shape is an ordinary <code>Shape</code> object, the accessor returns a <code>Value</code> of the corresponding shape that slices the viewed object.</p>
<p>When a view is used to access a field whose shape is an aggregate value layout, the accessor returns another <code>View</code> with this layout, wrapping the slice of the viewed object. For fields that have any other shape-castable object set as their shape, the behavior is the same as for the <code>Shape</code> case.</p>
<p>Views that have an <code>ArrayLayout</code> as their layout can be indexed with a <code>Value</code>. In this case, the viewed object is sliced with <code>Value.word_select</code>.</p>
<p>A signal can be manipulated with its structure viewed as the discriminated union defined above as follows:</p>
<pre><code class="language-python"># creates an unsigned(3) signal by shape-casting `layout`
sig = Signal(layout)
view = data.View(layout, sig)

# if the second argument is omitted, a signal with the right shape is created internally;
# the line below is equivlent to the two lines above
view = data.View(layout)

m = Module()
m.d.comb += [
    view.kind.eq(Kind.TWO_UNSIGNED),
    view.value.two_unsigned[0].eq(1),
]
</code></pre>
<h3 id="ergonomic-layout-definition"><a class="header" href="#ergonomic-layout-definition">Ergonomic layout definition</a></h3>
<p>Rather than using the underlying <code>StructLayout</code> and <code>UnionLayout</code> classes, struct and union layouts can be defined using the Python class definition syntax, with the shapes of the members specified using the <a href="https://peps.python.org/pep-0526/">PEP 526</a> variable annotations:</p>
<pre><code class="language-python">class SomeVariant(data.Struct):
    class Value(data.Union):
        one_signed: signed(2)
        two_unsigned: data.ArrayLayout(unsigned(1), 2)

    kind: Kind
    value: Value


# this class can be used in the same way as a `data.View` without needing to specify the layout:
view2 = SomeVariant()
m.d.comb += [
    view2.kind.eq(Kind.ONE_SIGNED),
    view2.value.eq(view.value)
]
</code></pre>
<p>When they refer to other structures or unions defined in the same way, the variable annotations are also valid <a href="https://peps.python.org/pep-0484/">PEP 484</a> type hints, and will be used by IDEs to derive types of properties and expressions. Otherwise, the annotations will be opaque to IDEs or type checkers, but are still useful for a human reader.</p>
<p>The classes defined in this way are shape-castable and can be used anywhere a shape or a aggregate value layout is accepted:</p>
<pre><code class="language-python">sig2 = Signal(SomeVariant)
layout2 = data.StructLayout({
    &quot;ready&quot;: unsigned(1),
    &quot;payload&quot;: SomeVariant
})
</code></pre>
<p><strong>Implementation note:</strong> This can be achieved by using a custom metaclass for <code>Struct</code> and <code>Union</code> that inherits from <code>ShapeCastable</code>.</p>
<p>If an explicit <code>Layout</code> object is nevertheless needed (e.g. for introspection), it can be extracted from the class using <code>Layout.cast</code>:</p>
<pre><code class="language-python">layout == data.Layout.cast(SomeVariant) # =&gt; True
</code></pre>
<p>Conversely, the shape-castable object defining the layout of a <code>View</code> (which might be a <code>Layout</code> subclass or a <code>Struct</code>/<code>Union</code> subclass) can be extracted from the view using <code>Layout.of</code>:</p>
<pre><code class="language-python">SomeVariant is data.Layout.of(view2) # =&gt; True
</code></pre>
<h3 id="advanced-usage-parametric-layouts"><a class="header" href="#advanced-usage-parametric-layouts">Advanced usage: Parametric layouts</a></h3>
<p>The ergonomic definitions using the <code>Struct</code> and <code>Union</code> base classes are concise and integrated with Python type annotations. However, they cannot be used if the layout of an aggregate value is parameterized. In this case, a class with similar functionality can be defined in a more explicit way:</p>
<pre><code class="language-python">class Stream8b10b(data.View):
    data: Signal
    ctrl: Signal

    def __init__(self, value=None, *, width: int):
        super().__init__(data.StructLayout({
            &quot;data&quot;: unsigned(8 * width),
            &quot;ctrl&quot;: unsigned(width)
        }), value)


len(Stream8b10b(width=1).data) # =&gt; 8
len(Stream8b10b(width=4).data) # =&gt; 32
</code></pre>
<p>Since the parametric class name itself does not have a fixed layout, it cannot be used with <code>Layout.cast</code>. Similarly, the type annotations cannot include specific field widths; they are included only to indicate the presence of a corresponding attribute to IDEs and type checkers.</p>
<h3 id="structure-field-ordering"><a class="header" href="#structure-field-ordering">Structure field ordering</a></h3>
<p>The fields of a structure layout object are ordered from least significant to most significant:</p>
<pre><code class="language-python">float32_layout = data.StructLayout({
    &quot;fraction&quot;: unsigned(23),   # bits  0..22
    &quot;exponent&quot;: unsigned(8),    # bits 23..30
    &quot;sign&quot;: unsigned(1)         # bit  31
})

class Float32(data.Struct):
    fraction: unsigned(23)      # bits  0..22
    exponent: unsigned(8)       # bits 23..30
    sign: unsigned(1)           # bit  31
</code></pre>
<p>In other words, the following identity holds:</p>
<pre><code class="language-python">float32_storage = Signal(float32_layout)
float32 = data.View(float32_layout, float32_storage)

float32_storage == Cat(float32.fraction, float32_layout.exponent, float32.sign)
</code></pre>
<h3 id="customizing-the-automatically-created-signal"><a class="header" href="#customizing-the-automatically-created-signal">Customizing the automatically created <code>Signal</code></a></h3>
<p>When a view is instantiated without an explicit view target, it creates a <code>Signal</code> with a shape matching the view layout. The <code>View</code> constructor accepts all of the <code>Signal</code> constructor keyword arguments and passes them along; the <code>reset=</code> argument accepts a struct or an array (according to the type of the layout):</p>
<pre><code class="language-python">flt_neg_reset = data.View(float32_layout, reset={&quot;sign&quot;: 1})

flt_reset_less = Float32(reset_less=True)
</code></pre>
<h2 id="drawbacks"><a class="header" href="#drawbacks">Drawbacks</a></h2>
<p>This feature introduces a language-level concept, shape-castable objects, increasing language complexity.</p>
<p>This feature introduces a finely grained hierarchy of 5 similar and related classes for describing layouts.</p>
<h2 id="alternatives"><a class="header" href="#alternatives">Alternatives</a></h2>
<p>Do nothing. <code>Record</code> will continue to be used alongside the continued proliferation of ad-hoc implementations of similar functionality.</p>
<p>Remove <code>ArrayLayout</code> from this proposal. The array functionality is niche and introduces the complexity of handling by-index accessors alongside by-name ones.</p>
<p>Remove <code>ArrayLayout</code>, <code>UnionLayout</code>, and <code>FlexibleLayout</code> from this proposal. Their functionality is less commonly used than that of <code>StructLayout</code> and introduces the substantial complexity of handling fields at arbitrary offsets. (This would make <code>amaranth.lib.data</code> useless for slicing CSRs in Amaranth SoC.) This change would bring this proposal close to the original <code>PackedStruct</code> proposal discussed in https://github.com/amaranth-lang/amaranth/issues/342.</p>
<p>Combine the <code>Layout</code> and all of its derivative classes into a single <code>Layout(fields={&quot;name&quot;: Field(...), 0: Field(...)})</code> class that provides a superset of the functionality. This simplifies the API, but makes introspection of aggregate layouts very difficult and can be inefficient if large arrays are used. In this case, factory methods of the <code>Layout</code> class would be provided for more convenient construction of regular struct, union, and array layouts.</p>
<p>Remove <code>Struct</code> and <code>Union</code> annotation-driven definition syntax. This makes the API simpler, less redundant, and with fewer corner cases, also avoiding the use of variable annotations that are not valid PEP 484 type hints, at the cost of a continued jarring experience for IDE users.</p>
<p>Include a more concise and less visually noisy way to build <code>StructLayout</code> and <code>UnionLayout</code> objects (or their equivalents) using a builder pattern. This may make the syntax slightly nicer, though the RFC author could not come up with anything that would actually be such.</p>
<h2 id="bikeshedding"><a class="header" href="#bikeshedding">Bikeshedding</a></h2>
<p>The names of the <code>Field</code>, <code>*Layout</code>, and <code>View</code> classes could be changed to something better.</p>
<ul>
<li><code>IrregularLayout</code> was renamed to <code>FlexibleLayout</code>.</li>
</ul>
<h2 id="future-work"><a class="header" href="#future-work">Future work</a></h2>
<p>This feature could be improved in several ways that are not in scope of this RFC:</p>
<ul>
<li><code>StructLayout</code>, <code>UnionLayout</code>, and <code>ArrayLayout</code> could be extended to generate layouts with padding at the end (for structs and unions) or between elements (for arrays). Currently this requires the use of a <code>FlexibleLayout</code>.</li>
<li><code>StructLayout</code> could be extended to accept a list of fields in addition to a map of field names to values. In this case, it would represent an aggregate value with non-overlapping indexed fields (tuple).</li>
<li><code>Struct</code> and/or <code>StructLayout</code> could be extended to treat certain reserved field names (e.g. <code>&quot;_1&quot;</code>, <code>&quot;_2&quot;</code>, ...) as designating padding bits. In this case, the offset of the following fields would be adjusted, and the fields with such names would not appear in the layout.</li>
<li><code>Struct</code> and/or <code>StructLayout</code> could be extended to treat certain reserved field names (e.g. <code>&quot;_&quot;</code> for <code>Struct</code> and <code>None</code> for <code>StructLayout</code>) as designating an anonymous inner aggregate. In this case, the members of the anonymous inner aggregate would be possible to access as if they were the members of the outer aggregate.</li>
<li>The automatic wrapping of accessed aggregate fields done by <code>View</code> could be extended to call a user-specified cast function rather than hard-coding a check for whether the shape is a <code>Layout</code>. This would allow seamless inclusion of user-defined value-castable types in aggregates.</li>
<li>The <a href="https://peps.python.org/pep-0484/">PEP 484</a> generics could be used to define layouts parametric over field shapes, using type annotations alone. Since Python does not have type-level integers, layouts parametric over field sizes would still need to be defined explicitly.</li>
<li>The struct, union, and enum support could be used as the building blocks to implement first-class discriminated unions. Discriminated unions will also benefit from tuples, described above. (<a href="https://github.com/amaranth-lang/amaranth/issues/693#issuecomment-1089322514">Suggestion</a> by @lachlansneff.)</li>
</ul>
<h2 id="acknowledgements-1"><a class="header" href="#acknowledgements-1">Acknowledgements</a></h2>
<p><a href="https://github.com/modwizcode">@modwizcode</a>, <a href="https://github.com/Kaucasus">@Kaucasus</a>, and <a href="https://github.com/lachlansneff">@lachlansneff</a> provided valuable feedback while this RFC was being drafted.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2023-08-22</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/2">amaranth-lang/rfcs#2</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth/issues/872">amaranth-lang/amaranth#872</a></li>
</ul>
<h1 id="interface-definition-library-rfc"><a class="header" href="#interface-definition-library-rfc">Interface definition library RFC</a></h1>
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<p>Add standard ways of declaring that a component of a design conforms to a particular interface and connecting components with complementary interfaces together, to fill the other of the two major use cases of <code>Record</code> while avoiding its downsides.</p>
<p>See also <a href="0001-aggregate-data-structures.html">RFC #1</a>.</p>
<h2 id="motivation-1"><a class="header" href="#motivation-1">Motivation</a></h2>
<p>Digital designs are composed of densely packed components that communicate with each other using well-defined interfaces. Mechanisms to denote the boundary of a component, to ensure that a component complies to a specified interface, and to make reliable connections between components are essential.</p>
<p>Currently, Amaranth provides none of these mechanisms. A component implemented in Amaranth, however well-defined conceptually, has no more external structure than a loose collection of <code>Signal</code>s assigned to its attributes; and whether any one of them is a part of the interface or the implementation is up to a guess. Even when an interface is described using <code>amaranth.hdl.rec.Layout</code>, such a description cannot be used to verify even the simplest aspects of compliance, such as presence of fields. Although building components by composing smaller components together is ubiquitous, <code>amaranth.hdl.rec.Layout</code> is not able to compose their interface with the same ease. Connecting components using <code>amaranth.hdl.rec.Record.connect</code> is difficult enough that it sees very little use.</p>
<p>Originally, <code>Record</code> was aimed at solving many of these issues. However, it has multiple major drawbacks:</p>
<ol>
<li>
<p><code>Record</code> attempts to do too much: it is both a mechanism for <em>controlling representation</em> (including implicitly casting a record to a value) and a mechanism for <em>defining interfaces</em> (specifying signal directions and facilitating connections between records).</p>
<p>These mechanisms should be defined separately, since the only aspect they have in common is using a container class that consists of multiple named fields. Conflating the two mechanisms constraints the design space, making addressing the other drawbacks impossible, and the ill-defined scope encourages bugs in downstream code.</p>
</li>
<li>
<p><code>Record</code>'s model of signal directions is too complex. Because it attempts to model both aggregates with controlled representation and interfaces with defined directionality, every signal can have one of the three directions, the third option being non-directed. While this can be applied in a robust way--<a href="https://github.com/chipsalliance/firrtl-spec/releases/latest/download/spec.pdf">FIRRTL</a> has only one aggregate type that it uses for both purposes--this gives rise to a large combination of features and requires handling many edge cases.</p>
</li>
<li>
<p><code>Record</code>'s model of signal directions is too limited. The two static directionalities it has are the confusingly named &quot;fanout&quot; and &quot;fanin&quot;, which really mean &quot;from initiator to target&quot; and &quot;from target to initiator&quot;. This is insufficient to describe common, straightforward interactions such as two components exchanging streams of data across pairs of identical, complementary endpoints.</p>
</li>
<li>
<p><code>Record</code>s are hard to customize. Records create and hold their signals, only providing the caller with an ability to place caller-created signals into individual fields. Signals often need adjustments: primarily setting a reset value or adding a decoder, but sometimes adding attributes or renaming. These adjustments must be performed at the record creation site, which is burdensome.</p>
</li>
<li>
<p><code>Record</code> fields can be (apart from sub-records) only plain signals. In many cases, an interface between components carries structured data rather than opaque bit vectors. It is not possible to define inner structure for record fields other than through a sub-record, and using a sub-record for this means that an application-specific endpoint that defines such structure cannot be connected to a generic endpoint that does not.</p>
</li>
<li>
<p><code>Record</code>s are hard to compose. The natural way to define a record is to call the <code>Record</code> constructor with a layout, but this creates the entire layout hierarchy unless parts of it are replaced; and it requires having the layout of the result in advance.</p>
</li>
<li>
<p><code>Record.connect</code> determines the direction of data flow that it will create by the relative position of the interfaces being connected, with <code>x.connect(y)</code> and <code>y.connect(x)</code> having the oposite polarity of assignments. However, the direction of data flow is defined by the component that exposes the interface. Thus, every call of <code>Record.connect</code> can be done in one of the two very similar ways, one of which is always wrong.</p>
</li>
<li>
<p><code>Record.connect</code> uses wired-OR to gather the &quot;fanin&quot; signals, a feature that exists so that it could be used to connect e.g. Wishbone endpoints together without additional gateware. The assumption that the response signals of inactive endpoints will remain all-zero is, generally, unsound.</p>
</li>
<li>
<p><code>Record.connect</code> manages connections between interfaces with optional signals at the call site using an include/exclude mechanism. However, the semantics of the non-implemented optional signals are a property of the interface, not the connection.</p>
</li>
<li>
<p><code>Record</code> and <code>rec.Layout</code> are often used as base classes. The <code>Record.like</code> facility, frequently used because of the poor ergonomics of <code>rec.Layout</code>, loses this information and returns an instance of the base class; <code>rec.Layout</code> does the same when indexed. As a result, there is little value in defining methods and attributes on the subclass, and <code>Record</code> subclasses are little more than a callable computing a layout.</p>
</li>
<li>
<p>Due to the limitations of <code>Record</code>, one might define a plain Python class that exposes compatible attributes. An instance of such a class cannot be compared to a known <code>rec.Layout</code> nor can it be embedded in another <code>Record</code>.</p>
</li>
<li>
<p><code>Record</code> is value-castable and implements the <code>.eq()</code> protocol. Although useful when all fields are non-directional, using <code>.eq()</code> instead of <code>.connect()</code> when connecting directional interfaces is, generally, unsound. It also reserves commonly used names such as <code>any</code>, <code>all</code>, and <code>matches</code>, and implements arithmetic operations that are rarely if ever used on field containers.</p>
</li>
<li>
<p><code>rec.Layout</code>'s DSL is very amorphous. It passes around variable length tuples. The second element of these tuples (the shape) can be another <code>rec.Layout</code>, which is neither a shape nor a shape-castable object.</p>
</li>
</ol>
<p>Since these drawbacks are entrenched in the public API and make <code>Record</code> nearly useless for defining interfaces, a new mechanism must replace it.</p>
<h2 id="outline-of-the-design-space"><a class="header" href="#outline-of-the-design-space">Outline of the design space</a></h2>
<p>Although some HDLs and IRs (Migen, Chisel, FIRRTL, ...) choose to use the same basic aggregate data type to represent <em>structured data</em> and <em>directional interfaces</em>, these mechanisms are in direct conflict. Complex forms of structured data, such as unions, are incompatible with associating directionality independently with every leaf member; and the non-directional nature of stored data requires complicated and error-prone rules when it can become a part of a directional connection.</p>
<p>Amaranth, instead, opts to include two superficially similar mechanisms for defining and accessing hierarchical aggregate data: <code>amaranth.lib.data</code> (RFC #1) and <code>amaranth.lib.wiring</code> (this RFC). <code>amaranth.lib.data</code> provides <em>data views</em> that reinterpret bit containers as complex aggregates, and entirely avoids directionality. <code>amaranth.lib.wiring</code> provides <em>signatures</em> that give a concrete shape to signals at component boundaries, and always treats them as directional.</p>
<p>When connections are made strictly between an output and a correspondingly named input, interfaces gain a dualistic nature: every connection is made between two interfaces whose port directions are the inverse of each other, and which are identical otherwise. To describe interfaces without repeating oneself, then, one has to pick an arbitrarily preferred directionality (and stick with it). Many interfaces are asymmetric, with data flowing from a source to a sink, or transactions issued from an initiator to a target. Amaranth picks the <em>source</em> or <em>initiator</em> perspective; an interface, examined in isolation, defines as outputs the signals that would be outputs of an initiator (and inputs of a target). Then, when an interface with true (non-flipped) directionality describes a component's output, the same interface with inverse (flipped) directionality symmetrically describes an input.</p>
<p>To eliminate the major usability issues with <code>Record.connect</code>, the interface connection mechanism assigns no precedence to interfaces and has no effect on signal directionality; whether a signal is an input or an output depends only on the interface itself. A connection is only made from an output to a matching input, and any other combination is rejected with a diagnostic. This way, connecting a pair of interfaces always leads to the same outcome, regardless of their order.</p>
<p>The choice to always treat interface signals as directional and to make their directionality dependent only on the interface itself leaves only one aspect of the design open: when and how interface directionality is flipped. The decisions that determine it affect both ergonomics and soundness. <code>Record.connect</code> in effect gives the programmer an option to flip directionality even when it would create an illegal connection. Conversely, <code>rec.Layout</code> provides no such affordance, even though it is necessary for composing components.</p>
<p>To facilitate composing components, the interface's directionality is flipped when it is used as an input, whether a top-level input of a component, or as a constituent of a larger interface. This way, the existing mechanism of annotating the directionality of an interface signal or a module port transparently handles interface composition.</p>
<h2 id="guide-level-explanation"><a class="header" href="#guide-level-explanation">Guide-level explanation</a></h2>
<p>Amaranth designs are made out of components (Python classes implementing <code>Elaboratable</code>) whose attributes include signals. These signals have directions: &quot;in&quot; signals are sampled by the component, while &quot;out&quot; signals are driven by it, or left at their reset value, and are provided to be sampled by other components.</p>
<p>At the moment, these directions are completely informal, and described in the documentation and/or in the signal name as an <code>i_</code> or <code>o_</code> prefix (to make it clearer what the direction is at the point of use, or to disambiguate the ports that would otherwise have identical name):</p>
<pre><code class="language-python">class SequenceSource(Elaboratable):
    &quot;&quot;&quot;
    Ports
    -----
    data : Signal(width), out
    ready : Signal(1), in
    valid : Signal(1), out
    &quot;&quot;&quot;
    def __init__(self, width=16):
        self.data = Signal(width)
        self.ready = Signal()
        self.valid = Signal(reset=1)

    def elaborate(self, platform):
        m = Module()
        with m.If(self.ready):
            m.d.sync += self.data.eq(self.data + 1)
        return m
</code></pre>
<p>The <code>SequenceSource</code> component is implemented as a simple counter producing values for an <em>output stream</em> that is connected to some other component consuming them. On each clock tick, if the consumer is <em>ready</em>, it samples the <em>data</em> (the counter value), and simultaneously with that, the producer advances the data to the next item (the incremented value). Since there is always a next item available and it is ready for consumption on the next clock cycle, the stream always contains <em>valid</em> results.</p>
<blockquote>
<p><strong>Note</strong>
It is not, in general, possible to infer the directions of the signals from the implementationhere, <code>ready</code> and <code>valid</code> have different directions and different intended uses, but they look similar to the Amaranth implementation since they are both undriven in the component.</p>
</blockquote>
<p>This RFC proposes a way of describing signal directions that can be applied to any Python object. In addition to elaboratables, it includes Python objects that are used to group together signals with a similar purpose, such as those that are parts of a bus.</p>
<p>To describe signal directions, only a single addition is needed: the <code>signature</code> property:</p>
<pre><code class="language-python">from amaranth.lib.wiring import Signature, In, Out


class SequenceSource(Elaboratable):
    ...

    signature = Signature({
        &quot;data&quot;: Out(16),
        &quot;ready&quot;: In(1),
        &quot;valid&quot;: Out(1)
    })
</code></pre>
<p>Consider another component that is consuming these values:</p>
<pre><code class="language-python">class NumberSink(Elaboratable):
    ...

    def elaborate(self):
        m = Module()
        processing = Signal()
        m.d.comb += self.ready.eq(~processing)
        with m.If(self.valid &amp; ~processing):
            m.d.sync += processing.eq(1)
        with m.Elif(processing):
            ... # process it somehow

    signature = Signature({
        &quot;data&quot;: In(16),
        &quot;ready&quot;: Out(1),
        &quot;valid&quot;: In(1)
    })
</code></pre>
<p>Currently, the only way (given the tools provided by the language and the standard library) to connect the <em>output stream</em> of the <code>SequenceSource</code> to the <em>input stream</em> of the <code>NumberSink</code> is to do this signal-wise:</p>
<pre><code class="language-python">m = Module()
m.submodules.source = source = SequenceSource()
m.submodules.sink = sink = NumberSink()
m.d.comb += [
    sink.data.eq(source.data),
    source.ready.eq(sink.ready),
    sink.valid.eq(source.valid)
]
</code></pre>
<p>This is tedious, verbose, and error-prone. It is possible to define an application-specific function abstracting this operation, and many applications do, but something this universal should be defined on the language level.</p>
<p>This RFC introduces a way to describe interfaces (collections of directional signals; more on this later) and a single operation: <em>connecting</em>. The code above now transforms into:</p>
<pre><code class="language-python">from amaranth.lib.wiring import connect


m = Module()
m.submodules.source = source = SequenceSource()
m.submodules.sink = sink = NumberSink()
connect(m, sink, source)
</code></pre>
<p>The order of arguments to <code>connect</code> does not matter as the directionality is defined by the components themselves. It could just as well be written as:</p>
<pre><code class="language-python">connect(m, source, sink)
</code></pre>
<p>However, this approach still has flaws. Most importantly, the signature for <code>SequenceSource</code> and <code>NumberSink</code> is written twice, but their <code>signature</code> is exactly the same except that the direction is flipped: <code>In</code> members become <code>Out</code>, and vice versa. To avoid error-prone repetition here, the signature can be defined once:</p>
<pre><code class="language-python">Stream16BitSignature = Signature({
    &quot;data&quot;: Out(16),
    &quot;ready&quot;: In(1),
    &quot;valid&quot;: Out(1)
})
</code></pre>
<p>and then used twice, for both the source and the sink:</p>
<pre><code class="language-python">class SequenceSource(Elaboratable):
    ...

    signature = Stream16BitSignature

class NumberSink(Elaboratable):
    ...

    signature = Stream16BitSignature.flip()
</code></pre>
<p>The <code>Signature.flip()</code> method returns a <em>flipped signature object</em>: a signature object whose members have inverse direction but which is otherwise identical.</p>
<p>Since this approach has reusable signatures defined with a specific direction, it is necessary to make an arbitrary choice: pick the kind of object whose signature will use the non-flipped directions. This RFC picks the object that is the <em>source of data</em> (for stream-like interfaces), the <em>transaction initiator</em> (for bus-like interfaces), and so on to use non-flipped directions by convention.</p>
<p>Although some duplication was eliminated, some more remains: currently, it is necessary to define a stream signature for every kind of stream (a stream of 16-bit values, a stream of RGB colors, and so on). It is possible to define a reusable stream signature by inheriting from the <code>Signature</code> class:</p>
<pre><code class="language-python">class StreamSignature(Signature):
    def __init__(self, payload_shape):
        super().__init__({
            &quot;payload&quot;: Out(payload_shape),
            &quot;ready&quot;: In(1),
            &quot;valid&quot;: Out(1)
        })
</code></pre>
<p>The elaboratables above can then be defined as:</p>
<pre><code class="language-python">class SequenceSource(Elaboratable):
    ...

    signature = StreamSignature(16)

class NumberSink(Elaboratable):
    ...

    signature = StreamSignature(16).flip()
</code></pre>
<p>Usually, elaboratables have more than one interface. For example, a very simple DSP block could sink a stream of signed numbers, take their absolute value, and source a stream of unsigned numbers. It would then have a pair of <code>ready</code>, <code>valid</code>, and <code>payload</code> signals each: one for the input steam, and another for the output stream.</p>
<p>To handle this case, signature's members can be signatures themselves. These members also have directionality; an <code>Out</code> signature leaves the directionality of its members unchanged, while an <code>In</code> signature flips it. The signature method of the processing block could be defined as:</p>
<pre><code class="language-python">class AbsoluteProcessor(Elaboratable):
    ...

    signature = Signature({
        &quot;i&quot;: In(StreamSignature(signed(16))),
        &quot;o&quot;: Out(StreamSignature(unsigned(16)))
    })
</code></pre>
<p>To be compliant with this signature, an <code>AbsoluteProcessor</code> instance must have an <code>i</code> attribute compliant with a <code>StreamSignature(signed(16)).flip()</code>, and an <code>o</code> attribute compliant with a <code>StreamSignature(unsigned(16))</code>. These could be defined manually:</p>
<pre><code class="language-python">class AbsoluteProcessor(Elaboratable):
    def __init__(self):
        self.i = object()
        self.i.payload = Signal(signed(16))
        self.i.ready = Signal()
        self.i.valid = Signal()
        self.i.signature = StreamSignature(signed(16)).flip()

        self.o = object()
        self.o.payload = Signal(unsigned(16))
        self.o.ready = Signal()
        self.o.valid = Signal()
        self.o.signature = StreamSignature(unsigned(16))

    ...
</code></pre>
<p>Once more, to reduce error-prone repetition, the <code>Signature</code> class offers a way to define objects just like the ones created above, making the complete definition be:</p>
<pre><code class="language-python">class AbsoluteProcessor(Elaboratable):
    def __init__(self):
        self.i = StreamSignature(signed(16)).flip().create()
        self.o = StreamSignature(unsigned(16)).create()

    signature = Signature({
        &quot;i&quot;: In(StreamSignature(signed(16))),
        &quot;o&quot;: Out(StreamSignature(unsigned(16)))
    })

    ...
</code></pre>
<p><code>Signature</code> subclasses can also override the <code>create</code> method to add functionality not present in the base class. For example, a signature for a bus such as Wishbone or AXI could return an instance of a class rather than a simple <code>object()</code>, and include attributes indicating which optional features of the bus are enabled.</p>
<p>However, since the interface of <code>AbsoluteProcessor</code> as a whole can itself be described as a signature, it is possible to further shorten it by deriving from <code>component.Component</code> instead of <code>Elaboratable</code>, in which case the attributes will be filled in from the signature automatically:</p>
<pre><code class="language-python">from amaranth.lib.wiring import Component


class AbsoluteProcessor(Component):
    signature = Signature({
        &quot;i&quot;: In(StreamSignature(signed(16))),
        &quot;o&quot;: Out(StreamSignature(unsigned(16)))
    })

    def elaborate(self):
        m = Module()
        with m.If(self.i.payload &gt; 0):
            m.d.comb += self.o.payload.eq(self.i.payload)
        with m.Else():
            # Does not overflow, since -(-32768) [least signed(16)] is less
            # than 65536 [greatest unsigned(16)].
            m.d.comb += self.o.payload.eq(-self.i.payload)
        return m
</code></pre>
<p>Python variable annotations can also be used in cases like the above, where the signature is the same for every instance of the class (i.e. the component is not parameterized during creation):</p>
<pre><code class="language-python">class AbsoluteProcessor(Component):
    i: In(StreamSignature(signed(16)))
    o: Out(StreamSignature(unsigned(16)))

    def elaborate(self):
        m = Module()
        with m.If(self.i.payload &gt; 0):
            m.d.comb += self.o.payload.eq(self.i.payload)
        with m.Else():
            # Does not overflow, since -(-32768) [least signed(16)] is less
            # than 65536 [greatest unsigned(16)].
            m.d.comb += self.o.payload.eq(-self.i.payload)
        return m
</code></pre>
<p>All of the import statements in the code examples above can be replaced with:</p>
<pre><code class="language-python">from amaranth.lib.wiring import *
</code></pre>
<h2 id="reference-level-explanation"><a class="header" href="#reference-level-explanation">Reference-level explanation</a></h2>
<p>This RFC proposes a number of library additions:</p>
<ul>
<li>Adding classes that describe a hierarchy of Amaranth objects (an elaboratable object and the objects containing its interface signals) and ease instantiating such hierarchies.</li>
<li>Adding a function that connects such hierarchies to each other.</li>
</ul>
<p>It also introduces a number of technical terms:</p>
<ul>
<li>A <em>component</em> is an Amaranth elaboratable object.</li>
<li>An <em>interface</em> (a concept) is a shared boundary across which several Amaranth components exchange data. It is comprised of a set of signals and the invairants that govern their use.</li>
<li>An <em>interface object</em> (an implementation of the concept) a Python object that includes:
<ol>
<li>attributes whose value is an Amaranth value-castable, or another interface;</li>
<li>a <code>signature</code> attribute whose value is a <em>signature</em> that is <em>compliant</em> with this object;</li>
<li>a description of the invariants applying to its use (in form of documentation, testbenches, formal tests, etc.).</li>
</ol>
</li>
<li>A <em>signature</em> is a <code>Signature</code> instance describing requirements applicable to a hierarchy of interace objects.</li>
<li>A <em>signature member</em> is a <code>Member</code> instance describing requirements applicable to a single attribute of an interface object. Two kinds of signature members exist: port members (requiring the value of the attribute to be a <code>Signal</code>), and interface members (requiring the value of the attribute to be another interface object).</li>
<li>An object is <em>compliant</em> with a signature (therefore making it an interface object) if every member of the signature corresponds to an attribute of the object whose value fits the requirements.</li>
</ul>
<p>A single elaboratable object will often have several interfaces; e.g. a peripheral can have a CSR and/or Wishbone bus interface, and a pin interface. However, the elaboratable object itself can be an interface object as well, which makes it easy to convert it to Verilog and use standalone since its signature defines the ports the Verilog module needs to have.</p>
<h3 id="interface-description"><a class="header" href="#interface-description">Interface description</a></h3>
<p>Interfaces are described using an enumeration, <code>amaranth.lib.wiring.Flow</code>, and two classes, <code>amaranth.lib.wiring.Member</code> and <code>amaranth.lib.wiring.Signature</code>:</p>
<ul>
<li>
<p><code>Flow</code> is an enumeration with two values, <code>In</code> and <code>Out</code>.</p>
<ul>
<li><code>Flow.__call__(arg, **kwargs)</code> forwards to <code>Member(self, arg, **kwargs)</code>.
<ul>
<li>Thus, <code>Out(unsigned(16), reset=0x1234)</code> is a shorthand for <code>Member(Flow.Out, unsigned(16), reset=0x1234)</code>.</li>
</ul>
</li>
<li><code>flow.flip()</code> flips the value from <code>In</code> to <code>Out</code> and back.</li>
</ul>
</li>
<li>
<p>A <code>Member(flow, ...)</code> object describes a part of an interface. It is immutable.</p>
<ul>
<li>A <code>Member(flow, shape_castable, reset=reset_value)</code> object describes a port with the given shape and flow direction. The returned <code>Member</code> object has:
<ul>
<li>the <code>.flow</code> property be <code>flow</code>;</li>
<li>the <code>.is_port</code> property be <code>True</code>;</li>
<li>the <code>.is_signature</code> property be <code>False</code>;</li>
<li>the <code>.shape</code> property be <code>shape_castable</code>;</li>
<li>the <code>.reset</code> property be <code>reset_value</code>;</li>
<li>the <code>.signature</code> property raise <code>TypeError</code>;</li>
<li>the <code>.dimensions</code> property be <code>()</code>.</li>
</ul>
</li>
<li>A <code>Member(flow, signature)</code> object describes a constituent interface with the given flow direction. If <code>flow</code> is <code>Flow.In</code>, then the actual flow of every port recursively described by <code>signature</code> is the reverse of the stated direction. The returned <code>Member</code> object has:
<ul>
<li>the <code>.flow</code> property be <code>flow</code>;</li>
<li>the <code>.is_port</code> property be <code>False</code>;</li>
<li>the <code>.is_signature</code> property be <code>True</code>;</li>
<li>the <code>.shape</code> property raise <code>TypeError</code>;</li>
<li>the <code>.reset</code> property raise <code>TypeError</code>;</li>
<li>the <code>.signature</code> property return <code>signature</code> if <code>flow</code> is <code>Out</code>, <code>signature.flip()</code> if <code>flow</code> is <code>In</code>.</li>
<li>the <code>.dimensions</code> property be <code>()</code>.</li>
</ul>
</li>
<li><code>member.array(*dimensions)</code> returns a new <code>Member</code> object whose <code>.dimensions</code> property is <code>dimensions</code>, which is any amount of non-negative numbers, and all other properties are the same as those of <code>member</code>. Calling <code>.array()</code> on a member with dimensions prepends the new dimensions before the old ones, for composability.</li>
<li><code>member.flip()</code> returns a new <code>Member</code> object whose <code>.flow</code> property is <code>~member.flow</code>, and all other properties are the same as those of <code>member</code>.</li>
</ul>
</li>
<li>
<p>A <code>Signature(...)</code> object describes an interface comprised of named members: ports and nested interfaces (which themselves are described using signature objects).</p>
<p>The <code>Signature</code> class can be derived from. Instances of <code>Signature</code> itself are termed <em>anonymous signatures</em>, and instances of derived classes are <em>named signatures</em>.</p>
<ul>
<li>A <code>Signature({&quot;name&quot;: Member(...)})</code> object can be constructed from a name to member mapping.</li>
<li><code>signature.members</code> is a mutable mapping that can be used to alter the description of a non-frozen signature.
<ul>
<li><code>signature.members += {...}</code> adds members from the given mapping to <code>signature.members</code> if the names being added are not already used. Raises <code>NameError</code> otherwise.</li>
</ul>
</li>
<li><code>signature.freeze()</code> (or <code>signature.members.freeze()</code>) prevents any further modifications of <code>signature</code> (and in particular <code>signature.members</code>), enabling the caller to rely on a particular layout. It is applied recursively to constituent interfaces.
<ul>
<li>It returns <code>self</code> to aid assignments in class definition like:
<pre><code class="language-python">class X:
    signature = Signature({
        ...
    }).freeze()
</code></pre>
</li>
</ul>
</li>
<li><code>signature.flip()</code> returns a signature where every member is <code>member.flip()</code>ped. The exact object returned is a proxy object that overrides the methods and attributes defined here such that the flow is flipped, and otherwise forwards attribute accesses untouched. That is, <code>signature.x = &lt;value&gt;</code> and <code>signature.flip().x = &lt;value&gt;</code> both define an attribute on the original <code>signature</code> object, and never on the proxy object alone. When calling method <code>signature.f</code> as <code>signature.flip().f</code>, <code>self</code> is the flipped signature.</li>
<li><code>signature.flatten(object)</code> returns an iterator yielding a <code>path, member, value</code> tuples for each of the ports recursively contained in the signature, where:
<ul>
<li><code>path</code> is a tuple of strings or integers indicating the sequence of attribute or index accesses that were used to retrieve <code>value</code> from <code>object</code></li>
<li><code>member</code> is the port member corresponding to <code>value</code>, with the flow flipped as appropriate</li>
<li><code>value</code> is a value-castable object corresponding to the port (usually but not always a <code>Signal</code>)</li>
</ul>
</li>
<li><code>signature.is_compliant(object)</code> checks whether an arbitrary Python object is compliant with this signature. To be compliant with a signature:
<ul>
<li>for every member of the signature, the object must have a corresponding attribute</li>
<li>if the member is a port, the attribute value must be a value-castable such that <code>Value.cast(object.attr)</code> method returns a <code>Signal</code> or a <code>Const</code> that has the same width and signedness, and for signals, is not reset-less and has the same reset value as the member
<ul>
<li>a warning may be emitted if the <code>.shape</code> of the member and the <code>.shape()</code> of <code>object.attr</code> are not equal</li>
</ul>
</li>
<li>if the member is an interface, the attribute value must be compliant with the signature of the member</li>
<li>if the member's <code>dimensions</code> are <code>(p, q, ...)</code>, the requirements below hold instead for every result of indexing the attribute value with <code>[i][j]...</code> where <code>i in range(p)</code>, <code>j in range(q)</code>, ...</li>
</ul>
</li>
<li><code>signature.members.create()</code> creates a dictionary of members from it. This is a helper method for the common part of <code>signature.create()</code>. For every member of the signature, the dictionary contains a value equal to:
<ul>
<li>If the member is a port, <code>Signal(member.shape, reset=member.reset)</code>.</li>
<li>If the member is a signature, <code>member.signature.create()</code> for <code>Out</code> members, and <code>member.signature.flip().create()</code> for <code>In</code> members.</li>
</ul>
</li>
<li><code>signature.create()</code> creates an interface object from this signature. To do this, it calls the constructor of <code>Interface</code> described below. This method is expected to be routinely overridden in <code>Signature</code> subclasses to instantiate subclasses of <code>Interface</code>.</li>
</ul>
</li>
</ul>
<p>All of the methods that can be called on <code>signature</code> can be called on the object returned by <code>signature.flip()</code>, and <code>self</code> in that case is <code>signature.flip()</code>. This means that in a method defined on a subclass of <code>Signature</code>, <code>self</code> can be an instance of that type, or an instance of a different type, <code>FlippedSignature</code>, which implements the flipping behavior. In the rare case where it is useful to determine which one it is, it is possible to use <code>type(self) is amaranth.lib.wiring.FlippedSignature</code>.</p>
<p>Any object can be an interface object if it has the appropriate <code>signature</code> property. However, an <code>amaranth.lib.wiring.Interface</code> class is introduced, serving two purposes: instantiating interfaces from an anonymous signature, and serving as a convenient base class for custom interface classes. The <code>Interface</code> class implements only the <code>__init__()</code> method, accepting a signature as a parameter. It assigns <code>self.signature</code> to be that signature, and for each item in <code>signature.members.create()</code> it creates a corresponding attribute on <code>self</code>.</p>
<h3 id="interface-connection"><a class="header" href="#interface-connection">Interface connection</a></h3>
<p>Interface objects may be connected to each other using the <code>amaranth.lib.wiring.connect(m, *objects)</code> free function.</p>
<p>This function connects interface objects that satisfy the following requirements:</p>
<ul>
<li>The set of members (considered by their paths) is exactly the same for each of the objects.</li>
<li>For each given path, all members are either signature members or port members.</li>
<li>For each given path where all members are port members, the width of every member with the same path is equal, though the exact types of the objects returned by the <code>.shape</code> property may differ.</li>
<li>For each given path where all members are port members, the reset values of all members with the same path must match.</li>
<li>For each given path where all members are port members, exactly one member has an <code>Out</code> flow.</li>
</ul>
<p>If the <code>In</code> port member is a signal, it is connected to the <code>Out</code> port member with the same path as follows:</p>
<pre><code class="language-python">m.d.comb += input_port.eq(output_port)
</code></pre>
<p>If the <code>In</code> port member is a constant, no connection is actually made. The <code>Out</code> port member with the same path (if any) must be a constant with the same value.</p>
<h3 id="forwarding-interfaces"><a class="header" href="#forwarding-interfaces">Forwarding interfaces</a></h3>
<p>In some cases, an outer elaboratable object creates an inner elaboratable object and exposes an interface of the inner object as its own:</p>
<pre><code class="language-python">class Outer(Component):
    bus: Out(BusSignature())

    def __init__(self):
        super().__init__()

        self.inner = Inner()

    def elaborate(self, platform):
        m = Module()
        m.d.comb += [
            self.inner.bus.addr.eq(self.bus.addr),
            self.inner.bus.w_data.eq(self.bus.w_data),
            self.bus.r_data.eq(self.inner.bus.r_data),
            # ...
        ]
        return m


class Inner(Component):
    bus: Out(BusSignature())

    ...
</code></pre>
<p>In this case, <code>amaranth.lib.wiring.connect(...)</code> won't help, since an output needs to be connected to an output, and an input to an input.</p>
<p>An additional function <code>amaranth.lib.wiring.flipped(obj)</code> is added to assist in this case. It returns a proxy object <code>obj_flipped</code> where <code>obj_flipped.signature</code> equals <code>obj.signature.flip()</code>, and everything else is forwarded identically otherwise. So, the <code>Outer.elaborate</code> method can be rewritten as:</p>
<pre><code class="language-python">class Outer(Component):
    bus: Out(BusSignature())

    def __init__(self):
        super().__init__()

        self.inner = Inner()

    def elaborate(self, platform):
        m = Module()
        connect(m, flipped(self.bus), self.inner.bus)
        return m
</code></pre>
<h3 id="component-definition"><a class="header" href="#component-definition">Component definition</a></h3>
<p>This RFC in effect introduces a particular kind of elaboratable object: one that has a signature. While connecting an elaboratable as a whole (as opposed to its sub-interfaces) will rarely, if ever, happen, it is still convenient to have an elaboratable define its signature, for three reasons:</p>
<ol>
<li>It is a declaration of intent, separating the signals that are purposefully a part of its interface from ones that just happen to be assigned to attributes, and stating their direction;</li>
<li>It simplifies and standardizes assignment of the interface attributes, making the <code>signature</code> property the single source of truth for the module's interface;</li>
<li>It makes it easy to convert a single standalone elaboratable to Verilog.</li>
</ol>
<p>To this end, a class <code>amaranth.lib.wiring.Component</code> is introduced:</p>
<ul>
<li><code>Component.__init__</code> (typically called as <code>super().__init__()</code>) updates <code>self.__dict__</code> with the result of <code>self.signature.members.create()</code>. (If there is a name conflict, it raises an error.)</li>
<li><code>Component.signature</code> collects PEP 526 variable annotations in the class's method resolution order chain up to <code>Component</code>, if any, and returns a signature object constructed from these, or raises an error otherwise. The signature object is created per-instance, not per-class, so that it can be safely mutated if this is a part of the workflow.</li>
</ul>
<h2 id="alternatives-and-rationale"><a class="header" href="#alternatives-and-rationale">Alternatives and rationale</a></h2>
<ul>
<li>
<p>Do nothing. <code>Record</code> will continue to be used alongside the continued proliferation of ad-hoc implementations of similar functionality, and continue to impair the use of Amaranth components together.</p>
</li>
<li>
<p>Replace the <code>amaranth.lib.wiring.connect</code> free function with a function <code>amaranth.hdl.dsl.Module.connect</code>.</p>
<ul>
<li>It is not a function on <code>amaranth.hdl.dsl.Module</code> to avoid privileging the standard interface library over any other library that may be written downstream. At the moment nothing in <code>amaranth.lib</code> is special in any way other than its name, and preserving this is valuable to the author.</li>
</ul>
</li>
</ul>
<h2 id="naming-questions"><a class="header" href="#naming-questions">Naming questions</a></h2>
<ul>
<li>Should <code>amaranth.lib.wiring</code> be called something else, like <code>amaranth.lib.bus</code> or <code>amaranth.lib.component</code>?
<ul>
<li>bus is short, but not every interface is a bus interface; component (or module, really) puts too much emphasis on the things being interfaced, rather than the interfaces (@jfng)</li>
<li>i wouldn't want the bus keyword to already be taken in my namespaces (@jfng)</li>
<li>I guess my point is mostly that bus is not the opposite of data, but wiring is (@whitequark)</li>
<li>I don't like how long &quot;component&quot; is (@whitequark)</li>
</ul>
</li>
<li>Should <code>Signature.compatible</code> be named something else, like <code>Signature.is_implemented_by</code>, <code>Signature.is_compliant</code>, <code>Signature.complies_with</code>?
<ul>
<li><code>Signature.compatible</code> misses an <code>is_</code> and does not look like a query method (@jfng)</li>
<li>I mean, &quot;compatible&quot; could mean that two signatures could be connected together. when checking if an object is compliant to a signature, directions also matters (@zyp)</li>
<li><code>Signature.complies_with</code> reverses subject and object (@zyp)</li>
<li><code>Signature.is_implemented_by</code> is verbose (@jfng)</li>
</ul>
</li>
<li>Should <code>amaranth.lib.wiring.forward</code> be named something else, like <code>amaranth.lib.wiring.forwarded</code> or <code>amaranth.lib.wiring.forwarding</code> or <code>amaranth.lib.wiring.flip</code> or <code>amaranth.lib.wiring.transpose</code> or ``amaranth.lib.wiring.transpose<code>or</code>amaranth.lib.wiring.inner`?
<ul>
<li>having two essentially unrelated operations called <code>flip</code> when one is already confusing is too much (@whitequark)</li>
<li>reflective programming is a thing (@zyp)</li>
<li>inner(inner(interface)) to flip it back to the original wouldn't make much sense (@zyp)</li>
</ul>
</li>
</ul>
<h2 id="future-work-1"><a class="header" href="#future-work-1">Future work</a></h2>
<ul>
<li>One-to-many connections between interfaces are currently provided only with a fan-out topology: a single interface with output members only can be connected with multiple interfaces with input members only. This avoids the question of what to do with an input that must be driven by multiple outputs. The interface library could be enriched by adding a small amount of fixed fan-in topologies, e.g. wired-OR and wired-AND, specified as a <code>Member()</code> constructor parameter that must match between all of the respective members.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2023-02-27</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/3">amaranth-lang/rfcs#3</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth/issues/756">amaranth-lang/amaranth#756</a></li>
</ul>
<h1 id="enumeration-shapes"><a class="header" href="#enumeration-shapes">Enumeration shapes</a></h1>
<blockquote>
<p><strong>Amendments</strong>
The behavior described in this RFC was updated by <a href="0004-const-castable-exprs.html">RFC #4</a>.</p>
</blockquote>
<h2 id="summary-2"><a class="header" href="#summary-2">Summary</a></h2>
<p>Allow explicitly specifying shape for enumerations as an alternative to implicitly inferring it.</p>
<h2 id="motivation-2"><a class="header" href="#motivation-2">Motivation</a></h2>
<p>Hardware development includes a lot of enumerated values, so first class support for enumerations is important, and so is integration with the standard Python mechanisms for specifying enumerations.</p>
<p>Amaranth accepts <code>enum.Enum</code> subclasses anywhere a shape is expected, and <code>enum.Enum</code> instances anywhere a value is expected:</p>
<pre><code class="language-python">&gt;&gt;&gt; from amaranth import *
&gt;&gt;&gt; from enum import Enum
&gt;&gt;&gt; class Kind(Enum):
...     MUL = 0
...     ADD = 1
...     SUB = 2
...
&gt;&gt;&gt; Shape.cast(Kind)
unsigned(2)
&gt;&gt;&gt; Value.cast(Kind.SUB)
(const 2'd2)
</code></pre>
<p>However, this does not cover an important use case: a enumeration where many values are reserved. For example, if the <code>Kind</code> enumeration above may need to be extended in the future, it would be necessary to reserve space for additional values, which may require additional storage bits. Right now there is no way to specify that <code>Kind</code> should be cast to e.g. <code>unsigned(4)</code>.</p>
<h2 id="guide-level-explanation-1"><a class="header" href="#guide-level-explanation-1">Guide-level explanation</a></h2>
<p>The Amaranth standard library module, <code>amaranth.lib.enum</code> can be used as a drop-in replacement for the Python standard library <code>enum</code> module. It exports the same classes as the ones provided by Python's <code>enum</code> (namely <code>Enum</code>, <code>Flag</code>, <code>IntEnum</code>, and <code>IntFlag</code>) and provides the same functionality, adding the possibility of specifying a shape for the enumeration when it is defined:</p>
<pre><code class="language-python">&gt;&gt;&gt; from amaranth.lib.enum import Enum
&gt;&gt;&gt; class Kind(Enum, shape=unsigned(4)):
...    MUL = 0
...    ADD = 1
...    SUB = 2
...
&gt;&gt;&gt; Shape.cast(Kind)
unsigned(4)
&gt;&gt;&gt; Value.cast(Kind.SUB)
(const 4'd2)
</code></pre>
<p>If the <code>shape=</code> keyword argument is not specified, the enumeration is treated exactly the same as the corresponding standard Python class.</p>
<p>If the values specified for the members are not representable with the explicitly provided shape, a warning is emitted:</p>
<pre><code class="language-python">&gt;&gt;&gt; class Funct3(Enum, shape=unsigned(3)):
...     SUB = 8
...
&lt;stdin&gt;:1: RuntimeWarning: Value of enumeration member &lt;Funct3.SUB: 8&gt; will be truncated to enumeration shape unsigned(3)
&gt;&gt;&gt; class Funct3(Enum, shape=unsigned(3)):
...     SUB = -1
...
&lt;stdin&gt;:1: RuntimeWarning: Value of enumeration member &lt;Funct3.SUB: -1&gt; is signed, but enumeration shape is unsigned(3)
</code></pre>
<p>A shape that is specified for a base class will be inherited in subclasses:</p>
<pre><code class="language-python">&gt;&gt;&gt; class Enum3(Enum, shape=unsigned(3)): pass
...
&gt;&gt;&gt; class Funct3(Enum3):
...     SUB = 2
...
&gt;&gt;&gt; Shape.cast(Funct3)
unsigned(3)
</code></pre>
<p>If a enumeration without an explicitly defined shape is used in a concatenation, a warning is emitted:</p>
<pre><code class="language-python">&gt;&gt;&gt; class Kind(Enum):
...     ADD = 1
...
&gt;&gt;&gt; Cat(Kind.ADD)
&lt;stdin&gt;:1: SyntaxWarning: Argument #1 of Cat() is an enumeration Kind.ADD without a defined shape used in bit vector context; define the enumeration by inheriting from the class in amaranth.lib.enum and specifying the 'shape=' keyword argument
(cat (const 1'd1))
</code></pre>
<h2 id="reference-level-explanation-1"><a class="header" href="#reference-level-explanation-1">Reference-level explanation</a></h2>
<p>The Amaranth standard library module, <code>amaranth.lib.enum</code>, exports all of the public names of the Python standard library <code>enum</code> module. The <code>EnumMeta</code> class adds the functionality for storing and casting to shapes, and inherits from <code>ShapeCastable</code>. The <code>Enum</code>, <code>Flag</code>, <code>IntEnum</code>, and <code>IntFlag</code> classes in this module derive from <code>enum.Enum</code>, <code>enum.Flag</code>, <code>enum.IntEnum</code>, and <code>enum.IntFlag</code> respectively, and use <code>amaranth.lib.enum.EnumMeta</code> as their metaclass, which makes subclasses of <code>amaranth.lib.enum.Enum</code>, etc be instances of <code>ShapeCastable</code>.</p>
<p>When a new <code>amaranth.lib.enum.Enum</code> subclass is defined, <code>amaranth.lib.enum.EnumMeta.__new__</code> checks that the enumeration members are valid (currently, Amaranth requires these to be integers), and if the <code>shape=</code> argument is provided, stores it in an internal attribute. Importantly, the attribute is only set if the argument is provided, making it possible to distinguish these cases later. It also checks that all of the members can be represented by the given shape.</p>
<p>When an <code>amaranth.lib.enum.Enum</code> subclass is cast to a shape, if the internal attribute is set, the shape in it is returned. Otherwise it is cast to a shape using exactly the same logic as what <code>Shape.cast</code> uses for <code>enum.Enum</code> subclasses.</p>
<p>When an instance of a <code>enum.Enum</code> subclass is used in a concatenation, and it is not an instance of <code>ShapeCastable</code>, or if it lacks the <code>_amaranth_shape_</code> attribute, a warning is emitted. This approach avoids a circular dependency between <code>amaranth.hdl.ast</code> and <code>amaranth.lib.enum</code>.</p>
<h2 id="drawbacks-1"><a class="header" href="#drawbacks-1">Drawbacks</a></h2>
<ul>
<li>Introducing a new standard library module increases the API surface.</li>
<li>The names of enumeration base classes are the same as the standard library enumeration base classes, which may be confusing.</li>
<li>Deriving from a different class requires changes to the enumeration at its point of definition, meaning that it is not possible to annotate a enum that comes from an external library with an Amaranth shape.</li>
</ul>
<h2 id="rationale-and-alternatives"><a class="header" href="#rationale-and-alternatives">Rationale and alternatives</a></h2>
<p>Ultimately, this feature boils down to defining an internal variable on an enum, which is then used by <code>Shape.cast</code> and other core Amaranth code. There are a few possible options for doing this.</p>
<ol>
<li>
<p>Special class variable:</p>
<pre><code class="language-python">class SomeEnum(enum.Enum):
    _amaranth_shape_ = unsigned(4)
</code></pre>
</li>
<li>
<p>Class decorator:</p>
<pre><code class="language-python">@amaranth.shape(unsigned(4))
class SomeEnum(enum.Enum):
</code></pre>
</li>
<li>
<p>Class keyword argument (this proposal):</p>
<pre><code class="language-python">class SomeEnum(amaranth.lib.enum.Enum, shape=unsigned(4)):
</code></pre>
</li>
</ol>
<p>Alternative (1) has the following drawbacks:</p>
<ul>
<li>It is not possible to check that the enumeration members can be represented by the specified shape at the point of definition.</li>
<li>It exposes what should be an implementation detail to the user.</li>
<li>The documentation for the standard <code>enum</code> module does not specify whether it's OK to use <code>_sunder_</code> names for one's own purposes, but it would have to be a part of the stable API.</li>
</ul>
<p>Its advantages are:</p>
<ul>
<li>No additional methods or classes in the API surface.</li>
<li><code>_amaranth_shape_</code> makes it immediately clear what's going on.</li>
<li>The variable can be defined on any enum, even an external one.</li>
</ul>
<p>Alternative (2) has the following drawbacks:</p>
<ul>
<li>It's not clear where the <code>shape</code> decorator should be. It can only be applied to enums, but there's no enum-specific namespace in Amaranth core to put it into.</li>
<li><code>SomeEnum</code> would inherit from the standard <code>Enum</code> class and therefore <code>isinstance(SomeEnum, ShapeCastable)</code> would be <code>False</code> unless <code>ShapeCastable.__instancecheck__</code> is overridden to fix that.</li>
</ul>
<p>Its advantages are:</p>
<ul>
<li>The decorator can be applied to an external enum.</li>
</ul>
<p>Alternative (3) has the drawbacks specified above, and the following advantages:</p>
<ul>
<li><code>isinstance(SomeEnum, ShapeCastable)</code> naturally works.</li>
<li>As a consequence, no additional code is required in the core language. All of the functionality necessary for the feature to work lives in <code>amaranth.lib.enum</code>.</li>
<li>The <code>shape</code> argument matches <code>Signal(shape=)</code> (even though no one uses the keyword form) and works the way one would naturally expect.</li>
<li>Uses of <code>import enum</code> can be transparently replaced with <code>from amaranth.lib import enum</code> without updating the call sites, making the migration as easy as the other alternatives.</li>
</ul>
<h2 id="prior-art"><a class="header" href="#prior-art">Prior art</a></h2>
<p>None.</p>
<h2 id="unresolved-questions"><a class="header" href="#unresolved-questions">Unresolved questions</a></h2>
<p>None.</p>
<h2 id="future-possibilities"><a class="header" href="#future-possibilities">Future possibilities</a></h2>
<p>None.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2023-02-07</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/4">amaranth-lang/rfcs#4</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth/issues/755">amaranth-lang/amaranth#755</a></li>
</ul>
<h1 id="const-castable-expressions"><a class="header" href="#const-castable-expressions">Const-castable expressions</a></h1>
<h2 id="summary-3"><a class="header" href="#summary-3">Summary</a></h2>
<p>Define a subset of expressions that are &quot;const-castable&quot; and accept them in contexts where currently only integers and enumerations with integer values are accepted.</p>
<h2 id="motivation-3"><a class="header" href="#motivation-3">Motivation</a></h2>
<p>In certain contexts, Amaranth requires a constant to be used. These contexts are: <code>with m.Case(...):</code>, <code>Value.matches(...)</code>, and the value of an enumeration member that is being cast to a value.</p>
<p>Currently, only integers and enumeration members with integer values are considered constants. However, this is too limiting. For example, when developing a CPU, one might want to define control signals for several functional units and combine them into instructions, or conversely, match an instruction against a combination of control signals:</p>
<pre><code class="language-python">class Func(Enum):
    ADD = 0
    SUB = 1

class Src(Enum):
    MEM = 0
    REG = 1

class Instr(Enum):
    ADD  = Cat(Func.ADD, Src.MEM)
    ADDI = Cat(Func.ADD, Src.REG)
    ...

with m.Switch(instr):
    with m.Case(Cat(Func.ADD, Src.MEM)):
        ...
</code></pre>
<p>Currently, all of these cases would produce syntax errors.</p>
<p>There is a private <code>Value._as_const</code> method. It is not used internally, however Amaranth developers have started using it due to unmet needs. Removing it without providing a replacement would be disruptive, and will result in downstream codebases defining their own equivalent.</p>
<h2 id="guide-level-explanation-2"><a class="header" href="#guide-level-explanation-2">Guide-level explanation</a></h2>
<p>In any context where a constant is accepted (<code>with m.Case(...):</code>, <code>Value.matches(...)</code>, and the value of an enumeration member), a &quot;const-castable&quot; expression can be used. The following expressions are const-castable:</p>
<ul>
<li><code>int</code>;</li>
<li><code>Const</code>;</li>
<li><code>Cat</code> where all operands are const-castable;</li>
<li>instance of a <code>Enum</code> subclass where the value is const-castable.</li>
</ul>
<p>A const-castable expression can be converted to a <code>Const</code> using <code>Const.cast</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; Const.cast(1)
(const 1'd1)
&gt;&gt;&gt; Const.cast(Cat(1, 0, 1))
(const 3'd5)
&gt;&gt;&gt; Const.cast(Cat(Func.ADD, Src.REG))
(const 2'd2)
</code></pre>
<h2 id="reference-level-explanation-2"><a class="header" href="#reference-level-explanation-2">Reference-level explanation</a></h2>
<p>The <code>Const.cast</code> static method casts its argument to a value and examines it. If it is a <code>Const</code>, it is returned. If it is a const-castable expression, the operands are recursively cast to constants, and the expression is evaluated.</p>
<p>The list of const-castable expressions is:</p>
<ul>
<li><code>Cat</code></li>
</ul>
<p>The <code>m.Case(...)</code> (through the <code>Switch()</code> constructor) and <code>Value.matches(...)</code> methods accept two kinds of operands: const-castable expressions, or a string containing a bit pattern (a sequence of <code>0</code>, <code>1</code>, or <code>-</code> meaning a wildcard).</p>
<p>The <code>Shape.cast</code> method accepts enumerations where all members have const-castable expressions as their values. The shape of an enumeration is a shape with the smallest width that can represent the value of any enumeration member.</p>
<p><a href="0003-enumeration-shapes.html">RFC 3</a>: The <code>EnumMeta.__new__</code> method accepts enumerations where all members have const-castable expressions as their values. The value of each member is the value of the constant resulting from casting the user-provided expression.</p>
<h2 id="drawbacks-2"><a class="header" href="#drawbacks-2">Drawbacks</a></h2>
<ul>
<li>A new language-level concept makes it harder to learn the language.
<ul>
<li>Most developers already have an intuitive understanding of which expressions are const-castable.</li>
</ul>
</li>
<li><code>Const.cast</code> shadows an existing <code>Value.cast</code> method since <code>Const</code> inherits from <code>Value</code>.
<ul>
<li>No one is calling <code>Value.cast</code> through the <code>Const.cast</code> binding.</li>
<li><code>Const.cast</code> has a compatible interface (it returns a <code>Value</code>) and performs a similar function (it calls <code>Value.cast</code> first). However, it's not Liskov-compatible.</li>
</ul>
</li>
</ul>
<h2 id="rationale-and-alternatives-1"><a class="header" href="#rationale-and-alternatives-1">Rationale and alternatives</a></h2>
<p>Alternatives:</p>
<ol>
<li>Do not add this functionality. Developers will define their own const-casting functions, continue to rely on the undocumented and private <code>._as_const()</code> method, or use other workarounds.</li>
<li>Make <code>._as_const()</code> public (i.e. rename it to <code>.as_const()</code>).</li>
<li>Add a new <code>Const.cast</code> method (this option).</li>
</ol>
<p>Alternatives (2) and (3) both introduce a new language-level concept, the only difference is in the interface that is used to access it.</p>
<p>Alternative (3) fits the language better: <code>Value.cast</code> takes something value-castable and returns a <code>Value</code>, <code>Shape.cast</code> takes something shape-castable and returns a <code>Shape</code>, so <code>Const.cast</code> is a logical addition in that it takes something const-castable and returns a <code>Const</code>.</p>
<h2 id="prior-art-1"><a class="header" href="#prior-art-1">Prior art</a></h2>
<p>Rust and C++ provide functionality (<code>const fn</code> and <code>constexpr</code> respectively) for performing computation at compile time, restricted to a strict subset of the full language. In particular, it can be used to initialize constants, which makes it similar to the functionality proposed here.</p>
<p>One challenge these languages face is the question of how large the subset should be. Rust in particular started off heavily restricting <code>const fn</code>, where it did not have any control flow. The functionality was gradually introduced later as needed.</p>
<h2 id="unresolved-questions-1"><a class="header" href="#unresolved-questions-1">Unresolved questions</a></h2>
<p>None.</p>
<h2 id="future-possibilities-1"><a class="header" href="#future-possibilities-1">Future possibilities</a></h2>
<p>Expanding the set of const-castable expressions to include arbitrary arithmetic operations. This RFC limits it to the most requested expression, <code>Cat</code>. This simplifies implementation and reduces the likelihood of introducing bugs in the constant evaluation code, most of which would be almost never used.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2023-02-07</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/5">amaranth-lang/rfcs#5</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth/issues/754">amaranth-lang/amaranth#754</a></li>
</ul>
<h1 id="remove-constnormalize"><a class="header" href="#remove-constnormalize">Remove <code>Const.normalize</code></a></h1>
<h2 id="summary-4"><a class="header" href="#summary-4">Summary</a></h2>
<p>Remove <code>Const.normalize(value, shape)</code>.</p>
<h2 id="motivation-4"><a class="header" href="#motivation-4">Motivation</a></h2>
<p>From the name it is not clear what it is supposed to achieve (it's truncation and inversion according to the shape) and it does not check types of arguments.</p>
<p>We already have <code>Const(value, shape).value</code> and most developers should be aware of it. Having <code>Const.normalize(value, shape)</code> as well provides no benefit over the former. It's also longer.</p>
<h2 id="explanation"><a class="header" href="#explanation">Explanation</a></h2>
<p>The <code>Const.normalize</code> method is deprecated (with the suggestion to use <code>Const().value</code>) and removed.</p>
<h2 id="drawbacks-3"><a class="header" href="#drawbacks-3">Drawbacks</a></h2>
<ul>
<li>Churn.</li>
</ul>
<h2 id="rationale-and-alternatives-2"><a class="header" href="#rationale-and-alternatives-2">Rationale and alternatives</a></h2>
<p>We could keep it. Removing it reduces the API surface and makes the language a bit more elegant.</p>
<h2 id="prior-art-2"><a class="header" href="#prior-art-2">Prior art</a></h2>
<p>None.</p>
<h2 id="unresolved-questions-2"><a class="header" href="#unresolved-questions-2">Unresolved questions</a></h2>
<p>None.</p>
<h2 id="future-possibilities-2"><a class="header" href="#future-possibilities-2">Future possibilities</a></h2>
<p>None.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2023-05-31</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/0006">amaranth-lang/rfcs#0006</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth/issues/681">amaranth-lang/amaranth#681</a></li>
</ul>
<h1 id="crc-generator"><a class="header" href="#crc-generator">CRC generator</a></h1>
<h2 id="summary-5"><a class="header" href="#summary-5">Summary</a></h2>
<p>Add a cyclic redundancy check (CRC) generator to the Amaranth standard library.</p>
<h2 id="motivation-5"><a class="header" href="#motivation-5">Motivation</a></h2>
<p>Computing CRCs is a common requirement in hardware designs as they are used
by a range of communication and storage protocols to detect errors and thereby
ensure data integrity. Because of the standard structure and typical set of
variations used by CRCs, it is readily possible to provide a general-purpose
CRC generator in the standard library which should cover the majority of use
cases efficiently.</p>
<p>See the <a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">Wikipedia page on CRCs</a> for more background and use cases.</p>
<h2 id="guide-level-explanation-3"><a class="header" href="#guide-level-explanation-3">Guide-level explanation</a></h2>
<p>The Amaranth standard library includes a generator for a cyclic redundancy
check (CRC) module, which can be used to compute and/or validate most common
CRCs used by transmission and storage protocols.</p>
<p>There are many different CRC algorithms in use, but they can almost all be
described by the following parameters:</p>
<ul>
<li>The bit width of the CRC, commonly (but not always) a power of 2,</li>
<li>The generator polynomial, represented as an integer where each bit is a 0 or
1 term in a binary-valued polynomial with as many terms as the CRC width,</li>
<li>The initial value of the CRC register, commonly non-zero to allow detection
of additional 0-valued data words at the start of a message,</li>
<li>Whether to process input words least- or most-significant-bit first,
allowing the CRC processing order to match the transmission or storage order
of the data bits,</li>
<li>Whether to flip the final output so that its least-significant-bit becomes
the most-significant bit, set for the same reason as reflecting the input
when the CRC value will also be transmitted or stored with a certain bit
order,</li>
<li>What value, if any, to XOR the output bits with before using the CRC value,
often used to invert all bits of the output.</li>
</ul>
<p>This set of parameters is commonly known as the Williams or Rocksoft model. For
more information, refer to <a href="http://www.ross.net/crc/download/crc_v3.txt">&quot;A Painless Guide to CRC Error Detection Algorithms&quot;</a>.</p>
<p>For a list of parameters to use for standard CRCs, refer to:</p>
<ul>
<li><a href="https://reveng.sourceforge.io/crc-catalogue/all.htm">reveng</a>'s catalogue, which uses the same parameterisation</li>
<li><a href="http://crcmod.sourceforge.net/crcmod.predefined.html">crcmod</a>'s predefined list, but remove the leading <code>1</code> from the
polynomials, XOR the &quot;Init-value&quot; with &quot;XOR-out&quot; to obtain <code>initial_crc</code>,
and where <code>Reversed</code> is <code>True</code>, set both <code>ref_in</code> <strong>and</strong>
<code>ref_out</code> to <code>True</code>.</li>
<li><a href="https://users.ece.cmu.edu/~koopman/crc/">CRC Zoo</a>, which only lists polynomials; use the &quot;explicit +1&quot; form but
remove the leading <code>1</code>.</li>
</ul>
<p>The CRC algorithms described in the <a href="https://reveng.sourceforge.io/crc-catalogue/all.htm">reveng</a> catalogue are also available
in the Amaranth standard library in the <code>crc.catalog</code> module.</p>
<p>In Amaranth, the <code>crc.Algorithm</code> class holds the parameters that describe a
CRC algorithm:</p>
<ul>
<li><code>crc_width</code>: the bit width of the CRC</li>
<li><code>polynomial</code>: the generator polynomial of the CRC, excluding an implicit
leading 1 for the &quot;x^n&quot; term</li>
<li><code>initial_crc</code>: the initial value of the CRC, loaded when computation of a
new CRC begins</li>
<li><code>reflect_input</code>: if True, input words are bit-reversed so that the least
significant bit is processed first</li>
<li><code>reflect_output</code>: if True, the final output is bit-reversed so that its
least-significant bit becomes the most-significant bit of output</li>
<li><code>xor_output</code>: a value to XOR the output with</li>
</ul>
<p>The <code>crc.Algorithm</code> class may be constructed manually, but for many
commonly used CRC algorithms a predefined instance is available in
the <code>crc.catalog</code> module.</p>
<p>To fully define a CRC computation, the width of input data words to the CRC
must also be specified. This is commonly 8 for processing byte-wise data,
but can be any length greater than 0. The combination of a <code>crc.Algorithm</code>
and the <code>data_width</code> makes a <code>crc.Parameters</code> instance, for example:</p>
<pre><code class="language-python">from amaranth.lib import crc
algo = crc.Algorithm(crc_width=8, polynomial=0x2f, initial_crc=0xff,
                     reflect_input=False, reflect_output=False,
                     xor_output=0xff)
params1 = algo(data_width=8)
params2 = crc.catalog.CRC8_AUTOSAR(data_width=8)
</code></pre>
<p>If not specified, the data width defaults to 8 bits.</p>
<p>The <code>crc.Parameters</code> class can be used to compute CRCs in software with its
<code>compute()</code> method, which is passed an iterable of integer data words and
returns the resulting CRC value.</p>
<pre><code class="language-python">from amaranth.lib import crc
params = crc.catalog.CRC8_AUTOSAR()
assert params.compute(b&quot;123456789&quot;) == 0xdf
</code></pre>
<p>To generate a hardware CRC module, either call <code>create()</code> on <code>crc.Parameters</code>
or manually construct a <code>crc.Processor</code>:</p>
<pre><code class="language-python">from amaranth.lib import crc
algo = crc.Algorithm(crc_width=8, polynomial=0x2f, initial_crc=0xff,
                     reflect_input=False, reflect_output=False,
                     xor_output=0xff)
params = algo(data_width=8)
crc1 = m.submodules.crc1 = crc.Processor(params)
crc2 = m.submodules.crc2 = crc.Catalog.CRC8_AUTOSAR().create()
</code></pre>
<p>The <code>crc.Processor</code> module begins computation of a new CRC whenever its <code>start</code>
input is asserted. Input on <code>data</code> is processed whenever <code>valid</code> is asserted,
which may occur in the same clock cycle as <code>start</code>. The updated CRC value is
available on the <code>crc</code> output on the clock cycle after <code>valid</code>.</p>
<p>With the data width set to 1, a traditional bit-serial CRC is implemented
for the given polynomial in a Galois-type shift register. For larger values
of data width, a similar architecture computes every new bit of the CRC in
parallel.</p>
<p>The <code>match_detected</code> output signal may be used to validate data that contains a
trailing CRC. If the most recently processed word(s) form a valid CRC for all
the data processed since <code>start</code>, the CRC register will always contain a fixed
value which can be computed in advance, and the <code>match_detected</code> output
indicates whether the CRC register currently contains this value.</p>
<h2 id="reference-level-explanation-3"><a class="header" href="#reference-level-explanation-3">Reference-level explanation</a></h2>
<p>The proposed new interface is:</p>
<ul>
<li>A <code>crc.Algorithm</code> class which holds the parameters for a CRC algorithm,
all of which are passed to the constructor:
<ul>
<li><code>crc_width</code>: bit width of the CRC register</li>
<li><code>polynomial</code>: generator polynomial for CRC algorithm</li>
<li><code>initial_crc</code>: initial value of CRC at start of computation</li>
<li><code>reflect_input</code>: if True, input words are bit-reversed</li>
<li><code>reflect_output</code>: if True, output values are bit-reversed</li>
<li><code>xor_output</code>: value to XOR the CRC value with at output</li>
</ul>
</li>
<li><code>crc.Algorithm</code> implements <code>__call__(data_width=)</code> which is used to create
a <code>crc.Parameters</code> instance with the specified data width.</li>
<li>A <code>crc.Parameters</code> class which is constructed using a <code>crc.Algorithm</code> and
a <code>data_width</code>.</li>
<li><code>crc.Parameters</code> has the following methods:
<ul>
<li><code>compute(data)</code> performs a software CRC computation on <code>data</code>, an
iterable of input data words, and returns the CRC value</li>
<li><code>create()</code> returns a <code>crc.Processor</code> instance preconfigured to use
these parameters</li>
<li><code>residue()</code> returns the residue value for these parameters, which is
the value left in the CRC register after processing an entire valid
codeword (data followed by its own valid CRC)</li>
<li><code>algorithm()</code> returns an <code>crc.Algorithm</code> with the same settings as
this <code>crc.Parameters</code> instance</li>
</ul>
</li>
<li>A <code>crc.Processor</code> class which inherits from <code>Elaboratable</code> and implements
the hardware generator</li>
<li>A <code>crc.catalog</code> module which contains instances of <code>crc.Algorithm</code></li>
</ul>
<p>The hardware implementation uses the property that CRCs are linear, and so the
new value of any bit of the CRC register can be found as a linear combination
of the current state and all the input bits. By expressing the CRC computation
as a linear system like this, we can then determine the boolean equation used
to update each bit of the CRC in parallel. A software CRC calculator is
implemented in Python in order to find these logic equations.</p>
<p>The proposed CRC generator is already implemented and available in <a href="https://github.com/amaranth-lang/amaranth/pull/681">PR 681</a>.
The docstrings and comments in it should explain its operation to a suitably
technical level of detail.</p>
<h2 id="drawbacks-4"><a class="header" href="#drawbacks-4">Drawbacks</a></h2>
<p>Users could always write their own CRC or use an external library; Amaranth
does not need to provide one for them. However, since it's a very common
requirement that we can satisfy efficiently for a lot of users, it seems
reasonable to include in the standard library.</p>
<h2 id="rationale-and-alternatives-3"><a class="header" href="#rationale-and-alternatives-3">Rationale and alternatives</a></h2>
<p>As far as I'm aware, the method here is the optimal technique for generating
the logic equations required for this combinatorial CRC generation.</p>
<p>One alternative to the combinatorial logic equations is to store intermediate
values in a lookup table; the table needs to contain a CRC-sized value for
every possible input value, and then the computation required is reduced to a
table lookup, an XOR, and some bit shifts. For single-byte words this approach
may be practical, but it is unlikely to be worthwhile with 16- or 32-bit words.
Additionally, the table approach generally requires a latency of 2 cycles (one
extra to perform the table lookup). It's possible this would give better timing
in some circumstances, but at the cost of block RAM resources and latency.</p>
<h2 id="prior-art-3"><a class="header" href="#prior-art-3">Prior art</a></h2>
<p>The specification chosen for the CRC parameters is a popular de-facto standard,
and importantly the <a href="https://reveng.sourceforge.io/crc-catalogue/all.htm">reveng</a> catalogue lists suitable parameters for a wide
range of standard CRCs.</p>
<p>This particular implementation was written in 2020 and is extracted (with
permission) from a proprietary codebase, where it is used to generate a
variety of CRCs on FPGAs.</p>
<p>One early public example of using Amaranth to generate CRCs is from
<a href="https://gitlab.com/harmoninstruments/harmon-instruments-open-hdl/-/blob/master/Ethernet/CRC.py">Harmon Instruments</a>, also in 2020, which has a similar construction
but does not support the full set of CRC parameters.</p>
<p>In general, I found many examples of implementations of <em>specific</em> CRCs in
other HDLs, but few for generic generators. There are many software libraries
for generating CRCs in most programming languages, but as they are not
generating hardware their implementation details are not as relevant - small
table lookups are popular as the tradeoffs there tend to favour word-at-a-time
computations.</p>
<h2 id="unresolved-questions-3"><a class="header" href="#unresolved-questions-3">Unresolved questions</a></h2>
<ul>
<li>No outstanding unresolved questions.</li>
</ul>
<h2 id="future-possibilities-3"><a class="header" href="#future-possibilities-3">Future possibilities</a></h2>
<ul>
<li>
<p>The data interface uses <code>start</code>, <code>data</code>, and <code>valid</code> signals.
Eventually, this could be replaced with a Stream, once they are finalised.</p>
</li>
<li>
<p>Currently the entire input data word must be valid together; there is no
support for masking some bits off. In particular, such a feature could be
useful for wide data paths where the underlying CRC computation is byte-wise,
for example a 128-bit-wide data stream from a 10GbE MAC where the Ethernet
FCS must be computed over individual bytes. However, the implementation
complexity is high, the use cases seem more niche, and such a feature could
be added in a backwards-compatible later revision.</p>
</li>
<li>
<p>The software CRC computation only supports computing over an entire
set of data. It would be possible to offer an API to permit incremental
updates and finalisation.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2023-05-11</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/8">amaranth-lang/rfcs#8</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth/issues/772">amaranth-lang/amaranth#772</a></li>
</ul>
<h1 id="aggregate-data-structure-extensibility"><a class="header" href="#aggregate-data-structure-extensibility">Aggregate data structure extensibility</a></h1>
<h2 id="summary-6"><a class="header" href="#summary-6">Summary</a></h2>
<p>Provide well-defined extension points for the aggregate data structure library.</p>
<h2 id="motivation-6"><a class="header" href="#motivation-6">Motivation</a></h2>
<p><a href="0001-aggregate-data-structures.html">RFC 1</a> introduces the aggregate data structure library, which allows using any shape-castable object as the shape of a field. Layouts do not consider the specific type of the shape-castable object. However, views do, and depending on whether it's a layout, a subclass of an aggregate class (<code>Struct</code> or <code>Union</code>), or any other shape-castable object, behavior differs:</p>
<pre><code class="language-python">&gt;&gt;&gt; from amaranth import *
&gt;&gt;&gt; from amaranth.lib.data import *
&gt;&gt;&gt; class S(Struct):
...     x: unsigned(1)
...
&gt;&gt;&gt; layout = StructLayout({
...     &quot;a&quot;: unsigned(1),
...     &quot;b&quot;: ArrayLayout(unsigned(2), 4),
...     &quot;c&quot;: S
... })
...
&gt;&gt;&gt; View(layout).a
(slice (sig $signal) 0:1)
&gt;&gt;&gt; View(layout).b
&lt;amaranth.lib.data.View object at 0x7f53e46934c0&gt;
&gt;&gt;&gt; View(layout).c
&lt;__main__.S object at 0x7f53e4693a30&gt;
</code></pre>
<p>At the moment this behavior is not well-defined and it special-cases the aggregate classes defined in <code>amaranth.lib.data</code>.</p>
<h2 id="guide-level-explanation-4"><a class="header" href="#guide-level-explanation-4">Guide-level explanation</a></h2>
<p>Any shape-castable object can be used as the shape of a field in a layout. This includes another layout. If the object is a callable (provides a <code>__call__</code> method), then when a view is accessed, the <code>__call__</code> method will be called with a single argument, the slice of the underlying value, which will be returned by the view. A <code>Layout</code> is a callable that constructs a <code>View</code> from itself and the value.</p>
<h2 id="reference-level-explanation-4"><a class="header" href="#reference-level-explanation-4">Reference-level explanation</a></h2>
<p>The <code>Layout</code> class has a method <code>__call__</code>. <code>layout(value)</code> is equivalent to <code>View(layout, value)</code>.</p>
<p>The <code>View.__getitem__</code> method (and by extension <code>View.__getattr__</code>), after extracting a <code>field</code> from the layout, attempts to call <code>field.shape.__call__(value_slice)</code>, where <code>value_slice</code> is the slice of the underlying value corresponding to the field. If there is no such method, it iteratively calls <code>as_shape()</code> on <code>field.shape</code> or the result of the previous call to <code>as_shape()</code> until an object is returned that has a <code>__call__</code> method, or until an instance of <code>Shape</code> is returned.</p>
<h2 id="drawbacks-5"><a class="header" href="#drawbacks-5">Drawbacks</a></h2>
<ul>
<li>The syntax may be confusing.
<ul>
<li>Using <code>__call__</code> to implement construction is a widespread pattern in Python. Moreover, <code>Struct</code> and <code>Union</code> are classes, whose <code>__call__</code> method forwards to <code>__new__</code>, so implementing this behavior would remove the special case for aggregate base classes without additional code.</li>
</ul>
</li>
</ul>
<h2 id="rationale-and-alternatives-4"><a class="header" href="#rationale-and-alternatives-4">Rationale and alternatives</a></h2>
<p>This design is, as far as the author knows, the smallest possible addition that provides the largest possible extensibility and removes all special casing of aggregate base classes. That it requires no additional functionality to be implemented on the aggregate base classes indicates that it fits well into the existing design.</p>
<p>Alternatives:</p>
<ul>
<li>Do not do this.</li>
</ul>
<h2 id="prior-art-4"><a class="header" href="#prior-art-4">Prior art</a></h2>
<p>None.</p>
<h2 id="unresolved-questions-4"><a class="header" href="#unresolved-questions-4">Unresolved questions</a></h2>
<p>None.</p>
<h2 id="future-possibilities-4"><a class="header" href="#future-possibilities-4">Future possibilities</a></h2>
<p>None.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2023-05-11</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/9">amaranth-lang/rfcs#9</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth/issues/771">amaranth-lang/amaranth#771</a></li>
</ul>
<h1 id="constant-initialization-for-shape-castable-objects"><a class="header" href="#constant-initialization-for-shape-castable-objects">Constant initialization for shape-castable objects</a></h1>
<h2 id="summary-7"><a class="header" href="#summary-7">Summary</a></h2>
<p>Add an extension point to shape-castable objects, for converting constant initializers (typically Python literals) to Amaranth constant expressions.</p>
<h2 id="motivation-7"><a class="header" href="#motivation-7">Motivation</a></h2>
<p><a href="0001-aggregate-data-structures.html">RFC 1</a> specifies that the <code>reset=</code> argument of a <code>View</code> accepts structured data:</p>
<pre><code class="language-python">flt_neg_reset = data.View(float32_layout, reset={&quot;sign&quot;: 1})
</code></pre>
<p>This structured data is internally turned into an integer constant that is supplied to <code>Signal(reset=)</code>. This mechanism is not exposed to Amaranth developers. However, this creates a clear unmet need, since at the moment there is no way to turn a layout and a field-to-value mapping into a constant integer for use elsewhere.</p>
<p>For example, if a signal is created manually and not through the <code>View</code>, this will not work despite looking reasonable (the layout is shape-castable and can be supplied to <code>Signal</code>):</p>
<pre><code class="language-python">flt_neg_reset_signal = Signal(float32_layout, reset={&quot;sign&quot;: 1})
</code></pre>
<h2 id="guide-level-explanation-5"><a class="header" href="#guide-level-explanation-5">Guide-level explanation</a></h2>
<p>Shape-castable objects must, in addition to the mandatory <code>.as_shape()</code> method, implement a mandatory <code>.const(value)</code> method to define how a constant initializer (the reset value of a <code>Signal</code> or <code>View</code>) is converted to an Amaranth constant.</p>
<p>This method is defined by shape-castable objects to convert arbitrary Python objects into Amaranth constants. For example, if a shape-castable object has complex internal structure, it can accept a dictionary with the values to be filled into various bits of this structure. If <code>Shape</code> implemented <code>ShapeCastable</code>, the method would be defined as <code>def const(self, value): return Const(value, self)</code>.</p>
<p>The value returned by this method can be a <code>Const</code> or a value-castable object whose <code>.as_value()</code> will return a <code>Const</code>.</p>
<p>This method can also be directly called by the developer to construct a constant using a given shape-castable object.</p>
<h2 id="reference-level-explanation-5"><a class="header" href="#reference-level-explanation-5">Reference-level explanation</a></h2>
<p>A method <code>def const(self, obj):</code> is added on <code>ShapeCastable</code>.</p>
<p>The <code>Signal(shape, reset=)</code> constructor is changed so that if <code>isinstance(shape, ShapeCastable)</code>, then <code>shape.const(reset)</code> is used instead of <code>reset</code>.</p>
<p>The <code>.const()</code> instance method is implemented on <code>Layout</code> to accept a <code>Sequence</code> or <code>Mapping</code> instance and returns a <code>View</code> over a <code>Const</code> with a bit pattern that has the fields set to the given values. Overlapping fields are written in the order of iteration of the input. If the field shape is a shape-castable object, then the value for that field is computed using <code>Const.cast(value, field.shape)</code>.</p>
<p>The <code>.const()</code> method is implemented on the metaclass of <code>Struct</code> and <code>Union</code> as <code>return View(self, self.as_shape().const(obj))</code>.</p>
<p>The <code>View(..., reset=)</code> constructor is changed to pass <code>reset</code> through to the <code>Signal()</code> constructor.</p>
<h2 id="drawbacks-6"><a class="header" href="#drawbacks-6">Drawbacks</a></h2>
<ul>
<li>Additional method on <code>ShapeCastable</code>.
<ul>
<li>It was clear from the beginning that this functionality will likely be necessary, and we are unlikely to ever add more.</li>
</ul>
</li>
<li>The <code>reset=</code> argument becomes dependently typed.</li>
</ul>
<h2 id="rationale-and-alternatives-5"><a class="header" href="#rationale-and-alternatives-5">Rationale and alternatives</a></h2>
<p>Given:</p>
<pre><code class="language-python">class Point(Struct):
    x: 16
    y: 16
</code></pre>
<p>it is clear that there needs to be some way to go from <code>{&quot;x&quot;: 123, &quot;y&quot;: 456}</code> to <code>Cat(C(123, 16), C(456, 16))</code> without manually writing out the concatenation.</p>
<p>There are two main options for this:</p>
<ol>
<li>Implement a new method, such that <code>Point.const({&quot;x&quot;: 123, &quot;y&quot;: 456})</code> returns a constant of some kind (either an <code>int</code> or a <code>Const</code> or a constant-castable expression).</li>
<li>Implement an additional <code>.__init__()</code> override, such that <code>Point({&quot;x&quot;: 123, &quot;y&quot;: 456})</code> returns a view that has a constant-castable expression as its target.</li>
</ol>
<p>Option (1) has the benefit of making it clear when downstream code is creating a constant (and expects an argument where the nested data must all be constant), and of minimizing useless wrapping/unwrapping of views that would otherwise happen. It is an explicit type conversion (from a literal to <code>Const</code>).</p>
<p>Option (2) avoids introducing new names. It is an implicit type conversion (from a literal to a view, which in this case is <code>Point</code>).</p>
<p>In the end, option (1) seems preferable here since implicit type conversions are easy to unintentionally misuse. It also avoids any clashes with proposed RFC 8.</p>
<h2 id="prior-art-5"><a class="header" href="#prior-art-5">Prior art</a></h2>
<p>None.</p>
<h2 id="unresolved-questions-5"><a class="header" href="#unresolved-questions-5">Unresolved questions</a></h2>
<p>None.</p>
<h2 id="future-possibilities-5"><a class="header" href="#future-possibilities-5">Future possibilities</a></h2>
<p>None.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2023-05-11</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/10">amaranth-lang/rfcs#10</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth/issues/770">amaranth-lang/amaranth#770</a></li>
</ul>
<h1 id="move-repl-to-valuereplicate"><a class="header" href="#move-repl-to-valuereplicate">Move <code>Repl</code> to <code>Value.replicate</code></a></h1>
<h2 id="summary-8"><a class="header" href="#summary-8">Summary</a></h2>
<p>Replace the standalone <code>Repl(value, count)</code> node with <code>value.replicate(count)</code>.</p>
<h2 id="motivation-8"><a class="header" href="#motivation-8">Motivation</a></h2>
<p><code>Repl</code> is a <a href="https://github.com/search?q=%2F%5CbRepl%5Cb%2F+amaranth+language%3Apython&amp;type=code">rarely used</a> construct (it's mostly useful for manual sign extension).</p>
<p>It is currently a first-class entity that has its own AST node and a name in the prelude, mostly for historical reasons (<code>Repl(v, n)</code> is analogous to Verilog's <code>{x{n}}</code>).</p>
<p><code>Repl</code> does not need to be a first-class entity; <code>Repl(x, n)</code> is almost exactly equivalent to <code>Cat(x for x in range(n))</code>. It especially does not need a name in the prelude.</p>
<h2 id="guide-level-explanation-6"><a class="header" href="#guide-level-explanation-6">Guide-level explanation</a></h2>
<p>Use of <code>Repl</code> is deprecated. To replicate a value multiple times, use <code>value.replicate()</code>.</p>
<h2 id="reference-level-explanation-6"><a class="header" href="#reference-level-explanation-6">Reference-level explanation</a></h2>
<p>Direct use of <code>Repl</code> is deprecated. Its implementation is replaced with <code>def Repl(value, count): return Value.cast(value).replicate(count)</code>.</p>
<p>A function <code>Value.replicate(count)</code> is added. It is implemented as <code>Cat(value for _ in range(count))</code>. The <code>Repl</code> AST node is removed.</p>
<h2 id="drawbacks-7"><a class="header" href="#drawbacks-7">Drawbacks</a></h2>
<ul>
<li>Churn.</li>
<li>The proposed implementation makes <code>Value.replicate</code> valid on left-hand side of assignment, with potentially surprising behavior. However, this can be handled by prohibiting multiple assignment to the same bit of a signal in general.</li>
</ul>
<h2 id="rationale-and-alternatives-6"><a class="header" href="#rationale-and-alternatives-6">Rationale and alternatives</a></h2>
<p>Rationale:</p>
<ul>
<li>Fewer names in the prelude is always good.</li>
<li>Unlike with <code>Cat</code> (where <code>Cat()</code> makes sense), <code>Repl</code> does not make sense as a standalone node any more than <code>Part</code> does (and we do not currently export <code>Part</code>).</li>
<li>Despite existing by analogy with <code>{x{n}}</code>, it is currently turned into a concatenation before it reaches the Verilog backend <em>anyway</em>, and any future work will have to reconstruct replication from concatenation in any case.</li>
<li><code>Repl</code> being a dedicated node complicates AST processing for no reason.</li>
</ul>
<p>Alternatives:</p>
<ul>
<li>Do not do this.</li>
</ul>
<h2 id="prior-art-6"><a class="header" href="#prior-art-6">Prior art</a></h2>
<p>None.</p>
<h2 id="unresolved-questions-6"><a class="header" href="#unresolved-questions-6">Unresolved questions</a></h2>
<p>None.</p>
<h2 id="future-possibilities-6"><a class="header" href="#future-possibilities-6">Future possibilities</a></h2>
<ul>
<li>The Verilog backend currently bitblasts what could be a replication. We could detect these and convert them to replications proper.</li>
<li>We could detect code like <code>Cat(x, x).eq(0b11)</code> and warn or reject it.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2023-05-15</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/15">amaranth-lang/rfcs#15</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth/issues/784">amaranth-lang/amaranth#784</a></li>
</ul>
<h1 id="lifting-shape-castable-objects"><a class="header" href="#lifting-shape-castable-objects">Lifting shape-castable objects</a></h1>
<h2 id="summary-9"><a class="header" href="#summary-9">Summary</a></h2>
<p>Make <code>Signal(shape_castable, ...)</code> return <code>shape_castable(Signal(shape_castable.as_shape(), ...))</code>.</p>
<h2 id="motivation-9"><a class="header" href="#motivation-9">Motivation</a></h2>
<p>When Amaranth was a very new language, it did not have any facilities for ascribing type information to data. It had shapes (width and signedness), and it had special handling for <code>range()</code> in the shape position, as well as enumerations. Back then it made sense to have <code>Signal</code>, the single way to define new storage of any kind, to only operate on values (numbers / bit containers).</p>
<p>Today the situation is completely different. Amaranth has first-class support for enumerations in the standard library as well as the standard range of data structures (structs, unions, arrays) via <a href="0001-aggregate-data-structures.html">RFC 1</a> and <a href="0003-enumeration-shapes.html">RFC 3</a>. It provides extensibility through <a href="0008-aggregate-extensibility.html">RFC 8</a> and <a href="0009-const-init-shape-castable.html">RFC 9</a>. Using the existing hooks alone it is possible to extend Amaranth with rich numeric types (fixed-point, complex, potentially even floating-point), and some of these are very likely to end up in the standard library.</p>
<p>All of this new functionality internally wraps a <code>Value</code>. It is so common and useful to initialize e.g. a struct view with a fresh <code>Signal</code> that <code>data.View</code> reexports all of the arguments of the <code>Signal</code> constructors and automatically constructs a <code>Signal</code> if no view target is provided. This works, but ties the two together more than would be ideal, and requires every similar facility to reimplement the functionality itself. What is worse is that it seems to be quite confusing to programmers, since it's not apparent that calling <code>data.View(foo_layout)</code> internally creates a <code>Signal</code>. Furthermore, people want to call <code>Signal(foo_layout)</code> to construct some storage for <code>foo_layout</code>, and that works (<code>foo_layout</code> is shape-castable), but does the wrong thing: the returned object is a <code>Signal</code>, not a <code>data.View</code>.</p>
<p>It would make teaching a lot easier if we could draw an equivalence between a <code>Signal</code> and a variable in a general purpose programming language, and between its shape and a type in a general purpose programming language. Then, no matter what shape-castable object it is, the way to make some storage is <code>Signal(x)</code>. It will also simplify the internals a fair bit.</p>
<p>This change wasn't practical before <a href="0008-aggregate-extensibility.html">RFC 8</a> and <a href="0009-const-init-shape-castable.html">RFC 9</a> laid the groundwork for it, but now it is an obvious extension.</p>
<h2 id="guide-level-explanation-7"><a class="header" href="#guide-level-explanation-7">Guide-level explanation</a></h2>
<p>To include state in a design, use the <code>Signal(shape)</code> constructor, where <code>shape</code> describes the bit layout and possible operations on that state. The <code>reset=</code> argument and the returned value depend on the <code>shape</code> that is provided. If it is <code>signed(N)</code> or <code>unsigned(N)</code> or a built-in enumeration or a <code>range</code>, then a plain <code>Value</code> is returned, and the <code>reset=</code> argument accepts a number, an enumeration member, or a constant. If it is a <code>data.Layout</code>, then a <code>data.View</code> is returned, and the <code>reset=</code> argument accepts a sequence or a mapping, potentially nested for nested layouts. Other shape-castable classes will have their own behavior.</p>
<blockquote>
<p><strong>Warning</strong>
The existing syntax for creating a <code>View</code> with a new <code>Signal</code> underlying it will be removed immediately (it has never been in a release) to resolve an ambiguity over the semantics of <code>__call__</code>.</p>
</blockquote>
<h2 id="reference-level-explanation-7"><a class="header" href="#reference-level-explanation-7">Reference-level explanation</a></h2>
<p>A method <code>def __call__(self, value):</code> is added on <code>ShapeCastable</code>. It must return <code>Value</code> or a <code>ValueCastable</code> instance with the right shape. (Such a method is opportunistically used by <code>data.View</code> for nested views since <a href="0008-aggregate-extensibility.html">RFC 8</a>, however this RFC makes it mandatory for all shape-castable objects.)</p>
<p>The <code>Signal.__call__(shape, ...)</code> method is overridden (on the metaclass) to consider <code>shape</code>. First, a <code>signal</code> is constructed normally with all of the arguments. Afterwards, if <code>shape</code> is a <code>ShapeCastable</code> instance, then <code>shape(signal)</code> is returned. Otherwise <code>signal</code> is returned.</p>
<h2 id="drawbacks-8"><a class="header" href="#drawbacks-8">Drawbacks</a></h2>
<ul>
<li>Increase in language complexity.</li>
<li>More metaclasses.
<ul>
<li><code>Signal</code> is a final class so this is unlikely to go wrong.</li>
</ul>
</li>
<li>A <code>Signal()</code> constructor sometimes returning non-<code>Signal</code> objects can be confusing.</li>
</ul>
<h2 id="rationale-and-alternatives-7"><a class="header" href="#rationale-and-alternatives-7">Rationale and alternatives</a></h2>
<p>There are several arguments in favor of the design:</p>
<ul>
<li>It does not de facto introduce any new methods on protocols, since <code>ShapeCastable.__call__</code> is expected to be implemented by essentially everyone after <a href="0008-aggregate-extensibility.html">RFC 8</a>.</li>
<li>It does not introduce new complexity to <code>Signal.__init__</code>; the logic for handling non-integer reset exists since <a href="0009-const-init-shape-castable.html">RFC 9</a>.</li>
<li>It eliminates unnecessary coupling between <code>data.View</code> (and other similar facilities) and <code>Signal()</code>.</li>
<li>It is a natural extension of the language and has clear parallels to the notion of variables in other languages.</li>
<li>It has been repeatedly requested by users, almost every time someone became familiar with the aggregate data structure design.</li>
</ul>
<p>All of these points are compelling but the last one perhaps the most. The author did not find it a stark enough necessity to introduce themselves but it does seem to be one.</p>
<p>Alternatives:</p>
<ul>
<li>Do not do this. The status quo is acceptable.</li>
</ul>
<h2 id="prior-art-7"><a class="header" href="#prior-art-7">Prior art</a></h2>
<p>This RFC brings the semantics of <code>Signal</code> to be very close to semantics of typed variables in other languages.</p>
<p>&quot;Lifting&quot; in the title of this RFC refers to a <a href="https://wiki.haskell.org/Lifting">concept in functional programming</a> of the same name where a higher order function (<code>Signal</code>, here) is used to generalize an operation over a set of other functions (<code>data.View</code> and other shape-castable objects that implement the <code>__call__</code> protocol, here).</p>
<h2 id="unresolved-questions-7"><a class="header" href="#unresolved-questions-7">Unresolved questions</a></h2>
<ul>
<li>How does this interact with typechecking?
<ul>
<li>This is a straightforward higher order function so it's probably fine.</li>
</ul>
</li>
</ul>
<h2 id="future-possibilities-7"><a class="header" href="#future-possibilities-7">Future possibilities</a></h2>
<p>This RFC is the final one in a chain that started with <a href="0001-aggregate-data-structures.html">RFC 1</a>.</p>
<p>Enumerations and ranges could be adjusted such that something other than <code>Value</code> is returned. This creates backwards compatibility concerns though.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2023-08-22</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/18">amaranth-lang/rfcs#18</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth/issues/873">amaranth-lang/amaranth#873</a></li>
</ul>
<h1 id="reorganize-vendor-platforms"><a class="header" href="#reorganize-vendor-platforms">Reorganize vendor platforms</a></h1>
<h2 id="summary-10"><a class="header" href="#summary-10">Summary</a></h2>
<p>Update <code>amaranth.vendor</code> namespace so that instead of:</p>
<pre><code class="language-python">from amaranth.vendor.lattice_ecp5 import LatticeECP5Platform
</code></pre>
<p>you would write:</p>
<pre><code class="language-python">from amaranth.vendor import LatticeECP5Platform
</code></pre>
<h2 id="motivation-10"><a class="header" href="#motivation-10">Motivation</a></h2>
<p>Vendor names are ever-changing. Xilinx was bought by AMD and the brand has been phased out. Altera was bought by Intel and the brand has been phased out. SiliconBlue has been bought by Lattice (a long time ago) and the brand has <em>long</em> been phased out but still remains as &quot;SB&quot; in <code>SB_LUT</code> primitive name.</p>
<p>In addition, we attempt to group FPGA families into a single file, like <code>vendor.lattice_machxo2_3l</code> that has been renamed from <code>vendor.lattice_machxo2</code>. This will likely include another FPGA family as soon as it becomes available.</p>
<p>By tying module (and file) names to brand names we create churn. Every Amaranth release so far has included renaming of both platform class names and module names. This causes additional downstream breakage and annoys designers using Amaranth.</p>
<h2 id="guide-level-explanation-8"><a class="header" href="#guide-level-explanation-8">Guide-level explanation</a></h2>
<p>To target your FPGA-based project for a particular FPGA family, import the platform class corresponding to the FPGA family from <code>amaranth.vendor</code>, e.g.:</p>
<pre><code class="language-python">from amaranth.vendor import LatticeECP5Platform
</code></pre>
<h2 id="reference-level-explanation-8"><a class="header" href="#reference-level-explanation-8">Reference-level explanation</a></h2>
<p>All of the <code>amaranth.vendor.name</code> modules are renamed to <code>amaranth.vendor._internal_name</code>.</p>
<p>Python allows <code>__getattr__</code> to be present in modules:</p>
<pre><code>$ cat &gt;x.py
def __getattr__(self, name):
    return f&quot;__getattr__({name!r})&quot;
$ python
&gt;&gt;&gt; from x import abc
&gt;&gt;&gt; abc
&quot;__getattr__('abc')&quot;
</code></pre>
<p>This allows us to make all the platform classes be present as-if they were defined in the <code>amaranth.vendor</code> modules, while retaining all of the benefits of having them in their own <code>amaranth.vendor._internal_name</code> module, such as lazy loading.</p>
<h2 id="drawbacks-9"><a class="header" href="#drawbacks-9">Drawbacks</a></h2>
<ul>
<li>Churn.</li>
<li>A somewhat unusual loading mechanism could cause confusion.</li>
</ul>
<h2 id="rationale-and-alternatives-8"><a class="header" href="#rationale-and-alternatives-8">Rationale and alternatives</a></h2>
<p>Decoupling marketing/brand names from technical names is increasingly important as Amaranth evolves and supports more FPGA families. It allows us to maintain any internal hierarchy we want without it having any impact on downstream code, which solely operates on names imported from <code>amaranth.vendor</code>.</p>
<h2 id="prior-art-8"><a class="header" href="#prior-art-8">Prior art</a></h2>
<p>None.</p>
<h2 id="unresolved-questions-8"><a class="header" href="#unresolved-questions-8">Unresolved questions</a></h2>
<p>None.</p>
<h2 id="future-possibilities-8"><a class="header" href="#future-possibilities-8">Future possibilities</a></h2>
<p>None.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2023-08-22</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/19">amaranth-lang/rfcs#19</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth/issues/874">amaranth-lang/amaranth#874</a></li>
</ul>
<h1 id="remove-amaranthlibscheduler"><a class="header" href="#remove-amaranthlibscheduler">Remove <code>amaranth.lib.scheduler</code></a></h1>
<h2 id="summary-11"><a class="header" href="#summary-11">Summary</a></h2>
<p>Remove <code>amaranth.lib.scheduler</code> and the only class <code>RoundRobin</code> in it.</p>
<h2 id="motivation-11"><a class="header" href="#motivation-11">Motivation</a></h2>
<p>This module is not used in the sole place for which it was added (Amaranth SoC), it is not especially useful, and it has not undergone proper community review when it was added.</p>
<h2 id="guide-level-explanation-9"><a class="header" href="#guide-level-explanation-9">Guide-level explanation</a></h2>
<p>The module <code>amaranth.lib.scheduler</code> and the sole class <code>RoundRobin</code> in it is removed. To continue using it, copy the contents of the module into your own project.</p>
<h2 id="reference-level-explanation-9"><a class="header" href="#reference-level-explanation-9">Reference-level explanation</a></h2>
<p>The class <code>amaranth.lib.scheduler.RoundRobin</code> is deprecated in Amaranth 0.4 and removed in Amaranth 0.5.</p>
<h2 id="drawbacks-10"><a class="header" href="#drawbacks-10">Drawbacks</a></h2>
<ul>
<li>Churn.</li>
</ul>
<h2 id="rationale-and-alternatives-9"><a class="header" href="#rationale-and-alternatives-9">Rationale and alternatives</a></h2>
<ul>
<li>This module is out of place in the standard library.</li>
<li>It has not seen much use and is trivially implemented outside of it.</li>
<li>Downstream consumers tend to inline the logic anyway.</li>
<li>It does not seem like there would be any other uses for the <code>amaranth.lib.scheduler</code> module since any other scheduling algorithm would be more closely tied to the consumer.</li>
</ul>
<h2 id="unresolved-questions-9"><a class="header" href="#unresolved-questions-9">Unresolved questions</a></h2>
<p>None.</p>
<h2 id="future-possibilities-9"><a class="header" href="#future-possibilities-9">Future possibilities</a></h2>
<p>None.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2023-08-22</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/20">amaranth-lang/rfcs#20</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth/issues/875">amaranth-lang/amaranth#875</a></li>
</ul>
<h1 id="deprecate-non-fwft-fifos"><a class="header" href="#deprecate-non-fwft-fifos">Deprecate non-FWFT FIFOs</a></h1>
<h2 id="summary-12"><a class="header" href="#summary-12">Summary</a></h2>
<p>Deprecate non-first-word-fall-through FIFOs.</p>
<h2 id="motivation-12"><a class="header" href="#motivation-12">Motivation</a></h2>
<p>Currently, FIFOs in <code>amaranth.lib.fifo</code> have two incompatible interfaces: FWFT (first word fallthrough) and non-FWFT. The incompatibility concerns only the read half. FWFT FIFOs have <code>r_data</code> valid when <code>r_rdy</code> is asserted. Non-FWFT FIFOs have <code>r_data</code> valid only after strobing <code>r_en</code>, if the FIFO was empty previously.</p>
<p>Non-FWFT interface is awkward and is essentially never used. It is a holdover from Migen and its implementation details that was included for compatibility. There are three downsides to having it:</p>
<ol>
<li>Having non-FWFT FIFOs requires every consumer of the FIFO interface to check for <code>fwft</code> when interacting with the FIFO and either asserting that it is <code>True</code>, or adding a code path to handle it. No one does this.</li>
<li>The FWFT interface is directly compatible with streams and allows us to add e.g. <code>r_stream</code> and <code>w_stream</code> to existing FIFOs without adding a wrapper such as <code>stream.FIFO</code>. It also makes any custom FIFOs defined downstream of Amaranth stream-enabled.</li>
<li>The notion of FWFT vs non-FWFT FIFOs is confusing and difficult to understand. E.g. the author of this RFC wrote both <code>lib.fifo</code> and the Glasgow FIFO code, and she misused the <code>fwft</code> argument in the latter.</li>
</ol>
<h2 id="guide-level-and-reference-level-explanation"><a class="header" href="#guide-level-and-reference-level-explanation">Guide-level and reference-level explanation</a></h2>
<p>In the next version, instantiating <code>SyncFIFO(fwft=False)</code> emits a deprecation warning. In addition, <code>FIFOInterface</code>'s <code>fwft</code> parameter now defaults to <code>True</code>. Other FIFOs have no non-FWFT variant in the first place.</p>
<p>In the version after that, there is no way to instantiate <code>SyncFIFO(fwft=False)</code>. The feature and all references to it are removed in their entirety.</p>
<h2 id="implementation-considerations"><a class="header" href="#implementation-considerations">Implementation considerations</a></h2>
<p>At the moment, <code>SyncFIFOBuffered</code> is implemented as a register in the output of <code>SyncFIFO(fwft=False)</code>. The implementation will need to be rewritten.</p>
<h2 id="drawbacks-11"><a class="header" href="#drawbacks-11">Drawbacks</a></h2>
<ul>
<li>Churn.</li>
<li>There will be no alternative to <code>SyncFIFO(fwft=False)</code>.</li>
</ul>
<h2 id="rationale-and-alternatives-10"><a class="header" href="#rationale-and-alternatives-10">Rationale and alternatives</a></h2>
<ul>
<li>It is feasible to extract <code>SyncFIFO(fwft=False)</code> into its own module that may be used by downstream code that needs non-FWFT FIFOs. It would not implement <code>FIFOInterface</code>.
<ul>
<li>There is no reason the <code>SyncFIFO</code> class could not be copied into downstream code as it is.</li>
</ul>
</li>
<li>It is possible to wrap FIFOs in the stream library in a way that ensures only FWFT FIFOs are used.
<ul>
<li>Let's not create pointless wrappers.</li>
</ul>
</li>
</ul>
<h2 id="prior-art-9"><a class="header" href="#prior-art-9">Prior art</a></h2>
<p>Not relevant.</p>
<h2 id="unresolved-questions-10"><a class="header" href="#unresolved-questions-10">Unresolved questions</a></h2>
<p>None.</p>
<h2 id="future-possibilities-10"><a class="header" href="#future-possibilities-10">Future possibilities</a></h2>
<p>This RFC primarily exists to enable better stream interface integration.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2023-08-22</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/21">amaranth-lang/rfcs#21</a></li>
</ul>
<h1 id="patch-releases"><a class="header" href="#patch-releases">Patch releases</a></h1>
<h2 id="summary-13"><a class="header" href="#summary-13">Summary</a></h2>
<p>Change Amaranth versioning from <code>major.minor</code> to <code>major.minor.patch</code> after version 0.4, and define the backport policy for patch releases.</p>
<h2 id="motivation-13"><a class="header" href="#motivation-13">Motivation</a></h2>
<p>Amaranth 0.3 was released on 2021-12-16; almost two years ago. Several important bugs have been fixed in <code>main</code> since, most notably depending on a version of <code>Jinja2</code> that is no longer installable. At the moment the policy is to issue only <code>major.minor</code> releases, which was OK in the early days but no longer fits the project.</p>
<p>We should change the policy that is used for the next Amaranth release and later ones.</p>
<h2 id="explanation-1"><a class="header" href="#explanation-1">Explanation</a></h2>
<p>Amaranth feature releases all have the version of <code>major.minor.0</code>. The policy for these releases is unchanged and is tied to our two-step process for making breaking changes.</p>
<p>In addition to these releases, Amaranth now has bug-fix releases with the <code>major.minor.patch</code> versions. These are intended to address the need of the community to have bugs fixed before a next feature release can be made, and the policy is designed to minimize developer time spent on them.</p>
<p>Bug-fix releases are made when all of the following conditions are satisfied:</p>
<ul>
<li>There is an issue that is fixed in the <code>main</code> branch.</li>
<li>A member of the community requests this issue to be fixed in a point release.</li>
<li>It is possible to fix the issue such that there is a high degree of confidence that the change will not break existing code using Amaranth with a <code>~=major.minor</code> version constraint.</li>
<li>A community member steps up to backport the fix to the release branch.
<ul>
<li>This could be one of the Amaranth maintainers, or anyone else. Amaranth maintainers have no obligation to back-port any fix.</li>
</ul>
</li>
</ul>
<h2 id="drawbacks-12"><a class="header" href="#drawbacks-12">Drawbacks</a></h2>
<p>This creates additional work for maintainers.</p>
<h2 id="rationale-and-alternatives-11"><a class="header" href="#rationale-and-alternatives-11">Rationale and alternatives</a></h2>
<ul>
<li>It would be possible to backport all feasible fixes as a policy.
<ul>
<li>This would significantly increase maintainer workload.</li>
</ul>
</li>
<li>It is possible to keep the current policy.
<ul>
<li>Because we do not control all of the upstream dependencies (including Python), this seems untenable.</li>
</ul>
</li>
</ul>
<h2 id="prior-art-10"><a class="header" href="#prior-art-10">Prior art</a></h2>
<p>Rust has an even stricter bug-fix release policy: the Rust project only issues patch releases in cases of security issues, widespread miscompilations, or unintentional breaking changes.</p>
<h2 id="unresolved-questions-11"><a class="header" href="#unresolved-questions-11">Unresolved questions</a></h2>
<p>Should Amaranth SoC adopt the same policy?</p>
<h2 id="future-possibilities-11"><a class="header" href="#future-possibilities-11">Future possibilities</a></h2>
<p>Eventually, Amaranth may gain release engineers who will maintain long-living release branches.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2023-08-22</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/22">amaranth-lang/rfcs#22</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth/issues/876">amaranth-lang/amaranth#876</a></li>
</ul>
<h1 id="define-valuecastableshape"><a class="header" href="#define-valuecastableshape">Define <code>ValueCastable.shape()</code></a></h1>
<h2 id="summary-14"><a class="header" href="#summary-14">Summary</a></h2>
<p>Require value-castable objects to have a method that returns their high-level shape.</p>
<h2 id="motivation-14"><a class="header" href="#motivation-14">Motivation</a></h2>
<p><a href="0015-lifting-shape-castables.html">RFC #15</a> advanced the extensibility of the language significantly, but broke constructs like <code>Signal.like(Signal(data.StructLayout(...)))</code>. In addition, not having a well-defined point for returning the high-level shape (i.e. a shape-castable object from which this value-castable object was creaed rather than a <code>Shape</code> instance) causes workarounds such as <code>data.Layout.of</code> to be added to the language and standard library.</p>
<h2 id="explanation-2"><a class="header" href="#explanation-2">Explanation</a></h2>
<p>The <code>ValueCastable</code> interface has a method <code>.shape()</code>. This method returns a shape-castable object. Where possibe, this object should, when passed to <code>Signal</code>, create a value-castable object of the same type.</p>
<p><code>amaranth.lib.data.Layout.of</code> is removed immediately.</p>
<h2 id="drawbacks-13"><a class="header" href="#drawbacks-13">Drawbacks</a></h2>
<ul>
<li>Increased API surface area
<ul>
<li>At one point a commitment was made that the only method <code>ValueCastable</code> will ever define will be <code>as_value</code>. However, radical changes to the language such as <a href="0015-lifting-shape-castables.html">RFC #15</a> make it reasonable to revisit this.</li>
</ul>
</li>
</ul>
<h2 id="rationale-and-alternatives-12"><a class="header" href="#rationale-and-alternatives-12">Rationale and alternatives</a></h2>
<p>This change is the minimal possible one that fixes the problem systemically. Some minor variations in the design are possible:</p>
<ul>
<li>Instead of requiring <code>shape()</code> to be defined (which is a breaking change), this method can be added optionally in the next release and be required in the release after that.
<ul>
<li>This is difficult to do with <code>ValueCastable</code> and will require workarounds both in the core language implementation and in downstream code that operates on <code>ValueCastable</code> objects.</li>
<li><code>ValueCastable</code> is not very widely used yet and the breakage will likely be minimal.</li>
</ul>
</li>
</ul>
<h2 id="prior-art-11"><a class="header" href="#prior-art-11">Prior art</a></h2>
<p>It is typical for a programming language to have a way of retrieving the type of a value. The mechanism being added here is equivalent.</p>
<h2 id="unresolved-questions-12"><a class="header" href="#unresolved-questions-12">Unresolved questions</a></h2>
<p>None.</p>
<h2 id="future-possibilities-12"><a class="header" href="#future-possibilities-12">Future possibilities</a></h2>
<p>None.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2023-10-30</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/0028">amaranth-lang/rfcs#0028</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth/issues/0929">amaranth-lang/amaranth#0929</a></li>
</ul>
<h1 id="allow-overriding-value-operators"><a class="header" href="#allow-overriding-value-operators">Allow overriding Value operators</a></h1>
<h2 id="summary-15"><a class="header" href="#summary-15">Summary</a></h2>
<p>Allow overriding binary <code>Value</code> operators with reflected operators in a value-castable type.</p>
<h2 id="motivation-15"><a class="header" href="#motivation-15">Motivation</a></h2>
<p>A value-castable type can define operators that return another value-castable.
However, if the left side operand is a <code>Value</code>, its operator will be called first, casting the right side operand to a plain <code>Value</code>.
This creates a mismatch in behavior depending on the type and order of operands.</p>
<p>As an example, consider the multiplication of a fixed point value-castable with an integral type:</p>
<pre><code>&gt;&gt;&gt; Q(7).const(0.5) * 255
(fixedpoint Q8.7 (* (const 8'sd64) (const 8'd255)))
&gt;&gt;&gt; 255 * Q(7).const(0.5)
(fixedpoint Q8.7 (* (const 8'sd64) (const 8'd255)))
&gt;&gt;&gt; Q(7).const(0.5) * C(255)
(fixedpoint Q8.7 (* (const 8'sd64) (const 8'd255)))
&gt;&gt;&gt; C(255) * Q(7).const(0.5)
(* (const 8'd255) (const 8'sd64))
</code></pre>
<h2 id="explanation-3"><a class="header" href="#explanation-3">Explanation</a></h2>
<p>When a binary <code>Value</code> operator is called with a value-castable <code>other</code>, check whether the value-castable implements the reflected variant of the operator first and defer to it when present.</p>
<h2 id="drawbacks-14"><a class="header" href="#drawbacks-14">Drawbacks</a></h2>
<p>Extra logic required around every <code>Value</code> operator.</p>
<h2 id="prior-art-12"><a class="header" href="#prior-art-12">Prior art</a></h2>
<p>This is standard behavior for inheritance in <a href="https://docs.python.org/3/reference/datamodel.html#emulating-numeric-types">Python</a>:</p>
<blockquote>
<p>Note: If the right operands type is a subclass of the left operands type and that subclass provides a different implementation of the reflected method for the operation, this method will be called before the left operands non-reflected method. This behavior allows subclasses to override their ancestors operations.</p>
</blockquote>
<p>We don't get this behavior automatically because <code>Value</code> is not an ancestor of <code>ValueCastable</code>, but it would make sense for it to behave as it were.</p>
<h2 id="rationale-and-alternatives-13"><a class="header" href="#rationale-and-alternatives-13">Rationale and alternatives</a></h2>
<p>As an alternative, <code>Value</code> and <code>ValueCastable</code> could be rearchitected so that <code>ValueCastable</code> inherits from either <code>Value</code> or a common base that implements the <code>Value</code> operators.
This would make Python do the right thing w.r.t. operator overriding, but is a larger change with more potential for undesirable consequences.</p>
<h2 id="unresolved-questions-13"><a class="header" href="#unresolved-questions-13">Unresolved questions</a></h2>
<p>None.</p>
<h2 id="future-possibilities-13"><a class="header" href="#future-possibilities-13">Future possibilities</a></h2>
<p><code>Value.eq()</code> could in the same manner check for and defer to a <code>.req()</code> method, i.e. reflected <code>.eq()</code>, to allow a value-castable to override how assignment from it to a <code>Value</code> is handled.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2023-11-27</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/31">amaranth-lang/rfcs#31</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth/issues/972">amaranth-lang/amaranth#972</a></li>
</ul>
<h1 id="enumeration-type-safety"><a class="header" href="#enumeration-type-safety">Enumeration type safety</a></h1>
<h2 id="summary-16"><a class="header" href="#summary-16">Summary</a></h2>
<p>Make Amaranth <code>Enum</code> and <code>Flag</code> use a custom <code>ValueCastable</code> view class, enforcing type safety.</p>
<h2 id="motivation-16"><a class="header" href="#motivation-16">Motivation</a></h2>
<p>Python <code>Enum</code> provides an opaque wrapper over the underlying enum values,
providing type safety and guarding against improper usage in arithmetic
operations:</p>
<pre><code class="language-pycon">&gt;&gt;&gt; from enum import Enum
&gt;&gt;&gt; class EnumA(Enum):
...     A = 0
...     B = 1
...
&gt;&gt;&gt; EnumA.A + 1
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: unsupported operand type(s) for +: 'EnumA' and 'int'
</code></pre>
<p>Likewise, <code>Flag</code> values can be used in bitwise operations, but only within
their own type:</p>
<pre><code class="language-pycon">&gt;&gt;&gt; from enum import Flag
&gt;&gt;&gt; class FlagA(Flag):
...     A = 1
...     B = 2
... 
&gt;&gt;&gt; class FlagB(Flag):
...     C = 1
...     D = 2
... 
&gt;&gt;&gt; FlagA.A | FlagA.B
&lt;FlagA.A|B: 3&gt;
&gt;&gt;&gt; FlagA.A | FlagB.C
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: unsupported operand type(s) for |: 'FlagA' and 'FlagB'
</code></pre>
<p>However, these safety properties are not currently enforced by Amaranth
on enum-typed signals:</p>
<pre><code class="language-pycon">&gt;&gt;&gt; from amaranth import *
&gt;&gt;&gt; from amaranth.lib.enum import *
&gt;&gt;&gt; class FlagA(Flag):
...     A = 1
...     B = 2
... 
&gt;&gt;&gt; class FlagB(Flag):
...     C = 1
...     D = 2
... 
&gt;&gt;&gt; a = Signal(FlagA)
&gt;&gt;&gt; b = Signal(FlagB)
&gt;&gt;&gt; a | b
(| (sig a) (sig b))
</code></pre>
<h2 id="guide-level-explanation-10"><a class="header" href="#guide-level-explanation-10">Guide-level explanation</a></h2>
<p>Like in Python, <code>Enum</code> and <code>Flag</code> subclasses are considered strongly-typed,
while <code>IntEnum</code> and <code>IntFlag</code> are weakly-typed. Enum-typed Amaranth values
with strong typing are manipulated through <code>amaranth.lib.enum.EnumView</code>
and <code>amaranth.lib.enum.FlagView</code> classes, which wrap an underlying <code>Value</code>
in a type-safe container that only allows a small subset of operations.
For weakly-typed enums, <code>Value</code> is used directly, providing full
interchangeability with other values.</p>
<p>An <code>EnumView</code> or a <code>FlagView</code> can be obtained by:</p>
<ul>
<li>Creating an enum-typed signal (<code>a = Signal(MyEnum)</code>)</li>
<li>Explicitly casting a value to the enum type (<code>MyEnum(value)</code>)</li>
</ul>
<p>The operations available on <code>EnumView</code> and <code>FlagView</code> include:</p>
<ul>
<li>Comparing for equality to another view of the same enum type (<code>a == b</code> and <code>a != b</code>)</li>
<li>Assigning to or from a value</li>
<li>Converting to a plain value via <code>Value.cast</code></li>
</ul>
<p>The operations additionally available on <code>FlagView</code> include:</p>
<ul>
<li>Binary bitwise operations with another <code>FlagView</code> of the same type
(<code>a | b</code>, <code>a &amp; b</code>, <code>a ^ b</code>)</li>
<li>Bitwise inversion (<code>~a</code>)</li>
</ul>
<p>A custom subclass of <code>EnumView</code> or <code>FlagView</code> can be used for a given enum
type if so desired, by using the <code>view_class</code> keyword parameter on enum
creation.</p>
<h2 id="reference-level-explanation-10"><a class="header" href="#reference-level-explanation-10">Reference-level explanation</a></h2>
<p><code>amaranth.lib.enum.EnumView</code> is a <code>ValueCastable</code> subclass.  The following
operations are defined on it:</p>
<ul>
<li><code>EnumView(enum, value_castable)</code>: creates the view</li>
<li><code>shape()</code>: returns the underlying enum</li>
<li><code>as_value()</code>: returns the underlying value</li>
<li><code>eq(value_castable)</code>: delegates to <code>eq</code> on the underlying value</li>
<li><code>__eq__</code> and <code>__ne__</code>: if the other argument is an <code>EnumView</code> of the same
enum type or a value of the enum type, delegates to the corresponding
<code>Value</code> operator; otherwise, raises a <code>TypeError</code></li>
<li>All binary arithmetic, bitwise, and remaining comparison operators: raise
a <code>TypeError</code> (to override the implementation provided by <code>Value</code> in case
of an operation between <code>EnumView</code> and <code>Value</code>)</li>
</ul>
<p><code>amaranth.lib.enum.FlagView</code> is a subclass of <code>EnumView</code>.  The following
additional operations are defined on it:</p>
<ul>
<li><code>__and__</code>, <code>__or__</code>, <code>__xor__</code>: if the other argument is a <code>FlagView</code>
of the same enum type or a value of the enum type, delegates to the
corresponding <code>Value</code> operator and wraps the result in <code>FlagView</code>;
otherwise, raises a <code>TypeError</code></li>
<li><code>__invert__</code>: inverts all bits in this value corresponding to actually
defined flags in the underlying enum type, then wraps the result in
<code>FlagView</code></li>
</ul>
<p>The behavior of <code>EnumMeta.__call__</code> when called on a value-castable
is changed as follows:</p>
<ul>
<li>If the enum has been created with a <code>view_class</code>, the value-castable
is wrapped in the given class</li>
<li>Otherwise, if the enum type is a subclass of <code>IntEnum</code> or <code>IntFlag</code>, the
value-castable is returned as a plain <code>Value</code></li>
<li>Otherwise, if the enum type is a subclass of <code>Flag</code>, the value-castable
is wrapped in <code>FlagView</code></li>
<li>Otherwise, the value-castable is wrapped in <code>EnumView</code></li>
</ul>
<p>The behavior of <code>EnumMeta.const</code> is modified to go through the same logic.</p>
<h2 id="drawbacks-15"><a class="header" href="#drawbacks-15">Drawbacks</a></h2>
<p>This proposal increases language complexity, and is not consistent with
eg. how <code>amaranth.lib.data.View</code> operates (which has much more lax type
checking).</p>
<h2 id="rationale-and-alternatives-14"><a class="header" href="#rationale-and-alternatives-14">Rationale and alternatives</a></h2>
<p>Do nothing. Operations on mismatched types will continue to be silently
allowed.</p>
<p>Equality could work more like Python equality (always returning false
for mismatched types).</p>
<p>Assignment could be made strongly-typed as well (with corresponding hook
added to <code>Value</code>).</p>
<h2 id="prior-art-13"><a class="header" href="#prior-art-13">Prior art</a></h2>
<p>This feature directly parallels the differences between Python's
<code>Enum</code>/<code>Flag</code> and <code>IntEnum</code>/<code>IntFlag</code>.</p>
<h2 id="unresolved-questions-14"><a class="header" href="#unresolved-questions-14">Unresolved questions</a></h2>
<p>Instead of having an extension point via <code>view_class</code>, we could instead
automatically forward all otherwise unknown methods to the underlying enum
class, providing it the <code>EnumView</code> as <code>self</code>.</p>
<h2 id="future-possibilities-14"><a class="header" href="#future-possibilities-14">Future possibilities</a></h2>
<p>None.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2023-12-04</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/34">amaranth-lang/rfcs#34</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth/issues/985">amaranth-lang/amaranth#985</a></li>
</ul>
<h1 id="rename-amaranthlibwiringinterface-to-pureinterface"><a class="header" href="#rename-amaranthlibwiringinterface-to-pureinterface">Rename <code>amaranth.lib.wiring.Interface</code> to <code>PureInterface</code></a></h1>
<h2 id="summary-17"><a class="header" href="#summary-17">Summary</a></h2>
<p>The <code>Interface</code> class in <code>amaranth.lib.wiring</code> is renamed to <code>PureInterface</code>, to avoid the impression that it is used for <em>all</em> interfaces.</p>
<h2 id="motivation-17"><a class="header" href="#motivation-17">Motivation</a></h2>
<p>The current naming of the <code>Interface</code> class wrongly suggests that it is the base class to be used for all interfaces, and that <code>isinstance(foo, Interface)</code> is a valid check for an interface. However, this is in stark contrast to how <code>lib.wiring</code> works: any object can be an interface, as long as it has a <code>signature</code> property and compliant members. This misleads users (and, on at least two occasions, amaranth developers), making them write buggy code.</p>
<p>Additionally, the naming makes spoken language ambiguous in a bad way, as it is impossible to tell apart &quot;an interface&quot; and &quot;an Interface&quot;.</p>
<p>Therefore, this RFC proposes to rename <code>Interface</code> to something more specific and reflecting its function.</p>
<h2 id="guide-level-explanation-11"><a class="header" href="#guide-level-explanation-11">Guide-level explanation</a></h2>
<p>The <code>Interface</code> class in <code>amaranth.lib.wiring</code> is renamed to <code>PureInterface</code>.</p>
<h2 id="reference-level-explanation-11"><a class="header" href="#reference-level-explanation-11">Reference-level explanation</a></h2>
<p>The <code>Interface</code> class in <code>amaranth.lib.wiring</code> is renamed to <code>PureInterface</code>.</p>
<h2 id="drawbacks-16"><a class="header" href="#drawbacks-16">Drawbacks</a></h2>
<p>Minor churn.</p>
<h2 id="rationale-and-alternatives-15"><a class="header" href="#rationale-and-alternatives-15">Rationale and alternatives</a></h2>
<p>The new name is, of course, subject to bikeshedding. The names that have been proposed are:</p>
<ul>
<li><code>PureInterface</code></li>
<li><code>BareInterface</code></li>
</ul>
<h2 id="prior-art-14"><a class="header" href="#prior-art-14">Prior art</a></h2>
<p>None.</p>
<h2 id="unresolved-questions-15"><a class="header" href="#unresolved-questions-15">Unresolved questions</a></h2>
<p>None.</p>
<h2 id="future-possibilities-15"><a class="header" href="#future-possibilities-15">Future possibilities</a></h2>
<p>The name <code>Interface</code> that has just been freed up can be reused for an ABC-like class representing all valid interfaces.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2023-12-04</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/35">amaranth-lang/rfcs#35</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth/issues/986">amaranth-lang/amaranth#986</a></li>
</ul>
<h1 id="add-shapelike-valuelike"><a class="header" href="#add-shapelike-valuelike">Add <code>ShapeLike</code>, <code>ValueLike</code></a></h1>
<h2 id="summary-18"><a class="header" href="#summary-18">Summary</a></h2>
<p>Two special classes are added to the language: <code>ShapeLike</code> and <code>ValueLike</code>. They cannot be constructed, but can be used to determine with <code>isinstance</code> and <code>issubclass</code> to determine whether something can be cast to <code>Shape</code> or a <code>Value</code>, respectively.</p>
<h2 id="motivation-18"><a class="header" href="#motivation-18">Motivation</a></h2>
<p>As it stands, we have multiple types of objects that can be used as shapes (<code>Shape</code>, <code>ShapeCastable</code>, <code>int</code>, <code>range</code>, <code>EnumMeta</code>) and values (<code>Value</code>, <code>ValueCastable</code>, <code>int</code>, <code>Enum</code>). These types have no common superclass, so there's no easy way to check if an object can be used as a shape or a value, save for actually calling <code>Shape.cast</code> or <code>Value.cast</code>. Introducing <code>ShapeLike</code> and <code>ValueLike</code> provides an idiomatic way to perform such a check.</p>
<p>Additionally, when type annotations are in use, there is currently no simple type that can be used for an argument that takes an arbitrary shape- or value-castable object. These new classes provide such a simple type.</p>
<h2 id="guide-level-explanation-12"><a class="header" href="#guide-level-explanation-12">Guide-level explanation</a></h2>
<p>In Amaranth, multiple types of objects can be cast to shapes:</p>
<ul>
<li>actual <code>Shape</code> objects</li>
<li><code>ShapeCastable</code> objects</li>
<li>non-negative integers</li>
<li><code>range</code> objects</li>
<li><code>Enum</code> subclasses with const-castable values</li>
</ul>
<p>To check whether an object is of a type that can be cast to a shape, <code>isinstance(obj, ShapeLike)</code> can be used. To check whether a type can be, in general, cast to a shape, <code>issubclass(cls, ShapeLike)</code> can be used.</p>
<p>Likewise, multiple types of objects can be cast to values:</p>
<ul>
<li>actual <code>Value</code> objects</li>
<li><code>ValueCastable</code> objects</li>
<li>integers</li>
<li>values of <code>Enum</code> subclasses with const-castable values</li>
</ul>
<p>To check whether an object is of a type that can be cast to a value, <code>isinstance(obj, ValueLike)</code> can be used. To check whether a type can be, in general, cast to a value, <code>issubclass(cls, ValueLike)</code> can be used.</p>
<h2 id="reference-level-explanation-12"><a class="header" href="#reference-level-explanation-12">Reference-level explanation</a></h2>
<p>A <code>ShapeLike</code> class is provided. It cannot be constructed, and can only be used with <code>isinstance</code> and <code>issubclass</code>, which are overriden by a custom metaclass.</p>
<p><code>issubclass(cls, ShapeLike)</code> returns <code>True</code> for:</p>
<ul>
<li><code>Shape</code></li>
<li><code>ShapeCastable</code> and its subclasses</li>
<li><code>int</code> and its subclasses</li>
<li><code>range</code> and its subclasses</li>
<li><code>enum.EnumMeta</code> and its subclasses</li>
</ul>
<p><code>isinstance(obj, ShapeLike)</code> returns <code>True</code> for:</p>
<ul>
<li>instances of <code>Shape</code></li>
<li>instances of <code>ShapeCastable</code> and its subclasses</li>
<li>non-negative <code>int</code> values (and <code>int</code> subclasses)</li>
<li><code>enum.Enum</code> subclasses where every value is a <code>ValueLike</code></li>
</ul>
<p>Similarly, a <code>ValueLike</code> class is provided.</p>
<p><code>issubclass(cls, ValueLike)</code> returns <code>True</code> for:</p>
<ul>
<li><code>Value</code> and its subclasses</li>
<li><code>ValueCastable</code> and its subclasses</li>
<li><code>int</code> and its subclasses</li>
<li><code>enum.Enum</code> subclasses where every value is a <code>ValueLike</code></li>
</ul>
<p><code>isinstance(obj, ValueLike)</code> returns <code>True</code> iff <code>issubclass(type(obj), ValueLike)</code> returns <code>True</code>.</p>
<h2 id="drawbacks-17"><a class="header" href="#drawbacks-17">Drawbacks</a></h2>
<p>More moving parts in the language.</p>
<p><code>isinstance(obj, ShapeLike)</code> does not actually guarantee that <code>Shape.cast(obj)</code> will succeed  the instance check looks only at surface-level information, and an exception can still be thrown. <code>issubclass(cls, ShapeLike)</code> is, by necessity, even more inaccurate.</p>
<h2 id="rationale-and-alternatives-16"><a class="header" href="#rationale-and-alternatives-16">Rationale and alternatives</a></h2>
<p>There are many ways to implement the instance and subclass checks, some more precise (and complex) than others. The semantics described above are a compromise.</p>
<p>For <code>isinstance</code>, a simple variant would be to just try <code>Shape.cast</code> or <code>Value.cast</code> and see if it raises an exception. However, this will sometimes result in <code>isinstance(MyShapeCastable(), ShapeLike)</code> returning <code>False</code>, which may be very unintuitive and hide bugs.</p>
<p>The check for a valid shape-castable enum described above is an approximation  the actual logic used requires all values of an enum to be <em>const</em>-castable, not just value-castable. However, there is no way to check this without actually invoking <code>Value.cast</code> on the enum members.</p>
<h2 id="prior-art-15"><a class="header" href="#prior-art-15">Prior art</a></h2>
<p>Python has the concept of abstract base classes, such as <code>collections.abc.Sequence</code>, which can be used for subclass checking even if they are not actual superclasses of the types involved. <code>ShapeLike</code> and <code>ValueLike</code> are effectively ABCs, though they do not use the actual ABC machinery (due to having custom logic in instance checking).</p>
<h2 id="unresolved-questions-16"><a class="header" href="#unresolved-questions-16">Unresolved questions</a></h2>
<ul>
<li>Should the exact details of the instance and subclass checks be changed?</li>
</ul>
<h2 id="future-possibilities-16"><a class="header" href="#future-possibilities-16">Future possibilities</a></h2>
<p>A similar ABC-like class has been proposed for <code>lib.wiring</code> interfaces.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2023-12-11</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/37">amaranth-lang/rfcs#37</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth/issues/995">amaranth-lang/amaranth#995</a></li>
</ul>
<h1 id="make-signature-immutable"><a class="header" href="#make-signature-immutable">Make <code>Signature</code> immutable</a></h1>
<h2 id="summary-19"><a class="header" href="#summary-19">Summary</a></h2>
<p>Remove mutability from <code>amaranth.lib.wiring.Signature</code>.</p>
<h2 id="motivation-19"><a class="header" href="#motivation-19">Motivation</a></h2>
<p>At the time of writing, <code>Signature</code> allows limited mutability: members can be added, but not removed or changed; and a signature may be frozen, preventing further mutation.</p>
<p>The intent behind this feature was unfortunately never explicitly described. I (Catherine) came up with it, to cover the following case: suppose an interface without certain features needs to be connected to an interface with such features. For example, a Wishbone initiator that does not handle errors needs to be connected to a Wishbone decoder that does. In this case, a method on the Wishbone initiator's interface could be used to add a dummy <code>err</code> output, which will always remain at its reset value, zero.</p>
<p>This intent was never realized as the feature was never actually used by Amaranth SoC. In addition, it turned out to be problematic when combined with variable annotations. Consider this class definition:</p>
<pre><code class="language-py">class SomeInitiator(wiring.Component):
    bus: Out(wishbone.Interface(...))
</code></pre>
<p>In this case, only one instance of <code>wishbone.Interface</code> is created. Mutating this instance would be unsound, since it would affect every instance of the component and not just the one for that particular one, and when this causes issues this would be very difficult to debug.</p>
<p>The presence of this feature encouraged adding other mutable objects to <code>Signature</code> subclasses, such as memory maps. That is also unsound, for similar reasons. Because memory maps in Amaranth SoC can also be frozen, considerable additional complexity was introduced since piecewise freezing was now possible.</p>
<p>Because freezing was defined as a property of the signature members dictionary, overloading <code>Signature.freeze</code> was meaningless: it would be possible, in rare but legal cases, to have a signature frozen without <code>freeze</code> being called for that signature, leaving any additional objects that should have been frozen mutable.</p>
<p>The <code>wiring.connect</code> function also supports constants as both inputs and outputs, where a constant input can be connected to a constant output provided their values match. This behavior is also suited for implementing optional features (where the absence of an optional feature means the corresponding ports are fixed at a constant value), and does not pose any hazards.</p>
<h2 id="guide-level-and-reference-level-explanation-1"><a class="header" href="#guide-level-and-reference-level-explanation-1">Guide-level and reference-level explanation</a></h2>
<p>The <code>SignatureMembers.freeze</code>, <code>SignatureMembers.frozen</code>, <code>Signature.freeze</code>, <code>Signature.frozen</code>, <code>FlippedSignatureMembers.freeze</code>, <code>FlippedSignatureMembers.frozen</code>, <code>FlippedSignature.freeze</code>, <code>FlippedSignature.frozen</code>, <code>SignatureMembers.__iadd__</code>, <code>SignatureMembers.__setitem__</code>, <code>FlippedSignatureMembers.__iadd__</code>, <code>FlippedSignatureMembers.__setitem__</code> methods and properties are removed.</p>
<p><code>SignatureMembers</code> becomes an immutable mapping.</p>
<p><code>Signature</code> becomes immutable. Subclasses of <code>Signature</code> are required to ensure any additional methods or properties do not allow mutation.</p>
<h2 id="drawbacks-18"><a class="header" href="#drawbacks-18">Drawbacks</a></h2>
<p>The author is not aware of anyone actually using this feature.</p>
<h2 id="rationale-and-alternatives-17"><a class="header" href="#rationale-and-alternatives-17">Rationale and alternatives</a></h2>
<p>An alternative to this proposal would be to automatically freeze any signature that is used in <code>wiring.Component</code> variable annotations. This does not address similar hazards, such as the case of a user-defined constant <code>SomeSignature = Signature({...})</code>, which is also a legitimate way to define a signature that does not require parameterization. It also would not address hazards associated with interior mutability.</p>
<h2 id="prior-art-16"><a class="header" href="#prior-art-16">Prior art</a></h2>
<p>None seems applicable. Mutation of interface definitions is uncommon in first place (excluding languages where everything is mutable, like Python).</p>
<h2 id="unresolved-questions-17"><a class="header" href="#unresolved-questions-17">Unresolved questions</a></h2>
<ul>
<li>Should <em>all</em> interior mutability be prohibited? At the moment it is not completely clear where memory maps should be attached, and requiring no interior mutability would mean it cannot be <code>Signature</code> no matter what. Interior mutability could be left to specific <code>Signature</code> subclasses instead on an experimental basis, and prohibited later if it turns out to be a bad idea.</li>
</ul>
<h2 id="future-possibilities-17"><a class="header" href="#future-possibilities-17">Future possibilities</a></h2>
<p>Reintroducing mutability of <code>Signature</code> after it has been removed will be unfeasible due to expectation of immutability being baked in widely in downstream code. Once we commit to this RFC we will have to commit to it effectively forever.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
