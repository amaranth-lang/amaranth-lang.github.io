var B_=Object.create;var fn=Object.defineProperty;var F_=Object.getOwnPropertyDescriptor;var W_=Object.getOwnPropertyNames;var H_=Object.getPrototypeOf,k_=Object.prototype.hasOwnProperty;var U_=(t,e,n)=>e in t?fn(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n;var Vt=(t=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(t,{get:(e,n)=>(typeof require<"u"?require:e)[n]}):t)(function(t){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+t+'" is not supported')});var G_=(t,e)=>()=>(t&&(e=t(t=0)),e);var ce=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),z_=(t,e)=>{for(var n in e)fn(t,n,{get:e[n],enumerable:!0})},K_=(t,e,n,_)=>{if(e&&typeof e=="object"||typeof e=="function")for(let r of W_(e))!k_.call(t,r)&&r!==n&&fn(t,r,{get:()=>e[r],enumerable:!(_=F_(e,r))||_.enumerable});return t};var Gt=(t,e,n)=>(n=t!=null?B_(H_(t)):{},K_(e||!t||!t.__esModule?fn(n,"default",{value:t,enumerable:!0}):n,t));var Rn=(t,e,n)=>(U_(t,typeof e!="symbol"?e+"":e,n),n);var gn=ce(()=>{});var Ke=ce(()=>{});var Pn=ce(()=>{});var Yn=ce(()=>{});var yn=ce(()=>{});var Ye=ce((kr,H0)=>{"use strict";H0.exports=function(){throw new Error("ws does not work in the browser. Browser clients must use the native WebSocket object")}});var Sn=ce(()=>{});var k0=ce((exports,module)=>{"use strict";var _createPyodideModule=(()=>{var _scriptDir=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(_scriptDir=_scriptDir||__filename),function(moduleArg={}){var Module=moduleArg,readyPromiseResolve,readyPromiseReject;Module.ready=new Promise((t,e)=>{readyPromiseResolve=t,readyPromiseReject=e});var moduleOverrides=Object.assign({},Module),arguments_=[],thisProgram="./this.program",quit_=(t,e)=>{throw e},ENVIRONMENT_IS_WEB=typeof window=="object",ENVIRONMENT_IS_WORKER=typeof importScripts=="function",ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",ENVIRONMENT_IS_SHELL=!ENVIRONMENT_IS_WEB&&!ENVIRONMENT_IS_NODE&&!ENVIRONMENT_IS_WORKER,scriptDirectory="";function locateFile(t){return Module.locateFile?Module.locateFile(t,scriptDirectory):scriptDirectory+t}var read_,readAsync,readBinary;if(ENVIRONMENT_IS_NODE){var fs=gn(),nodePath=Ke();ENVIRONMENT_IS_WORKER?scriptDirectory=nodePath.dirname(scriptDirectory)+"/":scriptDirectory=__dirname+"/",read_=(t,e)=>(t=isFileURI(t)?new URL(t):nodePath.normalize(t),fs.readFileSync(t,e?void 0:"utf8")),readBinary=t=>{var e=read_(t,!0);return e.buffer||(e=new Uint8Array(e)),e},readAsync=(t,e,n,_=!0)=>{t=isFileURI(t)?new URL(t):nodePath.normalize(t),fs.readFile(t,_?void 0:"utf8",(r,a)=>{r?n(r):e(_?a.buffer:a)})},!Module.thisProgram&&process.argv.length>1&&(thisProgram=process.argv[1].replace(/\\/g,"/")),arguments_=process.argv.slice(2),quit_=(t,e)=>{throw process.exitCode=t,e},Module.inspect=()=>"[Emscripten Module object]"}else(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER)&&(ENVIRONMENT_IS_WORKER?scriptDirectory=self.location.href:typeof document<"u"&&document.currentScript&&(scriptDirectory=document.currentScript.src),_scriptDir&&(scriptDirectory=_scriptDir),scriptDirectory.indexOf("blob:")!==0?scriptDirectory=scriptDirectory.substr(0,scriptDirectory.replace(/[?#].*/,"").lastIndexOf("/")+1):scriptDirectory="",read_=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.send(null),e.responseText},ENVIRONMENT_IS_WORKER&&(readBinary=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.responseType="arraybuffer",e.send(null),new Uint8Array(e.response)}),readAsync=(t,e,n)=>{var _=new XMLHttpRequest;_.open("GET",t,!0),_.responseType="arraybuffer",_.onload=()=>{if(_.status==200||_.status==0&&_.response){e(_.response);return}n()},_.onerror=n,_.send(null)});var out=Module.print||console.log.bind(console),err=Module.printErr||console.error.bind(console);Object.assign(Module,moduleOverrides),moduleOverrides=null,Module.arguments&&(arguments_=Module.arguments),Module.thisProgram&&(thisProgram=Module.thisProgram),Module.quit&&(quit_=Module.quit),Module.wrapException||(Module.wrapException=t=>t);var dynamicLibraries=Module.dynamicLibraries||[],wasmBinary;Module.wasmBinary&&(wasmBinary=Module.wasmBinary);var noExitRuntime=Module.noExitRuntime||!0;typeof WebAssembly!="object"&&abort("no native wasm support detected");var wasmMemory,ABORT=!1,EXITSTATUS;function assert(t,e){t||abort(e)}var HEAP,HEAP8,HEAPU8,HEAP16,HEAPU16,HEAP32,HEAPU32,HEAPF32,HEAP64,HEAPU64,HEAPF64;function updateMemoryViews(){var t=wasmMemory.buffer;Module.HEAP8=HEAP8=new Int8Array(t),Module.HEAP16=HEAP16=new Int16Array(t),Module.HEAPU8=HEAPU8=new Uint8Array(t),Module.HEAPU16=HEAPU16=new Uint16Array(t),Module.HEAP32=HEAP32=new Int32Array(t),Module.HEAPU32=HEAPU32=new Uint32Array(t),Module.HEAPF32=HEAPF32=new Float32Array(t),Module.HEAPF64=HEAPF64=new Float64Array(t),Module.HEAP64=HEAP64=new BigInt64Array(t),Module.HEAPU64=HEAPU64=new BigUint64Array(t)}var INITIAL_MEMORY=Module.INITIAL_MEMORY||20971520;assert(INITIAL_MEMORY>=5242880,"INITIAL_MEMORY should be larger than STACK_SIZE, was "+INITIAL_MEMORY+"! (STACK_SIZE=5242880)"),Module.wasmMemory?wasmMemory=Module.wasmMemory:wasmMemory=new WebAssembly.Memory({initial:INITIAL_MEMORY/65536,maximum:32768}),updateMemoryViews(),INITIAL_MEMORY=wasmMemory.buffer.byteLength;var __ATPRERUN__=[],__ATINIT__=[],__ATMAIN__=[],__ATEXIT__=[],__ATPOSTRUN__=[],__RELOC_FUNCS__=[],runtimeInitialized=!1,runtimeKeepaliveCounter=0;function keepRuntimeAlive(){return noExitRuntime||runtimeKeepaliveCounter>0}function preRun(){if(Module.preRun)for(typeof Module.preRun=="function"&&(Module.preRun=[Module.preRun]);Module.preRun.length;)addOnPreRun(Module.preRun.shift());callRuntimeCallbacks(__ATPRERUN__)}function initRuntime(){runtimeInitialized=!0,callRuntimeCallbacks(__RELOC_FUNCS__),!Module.noFSInit&&!FS.init.initialized&&FS.init(),FS.ignorePermissions=!1,TTY.init(),SOCKFS.root=FS.mount(SOCKFS,{},null),PIPEFS.root=FS.mount(PIPEFS,{},null),callRuntimeCallbacks(__ATINIT__)}function preMain(){callRuntimeCallbacks(__ATMAIN__)}function postRun(){if(Module.postRun)for(typeof Module.postRun=="function"&&(Module.postRun=[Module.postRun]);Module.postRun.length;)addOnPostRun(Module.postRun.shift());callRuntimeCallbacks(__ATPOSTRUN__)}function addOnPreRun(t){__ATPRERUN__.unshift(t)}function addOnInit(t){__ATINIT__.unshift(t)}function addOnPreMain(t){__ATMAIN__.unshift(t)}function addOnExit(t){}function addOnPostRun(t){__ATPOSTRUN__.unshift(t)}var runDependencies=0,runDependencyWatcher=null,dependenciesFulfilled=null;function getUniqueRunDependency(t){return t}function addRunDependency(t){runDependencies++,Module.monitorRunDependencies&&Module.monitorRunDependencies(runDependencies)}function removeRunDependency(t){if(runDependencies--,Module.monitorRunDependencies&&Module.monitorRunDependencies(runDependencies),runDependencies==0&&(runDependencyWatcher!==null&&(clearInterval(runDependencyWatcher),runDependencyWatcher=null),dependenciesFulfilled)){var e=dependenciesFulfilled;dependenciesFulfilled=null,e()}}function abort(t){Module.onAbort&&Module.onAbort(t),t="Aborted("+t+")",err(t),ABORT=!0,EXITSTATUS=1,t+=". Build with -sASSERTIONS for more info.";var e=new WebAssembly.RuntimeError(t);throw readyPromiseReject(e),e}var dataURIPrefix="data:application/octet-stream;base64,";function isDataURI(t){return t.startsWith(dataURIPrefix)}function isFileURI(t){return t.startsWith("file://")}var wasmBinaryFile;wasmBinaryFile="pyodide.asm.wasm",isDataURI(wasmBinaryFile)||(wasmBinaryFile=locateFile(wasmBinaryFile));function getBinarySync(t){if(t==wasmBinaryFile&&wasmBinary)return new Uint8Array(wasmBinary);if(readBinary)return readBinary(t);throw"both async and sync fetching of the wasm failed"}function getBinaryPromise(t){if(!wasmBinary&&(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER)){if(typeof fetch=="function"&&!isFileURI(t))return fetch(t,{credentials:"same-origin"}).then(e=>{if(!e.ok)throw"failed to load wasm binary file at '"+t+"'";return e.arrayBuffer()}).catch(()=>getBinarySync(t));if(readAsync)return new Promise((e,n)=>{readAsync(t,_=>e(new Uint8Array(_)),n)})}return Promise.resolve().then(()=>getBinarySync(t))}function instantiateArrayBuffer(t,e,n){return getBinaryPromise(t).then(_=>WebAssembly.instantiate(_,e)).then(_=>_).then(n,_=>{err(`failed to asynchronously prepare wasm: ${_}`),abort(_)})}function instantiateAsync(t,e,n,_){return!t&&typeof WebAssembly.instantiateStreaming=="function"&&!isDataURI(e)&&!isFileURI(e)&&!ENVIRONMENT_IS_NODE&&typeof fetch=="function"?fetch(e,{credentials:"same-origin"}).then(r=>{var a=WebAssembly.instantiateStreaming(r,n);return a.then(_,function(o){return err(`wasm streaming compile failed: ${o}`),err("falling back to ArrayBuffer instantiation"),instantiateArrayBuffer(e,n,_)})}):instantiateArrayBuffer(e,n,_)}function createWasm(){Module.adjustWasmImports&&Module.adjustWasmImports(wasmImports);var t={env:wasmImports,wasi_snapshot_preview1:wasmImports,"GOT.mem":new Proxy(wasmImports,GOTHandler),"GOT.func":new Proxy(wasmImports,GOTHandler)};function e(_,r){wasmExports=_.exports,wasmExports=relocateExports(wasmExports,1024);var a=getDylinkMetadata(r);return a.neededDynlibs&&(dynamicLibraries=a.neededDynlibs.concat(dynamicLibraries)),mergeLibSymbols(wasmExports,"main"),LDSO.init(),loadDylibs(),addOnInit(wasmExports.__wasm_call_ctors),__RELOC_FUNCS__.push(wasmExports.__wasm_apply_data_relocs),removeRunDependency("wasm-instantiate"),wasmExports}addRunDependency("wasm-instantiate");function n(_){e(_.instance,_.module)}if(Module.instantiateWasm)try{return Module.instantiateWasm(t,e)}catch(_){err(`Module.instantiateWasm callback failed with error: ${_}`),readyPromiseReject(_)}return instantiateAsync(wasmBinary,wasmBinaryFile,t,n).catch(readyPromiseReject),{}}var ASM_CONSTS={3885483:()=>{throw new Error("intentionally triggered fatal error!")},3885540:()=>{wasmImports.open64=wasmImports.open},3885589:()=>Module.jspiSupported};function console_error(t){let e=UTF8ToString(t);console.error(e)}function console_error_obj(t){console.error(t)}function new_error(t,e,n){return new API.PythonError(UTF8ToString(t),UTF8ToString(e),n)}new_error.sig="eiii";function fail_test(){API.fail_test=!0}fail_test.sig="v";function raw_call_js(t){t()}raw_call_js.sig="ve";function hiwire_invalid_ref(t,e){if(API.fail_test=!0,t===1&&!e)if(_PyErr_Occurred()){let r=_wrap_exception();throw console.error("Pyodide internal error: Argument to hiwire_get is falsy. This was probably because the Python error indicator was set when get_value was called. The Python error that caused this was:",r),r}else{let r="Pyodide internal error: Argument to hiwire_get is falsy (but error indicator is not set).";throw console.error(r),new Error(r)}let _=`hiwire_${{1:"get",2:"incref",3:"decref"}[t]} on invalid reference ${e}. This is most likely due to use after free. It may also be due to memory corruption.`;throw console.error(_),new Error(_)}hiwire_invalid_ref.sig="vii";function set_pyodide_module(t){API._pyodide=t}set_pyodide_module.sig="ve";function js2python_immutable_js(t){try{let e=Module.js2python_convertImmutable(t);return e!==void 0?e:0}catch(e){return Module.handle_js_error(e),0}errNoRet()}js2python_immutable_js.sig="ie";function js2python_js(t){try{let e=Module.js2python_convertImmutable(t);return e!==void 0?e:_JsProxy_create(t)}catch(e){return Module.handle_js_error(e),0}errNoRet()}js2python_js.sig="ie";function js2python_convert(t,e,n){try{return Module.js2python_convert(t,{depth:e,defaultConverter:n})}catch(_){return Module.handle_js_error(_),0}errNoRet()}js2python_convert.sig="ieie";function js2python_init(){try{{let e=function(m){let E=0,f=0;for(let w of m){f++;let g=w.codePointAt(0);E=g>E?g:E}let R=_PyUnicode_New(f,E);if(R===0)throw new t;let h=_PyUnicode_Data(R);if(E>65535)for(let w of m)HEAPU32[h/4]=w.codePointAt(0),h+=4;else if(E>255)for(let w of m)HEAPU16[h/2]=w.codePointAt(0),h+=2;else for(let w of m)HEAPU8[h]=w.codePointAt(0),h+=1;return R},n=function(m){let E=m,f=0;for(m<0&&(m=-m),m<<=BigInt(1);m;)f++,m>>=BigInt(32);let R=stackSave(),h=stackAlloc(f*4);m=E;for(let g=0;g<f;g++)HEAPU32[(h>>2)+g]=Number(m&BigInt(4294967295)),m>>=BigInt(32);let w=__PyLong_FromByteArray(h,f*4,!0,!0);return stackRestore(R),w},_=function(m){let E=r(m);if(E===0)throw new t;return E},r=function(m){let E=typeof m;if(E==="string")return e(m);if(E==="number")return Number.isSafeInteger(m)?_PyLong_FromDouble(m):_PyFloat_FromDouble(m);if(E==="bigint")return n(m);if(m==null)return __js2python_none();if(m===!0)return __js2python_true();if(m===!1)return __js2python_false();if(API.isPyProxy(m)){let{props:f,shared:R}=Module.PyProxy_getAttrs(m);return f.roundtrip?_JsProxy_create(m):__js2python_pyproxy(R.ptr)}},a=function(m,E){let f=_PyList_New(m.length);if(f===0)return 0;let R=0;try{E.cache.set(m,f);for(let h=0;h<m.length;h++){if(R=I(m[h],E),_Py_IncRef(R),_PyList_SetItem(f,h,R)===-1)throw new t;_Py_DecRef(R),R=0}}catch(h){throw _Py_DecRef(R),_Py_DecRef(f),h}return f},o=function(m,E,f){let R=_PyDict_New();if(R===0)return 0;let h=0,w=0;try{f.cache.set(m,R);for(let[g,O]of E){if(h=_(g),h===void 0){let W=g.constructor&&g.constructor.name||typeof g;throw new Error(`Cannot use key of type ${W} as a key to a Python dict`)}if(w=I(O,f),_PyDict_SetItem(R,h,w)===-1)throw new t;_Py_DecRef(h),h=0,_Py_DecRef(w),w=0}}catch(g){throw _Py_DecRef(h),_Py_DecRef(w),_Py_DecRef(R),g}return R},l=function(m,E){let f=_PySet_New(0);if(f===0)return 0;let R=0;try{E.cache.set(m,f);for(let h of m){if(R=_(h),R===void 0){let g=h.constructor&&h.constructor.name||typeof h;throw new Error(`Cannot use key of type ${g} as a key to a Python set`)}if(_PySet_Add(f,R)===-1)throw new t;_Py_DecRef(R),R=0}}catch(h){throw _Py_DecRef(R),_Py_DecRef(f),h}return f},p=function(m,E){if(m.has(1)&&m.has(!0))throw new Error(`Cannot faithfully convert ${E} into Python since it contains both 1 and true as keys.`);if(m.has(0)&&m.has(!1))throw new Error(`Cannot faithfully convert ${E} into Python since it contains both 0 and false as keys.`)},c=function(m,E){let f=getTypeTag(m);if(Array.isArray(m)||m==="[object HTMLCollection]"||m==="[object NodeList]")return a(m,E);if(f==="[object Map]"||m instanceof Map)return p(m,"Map"),o(m,m.entries(),E);if(f==="[object Set]"||m instanceof Set)return p(m,"Set"),l(m,E);if(f==="[object Object]"&&(m.constructor===void 0||m.constructor.name==="Object"))return o(m,Object.entries(m),E);if(f==="[object ArrayBuffer]"||ArrayBuffer.isView(m)){let[R,h]=Module.get_buffer_datatype(m);return _JsBuffer_CopyIntoMemoryView(m,m.byteLength,R,h)}},I=function(m,E){let f=_(m);if(f!==void 0)return f;if(E.depth===0)return _JsProxy_create(m);if(f=E.cache.get(m),f!==void 0)return f;E.depth--;try{if(f=c(m,E),f!==void 0)return f;if(E.defaultConverter===void 0)return _JsProxy_create(m);let R=E.defaultConverter(m,E.converter,E.cacheConversion);return f=_(R),API.isPyProxy(R)&&Module.pyproxy_destroy(R,"",!1),f!==void 0?f:_JsProxy_create(R)}finally{E.depth++}},A=function(m,{depth:E,defaultConverter:f}){let R={cache:new Map,depth:E,defaultConverter:f,converter:h=>Module.pyproxy_new(I(h,R)),cacheConversion(h,w){if(API.isPyProxy(w))R.cache.set(h,Module.PyProxy_getPtr(w));else throw new Error("Second argument should be a PyProxy!")}};return I(m,R)},t=Module._PropagatePythonError;Module.js2python_convertImmutable=_,Module.js2python_convert=A}return 0}catch(t){return Module.handle_js_error(t),-1}return 0}js2python_init.sig="i";function isReservedWord(t){return Module.pythonReservedWords||(Module.pythonReservedWords=new Set(["False","await","else","import","pass","None","break","except","in","raise","True","class","finally","is","return","and","continue","for","lambda","try","as","def","from","nonlocal","while","assert","del","global","not","with","async","elif","if","or","yield"])),Module.pythonReservedWords.has(t)}function normalizeReservedWords(t){let e=t.replace(/_*$/,"");return isReservedWord(e)&&e!==t?t.slice(0,-1):t}function JsProxy_GetAttr_js(t,e){try{let n=normalizeReservedWords(UTF8ToString(e)),_=t[n];return _===void 0&&!(n in t)?null:nullToUndefined(_)}catch(n){return Module.handle_js_error(n),null}errNoRet()}JsProxy_GetAttr_js.sig="eei";function JsProxy_SetAttr_js(t,e,n){try{let _=normalizeReservedWords(UTF8ToString(e));t[_]=n}catch(_){return Module.handle_js_error(_),-1}return 0}JsProxy_SetAttr_js.sig="ieie";function JsProxy_DelAttr_js(t,e){try{let n=normalizeReservedWords(UTF8ToString(e));delete t[n]}catch(n){return Module.handle_js_error(n),-1}return 0}JsProxy_DelAttr_js.sig="iei";function JsProxy_GetIter_js(t){try{return t[Symbol.iterator]()}catch(e){return Module.handle_js_error(e),null}errNoRet()}JsProxy_GetIter_js.sig="ee";function handle_next_result_js(t,e,n){try{let _;return typeof t!="object"?_=`Result should have type "object" not "${typeof t}"`:typeof t.done>"u"&&(typeof t.then=="function"?_="Result was a promise, use anext() / asend() / athrow() instead.":_='Result has no "done" field.'),_&&(HEAPU32[(n>>2)+0]=stringToNewUTF8(_),HEAPU32[(e>>2)+0]=-1),HEAPU32[(e>>2)+0]=t.done,t.value}catch(_){return Module.handle_js_error(_),-1}return 0}handle_next_result_js.sig="eeii";function JsException_new_helper(t,e,n){try{let _=UTF8ToString(t),r=UTF8ToString(e),a=UTF8ToString(n);return API.deserializeError(_,r,a)}catch(_){return Module.handle_js_error(_),null}errNoRet()}JsException_new_helper.sig="eiii";function JsProxy_GetAsyncIter_js(t){try{return t[Symbol.asyncIterator]()}catch(e){return Module.handle_js_error(e),null}errNoRet()}JsProxy_GetAsyncIter_js.sig="ee";function _agen_handle_result_js(t,e,n,_,r){try{let a;return typeof t!="object"?a=`Result of anext() should be object not ${typeof t}`:typeof t.then!="function"&&(typeof t.done=="boolean"?a="Result of anext() was not a promise, use next() instead.":a="Result of anext() was not a promise."),a?(HEAPU32[(e>>2)+0]=stringToNewUTF8(a),-1):(_Py_IncRef(n),_Py_IncRef(_),t.then(({done:o,value:l})=>{__agen_handle_result_js_c(n,_,o,l,r)},o=>{__agen_handle_result_js_c(n,_,-1,o,r)}).finally(()=>{_Py_DecRef(n),_Py_DecRef(_)}),0)}catch(a){return Module.handle_js_error(a),-1}return 0}_agen_handle_result_js.sig="ieiiii";function get_length_helper(t){try{let e;if(typeof t.size=="number")e=t.size;else if(typeof t.length=="number")e=t.length;else return-2;return e<0?-3:e>2147483647?-4:e}catch(e){return Module.handle_js_error(e),-1}return 0}get_length_helper.sig="ie";function get_length_string(t){try{let e;return typeof t.size=="number"?e=t.size:typeof t.length=="number"&&(e=t.length),stringToNewUTF8(" "+e.toString())}catch(e){return Module.handle_js_error(e),0}errNoRet()}get_length_string.sig="ie";function destroy_jsarray_entries(t){for(let e of t)try{typeof e.destroy=="function"&&e.destroy()}catch(n){console.warn("Weird error:",n)}}destroy_jsarray_entries.sig="ve";function JsArray_repeat_js(t,e){try{return Array.from({length:e},()=>t).flat()}catch(n){return Module.handle_js_error(n),null}errNoRet()}JsArray_repeat_js.sig="eei";function JsArray_inplace_repeat_js(t,e){try{t.splice(0,t.length,...Array.from({length:e},()=>t).flat())}catch(n){return Module.handle_js_error(n),-1}return 0}JsArray_inplace_repeat_js.sig="iei";function JsArray_reversed_iterator(t){return new ReversedIterator(t)}class ReversedIterator{constructor(e){this._array=e,this._i=e.length-1}__length_hint__(){return this._array.length}[Symbol.toStringTag](){return"ReverseIterator"}next(){let e=this._i,n=this._array,_=e<0,r=_?void 0:n[e];return this._i--,{done:_,value:r}}}JsArray_reversed_iterator.sig="ee";function JsArray_index_js(t,e,n,_){try{for(let r=n;r<_;r++)if(t[r]===e)return r;return-1}catch(r){return Module.handle_js_error(r),-1}return 0}JsArray_index_js.sig="ieeii";function JsArray_count_js(t,e){try{let n=0;for(let _=0;_<t.length;_++)t[_]===e&&n++;return n}catch(n){return Module.handle_js_error(n),-1}return 0}JsArray_count_js.sig="iee";function JsArray_reverse_js(t){try{t.reverse()}catch(e){return Module.handle_js_error(e),-1}return 0}JsArray_reverse_js.sig="ie";function JsProxy_subscript_js(t,e){try{let n=t.get(e);return n===void 0&&t.has&&typeof t.has=="function"&&!t.has(e)?null:nullToUndefined(n)}catch(n){return Module.handle_js_error(n),null}errNoRet()}JsProxy_subscript_js.sig="eee";function JsMap_GetIter_js(t){try{let e;return typeof t.keys=="function"?e=t.keys():e=t[Symbol.iterator](),e}catch(e){return Module.handle_js_error(e),null}errNoRet()}JsMap_GetIter_js.sig="ee";function JsMap_clear_js(t){try{return t&&typeof t.clear=="function"?(t.clear(),1):0}catch(e){return Module.handle_js_error(e),-1}return 0}JsMap_clear_js.sig="ie";function JsProxy_Dir_js(t){try{let e=[];do{let n=Object.getOwnPropertyNames(t);e.push(...n.filter(_=>{let r=_.charCodeAt(0);return r<48||r>57}).map(_=>isReservedWord(_.replace(/_*$/,""))?_+"_":_))}while(t=Object.getPrototypeOf(t));return e}catch(e){return Module.handle_js_error(e),null}errNoRet()}JsProxy_Dir_js.sig="ee";function JsProxy_Bool_js(t){try{return t?t.size===0?!!/HTML[A-Za-z]*Element/.test(getTypeTag(t)):!(t.length===0&&JsvArray_Check(t)||t.byteLength===0):!1}catch{return!1}}JsProxy_Bool_js.sig="ie";function JsObjMap_GetIter_js(t){try{return Module.iterObject(t)}catch(e){return Module.handle_js_error(e),null}errNoRet()}JsObjMap_GetIter_js.sig="ee";function JsObjMap_length_js(t){try{let e=0;for(let n of Module.iterObject(t))e++;return e}catch(e){return Module.handle_js_error(e),-1}return 0}JsObjMap_length_js.sig="ie";function JsObjMap_subscript_js(t,e){try{return Object.prototype.hasOwnProperty.call(t,e)?t[e]:null}catch(n){return Module.handle_js_error(n),null}errNoRet()}JsObjMap_subscript_js.sig="eee";function JsObjMap_ass_subscript_js(t,e,n){try{if(n===null){if(!Object.prototype.hasOwnProperty.call(t,e))return-1;delete t[e]}else t[e]=n;return 0}catch(_){return Module.handle_js_error(_),-1}return 0}JsObjMap_ass_subscript_js.sig="ieee";function JsObjMap_contains_js(t,e){try{return Object.prototype.hasOwnProperty.call(t,e)}catch(n){return Module.handle_js_error(n),-1}return 0}JsObjMap_contains_js.sig="iee";function get_async_js_call_done_callback(t){try{return function(e){let n="This borrowed proxy was automatically destroyed at the end of an asynchronous function call. Try using create_proxy or create_once_callable.";for(let _ of t)Module.pyproxy_destroy(_,n,!1);API.isPyProxy(e)&&Module.pyproxy_destroy(e,n,!1)}}catch(e){return Module.handle_js_error(e),null}errNoRet()}get_async_js_call_done_callback.sig="ee";function wrap_generator(t,e){try{let _=function(){e.forEach(a=>Module.pyproxy_destroy(a,n))},r=function(a){return function(o){API.isPyProxy(o)&&(o=o.copy(),e.add(o));let l;try{l=t[a](o)}catch(p){throw _(),p}return l.done&&(e.delete(l.value),_()),l}};e=new Set(e);let n="This borrowed proxy was automatically destroyed when a generator completed execution. Try using create_proxy or create_once_callable.";return{get[Symbol.toStringTag](){return"Generator"},[Symbol.iterator](){return this},next:r("next"),throw:r("throw"),return:r("return")}}catch(n){return Module.handle_js_error(n),null}errNoRet()}wrap_generator.sig="eee";function wrap_async_generator(t,e){try{let _=function(){e.forEach(a=>Module.pyproxy_destroy(a,n))},r=function(a){return async function(o){API.isPyProxy(o)&&(o=o.copy(),e.add(o));let l;try{l=await t[a](o)}catch(p){throw _(),p}return l.done&&(e.delete(l.value),_()),l}};e=new Set(e);let n="This borrowed proxy was automatically destroyed when an asynchronous generator completed execution. Try using create_proxy or create_once_callable.";return{get[Symbol.toStringTag](){return"AsyncGenerator"},[Symbol.asyncIterator](){return this},next:r("next"),throw:r("throw"),return:r("return")}}catch(n){return Module.handle_js_error(n),null}errNoRet()}wrap_async_generator.sig="eee";function JsBuffer_DecodeString_js(t,e){try{let n;e&&(n=UTF8ToString(e));let _=new TextDecoder(n,{fatal:!0,ignoreBOM:!0}),r;try{r=_.decode(t)}catch(a){if(a instanceof TypeError)return null;throw a}return r}catch(n){return Module.handle_js_error(n),null}errNoRet()}JsBuffer_DecodeString_js.sig="eei";function JsBuffer_get_info(t,e,n,_,r){let[a,o,l]=Module.get_buffer_datatype(t);HEAPU32[(e>>2)+0]=t.byteLength,HEAPU32[(n>>2)+0]=a,HEAPU32[(_>>2)+0]=o,HEAPU8[r+0]=l}JsBuffer_get_info.sig="veiiii";function JsDoubleProxy_unwrap_helper(t){try{return Module.PyProxy_getPtr(t)}catch(e){return Module.handle_js_error(e),0}errNoRet()}JsDoubleProxy_unwrap_helper.sig="ie";function JsProxy_compute_typeflags(t){try{let _=function(l){try{return l()}catch{return!1}},e=0;if(API.isPyProxy(t)&&!pyproxyIsAlive(t))return 0;let n=getTypeTag(t),r=_(()=>ArrayBuffer.isView(t)),a=_(()=>Array.isArray(t)),o=_(()=>t.constructor.name)||"";return typeof t=="function"&&(e|=512),hasMethod(t,"then")&&(e|=128),hasMethod(t,Symbol.iterator)&&(e|=1),hasMethod(t,Symbol.asyncIterator)&&(e|=32768),hasMethod(t,"next")&&(hasMethod(t,Symbol.iterator)||!hasMethod(t,Symbol.asyncIterator))&&(e|=2),hasMethod(t,"next")&&(!hasMethod(t,Symbol.iterator)||hasMethod(t,Symbol.asyncIterator))&&(e|=262144),(hasProperty(t,"size")||hasProperty(t,"length")&&typeof t!="function")&&(e|=4),hasMethod(t,"get")&&(e|=8),hasMethod(t,"set")&&(e|=16),hasMethod(t,"has")&&(e|=32),hasMethod(t,"includes")&&(e|=64),(r||n==="[object ArrayBuffer]")&&!(e&512)&&(e|=256),API.isPyProxy(t)&&(e|=8192),a&&(e|=1024),(n==="[object HTMLCollection]"||n==="[object NodeList]")&&(e|=2048),r&&n!=="[object DataView]"&&(e|=4096),n==="[object Generator]"&&(e|=65536),n==="[object AsyncGenerator]"&&(e|=131072),hasProperty(t,"name")&&hasProperty(t,"message")&&(hasProperty(t,"stack")||o==="DOMException")&&!(e&768)&&(e|=524288),e}catch(e){return Module.handle_js_error(e),-1}return 0}JsProxy_compute_typeflags.sig="ie";function is_comlink_proxy(t){try{return!!(API.Comlink&&value[API.Comlink.createEndpoint])}catch{return!1}}is_comlink_proxy.sig="ie";function throw_no_gil(){throw new API.NoGilError("Attempted to use PyProxy when Python GIL not held")}throw_no_gil.sig="v";function pyproxy_Check(t){return API.isPyProxy(t)}pyproxy_Check.sig="ie";function pyproxy_AsPyObject(t){return!API.isPyProxy(t)||!pyproxyIsAlive(t)?0:Module.PyProxy_getPtr(t)}pyproxy_AsPyObject.sig="ie";function destroy_proxies(t,e){let n;e&&(n=_JsvString_FromId(e));for(let _ of t)Module.pyproxy_destroy(_,n,!1)}destroy_proxies.sig="vei";function gc_register_proxies(t){for(let e of t)Module.gc_register_proxy(Module.PyProxy_getAttrs(e).shared)}gc_register_proxies.sig="ve";function destroy_proxy(t,e){let{shared:n,props:_}=Module.PyProxy_getAttrsQuiet(t);if(!n.ptr||_.roundtrip)return;let r;e&&(r=_JsvString_FromId(e)),Module.pyproxy_destroy(t,r,!1)}destroy_proxy.sig="vei";function proxy_cache_get(t,e){let n=t.get(e);return n?pyproxyIsAlive(n)?n:(t.delete(e),null):null}proxy_cache_get.sig="eei";function proxy_cache_set(t,e,n){t.set(e,n)}proxy_cache_set.sig="veie";function _pyproxyGen_make_result(t,e){return{done:!!t,value:e}}_pyproxyGen_make_result.sig="eie";function array_to_js(t,e){return Array.from(HEAP32.subarray(t/4,t/4+e))}array_to_js.sig="eii";function _pyproxy_get_buffer_result(t,e,n,_,r,a,o,l,p,c,I,A){return r=UTF8ToString(r),{start_ptr:t,smallest_ptr:e,largest_ptr:n,readonly:_,format:r,itemsize:a,shape:o,strides:l,view:p,c_contiguous:c,f_contiguous:I}}_pyproxy_get_buffer_result.sig="eiiiiiieeiiii";function pyproxy_new_ex(t,e,n,_){try{return Module.pyproxy_new(t,{props:{captureThis:!!e,roundtrip:!!n},gcRegister:_})}catch(r){return Module.handle_js_error(r),null}errNoRet()}pyproxy_new_ex.sig="eiiii";function pyproxy_new(t){try{return Module.pyproxy_new(t)}catch(e){return Module.handle_js_error(e),null}errNoRet()}pyproxy_new.sig="ei";function create_once_callable(t){try{let n=function(..._){if(e)throw new Error("OnceProxy can only be called once");try{return Module.callPyObject(t,_)}finally{n.destroy()}};_Py_IncRef(t);let e=!1;return n.destroy=function(){if(e)throw new Error("OnceProxy has already been destroyed");e=!0,Module.finalizationRegistry.unregister(n),_Py_DecRef(t)},Module.finalizationRegistry.register(n,[t,void 0],n),n}catch(e){return Module.handle_js_error(e),null}errNoRet()}create_once_callable.sig="ei";function create_promise_handles(t,e,n){try{let r=function(){if(_)throw new Error("One of the promise handles has already been called.")},a=function(){r(),_=!0,t&&_Py_DecRef(t),e&&_Py_DecRef(e)},o=function(p){r();try{if(t)return Module.callPyObject(t,[p])}finally{n(p),a()}},l=function(p){r();try{if(e)return Module.callPyObject(e,[p])}finally{n(void 0),a()}};t&&_Py_IncRef(t),e&&_Py_IncRef(e),n||(n=p=>{});let _=!1;return o.destroy=a,l.destroy=a,[o,l]}catch(_){return Module.handle_js_error(_),null}errNoRet()}create_promise_handles.sig="eiie";function _python2js_buffer_inner(t,e,n,_,r,a,o){try{let l=Module.get_converter(_,e);return Module._python2js_buffer_recursive(t,0,{ndim:n,format:_,itemsize:e,shape:r,strides:a,suboffsets:o,converter:l})}catch(l){return Module.handle_js_error(l),null}errNoRet()}_python2js_buffer_inner.sig="eiiiiiii";function python2js_buffer_init(){try{return Module.processBufferFormatString=function(t,e=""){if(t.length>2)throw new Error(`Expected format string to have length <= 2, got '${t}'.`+e);let n=t.slice(-1),_=t.slice(0,-1),r;switch(_){case"!":case">":r=!0;break;case"<":case"@":case"=":case"":r=!1;break;default:throw new Error(`Unrecognized alignment character ${_}.`+e)}let a;switch(n){case"b":a=Int8Array;break;case"s":case"p":case"c":case"B":case"?":a=Uint8Array;break;case"h":a=Int16Array;break;case"H":a=Uint16Array;break;case"i":case"l":case"n":a=Int32Array;break;case"I":case"L":case"N":case"P":a=Uint32Array;break;case"q":if(globalThis.BigInt64Array===void 0)throw new Error("BigInt64Array is not supported on this browser."+e);a=BigInt64Array;break;case"Q":if(globalThis.BigUint64Array===void 0)throw new Error("BigUint64Array is not supported on this browser."+e);a=BigUint64Array;break;case"f":a=Float32Array;break;case"d":a=Float64Array;break;case"e":throw new Error("Javascript has no Float16 support.");default:throw new Error(`Unrecognized format character '${n}'.`+e)}return[a,r]},Module.python2js_buffer_1d_contiguous=function(t,e,n){let _=e*n;return HEAP8.slice(t,t+_).buffer},Module.python2js_buffer_1d_noncontiguous=function(t,e,n,_,r){let a=r*_,o=new Uint8Array(a);for(let l=0;l<_;++l){let p=t+l*e;n>=0&&(p=HEAPU32[(p>>2)+0]+n),o.set(HEAP8.subarray(p,p+r),l*r)}return o.buffer},Module._python2js_buffer_recursive=function(t,e,n){let _=HEAPU32[(n.shape>>2)+e],r=HEAP32[(n.strides>>2)+e],a=-1;if(n.suboffsets!==0&&(a=HEAP32[(n.suboffsets>>2)+e]),e===n.ndim-1){let l;return r===n.itemsize&&a<0?l=Module.python2js_buffer_1d_contiguous(t,r,_):l=Module.python2js_buffer_1d_noncontiguous(t,r,a,_,n.itemsize),n.converter(l)}let o=[];for(let l=0;l<_;++l){let p=t+l*r;a>=0&&(curptr=HEAPU32[(curptr>>2)+0]+a),o.push(Module._python2js_buffer_recursive(p,e+1,n))}return o},Module.get_converter=function(t,e){let n=UTF8ToString(t),[_,r]=Module.processBufferFormatString(n);switch(n.slice(-1)){case"s":let c=new TextDecoder("utf8",{ignoreBOM:!0});return I=>c.decode(I);case"?":return I=>Array.from(new Uint8Array(I),A=>!!A)}if(!r)return c=>new _(c);let o,l;switch(e){case 2:o="getUint16",l="setUint16";break;case 4:o="getUint32",l="setUint32";break;case 8:o="getFloat64",l="setFloat64";break;default:throw new Error(`Unexpected size ${e}`)}function p(c){let I=new DataView(c),A=I[o].bind(I),m=I[l].bind(I);for(let E=0;E<I.byteLength;E+=e)m(E,A(E,!0),!1);return c}return c=>new _(p(c))},0}catch(t){return Module.handle_js_error(t),-1}return 0}python2js_buffer_init.sig="i";function jslib_init_js(){try{return HEAP32[_Jsr_undefined/4]=_hiwire_intern(void 0),HEAP32[_Jsr_true/4]=_hiwire_intern(!0),HEAP32[_Jsr_false/4]=_hiwire_intern(!1),HEAP32[_Jsr_novalue/4]=_hiwire_intern({noValueMarker:1}),Module.novalue=_hiwire_get(HEAP32[_Jsr_novalue/4]),Hiwire.num_keys=_hiwire_num_refs,0}catch(t){return Module.handle_js_error(t),-1}return 0}jslib_init_js.sig="i";function JsvNoValue_Check(t){return t===Module.novalue}JsvNoValue_Check.sig="ie";function JsvNum_fromInt(t){return t}JsvNum_fromInt.sig="ei";function JsvNum_fromDouble(t){return t}JsvNum_fromDouble.sig="ed";function JsvNum_fromDigits(t,e){let n=BigInt(0);for(let _=0;_<e;_++)n+=BigInt(HEAPU32[(t>>2)+_])<<BigInt(32*_);return n+=BigInt(HEAPU32[(t>>2)+e-1]&2147483648)<<BigInt(1+32*(e-1)),-Number.MAX_SAFE_INTEGER<n&&n<Number.MAX_SAFE_INTEGER&&(n=Number(n)),n}JsvNum_fromDigits.sig="eii";function Jsv_to_bool(t){return!!t}Jsv_to_bool.sig="ie";function Jsv_typeof(t){return typeof t}Jsv_typeof.sig="ee";function Jsv_constructorName(t){try{return stringToNewUTF8(t.constructor.name)}catch(e){return Module.handle_js_error(e),0}errNoRet()}Jsv_constructorName.sig="ie";function JsvUTF8ToString(t){return UTF8ToString(t)}JsvUTF8ToString.sig="ei";function JsvArray_New(){return[]}JsvArray_New.sig="e";function JsvArray_Check(t){try{if(Array.isArray(t))return!0;let e=getTypeTag(t);return!!(e==="[object HTMLCollection]"||e==="[object NodeList]"||ArrayBuffer.isView(t)&&t.constructor.name!=="DataView")}catch{return!1}}JsvArray_Check.sig="ie";function JsvArray_Get(t,e){try{let n=t[e];return n===void 0&&!(e in t)?null:nullToUndefined(n)}catch(n){return Module.handle_js_error(n),null}errNoRet()}JsvArray_Get.sig="eei";function JsvArray_Set(t,e,n){try{t[e]=n}catch(_){return Module.handle_js_error(_),-1}return 0}JsvArray_Set.sig="ieie";function JsvArray_Delete(t,e){try{return e<0||e>=t.length?null:t.splice(e,1)[0]}catch(n){return Module.handle_js_error(n),null}errNoRet()}JsvArray_Delete.sig="eei";function JsvArray_Push(t,e){return t.push(e)}JsvArray_Push.sig="iee";function JsvArray_Extend(t,e){t.push(...e)}JsvArray_Extend.sig="vee";function JsvArray_Insert(t,e,n){try{t.splice(e,0,n)}catch(_){return Module.handle_js_error(_),-1}return 0}JsvArray_Insert.sig="ieie";function JsvArray_ShallowCopy(t){try{return"slice"in t?t.slice():Array.from(t)}catch(e){return Module.handle_js_error(e),-1}return 0}JsvArray_ShallowCopy.sig="ee";function JsvArray_slice(t,e,n,_,r){try{let a;return r===1?a=t.slice(n,_):a=Array.from({length:e},(o,l)=>t[n+l*r]),a}catch(a){return Module.handle_js_error(a),null}errNoRet()}JsvArray_slice.sig="eeiiii";function JsvArray_slice_assign(t,e,n,_,r,a,o){try{let l=[];for(let p=0;p<a;p++){let c=_python2js(HEAPU32[(o>>2)+p]);if(c===null)return-1;l.push(c)}if(r===1)t.splice(n,e,...l);else if(o!==0)for(let p=0;p<e;p++)t.splice(n+p*r,1,l[p]);else for(let p=e-1;p>=0;p--)t.splice(n+p*r,1)}catch(l){return Module.handle_js_error(l),-1}return 0}JsvArray_slice_assign.sig="ieiiiiii";function JsvObject_New(){return{}}JsvObject_New.sig="e";function JsvObject_SetAttr(t,e,n){try{t[e]=n}catch(_){return Module.handle_js_error(_),-1}return 0}JsvObject_SetAttr.sig="ieee";function JsvObject_Entries(t){try{return Object.entries(t)}catch(e){return Module.handle_js_error(e),null}errNoRet()}JsvObject_Entries.sig="ee";function JsvObject_Keys(t){try{return Object.keys(t)}catch(e){return Module.handle_js_error(e),null}errNoRet()}JsvObject_Keys.sig="ee";function JsvObject_Values(t){try{return Object.values(t)}catch(e){return Module.handle_js_error(e),null}errNoRet()}JsvObject_Values.sig="ee";function JsvObject_toString(t){try{return t.toString()}catch(e){return Module.handle_js_error(e),null}errNoRet()}JsvObject_toString.sig="ee";function JsvObject_CallMethod(t,e,n){try{return nullToUndefined(t[e](...n))}catch(_){return Module.handle_js_error(_),null}errNoRet()}JsvObject_CallMethod.sig="eeee";function JsvObject_CallMethod_NoArgs(t,e){try{return nullToUndefined(t[e]())}catch(n){return Module.handle_js_error(n),null}errNoRet()}JsvObject_CallMethod_NoArgs.sig="eee";function JsvObject_CallMethod_OneArg(t,e,n){try{return nullToUndefined(t[e](n))}catch(_){return Module.handle_js_error(_),null}errNoRet()}JsvObject_CallMethod_OneArg.sig="eeee";function JsvObject_CallMethod_TwoArgs(t,e,n,_){try{return nullToUndefined(t[e](n,_))}catch(r){return Module.handle_js_error(r),null}errNoRet()}JsvObject_CallMethod_TwoArgs.sig="eeeee";function JsvFunction_Check(t){try{return typeof t=="function"}catch{return!1}}JsvFunction_Check.sig="ie";function JsvFunction_CallBound(t,e,n){try{return nullToUndefined(t.apply(e,n))}catch(_){return Module.handle_js_error(_),null}errNoRet()}JsvFunction_CallBound.sig="eeee";function JsvFunction_Call_OneArg(t,e){try{return nullToUndefined(t.apply(null,[e]))}catch(n){return Module.handle_js_error(n),null}errNoRet()}JsvFunction_Call_OneArg.sig="eee";function JsvFunction_Construct(t,e){try{return nullToUndefined(Reflect.construct(t,e))}catch(n){return Module.handle_js_error(n),null}errNoRet()}JsvFunction_Construct.sig="eee";function JsvPromise_Check(t){try{return isPromise(t)}catch{return!1}}JsvPromise_Check.sig="ie";function JsvPromise_Resolve(t){try{return Promise.resolve(t)}catch(e){return Module.handle_js_error(e),null}errNoRet()}JsvPromise_Resolve.sig="ee";function JsvPromise_Syncify_handleError(){Module.syncify_error&&(Module.handle_js_error(Module.syncify_error),delete Module.syncify_error)}JsvPromise_Syncify_handleError.sig="v";function jslib_init_buffers_js(){try{let t=["b","B","h","H","i","I","f","d"].join("\0"),e=stringToNewUTF8(t),n=Object.fromEntries(Object.entries(t).map(([r,a])=>[a,e+ +r])),_=new Map([["Int8Array",[n.b,1,!0]],["Uint8Array",[n.B,1,!0]],["Uint8ClampedArray",[n.B,1,!0]],["Int16Array",[n.h,2,!0]],["Uint16Array",[n.H,2,!0]],["Int32Array",[n.i,4,!0]],["Uint32Array",[n.I,4,!0]],["Float32Array",[n.f,4,!0]],["Float64Array",[n.d,8,!0]],["DataView",[n.B,1,!1]],["ArrayBuffer",[n.B,1,!1]]]);Module.get_buffer_datatype=function(r){return _.get(r.constructor.name)||[0,0,!1]}}catch(t){return Module.handle_js_error(t),-1}return 0}jslib_init_buffers_js.sig="i";function JsvBuffer_assignToPtr(t,e){try{Module.HEAPU8.set(bufferAsUint8Array(t),e)}catch(n){return Module.handle_js_error(n),-1}return 0}JsvBuffer_assignToPtr.sig="iei";function JsvBuffer_assignFromPtr(t,e){try{bufferAsUint8Array(t).set(Module.HEAPU8.subarray(e,e+t.byteLength))}catch(n){return Module.handle_js_error(n),-1}return 0}JsvBuffer_assignFromPtr.sig="iei";function JsvBuffer_readFromFile(t,e){try{let n=bufferAsUint8Array(t),_=Module.FS.streams[e];Module.FS.read(_,n,0,n.byteLength)}catch(n){return Module.handle_js_error(n),-1}return 0}JsvBuffer_readFromFile.sig="iei";function JsvBuffer_writeToFile(t,e){try{let n=bufferAsUint8Array(t),_=Module.FS.streams[e];Module.FS.write(_,n,0,n.byteLength)}catch(n){return Module.handle_js_error(n),-1}return 0}JsvBuffer_writeToFile.sig="iei";function JsvBuffer_intoFile(t,e){try{let n=bufferAsUint8Array(t),_=Module.FS.streams[e];Module.FS.write(_,n,0,n.byteLength,void 0,!0)}catch(n){return Module.handle_js_error(n),-1}return 0}JsvBuffer_intoFile.sig="iei";function JsvGenerator_Check(t){try{return getTypeTag(t)==="[object Generator]"}catch{return!1}}JsvGenerator_Check.sig="ie";function JsvAsyncGenerator_Check(t){try{return getTypeTag(t)==="[object AsyncGenerator]"}catch{return!1}}JsvAsyncGenerator_Check.sig="ie";function JsvError_Throw(t){throw t}JsvError_Throw.sig="ve";function Jsv_less_than(t,e){try{return t<e}catch{return!1}}Jsv_less_than.sig="iee";function Jsv_less_than_equal(t,e){try{return t<=e}catch{return!1}}Jsv_less_than_equal.sig="iee";function Jsv_equal(t,e){try{return t===e}catch{return!1}}Jsv_equal.sig="iee";function Jsv_not_equal(t,e){try{return t!==e}catch{return!1}}Jsv_not_equal.sig="iee";function Jsv_greater_than(t,e){try{return t>e}catch{return!1}}Jsv_greater_than.sig="iee";function Jsv_greater_than_equal(t,e){try{return t>=e}catch{return!1}}Jsv_greater_than_equal.sig="iee";function JsvMap_New(){try{return new Map}catch(t){return Module.handle_js_error(t),null}errNoRet()}JsvMap_New.sig="e";function JsvMap_Set(t,e,n){try{t.set(e,n)}catch(_){return Module.handle_js_error(_),-1}return 0}JsvMap_Set.sig="ieee";function JsvSet_New(){try{return new Set}catch(t){return Module.handle_js_error(t),null}errNoRet()}JsvSet_New.sig="e";function JsvSet_Add(t,e){try{t.add(e)}catch(n){return Module.handle_js_error(n),-1}return 0}JsvSet_Add.sig="iee";function _python2js_addto_postprocess_list(t,e,n,_){t.push([e,n,_])}_python2js_addto_postprocess_list.sig="veeei";function _python2js_handle_postprocess_list(t,e){for(let[n,_,r]of t){let a=e.get(r);n.constructor.name==="Map"?n.set(_,a):n[_]=a}}_python2js_handle_postprocess_list.sig="vee";function _python2js_ucs1(t,e){try{let n="";for(let _=0;_<e;++_)n+=String.fromCharCode(HEAPU8[t+_]);return n}catch(n){return Module.handle_js_error(n),null}errNoRet()}_python2js_ucs1.sig="eii";function _python2js_ucs2(t,e){try{let n="";for(let _=0;_<e;++_)n+=String.fromCharCode(HEAPU16[(t>>1)+_]);return n}catch(n){return Module.handle_js_error(n),null}errNoRet()}_python2js_ucs2.sig="eii";function _python2js_ucs4(t,e){try{let n="";for(let _=0;_<e;++_)n+=String.fromCodePoint(HEAPU32[(t>>2)+_]);return n}catch(n){return Module.handle_js_error(n),null}errNoRet()}_python2js_ucs4.sig="eii";function _python2js_add_to_cache(t,e,n){try{t.set(e,n)}catch(_){return Module.handle_js_error(_),-1}return 0}_python2js_add_to_cache.sig="ieie";function _python2js_cache_lookup(t,e){return t.get(e)||null}_python2js_cache_lookup.sig="eei";function _JsArray_PushEntry_helper(t,e,n){try{t.push([e,n])}catch(_){return Module.handle_js_error(_),-1}return 0}_JsArray_PushEntry_helper.sig="ieee";function _JsArray_PostProcess_helper(t,e){try{return t.dict_converter(e)}catch(n){return Module.handle_js_error(n),null}errNoRet()}_JsArray_PostProcess_helper.sig="eee";function python2js__default_converter_js(t,e){try{let n=Module.pyproxy_new(e),_=t.default_converter(n,t.converter,t.cacheConversion);return n.destroy(),_}catch(n){return Module.handle_js_error(n),null}errNoRet()}python2js__default_converter_js.sig="eei";function python2js_custom__create_jscontext(t,e,n,_){try{let r={};return n&&(r.dict_converter=n),_&&(r.default_converter=_,r.cacheConversion=function(a,o){if(!API.isPyProxy(a))throw new TypeError("The first argument to cacheConversion must be a PyProxy.");let l=Module.PyProxy_getPtr(a);e.set(l,o)},r.converter=function(a){if(!API.isPyProxy(a))return a;let o=Module.PyProxy_getPtr(a);return __python2js(t,o)}),r}catch(r){return Module.handle_js_error(r),null}errNoRet()}python2js_custom__create_jscontext.sig="eieee";function destroy_proxies_js(t){try{for(let e of t)e.destroy()}catch(e){return Module.handle_js_error(e),-1}return 0}destroy_proxies_js.sig="ie";function pyodide_js_init(){"use strict";(()=>{var t=Object.create,e=Object.defineProperty,n=Object.getOwnPropertyDescriptor,_=Object.getOwnPropertyNames,r=Object.getPrototypeOf,a=Object.prototype.hasOwnProperty,o=(d,u)=>e(d,"name",{value:u,configurable:!0}),l=(d=>typeof Vt<"u"?Vt:typeof Proxy<"u"?new Proxy(d,{get:(u,T)=>(typeof Vt<"u"?Vt:u)[T]}):d)(function(d){if(typeof Vt<"u")return Vt.apply(this,arguments);throw new Error('Dynamic require of "'+d+'" is not supported')}),p=(d,u)=>()=>(u||d((u={exports:{}}).exports,u),u.exports),c=(d,u,T,D)=>{if(u&&typeof u=="object"||typeof u=="function")for(let S of _(u))!a.call(d,S)&&S!==T&&e(d,S,{get:()=>u[S],enumerable:!(D=n(u,S))||D.enumerable});return d},I=(d,u,T)=>(T=d!=null?t(r(d)):{},c(u||!d||!d.__esModule?e(T,"default",{value:d,enumerable:!0}):T,d)),A=p((d,u)=>{(function(T,D){"use strict";typeof define=="function"&&define.amd?define("stackframe",[],D):typeof d=="object"?u.exports=D():T.StackFrame=D()})(d,function(){"use strict";function T(Dt){return!isNaN(parseFloat(Dt))&&isFinite(Dt)}o(T,"_isNumber");function D(Dt){return Dt.charAt(0).toUpperCase()+Dt.substring(1)}o(D,"_capitalize");function S(Dt){return function(){return this[Dt]}}o(S,"_getter");var F=["isConstructor","isEval","isNative","isToplevel"],x=["columnNumber","lineNumber"],K=["fileName","functionName","source"],j=["args"],pt=["evalOrigin"],mt=F.concat(x,K,j,pt);function ft(Dt){if(Dt)for(var bt=0;bt<mt.length;bt++)Dt[mt[bt]]!==void 0&&this["set"+D(mt[bt])](Dt[mt[bt]])}o(ft,"StackFrame"),ft.prototype={getArgs:function(){return this.args},setArgs:function(Dt){if(Object.prototype.toString.call(Dt)!=="[object Array]")throw new TypeError("Args must be an Array");this.args=Dt},getEvalOrigin:function(){return this.evalOrigin},setEvalOrigin:function(Dt){if(Dt instanceof ft)this.evalOrigin=Dt;else if(Dt instanceof Object)this.evalOrigin=new ft(Dt);else throw new TypeError("Eval Origin must be an Object or StackFrame")},toString:function(){var Dt=this.getFileName()||"",bt=this.getLineNumber()||"",Yt=this.getColumnNumber()||"",le=this.getFunctionName()||"";return this.getIsEval()?Dt?"[eval] ("+Dt+":"+bt+":"+Yt+")":"[eval]:"+bt+":"+Yt:le?le+" ("+Dt+":"+bt+":"+Yt+")":Dt+":"+bt+":"+Yt}},ft.fromString=o(function(Dt){var bt=Dt.indexOf("("),Yt=Dt.lastIndexOf(")"),le=Dt.substring(0,bt),zn=Dt.substring(bt+1,Yt).split(","),Dn=Dt.substring(Yt+1);if(Dn.indexOf("@")===0)var Pe=/@(.+?)(?::(\d+))?(?::(\d+))?$/.exec(Dn,""),Kn=Pe[1],w_=Pe[2],x_=Pe[3];return new ft({functionName:le,args:zn||void 0,fileName:Kn,lineNumber:w_||void 0,columnNumber:x_||void 0})},"StackFrame$$fromString");for(var St=0;St<F.length;St++)ft.prototype["get"+D(F[St])]=S(F[St]),ft.prototype["set"+D(F[St])]=function(Dt){return function(bt){this[Dt]=!!bt}}(F[St]);for(var xt=0;xt<x.length;xt++)ft.prototype["get"+D(x[xt])]=S(x[xt]),ft.prototype["set"+D(x[xt])]=function(Dt){return function(bt){if(!T(bt))throw new TypeError(Dt+" must be a Number");this[Dt]=Number(bt)}}(x[xt]);for(var ae=0;ae<K.length;ae++)ft.prototype["get"+D(K[ae])]=S(K[ae]),ft.prototype["set"+D(K[ae])]=function(Dt){return function(bt){this[Dt]=String(bt)}}(K[ae]);return ft})}),m=p((d,u)=>{(function(T,D){"use strict";typeof define=="function"&&define.amd?define("error-stack-parser",["stackframe"],D):typeof d=="object"?u.exports=D(A()):T.ErrorStackParser=D(T.StackFrame)})(d,o(function(T){"use strict";var D=/(^|@)\S+:\d+/,S=/^\s*at .*(\S+:\d+|\(native\))/m,F=/^(eval@)?(\[native code])?$/;return{parse:o(function(x){if(typeof x.stacktrace<"u"||typeof x["opera#sourceloc"]<"u")return this.parseOpera(x);if(x.stack&&x.stack.match(S))return this.parseV8OrIE(x);if(x.stack)return this.parseFFOrSafari(x);throw new Error("Cannot parse given Error object")},"ErrorStackParser$$parse"),extractLocation:o(function(x){if(x.indexOf(":")===-1)return[x];var K=/(.+?)(?::(\d+))?(?::(\d+))?$/,j=K.exec(x.replace(/[()]/g,""));return[j[1],j[2]||void 0,j[3]||void 0]},"ErrorStackParser$$extractLocation"),parseV8OrIE:o(function(x){var K=x.stack.split(`
`).filter(function(j){return!!j.match(S)},this);return K.map(function(j){j.indexOf("(eval ")>-1&&(j=j.replace(/eval code/g,"eval").replace(/(\(eval at [^()]*)|(,.*$)/g,""));var pt=j.replace(/^\s+/,"").replace(/\(eval code/g,"(").replace(/^.*?\s+/,""),mt=pt.match(/ (\(.+\)$)/);pt=mt?pt.replace(mt[0],""):pt;var ft=this.extractLocation(mt?mt[1]:pt),St=mt&&pt||void 0,xt=["eval","<anonymous>"].indexOf(ft[0])>-1?void 0:ft[0];return new T({functionName:St,fileName:xt,lineNumber:ft[1],columnNumber:ft[2],source:j})},this)},"ErrorStackParser$$parseV8OrIE"),parseFFOrSafari:o(function(x){var K=x.stack.split(`
`).filter(function(j){return!j.match(F)},this);return K.map(function(j){if(j.indexOf(" > eval")>-1&&(j=j.replace(/ line (\d+)(?: > eval line \d+)* > eval:\d+:\d+/g,":$1")),j.indexOf("@")===-1&&j.indexOf(":")===-1)return new T({functionName:j});var pt=/((.*".+"[^@]*)?[^@]*)(?:@)/,mt=j.match(pt),ft=mt&&mt[1]?mt[1]:void 0,St=this.extractLocation(j.replace(pt,""));return new T({functionName:ft,fileName:St[0],lineNumber:St[1],columnNumber:St[2],source:j})},this)},"ErrorStackParser$$parseFFOrSafari"),parseOpera:o(function(x){return!x.stacktrace||x.message.indexOf(`
`)>-1&&x.message.split(`
`).length>x.stacktrace.split(`
`).length?this.parseOpera9(x):x.stack?this.parseOpera11(x):this.parseOpera10(x)},"ErrorStackParser$$parseOpera"),parseOpera9:o(function(x){for(var K=/Line (\d+).*script (?:in )?(\S+)/i,j=x.message.split(`
`),pt=[],mt=2,ft=j.length;mt<ft;mt+=2){var St=K.exec(j[mt]);St&&pt.push(new T({fileName:St[2],lineNumber:St[1],source:j[mt]}))}return pt},"ErrorStackParser$$parseOpera9"),parseOpera10:o(function(x){for(var K=/Line (\d+).*script (?:in )?(\S+)(?:: In function (\S+))?$/i,j=x.stacktrace.split(`
`),pt=[],mt=0,ft=j.length;mt<ft;mt+=2){var St=K.exec(j[mt]);St&&pt.push(new T({functionName:St[3]||void 0,fileName:St[2],lineNumber:St[1],source:j[mt]}))}return pt},"ErrorStackParser$$parseOpera10"),parseOpera11:o(function(x){var K=x.stack.split(`
`).filter(function(j){return!!j.match(D)&&!j.match(/^Error created at/)},this);return K.map(function(j){var pt=j.split("@"),mt=this.extractLocation(pt.pop()),ft=pt.shift()||"",St=ft.replace(/<anonymous function(: (\w+))?>/,"$2").replace(/\([^)]*\)/g,"")||void 0,xt;ft.match(/\(([^)]*)\)/)&&(xt=ft.replace(/^[^(]+\(([^)]*)\)$/,"$1"));var ae=xt===void 0||xt==="[arguments not available]"?void 0:xt.split(",");return new T({functionName:St,args:ae,fileName:mt[0],lineNumber:mt[1],columnNumber:mt[2],source:j})},this)},"ErrorStackParser$$parseOpera11")}},"ErrorStackParser"))}),E=I(m()),f=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string"&&typeof process.browser>"u",R=f&&typeof module<"u"&&typeof module.exports<"u"&&typeof l<"u"&&typeof __dirname<"u",h=typeof Deno<"u",w=!f&&!h,g=w&&typeof window<"u"&&typeof document<"u"&&typeof document.createElement<"u"&&typeof sessionStorage<"u",O=w&&typeof importScripts<"u"&&typeof self<"u",W,k,Z,v,tt,z=`"fetch" is not defined, maybe you're using node < 18? From Pyodide >= 0.25.0, node >= 18 is required. Older versions of Node.js may work, but it is not guaranteed or supported. Falling back to "node-fetch".`;async function et(){if(!f||(W=(await Promise.resolve().then(()=>Gt(Pn()))).default,tt=await import("fs/promises"),globalThis.fetch?k=fetch:(console.warn(z),k=(await import("node-fetch")).default),v=(await Promise.resolve().then(()=>Gt(Yn()))).default,Z=await Promise.resolve().then(()=>Gt(Ke())),it=Z.sep,typeof l<"u"))return;let d=await Promise.resolve().then(()=>Gt(gn())),u=await Promise.resolve().then(()=>Gt(yn())),T=await Promise.resolve().then(()=>Gt(Ye())),D=await Promise.resolve().then(()=>Gt(Sn())),S={fs:d,crypto:u,ws:T,child_process:D};globalThis.require=function(F){return S[F]}}o(et,"initNodeModules");function At(d,u){return Z.resolve(u||".",d)}o(At,"node_resolvePath");function rt(d,u){return u===void 0&&(u=location),new URL(d,u).toString()}o(rt,"browser_resolvePath");var J;f?J=At:J=rt;var it;f||(it="/");function ot(d,u){return d.startsWith("file://")&&(d=d.slice(7)),d.includes("://")?{response:k(d)}:{binary:tt.readFile(d).then(T=>new Uint8Array(T.buffer,T.byteOffset,T.byteLength))}}o(ot,"node_getBinaryResponse");function G(d,u){let T=new URL(d,location);return{response:fetch(T,u?{integrity:u}:{})}}o(G,"browser_getBinaryResponse");var ht;f?ht=ot:ht=G;async function Pt(d,u){let{response:T,binary:D}=ht(d,u);if(D)return D;let S=await T;if(!S.ok)throw new Error(`Failed to load '${d}': request failed.`);return new Uint8Array(await S.arrayBuffer())}o(Pt,"loadBinaryFile");var Lt;if(g)Lt=o(async d=>await import(d),"loadScript");else if(O)Lt=o(async d=>{try{globalThis.importScripts(d)}catch(u){if(u instanceof TypeError)await import(d);else throw u}},"loadScript");else if(f)Lt=vt;else throw new Error("Cannot determine runtime environment");async function vt(d){d.startsWith("file://")&&(d=d.slice(7)),d.includes("://")?v.runInThisContext(await(await k(d)).text()):await import(W.pathToFileURL(d).href)}o(vt,"nodeLoadScript");function Ct(d){return Buffer.from(d,"hex").toString("base64")}o(Ct,"nodeBase16ToBase64");function te(d){return btoa(d.match(/\w{2}/g).map(function(u){return String.fromCharCode(parseInt(u,16))}).join(""))}o(te,"browserBase16ToBase64");var gt=f?Ct:te;function jt(d){try{return d instanceof Tt}catch{return!1}}o(jt,"isPyProxy"),API.isPyProxy=jt,globalThis.FinalizationRegistry?Module.finalizationRegistry=new FinalizationRegistry(({ptr:d,cache:u})=>{u&&(u.leaked=!0,Ie(u));try{_check_gil();let T=Module.validSuspender.value;Module.validSuspender.value=!1,_Py_DecRef(d),Module.validSuspender.value=T}catch(T){API.fatal_error(T)}}):Module.finalizationRegistry={register(){},unregister(){}};var y=new Map;Module.pyproxy_alloc_map=y;var B,X;Module.enable_pyproxy_allocation_tracing=function(){B=o(function(d){y.set(d,Error().stack)},"trace_pyproxy_alloc"),X=o(function(d){y.delete(d)},"trace_pyproxy_dealloc")},Module.disable_pyproxy_allocation_tracing=function(){B=o(function(d){},"trace_pyproxy_alloc"),X=o(function(d){},"trace_pyproxy_dealloc")},Module.disable_pyproxy_allocation_tracing();var _t=Symbol("pyproxy.attrs");function yt(d){_check_gil();let u=Module.validSuspender.value;Module.validSuspender.value=!1;try{return _pyproxy_getflags(d)}finally{Module.validSuspender.value=u}}o(yt,"pyproxy_getflags");function Et(d,{flags:u,cache:T,props:D,shared:S,gcRegister:F}={}){F===void 0&&(F=!0);let x=u!==void 0?u:yt(d);x===-1&&_pythonexc2js();let K=x&8192,j=Module.getPyProxyClass(x),pt;x&256?(pt=o(function(){},"target"),Object.setPrototypeOf(pt,j.prototype),delete pt.length,delete pt.name,pt.prototype=void 0):pt=Object.create(j.prototype);let mt=!!S;S||(T||(T={map:new Map,refcnt:0}),T.refcnt++,S={ptr:d,cache:T,flags:x,promise:void 0,destroyed_msg:void 0,gcRegistered:!1},_Py_IncRef(d)),D=Object.assign({isBound:!1,captureThis:!1,boundArgs:[],roundtrip:!1},D);let ft=new Proxy(pt,K?q:b);!mt&&F&&Wt(S),mt||B(ft);let St={shared:S,props:D};return pt[_t]=St,ft}o(Et,"pyproxy_new"),Module.pyproxy_new=Et;function Wt(d){let u=Object.assign({},d);d.gcRegistered=!0,Module.finalizationRegistry.register(d,u,d)}o(Wt,"gc_register_proxy"),Module.gc_register_proxy=Wt;function Ht(d){return d[_t]}o(Ht,"_getAttrsQuiet"),Module.PyProxy_getAttrsQuiet=Ht;function kt(d){let u=Ht(d);if(!u.shared.ptr)throw new Error(u.shared.destroyed_msg);return u}o(kt,"_getAttrs"),Module.PyProxy_getAttrs=kt;function It(d){return kt(d).shared.ptr}o(It,"_getPtr");function Nt(d){return Object.getPrototypeOf(d).$$flags}o(Nt,"_getFlags");function ie(d,u,T){let{captureThis:D,boundArgs:S,boundThis:F,isBound:x}=kt(d).props;return D?x?[F].concat(S,T):[u].concat(T):x?S.concat(T):T}o(ie,"_adjustArgs");var Ne=new Map;Module.getPyProxyClass=function(d){let u=[[1,je],[2,We],[4,Oe],[8,Je],[16,nn],[32,on],[2048,dn],[512,an],[1024,se],[4096,He],[64,Q],[128,L],[256,V],[8192,ve],[16384,De]],T=Ne.get(d);if(T)return T;let D={};for(let[K,j]of u)d&K&&Object.assign(D,Object.getOwnPropertyDescriptors(j.prototype));D.constructor=Object.getOwnPropertyDescriptor(Tt.prototype,"constructor"),Object.assign(D,Object.getOwnPropertyDescriptors({$$flags:d}));let S=d&256?Le:Ae,F=Object.create(S,D);function x(){}return o(x,"NewPyProxyClass"),x.prototype=F,Ne.set(d,x),x},Module.PyProxy_getPtr=It;var ee="This borrowed attribute proxy was automatically destroyed in the process of destroying the proxy it was borrowed from. Try using the 'copy' method.";function Ie(d){if(d&&(d.refcnt--,d.refcnt===0))for(let u of d.map.values())d.leaked||Module.pyproxy_destroy(u,ee,!0)}o(Ie,"pyproxy_decref_cache");function Ce(d,u){if(u=u||"Object has already been destroyed",API.debug_ffi){let T=d.type,D;try{D=d.toString()}catch(S){if(S.pyodide_fatal_error)throw S}u+=`
The object was of type "${T}" and `,D?u+=`had repr "${D}"`:u+="an error was raised when trying to generate its repr"}else u+="\nFor more information about the cause of this error, use `pyodide.setDebug(true)`";return u}o(Ce,"generateDestroyedMessage"),Module.pyproxy_destroy=function(d,u,T){let{shared:D,props:S}=Ht(d);if(!D.ptr||!T&&S.roundtrip)return;D.destroyed_msg=Ce(d,u);let F=D.ptr;D.ptr=0,D.gcRegistered&&Module.finalizationRegistry.unregister(D),Ie(D.cache);try{_check_gil();let x=Module.validSuspender.value;Module.validSuspender.value=!1,_Py_DecRef(F),X(d),Module.validSuspender.value=x}catch(x){API.fatal_error(x)}},Module.callPyObjectKwargs=function(d,u,T){let D=u.length,S=Object.keys(T),F=Object.values(T),x=S.length;u.push(...F);let K;try{_check_gil();let j=Module.validSuspender.value;Module.validSuspender.value=!1,K=__pyproxy_apply(d,u,D,S,x),Module.validSuspender.value=j}catch(j){API.maybe_fatal_error(j);return}if(K===null&&_pythonexc2js(),K&&K.type==="coroutine"&&K._ensure_future){_check_gil();let j=Module.validSuspender.value;Module.validSuspender.value=!1;let pt=__iscoroutinefunction(d);Module.validSuspender.value=j,pt&&K._ensure_future()}return K};async function Te(d,u,T){if(!Module.jspiSupported)throw new Error("WebAssembly stack switching not supported in this JavaScript runtime");let D=u.length,S=Object.keys(T),F=Object.values(T),x=S.length;u.push(...F);let K;try{_check_gil();let j=Module.validSuspender.value;Module.validSuspender.value=!1,K=await Module.promisingApply(d,u,D,S,x),Module.validSuspender.value=j}catch(j){API.fatal_error(j)}if(K===null&&_pythonexc2js(),K&&K.type==="coroutine"&&K._ensure_future){_check_gil();let j=Module.validSuspender.value;Module.validSuspender.value=!1;let pt=__iscoroutinefunction(d);Module.validSuspender.value=j,pt&&K._ensure_future()}return K}o(Te,"callPyObjectKwargsSuspending"),Module.callPyObject=function(d,u){return Module.callPyObjectKwargs(d,u,{})};var Tt=class{static[Symbol.hasInstance](d){return[Tt,$t].some(u=>Function.prototype[Symbol.hasInstance].call(u,d))}constructor(){throw new TypeError("PyProxy is not a constructor")}get[Symbol.toStringTag](){return"PyProxy"}get type(){let d=It(this);return __pyproxy_type(d)}toString(){let d=It(this),u;try{_check_gil();let T=Module.validSuspender.value;Module.validSuspender.value=!1,u=__pyproxy_repr(d),Module.validSuspender.value=T}catch(T){API.fatal_error(T)}return u===null&&_pythonexc2js(),u}destroy(d={}){d=Object.assign({message:"",destroyRoundtrip:!0},d);let{message:u,destroyRoundtrip:T}=d;Module.pyproxy_destroy(this,u,T)}copy(){let d=kt(this);return Et(d.shared.ptr,{flags:Nt(this),cache:d.shared.cache,props:d.props})}toJs({depth:d=-1,pyproxies:u=void 0,create_pyproxies:T=!0,dict_converter:D=void 0,default_converter:S=void 0}={}){let F=It(this),x,K;T?u?K=u:K=[]:K=null;try{_check_gil();let j=Module.validSuspender.value;Module.validSuspender.value=!1,x=_python2js_custom(F,d,K,D||null,S||null),Module.validSuspender.value=j}catch(j){API.fatal_error(j)}return x===null&&_pythonexc2js(),x}};o(Tt,"PyProxy");var Ae=Tt.prototype;Tests.Function=Function;var Le=Object.create(Function.prototype,Object.getOwnPropertyDescriptors(Ae));function $t(){}o($t,"PyProxyFunction"),$t.prototype=Le,globalThis.PyProxyFunction=$t;var Qe=class extends Tt{static[Symbol.hasInstance](d){return API.isPyProxy(d)&&!!(Nt(d)&1)}};o(Qe,"PyProxyWithLength");var je=class{get length(){let d=It(this),u;try{_check_gil();let T=Module.validSuspender.value;Module.validSuspender.value=!1,u=_PyObject_Size(d),Module.validSuspender.value=T}catch(T){API.fatal_error(T)}return u===-1&&_pythonexc2js(),u}};o(je,"PyLengthMethods");var $e=class extends Tt{static[Symbol.hasInstance](d){return API.isPyProxy(d)&&!!(Nt(d)&2)}};o($e,"PyProxyWithGet");var We=class{get(d){let u=It(this),T;try{_check_gil();let D=Module.validSuspender.value;Module.validSuspender.value=!1,T=__pyproxy_getitem(u,d),Module.validSuspender.value=D}catch(D){API.fatal_error(D)}if(T===null)if(_PyErr_Occurred())_pythonexc2js();else return;return T}};o(We,"PyGetItemMethods");var qe=class extends Tt{static[Symbol.hasInstance](d){return API.isPyProxy(d)&&!!(Nt(d)&4)}};o(qe,"PyProxyWithSet");var Oe=class{set(d,u){let T=It(this),D;try{_check_gil();let S=Module.validSuspender.value;Module.validSuspender.value=!1,D=__pyproxy_setitem(T,d,u),Module.validSuspender.value=S}catch(S){API.fatal_error(S)}D===-1&&_pythonexc2js()}delete(d){let u=It(this),T;try{_check_gil();let D=Module.validSuspender.value;Module.validSuspender.value=!1,T=__pyproxy_delitem(u,d),Module.validSuspender.value=D}catch(D){API.fatal_error(D)}T===-1&&_pythonexc2js()}};o(Oe,"PySetItemMethods");var Ze=class extends Tt{static[Symbol.hasInstance](d){return API.isPyProxy(d)&&!!(Nt(d)&8)}};o(Ze,"PyProxyWithHas");var Je=class{has(d){let u=It(this),T;try{_check_gil();let D=Module.validSuspender.value;Module.validSuspender.value=!1,T=__pyproxy_contains(u,d),Module.validSuspender.value=D}catch(D){API.fatal_error(D)}return T===-1&&_pythonexc2js(),T===1}};o(Je,"PyContainsMethods");function*tn(d,u){try{for(;;){_check_gil();let T=Module.validSuspender.value;Module.validSuspender.value=!1;let D=__pyproxy_iter_next(d);if(D===null)break;Module.validSuspender.value=T,yield D}}catch(T){API.fatal_error(T)}finally{Module.finalizationRegistry.unregister(u),_Py_DecRef(d)}_PyErr_Occurred()&&_pythonexc2js()}o(tn,"iter_helper");var en=class extends Tt{static[Symbol.hasInstance](d){return API.isPyProxy(d)&&!!(Nt(d)&48)}};o(en,"PyIterable");var nn=class{[Symbol.iterator](){let d=It(this),u={},T;try{_check_gil();let S=Module.validSuspender.value;Module.validSuspender.value=!1,T=_PyObject_GetIter(d),Module.validSuspender.value=S}catch(S){API.fatal_error(S)}T===0&&_pythonexc2js();let D=tn(T,u);return Module.finalizationRegistry.register(D,[T,void 0],u),D}};o(nn,"PyIterableMethods");async function*_n(d,u){try{for(;;){let T;try{_check_gil();let D=Module.validSuspender.value;if(Module.validSuspender.value=!1,T=__pyproxy_aiter_next(d),Module.validSuspender.value=D,T===null)break}catch(D){API.fatal_error(D)}try{yield await T}catch(D){if(D&&typeof D=="object"&&D.type==="StopAsyncIteration")return;throw D}finally{T.destroy()}}}finally{Module.finalizationRegistry.unregister(u),_Py_DecRef(d)}_PyErr_Occurred()&&_pythonexc2js()}o(_n,"aiter_helper");var rn=class extends Tt{static[Symbol.hasInstance](d){return API.isPyProxy(d)&&!!(Nt(d)&1536)}};o(rn,"PyAsyncIterable");var an=class{[Symbol.asyncIterator](){let d=It(this),u={},T;try{_check_gil();let S=Module.validSuspender.value;Module.validSuspender.value=!1,T=_PyObject_GetAIter(d),Module.validSuspender.value=S}catch(S){API.fatal_error(S)}T===0&&_pythonexc2js();let D=_n(T,u);return Module.finalizationRegistry.register(D,[T,void 0],u),D}};o(an,"PyAsyncIterableMethods");var sn=class extends Tt{static[Symbol.hasInstance](d){return API.isPyProxy(d)&&!!(Nt(d)&32)}};o(sn,"PyIterator");var on=class{[Symbol.iterator](){return this}next(d=void 0){let u,T;try{_check_gil();let D=Module.validSuspender.value;Module.validSuspender.value=!1,u=__pyproxyGen_Send(It(this),d),Module.validSuspender.value=D}catch(D){API.fatal_error(D)}return u===null&&_pythonexc2js(),u}};o(on,"PyIteratorMethods");var ln=class extends Tt{static[Symbol.hasInstance](d){return API.isPyProxy(d)&&!!(Nt(d)&2048)}};o(ln,"PyGenerator");var dn=class{throw(d){let u;try{_check_gil();let T=Module.validSuspender.value;Module.validSuspender.value=!1,u=__pyproxyGen_throw(It(this),d),Module.validSuspender.value=T}catch(T){API.fatal_error(T)}return u===null&&_pythonexc2js(),u}return(d){let u;try{_check_gil();let T=Module.validSuspender.value;Module.validSuspender.value=!1,u=__pyproxyGen_return(It(this),d),Module.validSuspender.value=T}catch(T){API.fatal_error(T)}return u===null&&_pythonexc2js(),u}};o(dn,"PyGeneratorMethods");var Zt=class extends Tt{static[Symbol.hasInstance](d){return API.isPyProxy(d)&&!!(Nt(d)&1024)}};o(Zt,"PyAsyncIterator");var se=class{[Symbol.asyncIterator](){return this}async next(d=void 0){let u;try{_check_gil();let D=Module.validSuspender.value;Module.validSuspender.value=!1,u=__pyproxyGen_asend(It(this),d),Module.validSuspender.value=D}catch(D){API.fatal_error(D)}u===null&&_pythonexc2js();let T;try{T=await u}catch(D){if(D&&typeof D=="object"&&D.type==="StopAsyncIteration")return{done:!0,value:T};throw D}finally{u.destroy()}return{done:!1,value:T}}};o(se,"PyAsyncIteratorMethods");var oe=class extends Tt{static[Symbol.hasInstance](d){return API.isPyProxy(d)&&!!(Nt(d)&4096)}};o(oe,"PyAsyncGenerator");var He=class{async throw(d){let u;try{_check_gil();let D=Module.validSuspender.value;Module.validSuspender.value=!1,u=__pyproxyGen_athrow(It(this),d),Module.validSuspender.value=D}catch(D){API.fatal_error(D)}u===null&&_pythonexc2js();let T;try{T=await u}catch(D){if(D&&typeof D=="object"){if(D.type==="StopAsyncIteration")return{done:!0,value:T};if(D.type==="GeneratorExit")return{done:!0,value:T}}throw D}finally{u.destroy()}return{done:!1,value:T}}async return(d){let u;try{_check_gil();let D=Module.validSuspender.value;Module.validSuspender.value=!1,u=__pyproxyGen_areturn(It(this)),Module.validSuspender.value=D}catch(D){API.fatal_error(D)}u===null&&_pythonexc2js();let T;try{T=await u}catch(D){if(D&&typeof D=="object"){if(D.type==="StopAsyncIteration")return{done:!0,value:T};if(D.type==="GeneratorExit")return{done:!0,value:d}}throw D}finally{u.destroy()}return{done:!1,value:T}}};o(He,"PyAsyncGeneratorMethods");var qt=class extends Tt{static[Symbol.hasInstance](d){return API.isPyProxy(d)&&!!(Nt(d)&8192)}};o(qt,"PySequence");function Ee(d,u){let T=d.toString(),D=u.toString();return T===D?0:T<D?-1:1}o(Ee,"defaultCompareFunc");var ve=class{get[Symbol.isConcatSpreadable](){return!0}join(d){return Array.prototype.join.call(this,d)}slice(d,u){return Array.prototype.slice.call(this,d,u)}lastIndexOf(d,u){return u===void 0&&(u=this.length),Array.prototype.lastIndexOf.call(this,d,u)}indexOf(d,u){return Array.prototype.indexOf.call(this,d,u)}forEach(d,u){Array.prototype.forEach.call(this,d,u)}map(d,u){return Array.prototype.map.call(this,d,u)}filter(d,u){return Array.prototype.filter.call(this,d,u)}some(d,u){return Array.prototype.some.call(this,d,u)}every(d,u){return Array.prototype.every.call(this,d,u)}reduce(...d){return Array.prototype.reduce.apply(this,d)}reduceRight(...d){return Array.prototype.reduceRight.apply(this,d)}at(d){return Array.prototype.at.call(this,d)}concat(...d){return Array.prototype.concat.apply(this,d)}includes(d){return this.has(d)}entries(){return Array.prototype.entries.call(this)}keys(){return Array.prototype.keys.call(this)}values(){return Array.prototype.values.call(this)}find(d,u){return Array.prototype.find.call(this,d,u)}findIndex(d,u){return Array.prototype.findIndex.call(this,d,u)}};o(ve,"PySequenceMethods");var pn=class extends Tt{static[Symbol.hasInstance](d){return API.isPyProxy(d)&&!!(Nt(d)&8192)}};o(pn,"PyMutableSequence");var De=class{reverse(){return this.$reverse(),this}sort(d){let u=API.public_api.pyimport("functools"),T=u.cmp_to_key,D;d?D=d:D=Ee;function S(x,K){return x===void 0&&K===void 0?0:x===void 0?1:K===void 0?-1:D(x,K)}o(S,"wrapper");let F;try{F=T(S),this.$sort.callKwargs({key:F})}finally{F?.destroy(),T.destroy(),u.destroy()}return this}splice(d,u,...T){return u===void 0&&(u=1<<30),un(this,d,d+u,T)}push(...d){for(let u of d)this.append(u);return this.length}pop(){return Me(this,!1)}shift(){return Me(this,!0)}unshift(...d){return d.forEach((u,T)=>{this.insert(T,u)}),this.length}copyWithin(...d){return Array.prototype.copyWithin.apply(this,d),this}fill(...d){return Array.prototype.fill.apply(this,d),this}};o(De,"PyMutableSequenceMethods");function ke(d,u){let T=It(d),D;try{_check_gil();let S=Module.validSuspender.value;Module.validSuspender.value=!1,D=__pyproxy_hasattr(T,u),Module.validSuspender.value=S}catch(S){API.fatal_error(S)}return D===-1&&_pythonexc2js(),D!==0}o(ke,"python_hasattr");function Mt(d,u){let{shared:T}=kt(d),D=T.cache.map,S;try{_check_gil();let F=Module.validSuspender.value;Module.validSuspender.value=!1,S=__pyproxy_getattr(T.ptr,u,D),Module.validSuspender.value=F}catch(F){API.fatal_error(F)}if(S===null){_PyErr_Occurred()&&_pythonexc2js();return}return S}o(Mt,"python_getattr");function Ue(d,u,T){let D=It(d),S;try{_check_gil();let F=Module.validSuspender.value;Module.validSuspender.value=!1,S=__pyproxy_setattr(D,u,T),Module.validSuspender.value=F}catch(F){API.fatal_error(F)}S===-1&&_pythonexc2js()}o(Ue,"python_setattr");function fe(d,u){let T=It(d),D;try{_check_gil();let S=Module.validSuspender.value;Module.validSuspender.value=!1,D=__pyproxy_delattr(T,u),Module.validSuspender.value=S}catch(S){API.fatal_error(S)}D===-1&&_pythonexc2js()}o(fe,"python_delattr");function un(d,u,T,D){let S=It(d),F;try{_check_gil();let x=Module.validSuspender.value;Module.validSuspender.value=!1,F=__pyproxy_slice_assign(S,u,T,D),Module.validSuspender.value=x}catch(x){API.fatal_error(x)}return F===null&&_pythonexc2js(),F}o(un,"python_slice_assign");function Me(d,u){let T=It(d),D;try{_check_gil();let S=Module.validSuspender.value;Module.validSuspender.value=!1,D=__pyproxy_pop(T,u),Module.validSuspender.value=S}catch(S){API.fatal_error(S)}return D===null&&_pythonexc2js(),D}o(Me,"python_pop");function H(d,u,T){return d instanceof Function?u in d&&!["name","length","caller","arguments",T?"prototype":void 0].includes(u):u in d}o(H,"filteredHasKey");var b={isExtensible(){return!0},has(d,u){return H(d,u,!1)?!0:typeof u=="symbol"?!1:(u.startsWith("$")&&(u=u.slice(1)),ke(d,u))},get(d,u){return typeof u=="symbol"||H(d,u,!0)?Reflect.get(d,u):(u.startsWith("$")&&(u=u.slice(1)),Mt(d,u))},set(d,u,T){let D=Object.getOwnPropertyDescriptor(d,u);return D&&!D.writable&&!D.set?!1:typeof u=="symbol"||H(d,u,!0)?Reflect.set(d,u,T):(u.startsWith("$")&&(u=u.slice(1)),Ue(d,u,T),!0)},deleteProperty(d,u){let T=Object.getOwnPropertyDescriptor(d,u);return T&&!T.configurable?!1:typeof u=="symbol"||H(d,u,!0)?Reflect.deleteProperty(d,u):(u.startsWith("$")&&(u=u.slice(1)),fe(d,u),!0)},ownKeys(d){let u=It(d),T;try{_check_gil();let D=Module.validSuspender.value;Module.validSuspender.value=!1,T=__pyproxy_ownKeys(u),Module.validSuspender.value=D}catch(D){API.fatal_error(D)}return T===null&&_pythonexc2js(),T.push(...Reflect.ownKeys(d)),T},apply(d,u,T){return d.apply(u,T)}};function Y(d){return d&&typeof d=="object"&&d.constructor&&d.constructor.name==="PythonError"}o(Y,"isPythonError");var q={isExtensible(){return!0},has(d,u){return typeof u=="string"&&/^[0-9]*$/.test(u)?Number(u)<d.length:b.has(d,u)},get(d,u){if(u==="length")return d.length;if(typeof u=="string"&&/^[0-9]*$/.test(u))try{return We.prototype.get.call(d,Number(u))}catch(T){if(Y(T))return;throw T}return b.get(d,u)},set(d,u,T){if(typeof u=="string"&&/^[0-9]*$/.test(u))try{return Oe.prototype.set.call(d,Number(u),T),!0}catch(D){if(Y(D))return!1;throw D}return b.set(d,u,T)},deleteProperty(d,u){if(typeof u=="string"&&/^[0-9]*$/.test(u))try{return Oe.prototype.delete.call(d,Number(u)),!0}catch(T){if(Y(T))return!1;throw T}return b.deleteProperty(d,u)},ownKeys(d){let u=b.ownKeys(d);return u.push(...Array.from({length:d.length},(T,D)=>D.toString())),u.push("length"),u}},U=class extends Tt{static[Symbol.hasInstance](d){return API.isPyProxy(d)&&!!(Nt(d)&64)}};o(U,"PyAwaitable");var Q=class{_ensure_future(){let{shared:d}=Ht(this);if(d.promise)return d.promise;let u=d.ptr;u||kt(this);let T,D,S=new Promise((x,K)=>{T=x,D=K}),F;try{_check_gil();let x=Module.validSuspender.value;Module.validSuspender.value=!1,F=__pyproxy_ensure_future(u,T,D),Module.validSuspender.value=x}catch(x){API.fatal_error(x)}return F===-1&&_pythonexc2js(),d.promise=S,this.destroy(),S}then(d,u){return this._ensure_future().then(d,u)}catch(d){return this._ensure_future().catch(d)}finally(d){return this._ensure_future().finally(d)}};o(Q,"PyAwaitableMethods");var $=class extends Tt{static[Symbol.hasInstance](d){return API.isPyProxy(d)&&!!(Nt(d)&256)}};o($,"PyCallable");var V=class{apply(d,u){return u=function(...T){return T}.apply(void 0,u),u=ie(this,d,u),Module.callPyObject(It(this),u)}call(d,...u){return u=ie(this,d,u),Module.callPyObject(It(this),u)}callKwargs(...d){if(d.length===0)throw new TypeError("callKwargs requires at least one argument (the key word argument object)");let u=d.pop();if(u.constructor!==void 0&&u.constructor.name!=="Object")throw new TypeError("kwargs argument is not an object");return Module.callPyObjectKwargs(It(this),d,u)}callSyncifying(...d){return Te(It(this),d,{})}callSyncifyingKwargs(...d){if(d.length===0)throw new TypeError("callKwargs requires at least one argument (the key word argument object)");let u=d.pop();if(u.constructor!==void 0&&u.constructor.name!=="Object")throw new TypeError("kwargs argument is not an object");return Te(It(this),d,u)}bind(d,...u){let{shared:T,props:D}=kt(this),{boundArgs:S,boundThis:F,isBound:x}=D,K=d;x&&(K=F);let j=S.concat(u);return D=Object.assign({},D,{boundArgs:j,isBound:!0,boundThis:K}),Et(T.ptr,{shared:T,flags:Nt(this),props:D})}captureThis(){let{props:d,shared:u}=kt(this);return d=Object.assign({},d,{captureThis:!0}),Et(u.ptr,{shared:u,flags:Nt(this),props:d})}};o(V,"PyCallableMethods"),V.prototype.prototype=Function.prototype;var N=new Map([["i8",Int8Array],["u8",Uint8Array],["u8clamped",Uint8ClampedArray],["i16",Int16Array],["u16",Uint16Array],["i32",Int32Array],["u32",Uint32Array],["i32",Int32Array],["u32",Uint32Array],["i64",globalThis.BigInt64Array],["u64",globalThis.BigUint64Array],["f32",Float32Array],["f64",Float64Array],["dataview",DataView]]),P=class extends Tt{static[Symbol.hasInstance](d){return API.isPyProxy(d)&&!!(Nt(d)&128)}};o(P,"PyBuffer");var L=class{getBuffer(d){let u;if(d&&(u=N.get(d),u===void 0))throw new Error(`Unknown type ${d}`);let T=It(this),D;try{_check_gil();let bt=Module.validSuspender.value;Module.validSuspender.value=!1,D=__pyproxy_get_buffer(T),Module.validSuspender.value=bt}catch(bt){API.fatal_error(bt)}D===null&&_pythonexc2js();let{start_ptr:S,smallest_ptr:F,largest_ptr:x,readonly:K,format:j,itemsize:pt,shape:mt,strides:ft,view:St,c_contiguous:xt,f_contiguous:ae}=D,Dt=!1;try{let bt=!1;u===void 0&&([u,bt]=Module.processBufferFormatString(j," In this case, you can pass an explicit type argument."));let Yt=parseInt(u.name.replace(/[^0-9]/g,""))/8||1;if(bt&&Yt>1)throw new Error("Javascript has no native support for big endian buffers. In this case, you can pass an explicit type argument. For instance, `getBuffer('dataview')` will return a `DataView`which has native support for reading big endian data. Alternatively, toJs will automatically convert the buffer to little endian.");let le=x-F;if(le!==0&&(S%Yt!==0||F%Yt!==0||x%Yt!==0))throw new Error(`Buffer does not have valid alignment for a ${u.name}`);let zn=le/Yt,Dn=(S-F)/Yt,Pe;le===0?Pe=new u:Pe=new u(HEAPU32.buffer,F,zn);for(let Kn of ft.keys())ft[Kn]/=Yt;return Dt=!0,Object.create(at.prototype,Object.getOwnPropertyDescriptors({offset:Dn,readonly:K,format:j,itemsize:pt,ndim:mt.length,nbytes:le,shape:mt,strides:ft,data:Pe,c_contiguous:xt,f_contiguous:ae,_view_ptr:St,_released:!1}))}finally{if(!Dt)try{_check_gil();let bt=Module.validSuspender.value;Module.validSuspender.value=!1,_PyBuffer_Release(St),_PyMem_Free(St),Module.validSuspender.value=bt}catch(bt){API.fatal_error(bt)}}}};o(L,"PyBufferMethods");var lt=class extends Tt{static[Symbol.hasInstance](d){return API.isPyProxy(d)&&d.type==="dict"}};o(lt,"PyDict");var at=class{constructor(){throw new TypeError("PyBufferView is not a constructor")}release(){if(!this._released){try{_check_gil();let d=Module.validSuspender.value;Module.validSuspender.value=!1,_PyBuffer_Release(this._view_ptr),_PyMem_Free(this._view_ptr),Module.validSuspender.value=d}catch(d){API.fatal_error(d)}this._released=!0,this.data=null}}};o(at,"PyBufferView");var C=I(m());function nt(d){if(typeof d=="string")d=new Error(d);else if(d&&typeof d=="object"&&d.name==="ExitStatus"){let u=d.status;d=new we(d.message),d.status=u}else if(typeof d!="object"||d===null||typeof d.stack!="string"||typeof d.message!="string"){let u=API.getTypeTag(d),T=`A value of type ${typeof d} with tag ${u} was thrown as an error!`;try{T+=`
String interpolation of the thrown value gives """${d}""".`}catch{T+=`
String interpolation of the thrown value fails.`}try{T+=`
The thrown value's toString method returns """${d.toString()}""".`}catch{T+=`
The thrown value's toString method fails.`}d=new Error(T)}return d}o(nt,"ensureCaughtObjectIsError");var Ot=class extends Error{constructor(d,u,T){u||(u=`The exception is an object of type ${d} at address ${T} which does not inherit from std::exception`),super(u),this.ty=d}};o(Ot,"CppException"),Object.defineProperty(Ot.prototype,"name",{get(){return`${this.constructor.name} ${this.ty}`}});var Bt=WebAssembly.Exception||function(){},ut=o(d=>d instanceof Bt,"isWasmException");function ne(d){if(ut(d))if(d.is(Module.jsWrapperTag))d=d.getArg(Module.jsWrapperTag,0);else return d;let[u,T]=Module.getExceptionMessage(d);return new Ot(u,T,d)}o(ne,"convertCppException"),Tests.convertCppException=ne;var Ft=!1;API.fatal_error=function(d){if(d&&d.pyodide_fatal_error)return;if(Ft){console.error("Recursive call to fatal_error. Inner error was:"),console.error(d);return}if(d instanceof xe)throw d;typeof d=="number"||ut(d)?d=ne(d):d=nt(d),d.pyodide_fatal_error=!0,Ft=!0;let u=d instanceof we;u||(console.error("Pyodide has suffered a fatal error. Please report this to the Pyodide maintainers."),console.error("The cause of the fatal error was:"),API.inTestHoist?(console.error(d.toString()),console.error(d.stack)):console.error(d));try{u||_dump_traceback();let T=`Pyodide already ${u?"exited":"fatally failed"} and can no longer be used.`;for(let D of Reflect.ownKeys(API.public_api))typeof D=="string"&&D.startsWith("_")||D==="version"||Object.defineProperty(API.public_api,D,{enumerable:!0,configurable:!0,get:()=>{throw new Error(T)}});API.on_fatal&&API.on_fatal(d)}catch(T){console.error("Another error occurred while handling the fatal error:"),console.error(T)}throw d},API.maybe_fatal_error=function(d){API._skip_unwind_fatal_error&&d==="unwind"||API.fatal_error(d)};var ct=[];API.capture_stderr=function(){ct=[],FS.createDevice("/dev","capture_stderr",null,d=>ct.push(d)),FS.closeStream(2),FS.open("/dev/capture_stderr",1)},API.restore_stderr=function(){return FS.closeStream(2),FS.unlink("/dev/capture_stderr"),FS.open("/dev/stderr",1),new TextDecoder().decode(new Uint8Array(ct))},API.fatal_loading_error=function(...d){let u=d.join(" ");if(_PyErr_Occurred()){API.capture_stderr(),_PyErr_Print();let T=API.restore_stderr();u+=`
`+T}throw new Re(u)};function pe(d){if(!d)return!1;let u=d.fileName||"";if(u.includes("wasm-function"))return!0;if(!u.includes("pyodide.asm.js"))return!1;let T=d.functionName||"";return T.startsWith("Object.")&&(T=T.slice(7)),API.public_api&&T in API.public_api&&T!=="PythonError"?(d.functionName=T,!1):!0}o(pe,"isPyodideFrame");function ue(d){return pe(d)&&d.functionName==="new_error"}o(ue,"isErrorStart"),Module.handle_js_error=function(d){if(d&&d.pyodide_fatal_error)throw d;if(d instanceof Module._PropagatePythonError)return;let u=!1;d instanceof Ut&&(u=_restore_sys_last_exception(d.__error_address));let T,D;try{T=C.default.parse(d)}catch{D=!0}if(D&&(d=nt(d)),!u){let S=_JsProxy_create(d);_set_error(S),_Py_DecRef(S)}if(!D){if(ue(T[0])||ue(T[1]))for(;pe(T[0]);)T.shift();for(let S of T){if(pe(S))break;let F=stringToNewUTF8(S.functionName||"???"),x=stringToNewUTF8(S.fileName||"???.js");__PyTraceback_Add(F,x,S.lineNumber),_free(F),_free(x)}}};var Ut=class extends Error{constructor(d,u,T){let D=Error.stackTraceLimit;Error.stackTraceLimit=1/0,super(u),Error.stackTraceLimit=D,this.type=d,this.__error_address=T}};o(Ut,"PythonError"),API.PythonError=Ut;var st=class extends Error{constructor(){super("If you are seeing this message, an internal Pyodide error has occurred. Please report it to the Pyodide maintainers.")}};o(st,"_PropagatePythonError");function _e(d){Object.defineProperty(d.prototype,"name",{value:d.name})}o(_e,"setName");var Re=class extends Error{};o(Re,"FatalPyodideError");var we=class extends Error{};o(we,"Exit");var xe=class extends Error{};o(xe,"NoGilError"),[st,Re,we,Ut,xe].forEach(_e),API.NoGilError=xe,Module._PropagatePythonError=st,API.errorConstructors=new Map([EvalError,RangeError,ReferenceError,SyntaxError,TypeError,URIError,globalThis.DOMException,globalThis.AssertionError,globalThis.SystemError].filter(d=>d).map(d=>[d.constructor.name,d])),API.deserializeError=function(d,u,T){let D=API.errorConstructors.get(d)||Error,S=new D(u);return API.errorConstructors.has(d)||(S.name=d),S.message=u,S.stack=T,S};var cn={PyProxy:Tt,PyProxyWithLength:Qe,PyProxyWithGet:$e,PyProxyWithSet:qe,PyProxyWithHas:Ze,PyDict:lt,PyIterable:en,PyAsyncIterable:rn,PyIterator:sn,PyAsyncIterator:Zt,PyGenerator:ln,PyAsyncGenerator:oe,PyAwaitable:U,PyCallable:$,PyBuffer:P,PyBufferView:at,PythonError:Ut,PySequence:qt,PyMutableSequence:pn},re=o(d=>{d.id!=="canvas"&&console.warn("If you are using canvas element for SDL library, it should have id 'canvas' to work properly."),Module.canvas=d},"setCanvas2D"),dt=o(()=>Module.canvas,"getCanvas2D"),ge=o(d=>{re(d)},"setCanvas3D"),y_=o(()=>dt(),"getCanvas3D"),S_={setCanvas2D:re,getCanvas2D:dt,setCanvas3D:ge,getCanvas3D:y_};function Ln(){let d=Promise.resolve();async function u(){let T=d,D;return d=new Promise(S=>D=S),await T,D}return o(u,"acquireLock"),u}o(Ln,"createLock");var h_=o(d=>{let u={};return(...T)=>{let D=T[0];if(D in u)return u[D];{let S=d(D);return u[D]=S,S}}},"memoize");function o0(d,u,T){let D=d.substring(0,d.lastIndexOf("/")),S=u||[];S=S.concat(API.defaultLdLibraryPath,[D]);let F=o(K=>{for(let j of S){let pt=Module.PATH.join2(j,K);if(Module.FS.findObject(pt)!==null)return pt}return K},"resolvePath"),x=o(K=>Module.FS.readFile(F(K)),"readFile");return T!==void 0&&(x=o(K=>T(F(K)),"readFile")),{findObject:(K,j)=>Module.FS.findObject(F(K),j),readFile:x}}o(o0,"createDynlibFS");var b_=Ln();async function On(d,u,T,D){let S=await b_(),F=o0(d,T,D);try{if(await Module.loadDynamicLibrary(d,{loadAsync:!0,nodelete:!0,allowUndefined:!0,global:u,fs:F}),u&&Module.PATH.isAbs(d)){let x=Module.PATH.basename(d);Module.LDSO.loadedLibsByName[x]||(Module.LDSO.loadedLibsByName[x]=Module.LDSO.loadedLibsByName[d])}}catch(x){if(x&&x.message&&x.message.includes("need to see wasm magic number")){console.warn(`Failed to load dynlib ${d}. We probably just tried to load a linux .so file or something.`);return}throw x}finally{S()}}o(On,"loadDynlib");async function vn(d,u){let T=`${API.sitepackages}/${d.file_name.split("-")[0]}.libs`,D=h_(Module.FS.readFile),S=!!d.shared_library,F;if(S)F=u.map(x=>({path:x,global:!0}));else{let x=l0(u,D);F=u.map(K=>{let j=x.has(Module.PATH.basename(K));return{path:K,global:j||!!d.shared_library}})}F.sort((x,K)=>Number(K.global)-Number(x.global));for(let{path:x,global:K}of F)await On(x,K,[T],D)}o(vn,"loadDynlibsFromPackage");function l0(d,u){let T=Module.FS.readFile;u!==void 0&&(T=u);let D=new Set;return d.forEach(S=>{let F=T(S);Module.getDylinkMetadata(F).neededDynlibs.forEach(x=>{D.add(x)})}),D}o(l0,"calculateGlobalLibs"),API.loadDynlib=On,API.loadDynlibsFromPackage=vn;var N_=/[-_.]+/g;function d0(d){return d.replace(N_,"-").toLowerCase()}o(d0,"canonicalizePackageName");var C_=/^.*?([^\/]*)\.whl$/;function p0(d){let u=C_.exec(d);if(u){let T=u[1].toLowerCase().split("-");return{name:T[0],version:T[1],fileName:T.join("-")+".whl"}}}o(p0,"uriToPackageData");async function u0(d){await et();let u=await d;if(!u.packages)throw new Error("Loaded pyodide lock file does not contain the expected key 'packages'.");API.lockfile_info=u.info,API.lockfile_packages=u.packages,API.lockfile_unvendored_stdlibs_and_test=[],API.repodata_info=u.info,API.repodata_packages=u.packages,API._import_name_to_package_name=new Map;for(let T of Object.keys(API.lockfile_packages)){let D=API.lockfile_packages[T];for(let S of D.imports)API._import_name_to_package_name.set(S,T);D.package_type==="cpython_module"&&API.lockfile_unvendored_stdlibs_and_test.push(T)}API.lockfile_unvendored_stdlibs=API.lockfile_unvendored_stdlibs_and_test.filter(T=>T!=="test"),await In(API.config.packages,{messageCallback(){}})}o(u0,"initializePackageIndex"),API.lockFilePromise&&(API.packageIndexReady=u0(API.lockFilePromise));var mn;API.setCdnUrl=function(d){mn=d};var Ge="default channel";function Mn(){let d=o(()=>{},"_resolve"),u=o(()=>{},"_reject"),T=new Promise((D,S)=>{d=D,u=S});return T.resolve=d,T.reject=u,T}o(Mn,"createDonePromise");function wn(d,u){let T=d0(d);if(u.has(T))return;let D=API.lockfile_packages[T];if(!D)throw new Error(`No known package with name '${d}'`);if(u.set(T,{name:D.name,normalizedName:T,channel:Ge,depends:D.depends,installPromise:void 0,done:Mn(),packageData:D}),Be[D.name]===void 0)for(let S of D.depends)wn(S,u)}o(wn,"addPackageToLoad");function c0(d,u){let T=new Map;for(let D of d){let S=p0(D);if(S===void 0){wn(D,T);continue}let{name:F,version:x,fileName:K}=S,j=D;if(T.has(F)&&T.get(F).channel!==j){u(`Loading same package ${F} from ${j} and ${T.get(F).channel}`);continue}T.set(F,{name:F,normalizedName:F,channel:j,depends:[],installPromise:void 0,done:Mn(),packageData:{name:F,version:x,file_name:K,install_dir:"site",sha256:"",package_type:"package",imports:[],depends:[],shared_library:!1}})}return T}o(c0,"recursiveDependencies");async function m0(d,u=!0){let T;f?(T=API.config.packageCacheDir,await tt.mkdir(API.config.packageCacheDir,{recursive:!0})):T=API.config.indexURL;let D,S,F;if(d.channel===Ge){if(!(d.normalizedName in API.lockfile_packages))throw new Error(`Internal error: no entry for package named ${name}`);let K=API.lockfile_packages[d.normalizedName];D=K.file_name,S=J(D,T),F="sha256-"+gt(K.sha256)}else S=d.channel,F=void 0;u||(F=void 0);try{return await Pt(S,F)}catch(K){if(!f||d.channel!==Ge)throw K}console.log(`Didn't find package ${D} locally, attempting to load from ${mn}`);let x=await Pt(mn+D);return console.log(`Package ${D} loaded from ${mn}, caching the wheel in node_modules for future use.`),await tt.writeFile(S,x),x}o(m0,"downloadPackage");async function I0(d,u,T){let D=API.lockfile_packages[d];D||(D={name:"",version:"",file_name:".whl",install_dir:"site",sha256:"",package_type:"package",imports:[],depends:[],shared_library:!1});let S=D.file_name,F=API.package_loader.unpack_buffer.callKwargs({buffer:u,filename:S,target:D.install_dir,calculate_dynlibs:!0,installer:"pyodide.loadPackage",source:T===Ge?"pyodide":T});await vn(D,F)}o(I0,"installPackage");async function T0(d,u,T,D,S=!0){if(Be[d.name]===void 0)try{let F=await m0(d,S),x=d.depends.map(K=>u.has(K)?u.get(K).done:Promise.resolve());await API.bootstrapFinalizedPromise,await Promise.all(x),await I0(d.normalizedName,F,d.channel),T.add(d.packageData),Be[d.name]=d.channel}catch(F){D.set(d.name,F)}finally{d.done.resolve()}}o(T0,"downloadAndInstall");var L_=Ln();function A0({name:d,version:u,file_name:T,package_type:D}){return{name:d,version:u,fileName:T,packageType:D}}o(A0,"filterPackageData");async function In(d,u={checkIntegrity:!0}){let T=new Set,D=u.messageCallback||console.log,S=u.errorCallback||console.error;d instanceof Tt&&(d=d.toJs()),Array.isArray(d)||(d=[d]);let F=c0(d,S);for(let[pt,{name:mt,normalizedName:ft,channel:St}]of F){let xt=Be[mt];xt!==void 0&&(F.delete(ft),xt===St||St===Ge?D(`${mt} already loaded from ${xt}`):S(`URI mismatch, attempting to load package ${mt} from ${St} while it is already loaded from ${xt}. To override a dependency, load the custom package first.`))}if(F.size===0)return D("No new packages to load"),[];let x=Array.from(F.values(),({name:pt})=>pt).join(", "),K=new Map,j=await L_();try{D(`Loading ${x}`);for(let[pt,mt]of F){if(Be[mt.name]){F.delete(mt.normalizedName);continue}mt.installPromise=T0(mt,F,T,K,u.checkIntegrity)}if(await Promise.all(Array.from(F.values()).map(({installPromise:pt})=>pt)),Module.reportUndefinedSymbols(),T.size>0){let pt=Array.from(T,mt=>mt.name).sort().join(", ");D(`Loaded ${pt}`)}if(K.size>0){let pt=Array.from(K.keys()).join(", ");D(`Failed to load ${pt}`);for(let[mt,ft]of K)S(`The following error occurred while loading ${mt}:`),S(ft.message)}return API.importlib.invalidate_caches(),Array.from(T,A0)}finally{j()}}o(In,"loadPackage");var Be={},O_="0.25.0",xn=f?l("fs"):void 0,E0=f?l("tty"):void 0;function Bn(d){try{xn.fsyncSync(d)}catch(u){if(u&&u.code==="EINVAL")return;throw u}}o(Bn,"nodeFsync");var D0=!1,Tn={},Jt={};function An(d){Tn[Jt.stdin]=d}o(An,"_setStdinOps");function f0(d){Tn[Jt.stdout]=d}o(f0,"_setStdoutOps");function R0(d){Tn[Jt.stderr]=d}o(R0,"_setStderrOps");function g0(d){return d&&typeof d=="object"&&"errno"in d}o(g0,"isErrnoError");var v_=new Int32Array(new WebAssembly.Memory({shared:!0,initial:1,maximum:1}).buffer);function P0(d){try{return Atomics.wait(v_,0,0,d),!0}catch{return!1}}o(P0,"syncSleep");function y0(d){for(;;)try{return d()}catch(u){if(u&&u.code==="EAGAIN"&&P0(100))continue;throw u}}o(y0,"handleEAGAIN");function Fn(d,u,T){let D;try{D=y0(u)}catch(S){throw S&&S.code&&Module.ERRNO_CODES[S.code]?new FS.ErrnoError(Module.ERRNO_CODES[S.code]):g0(S)?S:(console.error("Error thrown in read:"),console.error(S),new FS.ErrnoError(29))}if(D===void 0)throw console.warn(`${T} returned undefined; a correct implementation must return a number`),new FS.ErrnoError(29);return D!==0&&(d.node.timestamp=Date.now()),D}o(Fn,"readWriteHelper");var S0=o((d,u,T)=>API.typedArrayAsUint8Array(d).subarray(u,u+T),"prepareBuffer"),Wn={open:function(d){let u=Tn[d.node.rdev];if(!u)throw new FS.ErrnoError(43);d.devops=u,d.tty=d.devops.isatty,d.seekable=!1},close:function(d){d.stream_ops.fsync(d)},fsync:function(d){let u=d.devops;u.fsync&&u.fsync()},read:function(d,u,T,D,S){return u=S0(u,T,D),Fn(d,()=>d.devops.read(u),"read")},write:function(d,u,T,D,S){return u=S0(u,T,D),Fn(d,()=>d.devops.write(u),"write")}};function ze(){D0&&(FS.closeStream(0),FS.closeStream(1),FS.closeStream(2),FS.open("/dev/stdin",0),FS.open("/dev/stdout",1),FS.open("/dev/stderr",1))}o(ze,"refreshStreams"),API.initializeStreams=function(d,u,T){let D=FS.createDevice.major++;Jt.stdin=FS.makedev(D,0),Jt.stdout=FS.makedev(D,1),Jt.stderr=FS.makedev(D,2),FS.registerDevice(Jt.stdin,Wn),FS.registerDevice(Jt.stdout,Wn),FS.registerDevice(Jt.stderr,Wn),FS.unlink("/dev/stdin"),FS.unlink("/dev/stdout"),FS.unlink("/dev/stderr"),FS.mkdev("/dev/stdin",Jt.stdin),FS.mkdev("/dev/stdout",Jt.stdout),FS.mkdev("/dev/stderr",Jt.stderr),En({stdin:d}),kn({batched:u}),Un({batched:T}),D0=!0,ze()};function h0(){En(f?new v0(process.stdin.fd):{stdin:()=>prompt()})}o(h0,"setDefaultStdin");function b0(){An(new O0),ze()}o(b0,"setStdinError");function En(d={}){let{stdin:u,error:T,isatty:D,autoEOF:S,read:F}=d,x=+!!u+ +!!T+ +!!F;if(x>1)throw new TypeError("At most one of stdin, read, and error must be provided.");if(!u&&S!==void 0)throw new TypeError("The 'autoEOF' option can only be used with the 'stdin' option");if(x===0){h0();return}T&&b0(),u&&(S=S===void 0?!0:S,An(new M0(u.bind(d),!!D,S))),F&&An(d),ze()}o(En,"setStdin");function Hn(d,u,T){let{raw:D,isatty:S,batched:F,write:x}=d,K=+!!D+ +!!F+ +!!x;if(K===0&&(d=T(),{raw:D,isatty:S,batched:F,write:x}=d),K>1)throw new TypeError("At most one of 'raw', 'batched', and 'write' must be passed");if(!D&&!x&&S)throw new TypeError("Cannot set 'isatty' to true unless 'raw' or 'write' is provided");D&&u(new w0(D.bind(d),!!S)),F&&u(new x0(F.bind(d))),x&&u(d),ze()}o(Hn,"_setStdwrite");function N0(){return f?new Gn(process.stdout.fd):{batched:d=>console.log(d)}}o(N0,"_getStdoutDefaults");function C0(){return f?new Gn(process.stderr.fd):{batched:d=>console.warn(d)}}o(C0,"_getStderrDefaults");function kn(d={}){Hn(d,f0,N0)}o(kn,"setStdout");function Un(d={}){Hn(d,R0,C0)}o(Un,"setStderr");var M_=new TextEncoder,L0=new TextDecoder,O0=class{read(d){throw new FS.ErrnoError(29)}};o(O0,"ErrorReader");var v0=class{constructor(d){this.fd=d,this.isatty=E0.isatty(d)}read(d){try{return xn.readSync(this.fd,d)}catch(u){if(u.toString().includes("EOF"))return 0;throw u}}fsync(){Bn(this.fd)}};o(v0,"NodeReader");var M0=class{constructor(d,u,T){this.infunc=d,this.isatty=u,this.autoEOF=T,this.index=0,this.saved=void 0,this.insertEOF=!1}_getInput(){if(this.saved)return this.saved;let d=this.infunc();if(typeof d=="number")return d;if(d!=null){if(ArrayBuffer.isView(d)){if(d.BYTES_PER_ELEMENT!==1)throw console.warn(`Expected BYTES_PER_ELEMENT to be 1, infunc gave ${d.constructor}`),new FS.ErrnoError(29);return d}if(typeof d=="string")return d.endsWith(`
`)||(d+=`
`),d;if(Object.prototype.toString.call(d)==="[object ArrayBuffer]")return new Uint8Array(d);throw console.warn("Expected result to be undefined, null, string, array buffer, or array buffer view"),new FS.ErrnoError(29)}}read(d){if(this.insertEOF)return this.insertEOF=!1,0;let u=0;for(;;){let T=this._getInput();if(typeof T=="number"){d[0]=T,d=d.subarray(1),u++;continue}let D;if(T&&T.length>0)if(typeof T=="string"){let{read:S,written:F}=M_.encodeInto(T,d);this.saved=T.slice(S),u+=F,D=d[F-1],d=d.subarray(F)}else{let S;T.length>d.length?(d.set(T.subarray(0,d.length)),this.saved=T.subarray(d.length),S=d.length):(d.set(T),this.saved=void 0,S=T.length),u+=S,D=d[S-1],d=d.subarray(S)}if(!(T&&T.length>0)||this.autoEOF||d.length===0)return this.insertEOF=u>0&&this.autoEOF&&D!==10,u}}fsync(){}};o(M0,"LegacyReader");var w0=class{constructor(d,u){this.out=d,this.isatty=u}write(d){for(let u of d)this.out(u);return d.length}};o(w0,"CharacterCodeWriter");var x0=class{constructor(d){this.isatty=!1,this.out=d,this.output=[]}write(d){for(let u of d)u===10?(this.out(L0.decode(new Uint8Array(this.output))),this.output=[]):u!==0&&this.output.push(u);return d.length}fsync(){this.output&&this.output.length>0&&(this.out(L0.decode(new Uint8Array(this.output))),this.output=[])}};o(x0,"StringWriter");var Gn=class{constructor(d){this.fd=d,this.isatty=E0.isatty(d)}write(d){return xn.writeSync(this.fd,d)}fsync(){Bn(this.fd)}};o(Gn,"NodeWriter"),API.loadBinaryFile=Pt,API.rawRun=o(function(d){let u=Module.stringToNewUTF8(d);Module.API.capture_stderr();let T=_PyRun_SimpleString(u);_free(u);let D=Module.API.restore_stderr().trim();return[T,D]},"rawRun"),API.runPythonInternal=function(d){return API._pyodide._base.eval_code(d,API.runPythonInternal_dict)},API.setPyProxyToStringMethod=function(d){Module.HEAP8[Module._compat_to_string_repr]=+d},API.saveState=()=>API.pyodide_py._state.save_state(),API.restoreState=d=>API.pyodide_py._state.restore_state(d);var Kt=class{static async loadPackagesFromImports(d,u={checkIntegrity:!0}){let T=API.pyodide_code.find_imports(d),D;try{D=T.toJs()}finally{T.destroy()}if(D.length===0)return[];let S=API._import_name_to_package_name,F=new Set;for(let x of D)S.has(x)&&F.add(S.get(x));return F.size?await In(Array.from(F),u):[]}static runPython(d,u={}){return u.globals||(u.globals=API.globals),API.pyodide_code.eval_code.callKwargs(d,u)}static async runPythonAsync(d,u={}){return u.globals||(u.globals=API.globals),await API.pyodide_code.eval_code_async.callKwargs(d,u)}static async runPythonSyncifying(d,u={}){return u.globals||(u.globals=API.globals),API.pyodide_code.eval_code.callSyncifyingKwargs(d,u)}static registerJsModule(d,u){API.pyodide_ffi.register_js_module(d,u)}static unregisterJsModule(d){API.pyodide_ffi.unregister_js_module(d)}static toPy(d,{depth:u,defaultConverter:T}={depth:-1}){switch(typeof d){case"string":case"number":case"boolean":case"bigint":case"undefined":return d}if(!d||API.isPyProxy(d))return d;let D=0,S=0;try{D=Module.js2python_convert(d,{depth:u,defaultConverter:T})}catch(F){throw F instanceof Module._PropagatePythonError&&_pythonexc2js(),F}try{if(_JsProxy_Check(D))return d;S=_python2js(D),S===null&&_pythonexc2js()}finally{_Py_DecRef(D)}return S}static pyimport(d){return API.importlib.import_module(d)}static unpackArchive(d,u,T={}){if(!ArrayBuffer.isView(d)&&API.getTypeTag(d)!=="[object ArrayBuffer]")throw new TypeError("Expected argument 'buffer' to be an ArrayBuffer or an ArrayBuffer view");API.typedArrayAsUint8Array(d);let D=T.extractDir;API.package_loader.unpack_buffer.callKwargs({buffer:d,format:u,extract_dir:D,installer:"pyodide.unpackArchive"})}static async mountNativeFS(d,u){if(u.constructor.name!=="FileSystemDirectoryHandle")throw new TypeError("Expected argument 'fileSystemHandle' to be a FileSystemDirectoryHandle");return Module.FS.findObject(d)==null&&Module.FS.mkdirTree(d),Module.FS.mount(Module.FS.filesystems.NATIVEFS_ASYNC,{fileSystemHandle:u},d),await new Promise((T,D)=>Module.FS.syncfs(!0,T)),{syncfs:async()=>new Promise((T,D)=>Module.FS.syncfs(!1,T))}}static registerComlink(d){API._Comlink=d}static setInterruptBuffer(d){Module.HEAP8[Module._Py_EMSCRIPTEN_SIGNAL_HANDLING]=!!d,Module.Py_EmscriptenSignalBuffer=d}static checkInterrupt(){if(_PyGILState_Check()){__PyErr_CheckSignals()&&_pythonexc2js();return}else{let d=Module.Py_EmscriptenSignalBuffer;if(d&&d[0]===2)throw new Module.FS.ErrnoError(27)}}static setDebug(d){let u=!!API.debug_ffi;return API.debug_ffi=d,u}};o(Kt,"PyodideAPI"),Kt.version=O_,Kt.loadPackage=In,Kt.loadedPackages=Be,Kt.ffi=cn,Kt.setStdin=En,Kt.setStdout=kn,Kt.setStderr=Un,Kt.globals={},Kt.FS={},Kt.PATH={},Kt.canvas=S_,Kt.ERRNO_CODES={},Kt.pyodide_py={};function B0(){let d=Object.getOwnPropertyDescriptors(Kt);delete d.prototype;let u=Object.create({},d);return API.public_api=u,u.FS=Module.FS,u.PATH=Module.PATH,u.ERRNO_CODES=Module.ERRNO_CODES,u._module=Module,u._api=API,u}o(B0,"makePublicAPI");function F0(d,u){return new Proxy(d,{get(T,D){return D==="get"?S=>{let F=T.get(S);return F===void 0&&(F=u.get(S)),F}:D==="has"?S=>T.has(S)||u.has(S):Reflect.get(T,D)}})}o(F0,"wrapPythonGlobals");var W0;API.bootstrapFinalizedPromise=new Promise(d=>W0=d),API.finalizeBootstrap=function(){let[d,u]=API.rawRun("import _pyodide_core");d&&API.fatal_loading_error(`Failed to import _pyodide_core
`,u),API.runPythonInternal_dict=API._pyodide._base.eval_code("{}"),API.importlib=API.runPythonInternal("import importlib; importlib");let T=API.importlib.import_module;API.sys=T("sys"),API.sys.path.insert(0,API.config.env.HOME),API.os=T("os");let D=API.runPythonInternal("import __main__; __main__.__dict__"),S=API.runPythonInternal("import builtins; builtins.__dict__");API.globals=F0(D,S);let F=API._pyodide._importhook;function x(j){"__all__"in j||Object.defineProperty(j,"__all__",{get:()=>K.toPy(Object.getOwnPropertyNames(j).filter(pt=>pt!=="__all__")),enumerable:!1,configurable:!0})}o(x,"jsFinderHook"),F.register_js_finder.callKwargs({hook:x}),F.register_js_module("js",API.config.jsglobals);let K=B0();return F.register_js_module("pyodide_js",K),API.pyodide_py=T("pyodide"),API.pyodide_code=T("pyodide.code"),API.pyodide_ffi=T("pyodide.ffi"),API.package_loader=T("pyodide._package_loader"),API.sitepackages=API.package_loader.SITE_PACKAGES.__str__(),API.dsodir=API.package_loader.DSO_DIR.__str__(),API.defaultLdLibraryPath=[API.dsodir,API.sitepackages],API.os.environ.__setitem__("LD_LIBRARY_PATH",API.defaultLdLibraryPath.join(":")),K.pyodide_py=API.pyodide_py,K.globals=API.globals,W0(),K}})()}var StackSwitching=(()=>{var t=Object.defineProperty,e=Object.getOwnPropertyDescriptor,n=Object.getOwnPropertyNames,_=Object.prototype.hasOwnProperty,r=(B,X)=>{for(var _t in X)t(B,_t,{get:X[_t],enumerable:!0})},a=(B,X,_t,yt)=>{if(X&&typeof X=="object"||typeof X=="function")for(let Et of n(X))!_.call(B,Et)&&Et!==_t&&t(B,Et,{get:()=>X[Et],enumerable:!(yt=e(X,Et))||yt.enumerable});return B},o=B=>a(t({},"__esModule",{value:!0}),B),l=(()=>{for(var B=new Uint8Array(128),X=0;X<64;X++)B[X<26?X+65:X<52?X+71:X<62?X-4:X*4-205]=X;return _t=>{for(var yt=_t.length,Et=new Uint8Array((yt-(_t[yt-1]=="=")-(_t[yt-2]=="="))*3/4|0),Wt=0,Ht=0;Wt<yt;){var kt=B[_t.charCodeAt(Wt++)],It=B[_t.charCodeAt(Wt++)],Nt=B[_t.charCodeAt(Wt++)],ie=B[_t.charCodeAt(Wt++)];Et[Ht++]=kt<<2|It>>4,Et[Ht++]=It<<4|Nt>>2,Et[Ht++]=Nt<<6|ie}return Et}})(),p={};r(p,{createPromising:()=>te,jsWrapperTag:()=>W,promisingApply:()=>G});var c=[0,97,115,109,1,0,0,0];function I(B,X){var _t=[B];return uleb128Encode(X.length,_t),_t.push(...X),_t}var A={i32:127,i64:126,f32:125,f64:124,externref:111,void:64},m={i32:65,i64:66,f32:67,f64:68};function E(B){let X={i:"i32",j:"i64",f:"f32",d:"f64",e:"externref",v:""},_t=B.split("").map(Wt=>X[Wt]),yt=_t.shift();return{parameters:_t,results:yt?[yt]:[]}}var f=class{constructor(){this._numTypes=0,this._section=[0]}addEmscripten(B){return this.addWasm(E(B))}addWasm({parameters:B,results:X}){this._section.push(96),uleb128Encode(B.length,this._section);for(let _t of B)this._section.push(A[_t]);uleb128Encode(X.length,this._section);for(let _t of X)this._section.push(A[_t]);return this._numTypes++}generate(){return this._section[0]=this._numTypes,I(1,this._section)}};function R(B){let X=new TextEncoder().encode(B);return[X.length,...X]}var h=class{constructor(){this._numImports=0,this.numGlobals=0,this.numFuncs=0,this._section=[0]}_addName(B){this._section.push(...h._module),this._section.push(...R(B))}addFunction(B,X){return this._addName(B),this._section.push(h.descr.func,X),this._numImports++,this.numFuncs++}addTable(B){this._addName(B),this._section.push(h.descr.table,112,0,0),this._numImports++}addGlobal(B,X){return this._addName(B),this._section.push(h.descr.global,A[X],1),this._numImports++,this.numGlobals++}addTag(B,X){this._addName(B),this._section.push(h.descr.tag,0,X),this._numImports++}generate(){return this._section[0]=this._numImports,I(2,this._section)}};h._module=R("e"),h.descr={func:0,table:1,mem:2,global:3,tag:4};var w=class{constructor(...B){this._section=[],this.add(B.length);for(let X of B)this.add(1,A[X])}add(...B){this._section.push(...B)}local_get(B){this.add(32,B)}local_set(B){this.add(33,B)}local_tee(B){this.add(34,B)}global_get(B){this.add(35,B)}global_set(B){this.add(36,B)}call(B){this.add(16,B)}call_indirect(B){this.add(17,B,0)}const(B,...X){this.add(m[B],...X)}end(){this.add(11)}generate(){return this.end(),I(10,I(1,this._section))}},g=class{constructor(){this._sections=[c]}addSection(B){this._sections.push(B.generate())}addSectionBody(B,X){this._sections.push(I(B,X))}addImportSection(B){this.addSection(B),this._numImportFuncs=B.numFuncs}setExportType(B){let X=[1,B];this.addSectionBody(3,X);let _t=[1,...R("o"),0,this._numImportFuncs];this.addSectionBody(7,_t)}generate(){let B=new Uint8Array(this._sections.flat());return new WebAssembly.Module(B)}};function O(B){let X=new g,_t=new f,yt=E(B),Et=structuredClone(yt);Et.parameters.unshift("i32");let Wt=_t.addWasm(yt),Ht=_t.addWasm(Et),kt=A[yt.results[0]||"void"],It=_t.addEmscripten("ve"),Nt=_t.addEmscripten("i"),ie=_t.addEmscripten("vi"),Ne=_t.addEmscripten("vii");X.addSection(_t);let ee=new h;ee.addTable("t"),ee.addTag("tag",It);let Ie=ee.addFunction("s",Nt),Ce=ee.addFunction("r",ie),Te=ee.addFunction("q",Ne);X.addImportSection(ee),X.setExportType(Ht);let Tt=new w(["i32"]),Ae=Et.parameters.length;Tt.call(Ie),Tt.local_set(Ae),Tt.add(6,kt);for(let $t=1;$t<Et.parameters.length;$t++)Tt.local_get($t);Tt.local_get(0),Tt.call_indirect(Wt),Tt.add(7,0),Tt.add(26),Tt.local_get(Ae),Tt.call(Ce),Tt.const("i32",1),Tt.const("i32",0),Tt.call(Te);let Le={i32:1,i64:1,f32:4,f64:8};for(let $t of Et.results)Tt.const($t,...Array(Le[$t]).fill(0));return Tt.end(),X.addSection(Tt),X.generate()}var W;try{W=new WebAssembly.Tag({parameters:["externref"]})}catch{}var k=B=>new WebAssembly.Exception(W,[B]);function Z(B){if(!W)return createInvokeFunction(B);let X=O(B);return new WebAssembly.Instance(X,{e:{t:wasmTable,s:()=>stackSave(),r:yt=>stackRestore(yt),q:(yt,Et)=>_setThrew(yt,Et),tag:W}}).exports.o}function v(B){let X="invoke_";for(let _t of Object.keys(B))_t.startsWith(X)&&(B[_t]=Z(_t.slice(X.length)))}var tt={};r(tt,{default:()=>z});var z=l("AGFzbQEAAAABFARgAm9vAW9gAAFvYAFvAGABbwFvAioFAWUBcwNvAQFlAWMDfwEBZQFpAAABZQRzYXZlAAEBZQdyZXN0b3JlAAIDAgEDBwUBAW8AAwodARsBAW8jAUUEQNBvDwsQASEBIwAgABAAIAEQAgs="),et=[],At=class{constructor(){this.start=stackSave(),this.stop=Module.stackStop,this._copy=new Uint8Array(0),this.start!==this.stop&&et.push(this)}restore(){let B=0;for(;et.length>0&&et[et.length-1].stop<this.stop;)B+=et.pop()._save();let X=et[et.length-1];return X&&X!==this&&(B+=X._save_up_to(this.stop)),X&&X.stop===this.stop&&et.pop(),this._copy.length!==0&&(Module.HEAP8.set(this._copy,this.start),B+=this._copy.length,this._copy=new Uint8Array(0)),Module.stackStop=this.stop,stackRestore(this.start),B}_save_up_to(B){let X=this._copy.length,_t=B-this.start;if(_t<=X)return 0;let yt=HEAP8.subarray(this.start+X,this.start+_t),Et=new Uint8Array(_t);return Et.set(this._copy),Et.set(yt,X),this._copy=Et,_t}_save(){return this._save_up_to(this.stop)}};function rt(){let B=new At,X=_captureThreadState(),_t=Module.origCframe;return _restore_cframe(_t),{threadState:X,stackState:B,suspender:gt.value,origCframe:_t}}function J(B){B.stackState.restore(),Module.origCframe=B.origCframe,_restoreThreadState(B.threadState),gt.value=B.suspender,Module.validSuspender.value=!0}function it(){let B=new WebAssembly.Function({parameters:["externref","externref"],results:["externref"]},async yt=>{try{return nullToUndefined(await yt)}catch(Et){if(Et&&Et.pyodide_fatal_error)throw Et;return Module.syncify_error=Et,null}},{suspending:"first"}),X=new WebAssembly.Module(new Uint8Array(z)),_t=new WebAssembly.Instance(X,{e:{s:gt,i:B,c:jt,save:rt,restore:J}});HEAP32[_syncifyHandler/4]=addFunction(_t.exports.o)}var ot;function G(...B){jt.value=!0,Module.stackStop=stackSave(),Module.origCframe=_get_cframe();let X=stackAlloc(HEAP32[_size_of_cframe/4]);return _set_new_cframe(X),ot(...B)}function ht(B){return`params:${B.parameters};results:${B.results}`}function Pt(B){let X=new g,_t=new f,yt=structuredClone(B);yt.parameters.unshift("externref");let Et=_t.addWasm(B),Wt=_t.addWasm(yt);X.addSection(_t);let Ht=new h;Ht.addGlobal("s","externref");let kt=Ht.addFunction("i",Et);X.addImportSection(Ht),X.setExportType(Wt);let It=new w;It.local_get(0),It.global_set(0);for(let Nt=1;Nt<yt.parameters.length;Nt++)It.local_get(Nt);return It.call(kt),X.addSection(It),X.generate()}var Lt=new Map;function vt(B){let X=ht(B);if(Lt.has(X))return Lt.get(X);let _t=Pt(B);return Lt.set(X,_t),_t}var Ct=new WeakMap;function te(B){if(Ct.has(B))return Ct.get(B);let X=wasmFunctionType(B),_t=vt(X),yt=new WebAssembly.Instance(_t,{e:{i:B,s:gt}}),Et=new WebAssembly.Function({parameters:X.parameters,results:["externref"]},yt.exports.o,{promising:"first"});return Ct.set(B,Et),Et}var gt;try{gt=new WebAssembly.Global({value:"externref",mutable:!0},null)}catch{}var jt;function y(){jt=new WebAssembly.Global({value:"i32",mutable:!0},0),ot=te(wasmExports._pyproxy_apply),Module.validSuspender=jt,it()}if(Module.jspiSupported=!1,Module.validSuspender={value:0},"Suspender"in WebAssembly)try{new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0])),Module.jspiSupported=!0}catch{}return Module.jspiSupported&&(Module.preRun.push(y),Module.adjustWasmImports=v,Module.wrapException=k),o(p)})();let{createPromising,jsWrapperTag,promisingApply}=StackSwitching;Object.assign(Module,StackSwitching);let API=Module.API,Hiwire={},Tests={};API.tests=Tests,API.version="0.25.0",Module.hiwire=Hiwire;function getTypeTag(t){try{return Object.prototype.toString.call(t)}catch{return""}}API.getTypeTag=getTypeTag;function hasProperty(t,e){try{for(;t;){if(Object.getOwnPropertyDescriptor(t,e))return!0;t=Object.getPrototypeOf(t)}}catch{}return!1}function hasMethod(t,e){try{return typeof t[e]=="function"}catch{return!1}}let pyproxyIsAlive=t=>!!Module.PyProxy_getAttrsQuiet(t).shared.ptr;API.pyproxyIsAlive=pyproxyIsAlive;let errNoRet=()=>{throw new Error("Assertion error: control reached end of function without return")};Module.reportUndefinedSymbols=()=>{};let nullToUndefined=t=>t===null?void 0:t;function isPromise(t){try{return!!t&&typeof t.then=="function"}catch{return!1}}API.isPromise=isPromise;function bufferAsUint8Array(t){return ArrayBuffer.isView(t)?new Uint8Array(t.buffer,t.byteOffset,t.byteLength):new Uint8Array(t)}API.typedArrayAsUint8Array=bufferAsUint8Array,Module.iterObject=function*(t){for(let e in t)Object.prototype.hasOwnProperty.call(t,e)&&(yield e)};function wasmFunctionType(t){if(!WebAssembly.Function)throw new Error("No type reflection");return WebAssembly.Function.type?WebAssembly.Function.type(t):t.type()}pyodide_js_init(),pyodide_js_init.sig="v";function _PyImport_InitFunc_TrampolineCall(t){return wasmTable.get(t)()}_PyImport_InitFunc_TrampolineCall.sig="ii";function _Py_emscripten_runtime(){var t;typeof navigator=="object"?t=navigator.userAgent:typeof process=="object"?t="Node.js ".concat(process.version):t="UNKNOWN";var e=lengthBytesUTF8(t)+1,n=_malloc(e);return n&&stringToUTF8(t,n,e),n}_Py_emscripten_runtime.sig="i";function _Py_CheckEmscriptenSignals_Helper(){if(!Module.Py_EmscriptenSignalBuffer)return 0;try{let t=Module.Py_EmscriptenSignalBuffer[0];return Module.Py_EmscriptenSignalBuffer[0]=0,t}catch{return 0}}_Py_CheckEmscriptenSignals_Helper.sig="i";function _PyEM_detect_type_reflection(){return"Function"in WebAssembly}_PyEM_detect_type_reflection.sig="i";function _PyEM_TrampolineCall_JS(t,e,n,_){return wasmTable.get(t)(e,n,_)}_PyEM_TrampolineCall_JS.sig="iiiii";function _PyEM_CountFuncParams(t){let e=_PyEM_CountFuncParams.cache.get(t);return e!==void 0||(e=wasmFunctionType(wasmTable.get(t)).parameters.length,_PyEM_CountFuncParams.cache.set(t,e)),e}_PyEM_CountFuncParams.cache=new Map,_PyEM_CountFuncParams.sig="ii";function unbox_small_structs(t){for(var e=HEAPU16[(t+6>>1)+0];e===13;){var n=HEAPU32[(t+8>>2)+0],_=HEAPU32[(n>>2)+0];if(_===0){e=0;break}else if(HEAPU32[(n>>2)+1]===0)t=_,e=HEAPU16[(_+6>>1)+0];else break}return[t,e]}function ffi_call_js(t,e,n,_){var r=HEAPU32[(t>>2)+0],a=HEAPU32[(t>>2)+1],o=HEAPU32[(t>>2)+6],l=HEAPU32[(t>>2)+2],p=unbox_small_structs(HEAPU32[(t>>2)+3]),c=p[0],I=p[1],A=stackSave(),m=A,E=[],f=!1;if(I===15)throw new Error("complex ret marshalling nyi");if(I<0||I>15)throw new Error("Unexpected rtype "+I);(I===4||I===13)&&(E.push(n),f=!0);for(var R=0;R<o;R++){var h=HEAPU32[(_>>2)+R],w=unbox_small_structs(HEAPU32[(l>>2)+R]),g=w[0],O=w[1];switch(O){case 1:case 10:case 9:case 14:E.push(HEAPU32[(h>>2)+0]);break;case 2:E.push(HEAPF32[(h>>2)+0]);break;case 3:E.push(HEAPF64[(h>>3)+0]);break;case 5:E.push(HEAPU8[h+0]);break;case 6:E.push(HEAP8[h+0]);break;case 7:E.push(HEAPU16[(h>>1)+0]);break;case 8:E.push(HEAP16[(h>>1)+0]);break;case 11:case 12:E.push(HEAPU64[(h>>3)+0]);break;case 4:E.push(HEAPU64[(h>>3)+0]),E.push(HEAPU64[(h>>3)+1]);break;case 13:var W=HEAPU32[(g>>2)+0],k=HEAPU16[(g+4>>1)+0];m-=W,m&=~(k-1),HEAP8.subarray(m,m+W).set(HEAP8.subarray(h,h+W)),E.push(m);break;case 15:throw new Error("complex marshalling nyi");default:throw new Error("Unexpected type "+O)}}if(o!=a){for(var Z=[],R=a-1;R>=o;R--){var h=HEAPU32[(_>>2)+R],w=unbox_small_structs(HEAPU32[(l>>2)+R]),g=w[0],O=w[1];switch(O){case 5:case 6:m-=1,m&=-1,HEAPU8[m+0]=HEAPU8[h+0];break;case 7:case 8:m-=2,m&=-2,HEAPU16[(m>>1)+0]=HEAPU16[(h>>1)+0];break;case 1:case 9:case 10:case 14:case 2:m-=4,m&=-4,HEAPU32[(m>>2)+0]=HEAPU32[(h>>2)+0];break;case 3:case 11:case 12:m-=8,m&=-8,HEAPU32[(m>>2)+0]=HEAPU32[(h>>2)+0],HEAPU32[(m>>2)+1]=HEAPU32[(h>>2)+1];break;case 4:m-=16,m&=-8,HEAPU32[(m>>2)+0]=HEAPU32[(h>>2)+0],HEAPU32[(m>>2)+1]=HEAPU32[(h>>2)+1],HEAPU32[(m>>2)+2]=HEAPU32[(h>>2)+2],HEAPU32[(m>>2)+3]=HEAPU32[(h>>2)+3];break;case 13:m-=4,m&=-4,Z.push([m,h,HEAPU32[(g>>2)+0],HEAPU16[(g+4>>1)+0]]);break;case 15:throw new Error("complex arg marshalling nyi");default:throw new Error("Unexpected argtype "+O)}}E.push(m);for(var R=0;R<Z.length;R++){var v=Z[R],tt=v[0],h=v[1],W=v[2],k=v[3];m-=W,m&=~(k-1),HEAP8.subarray(m,m+W).set(HEAP8.subarray(h,h+W)),HEAPU32[(tt>>2)+0]=m}}stackRestore(m),stackAlloc(0);var z=getWasmTableEntry(e).apply(null,E);if(stackRestore(A),!f)switch(I){case 0:break;case 1:case 9:case 10:case 14:HEAPU32[(n>>2)+0]=z;break;case 2:HEAPF32[(n>>2)+0]=z;break;case 3:HEAPF64[(n>>3)+0]=z;break;case 5:case 6:HEAPU8[n+0]=z;break;case 7:case 8:HEAPU16[(n>>1)+0]=z;break;case 11:case 12:HEAPU64[(n>>3)+0]=z;break;case 15:throw new Error("complex ret marshalling nyi");default:throw new Error("Unexpected rtype "+I)}}ffi_call_js.sig="viiii";function ffi_closure_alloc_js(t,e){var n=_malloc(t),_=getEmptyTableSlot();return HEAPU32[(e>>2)+0]=_,HEAPU32[(n>>2)+0]=_,n}ffi_closure_alloc_js.sig="iii";function ffi_closure_free_js(t){var e=HEAPU32[(t>>2)+0];freeTableIndexes.push(e),_free(t)}ffi_closure_free_js.sig="vi";function ffi_prep_closure_loc_js(t,e,n,_,r){var a=HEAPU32[(e>>2)+0],o=HEAPU32[(e>>2)+1],l=HEAPU32[(e>>2)+6],p=HEAPU32[(e>>2)+2],c=unbox_small_structs(HEAPU32[(e>>2)+3]),I=c[0],A=c[1],m,E=!1;switch(A){case 0:m="v";break;case 13:case 4:m="vi",E=!0;break;case 1:case 5:case 6:case 7:case 8:case 9:case 10:case 14:m="i";break;case 2:m="f";break;case 3:m="d";break;case 11:case 12:m="j";break;case 15:throw new Error("complex ret marshalling nyi");default:throw new Error("Unexpected rtype "+A)}for(var f=[],R=[],h=0;h<o;h++){var w=unbox_small_structs(HEAPU32[(p>>2)+h]),g=w[0],O=w[1];f.push(O),R.push([HEAPU32[(g>>2)+0],HEAPU16[(g+4>>1)+0]])}for(var h=0;h<l;h++)switch(f[h]){case 1:case 5:case 6:case 7:case 8:case 9:case 10:case 14:case 13:m+="i";break;case 2:m+="f";break;case 3:m+="d";break;case 4:m+="jj";break;case 11:case 12:m+="j";break;case 15:throw new Error("complex marshalling nyi");default:throw new Error("Unexpected argtype "+O)}l<o&&(m+="i");function W(){var Z=Array.prototype.slice.call(arguments),v=0,tt=stackSave(),z=tt,et,At=0;E?et=Z[At++]:(z-=8,z&=-8,et=z),z-=4*o;for(var rt=z,J=0;J<l;J++){var it=Z[At++],ot=R[J],G=ot[0],ht=ot[1],Pt=f[J];switch(Pt){case 5:case 6:z-=1,z&=-4,HEAPU32[(rt>>2)+J]=z,HEAPU8[z+0]=it;break;case 7:case 8:z-=2,z&=-4,HEAPU32[(rt>>2)+J]=z,HEAPU16[(z>>1)+0]=it;break;case 1:case 9:case 10:case 14:z-=4,z&=-4,HEAPU32[(rt>>2)+J]=z,HEAPU32[(z>>2)+0]=it;break;case 13:z-=G,z&=~(ht-1),HEAP8.subarray(z,z+G).set(HEAP8.subarray(it,it+G)),HEAPU32[(rt>>2)+J]=z;break;case 2:z-=4,z&=-4,HEAPU32[(rt>>2)+J]=z,HEAPF32[(z>>2)+0]=it;break;case 3:z-=8,z&=-8,HEAPU32[(rt>>2)+J]=z,HEAPF64[(z>>3)+0]=it;break;case 11:case 12:z-=8,z&=-8,HEAPU32[(rt>>2)+J]=z,HEAPU64[(z>>3)+0]=it;break;case 4:z-=16,z&=-8,HEAPU32[(rt>>2)+J]=z,HEAPU64[(z>>3)+0]=it,it=Z[At++],HEAPU64[(z>>3)+1]=it;break}}for(var Lt=Z[Z.length-1];J<o;J++){var Pt=f[J],ot=R[J],G=ot[0],ht=ot[1];if(Pt===13){var vt=HEAPU32[(Lt>>2)+0];z-=G,z&=~(ht-1),HEAP8.subarray(z,z+G).set(HEAP8.subarray(vt,vt+G)),HEAPU32[(rt>>2)+J]=z}else HEAPU32[(rt>>2)+J]=Lt;Lt+=4}if(stackRestore(z),stackAlloc(0),getWasmTableEntry(HEAPU32[(t>>2)+2])(HEAPU32[(t>>2)+1],et,rt,HEAPU32[(t>>2)+3]),stackRestore(tt),!E)switch(m[0]){case"i":return HEAPU32[(et>>2)+0];case"j":return HEAPU64[(et>>3)+0];case"d":return HEAPF64[(et>>3)+0];case"f":return HEAPF32[(et>>2)+0]}}try{var k=convertJsFunctionToWasm(W,m)}catch{return 1}return setWasmTableEntry(r,k),HEAPU32[(t>>2)+1]=e,HEAPU32[(t>>2)+2]=n,HEAPU32[(t>>2)+3]=_,0}ffi_prep_closure_loc_js.sig="iiiiii";function __hiwire_deduplicate_new(){return new Map}__hiwire_deduplicate_new.sig="e";function __hiwire_deduplicate_get(t,e){return t.get(e)}__hiwire_deduplicate_get.sig="iee";function __hiwire_deduplicate_set(t,e,n){t.set(e,n)}__hiwire_deduplicate_set.sig="veei";function __hiwire_deduplicate_delete(t,e){t.delete(e)}__hiwire_deduplicate_delete.sig="vee";function ExitStatus(t){this.name="ExitStatus",this.message=`Program terminated with exit(${t})`,this.status=t}Module.ExitStatus=ExitStatus;var GOT={};Module.GOT=GOT;var currentModuleWeakSymbols=new Set([]);Module.currentModuleWeakSymbols=currentModuleWeakSymbols;var GOTHandler={get(t,e){var n=GOT[e];return n||(n=GOT[e]=new WebAssembly.Global({value:"i32",mutable:!0})),currentModuleWeakSymbols.has(e)||(n.required=!0),n}};Module.GOTHandler=GOTHandler;var callRuntimeCallbacks=t=>{for(;t.length>0;)t.shift()(Module)};Module.callRuntimeCallbacks=callRuntimeCallbacks;var decrementExceptionRefcount=t=>___cxa_decrement_exception_refcount(t);Module.decrementExceptionRefcount=decrementExceptionRefcount;var withStackSave=t=>{var e=stackSave(),n=t();return stackRestore(e),n};Module.withStackSave=withStackSave;var lengthBytesUTF8=t=>{for(var e=0,n=0;n<t.length;++n){var _=t.charCodeAt(n);_<=127?e++:_<=2047?e+=2:_>=55296&&_<=57343?(e+=4,++n):e+=3}return e};Module.lengthBytesUTF8=lengthBytesUTF8;var stringToUTF8Array=(t,e,n,_)=>{if(!(_>0))return 0;for(var r=n,a=n+_-1,o=0;o<t.length;++o){var l=t.charCodeAt(o);if(l>=55296&&l<=57343){var p=t.charCodeAt(++o);l=65536+((l&1023)<<10)|p&1023}if(l<=127){if(n>=a)break;e[n++]=l}else if(l<=2047){if(n+1>=a)break;e[n++]=192|l>>6,e[n++]=128|l&63}else if(l<=65535){if(n+2>=a)break;e[n++]=224|l>>12,e[n++]=128|l>>6&63,e[n++]=128|l&63}else{if(n+3>=a)break;e[n++]=240|l>>18,e[n++]=128|l>>12&63,e[n++]=128|l>>6&63,e[n++]=128|l&63}}return e[n]=0,n-r};Module.stringToUTF8Array=stringToUTF8Array;var stringToUTF8=(t,e,n)=>stringToUTF8Array(t,HEAPU8,e,n);Module.stringToUTF8=stringToUTF8;var stringToUTF8OnStack=t=>{var e=lengthBytesUTF8(t)+1,n=stackAlloc(e);return stringToUTF8(t,n,e),n};Module.stringToUTF8OnStack=stringToUTF8OnStack;var UTF8Decoder=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;Module.UTF8Decoder=UTF8Decoder;var UTF8ArrayToString=(t,e,n)=>{for(var _=e+n,r=e;t[r]&&!(r>=_);)++r;if(r-e>16&&t.buffer&&UTF8Decoder)return UTF8Decoder.decode(t.subarray(e,r));for(var a="";e<r;){var o=t[e++];if(!(o&128)){a+=String.fromCharCode(o);continue}var l=t[e++]&63;if((o&224)==192){a+=String.fromCharCode((o&31)<<6|l);continue}var p=t[e++]&63;if((o&240)==224?o=(o&15)<<12|l<<6|p:o=(o&7)<<18|l<<12|p<<6|t[e++]&63,o<65536)a+=String.fromCharCode(o);else{var c=o-65536;a+=String.fromCharCode(55296|c>>10,56320|c&1023)}}return a};Module.UTF8ArrayToString=UTF8ArrayToString;var UTF8ToString=(t,e)=>t?UTF8ArrayToString(HEAPU8,t,e):"";Module.UTF8ToString=UTF8ToString;var demangle=t=>(demangle.recursionGuard=(demangle.recursionGuard|0)+1,demangle.recursionGuard>1?t:withStackSave(()=>{try{var e=t;e.startsWith("__Z")&&(e=e.substr(1));var n=stringToUTF8OnStack(e),_=stackAlloc(4),r=___cxa_demangle(n,0,0,_);if(HEAP32[_>>2]===0&&r)return UTF8ToString(r)}catch{}finally{_free(r),demangle.recursionGuard<2&&--demangle.recursionGuard}return t}));Module.demangle=demangle;var getDylinkMetadata=t=>{var e=0,n=0;function _(){return t[e++]}function r(){for(var J=0,it=1;;){var ot=t[e++];if(J+=(ot&127)*it,it*=128,!(ot&128))break}return J}function a(){var J=r();return e+=J,UTF8ArrayToString(t,e-J,J)}function o(J,it){if(J)throw new Error(it)}var l="dylink.0";if(t instanceof WebAssembly.Module){var p=WebAssembly.Module.customSections(t,l);p.length===0&&(l="dylink",p=WebAssembly.Module.customSections(t,l)),o(p.length===0,"need dylink section"),t=new Uint8Array(p[0]),n=t.length}else{var c=new Uint32Array(new Uint8Array(t.subarray(0,24)).buffer),I=c[0]==1836278016;o(!I,"need to see wasm magic number"),o(t[8]!==0,"need the dylink section to be first"),e=9;var A=r();n=e+A,l=a()}var m={neededDynlibs:[],tlsExports:new Set,weakImports:new Set};if(l=="dylink"){m.memorySize=r(),m.memoryAlign=r(),m.tableSize=r(),m.tableAlign=r();for(var E=r(),f=0;f<E;++f){var R=a();m.neededDynlibs.push(R)}}else{o(l!=="dylink.0");for(var h=1,w=2,g=3,O=4,W=256,k=3,Z=1;e<n;){var v=_(),tt=r();if(v===h)m.memorySize=r(),m.memoryAlign=r(),m.tableSize=r(),m.tableAlign=r();else if(v===w)for(var E=r(),f=0;f<E;++f)R=a(),m.neededDynlibs.push(R);else if(v===g)for(var z=r();z--;){var et=a(),At=r();At&W&&m.tlsExports.add(et)}else if(v===O)for(var z=r();z--;){var rt=a(),et=a(),At=r();(At&k)==Z&&m.weakImports.add(et)}else e+=tt}}return m};Module.getDylinkMetadata=getDylinkMetadata;var getExceptionMessageCommon=t=>withStackSave(()=>{var e=stackAlloc(4),n=stackAlloc(4);___get_exception_message(t,e,n);var _=HEAPU32[e>>2],r=HEAPU32[n>>2],a=UTF8ToString(_);_free(_);var o;return r&&(o=UTF8ToString(r),_free(r)),[a,o]});Module.getExceptionMessageCommon=getExceptionMessageCommon;var getExceptionMessage=t=>getExceptionMessageCommon(t);Module.getExceptionMessage=getExceptionMessage;function getValue(t,e="i8"){switch(e.endsWith("*")&&(e="*"),e){case"i1":return HEAP8[t>>0];case"i8":return HEAP8[t>>0];case"i16":return HEAP16[t>>1];case"i32":return HEAP32[t>>2];case"i64":return HEAP64[t>>3];case"float":return HEAPF32[t>>2];case"double":return HEAPF64[t>>3];case"*":return HEAPU32[t>>2];default:abort(`invalid type for getValue: ${e}`)}}Module.getValue=getValue;var incrementExceptionRefcount=t=>___cxa_increment_exception_refcount(t);Module.incrementExceptionRefcount=incrementExceptionRefcount;var newDSO=(t,e,n)=>{var _={refcount:1/0,name:t,exports:n,global:!0};return LDSO.loadedLibsByName[t]=_,e!=null&&(LDSO.loadedLibsByHandle[e]=_),_};Module.newDSO=newDSO;var LDSO={loadedLibsByName:{},loadedLibsByHandle:{},init(){newDSO("__main__",0,wasmImports)}};Module.LDSO=LDSO;var ___heap_base=9191456;Module.___heap_base=___heap_base;var zeroMemory=(t,e)=>(HEAPU8.fill(0,t,t+e),t);Module.zeroMemory=zeroMemory;var alignMemory=(t,e)=>Math.ceil(t/e)*e;Module.alignMemory=alignMemory;var getMemory=t=>{if(runtimeInitialized)return zeroMemory(_malloc(t),t);var e=___heap_base,n=e+alignMemory(t,16);return ___heap_base=n,GOT.__heap_base.value=n,e};Module.getMemory=getMemory;var isInternalSym=t=>["__cpp_exception","__c_longjmp","__wasm_apply_data_relocs","__dso_handle","__tls_size","__tls_align","__set_stack_limits","_emscripten_tls_init","__wasm_init_tls","__wasm_call_ctors","__start_em_asm","__stop_em_asm","__start_em_js","__stop_em_js"].includes(t)||t.startsWith("__em_js__");Module.isInternalSym=isInternalSym;var uleb128Encode=(t,e)=>{t<128?e.push(t):e.push(t%128|128,t>>7)};Module.uleb128Encode=uleb128Encode;var sigToWasmTypes=t=>{for(var e={i:"i32",j:"i64",f:"f32",d:"f64",e:"externref",p:"i32"},n={parameters:[],results:t[0]=="v"?[]:[e[t[0]]]},_=1;_<t.length;++_)n.parameters.push(e[t[_]]);return n};Module.sigToWasmTypes=sigToWasmTypes;var generateFuncType=(t,e)=>{var n=t.slice(0,1),_=t.slice(1),r={i:127,p:127,j:126,f:125,d:124};e.push(96),uleb128Encode(_.length,e);for(var a=0;a<_.length;++a)e.push(r[_[a]]);n=="v"?e.push(0):e.push(1,r[n])};Module.generateFuncType=generateFuncType;var convertJsFunctionToWasm=(t,e)=>{if(typeof WebAssembly.Function=="function")return new WebAssembly.Function(sigToWasmTypes(e),t);var n=[1];generateFuncType(e,n);var _=[0,97,115,109,1,0,0,0,1];uleb128Encode(n.length,_),_.push.apply(_,n),_.push(2,7,1,1,101,1,102,0,0,7,5,1,1,102,0,0);var r=new WebAssembly.Module(new Uint8Array(_)),a=new WebAssembly.Instance(r,{e:{f:t}}),o=a.exports.f;return o};Module.convertJsFunctionToWasm=convertJsFunctionToWasm;var wasmTableMirror=[];Module.wasmTableMirror=wasmTableMirror;var wasmTable=new WebAssembly.Table({initial:6424,element:"anyfunc"});Module.wasmTable=wasmTable;var getWasmTableEntry=t=>{var e=wasmTableMirror[t];return e||(t>=wasmTableMirror.length&&(wasmTableMirror.length=t+1),wasmTableMirror[t]=e=wasmTable.get(t)),e};Module.getWasmTableEntry=getWasmTableEntry;var updateTableMap=(t,e)=>{if(functionsInTableMap)for(var n=t;n<t+e;n++){var _=getWasmTableEntry(n);_&&functionsInTableMap.set(_,n)}};Module.updateTableMap=updateTableMap;var functionsInTableMap;Module.functionsInTableMap=functionsInTableMap;var getFunctionAddress=t=>(functionsInTableMap||(functionsInTableMap=new WeakMap,updateTableMap(0,wasmTable.length)),functionsInTableMap.get(t)||0);Module.getFunctionAddress=getFunctionAddress;var freeTableIndexes=[];Module.freeTableIndexes=freeTableIndexes;var getEmptyTableSlot=()=>{if(freeTableIndexes.length)return freeTableIndexes.pop();try{wasmTable.grow(1)}catch(t){throw t instanceof RangeError?"Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.":t}return wasmTable.length-1};Module.getEmptyTableSlot=getEmptyTableSlot;var setWasmTableEntry=(t,e)=>{wasmTable.set(t,e),wasmTableMirror[t]=wasmTable.get(t)};Module.setWasmTableEntry=setWasmTableEntry;var addFunction=(t,e)=>{var n=getFunctionAddress(t);if(n)return n;var _=getEmptyTableSlot();try{setWasmTableEntry(_,t)}catch(a){if(!(a instanceof TypeError))throw a;var r=convertJsFunctionToWasm(t,e);setWasmTableEntry(_,r)}return functionsInTableMap.set(t,_),_};Module.addFunction=addFunction;var updateGOT=(t,e)=>{for(var n in t)if(!isInternalSym(n)){var _=t[n];GOT[n]||(GOT[n]=new WebAssembly.Global({value:"i32",mutable:!0})),(e||GOT[n].value==0)&&(typeof _=="function"?GOT[n].value=addFunction(_):typeof _=="number"?GOT[n].value=_:err(`unhandled export type for '${n}': ${typeof _}`))}};Module.updateGOT=updateGOT;var relocateExports=(t,e,n)=>{var _={};for(var r in t){var a=t[r];typeof a=="object"&&(a=a.value),typeof a=="number"&&(a+=e),_[r]=a}return updateGOT(_,n),_};Module.relocateExports=relocateExports;var isSymbolDefined=t=>{var e=wasmImports[t];return!(!e||e.stub)};Module.isSymbolDefined=isSymbolDefined;var dynCall=(t,e,n)=>{var _=getWasmTableEntry(e).apply(null,n);return _};Module.dynCall=dynCall;var createInvokeFunction=t=>function(){var e=stackSave();try{return dynCall(t,arguments[0],Array.prototype.slice.call(arguments,1))}catch(n){if(stackRestore(e),n!==n+0)throw n;_setThrew(1,0)}};Module.createInvokeFunction=createInvokeFunction;var resolveGlobalSymbol=(t,e=!1)=>{var n;return isSymbolDefined(t)?n=wasmImports[t]:t.startsWith("invoke_")?n=wasmImports[t]=Module.createInvoke(t.split("_")[1]):t.startsWith("__cxa_find_matching_catch_")&&(n=wasmImports[t]=function(){var _=Array.from(arguments),r=findMatchingCatch(_);return r}),{sym:n,name:t}};Module.resolveGlobalSymbol=resolveGlobalSymbol;var loadWebAssemblyModule=(binary,flags,libName,localScope,handle)=>{var metadata=getDylinkMetadata(binary);currentModuleWeakSymbols=metadata.weakImports;function loadModule(){var firstLoad=!handle||!HEAP8[handle+8>>0];if(firstLoad){var memAlign=Math.pow(2,metadata.memoryAlign),memoryBase=metadata.memorySize?alignMemory(getMemory(metadata.memorySize+memAlign),memAlign):0,tableBase=metadata.tableSize?wasmTable.length:0;handle&&(HEAP8[handle+8>>0]=1,HEAPU32[handle+12>>2]=memoryBase,HEAP32[handle+16>>2]=metadata.memorySize,HEAPU32[handle+20>>2]=tableBase,HEAP32[handle+24>>2]=metadata.tableSize)}else memoryBase=HEAPU32[handle+12>>2],tableBase=HEAPU32[handle+20>>2];var tableGrowthNeeded=tableBase+metadata.tableSize-wasmTable.length;tableGrowthNeeded>0&&wasmTable.grow(tableGrowthNeeded);var moduleExports;function resolveSymbol(t){var e=resolveGlobalSymbol(t).sym;return!e&&localScope&&(e=localScope[t]),e||(e=moduleExports[t]),e}var proxyHandler={get(t,e){switch(e){case"__memory_base":return memoryBase;case"__table_base":return tableBase}if(e in wasmImports&&!wasmImports[e].stub)return wasmImports[e];if(!(e in t)){var n;t[e]=function(){if(n||(n=resolveSymbol(e)),!n)throw new Error(`Dynamic linking error: cannot resolve symbol ${e}`);return n.apply(null,arguments)}}return t[e]}},proxy=new Proxy({},proxyHandler),info={"GOT.mem":new Proxy({},GOTHandler),"GOT.func":new Proxy({},GOTHandler),env:proxy,wasi_snapshot_preview1:proxy};function postInstantiation(module,instance){updateTableMap(tableBase,metadata.tableSize),moduleExports=relocateExports(instance.exports,memoryBase),flags.allowUndefined||reportUndefinedSymbols();function addEmAsm(addr,body){for(var args=[],arity=0;arity<16&&body.indexOf("$"+arity)!=-1;arity++)args.push("$"+arity);args=args.join(",");var func=`(${args}) => { ${body} };`;ASM_CONSTS[start]=eval(func)}if("__start_em_asm"in moduleExports)for(var start=moduleExports.__start_em_asm,stop=moduleExports.__stop_em_asm;start<stop;){var jsString=UTF8ToString(start);addEmAsm(start,jsString),start=HEAPU8.indexOf(0,start)+1}function addEmJs(name,cSig,body){var jsArgs=[];if(cSig=cSig.slice(1,-1),cSig!="void"){cSig=cSig.split(",");for(var i in cSig){var jsArg=cSig[i].split(" ").pop();jsArgs.push(jsArg.replace("*",""))}}var func=`(${jsArgs}) => ${body};`;moduleExports[name]=eval(func)}for(var name in moduleExports)if(name.startsWith("__em_js__")){var start=moduleExports[name],jsString=UTF8ToString(start),parts=jsString.split("<::>");addEmJs(name.replace("__em_js__",""),parts[0],parts[1]),delete moduleExports[name]}var applyRelocs=moduleExports.__wasm_apply_data_relocs;applyRelocs&&(runtimeInitialized?applyRelocs():__RELOC_FUNCS__.push(applyRelocs));var init=moduleExports.__wasm_call_ctors;return init&&(runtimeInitialized?init():__ATINIT__.push(init)),moduleExports}if(flags.loadAsync){if(binary instanceof WebAssembly.Module){var instance=new WebAssembly.Instance(binary,info);return Promise.resolve(postInstantiation(binary,instance))}return WebAssembly.instantiate(binary,info).then(t=>postInstantiation(t.module,t.instance))}var module=binary instanceof WebAssembly.Module?binary:new WebAssembly.Module(binary),instance=new WebAssembly.Instance(module,info);return postInstantiation(module,instance)}return flags.loadAsync?metadata.neededDynlibs.reduce((t,e)=>t.then(()=>loadDynamicLibrary(e,flags)),Promise.resolve()).then(loadModule):(metadata.neededDynlibs.forEach(t=>loadDynamicLibrary(t,flags,localScope)),loadModule())};Module.loadWebAssemblyModule=loadWebAssemblyModule;var mergeLibSymbols=(t,e)=>{for(var n in t){if(!t.hasOwnProperty(n))continue;let _=a=>{isSymbolDefined(a)||(wasmImports[a]=t[n])};_(n);let r="__main_argc_argv";n=="main"&&_(r),n==r&&_("main"),n.startsWith("dynCall_")&&!Module.hasOwnProperty(n)&&(Module[n]=t[n])}};Module.mergeLibSymbols=mergeLibSymbols;var asyncLoad=(t,e,n,_)=>{var r=_?"":`al ${t}`;readAsync(t,a=>{assert(a,`Loading data file "${t}" failed (no arrayBuffer).`),e(new Uint8Array(a)),r&&removeRunDependency(r)},a=>{if(n)n();else throw`Loading data file "${t}" failed.`}),r&&addRunDependency(r)};Module.asyncLoad=asyncLoad;var preloadPlugins=Module.preloadPlugins||[];Module.preloadPlugins=preloadPlugins;var registerWasmPlugin=()=>{var t={promiseChainEnd:Promise.resolve(),canHandle:e=>!Module.noWasmDecoding&&e.endsWith(".so"),handle:(e,n,_,r)=>{t.promiseChainEnd=t.promiseChainEnd.then(()=>loadWebAssemblyModule(e,{loadAsync:!0,nodelete:!0},n)).then(a=>{preloadedWasm[n]=a,_(e)},a=>{err(`failed to instantiate wasm: ${n}: ${a}`),r()})}};preloadPlugins.push(t)};Module.registerWasmPlugin=registerWasmPlugin;var preloadedWasm={};Module.preloadedWasm=preloadedWasm;function loadDynamicLibrary(t,e={global:!0,nodelete:!0},n,_){var r=LDSO.loadedLibsByName[t];if(r)return e.global?r.global||(r.global=!0,mergeLibSymbols(r.exports,t)):n&&Object.assign(n,r.exports),e.nodelete&&r.refcount!==1/0&&(r.refcount=1/0),r.refcount++,_&&(LDSO.loadedLibsByHandle[_]=r),e.loadAsync?Promise.resolve(!0):!0;r=newDSO(t,_,"loading"),r.refcount=e.nodelete?1/0:1,r.global=e.global;function a(){var p;if(_){var c=HEAPU32[_+28>>2],I=HEAPU32[_+32>>2];c&&I&&(p=HEAP8.slice(c,c+I))}if(!p&&e.fs&&e.fs.findObject(t)&&(p=e.fs.readFile(t,{encoding:"binary"}),p instanceof Uint8Array||(p=new Uint8Array(p))),p)return e.loadAsync?Promise.resolve(p):p;var A=locateFile(t);if(e.loadAsync)return new Promise(function(m,E){asyncLoad(A,f=>m(f),E)});if(!readBinary)throw new Error(`${A}: file not found, and synchronous loading of external files is not available`);return readBinary(A)}function o(){var p=preloadedWasm[t];return p?e.loadAsync?Promise.resolve(p):p:e.loadAsync?a().then(c=>loadWebAssemblyModule(c,e,t,n,_)):loadWebAssemblyModule(a(),e,t,n,_)}function l(p){r.global?mergeLibSymbols(p,t):n&&Object.assign(n,p),r.exports=p}return e.loadAsync?o().then(p=>(l(p),!0)):(l(o()),!0)}Module.loadDynamicLibrary=loadDynamicLibrary;var reportUndefinedSymbols=()=>{for(var t in GOT)if(GOT[t].value==0){var e=resolveGlobalSymbol(t,!0).sym;if(!e&&!GOT[t].required)continue;if(typeof e=="function")GOT[t].value=addFunction(e,e.sig);else if(typeof e=="number")GOT[t].value=e;else throw new Error(`bad export type for '${t}': ${typeof e}`)}};Module.reportUndefinedSymbols=reportUndefinedSymbols;var loadDylibs=()=>{if(!dynamicLibraries.length){reportUndefinedSymbols();return}addRunDependency("loadDylibs"),dynamicLibraries.reduce((t,e)=>t.then(()=>loadDynamicLibrary(e,{loadAsync:!0,global:!0,nodelete:!0,allowUndefined:!0})),Promise.resolve()).then(()=>{reportUndefinedSymbols(),removeRunDependency("loadDylibs")})};Module.loadDylibs=loadDylibs;function setValue(t,e,n="i8"){switch(n.endsWith("*")&&(n="*"),n){case"i1":HEAP8[t>>0]=e;break;case"i8":HEAP8[t>>0]=e;break;case"i16":HEAP16[t>>1]=e;break;case"i32":HEAP32[t>>2]=e;break;case"i64":HEAP64[t>>3]=BigInt(e);break;case"float":HEAPF32[t>>2]=e;break;case"double":HEAPF64[t>>3]=e;break;case"*":HEAPU32[t>>2]=e;break;default:abort(`invalid type for setValue: ${n}`)}}Module.setValue=setValue;function jsStackTrace(){var t=new Error;if(!t.stack){try{throw new Error}catch(e){t=e}if(!t.stack)return"(no stack trace available)"}return t.stack.toString()}Module.jsStackTrace=jsStackTrace;var demangleAll=t=>{var e=/\b_Z[\w\d_]+/g;return t.replace(e,function(n){var _=demangle(n);return n===_?n:_+" ["+n+"]"})};Module.demangleAll=demangleAll;function stackTrace(){var t=jsStackTrace();return Module.extraStackTrace&&(t+=`
`+Module.extraStackTrace()),demangleAll(t)}Module.stackTrace=stackTrace;var ___assert_fail=(t,e,n,_)=>{abort(`Assertion failed: ${UTF8ToString(t)}, at: `+[e?UTF8ToString(e):"unknown filename",n,_?UTF8ToString(_):"unknown function"])};Module.___assert_fail=___assert_fail,___assert_fail.sig="vppip";var ___call_sighandler=(t,e)=>getWasmTableEntry(t)(e);Module.___call_sighandler=___call_sighandler,___call_sighandler.sig="vpi";var exceptionCaught=[];Module.exceptionCaught=exceptionCaught;var uncaughtExceptionCount=0;Module.uncaughtExceptionCount=uncaughtExceptionCount;var ___cxa_begin_catch=t=>{var e=new ExceptionInfo(t);return e.get_caught()||(e.set_caught(!0),uncaughtExceptionCount--),e.set_rethrown(!1),exceptionCaught.push(e),___cxa_increment_exception_refcount(e.excPtr),e.get_exception_ptr()};Module.___cxa_begin_catch=___cxa_begin_catch,___cxa_begin_catch.sig="pp";var ___cxa_current_primary_exception=()=>{if(!exceptionCaught.length)return 0;var t=exceptionCaught[exceptionCaught.length-1];return ___cxa_increment_exception_refcount(t.excPtr),t.excPtr};Module.___cxa_current_primary_exception=___cxa_current_primary_exception,___cxa_current_primary_exception.sig="p";var exceptionLast=0;Module.exceptionLast=exceptionLast;var ___cxa_end_catch=()=>{_setThrew(0,0);var t=exceptionCaught.pop();___cxa_decrement_exception_refcount(t.excPtr),exceptionLast=0};Module.___cxa_end_catch=___cxa_end_catch,___cxa_end_catch.sig="v";function ExceptionInfo(t){this.excPtr=t,this.ptr=t-24,this.set_type=function(e){HEAPU32[this.ptr+4>>2]=e},this.get_type=function(){return HEAPU32[this.ptr+4>>2]},this.set_destructor=function(e){HEAPU32[this.ptr+8>>2]=e},this.get_destructor=function(){return HEAPU32[this.ptr+8>>2]},this.set_caught=function(e){e=e?1:0,HEAP8[this.ptr+12>>0]=e},this.get_caught=function(){return HEAP8[this.ptr+12>>0]!=0},this.set_rethrown=function(e){e=e?1:0,HEAP8[this.ptr+13>>0]=e},this.get_rethrown=function(){return HEAP8[this.ptr+13>>0]!=0},this.init=function(e,n){this.set_adjusted_ptr(0),this.set_type(e),this.set_destructor(n)},this.set_adjusted_ptr=function(e){HEAPU32[this.ptr+16>>2]=e},this.get_adjusted_ptr=function(){return HEAPU32[this.ptr+16>>2]},this.get_exception_ptr=function(){var e=___cxa_is_pointer_type(this.get_type());if(e)return HEAPU32[this.excPtr>>2];var n=this.get_adjusted_ptr();return n!==0?n:this.excPtr}}Module.ExceptionInfo=ExceptionInfo;var ___resumeException=t=>{throw exceptionLast||(exceptionLast=t),Module.wrapException(exceptionLast)};Module.___resumeException=___resumeException,___resumeException.sig="vp";var findMatchingCatch=t=>{var e=exceptionLast;if(!e)return setTempRet0(0),0;var n=new ExceptionInfo(e);n.set_adjusted_ptr(e);var _=n.get_type();if(!_)return setTempRet0(0),e;for(var r in t){var a=t[r];if(a===0||a===_)break;var o=n.ptr+16;if(___cxa_can_catch(a,_,o))return setTempRet0(a),e}return setTempRet0(_),e};Module.findMatchingCatch=findMatchingCatch;var ___cxa_find_matching_catch_2=()=>findMatchingCatch([]);Module.___cxa_find_matching_catch_2=___cxa_find_matching_catch_2,___cxa_find_matching_catch_2.sig="p";var ___cxa_find_matching_catch_3=t=>findMatchingCatch([t]);Module.___cxa_find_matching_catch_3=___cxa_find_matching_catch_3,___cxa_find_matching_catch_3.sig="pp";var ___cxa_rethrow=()=>{var t=exceptionCaught.pop();t||abort("no exception to throw");var e=t.excPtr;throw t.get_rethrown()||(exceptionCaught.push(t),t.set_rethrown(!0),t.set_caught(!1),uncaughtExceptionCount++),exceptionLast=e,Module.wrapException(exceptionLast)};Module.___cxa_rethrow=___cxa_rethrow,___cxa_rethrow.sig="v";var ___cxa_rethrow_primary_exception=t=>{if(t){var e=new ExceptionInfo(t);exceptionCaught.push(e),e.set_rethrown(!0),___cxa_rethrow()}};Module.___cxa_rethrow_primary_exception=___cxa_rethrow_primary_exception,___cxa_rethrow_primary_exception.sig="vp";var ___cxa_throw=(t,e,n)=>{var _=new ExceptionInfo(t);throw _.init(e,n),exceptionLast=t,uncaughtExceptionCount++,Module.wrapException(exceptionLast)};Module.___cxa_throw=___cxa_throw,___cxa_throw.sig="vppp";var ___cxa_uncaught_exceptions=()=>uncaughtExceptionCount;Module.___cxa_uncaught_exceptions=___cxa_uncaught_exceptions,___cxa_uncaught_exceptions.sig="i";var ___memory_base=new WebAssembly.Global({value:"i32",mutable:!1},1024);Module.___memory_base=___memory_base;var ___stack_high=9191456;Module.___stack_high=___stack_high;var ___stack_low=3948576;Module.___stack_low=___stack_low;var ___stack_pointer=new WebAssembly.Global({value:"i32",mutable:!0},9191456);Module.___stack_pointer=___stack_pointer;var PATH={isAbs:t=>t.charAt(0)==="/",splitPath:t=>{var e=/^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;return e.exec(t).slice(1)},normalizeArray:(t,e)=>{for(var n=0,_=t.length-1;_>=0;_--){var r=t[_];r==="."?t.splice(_,1):r===".."?(t.splice(_,1),n++):n&&(t.splice(_,1),n--)}if(e)for(;n;n--)t.unshift("..");return t},normalize:t=>{var e=PATH.isAbs(t),n=t.substr(-1)==="/";return t=PATH.normalizeArray(t.split("/").filter(_=>!!_),!e).join("/"),!t&&!e&&(t="."),t&&n&&(t+="/"),(e?"/":"")+t},dirname:t=>{var e=PATH.splitPath(t),n=e[0],_=e[1];return!n&&!_?".":(_&&(_=_.substr(0,_.length-1)),n+_)},basename:t=>{if(t==="/")return"/";t=PATH.normalize(t),t=t.replace(/\/$/,"");var e=t.lastIndexOf("/");return e===-1?t:t.substr(e+1)},join:function(){var t=Array.prototype.slice.call(arguments);return PATH.normalize(t.join("/"))},join2:(t,e)=>PATH.normalize(t+"/"+e)};Module.PATH=PATH;var initRandomFill=()=>{if(typeof crypto=="object"&&typeof crypto.getRandomValues=="function")return _=>crypto.getRandomValues(_);if(ENVIRONMENT_IS_NODE)try{var t=yn(),e=t.randomFillSync;if(e)return _=>t.randomFillSync(_);var n=t.randomBytes;return _=>(_.set(n(_.byteLength)),_)}catch{}abort("initRandomDevice")};Module.initRandomFill=initRandomFill;var randomFill=t=>(randomFill=initRandomFill())(t);Module.randomFill=randomFill;var PATH_FS={resolve:function(){for(var t="",e=!1,n=arguments.length-1;n>=-1&&!e;n--){var _=n>=0?arguments[n]:FS.cwd();if(typeof _!="string")throw new TypeError("Arguments to path.resolve must be strings");if(!_)return"";t=_+"/"+t,e=PATH.isAbs(_)}return t=PATH.normalizeArray(t.split("/").filter(r=>!!r),!e).join("/"),(e?"/":"")+t||"."},relative:(t,e)=>{t=PATH_FS.resolve(t).substr(1),e=PATH_FS.resolve(e).substr(1);function n(c){for(var I=0;I<c.length&&c[I]==="";I++);for(var A=c.length-1;A>=0&&c[A]==="";A--);return I>A?[]:c.slice(I,A-I+1)}for(var _=n(t.split("/")),r=n(e.split("/")),a=Math.min(_.length,r.length),o=a,l=0;l<a;l++)if(_[l]!==r[l]){o=l;break}for(var p=[],l=o;l<_.length;l++)p.push("..");return p=p.concat(r.slice(o)),p.join("/")}};Module.PATH_FS=PATH_FS;var FS_stdin_getChar_buffer=[];Module.FS_stdin_getChar_buffer=FS_stdin_getChar_buffer;function intArrayFromString(t,e,n){var _=n>0?n:lengthBytesUTF8(t)+1,r=new Array(_),a=stringToUTF8Array(t,r,0,r.length);return e&&(r.length=a),r}Module.intArrayFromString=intArrayFromString;var FS_stdin_getChar=()=>{if(!FS_stdin_getChar_buffer.length){var t=null;if(ENVIRONMENT_IS_NODE){var e=256,n=Buffer.alloc(e),_=0,r=process.stdin.fd;try{_=fs.readSync(r,n)}catch(a){if(a.toString().includes("EOF"))_=0;else throw a}_>0?t=n.slice(0,_).toString("utf-8"):t=null}else typeof window<"u"&&typeof window.prompt=="function"?(t=window.prompt("Input: "),t!==null&&(t+=`
`)):typeof readline=="function"&&(t=readline(),t!==null&&(t+=`
`));if(!t)return null;FS_stdin_getChar_buffer=intArrayFromString(t,!0)}return FS_stdin_getChar_buffer.shift()};Module.FS_stdin_getChar=FS_stdin_getChar;var TTY={ttys:[],init(){},shutdown(){},register(t,e){TTY.ttys[t]={input:[],output:[],ops:e},FS.registerDevice(t,TTY.stream_ops)},stream_ops:{open(t){var e=TTY.ttys[t.node.rdev];if(!e)throw new FS.ErrnoError(43);t.tty=e,t.seekable=!1},close(t){t.tty.ops.fsync(t.tty)},fsync(t){t.tty.ops.fsync(t.tty)},read(t,e,n,_,r){if(!t.tty||!t.tty.ops.get_char)throw new FS.ErrnoError(60);for(var a=0,o=0;o<_;o++){var l;try{l=t.tty.ops.get_char(t.tty)}catch{throw new FS.ErrnoError(29)}if(l===void 0&&a===0)throw new FS.ErrnoError(6);if(l==null)break;a++,e[n+o]=l}return a&&(t.node.timestamp=Date.now()),a},write(t,e,n,_,r){if(!t.tty||!t.tty.ops.put_char)throw new FS.ErrnoError(60);try{for(var a=0;a<_;a++)t.tty.ops.put_char(t.tty,e[n+a])}catch{throw new FS.ErrnoError(29)}return _&&(t.node.timestamp=Date.now()),a}},default_tty_ops:{get_char(t){return FS_stdin_getChar()},put_char(t,e){e===null||e===10?(out(UTF8ArrayToString(t.output,0)),t.output=[]):e!=0&&t.output.push(e)},fsync(t){t.output&&t.output.length>0&&(out(UTF8ArrayToString(t.output,0)),t.output=[])},ioctl_tcgets(t){return{c_iflag:25856,c_oflag:5,c_cflag:191,c_lflag:35387,c_cc:[3,28,127,21,4,0,1,0,17,19,26,0,18,15,23,22,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]}},ioctl_tcsets(t,e,n){return 0},ioctl_tiocgwinsz(t){return[24,80]}},default_tty1_ops:{put_char(t,e){e===null||e===10?(err(UTF8ArrayToString(t.output,0)),t.output=[]):e!=0&&t.output.push(e)},fsync(t){t.output&&t.output.length>0&&(err(UTF8ArrayToString(t.output,0)),t.output=[])}}};Module.TTY=TTY;var mmapAlloc=t=>{t=alignMemory(t,65536);var e=_emscripten_builtin_memalign(65536,t);return e?zeroMemory(e,t):0};Module.mmapAlloc=mmapAlloc;var MEMFS={ops_table:null,mount(t){return MEMFS.createNode(null,"/",16895,0)},createNode(t,e,n,_){if(FS.isBlkdev(n)||FS.isFIFO(n))throw new FS.ErrnoError(63);MEMFS.ops_table||(MEMFS.ops_table={dir:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr,lookup:MEMFS.node_ops.lookup,mknod:MEMFS.node_ops.mknod,rename:MEMFS.node_ops.rename,unlink:MEMFS.node_ops.unlink,rmdir:MEMFS.node_ops.rmdir,readdir:MEMFS.node_ops.readdir,symlink:MEMFS.node_ops.symlink},stream:{llseek:MEMFS.stream_ops.llseek}},file:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr},stream:{llseek:MEMFS.stream_ops.llseek,read:MEMFS.stream_ops.read,write:MEMFS.stream_ops.write,allocate:MEMFS.stream_ops.allocate,mmap:MEMFS.stream_ops.mmap,msync:MEMFS.stream_ops.msync}},link:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr,readlink:MEMFS.node_ops.readlink},stream:{}},chrdev:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr},stream:FS.chrdev_stream_ops}});var r=FS.createNode(t,e,n,_);return FS.isDir(r.mode)?(r.node_ops=MEMFS.ops_table.dir.node,r.stream_ops=MEMFS.ops_table.dir.stream,r.contents={}):FS.isFile(r.mode)?(r.node_ops=MEMFS.ops_table.file.node,r.stream_ops=MEMFS.ops_table.file.stream,r.usedBytes=0,r.contents=null):FS.isLink(r.mode)?(r.node_ops=MEMFS.ops_table.link.node,r.stream_ops=MEMFS.ops_table.link.stream):FS.isChrdev(r.mode)&&(r.node_ops=MEMFS.ops_table.chrdev.node,r.stream_ops=MEMFS.ops_table.chrdev.stream),r.timestamp=Date.now(),t&&(t.contents[e]=r,t.timestamp=r.timestamp),r},getFileDataAsTypedArray(t){return t.contents?t.contents.subarray?t.contents.subarray(0,t.usedBytes):new Uint8Array(t.contents):new Uint8Array(0)},expandFileStorage(t,e){var n=t.contents?t.contents.length:0;if(!(n>=e)){var _=1024*1024;e=Math.max(e,n*(n<_?2:1.125)>>>0),n!=0&&(e=Math.max(e,256));var r=t.contents;t.contents=new Uint8Array(e),t.usedBytes>0&&t.contents.set(r.subarray(0,t.usedBytes),0)}},resizeFileStorage(t,e){if(t.usedBytes!=e)if(e==0)t.contents=null,t.usedBytes=0;else{var n=t.contents;t.contents=new Uint8Array(e),n&&t.contents.set(n.subarray(0,Math.min(e,t.usedBytes))),t.usedBytes=e}},node_ops:{getattr(t){var e={};return e.dev=FS.isChrdev(t.mode)?t.id:1,e.ino=t.id,e.mode=t.mode,e.nlink=1,e.uid=0,e.gid=0,e.rdev=t.rdev,FS.isDir(t.mode)?e.size=4096:FS.isFile(t.mode)?e.size=t.usedBytes:FS.isLink(t.mode)?e.size=t.link.length:e.size=0,e.atime=new Date(t.timestamp),e.mtime=new Date(t.timestamp),e.ctime=new Date(t.timestamp),e.blksize=4096,e.blocks=Math.ceil(e.size/e.blksize),e},setattr(t,e){e.mode!==void 0&&(t.mode=e.mode),e.timestamp!==void 0&&(t.timestamp=e.timestamp),e.size!==void 0&&MEMFS.resizeFileStorage(t,e.size)},lookup(t,e){throw FS.genericErrors[44]},mknod(t,e,n,_){return MEMFS.createNode(t,e,n,_)},rename(t,e,n){if(FS.isDir(t.mode)){var _;try{_=FS.lookupNode(e,n)}catch{}if(_)for(var r in _.contents)throw new FS.ErrnoError(55)}delete t.parent.contents[t.name],t.parent.timestamp=Date.now(),t.name=n,e.contents[n]=t,e.timestamp=t.parent.timestamp,t.parent=e},unlink(t,e){delete t.contents[e],t.timestamp=Date.now()},rmdir(t,e){var n=FS.lookupNode(t,e);for(var _ in n.contents)throw new FS.ErrnoError(55);delete t.contents[e],t.timestamp=Date.now()},readdir(t){var e=[".",".."];for(var n in t.contents)t.contents.hasOwnProperty(n)&&e.push(n);return e},symlink(t,e,n){var _=MEMFS.createNode(t,e,41471,0);return _.link=n,_},readlink(t){if(!FS.isLink(t.mode))throw new FS.ErrnoError(28);return t.link}},stream_ops:{read(t,e,n,_,r){var a=t.node.contents;if(r>=t.node.usedBytes)return 0;var o=Math.min(t.node.usedBytes-r,_);if(o>8&&a.subarray)e.set(a.subarray(r,r+o),n);else for(var l=0;l<o;l++)e[n+l]=a[r+l];return o},write(t,e,n,_,r,a){if(e.buffer===HEAP8.buffer&&(a=!1),!_)return 0;var o=t.node;if(o.timestamp=Date.now(),e.subarray&&(!o.contents||o.contents.subarray)){if(a)return o.contents=e.subarray(n,n+_),o.usedBytes=_,_;if(o.usedBytes===0&&r===0)return o.contents=e.slice(n,n+_),o.usedBytes=_,_;if(r+_<=o.usedBytes)return o.contents.set(e.subarray(n,n+_),r),_}if(MEMFS.expandFileStorage(o,r+_),o.contents.subarray&&e.subarray)o.contents.set(e.subarray(n,n+_),r);else for(var l=0;l<_;l++)o.contents[r+l]=e[n+l];return o.usedBytes=Math.max(o.usedBytes,r+_),_},llseek(t,e,n){var _=e;if(n===1?_+=t.position:n===2&&FS.isFile(t.node.mode)&&(_+=t.node.usedBytes),_<0)throw new FS.ErrnoError(28);return _},allocate(t,e,n){MEMFS.expandFileStorage(t.node,e+n),t.node.usedBytes=Math.max(t.node.usedBytes,e+n)},mmap(t,e,n,_,r){if(!FS.isFile(t.node.mode))throw new FS.ErrnoError(43);var a,o,l=t.node.contents;if(!(r&2)&&l.buffer===HEAP8.buffer)o=!1,a=l.byteOffset;else{if((n>0||n+e<l.length)&&(l.subarray?l=l.subarray(n,n+e):l=Array.prototype.slice.call(l,n,n+e)),o=!0,a=mmapAlloc(e),!a)throw new FS.ErrnoError(48);HEAP8.set(l,a)}return{ptr:a,allocated:o}},msync(t,e,n,_,r){return MEMFS.stream_ops.write(t,e,0,_,n,!1),0}}};Module.MEMFS=MEMFS;var FS_createDataFile=(t,e,n,_,r,a)=>FS.createDataFile(t,e,n,_,r,a);Module.FS_createDataFile=FS_createDataFile;var FS_handledByPreloadPlugin=(t,e,n,_)=>{typeof Browser<"u"&&Browser.init();var r=!1;return preloadPlugins.forEach(a=>{r||a.canHandle(e)&&(a.handle(t,e,n,_),r=!0)}),r};Module.FS_handledByPreloadPlugin=FS_handledByPreloadPlugin;var FS_createPreloadedFile=(t,e,n,_,r,a,o,l,p,c)=>{var I=e?PATH_FS.resolve(PATH.join2(t,e)):t,A=`cp ${I}`;function m(E){function f(R){c&&c(),l||FS_createDataFile(t,e,R,_,r,p),a&&a(),removeRunDependency(A)}FS_handledByPreloadPlugin(E,I,f,()=>{o&&o(),removeRunDependency(A)})||f(E)}addRunDependency(A),typeof n=="string"?asyncLoad(n,E=>m(E),o):m(n)};Module.FS_createPreloadedFile=FS_createPreloadedFile;var FS_modeStringToFlags=t=>{var e={r:0,"r+":2,w:577,"w+":578,a:1089,"a+":1090},n=e[t];if(typeof n>"u")throw new Error(`Unknown file open mode: ${t}`);return n};Module.FS_modeStringToFlags=FS_modeStringToFlags;var FS_getMode=(t,e)=>{var n=0;return t&&(n|=365),e&&(n|=146),n};Module.FS_getMode=FS_getMode;var IDBFS={dbs:{},indexedDB:()=>{if(typeof indexedDB<"u")return indexedDB;var t=null;return typeof window=="object"&&(t=window.indexedDB||window.mozIndexedDB||window.webkitIndexedDB||window.msIndexedDB),assert(t,"IDBFS used, but indexedDB not supported"),t},DB_VERSION:21,DB_STORE_NAME:"FILE_DATA",mount:function(t){return MEMFS.mount.apply(null,arguments)},syncfs:(t,e,n)=>{IDBFS.getLocalSet(t,(_,r)=>{if(_)return n(_);IDBFS.getRemoteSet(t,(a,o)=>{if(a)return n(a);var l=e?o:r,p=e?r:o;IDBFS.reconcile(l,p,n)})})},quit:()=>{Object.values(IDBFS.dbs).forEach(t=>t.close()),IDBFS.dbs={}},getDB:(t,e)=>{var n=IDBFS.dbs[t];if(n)return e(null,n);var _;try{_=IDBFS.indexedDB().open(t,IDBFS.DB_VERSION)}catch(r){return e(r)}if(!_)return e("Unable to connect to IndexedDB");_.onupgradeneeded=r=>{var a=r.target.result,o=r.target.transaction,l;a.objectStoreNames.contains(IDBFS.DB_STORE_NAME)?l=o.objectStore(IDBFS.DB_STORE_NAME):l=a.createObjectStore(IDBFS.DB_STORE_NAME),l.indexNames.contains("timestamp")||l.createIndex("timestamp","timestamp",{unique:!1})},_.onsuccess=()=>{n=_.result,IDBFS.dbs[t]=n,e(null,n)},_.onerror=r=>{e(r.target.error),r.preventDefault()}},getLocalSet:(t,e)=>{var n={};function _(p){return p!=="."&&p!==".."}function r(p){return c=>PATH.join2(p,c)}for(var a=FS.readdir(t.mountpoint).filter(_).map(r(t.mountpoint));a.length;){var o=a.pop(),l;try{l=FS.stat(o)}catch(p){return e(p)}FS.isDir(l.mode)&&a.push.apply(a,FS.readdir(o).filter(_).map(r(o))),n[o]={timestamp:l.mtime}}return e(null,{type:"local",entries:n})},getRemoteSet:(t,e)=>{var n={};IDBFS.getDB(t.mountpoint,(_,r)=>{if(_)return e(_);try{var a=r.transaction([IDBFS.DB_STORE_NAME],"readonly");a.onerror=p=>{e(p.target.error),p.preventDefault()};var o=a.objectStore(IDBFS.DB_STORE_NAME),l=o.index("timestamp");l.openKeyCursor().onsuccess=p=>{var c=p.target.result;if(!c)return e(null,{type:"remote",db:r,entries:n});n[c.primaryKey]={timestamp:c.key},c.continue()}}catch(p){return e(p)}})},loadLocalEntry:(t,e)=>{var n,_;try{var r=FS.lookupPath(t);_=r.node,n=FS.stat(t)}catch(a){return e(a)}return FS.isDir(n.mode)?e(null,{timestamp:n.mtime,mode:n.mode}):FS.isFile(n.mode)?(_.contents=MEMFS.getFileDataAsTypedArray(_),e(null,{timestamp:n.mtime,mode:n.mode,contents:_.contents})):e(new Error("node type not supported"))},storeLocalEntry:(t,e,n)=>{try{if(FS.isDir(e.mode))FS.mkdirTree(t,e.mode);else if(FS.isFile(e.mode))FS.writeFile(t,e.contents,{canOwn:!0});else return n(new Error("node type not supported"));FS.chmod(t,e.mode),FS.utime(t,e.timestamp,e.timestamp)}catch(_){return n(_)}n(null)},removeLocalEntry:(t,e)=>{try{var n=FS.stat(t);FS.isDir(n.mode)?FS.rmdir(t):FS.isFile(n.mode)&&FS.unlink(t)}catch(_){return e(_)}e(null)},loadRemoteEntry:(t,e,n)=>{var _=t.get(e);_.onsuccess=r=>{n(null,r.target.result)},_.onerror=r=>{n(r.target.error),r.preventDefault()}},storeRemoteEntry:(t,e,n,_)=>{try{var r=t.put(n,e)}catch(a){_(a);return}r.onsuccess=()=>{_(null)},r.onerror=a=>{_(a.target.error),a.preventDefault()}},removeRemoteEntry:(t,e,n)=>{var _=t.delete(e);_.onsuccess=()=>{n(null)},_.onerror=r=>{n(r.target.error),r.preventDefault()}},reconcile:(t,e,n)=>{var _=0,r=[];Object.keys(t.entries).forEach(function(A){var m=t.entries[A],E=e.entries[A];(!E||m.timestamp.getTime()!=E.timestamp.getTime())&&(r.push(A),_++)});var a=[];if(Object.keys(e.entries).forEach(function(A){t.entries[A]||(a.push(A),_++)}),!_)return n(null);var o=!1,l=t.type==="remote"?t.db:e.db,p=l.transaction([IDBFS.DB_STORE_NAME],"readwrite"),c=p.objectStore(IDBFS.DB_STORE_NAME);function I(A){if(A&&!o)return o=!0,n(A)}p.onerror=A=>{I(this.error),A.preventDefault()},p.oncomplete=A=>{o||n(null)},r.sort().forEach(A=>{e.type==="local"?IDBFS.loadRemoteEntry(c,A,(m,E)=>{if(m)return I(m);IDBFS.storeLocalEntry(A,E,I)}):IDBFS.loadLocalEntry(A,(m,E)=>{if(m)return I(m);IDBFS.storeRemoteEntry(c,A,E,I)})}),a.sort().reverse().forEach(A=>{e.type==="local"?IDBFS.removeLocalEntry(A,I):IDBFS.removeRemoteEntry(c,A,I)})}};Module.IDBFS=IDBFS;var ERRNO_CODES={};Module.ERRNO_CODES=ERRNO_CODES;var NODEFS={isWindows:!1,staticInit(){NODEFS.isWindows=!!process.platform.match(/^win/);var t=process.binding("constants");t.fs&&(t=t.fs),NODEFS.flagsForNodeMap={1024:t.O_APPEND,64:t.O_CREAT,128:t.O_EXCL,256:t.O_NOCTTY,0:t.O_RDONLY,2:t.O_RDWR,4096:t.O_SYNC,512:t.O_TRUNC,1:t.O_WRONLY,131072:t.O_NOFOLLOW}},convertNodeCode(t){var e=t.code;return ERRNO_CODES[e]},mount(t){return NODEFS.createNode(null,"/",NODEFS.getMode(t.opts.root),0)},createNode(t,e,n,_){if(!FS.isDir(n)&&!FS.isFile(n)&&!FS.isLink(n))throw new FS.ErrnoError(28);var r=FS.createNode(t,e,n);return r.node_ops=NODEFS.node_ops,r.stream_ops=NODEFS.stream_ops,r},getMode(t){var e;try{e=fs.lstatSync(t),NODEFS.isWindows&&(e.mode=e.mode|(e.mode&292)>>2)}catch(n){throw n.code?new FS.ErrnoError(NODEFS.convertNodeCode(n)):n}return e.mode},realPath(t){for(var e=[];t.parent!==t;)e.push(t.name),t=t.parent;return e.push(t.mount.opts.root),e.reverse(),PATH.join.apply(null,e)},flagsForNode(t){t&=-2097153,t&=-2049,t&=-32769,t&=-524289,t&=-65537;var e=0;for(var n in NODEFS.flagsForNodeMap)t&n&&(e|=NODEFS.flagsForNodeMap[n],t^=n);if(t)throw new FS.ErrnoError(28);return e},node_ops:{getattr(t){var e=NODEFS.realPath(t),n;try{n=fs.lstatSync(e)}catch(_){throw _.code?new FS.ErrnoError(NODEFS.convertNodeCode(_)):_}return NODEFS.isWindows&&!n.blksize&&(n.blksize=4096),NODEFS.isWindows&&!n.blocks&&(n.blocks=(n.size+n.blksize-1)/n.blksize|0),{dev:n.dev,ino:n.ino,mode:n.mode,nlink:n.nlink,uid:n.uid,gid:n.gid,rdev:n.rdev,size:n.size,atime:n.atime,mtime:n.mtime,ctime:n.ctime,blksize:n.blksize,blocks:n.blocks}},setattr(t,e){var n=NODEFS.realPath(t);try{if(e.mode!==void 0&&(fs.chmodSync(n,e.mode),t.mode=e.mode),e.timestamp!==void 0){var _=new Date(e.timestamp);fs.utimesSync(n,_,_)}e.size!==void 0&&fs.truncateSync(n,e.size)}catch(r){throw r.code?new FS.ErrnoError(NODEFS.convertNodeCode(r)):r}},lookup(t,e){var n=PATH.join2(NODEFS.realPath(t),e),_=NODEFS.getMode(n);return NODEFS.createNode(t,e,_)},mknod(t,e,n,_){var r=NODEFS.createNode(t,e,n,_),a=NODEFS.realPath(r);try{FS.isDir(r.mode)?fs.mkdirSync(a,r.mode):fs.writeFileSync(a,"",{mode:r.mode})}catch(o){throw o.code?new FS.ErrnoError(NODEFS.convertNodeCode(o)):o}return r},rename(t,e,n){var _=NODEFS.realPath(t),r=PATH.join2(NODEFS.realPath(e),n);try{fs.renameSync(_,r)}catch(a){throw a.code?new FS.ErrnoError(NODEFS.convertNodeCode(a)):a}t.name=n},unlink(t,e){var n=PATH.join2(NODEFS.realPath(t),e);try{fs.unlinkSync(n)}catch(_){throw _.code?new FS.ErrnoError(NODEFS.convertNodeCode(_)):_}},rmdir(t,e){var n=PATH.join2(NODEFS.realPath(t),e);try{fs.rmdirSync(n)}catch(_){throw _.code?new FS.ErrnoError(NODEFS.convertNodeCode(_)):_}},readdir(t){var e=NODEFS.realPath(t);try{return fs.readdirSync(e)}catch(n){throw n.code?new FS.ErrnoError(NODEFS.convertNodeCode(n)):n}},symlink(t,e,n){var _=PATH.join2(NODEFS.realPath(t),e);try{fs.symlinkSync(n,_)}catch(r){throw r.code?new FS.ErrnoError(NODEFS.convertNodeCode(r)):r}},readlink(t){var e=NODEFS.realPath(t);try{return e=fs.readlinkSync(e),e=nodePath.relative(nodePath.resolve(t.mount.opts.root),e),e}catch(n){throw n.code?n.code==="UNKNOWN"?new FS.ErrnoError(28):new FS.ErrnoError(NODEFS.convertNodeCode(n)):n}}},stream_ops:{open(t){var e=NODEFS.realPath(t.node);try{FS.isFile(t.node.mode)&&(t.nfd=fs.openSync(e,NODEFS.flagsForNode(t.flags)))}catch(n){throw n.code?new FS.ErrnoError(NODEFS.convertNodeCode(n)):n}},close(t){try{FS.isFile(t.node.mode)&&t.nfd&&fs.closeSync(t.nfd)}catch(e){throw e.code?new FS.ErrnoError(NODEFS.convertNodeCode(e)):e}},read(t,e,n,_,r){if(_===0)return 0;try{return fs.readSync(t.nfd,new Int8Array(e.buffer,n,_),{position:r})}catch(a){throw new FS.ErrnoError(NODEFS.convertNodeCode(a))}},write(t,e,n,_,r){try{return fs.writeSync(t.nfd,new Int8Array(e.buffer,n,_),{position:r})}catch(a){throw new FS.ErrnoError(NODEFS.convertNodeCode(a))}},llseek(t,e,n){var _=e;if(n===1)_+=t.position;else if(n===2&&FS.isFile(t.node.mode))try{var r=fs.fstatSync(t.nfd);_+=r.size}catch(a){throw new FS.ErrnoError(NODEFS.convertNodeCode(a))}if(_<0)throw new FS.ErrnoError(28);return _},mmap(t,e,n,_,r){if(!FS.isFile(t.node.mode))throw new FS.ErrnoError(43);var a=mmapAlloc(e);return NODEFS.stream_ops.read(t,HEAP8,a,e,n),{ptr:a,allocated:!0}},msync(t,e,n,_,r){return NODEFS.stream_ops.write(t,e,0,_,n,!1),0}}};Module.NODEFS=NODEFS;var WORKERFS={DIR_MODE:16895,FILE_MODE:33279,reader:null,mount(t){assert(ENVIRONMENT_IS_WORKER),WORKERFS.reader||(WORKERFS.reader=new FileReaderSync);var e=WORKERFS.createNode(null,"/",WORKERFS.DIR_MODE,0),n={};function _(a){for(var o=a.split("/"),l=e,p=0;p<o.length-1;p++){var c=o.slice(0,p+1).join("/");n[c]||(n[c]=WORKERFS.createNode(l,o[p],WORKERFS.DIR_MODE,0)),l=n[c]}return l}function r(a){var o=a.split("/");return o[o.length-1]}return Array.prototype.forEach.call(t.opts.files||[],function(a){WORKERFS.createNode(_(a.name),r(a.name),WORKERFS.FILE_MODE,0,a,a.lastModifiedDate)}),(t.opts.blobs||[]).forEach(function(a){WORKERFS.createNode(_(a.name),r(a.name),WORKERFS.FILE_MODE,0,a.data)}),(t.opts.packages||[]).forEach(function(a){a.metadata.files.forEach(function(o){var l=o.filename.substr(1);WORKERFS.createNode(_(l),r(l),WORKERFS.FILE_MODE,0,a.blob.slice(o.start,o.end))})}),e},createNode(t,e,n,_,r,a){var o=FS.createNode(t,e,n);return o.mode=n,o.node_ops=WORKERFS.node_ops,o.stream_ops=WORKERFS.stream_ops,o.timestamp=(a||new Date).getTime(),assert(WORKERFS.FILE_MODE!==WORKERFS.DIR_MODE),n===WORKERFS.FILE_MODE?(o.size=r.size,o.contents=r):(o.size=4096,o.contents={}),t&&(t.contents[e]=o),o},node_ops:{getattr(t){return{dev:1,ino:t.id,mode:t.mode,nlink:1,uid:0,gid:0,rdev:0,size:t.size,atime:new Date(t.timestamp),mtime:new Date(t.timestamp),ctime:new Date(t.timestamp),blksize:4096,blocks:Math.ceil(t.size/4096)}},setattr(t,e){e.mode!==void 0&&(t.mode=e.mode),e.timestamp!==void 0&&(t.timestamp=e.timestamp)},lookup(t,e){throw new FS.ErrnoError(44)},mknod(t,e,n,_){throw new FS.ErrnoError(63)},rename(t,e,n){throw new FS.ErrnoError(63)},unlink(t,e){throw new FS.ErrnoError(63)},rmdir(t,e){throw new FS.ErrnoError(63)},readdir(t){var e=[".",".."];for(var n in t.contents)t.contents.hasOwnProperty(n)&&e.push(n);return e},symlink(t,e,n){throw new FS.ErrnoError(63)}},stream_ops:{read(t,e,n,_,r){if(r>=t.node.size)return 0;var a=t.node.contents.slice(r,r+_),o=WORKERFS.reader.readAsArrayBuffer(a);return e.set(new Uint8Array(o),n),a.size},write(t,e,n,_,r){throw new FS.ErrnoError(29)},llseek(t,e,n){var _=e;if(n===1?_+=t.position:n===2&&FS.isFile(t.node.mode)&&(_+=t.node.size),_<0)throw new FS.ErrnoError(28);return _}}};Module.WORKERFS=WORKERFS;var PROXYFS={mount(t){return PROXYFS.createNode(null,"/",t.opts.fs.lstat(t.opts.root).mode,0)},createNode(t,e,n,_){if(!FS.isDir(n)&&!FS.isFile(n)&&!FS.isLink(n))throw new FS.ErrnoError(ERRNO_CODES.EINVAL);var r=FS.createNode(t,e,n);return r.node_ops=PROXYFS.node_ops,r.stream_ops=PROXYFS.stream_ops,r},realPath(t){for(var e=[];t.parent!==t;)e.push(t.name),t=t.parent;return e.push(t.mount.opts.root),e.reverse(),PATH.join.apply(null,e)},node_ops:{getattr(t){var e=PROXYFS.realPath(t),n;try{n=t.mount.opts.fs.lstat(e)}catch(_){throw _.code?new FS.ErrnoError(ERRNO_CODES[_.code]):_}return{dev:n.dev,ino:n.ino,mode:n.mode,nlink:n.nlink,uid:n.uid,gid:n.gid,rdev:n.rdev,size:n.size,atime:n.atime,mtime:n.mtime,ctime:n.ctime,blksize:n.blksize,blocks:n.blocks}},setattr(t,e){var n=PROXYFS.realPath(t);try{if(e.mode!==void 0&&(t.mount.opts.fs.chmod(n,e.mode),t.mode=e.mode),e.timestamp!==void 0){var _=new Date(e.timestamp);t.mount.opts.fs.utime(n,_,_)}e.size!==void 0&&t.mount.opts.fs.truncate(n,e.size)}catch(r){throw r.code?new FS.ErrnoError(ERRNO_CODES[r.code]):r}},lookup(t,e){try{var n=PATH.join2(PROXYFS.realPath(t),e),_=t.mount.opts.fs.lstat(n).mode,r=PROXYFS.createNode(t,e,_);return r}catch(a){throw a.code?new FS.ErrnoError(ERRNO_CODES[a.code]):a}},mknod(t,e,n,_){var r=PROXYFS.createNode(t,e,n,_),a=PROXYFS.realPath(r);try{FS.isDir(r.mode)?r.mount.opts.fs.mkdir(a,r.mode):r.mount.opts.fs.writeFile(a,"",{mode:r.mode})}catch(o){throw o.code?new FS.ErrnoError(ERRNO_CODES[o.code]):o}return r},rename(t,e,n){var _=PROXYFS.realPath(t),r=PATH.join2(PROXYFS.realPath(e),n);try{t.mount.opts.fs.rename(_,r),t.name=n,t.parent=e}catch(a){throw a.code?new FS.ErrnoError(ERRNO_CODES[a.code]):a}},unlink(t,e){var n=PATH.join2(PROXYFS.realPath(t),e);try{t.mount.opts.fs.unlink(n)}catch(_){throw _.code?new FS.ErrnoError(ERRNO_CODES[_.code]):_}},rmdir(t,e){var n=PATH.join2(PROXYFS.realPath(t),e);try{t.mount.opts.fs.rmdir(n)}catch(_){throw _.code?new FS.ErrnoError(ERRNO_CODES[_.code]):_}},readdir(t){var e=PROXYFS.realPath(t);try{return t.mount.opts.fs.readdir(e)}catch(n){throw n.code?new FS.ErrnoError(ERRNO_CODES[n.code]):n}},symlink(t,e,n){var _=PATH.join2(PROXYFS.realPath(t),e);try{t.mount.opts.fs.symlink(n,_)}catch(r){throw r.code?new FS.ErrnoError(ERRNO_CODES[r.code]):r}},readlink(t){var e=PROXYFS.realPath(t);try{return t.mount.opts.fs.readlink(e)}catch(n){throw n.code?new FS.ErrnoError(ERRNO_CODES[n.code]):n}}},stream_ops:{open(t){var e=PROXYFS.realPath(t.node);try{t.nfd=t.node.mount.opts.fs.open(e,t.flags)}catch(n){throw n.code?new FS.ErrnoError(ERRNO_CODES[n.code]):n}},close(t){try{t.node.mount.opts.fs.close(t.nfd)}catch(e){throw e.code?new FS.ErrnoError(ERRNO_CODES[e.code]):e}},read(t,e,n,_,r){try{return t.node.mount.opts.fs.read(t.nfd,e,n,_,r)}catch(a){throw a.code?new FS.ErrnoError(ERRNO_CODES[a.code]):a}},write(t,e,n,_,r){try{return t.node.mount.opts.fs.write(t.nfd,e,n,_,r)}catch(a){throw a.code?new FS.ErrnoError(ERRNO_CODES[a.code]):a}},llseek(t,e,n){var _=e;if(n===1)_+=t.position;else if(n===2&&FS.isFile(t.node.mode))try{var r=t.node.node_ops.getattr(t.node);_+=r.size}catch(a){throw new FS.ErrnoError(ERRNO_CODES[a.code])}if(_<0)throw new FS.ErrnoError(ERRNO_CODES.EINVAL);return _}}};Module.PROXYFS=PROXYFS;var LZ4={DIR_MODE:16895,FILE_MODE:33279,CHUNK_SIZE:-1,codec:null,init(){LZ4.codec||(LZ4.codec=function(){var t=function(){var e={};e.uncompress=function(O,W,k,Z){k=k||0,Z=Z||O.length-k;for(var v=k,tt=Z,z=0;v<tt;){var et=O[v++],At=et>>4;if(At>0){for(var it=At+240;it===255;)it=O[v++],At+=it;for(var G=v+At;v<G;)W[z++]=O[v++];if(v===tt)return z}var rt=O[v++]|O[v++]<<8;if(rt===0)return z;if(rt>z)return-(v-2);for(var J=et&15,it=J+240;it===255;)it=O[v++],J+=it;for(var ot=z-rt,G=z+J+4;z<G;)W[z++]=W[ot++]}return z};var n=2113929216,_=4,r=16,a=_*8-r,o=1<<r,l=8,p=5,c=l+_,I=6,A=4,m=(1<<A)-1,E=8-A,f=(1<<E)-1,R=2654435761;assert(a===16);var h=new Int16Array(65536),w=new Int16Array(h.length);e.compressBound=function(O){return O>n?0:O+O/255+16|0},e.compress=function(O,W,k,Z){return h.set(w),g(O,W,0,k||0,Z||W.length)};function g(O,W,k,Z,v){var tt=Z,z=v-Z,et=0;if(O.length>=n)throw new Error("input too large");if(O.length>c){var At=e.compressBound(O.length);if(z<At)throw Error("output too small: "+z+" < "+At);for(var rt=1,J=(1<<I)+3,it=O.length-c;k+_<it;){var ot=O[k+1]<<8|O[k],G=O[k+3]<<8|O[k+2],ht=Math.imul(ot|G<<16,R)>>>a,Pt=h[ht]-1;if(h[ht]=k+1,Pt<0||k-Pt>>>16>0||(O[Pt+3]<<8|O[Pt+2])!=G||(O[Pt+1]<<8|O[Pt])!=ot){rt=J++>>I,k+=rt;continue}J=(1<<I)+3;var Lt=k-et,vt=k-Pt;k+=_,Pt+=_;for(var Ct=k;k<it&&O[k]==O[Pt];)k++,Pt++;Ct=k-Ct;var te=Ct<m?Ct:m;if(Lt>=f){W[tt++]=(f<<A)+te;for(var gt=Lt-f;gt>254;gt-=255)W[tt++]=255;W[tt++]=gt}else W[tt++]=(Lt<<A)+te;for(var jt=0;jt<Lt;jt++)W[tt++]=O[et+jt];if(W[tt++]=vt,W[tt++]=vt>>8,Ct>=m){for(Ct-=m;Ct>=255;)Ct-=255,W[tt++]=255;W[tt++]=Ct}et=k}}if(et==0)return 0;if(Lt=O.length-et,Lt>=f){W[tt++]=f<<A;for(var y=Lt-f;y>254;y-=255)W[tt++]=255;W[tt++]=y}else W[tt++]=Lt<<A;for(k=et;k<O.length;)W[tt++]=O[k++];return tt}return e.CHUNK_SIZE=2048,e.compressPackage=function(O,W){if(W)var k=new Uint8Array(e.CHUNK_SIZE);assert(O instanceof ArrayBuffer),O=new Uint8Array(O),console.log("compressing package of size "+O.length);for(var Z=[],v=[],tt=0,z=0;tt<O.length;){var et=O.subarray(tt,tt+e.CHUNK_SIZE);tt+=e.CHUNK_SIZE;var At=e.compressBound(et.length),rt=new Uint8Array(At),J=e.compress(et,rt);if(J>0){if(assert(J<=At),rt=rt.subarray(0,J),Z.push(rt),z+=J,v.push(1),W){var it=e.uncompress(rt,k);assert(it===et.length,[it,et.length]);for(var ot=0;ot<et.length;ot++)assert(et[ot]===k[ot])}}else assert(J===0),Z.push(et),z+=et.length,v.push(0)}O=null;var G={data:new Uint8Array(z+e.CHUNK_SIZE*2),cachedOffset:z,cachedIndexes:[-1,-1],cachedChunks:[null,null],offsets:[],sizes:[],successes:v};tt=0;for(var ot=0;ot<Z.length;ot++)G.data.set(Z[ot],tt),G.offsets[ot]=tt,G.sizes[ot]=Z[ot].length,tt+=Z[ot].length;return console.log("compressed package into "+[G.data.length]),assert(tt===z),G},assert(e.CHUNK_SIZE<32768),e}();return t}(),LZ4.CHUNK_SIZE=LZ4.codec.CHUNK_SIZE)},loadPackage(t,e){LZ4.init();var n=t.compressedData;n||(n=LZ4.codec.compressPackage(t.data)),assert(n.cachedIndexes.length===n.cachedChunks.length);for(var _=0;_<n.cachedIndexes.length;_++)n.cachedIndexes[_]=-1,n.cachedChunks[_]=n.data.subarray(n.cachedOffset+_*LZ4.CHUNK_SIZE,n.cachedOffset+(_+1)*LZ4.CHUNK_SIZE),assert(n.cachedChunks[_].length===LZ4.CHUNK_SIZE);t.metadata.files.forEach(r=>{var a=PATH.dirname(r.filename),o=PATH.basename(r.filename);FS.createPath("",a,!0,!0);var l=FS.analyzePath(a).object;LZ4.createNode(l,o,LZ4.FILE_MODE,0,{compressedData:n,start:r.start,end:r.end})}),e&&(Browser.init(),t.metadata.files.forEach(r=>{var a=!1,o=r.filename;preloadPlugins.forEach(l=>{if(!a&&l.canHandle(o)){var p="fp "+o;addRunDependency(p);var c=()=>removeRunDependency(p),I=FS.readFile(o);l.handle(I,o,c,c),a=!0}})}))},createNode(t,e,n,_,r,a){var o=FS.createNode(t,e,n);return o.mode=n,o.node_ops=LZ4.node_ops,o.stream_ops=LZ4.stream_ops,o.timestamp=(a||new Date).getTime(),assert(LZ4.FILE_MODE!==LZ4.DIR_MODE),n===LZ4.FILE_MODE?(o.size=r.end-r.start,o.contents=r):(o.size=4096,o.contents={}),t&&(t.contents[e]=o),o},node_ops:{getattr(t){return{dev:1,ino:t.id,mode:t.mode,nlink:1,uid:0,gid:0,rdev:0,size:t.size,atime:new Date(t.timestamp),mtime:new Date(t.timestamp),ctime:new Date(t.timestamp),blksize:4096,blocks:Math.ceil(t.size/4096)}},setattr(t,e){e.mode!==void 0&&(t.mode=e.mode),e.timestamp!==void 0&&(t.timestamp=e.timestamp)},lookup(t,e){throw new FS.ErrnoError(44)},mknod(t,e,n,_){throw new FS.ErrnoError(63)},rename(t,e,n){throw new FS.ErrnoError(63)},unlink(t,e){throw new FS.ErrnoError(63)},rmdir(t,e){throw new FS.ErrnoError(63)},readdir(t){throw new FS.ErrnoError(63)},symlink(t,e,n){throw new FS.ErrnoError(63)}},stream_ops:{read(t,e,n,_,r){if(_=Math.min(_,t.node.size-r),_<=0)return 0;for(var a=t.node.contents,o=a.compressedData,l=0;l<_;){var p=a.start+r+l,c=_-l,I=Math.floor(p/LZ4.CHUNK_SIZE),A=o.offsets[I],m=o.sizes[I],E;if(o.successes[I]){var f=o.cachedIndexes.indexOf(I);if(f>=0)E=o.cachedChunks[f];else{o.cachedIndexes.pop(),o.cachedIndexes.unshift(I),E=o.cachedChunks.pop(),o.cachedChunks.unshift(E),o.debug&&(out("decompressing chunk "+I),Module.decompressedChunks=(Module.decompressedChunks||0)+1);var R=o.data.subarray(A,A+m),h=LZ4.codec.uncompress(R,E);I<o.successes.length-1&&assert(h===LZ4.CHUNK_SIZE)}}else E=o.data.subarray(A,A+LZ4.CHUNK_SIZE);var w=p%LZ4.CHUNK_SIZE,g=Math.min(w+c,LZ4.CHUNK_SIZE);e.set(E.subarray(w,g),n+l);var O=g-w;l+=O}return l},write(t,e,n,_,r){throw new FS.ErrnoError(29)},llseek(t,e,n){var _=e;if(n===1?_+=t.position:n===2&&FS.isFile(t.node.mode)&&(_+=t.node.size),_<0)throw new FS.ErrnoError(28);return _}}};Module.LZ4=LZ4;var FS={root:null,mounts:[],devices:{},streams:[],nextInode:1,nameTable:null,currentPath:"/",initialized:!1,ignorePermissions:!0,ErrnoError:null,genericErrors:{},filesystems:null,syncFSRequests:0,lookupPath(t,e={}){if(t=PATH_FS.resolve(t),!t)return{path:"",node:null};var n={follow_mount:!0,recurse_count:0};if(e=Object.assign(n,e),e.recurse_count>8)throw new FS.ErrnoError(32);for(var _=t.split("/").filter(A=>!!A),r=FS.root,a="/",o=0;o<_.length;o++){var l=o===_.length-1;if(l&&e.parent)break;if(r=FS.lookupNode(r,_[o]),a=PATH.join2(a,_[o]),FS.isMountpoint(r)&&(!l||l&&e.follow_mount)&&(r=r.mounted.root),!l||e.follow)for(var p=0;FS.isLink(r.mode);){var c=FS.readlink(a);a=PATH_FS.resolve(PATH.dirname(a),c);var I=FS.lookupPath(a,{recurse_count:e.recurse_count+1});if(r=I.node,p++>40)throw new FS.ErrnoError(32)}}return{path:a,node:r}},getPath(t){for(var e;;){if(FS.isRoot(t)){var n=t.mount.mountpoint;return e?n[n.length-1]!=="/"?`${n}/${e}`:n+e:n}e=e?`${t.name}/${e}`:t.name,t=t.parent}},hashName(t,e){for(var n=0,_=0;_<e.length;_++)n=(n<<5)-n+e.charCodeAt(_)|0;return(t+n>>>0)%FS.nameTable.length},hashAddNode(t){var e=FS.hashName(t.parent.id,t.name);t.name_next=FS.nameTable[e],FS.nameTable[e]=t},hashRemoveNode(t){var e=FS.hashName(t.parent.id,t.name);if(FS.nameTable[e]===t)FS.nameTable[e]=t.name_next;else for(var n=FS.nameTable[e];n;){if(n.name_next===t){n.name_next=t.name_next;break}n=n.name_next}},lookupNode(t,e){var n=FS.mayLookup(t);if(n)throw new FS.ErrnoError(n,t);for(var _=FS.hashName(t.id,e),r=FS.nameTable[_];r;r=r.name_next){var a=r.name;if(r.parent.id===t.id&&a===e)return r}return FS.lookup(t,e)},createNode(t,e,n,_){var r=new FS.FSNode(t,e,n,_);return FS.hashAddNode(r),r},destroyNode(t){FS.hashRemoveNode(t)},isRoot(t){return t===t.parent},isMountpoint(t){return!!t.mounted},isFile(t){return(t&61440)===32768},isDir(t){return(t&61440)===16384},isLink(t){return(t&61440)===40960},isChrdev(t){return(t&61440)===8192},isBlkdev(t){return(t&61440)===24576},isFIFO(t){return(t&61440)===4096},isSocket(t){return(t&49152)===49152},flagsToPermissionString(t){var e=["r","w","rw"][t&3];return t&512&&(e+="w"),e},nodePermissions(t,e){return FS.ignorePermissions?0:e.includes("r")&&!(t.mode&292)||e.includes("w")&&!(t.mode&146)||e.includes("x")&&!(t.mode&73)?2:0},mayLookup(t){var e=FS.nodePermissions(t,"x");return e||(t.node_ops.lookup?0:2)},mayCreate(t,e){try{var n=FS.lookupNode(t,e);return 20}catch{}return FS.nodePermissions(t,"wx")},mayDelete(t,e,n){var _;try{_=FS.lookupNode(t,e)}catch(a){return a.errno}var r=FS.nodePermissions(t,"wx");if(r)return r;if(n){if(!FS.isDir(_.mode))return 54;if(FS.isRoot(_)||FS.getPath(_)===FS.cwd())return 10}else if(FS.isDir(_.mode))return 31;return 0},mayOpen(t,e){return t?FS.isLink(t.mode)?32:FS.isDir(t.mode)&&(FS.flagsToPermissionString(e)!=="r"||e&512)?31:FS.nodePermissions(t,FS.flagsToPermissionString(e)):44},MAX_OPEN_FDS:4096,nextfd(){for(var t=0;t<=FS.MAX_OPEN_FDS;t++)if(!FS.streams[t])return t;throw new FS.ErrnoError(33)},getStreamChecked(t){var e=FS.getStream(t);if(!e)throw new FS.ErrnoError(8);return e},getStream:t=>FS.streams[t],createStream(t,e=-1){return FS.FSStream||(FS.FSStream=function(){this.shared={}},FS.FSStream.prototype={},Object.defineProperties(FS.FSStream.prototype,{object:{get(){return this.node},set(n){this.node=n}},isRead:{get(){return(this.flags&2097155)!==1}},isWrite:{get(){return(this.flags&2097155)!==0}},isAppend:{get(){return this.flags&1024}},flags:{get(){return this.shared.flags},set(n){this.shared.flags=n}},position:{get(){return this.shared.position},set(n){this.shared.position=n}}})),t=Object.assign(new FS.FSStream,t),e==-1&&(e=FS.nextfd()),t.fd=e,FS.streams[e]=t,t},closeStream(t){FS.streams[t]=null},chrdev_stream_ops:{open(t){var e=FS.getDevice(t.node.rdev);t.stream_ops=e.stream_ops,t.stream_ops.open&&t.stream_ops.open(t)},llseek(){throw new FS.ErrnoError(70)}},major:t=>t>>8,minor:t=>t&255,makedev:(t,e)=>t<<8|e,registerDevice(t,e){FS.devices[t]={stream_ops:e}},getDevice:t=>FS.devices[t],getMounts(t){for(var e=[],n=[t];n.length;){var _=n.pop();e.push(_),n.push.apply(n,_.mounts)}return e},syncfs(t,e){typeof t=="function"&&(e=t,t=!1),FS.syncFSRequests++,FS.syncFSRequests>1&&err(`warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`);var n=FS.getMounts(FS.root.mount),_=0;function r(o){return FS.syncFSRequests--,e(o)}function a(o){if(o)return a.errored?void 0:(a.errored=!0,r(o));++_>=n.length&&r(null)}n.forEach(o=>{if(!o.type.syncfs)return a(null);o.type.syncfs(o,t,a)})},mount(t,e,n){var _=n==="/",r=!n,a;if(_&&FS.root)throw new FS.ErrnoError(10);if(!_&&!r){var o=FS.lookupPath(n,{follow_mount:!1});if(n=o.path,a=o.node,FS.isMountpoint(a))throw new FS.ErrnoError(10);if(!FS.isDir(a.mode))throw new FS.ErrnoError(54)}var l={type:t,opts:e,mountpoint:n,mounts:[]},p=t.mount(l);return p.mount=l,l.root=p,_?FS.root=p:a&&(a.mounted=l,a.mount&&a.mount.mounts.push(l)),p},unmount(t){var e=FS.lookupPath(t,{follow_mount:!1});if(!FS.isMountpoint(e.node))throw new FS.ErrnoError(28);var n=e.node,_=n.mounted,r=FS.getMounts(_);Object.keys(FS.nameTable).forEach(o=>{for(var l=FS.nameTable[o];l;){var p=l.name_next;r.includes(l.mount)&&FS.destroyNode(l),l=p}}),n.mounted=null;var a=n.mount.mounts.indexOf(_);n.mount.mounts.splice(a,1)},lookup(t,e){return t.node_ops.lookup(t,e)},mknod(t,e,n){var _=FS.lookupPath(t,{parent:!0}),r=_.node,a=PATH.basename(t);if(!a||a==="."||a==="..")throw new FS.ErrnoError(28);var o=FS.mayCreate(r,a);if(o)throw new FS.ErrnoError(o);if(!r.node_ops.mknod)throw new FS.ErrnoError(63);return r.node_ops.mknod(r,a,e,n)},create(t,e){return e=e!==void 0?e:438,e&=4095,e|=32768,FS.mknod(t,e,0)},mkdir(t,e){return e=e!==void 0?e:511,e&=1023,e|=16384,FS.mknod(t,e,0)},mkdirTree(t,e){for(var n=t.split("/"),_="",r=0;r<n.length;++r)if(n[r]){_+="/"+n[r];try{FS.mkdir(_,e)}catch(a){if(a.errno!=20)throw a}}},mkdev(t,e,n){return typeof n>"u"&&(n=e,e=438),e|=8192,FS.mknod(t,e,n)},symlink(t,e){if(!PATH_FS.resolve(t))throw new FS.ErrnoError(44);var n=FS.lookupPath(e,{parent:!0}),_=n.node;if(!_)throw new FS.ErrnoError(44);var r=PATH.basename(e),a=FS.mayCreate(_,r);if(a)throw new FS.ErrnoError(a);if(!_.node_ops.symlink)throw new FS.ErrnoError(63);return _.node_ops.symlink(_,r,t)},rename(t,e){var n=PATH.dirname(t),_=PATH.dirname(e),r=PATH.basename(t),a=PATH.basename(e),o,l,p;if(o=FS.lookupPath(t,{parent:!0}),l=o.node,o=FS.lookupPath(e,{parent:!0}),p=o.node,!l||!p)throw new FS.ErrnoError(44);if(l.mount!==p.mount)throw new FS.ErrnoError(75);var c=FS.lookupNode(l,r),I=PATH_FS.relative(t,_);if(I.charAt(0)!==".")throw new FS.ErrnoError(28);if(I=PATH_FS.relative(e,n),I.charAt(0)!==".")throw new FS.ErrnoError(55);var A;try{A=FS.lookupNode(p,a)}catch{}if(c!==A){var m=FS.isDir(c.mode),E=FS.mayDelete(l,r,m);if(E)throw new FS.ErrnoError(E);if(E=A?FS.mayDelete(p,a,m):FS.mayCreate(p,a),E)throw new FS.ErrnoError(E);if(!l.node_ops.rename)throw new FS.ErrnoError(63);if(FS.isMountpoint(c)||A&&FS.isMountpoint(A))throw new FS.ErrnoError(10);if(p!==l&&(E=FS.nodePermissions(l,"w"),E))throw new FS.ErrnoError(E);FS.hashRemoveNode(c);try{l.node_ops.rename(c,p,a)}catch(f){throw f}finally{FS.hashAddNode(c)}}},rmdir(t){var e=FS.lookupPath(t,{parent:!0}),n=e.node,_=PATH.basename(t),r=FS.lookupNode(n,_),a=FS.mayDelete(n,_,!0);if(a)throw new FS.ErrnoError(a);if(!n.node_ops.rmdir)throw new FS.ErrnoError(63);if(FS.isMountpoint(r))throw new FS.ErrnoError(10);n.node_ops.rmdir(n,_),FS.destroyNode(r)},readdir(t){var e=FS.lookupPath(t,{follow:!0}),n=e.node;if(!n.node_ops.readdir)throw new FS.ErrnoError(54);return n.node_ops.readdir(n)},unlink(t){var e=FS.lookupPath(t,{parent:!0}),n=e.node;if(!n)throw new FS.ErrnoError(44);var _=PATH.basename(t),r=FS.lookupNode(n,_),a=FS.mayDelete(n,_,!1);if(a)throw new FS.ErrnoError(a);if(!n.node_ops.unlink)throw new FS.ErrnoError(63);if(FS.isMountpoint(r))throw new FS.ErrnoError(10);n.node_ops.unlink(n,_),FS.destroyNode(r)},readlink(t){var e=FS.lookupPath(t),n=e.node;if(!n)throw new FS.ErrnoError(44);if(!n.node_ops.readlink)throw new FS.ErrnoError(28);return PATH_FS.resolve(FS.getPath(n.parent),n.node_ops.readlink(n))},stat(t,e){var n=FS.lookupPath(t,{follow:!e}),_=n.node;if(!_)throw new FS.ErrnoError(44);if(!_.node_ops.getattr)throw new FS.ErrnoError(63);return _.node_ops.getattr(_)},lstat(t){return FS.stat(t,!0)},chmod(t,e,n){var _;if(typeof t=="string"){var r=FS.lookupPath(t,{follow:!n});_=r.node}else _=t;if(!_.node_ops.setattr)throw new FS.ErrnoError(63);_.node_ops.setattr(_,{mode:e&4095|_.mode&-4096,timestamp:Date.now()})},lchmod(t,e){FS.chmod(t,e,!0)},fchmod(t,e){var n=FS.getStreamChecked(t);FS.chmod(n.node,e)},chown(t,e,n,_){var r;if(typeof t=="string"){var a=FS.lookupPath(t,{follow:!_});r=a.node}else r=t;if(!r.node_ops.setattr)throw new FS.ErrnoError(63);r.node_ops.setattr(r,{timestamp:Date.now()})},lchown(t,e,n){FS.chown(t,e,n,!0)},fchown(t,e,n){var _=FS.getStreamChecked(t);FS.chown(_.node,e,n)},truncate(t,e){if(e<0)throw new FS.ErrnoError(28);var n;if(typeof t=="string"){var _=FS.lookupPath(t,{follow:!0});n=_.node}else n=t;if(!n.node_ops.setattr)throw new FS.ErrnoError(63);if(FS.isDir(n.mode))throw new FS.ErrnoError(31);if(!FS.isFile(n.mode))throw new FS.ErrnoError(28);var r=FS.nodePermissions(n,"w");if(r)throw new FS.ErrnoError(r);n.node_ops.setattr(n,{size:e,timestamp:Date.now()})},ftruncate(t,e){var n=FS.getStreamChecked(t);if(!(n.flags&2097155))throw new FS.ErrnoError(28);FS.truncate(n.node,e)},utime(t,e,n){var _=FS.lookupPath(t,{follow:!0}),r=_.node;r.node_ops.setattr(r,{timestamp:Math.max(e,n)})},open(t,e,n){if(t==="")throw new FS.ErrnoError(44);e=typeof e=="string"?FS_modeStringToFlags(e):e,n=typeof n>"u"?438:n,e&64?n=n&4095|32768:n=0;var _;if(typeof t=="object")_=t;else{t=PATH.normalize(t);try{var r=FS.lookupPath(t,{follow:!(e&131072)});_=r.node}catch{}}var a=!1;if(e&64)if(_){if(e&128)throw new FS.ErrnoError(20)}else _=FS.mknod(t,n,0),a=!0;if(!_)throw new FS.ErrnoError(44);if(FS.isChrdev(_.mode)&&(e&=-513),e&65536&&!FS.isDir(_.mode))throw new FS.ErrnoError(54);if(!a){var o=FS.mayOpen(_,e);if(o)throw new FS.ErrnoError(o)}e&512&&!a&&FS.truncate(_,0),e&=-131713;var l=FS.createStream({node:_,path:FS.getPath(_),flags:e,seekable:!0,position:0,stream_ops:_.stream_ops,ungotten:[],error:!1});return l.stream_ops.open&&l.stream_ops.open(l),Module.logReadFiles&&!(e&1)&&(FS.readFiles||(FS.readFiles={}),t in FS.readFiles||(FS.readFiles[t]=1)),l},close(t){if(FS.isClosed(t))throw new FS.ErrnoError(8);t.getdents&&(t.getdents=null);try{t.stream_ops.close&&t.stream_ops.close(t)}catch(e){throw e}finally{FS.closeStream(t.fd)}t.fd=null},isClosed(t){return t.fd===null},llseek(t,e,n){if(FS.isClosed(t))throw new FS.ErrnoError(8);if(!t.seekable||!t.stream_ops.llseek)throw new FS.ErrnoError(70);if(n!=0&&n!=1&&n!=2)throw new FS.ErrnoError(28);return t.position=t.stream_ops.llseek(t,e,n),t.ungotten=[],t.position},read(t,e,n,_,r){if(_<0||r<0)throw new FS.ErrnoError(28);if(FS.isClosed(t))throw new FS.ErrnoError(8);if((t.flags&2097155)===1)throw new FS.ErrnoError(8);if(FS.isDir(t.node.mode))throw new FS.ErrnoError(31);if(!t.stream_ops.read)throw new FS.ErrnoError(28);var a=typeof r<"u";if(!a)r=t.position;else if(!t.seekable)throw new FS.ErrnoError(70);var o=t.stream_ops.read(t,e,n,_,r);return a||(t.position+=o),o},write(t,e,n,_,r,a){if(_<0||r<0)throw new FS.ErrnoError(28);if(FS.isClosed(t))throw new FS.ErrnoError(8);if(!(t.flags&2097155))throw new FS.ErrnoError(8);if(FS.isDir(t.node.mode))throw new FS.ErrnoError(31);if(!t.stream_ops.write)throw new FS.ErrnoError(28);t.seekable&&t.flags&1024&&FS.llseek(t,0,2);var o=typeof r<"u";if(!o)r=t.position;else if(!t.seekable)throw new FS.ErrnoError(70);var l=t.stream_ops.write(t,e,n,_,r,a);return o||(t.position+=l),l},allocate(t,e,n){if(FS.isClosed(t))throw new FS.ErrnoError(8);if(e<0||n<=0)throw new FS.ErrnoError(28);if(!(t.flags&2097155))throw new FS.ErrnoError(8);if(!FS.isFile(t.node.mode)&&!FS.isDir(t.node.mode))throw new FS.ErrnoError(43);if(!t.stream_ops.allocate)throw new FS.ErrnoError(138);t.stream_ops.allocate(t,e,n)},mmap(t,e,n,_,r){if(_&2&&!(r&2)&&(t.flags&2097155)!==2)throw new FS.ErrnoError(2);if((t.flags&2097155)===1)throw new FS.ErrnoError(2);if(!t.stream_ops.mmap)throw new FS.ErrnoError(43);return t.stream_ops.mmap(t,e,n,_,r)},msync(t,e,n,_,r){return t.stream_ops.msync?t.stream_ops.msync(t,e,n,_,r):0},munmap:t=>0,ioctl(t,e,n){if(!t.stream_ops.ioctl)throw new FS.ErrnoError(59);return t.stream_ops.ioctl(t,e,n)},readFile(t,e={}){if(e.flags=e.flags||0,e.encoding=e.encoding||"binary",e.encoding!=="utf8"&&e.encoding!=="binary")throw new Error(`Invalid encoding type "${e.encoding}"`);var n,_=FS.open(t,e.flags),r=FS.stat(t),a=r.size,o=new Uint8Array(a);return FS.read(_,o,0,a,0),e.encoding==="utf8"?n=UTF8ArrayToString(o,0):e.encoding==="binary"&&(n=o),FS.close(_),n},writeFile(t,e,n={}){n.flags=n.flags||577;var _=FS.open(t,n.flags,n.mode);if(typeof e=="string"){var r=new Uint8Array(lengthBytesUTF8(e)+1),a=stringToUTF8Array(e,r,0,r.length);FS.write(_,r,0,a,void 0,n.canOwn)}else if(ArrayBuffer.isView(e))FS.write(_,e,0,e.byteLength,void 0,n.canOwn);else throw new Error("Unsupported data type");FS.close(_)},cwd:()=>FS.currentPath,chdir(t){var e=FS.lookupPath(t,{follow:!0});if(e.node===null)throw new FS.ErrnoError(44);if(!FS.isDir(e.node.mode))throw new FS.ErrnoError(54);var n=FS.nodePermissions(e.node,"x");if(n)throw new FS.ErrnoError(n);FS.currentPath=e.path},createDefaultDirectories(){FS.mkdir("/tmp"),FS.mkdir("/home"),FS.mkdir("/home/web_user")},createDefaultDevices(){FS.mkdir("/dev"),FS.registerDevice(FS.makedev(1,3),{read:()=>0,write:(_,r,a,o,l)=>o}),FS.mkdev("/dev/null",FS.makedev(1,3)),TTY.register(FS.makedev(5,0),TTY.default_tty_ops),TTY.register(FS.makedev(6,0),TTY.default_tty1_ops),FS.mkdev("/dev/tty",FS.makedev(5,0)),FS.mkdev("/dev/tty1",FS.makedev(6,0));var t=new Uint8Array(1024),e=0,n=()=>(e===0&&(e=randomFill(t).byteLength),t[--e]);FS.createDevice("/dev","random",n),FS.createDevice("/dev","urandom",n),FS.mkdir("/dev/shm"),FS.mkdir("/dev/shm/tmp")},createSpecialDirectories(){FS.mkdir("/proc");var t=FS.mkdir("/proc/self");FS.mkdir("/proc/self/fd"),FS.mount({mount(){var e=FS.createNode(t,"fd",16895,73);return e.node_ops={lookup(n,_){var r=+_,a=FS.getStreamChecked(r),o={parent:null,mount:{mountpoint:"fake"},node_ops:{readlink:()=>a.path}};return o.parent=o,o}},e}},{},"/proc/self/fd")},createStandardStreams(){Module.stdin?FS.createDevice("/dev","stdin",Module.stdin):FS.symlink("/dev/tty","/dev/stdin"),Module.stdout?FS.createDevice("/dev","stdout",null,Module.stdout):FS.symlink("/dev/tty","/dev/stdout"),Module.stderr?FS.createDevice("/dev","stderr",null,Module.stderr):FS.symlink("/dev/tty1","/dev/stderr");var t=FS.open("/dev/stdin",0),e=FS.open("/dev/stdout",1),n=FS.open("/dev/stderr",1)},ensureErrnoError(){FS.ErrnoError||(FS.ErrnoError=function(e,n){this.name="ErrnoError",this.node=n,this.setErrno=function(_){this.errno=_},this.setErrno(e),this.message="FS error"},FS.ErrnoError.prototype=new Error,FS.ErrnoError.prototype.constructor=FS.ErrnoError,[44].forEach(t=>{FS.genericErrors[t]=new FS.ErrnoError(t),FS.genericErrors[t].stack="<generic error, no stack>"}))},staticInit(){FS.ensureErrnoError(),FS.nameTable=new Array(4096),FS.mount(MEMFS,{},"/"),FS.createDefaultDirectories(),FS.createDefaultDevices(),FS.createSpecialDirectories(),FS.filesystems={MEMFS,IDBFS,NODEFS,WORKERFS,PROXYFS}},init(t,e,n){FS.init.initialized=!0,FS.ensureErrnoError(),Module.stdin=t||Module.stdin,Module.stdout=e||Module.stdout,Module.stderr=n||Module.stderr,FS.createStandardStreams()},quit(){FS.init.initialized=!1,_fflush(0);for(var t=0;t<FS.streams.length;t++){var e=FS.streams[t];e&&FS.close(e)}},findObject(t,e){var n=FS.analyzePath(t,e);return n.exists?n.object:null},analyzePath(t,e){try{var n=FS.lookupPath(t,{follow:!e});t=n.path}catch{}var _={isRoot:!1,exists:!1,error:0,name:null,path:null,object:null,parentExists:!1,parentPath:null,parentObject:null};try{var n=FS.lookupPath(t,{parent:!0});_.parentExists=!0,_.parentPath=n.path,_.parentObject=n.node,_.name=PATH.basename(t),n=FS.lookupPath(t,{follow:!e}),_.exists=!0,_.path=n.path,_.object=n.node,_.name=n.node.name,_.isRoot=n.path==="/"}catch(r){_.error=r.errno}return _},createPath(t,e,n,_){t=typeof t=="string"?t:FS.getPath(t);for(var r=e.split("/").reverse();r.length;){var a=r.pop();if(a){var o=PATH.join2(t,a);try{FS.mkdir(o)}catch{}t=o}}return o},createFile(t,e,n,_,r){var a=PATH.join2(typeof t=="string"?t:FS.getPath(t),e),o=FS_getMode(_,r);return FS.create(a,o)},createDataFile(t,e,n,_,r,a){var o=e;t&&(t=typeof t=="string"?t:FS.getPath(t),o=e?PATH.join2(t,e):t);var l=FS_getMode(_,r),p=FS.create(o,l);if(n){if(typeof n=="string"){for(var c=new Array(n.length),I=0,A=n.length;I<A;++I)c[I]=n.charCodeAt(I);n=c}FS.chmod(p,l|146);var m=FS.open(p,577);FS.write(m,n,0,n.length,0,a),FS.close(m),FS.chmod(p,l)}return p},createDevice(t,e,n,_){var r=PATH.join2(typeof t=="string"?t:FS.getPath(t),e),a=FS_getMode(!!n,!!_);FS.createDevice.major||(FS.createDevice.major=64);var o=FS.makedev(FS.createDevice.major++,0);return FS.registerDevice(o,{open(l){l.seekable=!1},close(l){_&&_.buffer&&_.buffer.length&&_(10)},read(l,p,c,I,A){for(var m=0,E=0;E<I;E++){var f;try{f=n()}catch{throw new FS.ErrnoError(29)}if(f===void 0&&m===0)throw new FS.ErrnoError(6);if(f==null)break;m++,p[c+E]=f}return m&&(l.node.timestamp=Date.now()),m},write(l,p,c,I,A){for(var m=0;m<I;m++)try{_(p[c+m])}catch{throw new FS.ErrnoError(29)}return I&&(l.node.timestamp=Date.now()),m}}),FS.mkdev(r,a,o)},forceLoadFile(t){if(t.isDevice||t.isFolder||t.link||t.contents)return!0;if(typeof XMLHttpRequest<"u")throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");if(read_)try{t.contents=intArrayFromString(read_(t.url),!0),t.usedBytes=t.contents.length}catch{throw new FS.ErrnoError(29)}else throw new Error("Cannot load without read() or XMLHttpRequest.")},createLazyFile(t,e,n,_,r){function a(){this.lengthKnown=!1,this.chunks=[]}if(a.prototype.get=function(E){if(!(E>this.length-1||E<0)){var f=E%this.chunkSize,R=E/this.chunkSize|0;return this.getter(R)[f]}},a.prototype.setDataGetter=function(E){this.getter=E},a.prototype.cacheLength=function(){var E=new XMLHttpRequest;if(E.open("HEAD",n,!1),E.send(null),!(E.status>=200&&E.status<300||E.status===304))throw new Error("Couldn't load "+n+". Status: "+E.status);var f=Number(E.getResponseHeader("Content-length")),R,h=(R=E.getResponseHeader("Accept-Ranges"))&&R==="bytes",w=(R=E.getResponseHeader("Content-Encoding"))&&R==="gzip",g=1024*1024;h||(g=f);var O=(k,Z)=>{if(k>Z)throw new Error("invalid range ("+k+", "+Z+") or no bytes requested!");if(Z>f-1)throw new Error("only "+f+" bytes available! programmer error!");var v=new XMLHttpRequest;if(v.open("GET",n,!1),f!==g&&v.setRequestHeader("Range","bytes="+k+"-"+Z),v.responseType="arraybuffer",v.overrideMimeType&&v.overrideMimeType("text/plain; charset=x-user-defined"),v.send(null),!(v.status>=200&&v.status<300||v.status===304))throw new Error("Couldn't load "+n+". Status: "+v.status);return v.response!==void 0?new Uint8Array(v.response||[]):intArrayFromString(v.responseText||"",!0)},W=this;W.setDataGetter(k=>{var Z=k*g,v=(k+1)*g-1;if(v=Math.min(v,f-1),typeof W.chunks[k]>"u"&&(W.chunks[k]=O(Z,v)),typeof W.chunks[k]>"u")throw new Error("doXHR failed!");return W.chunks[k]}),(w||!f)&&(g=f=1,f=this.getter(0).length,g=f,out("LazyFiles on gzip forces download of the whole file when length is accessed")),this._length=f,this._chunkSize=g,this.lengthKnown=!0},typeof XMLHttpRequest<"u"){if(!ENVIRONMENT_IS_WORKER)throw"Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";var o=new a;Object.defineProperties(o,{length:{get:function(){return this.lengthKnown||this.cacheLength(),this._length}},chunkSize:{get:function(){return this.lengthKnown||this.cacheLength(),this._chunkSize}}});var l={isDevice:!1,contents:o}}else var l={isDevice:!1,url:n};var p=FS.createFile(t,e,l,_,r);l.contents?p.contents=l.contents:l.url&&(p.contents=null,p.url=l.url),Object.defineProperties(p,{usedBytes:{get:function(){return this.contents.length}}});var c={},I=Object.keys(p.stream_ops);I.forEach(m=>{var E=p.stream_ops[m];c[m]=function(){return FS.forceLoadFile(p),E.apply(null,arguments)}});function A(m,E,f,R,h){var w=m.node.contents;if(h>=w.length)return 0;var g=Math.min(w.length-h,R);if(w.slice)for(var O=0;O<g;O++)E[f+O]=w[h+O];else for(var O=0;O<g;O++)E[f+O]=w.get(h+O);return g}return c.read=(m,E,f,R,h)=>(FS.forceLoadFile(p),A(m,E,f,R,h)),c.mmap=(m,E,f,R,h)=>{FS.forceLoadFile(p);var w=mmapAlloc(E);if(!w)throw new FS.ErrnoError(48);return A(m,HEAP8,w,E,f),{ptr:w,allocated:!0}},p.stream_ops=c,p}};Module.FS=FS;var SYSCALLS={DEFAULT_POLLMASK:5,calculateAt(t,e,n){if(PATH.isAbs(e))return e;var _;if(t===-100)_=FS.cwd();else{var r=SYSCALLS.getStreamFromFD(t);_=r.path}if(e.length==0){if(!n)throw new FS.ErrnoError(44);return _}return PATH.join2(_,e)},doStat(t,e,n){try{var _=t(e)}catch(l){if(l&&l.node&&PATH.normalize(e)!==PATH.normalize(FS.getPath(l.node)))return-54;throw l}HEAP32[n>>2]=_.dev,HEAP32[n+4>>2]=_.mode,HEAPU32[n+8>>2]=_.nlink,HEAP32[n+12>>2]=_.uid,HEAP32[n+16>>2]=_.gid,HEAP32[n+20>>2]=_.rdev,HEAP64[n+24>>3]=BigInt(_.size),HEAP32[n+32>>2]=4096,HEAP32[n+36>>2]=_.blocks;var r=_.atime.getTime(),a=_.mtime.getTime(),o=_.ctime.getTime();return HEAP64[n+40>>3]=BigInt(Math.floor(r/1e3)),HEAPU32[n+48>>2]=r%1e3*1e3,HEAP64[n+56>>3]=BigInt(Math.floor(a/1e3)),HEAPU32[n+64>>2]=a%1e3*1e3,HEAP64[n+72>>3]=BigInt(Math.floor(o/1e3)),HEAPU32[n+80>>2]=o%1e3*1e3,HEAP64[n+88>>3]=BigInt(_.ino),0},doMsync(t,e,n,_,r){if(!FS.isFile(e.node.mode))throw new FS.ErrnoError(43);if(_&2)return 0;var a=HEAPU8.slice(t,t+n);FS.msync(e,a,r,n,_)},varargs:void 0,get(){var t=HEAP32[+SYSCALLS.varargs>>2];return SYSCALLS.varargs+=4,t},getp(){return SYSCALLS.get()},getStr(t){var e=UTF8ToString(t);return e},getStreamFromFD(t){var e=FS.getStreamChecked(t);return e}};Module.SYSCALLS=SYSCALLS;function ___syscall__newselect(t,e,n,_,r){try{for(var a=0,o=e?HEAP32[e>>2]:0,l=e?HEAP32[e+4>>2]:0,p=n?HEAP32[n>>2]:0,c=n?HEAP32[n+4>>2]:0,I=_?HEAP32[_>>2]:0,A=_?HEAP32[_+4>>2]:0,m=0,E=0,f=0,R=0,h=0,w=0,g=(e?HEAP32[e>>2]:0)|(n?HEAP32[n>>2]:0)|(_?HEAP32[_>>2]:0),O=(e?HEAP32[e+4>>2]:0)|(n?HEAP32[n+4>>2]:0)|(_?HEAP32[_+4>>2]:0),W=function(rt,J,it,ot){return rt<32?J&ot:it&ot},k=0;k<t;k++){var Z=1<<k%32;if(W(k,g,O,Z)){var v=SYSCALLS.getStreamFromFD(k),tt=SYSCALLS.DEFAULT_POLLMASK;if(v.stream_ops.poll){var z=-1;if(r){var et=e?HEAP32[r>>2]:0,At=e?HEAP32[r+8>>2]:0;z=(et+At/1e6)*1e3}tt=v.stream_ops.poll(v,z)}tt&1&&W(k,o,l,Z)&&(k<32?m=m|Z:E=E|Z,a++),tt&4&&W(k,p,c,Z)&&(k<32?f=f|Z:R=R|Z,a++),tt&2&&W(k,I,A,Z)&&(k<32?h=h|Z:w=w|Z,a++)}}return e&&(HEAP32[e>>2]=m,HEAP32[e+4>>2]=E),n&&(HEAP32[n>>2]=f,HEAP32[n+4>>2]=R),_&&(HEAP32[_>>2]=h,HEAP32[_+4>>2]=w),a}catch(rt){if(typeof FS>"u"||rt.name!=="ErrnoError")throw rt;return-rt.errno}}Module.___syscall__newselect=___syscall__newselect,___syscall__newselect.sig="iipppp";var SOCKFS={mount(t){return Module.websocket=Module.websocket&&typeof Module.websocket=="object"?Module.websocket:{},Module.websocket._callbacks={},Module.websocket.on=function(e,n){return typeof n=="function"&&(this._callbacks[e]=n),this},Module.websocket.emit=function(e,n){typeof this._callbacks[e]=="function"&&this._callbacks[e].call(this,n)},FS.createNode(null,"/",16895,0)},createSocket(t,e,n){e&=-526337;var _=e==1;if(_&&n&&n!=6)throw new FS.ErrnoError(66);var r={family:t,type:e,protocol:n,server:null,error:null,peers:{},pending:[],recv_queue:[],sock_ops:SOCKFS.websocket_sock_ops},a=SOCKFS.nextname(),o=FS.createNode(SOCKFS.root,a,49152,0);o.sock=r;var l=FS.createStream({path:a,node:o,flags:2,seekable:!1,stream_ops:SOCKFS.stream_ops});return r.stream=l,r},getSocket(t){var e=FS.getStream(t);return!e||!FS.isSocket(e.node.mode)?null:e.node.sock},stream_ops:{poll(t){var e=t.node.sock;return e.sock_ops.poll(e)},ioctl(t,e,n){var _=t.node.sock;return _.sock_ops.ioctl(_,e,n)},read(t,e,n,_,r){var a=t.node.sock,o=a.sock_ops.recvmsg(a,_);return o?(e.set(o.buffer,n),o.buffer.length):0},write(t,e,n,_,r){var a=t.node.sock;return a.sock_ops.sendmsg(a,e,n,_)},close(t){var e=t.node.sock;e.sock_ops.close(e)}},nextname(){return SOCKFS.nextname.current||(SOCKFS.nextname.current=0),"socket["+SOCKFS.nextname.current+++"]"},websocket_sock_ops:{createPeer(t,e,n){var _;if(typeof e=="object"&&(_=e,e=null,n=null),_)if(_._socket)e=_._socket.remoteAddress,n=_._socket.remotePort;else{var r=/ws[s]?:\/\/([^:]+):(\d+)/.exec(_.url);if(!r)throw new Error("WebSocket URL must be in the format ws(s)://address:port");e=r[1],n=parseInt(r[2],10)}else try{var a=Module.websocket&&typeof Module.websocket=="object",o="ws:#".replace("#","//");if(a&&typeof Module.websocket.url=="string"&&(o=Module.websocket.url),o==="ws://"||o==="wss://"){var l=e.split("/");o=o+l[0]+":"+n+"/"+l.slice(1).join("/")}var p="binary";a&&typeof Module.websocket.subprotocol=="string"&&(p=Module.websocket.subprotocol);var c=void 0;p!=="null"&&(p=p.replace(/^ +| +$/g,"").split(/ *, */),c=p),a&&Module.websocket.subprotocol===null&&(p="null",c=void 0);var I;ENVIRONMENT_IS_NODE?I=Ye():I=WebSocket,_=new I(o,c),_.binaryType="arraybuffer"}catch{throw new FS.ErrnoError(23)}var A={addr:e,port:n,socket:_,dgram_send_queue:[]};return SOCKFS.websocket_sock_ops.addPeer(t,A),SOCKFS.websocket_sock_ops.handlePeerEvents(t,A),t.type===2&&typeof t.sport<"u"&&A.dgram_send_queue.push(new Uint8Array([255,255,255,255,112,111,114,116,(t.sport&65280)>>8,t.sport&255])),A},getPeer(t,e,n){return t.peers[e+":"+n]},addPeer(t,e){t.peers[e.addr+":"+e.port]=e},removePeer(t,e){delete t.peers[e.addr+":"+e.port]},handlePeerEvents(t,e){var n=!0,_=function(){Module.websocket.emit("open",t.stream.fd);try{for(var a=e.dgram_send_queue.shift();a;)e.socket.send(a),a=e.dgram_send_queue.shift()}catch{e.socket.close()}};function r(a){if(typeof a=="string"){var o=new TextEncoder;a=o.encode(a)}else{if(assert(a.byteLength!==void 0),a.byteLength==0)return;a=new Uint8Array(a)}var l=n;if(n=!1,l&&a.length===10&&a[0]===255&&a[1]===255&&a[2]===255&&a[3]===255&&a[4]===112&&a[5]===111&&a[6]===114&&a[7]===116){var p=a[8]<<8|a[9];SOCKFS.websocket_sock_ops.removePeer(t,e),e.port=p,SOCKFS.websocket_sock_ops.addPeer(t,e);return}t.recv_queue.push({addr:e.addr,port:e.port,data:a}),Module.websocket.emit("message",t.stream.fd)}ENVIRONMENT_IS_NODE?(e.socket.on("open",_),e.socket.on("message",function(a,o){o&&r(new Uint8Array(a).buffer)}),e.socket.on("close",function(){Module.websocket.emit("close",t.stream.fd)}),e.socket.on("error",function(a){t.error=14,Module.websocket.emit("error",[t.stream.fd,t.error,"ECONNREFUSED: Connection refused"])})):(e.socket.onopen=_,e.socket.onclose=function(){Module.websocket.emit("close",t.stream.fd)},e.socket.onmessage=function(o){r(o.data)},e.socket.onerror=function(a){t.error=14,Module.websocket.emit("error",[t.stream.fd,t.error,"ECONNREFUSED: Connection refused"])})},poll(t){if(t.type===1&&t.server)return t.pending.length?65:0;var e=0,n=t.type===1?SOCKFS.websocket_sock_ops.getPeer(t,t.daddr,t.dport):null;return(t.recv_queue.length||!n||n&&n.socket.readyState===n.socket.CLOSING||n&&n.socket.readyState===n.socket.CLOSED)&&(e|=65),(!n||n&&n.socket.readyState===n.socket.OPEN)&&(e|=4),(n&&n.socket.readyState===n.socket.CLOSING||n&&n.socket.readyState===n.socket.CLOSED)&&(e|=16),e},ioctl(t,e,n){switch(e){case 21531:var _=0;return t.recv_queue.length&&(_=t.recv_queue[0].data.length),HEAP32[n>>2]=_,0;default:return 28}},close(t){if(t.server){try{t.server.close()}catch{}t.server=null}for(var e=Object.keys(t.peers),n=0;n<e.length;n++){var _=t.peers[e[n]];try{_.socket.close()}catch{}SOCKFS.websocket_sock_ops.removePeer(t,_)}return 0},bind(t,e,n){if(typeof t.saddr<"u"||typeof t.sport<"u")throw new FS.ErrnoError(28);if(t.saddr=e,t.sport=n,t.type===2){t.server&&(t.server.close(),t.server=null);try{t.sock_ops.listen(t,0)}catch(_){if(_.name!=="ErrnoError"||_.errno!==138)throw _}}},connect(t,e,n){if(t.server)throw new FS.ErrnoError(138);if(typeof t.daddr<"u"&&typeof t.dport<"u"){var _=SOCKFS.websocket_sock_ops.getPeer(t,t.daddr,t.dport);if(_)throw _.socket.readyState===_.socket.CONNECTING?new FS.ErrnoError(7):new FS.ErrnoError(30)}var r=SOCKFS.websocket_sock_ops.createPeer(t,e,n);throw t.daddr=r.addr,t.dport=r.port,new FS.ErrnoError(26)},listen(t,e){if(!ENVIRONMENT_IS_NODE)throw new FS.ErrnoError(138);if(t.server)throw new FS.ErrnoError(28);var n=Ye().Server,_=t.saddr;t.server=new n({host:_,port:t.sport}),Module.websocket.emit("listen",t.stream.fd),t.server.on("connection",function(r){if(t.type===1){var a=SOCKFS.createSocket(t.family,t.type,t.protocol),o=SOCKFS.websocket_sock_ops.createPeer(a,r);a.daddr=o.addr,a.dport=o.port,t.pending.push(a),Module.websocket.emit("connection",a.stream.fd)}else SOCKFS.websocket_sock_ops.createPeer(t,r),Module.websocket.emit("connection",t.stream.fd)}),t.server.on("close",function(){Module.websocket.emit("close",t.stream.fd),t.server=null}),t.server.on("error",function(r){t.error=23,Module.websocket.emit("error",[t.stream.fd,t.error,"EHOSTUNREACH: Host is unreachable"])})},accept(t){if(!t.server||!t.pending.length)throw new FS.ErrnoError(28);var e=t.pending.shift();return e.stream.flags=t.stream.flags,e},getname(t,e){var n,_;if(e){if(t.daddr===void 0||t.dport===void 0)throw new FS.ErrnoError(53);n=t.daddr,_=t.dport}else n=t.saddr||0,_=t.sport||0;return{addr:n,port:_}},sendmsg(t,e,n,_,r,a){if(t.type===2){if((r===void 0||a===void 0)&&(r=t.daddr,a=t.dport),r===void 0||a===void 0)throw new FS.ErrnoError(17)}else r=t.daddr,a=t.dport;var o=SOCKFS.websocket_sock_ops.getPeer(t,r,a);if(t.type===1){if(!o||o.socket.readyState===o.socket.CLOSING||o.socket.readyState===o.socket.CLOSED)throw new FS.ErrnoError(53);if(o.socket.readyState===o.socket.CONNECTING)throw new FS.ErrnoError(6)}ArrayBuffer.isView(e)&&(n+=e.byteOffset,e=e.buffer);var l;if(l=e.slice(n,n+_),t.type===2&&(!o||o.socket.readyState!==o.socket.OPEN))return(!o||o.socket.readyState===o.socket.CLOSING||o.socket.readyState===o.socket.CLOSED)&&(o=SOCKFS.websocket_sock_ops.createPeer(t,r,a)),o.dgram_send_queue.push(l),_;try{return o.socket.send(l),_}catch{throw new FS.ErrnoError(28)}},recvmsg(t,e){if(t.type===1&&t.server)throw new FS.ErrnoError(53);var n=t.recv_queue.shift();if(!n){if(t.type===1){var _=SOCKFS.websocket_sock_ops.getPeer(t,t.daddr,t.dport);if(!_)throw new FS.ErrnoError(53);if(_.socket.readyState===_.socket.CLOSING||_.socket.readyState===_.socket.CLOSED)return null;throw new FS.ErrnoError(6)}throw new FS.ErrnoError(6)}var r=n.data.byteLength||n.data.length,a=n.data.byteOffset||0,o=n.data.buffer||n.data,l=Math.min(e,r),p={buffer:new Uint8Array(o,a,l),addr:n.addr,port:n.port};if(t.type===1&&l<r){var c=r-l;n.data=new Uint8Array(o,a+l,c),t.recv_queue.unshift(n)}return p}}};Module.SOCKFS=SOCKFS;var getSocketFromFD=t=>{var e=SOCKFS.getSocket(t);if(!e)throw new FS.ErrnoError(8);return e};Module.getSocketFromFD=getSocketFromFD;var setErrNo=t=>(HEAP32[___errno_location()>>2]=t,t);Module.setErrNo=setErrNo;var Sockets={BUFFER_SIZE:10240,MAX_BUFFER_SIZE:10485760,nextFd:1,fds:{},nextport:1,maxport:65535,peer:null,connections:{},portmap:{},localAddr:4261412874,addrPool:[33554442,50331658,67108874,83886090,100663306,117440522,134217738,150994954,167772170,184549386,201326602,218103818,234881034]};Module.Sockets=Sockets;var inetPton4=t=>{for(var e=t.split("."),n=0;n<4;n++){var _=Number(e[n]);if(isNaN(_))return null;e[n]=_}return(e[0]|e[1]<<8|e[2]<<16|e[3]<<24)>>>0};Module.inetPton4=inetPton4;var jstoi_q=t=>parseInt(t);Module.jstoi_q=jstoi_q;var inetPton6=t=>{var e,n,_,r,a,o=/^((?=.*::)(?!.*::.+::)(::)?([\dA-F]{1,4}:(:|\b)|){5}|([\dA-F]{1,4}:){6})((([\dA-F]{1,4}((?!\3)::|:\b|$))|(?!\2\3)){2}|(((2[0-4]|1\d|[1-9])?\d|25[0-5])\.?\b){4})$/i,l=[];if(!o.test(t))return null;if(t==="::")return[0,0,0,0,0,0,0,0];for(t.startsWith("::")?t=t.replace("::","Z:"):t=t.replace("::",":Z:"),t.indexOf(".")>0?(t=t.replace(new RegExp("[.]","g"),":"),e=t.split(":"),e[e.length-4]=jstoi_q(e[e.length-4])+jstoi_q(e[e.length-3])*256,e[e.length-3]=jstoi_q(e[e.length-2])+jstoi_q(e[e.length-1])*256,e=e.slice(0,e.length-2)):e=t.split(":"),_=0,r=0,n=0;n<e.length;n++)if(typeof e[n]=="string")if(e[n]==="Z"){for(r=0;r<8-e.length+1;r++)l[n+r]=0;_=r-1}else l[n+_]=_htons(parseInt(e[n],16));else l[n+_]=e[n];return[l[1]<<16|l[0],l[3]<<16|l[2],l[5]<<16|l[4],l[7]<<16|l[6]]};Module.inetPton6=inetPton6;var writeSockaddr=(t,e,n,_,r)=>{switch(e){case 2:n=inetPton4(n),zeroMemory(t,16),r&&(HEAP32[r>>2]=16),HEAP16[t>>1]=e,HEAP32[t+4>>2]=n,HEAP16[t+2>>1]=_htons(_);break;case 10:n=inetPton6(n),zeroMemory(t,28),r&&(HEAP32[r>>2]=28),HEAP32[t>>2]=e,HEAP32[t+8>>2]=n[0],HEAP32[t+12>>2]=n[1],HEAP32[t+16>>2]=n[2],HEAP32[t+20>>2]=n[3],HEAP16[t+2>>1]=_htons(_);break;default:return 5}return 0};Module.writeSockaddr=writeSockaddr;var DNS={address_map:{id:1,addrs:{},names:{}},lookup_name(t){var e=inetPton4(t);if(e!==null||(e=inetPton6(t),e!==null))return t;var n;if(DNS.address_map.addrs[t])n=DNS.address_map.addrs[t];else{var _=DNS.address_map.id++;assert(_<65535,"exceeded max address mappings of 65535"),n="172.29."+(_&255)+"."+(_&65280),DNS.address_map.names[n]=t,DNS.address_map.addrs[t]=n}return n},lookup_addr(t){return DNS.address_map.names[t]?DNS.address_map.names[t]:null}};Module.DNS=DNS;function ___syscall_accept4(t,e,n,_,r,a){try{var o=getSocketFromFD(t),l=o.sock_ops.accept(o);if(e)var p=writeSockaddr(e,l.family,DNS.lookup_name(l.daddr),l.dport,n);return l.stream.fd}catch(c){if(typeof FS>"u"||c.name!=="ErrnoError")throw c;return-c.errno}}Module.___syscall_accept4=___syscall_accept4,___syscall_accept4.sig="iippiii";var inetNtop4=t=>(t&255)+"."+(t>>8&255)+"."+(t>>16&255)+"."+(t>>24&255);Module.inetNtop4=inetNtop4;var inetNtop6=t=>{var e="",n=0,_=0,r=0,a=0,o=0,l=0,p=[t[0]&65535,t[0]>>16,t[1]&65535,t[1]>>16,t[2]&65535,t[2]>>16,t[3]&65535,t[3]>>16],c=!0,I="";for(l=0;l<5;l++)if(p[l]!==0){c=!1;break}if(c){if(I=inetNtop4(p[6]|p[7]<<16),p[5]===-1)return e="::ffff:",e+=I,e;if(p[5]===0)return e="::",I==="0.0.0.0"&&(I=""),I==="0.0.0.1"&&(I="1"),e+=I,e}for(n=0;n<8;n++)p[n]===0&&(n-r>1&&(o=0),r=n,o++),o>_&&(_=o,a=n-_+1);for(n=0;n<8;n++){if(_>1&&p[n]===0&&n>=a&&n<a+_){n===a&&(e+=":",a===0&&(e+=":"));continue}e+=Number(_ntohs(p[n]&65535)).toString(16),e+=n<7?":":""}return e};Module.inetNtop6=inetNtop6;var readSockaddr=(t,e)=>{var n=HEAP16[t>>1],_=_ntohs(HEAPU16[t+2>>1]),r;switch(n){case 2:if(e!==16)return{errno:28};r=HEAP32[t+4>>2],r=inetNtop4(r);break;case 10:if(e!==28)return{errno:28};r=[HEAP32[t+8>>2],HEAP32[t+12>>2],HEAP32[t+16>>2],HEAP32[t+20>>2]],r=inetNtop6(r);break;default:return{errno:5}}return{family:n,addr:r,port:_}};Module.readSockaddr=readSockaddr;var getSocketAddress=(t,e,n)=>{if(n&&t===0)return null;var _=readSockaddr(t,e);if(_.errno)throw new FS.ErrnoError(_.errno);return _.addr=DNS.lookup_addr(_.addr)||_.addr,_};Module.getSocketAddress=getSocketAddress;function ___syscall_bind(t,e,n,_,r,a){try{var o=getSocketFromFD(t),l=getSocketAddress(e,n);return o.sock_ops.bind(o,l.addr,l.port),0}catch(p){if(typeof FS>"u"||p.name!=="ErrnoError")throw p;return-p.errno}}Module.___syscall_bind=___syscall_bind,___syscall_bind.sig="iippiii";function ___syscall_chdir(t){try{return t=SYSCALLS.getStr(t),FS.chdir(t),0}catch(e){if(typeof FS>"u"||e.name!=="ErrnoError")throw e;return-e.errno}}Module.___syscall_chdir=___syscall_chdir,___syscall_chdir.sig="ip";function ___syscall_chmod(t,e){try{return t=SYSCALLS.getStr(t),FS.chmod(t,e),0}catch(n){if(typeof FS>"u"||n.name!=="ErrnoError")throw n;return-n.errno}}Module.___syscall_chmod=___syscall_chmod,___syscall_chmod.sig="ipi";function ___syscall_connect(t,e,n,_,r,a){try{var o=getSocketFromFD(t),l=getSocketAddress(e,n);return o.sock_ops.connect(o,l.addr,l.port),0}catch(p){if(typeof FS>"u"||p.name!=="ErrnoError")throw p;return-p.errno}}Module.___syscall_connect=___syscall_connect,___syscall_connect.sig="iippiii";function ___syscall_dup(t){try{var e=SYSCALLS.getStreamFromFD(t);return FS.createStream(e).fd}catch(n){if(typeof FS>"u"||n.name!=="ErrnoError")throw n;return-n.errno}}Module.___syscall_dup=___syscall_dup,___syscall_dup.sig="ii";function ___syscall_dup3(t,e,n){try{var _=SYSCALLS.getStreamFromFD(t);if(_.fd===e)return-28;var r=FS.getStream(e);return r&&FS.close(r),FS.createStream(_,e).fd}catch(a){if(typeof FS>"u"||a.name!=="ErrnoError")throw a;return-a.errno}}Module.___syscall_dup3=___syscall_dup3,___syscall_dup3.sig="iiii";function ___syscall_faccessat(t,e,n,_){try{if(e=SYSCALLS.getStr(e),e=SYSCALLS.calculateAt(t,e),n&-8)return-28;var r=FS.lookupPath(e,{follow:!0}),a=r.node;if(!a)return-44;var o="";return n&4&&(o+="r"),n&2&&(o+="w"),n&1&&(o+="x"),o&&FS.nodePermissions(a,o)?-2:0}catch(l){if(typeof FS>"u"||l.name!=="ErrnoError")throw l;return-l.errno}}Module.___syscall_faccessat=___syscall_faccessat,___syscall_faccessat.sig="iipii";var ___syscall_fadvise64=(t,e,n,_)=>0;Module.___syscall_fadvise64=___syscall_fadvise64,___syscall_fadvise64.sig="iijji";var MAX_INT53=9007199254740992;Module.MAX_INT53=MAX_INT53;var MIN_INT53=-9007199254740992;Module.MIN_INT53=MIN_INT53;var bigintToI53Checked=t=>t<MIN_INT53||t>MAX_INT53?NaN:Number(t);Module.bigintToI53Checked=bigintToI53Checked;function ___syscall_fallocate(t,e,n,_){n=bigintToI53Checked(n),_=bigintToI53Checked(_);try{if(isNaN(n))return 61;var r=SYSCALLS.getStreamFromFD(t);return FS.allocate(r,n,_),0}catch(a){if(typeof FS>"u"||a.name!=="ErrnoError")throw a;return-a.errno}}Module.___syscall_fallocate=___syscall_fallocate,___syscall_fallocate.sig="iiijj";function ___syscall_fchdir(t){try{var e=SYSCALLS.getStreamFromFD(t);return FS.chdir(e.path),0}catch(n){if(typeof FS>"u"||n.name!=="ErrnoError")throw n;return-n.errno}}Module.___syscall_fchdir=___syscall_fchdir,___syscall_fchdir.sig="ii";function ___syscall_fchmod(t,e){try{return FS.fchmod(t,e),0}catch(n){if(typeof FS>"u"||n.name!=="ErrnoError")throw n;return-n.errno}}Module.___syscall_fchmod=___syscall_fchmod,___syscall_fchmod.sig="iii";function ___syscall_fchmodat(t,e,n,_){SYSCALLS.varargs=_;try{return e=SYSCALLS.getStr(e),e=SYSCALLS.calculateAt(t,e),FS.chmod(e,n),0}catch(r){if(typeof FS>"u"||r.name!=="ErrnoError")throw r;return-r.errno}}Module.___syscall_fchmodat=___syscall_fchmodat,___syscall_fchmodat.sig="iipip";function ___syscall_fchown32(t,e,n){try{return FS.fchown(t,e,n),0}catch(_){if(typeof FS>"u"||_.name!=="ErrnoError")throw _;return-_.errno}}Module.___syscall_fchown32=___syscall_fchown32,___syscall_fchown32.sig="iiii";function ___syscall_fchownat(t,e,n,_,r){try{e=SYSCALLS.getStr(e);var a=r&256;return r=r&-257,e=SYSCALLS.calculateAt(t,e),(a?FS.lchown:FS.chown)(e,n,_),0}catch(o){if(typeof FS>"u"||o.name!=="ErrnoError")throw o;return-o.errno}}Module.___syscall_fchownat=___syscall_fchownat,___syscall_fchownat.sig="iipiii";function ___syscall_fcntl64(t,e,n){SYSCALLS.varargs=n;try{var _=SYSCALLS.getStreamFromFD(t);switch(e){case 0:{var r=SYSCALLS.get();if(r<0)return-28;for(;FS.streams[r];)r++;var a;return a=FS.createStream(_,r),a.fd}case 1:case 2:return 0;case 3:return _.flags;case 4:{var r=SYSCALLS.get();return _.flags|=r,0}case 5:{var r=SYSCALLS.getp(),o=0;return HEAP16[r+o>>1]=2,0}case 6:case 7:return 0;case 16:case 8:return-28;case 9:return setErrNo(28),-1;default:return-28}}catch(l){if(typeof FS>"u"||l.name!=="ErrnoError")throw l;return-l.errno}}Module.___syscall_fcntl64=___syscall_fcntl64,___syscall_fcntl64.sig="iiip";function ___syscall_fdatasync(t){try{var e=SYSCALLS.getStreamFromFD(t);return 0}catch(n){if(typeof FS>"u"||n.name!=="ErrnoError")throw n;return-n.errno}}Module.___syscall_fdatasync=___syscall_fdatasync,___syscall_fdatasync.sig="ii";function ___syscall_fstat64(t,e){try{var n=SYSCALLS.getStreamFromFD(t);return SYSCALLS.doStat(FS.stat,n.path,e)}catch(_){if(typeof FS>"u"||_.name!=="ErrnoError")throw _;return-_.errno}}Module.___syscall_fstat64=___syscall_fstat64,___syscall_fstat64.sig="iip";function ___syscall_statfs64(t,e,n){try{return t=SYSCALLS.getStr(t),HEAP32[n+4>>2]=4096,HEAP32[n+40>>2]=4096,HEAP32[n+8>>2]=1e6,HEAP32[n+12>>2]=5e5,HEAP32[n+16>>2]=5e5,HEAP32[n+20>>2]=FS.nextInode,HEAP32[n+24>>2]=1e6,HEAP32[n+28>>2]=42,HEAP32[n+44>>2]=2,HEAP32[n+36>>2]=255,0}catch(_){if(typeof FS>"u"||_.name!=="ErrnoError")throw _;return-_.errno}}Module.___syscall_statfs64=___syscall_statfs64,___syscall_statfs64.sig="ippp";function ___syscall_fstatfs64(t,e,n){try{var _=SYSCALLS.getStreamFromFD(t);return ___syscall_statfs64(0,e,n)}catch(r){if(typeof FS>"u"||r.name!=="ErrnoError")throw r;return-r.errno}}Module.___syscall_fstatfs64=___syscall_fstatfs64,___syscall_fstatfs64.sig="iipp";function ___syscall_ftruncate64(t,e){e=bigintToI53Checked(e);try{return isNaN(e)?61:(FS.ftruncate(t,e),0)}catch(n){if(typeof FS>"u"||n.name!=="ErrnoError")throw n;return-n.errno}}Module.___syscall_ftruncate64=___syscall_ftruncate64,___syscall_ftruncate64.sig="iij";function ___syscall_getcwd(t,e){try{if(e===0)return-28;var n=FS.cwd(),_=lengthBytesUTF8(n)+1;return e<_?-68:(stringToUTF8(n,t,e),_)}catch(r){if(typeof FS>"u"||r.name!=="ErrnoError")throw r;return-r.errno}}Module.___syscall_getcwd=___syscall_getcwd,___syscall_getcwd.sig="ipp";function ___syscall_getdents64(t,e,n){try{var _=SYSCALLS.getStreamFromFD(t);_.getdents||(_.getdents=FS.readdir(_.path));for(var r=280,a=0,o=FS.llseek(_,0,1),l=Math.floor(o/r);l<_.getdents.length&&a+r<=n;){var p,c,I=_.getdents[l];if(I===".")p=_.node.id,c=4;else if(I===".."){var A=FS.lookupPath(_.path,{parent:!0});p=A.node.id,c=4}else{var m=FS.lookupNode(_.node,I);p=m.id,c=FS.isChrdev(m.mode)?2:FS.isDir(m.mode)?4:FS.isLink(m.mode)?10:8}HEAP64[e+a>>3]=BigInt(p),HEAP64[e+a+8>>3]=BigInt((l+1)*r),HEAP16[e+a+16>>1]=280,HEAP8[e+a+18>>0]=c,stringToUTF8(I,e+a+19,256),a+=r,l+=1}return FS.llseek(_,l*r,0),a}catch(E){if(typeof FS>"u"||E.name!=="ErrnoError")throw E;return-E.errno}}Module.___syscall_getdents64=___syscall_getdents64,___syscall_getdents64.sig="iipp";function ___syscall_getpeername(t,e,n,_,r,a){try{var o=getSocketFromFD(t);if(!o.daddr)return-53;var l=writeSockaddr(e,o.family,DNS.lookup_name(o.daddr),o.dport,n);return 0}catch(p){if(typeof FS>"u"||p.name!=="ErrnoError")throw p;return-p.errno}}Module.___syscall_getpeername=___syscall_getpeername,___syscall_getpeername.sig="iippiii";function ___syscall_getsockname(t,e,n,_,r,a){try{var o=getSocketFromFD(t),l=writeSockaddr(e,o.family,DNS.lookup_name(o.saddr||"0.0.0.0"),o.sport,n);return 0}catch(p){if(typeof FS>"u"||p.name!=="ErrnoError")throw p;return-p.errno}}Module.___syscall_getsockname=___syscall_getsockname,___syscall_getsockname.sig="iippiii";function ___syscall_getsockopt(t,e,n,_,r,a){try{var o=getSocketFromFD(t);return e===1&&n===4?(HEAP32[_>>2]=o.error,HEAP32[r>>2]=4,o.error=null,0):-50}catch(l){if(typeof FS>"u"||l.name!=="ErrnoError")throw l;return-l.errno}}Module.___syscall_getsockopt=___syscall_getsockopt,___syscall_getsockopt.sig="iiiippi";function ___syscall_ioctl(t,e,n){SYSCALLS.varargs=n;try{var _=SYSCALLS.getStreamFromFD(t);switch(e){case 21509:return _.tty?0:-59;case 21505:{if(!_.tty)return-59;if(_.tty.ops.ioctl_tcgets){var r=_.tty.ops.ioctl_tcgets(_),a=SYSCALLS.getp();HEAP32[a>>2]=r.c_iflag||0,HEAP32[a+4>>2]=r.c_oflag||0,HEAP32[a+8>>2]=r.c_cflag||0,HEAP32[a+12>>2]=r.c_lflag||0;for(var o=0;o<32;o++)HEAP8[a+o+17>>0]=r.c_cc[o]||0;return 0}return 0}case 21510:case 21511:case 21512:return _.tty?0:-59;case 21506:case 21507:case 21508:{if(!_.tty)return-59;if(_.tty.ops.ioctl_tcsets){for(var a=SYSCALLS.getp(),l=HEAP32[a>>2],p=HEAP32[a+4>>2],c=HEAP32[a+8>>2],I=HEAP32[a+12>>2],A=[],o=0;o<32;o++)A.push(HEAP8[a+o+17>>0]);return _.tty.ops.ioctl_tcsets(_.tty,e,{c_iflag:l,c_oflag:p,c_cflag:c,c_lflag:I,c_cc:A})}return 0}case 21519:{if(!_.tty)return-59;var a=SYSCALLS.getp();return HEAP32[a>>2]=0,0}case 21520:return _.tty?-28:-59;case 21531:{var a=SYSCALLS.getp();return FS.ioctl(_,e,a)}case 21523:{if(!_.tty)return-59;if(_.tty.ops.ioctl_tiocgwinsz){var m=_.tty.ops.ioctl_tiocgwinsz(_.tty),a=SYSCALLS.getp();HEAP16[a>>1]=m[0],HEAP16[a+2>>1]=m[1]}return 0}case 21524:return _.tty?0:-59;case 21515:return _.tty?0:-59;default:return-28}}catch(E){if(typeof FS>"u"||E.name!=="ErrnoError")throw E;return-E.errno}}Module.___syscall_ioctl=___syscall_ioctl,___syscall_ioctl.sig="iiip";function ___syscall_listen(t,e){try{var n=getSocketFromFD(t);return n.sock_ops.listen(n,e),0}catch(_){if(typeof FS>"u"||_.name!=="ErrnoError")throw _;return-_.errno}}Module.___syscall_listen=___syscall_listen,___syscall_listen.sig="iiiiiii";function ___syscall_lstat64(t,e){try{return t=SYSCALLS.getStr(t),SYSCALLS.doStat(FS.lstat,t,e)}catch(n){if(typeof FS>"u"||n.name!=="ErrnoError")throw n;return-n.errno}}Module.___syscall_lstat64=___syscall_lstat64,___syscall_lstat64.sig="ipp";function ___syscall_mkdirat(t,e,n){try{return e=SYSCALLS.getStr(e),e=SYSCALLS.calculateAt(t,e),e=PATH.normalize(e),e[e.length-1]==="/"&&(e=e.substr(0,e.length-1)),FS.mkdir(e,n,0),0}catch(_){if(typeof FS>"u"||_.name!=="ErrnoError")throw _;return-_.errno}}Module.___syscall_mkdirat=___syscall_mkdirat,___syscall_mkdirat.sig="iipi";function ___syscall_mknodat(t,e,n,_){try{switch(e=SYSCALLS.getStr(e),e=SYSCALLS.calculateAt(t,e),n&61440){case 32768:case 8192:case 24576:case 4096:case 49152:break;default:return-28}return FS.mknod(e,n,_),0}catch(r){if(typeof FS>"u"||r.name!=="ErrnoError")throw r;return-r.errno}}Module.___syscall_mknodat=___syscall_mknodat,___syscall_mknodat.sig="iipii";function ___syscall_newfstatat(t,e,n,_){try{e=SYSCALLS.getStr(e);var r=_&256,a=_&4096;return _=_&-6401,e=SYSCALLS.calculateAt(t,e,a),SYSCALLS.doStat(r?FS.lstat:FS.stat,e,n)}catch(o){if(typeof FS>"u"||o.name!=="ErrnoError")throw o;return-o.errno}}Module.___syscall_newfstatat=___syscall_newfstatat,___syscall_newfstatat.sig="iippi";function ___syscall_openat(t,e,n,_){SYSCALLS.varargs=_;try{e=SYSCALLS.getStr(e),e=SYSCALLS.calculateAt(t,e);var r=_?SYSCALLS.get():0;return FS.open(e,n,r).fd}catch(a){if(typeof FS>"u"||a.name!=="ErrnoError")throw a;return-a.errno}}Module.___syscall_openat=___syscall_openat,___syscall_openat.sig="iipip";var PIPEFS={BUCKET_BUFFER_SIZE:8192,mount(t){return FS.createNode(null,"/",16895,0)},createPipe(){var t={buckets:[],refcnt:2};t.buckets.push({buffer:new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),offset:0,roffset:0});var e=PIPEFS.nextname(),n=PIPEFS.nextname(),_=FS.createNode(PIPEFS.root,e,4096,0),r=FS.createNode(PIPEFS.root,n,4096,0);_.pipe=t,r.pipe=t;var a=FS.createStream({path:e,node:_,flags:0,seekable:!1,stream_ops:PIPEFS.stream_ops});_.stream=a;var o=FS.createStream({path:n,node:r,flags:1,seekable:!1,stream_ops:PIPEFS.stream_ops});return r.stream=o,{readable_fd:a.fd,writable_fd:o.fd}},stream_ops:{poll(t){var e=t.node.pipe;if((t.flags&2097155)===1)return 260;if(e.buckets.length>0)for(var n=0;n<e.buckets.length;n++){var _=e.buckets[n];if(_.offset-_.roffset>0)return 65}return 0},ioctl(t,e,n){return 28},fsync(t){return 28},read(t,e,n,_,r){for(var a=t.node.pipe,o=0,l=0;l<a.buckets.length;l++){var p=a.buckets[l];o+=p.offset-p.roffset}var c=e.subarray(n,n+_);if(_<=0)return 0;if(o==0)throw new FS.ErrnoError(6);for(var I=Math.min(o,_),A=I,m=0,l=0;l<a.buckets.length;l++){var E=a.buckets[l],f=E.offset-E.roffset;if(I<=f){var R=E.buffer.subarray(E.roffset,E.offset);I<f?(R=R.subarray(0,I),E.roffset+=I):m++,c.set(R);break}else{var R=E.buffer.subarray(E.roffset,E.offset);c.set(R),c=c.subarray(R.byteLength),I-=R.byteLength,m++}}return m&&m==a.buckets.length&&(m--,a.buckets[m].offset=0,a.buckets[m].roffset=0),a.buckets.splice(0,m),A},write(t,e,n,_,r){var a=t.node.pipe,o=e.subarray(n,n+_),l=o.byteLength;if(l<=0)return 0;var p=null;a.buckets.length==0?(p={buffer:new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),offset:0,roffset:0},a.buckets.push(p)):p=a.buckets[a.buckets.length-1],assert(p.offset<=PIPEFS.BUCKET_BUFFER_SIZE);var c=PIPEFS.BUCKET_BUFFER_SIZE-p.offset;if(c>=l)return p.buffer.set(o,p.offset),p.offset+=l,l;c>0&&(p.buffer.set(o.subarray(0,c),p.offset),p.offset+=c,o=o.subarray(c,o.byteLength));for(var I=o.byteLength/PIPEFS.BUCKET_BUFFER_SIZE|0,A=o.byteLength%PIPEFS.BUCKET_BUFFER_SIZE,m=0;m<I;m++){var E={buffer:new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),offset:PIPEFS.BUCKET_BUFFER_SIZE,roffset:0};a.buckets.push(E),E.buffer.set(o.subarray(0,PIPEFS.BUCKET_BUFFER_SIZE)),o=o.subarray(PIPEFS.BUCKET_BUFFER_SIZE,o.byteLength)}if(A>0){var E={buffer:new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),offset:o.byteLength,roffset:0};a.buckets.push(E),E.buffer.set(o)}return l},close(t){var e=t.node.pipe;e.refcnt--,e.refcnt===0&&(e.buckets=null)}},nextname(){return PIPEFS.nextname.current||(PIPEFS.nextname.current=0),"pipe["+PIPEFS.nextname.current+++"]"}};Module.PIPEFS=PIPEFS;function ___syscall_pipe(t){try{if(t==0)throw new FS.ErrnoError(21);var e=PIPEFS.createPipe();return HEAP32[t>>2]=e.readable_fd,HEAP32[t+4>>2]=e.writable_fd,0}catch(n){if(typeof FS>"u"||n.name!=="ErrnoError")throw n;return-n.errno}}Module.___syscall_pipe=___syscall_pipe,___syscall_pipe.sig="ip";function ___syscall_poll(t,e,n){try{for(var _=0,r=0;r<e;r++){var a=t+8*r,o=HEAP32[a>>2],l=HEAP16[a+4>>1],p=32,c=FS.getStream(o);c&&(p=SYSCALLS.DEFAULT_POLLMASK,c.stream_ops.poll&&(p=c.stream_ops.poll(c,-1))),p&=l|8|16,p&&_++,HEAP16[a+6>>1]=p}return _}catch(I){if(typeof FS>"u"||I.name!=="ErrnoError")throw I;return-I.errno}}Module.___syscall_poll=___syscall_poll,___syscall_poll.sig="ipii";function ___syscall_readlinkat(t,e,n,_){try{if(e=SYSCALLS.getStr(e),e=SYSCALLS.calculateAt(t,e),_<=0)return-28;var r=FS.readlink(e),a=Math.min(_,lengthBytesUTF8(r)),o=HEAP8[n+a];return stringToUTF8(r,n,_+1),HEAP8[n+a]=o,a}catch(l){if(typeof FS>"u"||l.name!=="ErrnoError")throw l;return-l.errno}}Module.___syscall_readlinkat=___syscall_readlinkat,___syscall_readlinkat.sig="iippp";function ___syscall_recvfrom(t,e,n,_,r,a){try{var o=getSocketFromFD(t),l=o.sock_ops.recvmsg(o,n);if(!l)return 0;if(r)var p=writeSockaddr(r,o.family,DNS.lookup_name(l.addr),l.port,a);return HEAPU8.set(l.buffer,e),l.buffer.byteLength}catch(c){if(typeof FS>"u"||c.name!=="ErrnoError")throw c;return-c.errno}}Module.___syscall_recvfrom=___syscall_recvfrom,___syscall_recvfrom.sig="iippipp";function ___syscall_recvmsg(t,e,n,_,r,a){try{for(var o=getSocketFromFD(t),l=HEAPU32[e+8>>2],p=HEAP32[e+12>>2],c=0,I=0;I<p;I++)c+=HEAP32[l+(8*I+4)>>2];var A=o.sock_ops.recvmsg(o,c);if(!A)return 0;var m=HEAPU32[e>>2];if(m)var E=writeSockaddr(m,o.family,DNS.lookup_name(A.addr),A.port);for(var f=0,R=A.buffer.byteLength,I=0;R>0&&I<p;I++){var h=HEAPU32[l+(8*I+0)>>2],w=HEAP32[l+(8*I+4)>>2];if(w){var g=Math.min(w,R),O=A.buffer.subarray(f,f+g);HEAPU8.set(O,h+f),f+=g,R-=g}}return f}catch(W){if(typeof FS>"u"||W.name!=="ErrnoError")throw W;return-W.errno}}Module.___syscall_recvmsg=___syscall_recvmsg,___syscall_recvmsg.sig="iipiiii";function ___syscall_renameat(t,e,n,_){try{return e=SYSCALLS.getStr(e),_=SYSCALLS.getStr(_),e=SYSCALLS.calculateAt(t,e),_=SYSCALLS.calculateAt(n,_),FS.rename(e,_),0}catch(r){if(typeof FS>"u"||r.name!=="ErrnoError")throw r;return-r.errno}}Module.___syscall_renameat=___syscall_renameat,___syscall_renameat.sig="iipip";function ___syscall_rmdir(t){try{return t=SYSCALLS.getStr(t),FS.rmdir(t),0}catch(e){if(typeof FS>"u"||e.name!=="ErrnoError")throw e;return-e.errno}}Module.___syscall_rmdir=___syscall_rmdir,___syscall_rmdir.sig="ip";function ___syscall_sendmsg(t,e,n,_,r,a){try{var o=getSocketFromFD(t),l=HEAPU32[e+8>>2],p=HEAP32[e+12>>2],c,I,A=HEAPU32[e>>2],m=HEAP32[e+4>>2];if(A){var E=readSockaddr(A,m);if(E.errno)return-E.errno;I=E.port,c=DNS.lookup_addr(E.addr)||E.addr}for(var f=0,R=0;R<p;R++)f+=HEAP32[l+(8*R+4)>>2];for(var h=new Uint8Array(f),w=0,R=0;R<p;R++)for(var g=HEAPU32[l+(8*R+0)>>2],O=HEAP32[l+(8*R+4)>>2],W=0;W<O;W++)h[w++]=HEAP8[g+W>>0];return o.sock_ops.sendmsg(o,h,0,f,c,I)}catch(k){if(typeof FS>"u"||k.name!=="ErrnoError")throw k;return-k.errno}}Module.___syscall_sendmsg=___syscall_sendmsg,___syscall_sendmsg.sig="iipippi";function ___syscall_sendto(t,e,n,_,r,a){try{var o=getSocketFromFD(t),l=getSocketAddress(r,a,!0);return l?o.sock_ops.sendmsg(o,HEAP8,e,n,l.addr,l.port):FS.write(o.stream,HEAP8,e,n)}catch(p){if(typeof FS>"u"||p.name!=="ErrnoError")throw p;return-p.errno}}Module.___syscall_sendto=___syscall_sendto,___syscall_sendto.sig="iippipp";function ___syscall_socket(t,e,n){try{var _=SOCKFS.createSocket(t,e,n);return _.stream.fd}catch(r){if(typeof FS>"u"||r.name!=="ErrnoError")throw r;return-r.errno}}Module.___syscall_socket=___syscall_socket,___syscall_socket.sig="iiiiiii";function ___syscall_stat64(t,e){try{return t=SYSCALLS.getStr(t),SYSCALLS.doStat(FS.stat,t,e)}catch(n){if(typeof FS>"u"||n.name!=="ErrnoError")throw n;return-n.errno}}Module.___syscall_stat64=___syscall_stat64,___syscall_stat64.sig="ipp";function ___syscall_symlink(t,e){try{return t=SYSCALLS.getStr(t),e=SYSCALLS.getStr(e),FS.symlink(t,e),0}catch(n){if(typeof FS>"u"||n.name!=="ErrnoError")throw n;return-n.errno}}Module.___syscall_symlink=___syscall_symlink,___syscall_symlink.sig="ipp";function ___syscall_symlinkat(t,e,n){try{return n=SYSCALLS.calculateAt(e,n),FS.symlink(t,n),0}catch(_){if(typeof FS>"u"||_.name!=="ErrnoError")throw _;return-_.errno}}Module.___syscall_symlinkat=___syscall_symlinkat,___syscall_symlinkat.sig="ipip";function ___syscall_truncate64(t,e){e=bigintToI53Checked(e);try{return isNaN(e)?61:(t=SYSCALLS.getStr(t),FS.truncate(t,e),0)}catch(n){if(typeof FS>"u"||n.name!=="ErrnoError")throw n;return-n.errno}}Module.___syscall_truncate64=___syscall_truncate64,___syscall_truncate64.sig="ipj";function ___syscall_unlinkat(t,e,n){try{return e=SYSCALLS.getStr(e),e=SYSCALLS.calculateAt(t,e),n===0?FS.unlink(e):n===512?FS.rmdir(e):abort("Invalid flags passed to unlinkat"),0}catch(_){if(typeof FS>"u"||_.name!=="ErrnoError")throw _;return-_.errno}}Module.___syscall_unlinkat=___syscall_unlinkat,___syscall_unlinkat.sig="iipi";var readI53FromI64=t=>HEAPU32[t>>2]+HEAP32[t+4>>2]*4294967296;Module.readI53FromI64=readI53FromI64;function ___syscall_utimensat(t,e,n,_){try{if(e=SYSCALLS.getStr(e),e=SYSCALLS.calculateAt(t,e,!0),n){var o=readI53FromI64(n),l=HEAP32[n+8>>2];r=o*1e3+l/1e6,n+=16,o=readI53FromI64(n),l=HEAP32[n+8>>2],a=o*1e3+l/1e6}else var r=Date.now(),a=r;return FS.utime(e,r,a),0}catch(p){if(typeof FS>"u"||p.name!=="ErrnoError")throw p;return-p.errno}}Module.___syscall_utimensat=___syscall_utimensat,___syscall_utimensat.sig="iippi";var ___table_base=new WebAssembly.Global({value:"i32",mutable:!1},1);Module.___table_base=___table_base;var ENV={};Module.ENV=ENV;var dlSetError=t=>{withStackSave(()=>{var e=stringToUTF8OnStack(t);___dl_seterr(e,0)})};Module.dlSetError=dlSetError;var dlopenInternal=(t,e)=>{var n=UTF8ToString(t+36),_=HEAP32[t+4>>2];n=PATH.normalize(n);var r=[],a=!!(_&256),o=a?null:{},l={global:a,nodelete:!!(_&4096),loadAsync:e.loadAsync};if(e.loadAsync)return loadDynamicLibrary(n,l,o,t);try{return loadDynamicLibrary(n,l,o,t)}catch(p){return dlSetError(`Could not load dynamic lib: ${n}
${p}`),0}};Module.dlopenInternal=dlopenInternal;var __dlopen_js=t=>dlopenInternal(t,{loadAsync:!1});Module.__dlopen_js=__dlopen_js,__dlopen_js.sig="pp";var __dlsym_js=(t,e,n)=>{e=UTF8ToString(e);var _,r,a=LDSO.loadedLibsByHandle[t];if(!a.exports.hasOwnProperty(e)||a.exports[e].stub)return dlSetError(`Tried to lookup unknown symbol "${e}" in dynamic lib: ${a.name}`),0;if(r=Object.keys(a.exports).indexOf(e),_=a.exports[e],typeof _=="function"){var o=getFunctionAddress(_);o?_=o:(_=addFunction(_,_.sig),HEAPU32[n>>2]=r)}return _};Module.__dlsym_js=__dlsym_js,__dlsym_js.sig="pppp";var handleException=t=>{if(t instanceof ExitStatus||t=="unwind")return EXITSTATUS;quit_(1,t)};Module.handleException=handleException;var _proc_exit=t=>{EXITSTATUS=t,keepRuntimeAlive()||(Module.onExit&&Module.onExit(t),ABORT=!0),quit_(t,new ExitStatus(t))};Module._proc_exit=_proc_exit,_proc_exit.sig="vi";var exitJS=(t,e)=>{EXITSTATUS=t,_proc_exit(t)};Module.exitJS=exitJS;var _exit=exitJS;Module._exit=_exit,_exit.sig="vi";var maybeExit=()=>{if(!keepRuntimeAlive())try{_exit(EXITSTATUS)}catch(t){handleException(t)}};Module.maybeExit=maybeExit;var callUserCallback=t=>{if(!ABORT)try{t(),maybeExit()}catch(e){handleException(e)}};Module.callUserCallback=callUserCallback;var __emscripten_dlopen_js=(t,e,n,_)=>{function r(l){var p=UTF8ToString(t+36);dlSetError(`'Could not load dynamic lib: ${p}
${l}`),callUserCallback(()=>getWasmTableEntry(n)(t,_))}function a(){callUserCallback(()=>getWasmTableEntry(e)(t,_))}var o=dlopenInternal(t,{loadAsync:!0});o?o.then(a,r):r()};Module.__emscripten_dlopen_js=__emscripten_dlopen_js,__emscripten_dlopen_js.sig="vpppp";var nowIsMonotonic=!0;Module.nowIsMonotonic=nowIsMonotonic;var __emscripten_get_now_is_monotonic=()=>nowIsMonotonic;Module.__emscripten_get_now_is_monotonic=__emscripten_get_now_is_monotonic,__emscripten_get_now_is_monotonic.sig="i";var __emscripten_get_progname=(t,e)=>{stringToUTF8(thisProgram,t,e)};Module.__emscripten_get_progname=__emscripten_get_progname,__emscripten_get_progname.sig="vpi";var __emscripten_throw_longjmp=()=>{throw Module.wrapException(1/0)};Module.__emscripten_throw_longjmp=__emscripten_throw_longjmp,__emscripten_throw_longjmp.sig="v";function __gmtime_js(t,e){t=bigintToI53Checked(t);var n=new Date(t*1e3);HEAP32[e>>2]=n.getUTCSeconds(),HEAP32[e+4>>2]=n.getUTCMinutes(),HEAP32[e+8>>2]=n.getUTCHours(),HEAP32[e+12>>2]=n.getUTCDate(),HEAP32[e+16>>2]=n.getUTCMonth(),HEAP32[e+20>>2]=n.getUTCFullYear()-1900,HEAP32[e+24>>2]=n.getUTCDay();var _=Date.UTC(n.getUTCFullYear(),0,1,0,0,0,0),r=(n.getTime()-_)/(1e3*60*60*24)|0;HEAP32[e+28>>2]=r}Module.__gmtime_js=__gmtime_js,__gmtime_js.sig="vjp";var isLeapYear=t=>t%4===0&&(t%100!==0||t%400===0);Module.isLeapYear=isLeapYear;var MONTH_DAYS_LEAP_CUMULATIVE=[0,31,60,91,121,152,182,213,244,274,305,335];Module.MONTH_DAYS_LEAP_CUMULATIVE=MONTH_DAYS_LEAP_CUMULATIVE;var MONTH_DAYS_REGULAR_CUMULATIVE=[0,31,59,90,120,151,181,212,243,273,304,334];Module.MONTH_DAYS_REGULAR_CUMULATIVE=MONTH_DAYS_REGULAR_CUMULATIVE;var ydayFromDate=t=>{var e=isLeapYear(t.getFullYear()),n=e?MONTH_DAYS_LEAP_CUMULATIVE:MONTH_DAYS_REGULAR_CUMULATIVE,_=n[t.getMonth()]+t.getDate()-1;return _};Module.ydayFromDate=ydayFromDate;function __localtime_js(t,e){t=bigintToI53Checked(t);var n=new Date(t*1e3);HEAP32[e>>2]=n.getSeconds(),HEAP32[e+4>>2]=n.getMinutes(),HEAP32[e+8>>2]=n.getHours(),HEAP32[e+12>>2]=n.getDate(),HEAP32[e+16>>2]=n.getMonth(),HEAP32[e+20>>2]=n.getFullYear()-1900,HEAP32[e+24>>2]=n.getDay();var _=ydayFromDate(n)|0;HEAP32[e+28>>2]=_,HEAP32[e+36>>2]=-(n.getTimezoneOffset()*60);var r=new Date(n.getFullYear(),0,1),a=new Date(n.getFullYear(),6,1).getTimezoneOffset(),o=r.getTimezoneOffset(),l=(a!=o&&n.getTimezoneOffset()==Math.min(o,a))|0;HEAP32[e+32>>2]=l}Module.__localtime_js=__localtime_js,__localtime_js.sig="vjp";var __mktime_js=function(t){var e=(()=>{var n=new Date(HEAP32[t+20>>2]+1900,HEAP32[t+16>>2],HEAP32[t+12>>2],HEAP32[t+8>>2],HEAP32[t+4>>2],HEAP32[t>>2],0),_=HEAP32[t+32>>2],r=n.getTimezoneOffset(),a=new Date(n.getFullYear(),0,1),o=new Date(n.getFullYear(),6,1).getTimezoneOffset(),l=a.getTimezoneOffset(),p=Math.min(l,o);if(_<0)HEAP32[t+32>>2]=+(o!=l&&p==r);else if(_>0!=(p==r)){var c=Math.max(l,o),I=_>0?p:c;n.setTime(n.getTime()+(I-r)*6e4)}HEAP32[t+24>>2]=n.getDay();var A=ydayFromDate(n)|0;return HEAP32[t+28>>2]=A,HEAP32[t>>2]=n.getSeconds(),HEAP32[t+4>>2]=n.getMinutes(),HEAP32[t+8>>2]=n.getHours(),HEAP32[t+12>>2]=n.getDate(),HEAP32[t+16>>2]=n.getMonth(),HEAP32[t+20>>2]=n.getYear(),n.getTime()/1e3})();return BigInt(e)};Module.__mktime_js=__mktime_js,__mktime_js.sig="jp";function __mmap_js(t,e,n,_,r,a,o){r=bigintToI53Checked(r);try{if(isNaN(r))return 61;var l=SYSCALLS.getStreamFromFD(_),p=FS.mmap(l,t,r,e,n),c=p.ptr;return HEAP32[a>>2]=p.allocated,HEAPU32[o>>2]=c,0}catch(I){if(typeof FS>"u"||I.name!=="ErrnoError")throw I;return-I.errno}}Module.__mmap_js=__mmap_js,__mmap_js.sig="ipiiijpp";function __msync_js(t,e,n,_,r,a){a=bigintToI53Checked(a);try{return isNaN(a)?61:(SYSCALLS.doMsync(t,SYSCALLS.getStreamFromFD(r),e,_,a),0)}catch(o){if(typeof FS>"u"||o.name!=="ErrnoError")throw o;return-o.errno}}Module.__msync_js=__msync_js,__msync_js.sig="ippiiij";function __munmap_js(t,e,n,_,r,a){a=bigintToI53Checked(a);try{if(isNaN(a))return 61;var o=SYSCALLS.getStreamFromFD(r);n&2&&SYSCALLS.doMsync(t,o,e,_,a),FS.munmap(o)}catch(l){if(typeof FS>"u"||l.name!=="ErrnoError")throw l;return-l.errno}}Module.__munmap_js=__munmap_js,__munmap_js.sig="ippiiij";var timers={};Module.timers=timers;var _emscripten_get_now;_emscripten_get_now=()=>performance.now(),Module._emscripten_get_now=_emscripten_get_now,_emscripten_get_now.sig="d";var __setitimer_js=(t,e)=>{if(timers[t]&&(clearTimeout(timers[t].id),delete timers[t]),!e)return 0;var n=setTimeout(()=>{delete timers[t],callUserCallback(()=>__emscripten_timeout(t,_emscripten_get_now()))},e);return timers[t]={id:n,timeout_ms:e},0};Module.__setitimer_js=__setitimer_js,__setitimer_js.sig="iid";var __timegm_js=function(t){var e=(()=>{var n=Date.UTC(HEAP32[t+20>>2]+1900,HEAP32[t+16>>2],HEAP32[t+12>>2],HEAP32[t+8>>2],HEAP32[t+4>>2],HEAP32[t>>2],0),_=new Date(n);HEAP32[t+24>>2]=_.getUTCDay();var r=Date.UTC(_.getUTCFullYear(),0,1,0,0,0,0),a=(_.getTime()-r)/(1e3*60*60*24)|0;return HEAP32[t+28>>2]=a,_.getTime()/1e3})();return BigInt(e)};Module.__timegm_js=__timegm_js,__timegm_js.sig="jp";var stringToNewUTF8=t=>{var e=lengthBytesUTF8(t)+1,n=_malloc(e);return n&&stringToUTF8(t,n,e),n};Module.stringToNewUTF8=stringToNewUTF8;var __tzset_js=(t,e,n)=>{var _=new Date().getFullYear(),r=new Date(_,0,1),a=new Date(_,6,1),o=r.getTimezoneOffset(),l=a.getTimezoneOffset(),p=Math.max(o,l);HEAPU32[t>>2]=p*60,HEAP32[e>>2]=+(o!=l);function c(f){var R=f.toTimeString().match(/\(([A-Za-z ]+)\)$/);return R?R[1]:"GMT"}var I=c(r),A=c(a),m=stringToNewUTF8(I),E=stringToNewUTF8(A);l<o?(HEAPU32[n>>2]=m,HEAPU32[n+4>>2]=E):(HEAPU32[n>>2]=E,HEAPU32[n+4>>2]=m)};Module.__tzset_js=__tzset_js,__tzset_js.sig="vppp";var _abort=()=>{abort("")};Module._abort=_abort,_abort.sig="v";var readEmAsmArgsArray=[];Module.readEmAsmArgsArray=readEmAsmArgsArray;var readEmAsmArgs=(t,e)=>{readEmAsmArgsArray.length=0;for(var n;n=HEAPU8[t++];){var _=n!=105;_&=n!=112,e+=_&&e%8?4:0,readEmAsmArgsArray.push(n==112?HEAPU32[e>>2]:n==106?HEAP64[e>>3]:n==105?HEAP32[e>>2]:HEAPF64[e>>3]),e+=_?8:4}return readEmAsmArgsArray};Module.readEmAsmArgs=readEmAsmArgs;var runEmAsmFunction=(t,e,n)=>{var _=readEmAsmArgs(e,n);return ASM_CONSTS[t].apply(null,_)};Module.runEmAsmFunction=runEmAsmFunction;var _emscripten_asm_const_int=(t,e,n)=>runEmAsmFunction(t,e,n);Module._emscripten_asm_const_int=_emscripten_asm_const_int,_emscripten_asm_const_int.sig="ippp";var _emscripten_console_error=t=>{console.error(UTF8ToString(t))};Module._emscripten_console_error=_emscripten_console_error,_emscripten_console_error.sig="vp";var _emscripten_console_log=t=>{console.log(UTF8ToString(t))};Module._emscripten_console_log=_emscripten_console_log,_emscripten_console_log.sig="vp";var _emscripten_console_warn=t=>{console.warn(UTF8ToString(t))};Module._emscripten_console_warn=_emscripten_console_warn,_emscripten_console_warn.sig="vp";var _emscripten_date_now=()=>Date.now();Module._emscripten_date_now=_emscripten_date_now,_emscripten_date_now.sig="d";var _emscripten_err=t=>err(UTF8ToString(t));Module._emscripten_err=_emscripten_err,_emscripten_err.sig="vp";var _emscripten_exit_with_live_runtime=()=>{throw"unwind"};Module._emscripten_exit_with_live_runtime=_emscripten_exit_with_live_runtime,_emscripten_exit_with_live_runtime.sig="v";var getHeapMax=()=>2147483648;Module.getHeapMax=getHeapMax;var _emscripten_get_heap_max=()=>getHeapMax();Module._emscripten_get_heap_max=_emscripten_get_heap_max,_emscripten_get_heap_max.sig="p";var _emscripten_get_now_res=()=>ENVIRONMENT_IS_NODE?1:1e3;Module._emscripten_get_now_res=_emscripten_get_now_res,_emscripten_get_now_res.sig="d";var webgl_enable_ANGLE_instanced_arrays=t=>{var e=t.getExtension("ANGLE_instanced_arrays");if(e)return t.vertexAttribDivisor=(n,_)=>e.vertexAttribDivisorANGLE(n,_),t.drawArraysInstanced=(n,_,r,a)=>e.drawArraysInstancedANGLE(n,_,r,a),t.drawElementsInstanced=(n,_,r,a,o)=>e.drawElementsInstancedANGLE(n,_,r,a,o),1};Module.webgl_enable_ANGLE_instanced_arrays=webgl_enable_ANGLE_instanced_arrays;var webgl_enable_OES_vertex_array_object=t=>{var e=t.getExtension("OES_vertex_array_object");if(e)return t.createVertexArray=()=>e.createVertexArrayOES(),t.deleteVertexArray=n=>e.deleteVertexArrayOES(n),t.bindVertexArray=n=>e.bindVertexArrayOES(n),t.isVertexArray=n=>e.isVertexArrayOES(n),1};Module.webgl_enable_OES_vertex_array_object=webgl_enable_OES_vertex_array_object;var webgl_enable_WEBGL_draw_buffers=t=>{var e=t.getExtension("WEBGL_draw_buffers");if(e)return t.drawBuffers=(n,_)=>e.drawBuffersWEBGL(n,_),1};Module.webgl_enable_WEBGL_draw_buffers=webgl_enable_WEBGL_draw_buffers;var webgl_enable_WEBGL_multi_draw=t=>!!(t.multiDrawWebgl=t.getExtension("WEBGL_multi_draw"));Module.webgl_enable_WEBGL_multi_draw=webgl_enable_WEBGL_multi_draw;var GL={counter:1,buffers:[],programs:[],framebuffers:[],renderbuffers:[],textures:[],shaders:[],vaos:[],contexts:[],offscreenCanvases:{},queries:[],stringCache:{},unpackAlignment:4,recordError:function t(e){GL.lastError||(GL.lastError=e)},getNewId:t=>{for(var e=GL.counter++,n=t.length;n<e;n++)t[n]=null;return e},getSource:(t,e,n,_)=>{for(var r="",a=0;a<e;++a){var o=_?HEAP32[_+a*4>>2]:-1;r+=UTF8ToString(HEAP32[n+a*4>>2],o<0?void 0:o)}return r},createContext:(t,e)=>{var n=t.getContext("webgl",e);if(!n)return 0;var _=GL.registerContext(n,e);return _},registerContext:(t,e)=>{var n=GL.getNewId(GL.contexts),_={handle:n,attributes:e,version:e.majorVersion,GLctx:t};return t.canvas&&(t.canvas.GLctxObject=_),GL.contexts[n]=_,(typeof e.enableExtensionsByDefault>"u"||e.enableExtensionsByDefault)&&GL.initExtensions(_),n},makeContextCurrent:t=>(GL.currentContext=GL.contexts[t],Module.ctx=GLctx=GL.currentContext&&GL.currentContext.GLctx,!(t&&!GLctx)),getContext:t=>GL.contexts[t],deleteContext:t=>{GL.currentContext===GL.contexts[t]&&(GL.currentContext=null),typeof JSEvents=="object"&&JSEvents.removeAllHandlersOnTarget(GL.contexts[t].GLctx.canvas),GL.contexts[t]&&GL.contexts[t].GLctx.canvas&&(GL.contexts[t].GLctx.canvas.GLctxObject=void 0),GL.contexts[t]=null},initExtensions:t=>{if(t||(t=GL.currentContext),!t.initExtensionsDone){t.initExtensionsDone=!0;var e=t.GLctx;webgl_enable_ANGLE_instanced_arrays(e),webgl_enable_OES_vertex_array_object(e),webgl_enable_WEBGL_draw_buffers(e),e.disjointTimerQueryExt=e.getExtension("EXT_disjoint_timer_query"),webgl_enable_WEBGL_multi_draw(e);var n=e.getSupportedExtensions()||[];n.forEach(_=>{!_.includes("lose_context")&&!_.includes("debug")&&e.getExtension(_)})}}};Module.GL=GL;function _glActiveTexture(t){GLctx.activeTexture(t)}Module._glActiveTexture=_glActiveTexture,_glActiveTexture.sig="vi";var _emscripten_glActiveTexture=_glActiveTexture;Module._emscripten_glActiveTexture=_emscripten_glActiveTexture;var _glAttachShader=(t,e)=>{GLctx.attachShader(GL.programs[t],GL.shaders[e])};Module._glAttachShader=_glAttachShader,_glAttachShader.sig="vii";var _emscripten_glAttachShader=_glAttachShader;Module._emscripten_glAttachShader=_emscripten_glAttachShader;var _glBeginQueryEXT=(t,e)=>{GLctx.disjointTimerQueryExt.beginQueryEXT(t,GL.queries[e])};Module._glBeginQueryEXT=_glBeginQueryEXT,_glBeginQueryEXT.sig="vii";var _emscripten_glBeginQueryEXT=_glBeginQueryEXT;Module._emscripten_glBeginQueryEXT=_emscripten_glBeginQueryEXT;var _glBindAttribLocation=(t,e,n)=>{GLctx.bindAttribLocation(GL.programs[t],e,UTF8ToString(n))};Module._glBindAttribLocation=_glBindAttribLocation,_glBindAttribLocation.sig="viip";var _emscripten_glBindAttribLocation=_glBindAttribLocation;Module._emscripten_glBindAttribLocation=_emscripten_glBindAttribLocation;var _glBindBuffer=(t,e)=>{GLctx.bindBuffer(t,GL.buffers[e])};Module._glBindBuffer=_glBindBuffer,_glBindBuffer.sig="vii";var _emscripten_glBindBuffer=_glBindBuffer;Module._emscripten_glBindBuffer=_emscripten_glBindBuffer;var _glBindFramebuffer=(t,e)=>{GLctx.bindFramebuffer(t,GL.framebuffers[e])};Module._glBindFramebuffer=_glBindFramebuffer,_glBindFramebuffer.sig="vii";var _emscripten_glBindFramebuffer=_glBindFramebuffer;Module._emscripten_glBindFramebuffer=_emscripten_glBindFramebuffer;var _glBindRenderbuffer=(t,e)=>{GLctx.bindRenderbuffer(t,GL.renderbuffers[e])};Module._glBindRenderbuffer=_glBindRenderbuffer,_glBindRenderbuffer.sig="vii";var _emscripten_glBindRenderbuffer=_glBindRenderbuffer;Module._emscripten_glBindRenderbuffer=_emscripten_glBindRenderbuffer;var _glBindTexture=(t,e)=>{GLctx.bindTexture(t,GL.textures[e])};Module._glBindTexture=_glBindTexture,_glBindTexture.sig="vii";var _emscripten_glBindTexture=_glBindTexture;Module._emscripten_glBindTexture=_emscripten_glBindTexture;var _glBindVertexArray=t=>{GLctx.bindVertexArray(GL.vaos[t])};Module._glBindVertexArray=_glBindVertexArray,_glBindVertexArray.sig="vi";var _glBindVertexArrayOES=_glBindVertexArray;Module._glBindVertexArrayOES=_glBindVertexArrayOES,_glBindVertexArrayOES.sig="vi";var _emscripten_glBindVertexArrayOES=_glBindVertexArrayOES;Module._emscripten_glBindVertexArrayOES=_emscripten_glBindVertexArrayOES;function _glBlendColor(t,e,n,_){GLctx.blendColor(t,e,n,_)}Module._glBlendColor=_glBlendColor,_glBlendColor.sig="vffff";var _emscripten_glBlendColor=_glBlendColor;Module._emscripten_glBlendColor=_emscripten_glBlendColor;function _glBlendEquation(t){GLctx.blendEquation(t)}Module._glBlendEquation=_glBlendEquation,_glBlendEquation.sig="vi";var _emscripten_glBlendEquation=_glBlendEquation;Module._emscripten_glBlendEquation=_emscripten_glBlendEquation;function _glBlendEquationSeparate(t,e){GLctx.blendEquationSeparate(t,e)}Module._glBlendEquationSeparate=_glBlendEquationSeparate,_glBlendEquationSeparate.sig="vii";var _emscripten_glBlendEquationSeparate=_glBlendEquationSeparate;Module._emscripten_glBlendEquationSeparate=_emscripten_glBlendEquationSeparate;function _glBlendFunc(t,e){GLctx.blendFunc(t,e)}Module._glBlendFunc=_glBlendFunc,_glBlendFunc.sig="vii";var _emscripten_glBlendFunc=_glBlendFunc;Module._emscripten_glBlendFunc=_emscripten_glBlendFunc;function _glBlendFuncSeparate(t,e,n,_){GLctx.blendFuncSeparate(t,e,n,_)}Module._glBlendFuncSeparate=_glBlendFuncSeparate,_glBlendFuncSeparate.sig="viiii";var _emscripten_glBlendFuncSeparate=_glBlendFuncSeparate;Module._emscripten_glBlendFuncSeparate=_emscripten_glBlendFuncSeparate;var _glBufferData=(t,e,n,_)=>{GLctx.bufferData(t,n?HEAPU8.subarray(n,n+e):e,_)};Module._glBufferData=_glBufferData,_glBufferData.sig="vippi";var _emscripten_glBufferData=_glBufferData;Module._emscripten_glBufferData=_emscripten_glBufferData;var _glBufferSubData=(t,e,n,_)=>{GLctx.bufferSubData(t,e,HEAPU8.subarray(_,_+n))};Module._glBufferSubData=_glBufferSubData,_glBufferSubData.sig="vippp";var _emscripten_glBufferSubData=_glBufferSubData;Module._emscripten_glBufferSubData=_emscripten_glBufferSubData;function _glCheckFramebufferStatus(t){return GLctx.checkFramebufferStatus(t)}Module._glCheckFramebufferStatus=_glCheckFramebufferStatus,_glCheckFramebufferStatus.sig="ii";var _emscripten_glCheckFramebufferStatus=_glCheckFramebufferStatus;Module._emscripten_glCheckFramebufferStatus=_emscripten_glCheckFramebufferStatus;function _glClear(t){GLctx.clear(t)}Module._glClear=_glClear,_glClear.sig="vi";var _emscripten_glClear=_glClear;Module._emscripten_glClear=_emscripten_glClear;function _glClearColor(t,e,n,_){GLctx.clearColor(t,e,n,_)}Module._glClearColor=_glClearColor,_glClearColor.sig="vffff";var _emscripten_glClearColor=_glClearColor;Module._emscripten_glClearColor=_emscripten_glClearColor;function _glClearDepthf(t){GLctx.clearDepth(t)}Module._glClearDepthf=_glClearDepthf,_glClearDepthf.sig="vf";var _emscripten_glClearDepthf=_glClearDepthf;Module._emscripten_glClearDepthf=_emscripten_glClearDepthf;function _glClearStencil(t){GLctx.clearStencil(t)}Module._glClearStencil=_glClearStencil,_glClearStencil.sig="vi";var _emscripten_glClearStencil=_glClearStencil;Module._emscripten_glClearStencil=_emscripten_glClearStencil;var _glColorMask=(t,e,n,_)=>{GLctx.colorMask(!!t,!!e,!!n,!!_)};Module._glColorMask=_glColorMask,_glColorMask.sig="viiii";var _emscripten_glColorMask=_glColorMask;Module._emscripten_glColorMask=_emscripten_glColorMask;var _glCompileShader=t=>{GLctx.compileShader(GL.shaders[t])};Module._glCompileShader=_glCompileShader,_glCompileShader.sig="vi";var _emscripten_glCompileShader=_glCompileShader;Module._emscripten_glCompileShader=_emscripten_glCompileShader;var _glCompressedTexImage2D=(t,e,n,_,r,a,o,l)=>{GLctx.compressedTexImage2D(t,e,n,_,r,a,l?HEAPU8.subarray(l,l+o):null)};Module._glCompressedTexImage2D=_glCompressedTexImage2D,_glCompressedTexImage2D.sig="viiiiiiip";var _emscripten_glCompressedTexImage2D=_glCompressedTexImage2D;Module._emscripten_glCompressedTexImage2D=_emscripten_glCompressedTexImage2D;var _glCompressedTexSubImage2D=(t,e,n,_,r,a,o,l,p)=>{GLctx.compressedTexSubImage2D(t,e,n,_,r,a,o,p?HEAPU8.subarray(p,p+l):null)};Module._glCompressedTexSubImage2D=_glCompressedTexSubImage2D,_glCompressedTexSubImage2D.sig="viiiiiiiip";var _emscripten_glCompressedTexSubImage2D=_glCompressedTexSubImage2D;Module._emscripten_glCompressedTexSubImage2D=_emscripten_glCompressedTexSubImage2D;function _glCopyTexImage2D(t,e,n,_,r,a,o,l){GLctx.copyTexImage2D(t,e,n,_,r,a,o,l)}Module._glCopyTexImage2D=_glCopyTexImage2D,_glCopyTexImage2D.sig="viiiiiiii";var _emscripten_glCopyTexImage2D=_glCopyTexImage2D;Module._emscripten_glCopyTexImage2D=_emscripten_glCopyTexImage2D;function _glCopyTexSubImage2D(t,e,n,_,r,a,o,l){GLctx.copyTexSubImage2D(t,e,n,_,r,a,o,l)}Module._glCopyTexSubImage2D=_glCopyTexSubImage2D,_glCopyTexSubImage2D.sig="viiiiiiii";var _emscripten_glCopyTexSubImage2D=_glCopyTexSubImage2D;Module._emscripten_glCopyTexSubImage2D=_emscripten_glCopyTexSubImage2D;var _glCreateProgram=()=>{var t=GL.getNewId(GL.programs),e=GLctx.createProgram();return e.name=t,e.maxUniformLength=e.maxAttributeLength=e.maxUniformBlockNameLength=0,e.uniformIdCounter=1,GL.programs[t]=e,t};Module._glCreateProgram=_glCreateProgram,_glCreateProgram.sig="i";var _emscripten_glCreateProgram=_glCreateProgram;Module._emscripten_glCreateProgram=_emscripten_glCreateProgram;var _glCreateShader=t=>{var e=GL.getNewId(GL.shaders);return GL.shaders[e]=GLctx.createShader(t),e};Module._glCreateShader=_glCreateShader,_glCreateShader.sig="ii";var _emscripten_glCreateShader=_glCreateShader;Module._emscripten_glCreateShader=_emscripten_glCreateShader;function _glCullFace(t){GLctx.cullFace(t)}Module._glCullFace=_glCullFace,_glCullFace.sig="vi";var _emscripten_glCullFace=_glCullFace;Module._emscripten_glCullFace=_emscripten_glCullFace;var _glDeleteBuffers=(t,e)=>{for(var n=0;n<t;n++){var _=HEAP32[e+n*4>>2],r=GL.buffers[_];r&&(GLctx.deleteBuffer(r),r.name=0,GL.buffers[_]=null)}};Module._glDeleteBuffers=_glDeleteBuffers,_glDeleteBuffers.sig="vip";var _emscripten_glDeleteBuffers=_glDeleteBuffers;Module._emscripten_glDeleteBuffers=_emscripten_glDeleteBuffers;var _glDeleteFramebuffers=(t,e)=>{for(var n=0;n<t;++n){var _=HEAP32[e+n*4>>2],r=GL.framebuffers[_];r&&(GLctx.deleteFramebuffer(r),r.name=0,GL.framebuffers[_]=null)}};Module._glDeleteFramebuffers=_glDeleteFramebuffers,_glDeleteFramebuffers.sig="vip";var _emscripten_glDeleteFramebuffers=_glDeleteFramebuffers;Module._emscripten_glDeleteFramebuffers=_emscripten_glDeleteFramebuffers;var _glDeleteProgram=t=>{if(t){var e=GL.programs[t];if(!e){GL.recordError(1281);return}GLctx.deleteProgram(e),e.name=0,GL.programs[t]=null}};Module._glDeleteProgram=_glDeleteProgram,_glDeleteProgram.sig="vi";var _emscripten_glDeleteProgram=_glDeleteProgram;Module._emscripten_glDeleteProgram=_emscripten_glDeleteProgram;var _glDeleteQueriesEXT=(t,e)=>{for(var n=0;n<t;n++){var _=HEAP32[e+n*4>>2],r=GL.queries[_];r&&(GLctx.disjointTimerQueryExt.deleteQueryEXT(r),GL.queries[_]=null)}};Module._glDeleteQueriesEXT=_glDeleteQueriesEXT,_glDeleteQueriesEXT.sig="vii";var _emscripten_glDeleteQueriesEXT=_glDeleteQueriesEXT;Module._emscripten_glDeleteQueriesEXT=_emscripten_glDeleteQueriesEXT;var _glDeleteRenderbuffers=(t,e)=>{for(var n=0;n<t;n++){var _=HEAP32[e+n*4>>2],r=GL.renderbuffers[_];r&&(GLctx.deleteRenderbuffer(r),r.name=0,GL.renderbuffers[_]=null)}};Module._glDeleteRenderbuffers=_glDeleteRenderbuffers,_glDeleteRenderbuffers.sig="vip";var _emscripten_glDeleteRenderbuffers=_glDeleteRenderbuffers;Module._emscripten_glDeleteRenderbuffers=_emscripten_glDeleteRenderbuffers;var _glDeleteShader=t=>{if(t){var e=GL.shaders[t];if(!e){GL.recordError(1281);return}GLctx.deleteShader(e),GL.shaders[t]=null}};Module._glDeleteShader=_glDeleteShader,_glDeleteShader.sig="vi";var _emscripten_glDeleteShader=_glDeleteShader;Module._emscripten_glDeleteShader=_emscripten_glDeleteShader;var _glDeleteTextures=(t,e)=>{for(var n=0;n<t;n++){var _=HEAP32[e+n*4>>2],r=GL.textures[_];r&&(GLctx.deleteTexture(r),r.name=0,GL.textures[_]=null)}};Module._glDeleteTextures=_glDeleteTextures,_glDeleteTextures.sig="vip";var _emscripten_glDeleteTextures=_glDeleteTextures;Module._emscripten_glDeleteTextures=_emscripten_glDeleteTextures;var _glDeleteVertexArrays=(t,e)=>{for(var n=0;n<t;n++){var _=HEAP32[e+n*4>>2];GLctx.deleteVertexArray(GL.vaos[_]),GL.vaos[_]=null}};Module._glDeleteVertexArrays=_glDeleteVertexArrays,_glDeleteVertexArrays.sig="vip";var _glDeleteVertexArraysOES=_glDeleteVertexArrays;Module._glDeleteVertexArraysOES=_glDeleteVertexArraysOES,_glDeleteVertexArraysOES.sig="vip";var _emscripten_glDeleteVertexArraysOES=_glDeleteVertexArraysOES;Module._emscripten_glDeleteVertexArraysOES=_emscripten_glDeleteVertexArraysOES;function _glDepthFunc(t){GLctx.depthFunc(t)}Module._glDepthFunc=_glDepthFunc,_glDepthFunc.sig="vi";var _emscripten_glDepthFunc=_glDepthFunc;Module._emscripten_glDepthFunc=_emscripten_glDepthFunc;var _glDepthMask=t=>{GLctx.depthMask(!!t)};Module._glDepthMask=_glDepthMask,_glDepthMask.sig="vi";var _emscripten_glDepthMask=_glDepthMask;Module._emscripten_glDepthMask=_emscripten_glDepthMask;function _glDepthRangef(t,e){GLctx.depthRange(t,e)}Module._glDepthRangef=_glDepthRangef,_glDepthRangef.sig="vff";var _emscripten_glDepthRangef=_glDepthRangef;Module._emscripten_glDepthRangef=_emscripten_glDepthRangef;var _glDetachShader=(t,e)=>{GLctx.detachShader(GL.programs[t],GL.shaders[e])};Module._glDetachShader=_glDetachShader,_glDetachShader.sig="vii";var _emscripten_glDetachShader=_glDetachShader;Module._emscripten_glDetachShader=_emscripten_glDetachShader;function _glDisable(t){GLctx.disable(t)}Module._glDisable=_glDisable,_glDisable.sig="vi";var _emscripten_glDisable=_glDisable;Module._emscripten_glDisable=_emscripten_glDisable;var _glDisableVertexAttribArray=t=>{GLctx.disableVertexAttribArray(t)};Module._glDisableVertexAttribArray=_glDisableVertexAttribArray,_glDisableVertexAttribArray.sig="vi";var _emscripten_glDisableVertexAttribArray=_glDisableVertexAttribArray;Module._emscripten_glDisableVertexAttribArray=_emscripten_glDisableVertexAttribArray;var _glDrawArrays=(t,e,n)=>{GLctx.drawArrays(t,e,n)};Module._glDrawArrays=_glDrawArrays,_glDrawArrays.sig="viii";var _emscripten_glDrawArrays=_glDrawArrays;Module._emscripten_glDrawArrays=_emscripten_glDrawArrays;var _glDrawArraysInstanced=(t,e,n,_)=>{GLctx.drawArraysInstanced(t,e,n,_)};Module._glDrawArraysInstanced=_glDrawArraysInstanced,_glDrawArraysInstanced.sig="viiii";var _glDrawArraysInstancedANGLE=_glDrawArraysInstanced;Module._glDrawArraysInstancedANGLE=_glDrawArraysInstancedANGLE;var _emscripten_glDrawArraysInstancedANGLE=_glDrawArraysInstancedANGLE;Module._emscripten_glDrawArraysInstancedANGLE=_emscripten_glDrawArraysInstancedANGLE;var tempFixedLengthArray=[];Module.tempFixedLengthArray=tempFixedLengthArray;var _glDrawBuffers=(t,e)=>{for(var n=tempFixedLengthArray[t],_=0;_<t;_++)n[_]=HEAP32[e+_*4>>2];GLctx.drawBuffers(n)};Module._glDrawBuffers=_glDrawBuffers,_glDrawBuffers.sig="vip";var _glDrawBuffersWEBGL=_glDrawBuffers;Module._glDrawBuffersWEBGL=_glDrawBuffersWEBGL;var _emscripten_glDrawBuffersWEBGL=_glDrawBuffersWEBGL;Module._emscripten_glDrawBuffersWEBGL=_emscripten_glDrawBuffersWEBGL;var _glDrawElements=(t,e,n,_)=>{GLctx.drawElements(t,e,n,_)};Module._glDrawElements=_glDrawElements,_glDrawElements.sig="viiip";var _emscripten_glDrawElements=_glDrawElements;Module._emscripten_glDrawElements=_emscripten_glDrawElements;var _glDrawElementsInstanced=(t,e,n,_,r)=>{GLctx.drawElementsInstanced(t,e,n,_,r)};Module._glDrawElementsInstanced=_glDrawElementsInstanced,_glDrawElementsInstanced.sig="viiipi";var _glDrawElementsInstancedANGLE=_glDrawElementsInstanced;Module._glDrawElementsInstancedANGLE=_glDrawElementsInstancedANGLE;var _emscripten_glDrawElementsInstancedANGLE=_glDrawElementsInstancedANGLE;Module._emscripten_glDrawElementsInstancedANGLE=_emscripten_glDrawElementsInstancedANGLE;function _glEnable(t){GLctx.enable(t)}Module._glEnable=_glEnable,_glEnable.sig="vi";var _emscripten_glEnable=_glEnable;Module._emscripten_glEnable=_emscripten_glEnable;var _glEnableVertexAttribArray=t=>{GLctx.enableVertexAttribArray(t)};Module._glEnableVertexAttribArray=_glEnableVertexAttribArray,_glEnableVertexAttribArray.sig="vi";var _emscripten_glEnableVertexAttribArray=_glEnableVertexAttribArray;Module._emscripten_glEnableVertexAttribArray=_emscripten_glEnableVertexAttribArray;var _glEndQueryEXT=t=>{GLctx.disjointTimerQueryExt.endQueryEXT(t)};Module._glEndQueryEXT=_glEndQueryEXT,_glEndQueryEXT.sig="vi";var _emscripten_glEndQueryEXT=_glEndQueryEXT;Module._emscripten_glEndQueryEXT=_emscripten_glEndQueryEXT;function _glFinish(){GLctx.finish()}Module._glFinish=_glFinish,_glFinish.sig="v";var _emscripten_glFinish=_glFinish;Module._emscripten_glFinish=_emscripten_glFinish;function _glFlush(){GLctx.flush()}Module._glFlush=_glFlush,_glFlush.sig="v";var _emscripten_glFlush=_glFlush;Module._emscripten_glFlush=_emscripten_glFlush;var _glFramebufferRenderbuffer=(t,e,n,_)=>{GLctx.framebufferRenderbuffer(t,e,n,GL.renderbuffers[_])};Module._glFramebufferRenderbuffer=_glFramebufferRenderbuffer,_glFramebufferRenderbuffer.sig="viiii";var _emscripten_glFramebufferRenderbuffer=_glFramebufferRenderbuffer;Module._emscripten_glFramebufferRenderbuffer=_emscripten_glFramebufferRenderbuffer;var _glFramebufferTexture2D=(t,e,n,_,r)=>{GLctx.framebufferTexture2D(t,e,n,GL.textures[_],r)};Module._glFramebufferTexture2D=_glFramebufferTexture2D,_glFramebufferTexture2D.sig="viiiii";var _emscripten_glFramebufferTexture2D=_glFramebufferTexture2D;Module._emscripten_glFramebufferTexture2D=_emscripten_glFramebufferTexture2D;function _glFrontFace(t){GLctx.frontFace(t)}Module._glFrontFace=_glFrontFace,_glFrontFace.sig="vi";var _emscripten_glFrontFace=_glFrontFace;Module._emscripten_glFrontFace=_emscripten_glFrontFace;var __glGenObject=(t,e,n,_)=>{for(var r=0;r<t;r++){var a=GLctx[n](),o=a&&GL.getNewId(_);a?(a.name=o,_[o]=a):GL.recordError(1282),HEAP32[e+r*4>>2]=o}};Module.__glGenObject=__glGenObject;var _glGenBuffers=(t,e)=>{__glGenObject(t,e,"createBuffer",GL.buffers)};Module._glGenBuffers=_glGenBuffers,_glGenBuffers.sig="vip";var _emscripten_glGenBuffers=_glGenBuffers;Module._emscripten_glGenBuffers=_emscripten_glGenBuffers;var _glGenFramebuffers=(t,e)=>{__glGenObject(t,e,"createFramebuffer",GL.framebuffers)};Module._glGenFramebuffers=_glGenFramebuffers,_glGenFramebuffers.sig="vip";var _emscripten_glGenFramebuffers=_glGenFramebuffers;Module._emscripten_glGenFramebuffers=_emscripten_glGenFramebuffers;var _glGenQueriesEXT=(t,e)=>{for(var n=0;n<t;n++){var _=GLctx.disjointTimerQueryExt.createQueryEXT();if(!_){for(GL.recordError(1282);n<t;)HEAP32[e+n++*4>>2]=0;return}var r=GL.getNewId(GL.queries);_.name=r,GL.queries[r]=_,HEAP32[e+n*4>>2]=r}};Module._glGenQueriesEXT=_glGenQueriesEXT,_glGenQueriesEXT.sig="vii";var _emscripten_glGenQueriesEXT=_glGenQueriesEXT;Module._emscripten_glGenQueriesEXT=_emscripten_glGenQueriesEXT;var _glGenRenderbuffers=(t,e)=>{__glGenObject(t,e,"createRenderbuffer",GL.renderbuffers)};Module._glGenRenderbuffers=_glGenRenderbuffers,_glGenRenderbuffers.sig="vip";var _emscripten_glGenRenderbuffers=_glGenRenderbuffers;Module._emscripten_glGenRenderbuffers=_emscripten_glGenRenderbuffers;var _glGenTextures=(t,e)=>{__glGenObject(t,e,"createTexture",GL.textures)};Module._glGenTextures=_glGenTextures,_glGenTextures.sig="vip";var _emscripten_glGenTextures=_glGenTextures;Module._emscripten_glGenTextures=_emscripten_glGenTextures;function _glGenVertexArrays(t,e){__glGenObject(t,e,"createVertexArray",GL.vaos)}Module._glGenVertexArrays=_glGenVertexArrays,_glGenVertexArrays.sig="vip";var _glGenVertexArraysOES=_glGenVertexArrays;Module._glGenVertexArraysOES=_glGenVertexArraysOES,_glGenVertexArraysOES.sig="vip";var _emscripten_glGenVertexArraysOES=_glGenVertexArraysOES;Module._emscripten_glGenVertexArraysOES=_emscripten_glGenVertexArraysOES;function _glGenerateMipmap(t){GLctx.generateMipmap(t)}Module._glGenerateMipmap=_glGenerateMipmap,_glGenerateMipmap.sig="vi";var _emscripten_glGenerateMipmap=_glGenerateMipmap;Module._emscripten_glGenerateMipmap=_emscripten_glGenerateMipmap;var __glGetActiveAttribOrUniform=(t,e,n,_,r,a,o,l)=>{e=GL.programs[e];var p=GLctx[t](e,n);if(p){var c=l&&stringToUTF8(p.name,l,_);r&&(HEAP32[r>>2]=c),a&&(HEAP32[a>>2]=p.size),o&&(HEAP32[o>>2]=p.type)}};Module.__glGetActiveAttribOrUniform=__glGetActiveAttribOrUniform;var _glGetActiveAttrib=(t,e,n,_,r,a,o)=>{__glGetActiveAttribOrUniform("getActiveAttrib",t,e,n,_,r,a,o)};Module._glGetActiveAttrib=_glGetActiveAttrib,_glGetActiveAttrib.sig="viiipppp";var _emscripten_glGetActiveAttrib=_glGetActiveAttrib;Module._emscripten_glGetActiveAttrib=_emscripten_glGetActiveAttrib;var _glGetActiveUniform=(t,e,n,_,r,a,o)=>{__glGetActiveAttribOrUniform("getActiveUniform",t,e,n,_,r,a,o)};Module._glGetActiveUniform=_glGetActiveUniform,_glGetActiveUniform.sig="viiipppp";var _emscripten_glGetActiveUniform=_glGetActiveUniform;Module._emscripten_glGetActiveUniform=_emscripten_glGetActiveUniform;var _glGetAttachedShaders=(t,e,n,_)=>{var r=GLctx.getAttachedShaders(GL.programs[t]),a=r.length;a>e&&(a=e),HEAP32[n>>2]=a;for(var o=0;o<a;++o){var l=GL.shaders.indexOf(r[o]);HEAP32[_+o*4>>2]=l}};Module._glGetAttachedShaders=_glGetAttachedShaders,_glGetAttachedShaders.sig="viipp";var _emscripten_glGetAttachedShaders=_glGetAttachedShaders;Module._emscripten_glGetAttachedShaders=_emscripten_glGetAttachedShaders;var _glGetAttribLocation=(t,e)=>GLctx.getAttribLocation(GL.programs[t],UTF8ToString(e));Module._glGetAttribLocation=_glGetAttribLocation,_glGetAttribLocation.sig="iip";var _emscripten_glGetAttribLocation=_glGetAttribLocation;Module._emscripten_glGetAttribLocation=_emscripten_glGetAttribLocation;var writeI53ToI64=(t,e)=>{HEAPU32[t>>2]=e;var n=HEAPU32[t>>2];HEAPU32[t+4>>2]=(e-n)/4294967296};Module.writeI53ToI64=writeI53ToI64;var emscriptenWebGLGet=(t,e,n)=>{if(!e){GL.recordError(1281);return}var _=void 0;switch(t){case 36346:_=1;break;case 36344:n!=0&&n!=1&&GL.recordError(1280);return;case 36345:_=0;break;case 34466:var r=GLctx.getParameter(34467);_=r?r.length:0;break}if(_===void 0){var a=GLctx.getParameter(t);switch(typeof a){case"number":_=a;break;case"boolean":_=a?1:0;break;case"string":GL.recordError(1280);return;case"object":if(a===null)switch(t){case 34964:case 35725:case 34965:case 36006:case 36007:case 32873:case 34229:case 34068:{_=0;break}default:{GL.recordError(1280);return}}else if(a instanceof Float32Array||a instanceof Uint32Array||a instanceof Int32Array||a instanceof Array){for(var o=0;o<a.length;++o)switch(n){case 0:HEAP32[e+o*4>>2]=a[o];break;case 2:HEAPF32[e+o*4>>2]=a[o];break;case 4:HEAP8[e+o>>0]=a[o]?1:0;break}return}else try{_=a.name|0}catch(l){GL.recordError(1280),err("GL_INVALID_ENUM in glGet"+n+"v: Unknown object returned from WebGL getParameter("+t+")! (error: "+l+")");return}break;default:GL.recordError(1280),err("GL_INVALID_ENUM in glGet"+n+"v: Native code calling glGet"+n+"v("+t+") and it returns "+a+" of type "+typeof a+"!");return}}switch(n){case 1:writeI53ToI64(e,_);break;case 0:HEAP32[e>>2]=_;break;case 2:HEAPF32[e>>2]=_;break;case 4:HEAP8[e>>0]=_?1:0;break}};Module.emscriptenWebGLGet=emscriptenWebGLGet;var _glGetBooleanv=(t,e)=>{emscriptenWebGLGet(t,e,4)};Module._glGetBooleanv=_glGetBooleanv,_glGetBooleanv.sig="vip";var _emscripten_glGetBooleanv=_glGetBooleanv;Module._emscripten_glGetBooleanv=_emscripten_glGetBooleanv;var _glGetBufferParameteriv=(t,e,n)=>{if(!n){GL.recordError(1281);return}HEAP32[n>>2]=GLctx.getBufferParameter(t,e)};Module._glGetBufferParameteriv=_glGetBufferParameteriv,_glGetBufferParameteriv.sig="viip";var _emscripten_glGetBufferParameteriv=_glGetBufferParameteriv;Module._emscripten_glGetBufferParameteriv=_emscripten_glGetBufferParameteriv;var _glGetError=()=>{var t=GLctx.getError()||GL.lastError;return GL.lastError=0,t};Module._glGetError=_glGetError,_glGetError.sig="i";var _emscripten_glGetError=_glGetError;Module._emscripten_glGetError=_emscripten_glGetError;var _glGetFloatv=(t,e)=>{emscriptenWebGLGet(t,e,2)};Module._glGetFloatv=_glGetFloatv,_glGetFloatv.sig="vip";var _emscripten_glGetFloatv=_glGetFloatv;Module._emscripten_glGetFloatv=_emscripten_glGetFloatv;var _glGetFramebufferAttachmentParameteriv=(t,e,n,_)=>{var r=GLctx.getFramebufferAttachmentParameter(t,e,n);(r instanceof WebGLRenderbuffer||r instanceof WebGLTexture)&&(r=r.name|0),HEAP32[_>>2]=r};Module._glGetFramebufferAttachmentParameteriv=_glGetFramebufferAttachmentParameteriv,_glGetFramebufferAttachmentParameteriv.sig="viiip";var _emscripten_glGetFramebufferAttachmentParameteriv=_glGetFramebufferAttachmentParameteriv;Module._emscripten_glGetFramebufferAttachmentParameteriv=_emscripten_glGetFramebufferAttachmentParameteriv;var _glGetIntegerv=(t,e)=>{emscriptenWebGLGet(t,e,0)};Module._glGetIntegerv=_glGetIntegerv,_glGetIntegerv.sig="vip";var _emscripten_glGetIntegerv=_glGetIntegerv;Module._emscripten_glGetIntegerv=_emscripten_glGetIntegerv;var _glGetProgramInfoLog=(t,e,n,_)=>{var r=GLctx.getProgramInfoLog(GL.programs[t]);r===null&&(r="(unknown error)");var a=e>0&&_?stringToUTF8(r,_,e):0;n&&(HEAP32[n>>2]=a)};Module._glGetProgramInfoLog=_glGetProgramInfoLog,_glGetProgramInfoLog.sig="viipp";var _emscripten_glGetProgramInfoLog=_glGetProgramInfoLog;Module._emscripten_glGetProgramInfoLog=_emscripten_glGetProgramInfoLog;var _glGetProgramiv=(t,e,n)=>{if(!n){GL.recordError(1281);return}if(t>=GL.counter){GL.recordError(1281);return}if(t=GL.programs[t],e==35716){var _=GLctx.getProgramInfoLog(t);_===null&&(_="(unknown error)"),HEAP32[n>>2]=_.length+1}else if(e==35719){if(!t.maxUniformLength)for(var r=0;r<GLctx.getProgramParameter(t,35718);++r)t.maxUniformLength=Math.max(t.maxUniformLength,GLctx.getActiveUniform(t,r).name.length+1);HEAP32[n>>2]=t.maxUniformLength}else if(e==35722){if(!t.maxAttributeLength)for(var r=0;r<GLctx.getProgramParameter(t,35721);++r)t.maxAttributeLength=Math.max(t.maxAttributeLength,GLctx.getActiveAttrib(t,r).name.length+1);HEAP32[n>>2]=t.maxAttributeLength}else if(e==35381){if(!t.maxUniformBlockNameLength)for(var r=0;r<GLctx.getProgramParameter(t,35382);++r)t.maxUniformBlockNameLength=Math.max(t.maxUniformBlockNameLength,GLctx.getActiveUniformBlockName(t,r).length+1);HEAP32[n>>2]=t.maxUniformBlockNameLength}else HEAP32[n>>2]=GLctx.getProgramParameter(t,e)};Module._glGetProgramiv=_glGetProgramiv,_glGetProgramiv.sig="viip";var _emscripten_glGetProgramiv=_glGetProgramiv;Module._emscripten_glGetProgramiv=_emscripten_glGetProgramiv;var _glGetQueryObjecti64vEXT=(t,e,n)=>{if(!n){GL.recordError(1281);return}var _=GL.queries[t],r;r=GLctx.disjointTimerQueryExt.getQueryObjectEXT(_,e);var a;typeof r=="boolean"?a=r?1:0:a=r,writeI53ToI64(n,a)};Module._glGetQueryObjecti64vEXT=_glGetQueryObjecti64vEXT,_glGetQueryObjecti64vEXT.sig="viii";var _emscripten_glGetQueryObjecti64vEXT=_glGetQueryObjecti64vEXT;Module._emscripten_glGetQueryObjecti64vEXT=_emscripten_glGetQueryObjecti64vEXT;var _glGetQueryObjectivEXT=(t,e,n)=>{if(!n){GL.recordError(1281);return}var _=GL.queries[t],r=GLctx.disjointTimerQueryExt.getQueryObjectEXT(_,e),a;typeof r=="boolean"?a=r?1:0:a=r,HEAP32[n>>2]=a};Module._glGetQueryObjectivEXT=_glGetQueryObjectivEXT,_glGetQueryObjectivEXT.sig="viii";var _emscripten_glGetQueryObjectivEXT=_glGetQueryObjectivEXT;Module._emscripten_glGetQueryObjectivEXT=_emscripten_glGetQueryObjectivEXT;var _glGetQueryObjectui64vEXT=_glGetQueryObjecti64vEXT;Module._glGetQueryObjectui64vEXT=_glGetQueryObjectui64vEXT;var _emscripten_glGetQueryObjectui64vEXT=_glGetQueryObjectui64vEXT;Module._emscripten_glGetQueryObjectui64vEXT=_emscripten_glGetQueryObjectui64vEXT;var _glGetQueryObjectuivEXT=_glGetQueryObjectivEXT;Module._glGetQueryObjectuivEXT=_glGetQueryObjectuivEXT;var _emscripten_glGetQueryObjectuivEXT=_glGetQueryObjectuivEXT;Module._emscripten_glGetQueryObjectuivEXT=_emscripten_glGetQueryObjectuivEXT;var _glGetQueryivEXT=(t,e,n)=>{if(!n){GL.recordError(1281);return}HEAP32[n>>2]=GLctx.disjointTimerQueryExt.getQueryEXT(t,e)};Module._glGetQueryivEXT=_glGetQueryivEXT,_glGetQueryivEXT.sig="viii";var _emscripten_glGetQueryivEXT=_glGetQueryivEXT;Module._emscripten_glGetQueryivEXT=_emscripten_glGetQueryivEXT;var _glGetRenderbufferParameteriv=(t,e,n)=>{if(!n){GL.recordError(1281);return}HEAP32[n>>2]=GLctx.getRenderbufferParameter(t,e)};Module._glGetRenderbufferParameteriv=_glGetRenderbufferParameteriv,_glGetRenderbufferParameteriv.sig="viip";var _emscripten_glGetRenderbufferParameteriv=_glGetRenderbufferParameteriv;Module._emscripten_glGetRenderbufferParameteriv=_emscripten_glGetRenderbufferParameteriv;var _glGetShaderInfoLog=(t,e,n,_)=>{var r=GLctx.getShaderInfoLog(GL.shaders[t]);r===null&&(r="(unknown error)");var a=e>0&&_?stringToUTF8(r,_,e):0;n&&(HEAP32[n>>2]=a)};Module._glGetShaderInfoLog=_glGetShaderInfoLog,_glGetShaderInfoLog.sig="viipp";var _emscripten_glGetShaderInfoLog=_glGetShaderInfoLog;Module._emscripten_glGetShaderInfoLog=_emscripten_glGetShaderInfoLog;var _glGetShaderPrecisionFormat=(t,e,n,_)=>{var r=GLctx.getShaderPrecisionFormat(t,e);HEAP32[n>>2]=r.rangeMin,HEAP32[n+4>>2]=r.rangeMax,HEAP32[_>>2]=r.precision};Module._glGetShaderPrecisionFormat=_glGetShaderPrecisionFormat,_glGetShaderPrecisionFormat.sig="viipp";var _emscripten_glGetShaderPrecisionFormat=_glGetShaderPrecisionFormat;Module._emscripten_glGetShaderPrecisionFormat=_emscripten_glGetShaderPrecisionFormat;var _glGetShaderSource=(t,e,n,_)=>{var r=GLctx.getShaderSource(GL.shaders[t]);if(r){var a=e>0&&_?stringToUTF8(r,_,e):0;n&&(HEAP32[n>>2]=a)}};Module._glGetShaderSource=_glGetShaderSource,_glGetShaderSource.sig="viipp";var _emscripten_glGetShaderSource=_glGetShaderSource;Module._emscripten_glGetShaderSource=_emscripten_glGetShaderSource;var _glGetShaderiv=(t,e,n)=>{if(!n){GL.recordError(1281);return}if(e==35716){var _=GLctx.getShaderInfoLog(GL.shaders[t]);_===null&&(_="(unknown error)");var r=_?_.length+1:0;HEAP32[n>>2]=r}else if(e==35720){var a=GLctx.getShaderSource(GL.shaders[t]),o=a?a.length+1:0;HEAP32[n>>2]=o}else HEAP32[n>>2]=GLctx.getShaderParameter(GL.shaders[t],e)};Module._glGetShaderiv=_glGetShaderiv,_glGetShaderiv.sig="viip";var _emscripten_glGetShaderiv=_glGetShaderiv;Module._emscripten_glGetShaderiv=_emscripten_glGetShaderiv;var _glGetString=t=>{var e=GL.stringCache[t];if(!e){switch(t){case 7939:var n=GLctx.getSupportedExtensions()||[];n=n.concat(n.map(p=>"GL_"+p)),e=stringToNewUTF8(n.join(" "));break;case 7936:case 7937:case 37445:case 37446:var _=GLctx.getParameter(t);_||GL.recordError(1280),e=_&&stringToNewUTF8(_);break;case 7938:var r=GLctx.getParameter(7938);r="OpenGL ES 2.0 ("+r+")",e=stringToNewUTF8(r);break;case 35724:var a=GLctx.getParameter(35724),o=/^WebGL GLSL ES ([0-9]\.[0-9][0-9]?)(?:$| .*)/,l=a.match(o);l!==null&&(l[1].length==3&&(l[1]=l[1]+"0"),a="OpenGL ES GLSL ES "+l[1]+" ("+a+")"),e=stringToNewUTF8(a);break;default:GL.recordError(1280)}GL.stringCache[t]=e}return e};Module._glGetString=_glGetString,_glGetString.sig="pi";var _emscripten_glGetString=_glGetString;Module._emscripten_glGetString=_emscripten_glGetString;var _glGetTexParameterfv=(t,e,n)=>{if(!n){GL.recordError(1281);return}HEAPF32[n>>2]=GLctx.getTexParameter(t,e)};Module._glGetTexParameterfv=_glGetTexParameterfv,_glGetTexParameterfv.sig="viip";var _emscripten_glGetTexParameterfv=_glGetTexParameterfv;Module._emscripten_glGetTexParameterfv=_emscripten_glGetTexParameterfv;var _glGetTexParameteriv=(t,e,n)=>{if(!n){GL.recordError(1281);return}HEAP32[n>>2]=GLctx.getTexParameter(t,e)};Module._glGetTexParameteriv=_glGetTexParameteriv,_glGetTexParameteriv.sig="viip";var _emscripten_glGetTexParameteriv=_glGetTexParameteriv;Module._emscripten_glGetTexParameteriv=_emscripten_glGetTexParameteriv;var webglGetLeftBracePos=t=>t.slice(-1)=="]"&&t.lastIndexOf("[");Module.webglGetLeftBracePos=webglGetLeftBracePos;var webglPrepareUniformLocationsBeforeFirstUse=t=>{var e=t.uniformLocsById,n=t.uniformSizeAndIdsByName,_,r;if(!e)for(t.uniformLocsById=e={},t.uniformArrayNamesById={},_=0;_<GLctx.getProgramParameter(t,35718);++_){var a=GLctx.getActiveUniform(t,_),o=a.name,l=a.size,p=webglGetLeftBracePos(o),c=p>0?o.slice(0,p):o,I=t.uniformIdCounter;for(t.uniformIdCounter+=l,n[c]=[l,I],r=0;r<l;++r)e[I]=r,t.uniformArrayNamesById[I++]=c}};Module.webglPrepareUniformLocationsBeforeFirstUse=webglPrepareUniformLocationsBeforeFirstUse;var _glGetUniformLocation=(t,e)=>{if(e=UTF8ToString(e),t=GL.programs[t]){webglPrepareUniformLocationsBeforeFirstUse(t);var n=t.uniformLocsById,_=0,r=e,a=webglGetLeftBracePos(e);a>0&&(_=jstoi_q(e.slice(a+1))>>>0,r=e.slice(0,a));var o=t.uniformSizeAndIdsByName[r];if(o&&_<o[0]&&(_+=o[1],n[_]=n[_]||GLctx.getUniformLocation(t,e)))return _}else GL.recordError(1281);return-1};Module._glGetUniformLocation=_glGetUniformLocation,_glGetUniformLocation.sig="iip";var _emscripten_glGetUniformLocation=_glGetUniformLocation;Module._emscripten_glGetUniformLocation=_emscripten_glGetUniformLocation;var webglGetUniformLocation=t=>{var e=GLctx.currentProgram;if(e){var n=e.uniformLocsById[t];return typeof n=="number"&&(e.uniformLocsById[t]=n=GLctx.getUniformLocation(e,e.uniformArrayNamesById[t]+(n>0?"["+n+"]":""))),n}else GL.recordError(1282)};Module.webglGetUniformLocation=webglGetUniformLocation;var emscriptenWebGLGetUniform=(t,e,n,_)=>{if(!n){GL.recordError(1281);return}t=GL.programs[t],webglPrepareUniformLocationsBeforeFirstUse(t);var r=GLctx.getUniform(t,webglGetUniformLocation(e));if(typeof r=="number"||typeof r=="boolean")switch(_){case 0:HEAP32[n>>2]=r;break;case 2:HEAPF32[n>>2]=r;break}else for(var a=0;a<r.length;a++)switch(_){case 0:HEAP32[n+a*4>>2]=r[a];break;case 2:HEAPF32[n+a*4>>2]=r[a];break}};Module.emscriptenWebGLGetUniform=emscriptenWebGLGetUniform;var _glGetUniformfv=(t,e,n)=>{emscriptenWebGLGetUniform(t,e,n,2)};Module._glGetUniformfv=_glGetUniformfv,_glGetUniformfv.sig="viip";var _emscripten_glGetUniformfv=_glGetUniformfv;Module._emscripten_glGetUniformfv=_emscripten_glGetUniformfv;var _glGetUniformiv=(t,e,n)=>{emscriptenWebGLGetUniform(t,e,n,0)};Module._glGetUniformiv=_glGetUniformiv,_glGetUniformiv.sig="viip";var _emscripten_glGetUniformiv=_glGetUniformiv;Module._emscripten_glGetUniformiv=_emscripten_glGetUniformiv;var _glGetVertexAttribPointerv=(t,e,n)=>{if(!n){GL.recordError(1281);return}HEAP32[n>>2]=GLctx.getVertexAttribOffset(t,e)};Module._glGetVertexAttribPointerv=_glGetVertexAttribPointerv,_glGetVertexAttribPointerv.sig="viip";var _emscripten_glGetVertexAttribPointerv=_glGetVertexAttribPointerv;Module._emscripten_glGetVertexAttribPointerv=_emscripten_glGetVertexAttribPointerv;var emscriptenWebGLGetVertexAttrib=(t,e,n,_)=>{if(!n){GL.recordError(1281);return}var r=GLctx.getVertexAttrib(t,e);if(e==34975)HEAP32[n>>2]=r&&r.name;else if(typeof r=="number"||typeof r=="boolean")switch(_){case 0:HEAP32[n>>2]=r;break;case 2:HEAPF32[n>>2]=r;break;case 5:HEAP32[n>>2]=Math.fround(r);break}else for(var a=0;a<r.length;a++)switch(_){case 0:HEAP32[n+a*4>>2]=r[a];break;case 2:HEAPF32[n+a*4>>2]=r[a];break;case 5:HEAP32[n+a*4>>2]=Math.fround(r[a]);break}};Module.emscriptenWebGLGetVertexAttrib=emscriptenWebGLGetVertexAttrib;var _glGetVertexAttribfv=(t,e,n)=>{emscriptenWebGLGetVertexAttrib(t,e,n,2)};Module._glGetVertexAttribfv=_glGetVertexAttribfv,_glGetVertexAttribfv.sig="viip";var _emscripten_glGetVertexAttribfv=_glGetVertexAttribfv;Module._emscripten_glGetVertexAttribfv=_emscripten_glGetVertexAttribfv;var _glGetVertexAttribiv=(t,e,n)=>{emscriptenWebGLGetVertexAttrib(t,e,n,5)};Module._glGetVertexAttribiv=_glGetVertexAttribiv,_glGetVertexAttribiv.sig="viip";var _emscripten_glGetVertexAttribiv=_glGetVertexAttribiv;Module._emscripten_glGetVertexAttribiv=_emscripten_glGetVertexAttribiv;function _glHint(t,e){GLctx.hint(t,e)}Module._glHint=_glHint,_glHint.sig="vii";var _emscripten_glHint=_glHint;Module._emscripten_glHint=_emscripten_glHint;var _glIsBuffer=t=>{var e=GL.buffers[t];return e?GLctx.isBuffer(e):0};Module._glIsBuffer=_glIsBuffer,_glIsBuffer.sig="ii";var _emscripten_glIsBuffer=_glIsBuffer;Module._emscripten_glIsBuffer=_emscripten_glIsBuffer;function _glIsEnabled(t){return GLctx.isEnabled(t)}Module._glIsEnabled=_glIsEnabled,_glIsEnabled.sig="ii";var _emscripten_glIsEnabled=_glIsEnabled;Module._emscripten_glIsEnabled=_emscripten_glIsEnabled;var _glIsFramebuffer=t=>{var e=GL.framebuffers[t];return e?GLctx.isFramebuffer(e):0};Module._glIsFramebuffer=_glIsFramebuffer,_glIsFramebuffer.sig="ii";var _emscripten_glIsFramebuffer=_glIsFramebuffer;Module._emscripten_glIsFramebuffer=_emscripten_glIsFramebuffer;var _glIsProgram=t=>(t=GL.programs[t],t?GLctx.isProgram(t):0);Module._glIsProgram=_glIsProgram,_glIsProgram.sig="ii";var _emscripten_glIsProgram=_glIsProgram;Module._emscripten_glIsProgram=_emscripten_glIsProgram;var _glIsQueryEXT=t=>{var e=GL.queries[t];return e?GLctx.disjointTimerQueryExt.isQueryEXT(e):0};Module._glIsQueryEXT=_glIsQueryEXT,_glIsQueryEXT.sig="ii";var _emscripten_glIsQueryEXT=_glIsQueryEXT;Module._emscripten_glIsQueryEXT=_emscripten_glIsQueryEXT;var _glIsRenderbuffer=t=>{var e=GL.renderbuffers[t];return e?GLctx.isRenderbuffer(e):0};Module._glIsRenderbuffer=_glIsRenderbuffer,_glIsRenderbuffer.sig="ii";var _emscripten_glIsRenderbuffer=_glIsRenderbuffer;Module._emscripten_glIsRenderbuffer=_emscripten_glIsRenderbuffer;var _glIsShader=t=>{var e=GL.shaders[t];return e?GLctx.isShader(e):0};Module._glIsShader=_glIsShader,_glIsShader.sig="ii";var _emscripten_glIsShader=_glIsShader;Module._emscripten_glIsShader=_emscripten_glIsShader;var _glIsTexture=t=>{var e=GL.textures[t];return e?GLctx.isTexture(e):0};Module._glIsTexture=_glIsTexture,_glIsTexture.sig="ii";var _emscripten_glIsTexture=_glIsTexture;Module._emscripten_glIsTexture=_emscripten_glIsTexture;var _glIsVertexArray=t=>{var e=GL.vaos[t];return e?GLctx.isVertexArray(e):0};Module._glIsVertexArray=_glIsVertexArray,_glIsVertexArray.sig="ii";var _glIsVertexArrayOES=_glIsVertexArray;Module._glIsVertexArrayOES=_glIsVertexArrayOES,_glIsVertexArrayOES.sig="ii";var _emscripten_glIsVertexArrayOES=_glIsVertexArrayOES;Module._emscripten_glIsVertexArrayOES=_emscripten_glIsVertexArrayOES;function _glLineWidth(t){GLctx.lineWidth(t)}Module._glLineWidth=_glLineWidth,_glLineWidth.sig="vf";var _emscripten_glLineWidth=_glLineWidth;Module._emscripten_glLineWidth=_emscripten_glLineWidth;var _glLinkProgram=t=>{t=GL.programs[t],GLctx.linkProgram(t),t.uniformLocsById=0,t.uniformSizeAndIdsByName={}};Module._glLinkProgram=_glLinkProgram,_glLinkProgram.sig="vi";var _emscripten_glLinkProgram=_glLinkProgram;Module._emscripten_glLinkProgram=_emscripten_glLinkProgram;var _glPixelStorei=(t,e)=>{t==3317&&(GL.unpackAlignment=e),GLctx.pixelStorei(t,e)};Module._glPixelStorei=_glPixelStorei,_glPixelStorei.sig="vii";var _emscripten_glPixelStorei=_glPixelStorei;Module._emscripten_glPixelStorei=_emscripten_glPixelStorei;function _glPolygonOffset(t,e){GLctx.polygonOffset(t,e)}Module._glPolygonOffset=_glPolygonOffset,_glPolygonOffset.sig="vff";var _emscripten_glPolygonOffset=_glPolygonOffset;Module._emscripten_glPolygonOffset=_emscripten_glPolygonOffset;var _glQueryCounterEXT=(t,e)=>{GLctx.disjointTimerQueryExt.queryCounterEXT(GL.queries[t],e)};Module._glQueryCounterEXT=_glQueryCounterEXT,_glQueryCounterEXT.sig="vii";var _emscripten_glQueryCounterEXT=_glQueryCounterEXT;Module._emscripten_glQueryCounterEXT=_emscripten_glQueryCounterEXT;var computeUnpackAlignedImageSize=(t,e,n,_)=>{function r(l,p){return l+p-1&-p}var a=t*n,o=r(a,_);return e*o};Module.computeUnpackAlignedImageSize=computeUnpackAlignedImageSize;var colorChannelsInGlTextureFormat=t=>{var e={5:3,6:4,8:2,29502:3,29504:4};return e[t-6402]||1};Module.colorChannelsInGlTextureFormat=colorChannelsInGlTextureFormat;var heapObjectForWebGLType=t=>(t-=5120,t==1?HEAPU8:t==4?HEAP32:t==6?HEAPF32:t==5||t==28922?HEAPU32:HEAPU16);Module.heapObjectForWebGLType=heapObjectForWebGLType;var heapAccessShiftForWebGLHeap=t=>31-Math.clz32(t.BYTES_PER_ELEMENT);Module.heapAccessShiftForWebGLHeap=heapAccessShiftForWebGLHeap;var emscriptenWebGLGetTexPixelData=(t,e,n,_,r,a)=>{var o=heapObjectForWebGLType(t),l=heapAccessShiftForWebGLHeap(o),p=1<<l,c=colorChannelsInGlTextureFormat(e)*p,I=computeUnpackAlignedImageSize(n,_,c,GL.unpackAlignment);return o.subarray(r>>l,r+I>>l)};Module.emscriptenWebGLGetTexPixelData=emscriptenWebGLGetTexPixelData;var _glReadPixels=(t,e,n,_,r,a,o)=>{var l=emscriptenWebGLGetTexPixelData(a,r,n,_,o,r);if(!l){GL.recordError(1280);return}GLctx.readPixels(t,e,n,_,r,a,l)};Module._glReadPixels=_glReadPixels,_glReadPixels.sig="viiiiiip";var _emscripten_glReadPixels=_glReadPixels;Module._emscripten_glReadPixels=_emscripten_glReadPixels;var _glReleaseShaderCompiler=()=>{};Module._glReleaseShaderCompiler=_glReleaseShaderCompiler,_glReleaseShaderCompiler.sig="v";var _emscripten_glReleaseShaderCompiler=_glReleaseShaderCompiler;Module._emscripten_glReleaseShaderCompiler=_emscripten_glReleaseShaderCompiler;function _glRenderbufferStorage(t,e,n,_){GLctx.renderbufferStorage(t,e,n,_)}Module._glRenderbufferStorage=_glRenderbufferStorage,_glRenderbufferStorage.sig="viiii";var _emscripten_glRenderbufferStorage=_glRenderbufferStorage;Module._emscripten_glRenderbufferStorage=_emscripten_glRenderbufferStorage;var _glSampleCoverage=(t,e)=>{GLctx.sampleCoverage(t,!!e)};Module._glSampleCoverage=_glSampleCoverage,_glSampleCoverage.sig="vfi";var _emscripten_glSampleCoverage=_glSampleCoverage;Module._emscripten_glSampleCoverage=_emscripten_glSampleCoverage;function _glScissor(t,e,n,_){GLctx.scissor(t,e,n,_)}Module._glScissor=_glScissor,_glScissor.sig="viiii";var _emscripten_glScissor=_glScissor;Module._emscripten_glScissor=_emscripten_glScissor;var _glShaderBinary=(t,e,n,_,r)=>{GL.recordError(1280)};Module._glShaderBinary=_glShaderBinary,_glShaderBinary.sig="vipipi";var _emscripten_glShaderBinary=_glShaderBinary;Module._emscripten_glShaderBinary=_emscripten_glShaderBinary;var _glShaderSource=(t,e,n,_)=>{var r=GL.getSource(t,e,n,_);GLctx.shaderSource(GL.shaders[t],r)};Module._glShaderSource=_glShaderSource,_glShaderSource.sig="viipp";var _emscripten_glShaderSource=_glShaderSource;Module._emscripten_glShaderSource=_emscripten_glShaderSource;function _glStencilFunc(t,e,n){GLctx.stencilFunc(t,e,n)}Module._glStencilFunc=_glStencilFunc,_glStencilFunc.sig="viii";var _emscripten_glStencilFunc=_glStencilFunc;Module._emscripten_glStencilFunc=_emscripten_glStencilFunc;function _glStencilFuncSeparate(t,e,n,_){GLctx.stencilFuncSeparate(t,e,n,_)}Module._glStencilFuncSeparate=_glStencilFuncSeparate,_glStencilFuncSeparate.sig="viiii";var _emscripten_glStencilFuncSeparate=_glStencilFuncSeparate;Module._emscripten_glStencilFuncSeparate=_emscripten_glStencilFuncSeparate;function _glStencilMask(t){GLctx.stencilMask(t)}Module._glStencilMask=_glStencilMask,_glStencilMask.sig="vi";var _emscripten_glStencilMask=_glStencilMask;Module._emscripten_glStencilMask=_emscripten_glStencilMask;function _glStencilMaskSeparate(t,e){GLctx.stencilMaskSeparate(t,e)}Module._glStencilMaskSeparate=_glStencilMaskSeparate,_glStencilMaskSeparate.sig="vii";var _emscripten_glStencilMaskSeparate=_glStencilMaskSeparate;Module._emscripten_glStencilMaskSeparate=_emscripten_glStencilMaskSeparate;function _glStencilOp(t,e,n){GLctx.stencilOp(t,e,n)}Module._glStencilOp=_glStencilOp,_glStencilOp.sig="viii";var _emscripten_glStencilOp=_glStencilOp;Module._emscripten_glStencilOp=_emscripten_glStencilOp;function _glStencilOpSeparate(t,e,n,_){GLctx.stencilOpSeparate(t,e,n,_)}Module._glStencilOpSeparate=_glStencilOpSeparate,_glStencilOpSeparate.sig="viiii";var _emscripten_glStencilOpSeparate=_glStencilOpSeparate;Module._emscripten_glStencilOpSeparate=_emscripten_glStencilOpSeparate;var _glTexImage2D=(t,e,n,_,r,a,o,l,p)=>{GLctx.texImage2D(t,e,n,_,r,a,o,l,p?emscriptenWebGLGetTexPixelData(l,o,_,r,p,n):null)};Module._glTexImage2D=_glTexImage2D,_glTexImage2D.sig="viiiiiiiip";var _emscripten_glTexImage2D=_glTexImage2D;Module._emscripten_glTexImage2D=_emscripten_glTexImage2D;function _glTexParameterf(t,e,n){GLctx.texParameterf(t,e,n)}Module._glTexParameterf=_glTexParameterf,_glTexParameterf.sig="viif";var _emscripten_glTexParameterf=_glTexParameterf;Module._emscripten_glTexParameterf=_emscripten_glTexParameterf;var _glTexParameterfv=(t,e,n)=>{var _=HEAPF32[n>>2];GLctx.texParameterf(t,e,_)};Module._glTexParameterfv=_glTexParameterfv,_glTexParameterfv.sig="viip";var _emscripten_glTexParameterfv=_glTexParameterfv;Module._emscripten_glTexParameterfv=_emscripten_glTexParameterfv;function _glTexParameteri(t,e,n){GLctx.texParameteri(t,e,n)}Module._glTexParameteri=_glTexParameteri,_glTexParameteri.sig="viii";var _emscripten_glTexParameteri=_glTexParameteri;Module._emscripten_glTexParameteri=_emscripten_glTexParameteri;var _glTexParameteriv=(t,e,n)=>{var _=HEAP32[n>>2];GLctx.texParameteri(t,e,_)};Module._glTexParameteriv=_glTexParameteriv,_glTexParameteriv.sig="viip";var _emscripten_glTexParameteriv=_glTexParameteriv;Module._emscripten_glTexParameteriv=_emscripten_glTexParameteriv;var _glTexSubImage2D=(t,e,n,_,r,a,o,l,p)=>{var c=null;p&&(c=emscriptenWebGLGetTexPixelData(l,o,r,a,p,0)),GLctx.texSubImage2D(t,e,n,_,r,a,o,l,c)};Module._glTexSubImage2D=_glTexSubImage2D,_glTexSubImage2D.sig="viiiiiiiip";var _emscripten_glTexSubImage2D=_glTexSubImage2D;Module._emscripten_glTexSubImage2D=_emscripten_glTexSubImage2D;var _glUniform1f=(t,e)=>{GLctx.uniform1f(webglGetUniformLocation(t),e)};Module._glUniform1f=_glUniform1f,_glUniform1f.sig="vif";var _emscripten_glUniform1f=_glUniform1f;Module._emscripten_glUniform1f=_emscripten_glUniform1f;var miniTempWebGLFloatBuffers=[];Module.miniTempWebGLFloatBuffers=miniTempWebGLFloatBuffers;var _glUniform1fv=(t,e,n)=>{if(e<=288)for(var _=miniTempWebGLFloatBuffers[e-1],r=0;r<e;++r)_[r]=HEAPF32[n+4*r>>2];else var _=HEAPF32.subarray(n>>2,n+e*4>>2);GLctx.uniform1fv(webglGetUniformLocation(t),_)};Module._glUniform1fv=_glUniform1fv,_glUniform1fv.sig="viip";var _emscripten_glUniform1fv=_glUniform1fv;Module._emscripten_glUniform1fv=_emscripten_glUniform1fv;var _glUniform1i=(t,e)=>{GLctx.uniform1i(webglGetUniformLocation(t),e)};Module._glUniform1i=_glUniform1i,_glUniform1i.sig="vii";var _emscripten_glUniform1i=_glUniform1i;Module._emscripten_glUniform1i=_emscripten_glUniform1i;var miniTempWebGLIntBuffers=[];Module.miniTempWebGLIntBuffers=miniTempWebGLIntBuffers;var _glUniform1iv=(t,e,n)=>{if(e<=288)for(var _=miniTempWebGLIntBuffers[e-1],r=0;r<e;++r)_[r]=HEAP32[n+4*r>>2];else var _=HEAP32.subarray(n>>2,n+e*4>>2);GLctx.uniform1iv(webglGetUniformLocation(t),_)};Module._glUniform1iv=_glUniform1iv,_glUniform1iv.sig="viip";var _emscripten_glUniform1iv=_glUniform1iv;Module._emscripten_glUniform1iv=_emscripten_glUniform1iv;var _glUniform2f=(t,e,n)=>{GLctx.uniform2f(webglGetUniformLocation(t),e,n)};Module._glUniform2f=_glUniform2f,_glUniform2f.sig="viff";var _emscripten_glUniform2f=_glUniform2f;Module._emscripten_glUniform2f=_emscripten_glUniform2f;var _glUniform2fv=(t,e,n)=>{if(e<=144)for(var _=miniTempWebGLFloatBuffers[2*e-1],r=0;r<2*e;r+=2)_[r]=HEAPF32[n+4*r>>2],_[r+1]=HEAPF32[n+(4*r+4)>>2];else var _=HEAPF32.subarray(n>>2,n+e*8>>2);GLctx.uniform2fv(webglGetUniformLocation(t),_)};Module._glUniform2fv=_glUniform2fv,_glUniform2fv.sig="viip";var _emscripten_glUniform2fv=_glUniform2fv;Module._emscripten_glUniform2fv=_emscripten_glUniform2fv;var _glUniform2i=(t,e,n)=>{GLctx.uniform2i(webglGetUniformLocation(t),e,n)};Module._glUniform2i=_glUniform2i,_glUniform2i.sig="viii";var _emscripten_glUniform2i=_glUniform2i;Module._emscripten_glUniform2i=_emscripten_glUniform2i;var _glUniform2iv=(t,e,n)=>{if(e<=144)for(var _=miniTempWebGLIntBuffers[2*e-1],r=0;r<2*e;r+=2)_[r]=HEAP32[n+4*r>>2],_[r+1]=HEAP32[n+(4*r+4)>>2];else var _=HEAP32.subarray(n>>2,n+e*8>>2);GLctx.uniform2iv(webglGetUniformLocation(t),_)};Module._glUniform2iv=_glUniform2iv,_glUniform2iv.sig="viip";var _emscripten_glUniform2iv=_glUniform2iv;Module._emscripten_glUniform2iv=_emscripten_glUniform2iv;var _glUniform3f=(t,e,n,_)=>{GLctx.uniform3f(webglGetUniformLocation(t),e,n,_)};Module._glUniform3f=_glUniform3f,_glUniform3f.sig="vifff";var _emscripten_glUniform3f=_glUniform3f;Module._emscripten_glUniform3f=_emscripten_glUniform3f;var _glUniform3fv=(t,e,n)=>{if(e<=96)for(var _=miniTempWebGLFloatBuffers[3*e-1],r=0;r<3*e;r+=3)_[r]=HEAPF32[n+4*r>>2],_[r+1]=HEAPF32[n+(4*r+4)>>2],_[r+2]=HEAPF32[n+(4*r+8)>>2];else var _=HEAPF32.subarray(n>>2,n+e*12>>2);GLctx.uniform3fv(webglGetUniformLocation(t),_)};Module._glUniform3fv=_glUniform3fv,_glUniform3fv.sig="viip";var _emscripten_glUniform3fv=_glUniform3fv;Module._emscripten_glUniform3fv=_emscripten_glUniform3fv;var _glUniform3i=(t,e,n,_)=>{GLctx.uniform3i(webglGetUniformLocation(t),e,n,_)};Module._glUniform3i=_glUniform3i,_glUniform3i.sig="viiii";var _emscripten_glUniform3i=_glUniform3i;Module._emscripten_glUniform3i=_emscripten_glUniform3i;var _glUniform3iv=(t,e,n)=>{if(e<=96)for(var _=miniTempWebGLIntBuffers[3*e-1],r=0;r<3*e;r+=3)_[r]=HEAP32[n+4*r>>2],_[r+1]=HEAP32[n+(4*r+4)>>2],_[r+2]=HEAP32[n+(4*r+8)>>2];else var _=HEAP32.subarray(n>>2,n+e*12>>2);GLctx.uniform3iv(webglGetUniformLocation(t),_)};Module._glUniform3iv=_glUniform3iv,_glUniform3iv.sig="viip";var _emscripten_glUniform3iv=_glUniform3iv;Module._emscripten_glUniform3iv=_emscripten_glUniform3iv;var _glUniform4f=(t,e,n,_,r)=>{GLctx.uniform4f(webglGetUniformLocation(t),e,n,_,r)};Module._glUniform4f=_glUniform4f,_glUniform4f.sig="viffff";var _emscripten_glUniform4f=_glUniform4f;Module._emscripten_glUniform4f=_emscripten_glUniform4f;var _glUniform4fv=(t,e,n)=>{if(e<=72){var _=miniTempWebGLFloatBuffers[4*e-1],r=HEAPF32;n>>=2;for(var a=0;a<4*e;a+=4){var o=n+a;_[a]=r[o],_[a+1]=r[o+1],_[a+2]=r[o+2],_[a+3]=r[o+3]}}else var _=HEAPF32.subarray(n>>2,n+e*16>>2);GLctx.uniform4fv(webglGetUniformLocation(t),_)};Module._glUniform4fv=_glUniform4fv,_glUniform4fv.sig="viip";var _emscripten_glUniform4fv=_glUniform4fv;Module._emscripten_glUniform4fv=_emscripten_glUniform4fv;var _glUniform4i=(t,e,n,_,r)=>{GLctx.uniform4i(webglGetUniformLocation(t),e,n,_,r)};Module._glUniform4i=_glUniform4i,_glUniform4i.sig="viiiii";var _emscripten_glUniform4i=_glUniform4i;Module._emscripten_glUniform4i=_emscripten_glUniform4i;var _glUniform4iv=(t,e,n)=>{if(e<=72)for(var _=miniTempWebGLIntBuffers[4*e-1],r=0;r<4*e;r+=4)_[r]=HEAP32[n+4*r>>2],_[r+1]=HEAP32[n+(4*r+4)>>2],_[r+2]=HEAP32[n+(4*r+8)>>2],_[r+3]=HEAP32[n+(4*r+12)>>2];else var _=HEAP32.subarray(n>>2,n+e*16>>2);GLctx.uniform4iv(webglGetUniformLocation(t),_)};Module._glUniform4iv=_glUniform4iv,_glUniform4iv.sig="viip";var _emscripten_glUniform4iv=_glUniform4iv;Module._emscripten_glUniform4iv=_emscripten_glUniform4iv;var _glUniformMatrix2fv=(t,e,n,_)=>{if(e<=72)for(var r=miniTempWebGLFloatBuffers[4*e-1],a=0;a<4*e;a+=4)r[a]=HEAPF32[_+4*a>>2],r[a+1]=HEAPF32[_+(4*a+4)>>2],r[a+2]=HEAPF32[_+(4*a+8)>>2],r[a+3]=HEAPF32[_+(4*a+12)>>2];else var r=HEAPF32.subarray(_>>2,_+e*16>>2);GLctx.uniformMatrix2fv(webglGetUniformLocation(t),!!n,r)};Module._glUniformMatrix2fv=_glUniformMatrix2fv,_glUniformMatrix2fv.sig="viiip";var _emscripten_glUniformMatrix2fv=_glUniformMatrix2fv;Module._emscripten_glUniformMatrix2fv=_emscripten_glUniformMatrix2fv;var _glUniformMatrix3fv=(t,e,n,_)=>{if(e<=32)for(var r=miniTempWebGLFloatBuffers[9*e-1],a=0;a<9*e;a+=9)r[a]=HEAPF32[_+4*a>>2],r[a+1]=HEAPF32[_+(4*a+4)>>2],r[a+2]=HEAPF32[_+(4*a+8)>>2],r[a+3]=HEAPF32[_+(4*a+12)>>2],r[a+4]=HEAPF32[_+(4*a+16)>>2],r[a+5]=HEAPF32[_+(4*a+20)>>2],r[a+6]=HEAPF32[_+(4*a+24)>>2],r[a+7]=HEAPF32[_+(4*a+28)>>2],r[a+8]=HEAPF32[_+(4*a+32)>>2];else var r=HEAPF32.subarray(_>>2,_+e*36>>2);GLctx.uniformMatrix3fv(webglGetUniformLocation(t),!!n,r)};Module._glUniformMatrix3fv=_glUniformMatrix3fv,_glUniformMatrix3fv.sig="viiip";var _emscripten_glUniformMatrix3fv=_glUniformMatrix3fv;Module._emscripten_glUniformMatrix3fv=_emscripten_glUniformMatrix3fv;var _glUniformMatrix4fv=(t,e,n,_)=>{if(e<=18){var r=miniTempWebGLFloatBuffers[16*e-1],a=HEAPF32;_>>=2;for(var o=0;o<16*e;o+=16){var l=_+o;r[o]=a[l],r[o+1]=a[l+1],r[o+2]=a[l+2],r[o+3]=a[l+3],r[o+4]=a[l+4],r[o+5]=a[l+5],r[o+6]=a[l+6],r[o+7]=a[l+7],r[o+8]=a[l+8],r[o+9]=a[l+9],r[o+10]=a[l+10],r[o+11]=a[l+11],r[o+12]=a[l+12],r[o+13]=a[l+13],r[o+14]=a[l+14],r[o+15]=a[l+15]}}else var r=HEAPF32.subarray(_>>2,_+e*64>>2);GLctx.uniformMatrix4fv(webglGetUniformLocation(t),!!n,r)};Module._glUniformMatrix4fv=_glUniformMatrix4fv,_glUniformMatrix4fv.sig="viiip";var _emscripten_glUniformMatrix4fv=_glUniformMatrix4fv;Module._emscripten_glUniformMatrix4fv=_emscripten_glUniformMatrix4fv;var _glUseProgram=t=>{t=GL.programs[t],GLctx.useProgram(t),GLctx.currentProgram=t};Module._glUseProgram=_glUseProgram,_glUseProgram.sig="vi";var _emscripten_glUseProgram=_glUseProgram;Module._emscripten_glUseProgram=_emscripten_glUseProgram;var _glValidateProgram=t=>{GLctx.validateProgram(GL.programs[t])};Module._glValidateProgram=_glValidateProgram,_glValidateProgram.sig="vi";var _emscripten_glValidateProgram=_glValidateProgram;Module._emscripten_glValidateProgram=_emscripten_glValidateProgram;function _glVertexAttrib1f(t,e){GLctx.vertexAttrib1f(t,e)}Module._glVertexAttrib1f=_glVertexAttrib1f,_glVertexAttrib1f.sig="vif";var _emscripten_glVertexAttrib1f=_glVertexAttrib1f;Module._emscripten_glVertexAttrib1f=_emscripten_glVertexAttrib1f;var _glVertexAttrib1fv=(t,e)=>{GLctx.vertexAttrib1f(t,HEAPF32[e>>2])};Module._glVertexAttrib1fv=_glVertexAttrib1fv,_glVertexAttrib1fv.sig="vip";var _emscripten_glVertexAttrib1fv=_glVertexAttrib1fv;Module._emscripten_glVertexAttrib1fv=_emscripten_glVertexAttrib1fv;function _glVertexAttrib2f(t,e,n){GLctx.vertexAttrib2f(t,e,n)}Module._glVertexAttrib2f=_glVertexAttrib2f,_glVertexAttrib2f.sig="viff";var _emscripten_glVertexAttrib2f=_glVertexAttrib2f;Module._emscripten_glVertexAttrib2f=_emscripten_glVertexAttrib2f;var _glVertexAttrib2fv=(t,e)=>{GLctx.vertexAttrib2f(t,HEAPF32[e>>2],HEAPF32[e+4>>2])};Module._glVertexAttrib2fv=_glVertexAttrib2fv,_glVertexAttrib2fv.sig="vip";var _emscripten_glVertexAttrib2fv=_glVertexAttrib2fv;Module._emscripten_glVertexAttrib2fv=_emscripten_glVertexAttrib2fv;function _glVertexAttrib3f(t,e,n,_){GLctx.vertexAttrib3f(t,e,n,_)}Module._glVertexAttrib3f=_glVertexAttrib3f,_glVertexAttrib3f.sig="vifff";var _emscripten_glVertexAttrib3f=_glVertexAttrib3f;Module._emscripten_glVertexAttrib3f=_emscripten_glVertexAttrib3f;var _glVertexAttrib3fv=(t,e)=>{GLctx.vertexAttrib3f(t,HEAPF32[e>>2],HEAPF32[e+4>>2],HEAPF32[e+8>>2])};Module._glVertexAttrib3fv=_glVertexAttrib3fv,_glVertexAttrib3fv.sig="vip";var _emscripten_glVertexAttrib3fv=_glVertexAttrib3fv;Module._emscripten_glVertexAttrib3fv=_emscripten_glVertexAttrib3fv;function _glVertexAttrib4f(t,e,n,_,r){GLctx.vertexAttrib4f(t,e,n,_,r)}Module._glVertexAttrib4f=_glVertexAttrib4f,_glVertexAttrib4f.sig="viffff";var _emscripten_glVertexAttrib4f=_glVertexAttrib4f;Module._emscripten_glVertexAttrib4f=_emscripten_glVertexAttrib4f;var _glVertexAttrib4fv=(t,e)=>{GLctx.vertexAttrib4f(t,HEAPF32[e>>2],HEAPF32[e+4>>2],HEAPF32[e+8>>2],HEAPF32[e+12>>2])};Module._glVertexAttrib4fv=_glVertexAttrib4fv,_glVertexAttrib4fv.sig="vip";var _emscripten_glVertexAttrib4fv=_glVertexAttrib4fv;Module._emscripten_glVertexAttrib4fv=_emscripten_glVertexAttrib4fv;var _glVertexAttribDivisor=(t,e)=>{GLctx.vertexAttribDivisor(t,e)};Module._glVertexAttribDivisor=_glVertexAttribDivisor,_glVertexAttribDivisor.sig="vii";var _glVertexAttribDivisorANGLE=_glVertexAttribDivisor;Module._glVertexAttribDivisorANGLE=_glVertexAttribDivisorANGLE;var _emscripten_glVertexAttribDivisorANGLE=_glVertexAttribDivisorANGLE;Module._emscripten_glVertexAttribDivisorANGLE=_emscripten_glVertexAttribDivisorANGLE;var _glVertexAttribPointer=(t,e,n,_,r,a)=>{GLctx.vertexAttribPointer(t,e,n,!!_,r,a)};Module._glVertexAttribPointer=_glVertexAttribPointer,_glVertexAttribPointer.sig="viiiiip";var _emscripten_glVertexAttribPointer=_glVertexAttribPointer;Module._emscripten_glVertexAttribPointer=_emscripten_glVertexAttribPointer;function _glViewport(t,e,n,_){GLctx.viewport(t,e,n,_)}Module._glViewport=_glViewport,_glViewport.sig="viiii";var _emscripten_glViewport=_glViewport;Module._emscripten_glViewport=_emscripten_glViewport;var _emscripten_memcpy_js=(t,e,n)=>HEAPU8.copyWithin(t,e,e+n);Module._emscripten_memcpy_js=_emscripten_memcpy_js,_emscripten_memcpy_js.sig="vppp";var _emscripten_out=t=>out(UTF8ToString(t));Module._emscripten_out=_emscripten_out,_emscripten_out.sig="vp";function handleAllocatorInit(){Object.assign(HandleAllocator.prototype,{get(t){return this.allocated[t]},has(t){return this.allocated[t]!==void 0},allocate(t){var e=this.freelist.pop()||this.allocated.length;return this.allocated[e]=t,e},free(t){this.allocated[t]=void 0,this.freelist.push(t)}})}Module.handleAllocatorInit=handleAllocatorInit;function HandleAllocator(){this.allocated=[void 0],this.freelist=[]}Module.HandleAllocator=HandleAllocator;var promiseMap=new HandleAllocator;Module.promiseMap=promiseMap;var makePromise=()=>{var t={};return t.promise=new Promise((e,n)=>{t.reject=n,t.resolve=e}),t.id=promiseMap.allocate(t),t};Module.makePromise=makePromise;var _emscripten_promise_create=()=>makePromise().id;Module._emscripten_promise_create=_emscripten_promise_create,_emscripten_promise_create.sig="p";var _emscripten_promise_destroy=t=>{promiseMap.free(t)};Module._emscripten_promise_destroy=_emscripten_promise_destroy,_emscripten_promise_destroy.sig="vp";var getPromise=t=>promiseMap.get(t).promise;Module.getPromise=getPromise;var _emscripten_promise_resolve=(t,e,n)=>{var _=promiseMap.get(t);switch(e){case 0:_.resolve(n);return;case 1:_.resolve(getPromise(n));return;case 2:_.resolve(getPromise(n)),_emscripten_promise_destroy(n);return;case 3:_.reject(n);return}};Module._emscripten_promise_resolve=_emscripten_promise_resolve,_emscripten_promise_resolve.sig="vpip";var growMemory=t=>{var e=wasmMemory.buffer,n=(t-e.byteLength+65535)/65536;try{return wasmMemory.grow(n),updateMemoryViews(),1}catch{}};Module.growMemory=growMemory;var _emscripten_resize_heap=t=>{var e=HEAPU8.length;t>>>=0;var n=getHeapMax();if(t>n)return!1;for(var _=(p,c)=>p+(c-p%c)%c,r=1;r<=4;r*=2){var a=e*(1+.2/r);a=Math.min(a,t+100663296);var o=Math.min(n,_(Math.max(t,a),65536)),l=growMemory(o);if(l)return!0}return!1};Module._emscripten_resize_heap=_emscripten_resize_heap,_emscripten_resize_heap.sig="ip";var getExecutableName=()=>thisProgram||"./this.program";Module.getExecutableName=getExecutableName;var getEnvStrings=()=>{if(!getEnvStrings.strings){var t=(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",e={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:t,_:getExecutableName()};for(var n in ENV)ENV[n]===void 0?delete e[n]:e[n]=ENV[n];var _=[];for(var n in e)_.push(`${n}=${e[n]}`);getEnvStrings.strings=_}return getEnvStrings.strings};Module.getEnvStrings=getEnvStrings;var stringToAscii=(t,e)=>{for(var n=0;n<t.length;++n)HEAP8[e++>>0]=t.charCodeAt(n);HEAP8[e>>0]=0};Module.stringToAscii=stringToAscii;var _environ_get=(t,e)=>{var n=0;return getEnvStrings().forEach((_,r)=>{var a=e+n;HEAPU32[t+r*4>>2]=a,stringToAscii(_,a),n+=_.length+1}),0};Module._environ_get=_environ_get,_environ_get.sig="ipp";var _environ_sizes_get=(t,e)=>{var n=getEnvStrings();HEAPU32[t>>2]=n.length;var _=0;return n.forEach(r=>_+=r.length+1),HEAPU32[e>>2]=_,0};Module._environ_sizes_get=_environ_sizes_get,_environ_sizes_get.sig="ipp";function _fd_close(t){try{var e=SYSCALLS.getStreamFromFD(t);return FS.close(e),0}catch(n){if(typeof FS>"u"||n.name!=="ErrnoError")throw n;return n.errno}}Module._fd_close=_fd_close,_fd_close.sig="ii";function _fd_fdstat_get(t,e){try{var n=0,_=0,r=0,a=SYSCALLS.getStreamFromFD(t),o=a.tty?2:FS.isDir(a.mode)?3:FS.isLink(a.mode)?7:4;return HEAP8[e>>0]=o,HEAP16[e+2>>1]=r,HEAP64[e+8>>3]=BigInt(n),HEAP64[e+16>>3]=BigInt(_),0}catch(l){if(typeof FS>"u"||l.name!=="ErrnoError")throw l;return l.errno}}Module._fd_fdstat_get=_fd_fdstat_get,_fd_fdstat_get.sig="iip";var doReadv=(t,e,n,_)=>{for(var r=0,a=0;a<n;a++){var o=HEAPU32[e>>2],l=HEAPU32[e+4>>2];e+=8;var p=FS.read(t,HEAP8,o,l,_);if(p<0)return-1;if(r+=p,p<l)break;typeof _<"u"&&(_+=p)}return r};Module.doReadv=doReadv;function _fd_pread(t,e,n,_,r){_=bigintToI53Checked(_);try{if(isNaN(_))return 61;var a=SYSCALLS.getStreamFromFD(t),o=doReadv(a,e,n,_);return HEAPU32[r>>2]=o,0}catch(l){if(typeof FS>"u"||l.name!=="ErrnoError")throw l;return l.errno}}Module._fd_pread=_fd_pread,_fd_pread.sig="iippjp";var doWritev=(t,e,n,_)=>{for(var r=0,a=0;a<n;a++){var o=HEAPU32[e>>2],l=HEAPU32[e+4>>2];e+=8;var p=FS.write(t,HEAP8,o,l,_);if(p<0)return-1;r+=p,typeof _<"u"&&(_+=p)}return r};Module.doWritev=doWritev;function _fd_pwrite(t,e,n,_,r){_=bigintToI53Checked(_);try{if(isNaN(_))return 61;var a=SYSCALLS.getStreamFromFD(t),o=doWritev(a,e,n,_);return HEAPU32[r>>2]=o,0}catch(l){if(typeof FS>"u"||l.name!=="ErrnoError")throw l;return l.errno}}Module._fd_pwrite=_fd_pwrite,_fd_pwrite.sig="iippjp";function _fd_read(t,e,n,_){try{var r=SYSCALLS.getStreamFromFD(t),a=doReadv(r,e,n);return HEAPU32[_>>2]=a,0}catch(o){if(typeof FS>"u"||o.name!=="ErrnoError")throw o;return o.errno}}Module._fd_read=_fd_read,_fd_read.sig="iippp";function _fd_seek(t,e,n,_){e=bigintToI53Checked(e);try{if(isNaN(e))return 61;var r=SYSCALLS.getStreamFromFD(t);return FS.llseek(r,e,n),HEAP64[_>>3]=BigInt(r.position),r.getdents&&e===0&&n===0&&(r.getdents=null),0}catch(a){if(typeof FS>"u"||a.name!=="ErrnoError")throw a;return a.errno}}Module._fd_seek=_fd_seek,_fd_seek.sig="iijip";function _fd_sync(t){try{var e=SYSCALLS.getStreamFromFD(t);return e.stream_ops&&e.stream_ops.fsync?e.stream_ops.fsync(e):0}catch(n){if(typeof FS>"u"||n.name!=="ErrnoError")throw n;return n.errno}}Module._fd_sync=_fd_sync,_fd_sync.sig="ii";function _fd_write(t,e,n,_){try{var r=SYSCALLS.getStreamFromFD(t),a=doWritev(r,e,n);return HEAPU32[_>>2]=a,0}catch(o){if(typeof FS>"u"||o.name!=="ErrnoError")throw o;return o.errno}}Module._fd_write=_fd_write,_fd_write.sig="iippp";var _getaddrinfo=(t,e,n,_)=>{var r=[],a=null,o=0,l=0,p=0,c=0,I=0,A=0,m,E;function f(R,h,w,g,O,W){var k,Z,v,tt;return Z=R===10?28:16,O=R===10?inetNtop6(O):inetNtop4(O),k=_malloc(Z),tt=writeSockaddr(k,R,O,W),assert(!tt),v=_malloc(32),HEAP32[v+4>>2]=R,HEAP32[v+8>>2]=h,HEAP32[v+12>>2]=w,HEAPU32[v+24>>2]=g,HEAPU32[v+20>>2]=k,R===10?HEAP32[v+16>>2]=28:HEAP32[v+16>>2]=16,HEAP32[v+28>>2]=0,v}if(n&&(p=HEAP32[n>>2],c=HEAP32[n+4>>2],I=HEAP32[n+8>>2],A=HEAP32[n+12>>2]),I&&!A&&(A=I===2?17:6),!I&&A&&(I=A===17?2:1),A===0&&(A=6),I===0&&(I=1),!t&&!e)return-2;if(p&-1088||n!==0&&HEAP32[n>>2]&2&&!t)return-1;if(p&32)return-2;if(I!==0&&I!==1&&I!==2)return-7;if(c!==0&&c!==2&&c!==10)return-6;if(e&&(e=UTF8ToString(e),l=parseInt(e,10),isNaN(l)))return p&1024?-2:-8;if(!t)return c===0&&(c=2),p&1||(c===2?o=_htonl(2130706433):o=[0,0,0,1]),m=f(c,I,A,null,o,l),HEAPU32[_>>2]=m,0;if(t=UTF8ToString(t),o=inetPton4(t),o!==null)if(c===0||c===2)c=2;else if(c===10&&p&8)o=[0,0,_htonl(65535),o],c=10;else return-2;else if(o=inetPton6(t),o!==null)if(c===0||c===10)c=10;else return-2;return o!=null?(m=f(c,I,A,t,o,l),HEAPU32[_>>2]=m,0):p&4?-2:(t=DNS.lookup_name(t),o=inetPton4(t),c===0?c=2:c===10&&(o=[0,0,_htonl(65535),o]),m=f(c,I,A,null,o,l),HEAPU32[_>>2]=m,0)};Module._getaddrinfo=_getaddrinfo,_getaddrinfo.sig="ipppp";var _getentropy=(t,e)=>(randomFill(HEAPU8.subarray(t,t+e)),0);Module._getentropy=_getentropy,_getentropy.sig="ipp";var getHostByName=t=>{var e=_malloc(20),n=stringToNewUTF8(t);HEAPU32[e>>2]=n;var _=_malloc(4);HEAPU32[_>>2]=0,HEAPU32[e+4>>2]=_;var r=2;HEAP32[e+8>>2]=r,HEAP32[e+12>>2]=4;var a=_malloc(12);return HEAPU32[a>>2]=a+8,HEAPU32[a+4>>2]=0,HEAP32[a+8>>2]=inetPton4(DNS.lookup_name(t)),HEAPU32[e+16>>2]=a,e};Module.getHostByName=getHostByName;var _gethostbyaddr=(t,e,n)=>{if(n!==2)return setErrNo(5),null;t=HEAP32[t>>2];var _=inetNtop4(t),r=DNS.lookup_addr(_);return r&&(_=r),getHostByName(_)};Module._gethostbyaddr=_gethostbyaddr,_gethostbyaddr.sig="ppii";var _gethostbyname=t=>getHostByName(UTF8ToString(t));Module._gethostbyname=_gethostbyname,_gethostbyname.sig="pp";var _getnameinfo=(t,e,n,_,r,a,o)=>{var l=readSockaddr(t,e);if(l.errno)return-6;var p=l.port,c=l.addr,I=!1;if(n&&_){var A;if(o&1||!(A=DNS.lookup_addr(c))){if(o&8)return-2}else c=A;var m=stringToUTF8(c,n,_);m+1>=_&&(I=!0)}if(r&&a){p=""+p;var m=stringToUTF8(p,r,a);m+1>=a&&(I=!0)}return I?-12:0};Module._getnameinfo=_getnameinfo,_getnameinfo.sig="ipipipii";var Protocols={list:[],map:{}};Module.Protocols=Protocols;var _setprotoent=t=>{function e(a,o,l){var p=_malloc(a.length+1);stringToAscii(a,p);for(var c=0,I=l.length,A=_malloc((I+1)*4),m=0;m<I;m++,c+=4){var E=l[m],f=_malloc(E.length+1);stringToAscii(E,f),HEAPU32[A+c>>2]=f}HEAPU32[A+c>>2]=0;var R=_malloc(12);return HEAPU32[R>>2]=p,HEAPU32[R+4>>2]=A,HEAP32[R+8>>2]=o,R}var n=Protocols.list,_=Protocols.map;if(n.length===0){var r=e("tcp",6,["TCP"]);n.push(r),_.tcp=_[6]=r,r=e("udp",17,["UDP"]),n.push(r),_.udp=_[17]=r}_setprotoent.index=0};Module._setprotoent=_setprotoent,_setprotoent.sig="vi";var _getprotobyname=t=>{t=UTF8ToString(t),_setprotoent(!0);var e=Protocols.map[t];return e};Module._getprotobyname=_getprotobyname,_getprotobyname.sig="pp";var arraySum=(t,e)=>{for(var n=0,_=0;_<=e;n+=t[_++]);return n};Module.arraySum=arraySum;var MONTH_DAYS_LEAP=[31,29,31,30,31,30,31,31,30,31,30,31];Module.MONTH_DAYS_LEAP=MONTH_DAYS_LEAP;var MONTH_DAYS_REGULAR=[31,28,31,30,31,30,31,31,30,31,30,31];Module.MONTH_DAYS_REGULAR=MONTH_DAYS_REGULAR;var addDays=(t,e)=>{for(var n=new Date(t.getTime());e>0;){var _=isLeapYear(n.getFullYear()),r=n.getMonth(),a=(_?MONTH_DAYS_LEAP:MONTH_DAYS_REGULAR)[r];if(e>a-n.getDate())e-=a-n.getDate()+1,n.setDate(1),r<11?n.setMonth(r+1):(n.setMonth(0),n.setFullYear(n.getFullYear()+1));else return n.setDate(n.getDate()+e),n}return n};Module.addDays=addDays;var writeArrayToMemory=(t,e)=>{HEAP8.set(t,e)};Module.writeArrayToMemory=writeArrayToMemory;var _strftime=(t,e,n,_)=>{var r=HEAPU32[_+40>>2],a={tm_sec:HEAP32[_>>2],tm_min:HEAP32[_+4>>2],tm_hour:HEAP32[_+8>>2],tm_mday:HEAP32[_+12>>2],tm_mon:HEAP32[_+16>>2],tm_year:HEAP32[_+20>>2],tm_wday:HEAP32[_+24>>2],tm_yday:HEAP32[_+28>>2],tm_isdst:HEAP32[_+32>>2],tm_gmtoff:HEAP32[_+36>>2],tm_zone:r?UTF8ToString(r):""},o=UTF8ToString(n),l={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var p in l)o=o.replace(new RegExp(p,"g"),l[p]);var c=["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],I=["January","February","March","April","May","June","July","August","September","October","November","December"];function A(g,O,W){for(var k=typeof g=="number"?g.toString():g||"";k.length<O;)k=W[0]+k;return k}function m(g,O){return A(g,O,"0")}function E(g,O){function W(Z){return Z<0?-1:Z>0?1:0}var k;return(k=W(g.getFullYear()-O.getFullYear()))===0&&(k=W(g.getMonth()-O.getMonth()))===0&&(k=W(g.getDate()-O.getDate())),k}function f(g){switch(g.getDay()){case 0:return new Date(g.getFullYear()-1,11,29);case 1:return g;case 2:return new Date(g.getFullYear(),0,3);case 3:return new Date(g.getFullYear(),0,2);case 4:return new Date(g.getFullYear(),0,1);case 5:return new Date(g.getFullYear()-1,11,31);case 6:return new Date(g.getFullYear()-1,11,30)}}function R(g){var O=addDays(new Date(g.tm_year+1900,0,1),g.tm_yday),W=new Date(O.getFullYear(),0,4),k=new Date(O.getFullYear()+1,0,4),Z=f(W),v=f(k);return E(Z,O)<=0?E(v,O)<=0?O.getFullYear()+1:O.getFullYear():O.getFullYear()-1}var h={"%a":g=>c[g.tm_wday].substring(0,3),"%A":g=>c[g.tm_wday],"%b":g=>I[g.tm_mon].substring(0,3),"%B":g=>I[g.tm_mon],"%C":g=>{var O=g.tm_year+1900;return m(O/100|0,2)},"%d":g=>m(g.tm_mday,2),"%e":g=>A(g.tm_mday,2," "),"%g":g=>R(g).toString().substring(2),"%G":g=>R(g),"%H":g=>m(g.tm_hour,2),"%I":g=>{var O=g.tm_hour;return O==0?O=12:O>12&&(O-=12),m(O,2)},"%j":g=>m(g.tm_mday+arraySum(isLeapYear(g.tm_year+1900)?MONTH_DAYS_LEAP:MONTH_DAYS_REGULAR,g.tm_mon-1),3),"%m":g=>m(g.tm_mon+1,2),"%M":g=>m(g.tm_min,2),"%n":()=>`
`,"%p":g=>g.tm_hour>=0&&g.tm_hour<12?"AM":"PM","%S":g=>m(g.tm_sec,2),"%t":()=>"	","%u":g=>g.tm_wday||7,"%U":g=>{var O=g.tm_yday+7-g.tm_wday;return m(Math.floor(O/7),2)},"%V":g=>{var O=Math.floor((g.tm_yday+7-(g.tm_wday+6)%7)/7);if((g.tm_wday+371-g.tm_yday-2)%7<=2&&O++,O){if(O==53){var k=(g.tm_wday+371-g.tm_yday)%7;k!=4&&(k!=3||!isLeapYear(g.tm_year))&&(O=1)}}else{O=52;var W=(g.tm_wday+7-g.tm_yday-1)%7;(W==4||W==5&&isLeapYear(g.tm_year%400-1))&&O++}return m(O,2)},"%w":g=>g.tm_wday,"%W":g=>{var O=g.tm_yday+7-(g.tm_wday+6)%7;return m(Math.floor(O/7),2)},"%y":g=>(g.tm_year+1900).toString().substring(2),"%Y":g=>g.tm_year+1900,"%z":g=>{var O=g.tm_gmtoff,W=O>=0;return O=Math.abs(O)/60,O=O/60*100+O%60,(W?"+":"-")+("0000"+O).slice(-4)},"%Z":g=>g.tm_zone,"%%":()=>"%"};o=o.replace(/%%/g,"\0\0");for(var p in h)o.includes(p)&&(o=o.replace(new RegExp(p,"g"),h[p](a)));o=o.replace(/\0\0/g,"%");var w=intArrayFromString(o,!1);return w.length>e?0:(writeArrayToMemory(w,t),w.length-1)};Module._strftime=_strftime,_strftime.sig="ppppp";var _strftime_l=(t,e,n,_,r)=>_strftime(t,e,n,_);Module._strftime_l=_strftime_l,_strftime_l.sig="pppppp";var _system=t=>{if(ENVIRONMENT_IS_NODE){if(!t)return 1;var e=UTF8ToString(t);if(!e.length)return 0;var n=Sn(),_=n.spawnSync(e,[],{shell:!0,stdio:"inherit"}),r=(o,l)=>o<<8|l;if(_.status===null){var a=o=>{switch(o){case"SIGHUP":return 1;case"SIGINT":return 2;case"SIGQUIT":return 3;case"SIGFPE":return 8;case"SIGKILL":return 9;case"SIGALRM":return 14;case"SIGTERM":return 15}return 2};return r(0,a(_.signal))}return r(_.status,0)}return t?(setErrNo(52),-1):0};Module._system=_system,_system.sig="ip";var FS_unlink=t=>FS.unlink(t);Module.FS_unlink=FS_unlink;var writeI53ToI64Clamped=(t,e)=>{e>9223372036854776e3?(HEAPU32[t>>2]=4294967295,HEAPU32[t+4>>2]=2147483647):e<-9223372036854776e3?(HEAPU32[t>>2]=0,HEAPU32[t+4>>2]=2147483648):writeI53ToI64(t,e)};Module.writeI53ToI64Clamped=writeI53ToI64Clamped;var writeI53ToI64Signaling=(t,e)=>{if(e>9223372036854776e3||e<-9223372036854776e3)throw`RangeError: ${e}`;writeI53ToI64(t,e)};Module.writeI53ToI64Signaling=writeI53ToI64Signaling;var writeI53ToU64Clamped=(t,e)=>{e>18446744073709552e3?(HEAPU32[t>>2]=4294967295,HEAPU32[t+4>>2]=4294967295):e<0?(HEAPU32[t>>2]=0,HEAPU32[t+4>>2]=0):writeI53ToI64(t,e)};Module.writeI53ToU64Clamped=writeI53ToU64Clamped;var writeI53ToU64Signaling=(t,e)=>{if(e<0||e>18446744073709552e3)throw`RangeError: ${e}`;writeI53ToI64(t,e)};Module.writeI53ToU64Signaling=writeI53ToU64Signaling;var readI53FromU64=t=>HEAPU32[t>>2]+HEAPU32[t+4>>2]*4294967296;Module.readI53FromU64=readI53FromU64;var convertI32PairToI53=(t,e)=>(t>>>0)+e*4294967296;Module.convertI32PairToI53=convertI32PairToI53;var convertI32PairToI53Checked=(t,e)=>e+2097152>>>0<4194305-!!t?(t>>>0)+e*4294967296:NaN;Module.convertI32PairToI53Checked=convertI32PairToI53Checked;var convertU32PairToI53=(t,e)=>(t>>>0)+(e>>>0)*4294967296;Module.convertU32PairToI53=convertU32PairToI53;var ptrToString=t=>(t>>>=0,"0x"+t.toString(16).padStart(8,"0"));Module.ptrToString=ptrToString;var _emscripten_notify_memory_growth=t=>{updateMemoryViews()};Module._emscripten_notify_memory_growth=_emscripten_notify_memory_growth,_emscripten_notify_memory_growth.sig="vp";var ___asctime_r=(t,e)=>{var n={tm_sec:HEAP32[t>>2],tm_min:HEAP32[t+4>>2],tm_hour:HEAP32[t+8>>2],tm_mday:HEAP32[t+12>>2],tm_mon:HEAP32[t+16>>2],tm_year:HEAP32[t+20>>2],tm_wday:HEAP32[t+24>>2]},_=["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],r=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],a=_[n.tm_wday]+" "+r[n.tm_mon]+(n.tm_mday<10?"  ":" ")+n.tm_mday+(n.tm_hour<10?" 0":" ")+n.tm_hour+(n.tm_min<10?":0":":")+n.tm_min+(n.tm_sec<10?":0":":")+n.tm_sec+" "+(1900+n.tm_year)+`
`;return stringToUTF8(a,e,26),e};Module.___asctime_r=___asctime_r,___asctime_r.sig="ppp";var _strptime=(t,e,n)=>{for(var _=UTF8ToString(e),r="\\!@#$^&*()+=-[]/{}|:<>?,.",a=0,o=r.length;a<o;++a)_=_.replace(new RegExp("\\"+r[a],"g"),"\\"+r[a]);var l={"%A":"%a","%B":"%b","%c":"%a %b %d %H:%M:%S %Y","%D":"%m\\/%d\\/%y","%e":"%d","%F":"%Y-%m-%d","%h":"%b","%R":"%H\\:%M","%r":"%I\\:%M\\:%S\\s%p","%T":"%H\\:%M\\:%S","%x":"%m\\/%d\\/(?:%y|%Y)","%X":"%H\\:%M\\:%S"};for(var p in l)_=_.replace(p,l[p]);var c={"%a":"(?:Sun(?:day)?)|(?:Mon(?:day)?)|(?:Tue(?:sday)?)|(?:Wed(?:nesday)?)|(?:Thu(?:rsday)?)|(?:Fri(?:day)?)|(?:Sat(?:urday)?)","%b":"(?:Jan(?:uary)?)|(?:Feb(?:ruary)?)|(?:Mar(?:ch)?)|(?:Apr(?:il)?)|May|(?:Jun(?:e)?)|(?:Jul(?:y)?)|(?:Aug(?:ust)?)|(?:Sep(?:tember)?)|(?:Oct(?:ober)?)|(?:Nov(?:ember)?)|(?:Dec(?:ember)?)","%C":"\\d\\d","%d":"0[1-9]|[1-9](?!\\d)|1\\d|2\\d|30|31","%H":"\\d(?!\\d)|[0,1]\\d|20|21|22|23","%I":"\\d(?!\\d)|0\\d|10|11|12","%j":"00[1-9]|0?[1-9](?!\\d)|0?[1-9]\\d(?!\\d)|[1,2]\\d\\d|3[0-6]\\d","%m":"0[1-9]|[1-9](?!\\d)|10|11|12","%M":"0\\d|\\d(?!\\d)|[1-5]\\d","%n":"\\s","%p":"AM|am|PM|pm|A\\.M\\.|a\\.m\\.|P\\.M\\.|p\\.m\\.","%S":"0\\d|\\d(?!\\d)|[1-5]\\d|60","%U":"0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53","%W":"0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53","%w":"[0-6]","%y":"\\d\\d","%Y":"\\d\\d\\d\\d","%%":"%","%t":"\\s"},I={JAN:0,FEB:1,MAR:2,APR:3,MAY:4,JUN:5,JUL:6,AUG:7,SEP:8,OCT:9,NOV:10,DEC:11},A={SUN:0,MON:1,TUE:2,WED:3,THU:4,FRI:5,SAT:6},m={MON:0,TUE:1,WED:2,THU:3,FRI:4,SAT:5,SUN:6};for(var E in c)_=_.replace(E,"("+E+c[E]+")");for(var f=[],a=_.indexOf("%");a>=0;a=_.indexOf("%"))f.push(_[a+1]),_=_.replace(new RegExp("\\%"+_[a+1],"g"),"");var R=new RegExp("^"+_,"i").exec(UTF8ToString(t));function h(){function G(ht,Pt,Lt){return typeof ht!="number"||isNaN(ht)?Pt:ht>=Pt?ht<=Lt?ht:Lt:Pt}return{year:G(HEAP32[n+20>>2]+1900,1970,9999),month:G(HEAP32[n+16>>2],0,11),day:G(HEAP32[n+12>>2],1,31),hour:G(HEAP32[n+8>>2],0,23),min:G(HEAP32[n+4>>2],0,59),sec:G(HEAP32[n>>2],0,59)}}if(R){var w=h(),g,O=G=>{var ht=f.indexOf(G);if(ht>=0)return R[ht+1]};if((g=O("S"))&&(w.sec=jstoi_q(g)),(g=O("M"))&&(w.min=jstoi_q(g)),g=O("H"))w.hour=jstoi_q(g);else if(g=O("I")){var W=jstoi_q(g);(g=O("p"))&&(W+=g.toUpperCase()[0]==="P"?12:0),w.hour=W}if(g=O("Y"))w.year=jstoi_q(g);else if(g=O("y")){var k=jstoi_q(g);(g=O("C"))?k+=jstoi_q(g)*100:k+=k<69?2e3:1900,w.year=k}if((g=O("m"))?w.month=jstoi_q(g)-1:(g=O("b"))&&(w.month=I[g.substring(0,3).toUpperCase()]||0),g=O("d"))w.day=jstoi_q(g);else if(g=O("j"))for(var Z=jstoi_q(g),v=isLeapYear(w.year),tt=0;tt<12;++tt){var z=arraySum(v?MONTH_DAYS_LEAP:MONTH_DAYS_REGULAR,tt-1);Z<=z+(v?MONTH_DAYS_LEAP:MONTH_DAYS_REGULAR)[tt]&&(w.day=Z-z)}else if(g=O("a")){var et=g.substring(0,3).toUpperCase();if(g=O("U")){var At=A[et],rt=jstoi_q(g),J=new Date(w.year,0,1),it;J.getDay()===0?it=addDays(J,At+7*(rt-1)):it=addDays(J,7-J.getDay()+At+7*(rt-1)),w.day=it.getDate(),w.month=it.getMonth()}else if(g=O("W")){var At=m[et],rt=jstoi_q(g),J=new Date(w.year,0,1),it;J.getDay()===1?it=addDays(J,At+7*(rt-1)):it=addDays(J,7-J.getDay()+1+At+7*(rt-1)),w.day=it.getDate(),w.month=it.getMonth()}}var ot=new Date(w.year,w.month,w.day,w.hour,w.min,w.sec,0);return HEAP32[n>>2]=ot.getSeconds(),HEAP32[n+4>>2]=ot.getMinutes(),HEAP32[n+8>>2]=ot.getHours(),HEAP32[n+12>>2]=ot.getDate(),HEAP32[n+16>>2]=ot.getMonth(),HEAP32[n+20>>2]=ot.getFullYear()-1900,HEAP32[n+24>>2]=ot.getDay(),HEAP32[n+28>>2]=arraySum(isLeapYear(ot.getFullYear())?MONTH_DAYS_LEAP:MONTH_DAYS_REGULAR,ot.getMonth()-1)+ot.getDate()-1,HEAP32[n+32>>2]=0,t+intArrayFromString(R[0]).length-1}return 0};Module._strptime=_strptime,_strptime.sig="pppp";var _strptime_l=(t,e,n,_)=>_strptime(t,e,n);Module._strptime_l=_strptime_l,_strptime_l.sig="ppppp";var ERRNO_MESSAGES={0:"Success",1:"Arg list too long",2:"Permission denied",3:"Address already in use",4:"Address not available",5:"Address family not supported by protocol family",6:"No more processes",7:"Socket already connected",8:"Bad file number",9:"Trying to read unreadable message",10:"Mount device busy",11:"Operation canceled",12:"No children",13:"Connection aborted",14:"Connection refused",15:"Connection reset by peer",16:"File locking deadlock error",17:"Destination address required",18:"Math arg out of domain of func",19:"Quota exceeded",20:"File exists",21:"Bad address",22:"File too large",23:"Host is unreachable",24:"Identifier removed",25:"Illegal byte sequence",26:"Connection already in progress",27:"Interrupted system call",28:"Invalid argument",29:"I/O error",30:"Socket is already connected",31:"Is a directory",32:"Too many symbolic links",33:"Too many open files",34:"Too many links",35:"Message too long",36:"Multihop attempted",37:"File or path name too long",38:"Network interface is not configured",39:"Connection reset by network",40:"Network is unreachable",41:"Too many open files in system",42:"No buffer space available",43:"No such device",44:"No such file or directory",45:"Exec format error",46:"No record locks available",47:"The link has been severed",48:"Not enough core",49:"No message of desired type",50:"Protocol not available",51:"No space left on device",52:"Function not implemented",53:"Socket is not connected",54:"Not a directory",55:"Directory not empty",56:"State not recoverable",57:"Socket operation on non-socket",59:"Not a typewriter",60:"No such device or address",61:"Value too large for defined data type",62:"Previous owner died",63:"Not super-user",64:"Broken pipe",65:"Protocol error",66:"Unknown protocol",67:"Protocol wrong type for socket",68:"Math result not representable",69:"Read only file system",70:"Illegal seek",71:"No such process",72:"Stale file handle",73:"Connection timed out",74:"Text file busy",75:"Cross-device link",100:"Device not a stream",101:"Bad font file fmt",102:"Invalid slot",103:"Invalid request code",104:"No anode",105:"Block device required",106:"Channel number out of range",107:"Level 3 halted",108:"Level 3 reset",109:"Link number out of range",110:"Protocol driver not attached",111:"No CSI structure available",112:"Level 2 halted",113:"Invalid exchange",114:"Invalid request descriptor",115:"Exchange full",116:"No data (for no delay io)",117:"Timer expired",118:"Out of streams resources",119:"Machine is not on the network",120:"Package not installed",121:"The object is remote",122:"Advertise error",123:"Srmount error",124:"Communication error on send",125:"Cross mount point (not really error)",126:"Given log. name not unique",127:"f.d. invalid for this operation",128:"Remote address changed",129:"Can   access a needed shared lib",130:"Accessing a corrupted shared lib",131:".lib section in a.out corrupted",132:"Attempting to link in too many libs",133:"Attempting to exec a shared library",135:"Streams pipe error",136:"Too many users",137:"Socket type not supported",138:"Not supported",139:"Protocol family not supported",140:"Can't send after socket shutdown",141:"Too many references",142:"Host is down",148:"No medium (in tape drive)",156:"Level 2 not synchronized"};Module.ERRNO_MESSAGES=ERRNO_MESSAGES;var _gethostbyname_r=(t,e,n,_,r,a)=>{var o=_gethostbyname(t);return _memcpy(e,o,20),_free(o),HEAP32[a>>2]=0,HEAPU32[r>>2]=e,0};Module._gethostbyname_r=_gethostbyname_r,_gethostbyname_r.sig="ipppppp";var _endprotoent=()=>{};Module._endprotoent=_endprotoent,_endprotoent.sig="v";var _getprotoent=t=>{if(_setprotoent.index===Protocols.list.length)return 0;var e=Protocols.list[_setprotoent.index++];return e};Module._getprotoent=_getprotoent,_getprotoent.sig="p";var _getprotobynumber=t=>{_setprotoent(!0);var e=Protocols.map[t];return e};Module._getprotobynumber=_getprotobynumber,_getprotobynumber.sig="pi";var _emscripten_run_script=ptr=>{eval(UTF8ToString(ptr))};Module._emscripten_run_script=_emscripten_run_script,_emscripten_run_script.sig="vp";var _emscripten_run_script_int=ptr=>eval(UTF8ToString(ptr))|0;Module._emscripten_run_script_int=_emscripten_run_script_int,_emscripten_run_script_int.sig="ip";var _emscripten_run_script_string=ptr=>{var s=eval(UTF8ToString(ptr));if(s==null)return 0;s+="";var me=_emscripten_run_script_string,len=lengthBytesUTF8(s);return(!me.bufferSize||me.bufferSize<len+1)&&(me.bufferSize&&_free(me.buffer),me.bufferSize=len+1,me.buffer=_malloc(me.bufferSize)),stringToUTF8(s,me.buffer,me.bufferSize),me.buffer};Module._emscripten_run_script_string=_emscripten_run_script_string,_emscripten_run_script_string.sig="pp";var _emscripten_random=()=>Math.random();Module._emscripten_random=_emscripten_random,_emscripten_random.sig="f";var warnOnce=t=>{warnOnce.shown||(warnOnce.shown={}),warnOnce.shown[t]||(warnOnce.shown[t]=1,ENVIRONMENT_IS_NODE&&(t="warning: "+t),err(t))};Module.warnOnce=warnOnce;function getCallstack(t){var e=jsStackTrace(),n=e.lastIndexOf("_emscripten_log"),_=e.lastIndexOf("_emscripten_get_callstack"),r=e.indexOf(`
`,Math.max(n,_))+1;e=e.slice(r),t&8&&typeof emscripten_source_map>"u"&&(warnOnce('Source map information is not available, emscripten_log with EM_LOG_C_STACK will be ignored. Build with "--pre-js $EMSCRIPTEN/src/emscripten-source-map.min.js" linker flag to add source map loading to code.'),t^=8,t|=16);var a=e.split(`
`);e="";var o=new RegExp("\\s*(.*?)@(.*?):([0-9]+):([0-9]+)"),l=new RegExp("\\s*(.*?)@(.*):(.*)(:(.*))?"),p=new RegExp("\\s*at (.*?) \\((.*):(.*):(.*)\\)");for(var c in a){var I=a[c],A="",m="",E=0,f=0,R=p.exec(I);if(R&&R.length==5)A=R[1],m=R[2],E=R[3],f=R[4];else if(R=o.exec(I),R||(R=l.exec(I)),R&&R.length>=4)A=R[1],m=R[2],E=R[3],f=R[4]|0;else{e+=I+`
`;continue}var h=!1;if(t&8){var w=emscripten_source_map.originalPositionFor({line:E,column:f});h=w&&w.source,h&&(t&64&&(w.source=w.source.substring(w.source.replace(/\\/g,"/").lastIndexOf("/")+1)),e+=`    at ${A} (${w.source}:${w.line}:${w.column})
`)}(t&16||!h)&&(t&64&&(m=m.substring(m.replace(/\\/g,"/").lastIndexOf("/")+1)),e+=(h?`     = ${A}`:`    at ${A}`)+` (${m}:${E}:${f})
`)}return e=e.replace(/\s+$/,""),e}Module.getCallstack=getCallstack;function _emscripten_get_callstack(t,e,n){var _=getCallstack(t);if(!e||n<=0)return lengthBytesUTF8(_)+1;var r=stringToUTF8(_,e,n);return r+1}Module._emscripten_get_callstack=_emscripten_get_callstack,_emscripten_get_callstack.sig="iipi";var emscriptenLog=(t,e)=>{t&24&&(e=e.replace(/\s+$/,""),e+=(e.length>0?`
`:"")+getCallstack(t)),t&1?t&4?console.error(e):t&2?console.warn(e):t&512?console.info(e):t&256?console.debug(e):console.log(e):t&6?err(e):out(e)};Module.emscriptenLog=emscriptenLog;var reallyNegative=t=>t<0||t===0&&1/t===-1/0;Module.reallyNegative=reallyNegative;var reSign=(t,e)=>{if(t<=0)return t;var n=e<=32?Math.abs(1<<e-1):Math.pow(2,e-1);return t>=n&&(e<=32||t>n)&&(t=-2*n+t),t};Module.reSign=reSign;var unSign=(t,e)=>t>=0?t:e<=32?2*Math.abs(1<<e-1)+t:Math.pow(2,e)+t;Module.unSign=unSign;var strLen=t=>{for(var e=t;HEAPU8[e];)++e;return e-t};Module.strLen=strLen;var formatString=(t,e)=>{var n=t,_=e;function r(vt,Ct){return(Ct==="double"||Ct==="i64")&&vt&7&&(vt+=4),vt}function a(vt){var Ct;return _=r(_,vt),vt==="double"?(Ct=HEAPF64[_>>3],_+=8):vt=="i64"?(Ct=[HEAP32[_>>2],HEAP32[_+4>>2]],_+=8):(vt="i32",Ct=HEAP32[_>>2],_+=4),Ct}for(var o=[],l,p,c;;){var I=n;if(l=HEAP8[n>>0],l===0)break;if(p=HEAP8[n+1>>0],l==37){var A=!1,m=!1,E=!1,f=!1,R=!1;t:for(;;){switch(p){case 43:A=!0;break;case 45:m=!0;break;case 35:E=!0;break;case 48:if(f)break t;f=!0;break;case 32:R=!0;break;default:break t}n++,p=HEAP8[n+1>>0]}var h=0;if(p==42)h=a("i32"),n++,p=HEAP8[n+1>>0];else for(;p>=48&&p<=57;)h=h*10+(p-48),n++,p=HEAP8[n+1>>0];var w=!1,g=-1;if(p==46){if(g=0,w=!0,n++,p=HEAP8[n+1>>0],p==42)g=a("i32"),n++;else for(;;){var O=HEAP8[n+1>>0];if(O<48||O>57)break;g=g*10+(O-48),n++}p=HEAP8[n+1>>0]}g<0&&(g=6,w=!1);var W;switch(String.fromCharCode(p)){case"h":var k=HEAP8[n+2>>0];k==104?(n++,W=1):W=2;break;case"l":var k=HEAP8[n+2>>0];k==108?(n++,W=8):W=4;break;case"L":case"q":case"j":W=8;break;case"z":case"t":case"I":W=4;break;default:W=null}switch(W&&n++,p=HEAP8[n+1>>0],String.fromCharCode(p)){case"d":case"i":case"u":case"o":case"x":case"X":case"p":{var Z=p==100||p==105;W=W||4,c=a("i"+W*8);var v;if(W==8&&(c=p==117?convertU32PairToI53(c[0],c[1]):convertI32PairToI53(c[0],c[1])),W<=4){var tt=Math.pow(256,W)-1;c=(Z?reSign:unSign)(c&tt,W*8)}var z=Math.abs(c),et="";if(p==100||p==105)v=reSign(c,8*W).toString(10);else if(p==117)v=unSign(c,8*W).toString(10),c=Math.abs(c);else if(p==111)v=(E?"0":"")+z.toString(8);else if(p==120||p==88){if(et=E&&c!=0?"0x":"",c<0){c=-c,v=(z-1).toString(16);for(var At=[],rt=0;rt<v.length;rt++)At.push((15-parseInt(v[rt],16)).toString(16));for(v=At.join("");v.length<W*2;)v="f"+v}else v=z.toString(16);p==88&&(et=et.toUpperCase(),v=v.toUpperCase())}else p==112&&(z===0?v="(nil)":(et="0x",v=z.toString(16)));if(w)for(;v.length<g;)v="0"+v;for(c>=0&&(A?et="+"+et:R&&(et=" "+et)),v.charAt(0)=="-"&&(et="-"+et,v=v.substr(1));et.length+v.length<h;)m?v+=" ":f?v="0"+v:et=" "+et;v=et+v,v.split("").forEach(function(vt){o.push(vt.charCodeAt(0))});break}case"f":case"F":case"e":case"E":case"g":case"G":{c=a("double");var v;if(isNaN(c))v="nan",f=!1;else if(!isFinite(c))v=(c<0?"-":"")+"inf",f=!1;else{var J=!1,it=Math.min(g,20);if(p==103||p==71){J=!0,g=g||1;var ot=parseInt(c.toExponential(it).split("e")[1],10);g>ot&&ot>=-4?(p=(p==103?"f":"F").charCodeAt(0),g-=ot+1):(p=(p==103?"e":"E").charCodeAt(0),g--),it=Math.min(g,20)}p==101||p==69?(v=c.toExponential(it),/[eE][-+]\d$/.test(v)&&(v=v.slice(0,-1)+"0"+v.slice(-1))):(p==102||p==70)&&(v=c.toFixed(it),c===0&&reallyNegative(c)&&(v="-"+v));var G=v.split("e");if(J&&!E)for(;G[0].length>1&&G[0].includes(".")&&(G[0].slice(-1)=="0"||G[0].slice(-1)==".");)G[0]=G[0].slice(0,-1);else for(E&&v.indexOf(".")==-1&&(G[0]+=".");g>it++;)G[0]+="0";v=G[0]+(G.length>1?"e"+G[1]:""),p==69&&(v=v.toUpperCase()),c>=0&&(A?v="+"+v:R&&(v=" "+v))}for(;v.length<h;)m?v+=" ":f&&(v[0]=="-"||v[0]=="+")?v=v[0]+"0"+v.slice(1):v=(f?"0":" ")+v;p<97&&(v=v.toUpperCase()),v.split("").forEach(function(Ct){o.push(Ct.charCodeAt(0))});break}case"s":{var ht=a("i8*"),Pt=ht?strLen(ht):6;if(w&&(Pt=Math.min(Pt,g)),!m)for(;Pt<h--;)o.push(32);if(ht)for(var rt=0;rt<Pt;rt++)o.push(HEAPU8[ht++>>0]);else o=o.concat(intArrayFromString("(null)".substr(0,Pt),!0));if(m)for(;Pt<h--;)o.push(32);break}case"c":{for(m&&o.push(a("i8"));--h>0;)o.push(32);m||o.push(a("i8"));break}case"n":{var Lt=a("i32*");HEAP32[Lt>>2]=o.length;break}case"%":{o.push(l);break}default:for(var rt=I;rt<n+2;rt++)o.push(HEAP8[rt>>0])}n+=2}else o.push(l),n+=1}return o};Module.formatString=formatString;var _emscripten_log=(t,e,n)=>{var _=formatString(e,n),r=UTF8ArrayToString(_,0);emscriptenLog(t,r)};Module._emscripten_log=_emscripten_log,_emscripten_log.sig="vipp";var _emscripten_get_compiler_setting=t=>{throw"You must build with -sRETAIN_COMPILER_SETTINGS for getCompilerSetting or emscripten_get_compiler_setting to work"};Module._emscripten_get_compiler_setting=_emscripten_get_compiler_setting,_emscripten_get_compiler_setting.sig="pp";var _emscripten_has_asyncify=()=>0;Module._emscripten_has_asyncify=_emscripten_has_asyncify,_emscripten_has_asyncify.sig="i";function _emscripten_debugger(){debugger}Module._emscripten_debugger=_emscripten_debugger,_emscripten_debugger.sig="v";var _emscripten_print_double=(t,e,n)=>{var _=t+"";return e?stringToUTF8(_,e,n):lengthBytesUTF8(_)};Module._emscripten_print_double=_emscripten_print_double,_emscripten_print_double.sig="idpi";var convertFrameToPC=t=>(abort("Cannot use convertFrameToPC (needed by __builtin_return_address) without -sUSE_OFFSET_CONVERTER"),0);Module.convertFrameToPC=convertFrameToPC;var _emscripten_return_address=t=>{var e=jsStackTrace().split(`
`);e[0]=="Error"&&e.shift();var n=e[t+3];return convertFrameToPC(n)};Module._emscripten_return_address=_emscripten_return_address,_emscripten_return_address.sig="pi";var UNWIND_CACHE={};Module.UNWIND_CACHE=UNWIND_CACHE;var saveInUnwindCache=t=>{t.forEach(e=>{var n=convertFrameToPC(e);n&&(UNWIND_CACHE[n]=e)})};Module.saveInUnwindCache=saveInUnwindCache;function _emscripten_stack_snapshot(){var t=jsStackTrace().split(`
`);return t[0]=="Error"&&t.shift(),saveInUnwindCache(t),UNWIND_CACHE.last_addr=convertFrameToPC(t[3]),UNWIND_CACHE.last_stack=t,UNWIND_CACHE.last_addr}Module._emscripten_stack_snapshot=_emscripten_stack_snapshot,_emscripten_stack_snapshot.sig="p";var _emscripten_stack_unwind_buffer=(t,e,n)=>{var _;UNWIND_CACHE.last_addr==t?_=UNWIND_CACHE.last_stack:(_=jsStackTrace().split(`
`),_[0]=="Error"&&_.shift(),saveInUnwindCache(_));for(var r=3;_[r]&&convertFrameToPC(_[r])!=t;)++r;for(var a=0;a<n&&_[a+r];++a)HEAP32[e+a*4>>2]=convertFrameToPC(_[a+r]);return a};Module._emscripten_stack_unwind_buffer=_emscripten_stack_unwind_buffer,_emscripten_stack_unwind_buffer.sig="ippi";var _emscripten_pc_get_function=t=>(abort("Cannot use emscripten_pc_get_function without -sUSE_OFFSET_CONVERTER"),0);Module._emscripten_pc_get_function=_emscripten_pc_get_function,_emscripten_pc_get_function.sig="pp";var convertPCtoSourceLocation=t=>{if(UNWIND_CACHE.last_get_source_pc==t)return UNWIND_CACHE.last_source;var e,n;if(!n){var _=UNWIND_CACHE[t];if(!_)return null;(e=/\((.*):(\d+):(\d+)\)$/.exec(_))?n={file:e[1],line:e[2],column:e[3]}:(e=/@(.*):(\d+):(\d+)/.exec(_))&&(n={file:e[1],line:e[2],column:e[3]})}return UNWIND_CACHE.last_get_source_pc=t,UNWIND_CACHE.last_source=n,n};Module.convertPCtoSourceLocation=convertPCtoSourceLocation;var _emscripten_pc_get_file=t=>{var e=convertPCtoSourceLocation(t);return e?(_emscripten_pc_get_file.ret&&_free(_emscripten_pc_get_file.ret),_emscripten_pc_get_file.ret=stringToNewUTF8(e.file),_emscripten_pc_get_file.ret):0};Module._emscripten_pc_get_file=_emscripten_pc_get_file,_emscripten_pc_get_file.sig="pp";var _emscripten_pc_get_line=t=>{var e=convertPCtoSourceLocation(t);return e?e.line:0};Module._emscripten_pc_get_line=_emscripten_pc_get_line,_emscripten_pc_get_line.sig="ip";var _emscripten_pc_get_column=t=>{var e=convertPCtoSourceLocation(t);return e&&e.column||0};Module._emscripten_pc_get_column=_emscripten_pc_get_column,_emscripten_pc_get_column.sig="ip";var _emscripten_get_module_name=(t,e)=>stringToUTF8(wasmBinaryFile,t,e);Module._emscripten_get_module_name=_emscripten_get_module_name,_emscripten_get_module_name.sig="ppp";var _emscripten_asm_const_double=(t,e,n)=>runEmAsmFunction(t,e,n);Module._emscripten_asm_const_double=_emscripten_asm_const_double,_emscripten_asm_const_double.sig="dppp";var _emscripten_asm_const_ptr=(t,e,n)=>runEmAsmFunction(t,e,n);Module._emscripten_asm_const_ptr=_emscripten_asm_const_ptr,_emscripten_asm_const_ptr.sig="pppp";var runMainThreadEmAsm=(t,e,n,_)=>{var r=readEmAsmArgs(e,n);return ASM_CONSTS[t].apply(null,r)};Module.runMainThreadEmAsm=runMainThreadEmAsm;var _emscripten_asm_const_int_sync_on_main_thread=(t,e,n)=>runMainThreadEmAsm(t,e,n,1);Module._emscripten_asm_const_int_sync_on_main_thread=_emscripten_asm_const_int_sync_on_main_thread,_emscripten_asm_const_int_sync_on_main_thread.sig="ippp";var _emscripten_asm_const_double_sync_on_main_thread=_emscripten_asm_const_int_sync_on_main_thread;Module._emscripten_asm_const_double_sync_on_main_thread=_emscripten_asm_const_double_sync_on_main_thread,_emscripten_asm_const_double_sync_on_main_thread.sig="dppp";var _emscripten_asm_const_async_on_main_thread=(t,e,n)=>runMainThreadEmAsm(t,e,n,0);Module._emscripten_asm_const_async_on_main_thread=_emscripten_asm_const_async_on_main_thread,_emscripten_asm_const_async_on_main_thread.sig="vppp";var jstoi_s=t=>Number(t);Module.jstoi_s=jstoi_s;var __Unwind_Backtrace=(t,e)=>{for(var n=getCallstack(),_=n.split(`
`),r=0;r<_.length;r++){var a=getWasmTableEntry(t)(0,e);if(a!==0)return}};Module.__Unwind_Backtrace=__Unwind_Backtrace,__Unwind_Backtrace.sig="ipp";var __Unwind_GetIPInfo=(t,e)=>abort("Unwind_GetIPInfo");Module.__Unwind_GetIPInfo=__Unwind_GetIPInfo,__Unwind_GetIPInfo.sig="ppp";var __Unwind_FindEnclosingFunction=t=>0;Module.__Unwind_FindEnclosingFunction=__Unwind_FindEnclosingFunction,__Unwind_FindEnclosingFunction.sig="pp";var __Unwind_RaiseException=t=>(err("Warning: _Unwind_RaiseException is not correctly implemented"),___cxa_throw(t,0,0));Module.__Unwind_RaiseException=__Unwind_RaiseException,__Unwind_RaiseException.sig="ip";var __Unwind_DeleteException=t=>{err("TODO: Unwind_DeleteException")};Module.__Unwind_DeleteException=__Unwind_DeleteException,__Unwind_DeleteException.sig="vp";var listenOnce=(t,e,n)=>{t.addEventListener(e,n,{once:!0})};Module.listenOnce=listenOnce;var autoResumeAudioContext=(t,e)=>{e||(e=[document,document.getElementById("canvas")]),["keydown","mousedown","touchstart"].forEach(n=>{e.forEach(_=>{_&&listenOnce(_,n,()=>{t.state==="suspended"&&t.resume()})})})};Module.autoResumeAudioContext=autoResumeAudioContext;var getDynCaller=(t,e)=>{var n=[];return function(){return n.length=0,Object.assign(n,arguments),dynCall(t,e,n)}};Module.getDynCaller=getDynCaller;var _emscripten_force_exit=t=>{noExitRuntime=!1,runtimeKeepaliveCounter=0,_exit(t)};Module._emscripten_force_exit=_emscripten_force_exit,_emscripten_force_exit.sig="vi";var _emscripten_outn=(t,e)=>out(UTF8ToString(t,e));Module._emscripten_outn=_emscripten_outn,_emscripten_outn.sig="vpp";var _emscripten_errn=(t,e)=>err(UTF8ToString(t,e));Module._emscripten_errn=_emscripten_errn,_emscripten_errn.sig="vpp";var _emscripten_throw_number=t=>{throw t};Module._emscripten_throw_number=_emscripten_throw_number,_emscripten_throw_number.sig="vd";var _emscripten_throw_string=t=>{throw UTF8ToString(t)};Module._emscripten_throw_string=_emscripten_throw_string,_emscripten_throw_string.sig="vp";var runtimeKeepalivePush=()=>{runtimeKeepaliveCounter+=1};Module.runtimeKeepalivePush=runtimeKeepalivePush,runtimeKeepalivePush.sig="v";var runtimeKeepalivePop=()=>{runtimeKeepaliveCounter-=1};Module.runtimeKeepalivePop=runtimeKeepalivePop,runtimeKeepalivePop.sig="v";var _emscripten_runtime_keepalive_push=runtimeKeepalivePush;Module._emscripten_runtime_keepalive_push=_emscripten_runtime_keepalive_push,_emscripten_runtime_keepalive_push.sig="v";var _emscripten_runtime_keepalive_pop=runtimeKeepalivePop;Module._emscripten_runtime_keepalive_pop=_emscripten_runtime_keepalive_pop,_emscripten_runtime_keepalive_pop.sig="v";var _emscripten_runtime_keepalive_check=()=>keepRuntimeAlive();Module._emscripten_runtime_keepalive_check=_emscripten_runtime_keepalive_check,_emscripten_runtime_keepalive_check.sig="i";var safeSetTimeout=(t,e)=>setTimeout(()=>{callUserCallback(t)},e);Module.safeSetTimeout=safeSetTimeout;var asmjsMangle=t=>{var e=["stackAlloc","stackSave","stackRestore","getTempRet0","setTempRet0"];return t=="__main_argc_argv"&&(t="main"),t.indexOf("dynCall_")==0||e.includes(t)?t:"_"+t};Module.asmjsMangle=asmjsMangle;var ___global_base=1024;Module.___global_base=___global_base;var __emscripten_fs_load_embedded_files=t=>{do{var e=HEAPU32[t>>2];t+=4;var n=HEAPU32[t>>2];t+=4;var _=HEAPU32[t>>2];t+=4;var r=UTF8ToString(e);FS.createPath("/",PATH.dirname(r),!0,!0),FS.createDataFile(r,null,HEAP8.subarray(_,_+n),!0,!0,!0)}while(HEAPU32[t>>2])};Module.__emscripten_fs_load_embedded_files=__emscripten_fs_load_embedded_files,__emscripten_fs_load_embedded_files.sig="vp";var POINTER_SIZE=4;Module.POINTER_SIZE=POINTER_SIZE;function getNativeTypeSize(t){switch(t){case"i1":case"i8":case"u8":return 1;case"i16":case"u16":return 2;case"i32":case"u32":return 4;case"i64":case"u64":return 8;case"float":return 4;case"double":return 8;default:{if(t[t.length-1]==="*")return POINTER_SIZE;if(t[0]==="i"){let e=Number(t.substr(1));return assert(e%8===0,"getNativeTypeSize invalid bits "+e+", type "+t),e/8}return 0}}}Module.getNativeTypeSize=getNativeTypeSize;var STACK_SIZE=5242880;Module.STACK_SIZE=STACK_SIZE;var STACK_ALIGN=16;Module.STACK_ALIGN=STACK_ALIGN;var ASSERTIONS=0;Module.ASSERTIONS=ASSERTIONS;var getCFunc=t=>{var e=Module["_"+t];return e};Module.getCFunc=getCFunc;var ccall=(t,e,n,_,r)=>{var a={string:f=>{var R=0;return f!=null&&f!==0&&(R=stringToUTF8OnStack(f)),R},array:f=>{var R=stackAlloc(f.length);return writeArrayToMemory(f,R),R}};function o(f){return e==="string"?UTF8ToString(f):e==="boolean"?!!f:f}var l=getCFunc(t),p=[],c=0;if(_)for(var I=0;I<_.length;I++){var A=a[n[I]];A?(c===0&&(c=stackSave()),p[I]=A(_[I])):p[I]=_[I]}var m=l.apply(null,p);function E(f){return c!==0&&stackRestore(c),o(f)}return m=E(m),m};Module.ccall=ccall;var cwrap=(t,e,n,_)=>{var r=!n||n.every(o=>o==="number"||o==="boolean"),a=e!=="string";return a&&r&&!_?getCFunc(t):function(){return ccall(t,e,n,arguments,_)}};Module.cwrap=cwrap;var removeFunction=t=>{functionsInTableMap.delete(getWasmTableEntry(t)),setWasmTableEntry(t,null),freeTableIndexes.push(t)};Module.removeFunction=removeFunction;var _emscripten_math_cbrt=t=>Math.cbrt(t);Module._emscripten_math_cbrt=_emscripten_math_cbrt,_emscripten_math_cbrt.sig="dd";var _emscripten_math_pow=(t,e)=>Math.pow(t,e);Module._emscripten_math_pow=_emscripten_math_pow,_emscripten_math_pow.sig="ddd";var _emscripten_math_random=()=>Math.random();Module._emscripten_math_random=_emscripten_math_random,_emscripten_math_random.sig="d";var _emscripten_math_sign=t=>Math.sign(t);Module._emscripten_math_sign=_emscripten_math_sign,_emscripten_math_sign.sig="dd";var _emscripten_math_sqrt=t=>Math.sqrt(t);Module._emscripten_math_sqrt=_emscripten_math_sqrt,_emscripten_math_sqrt.sig="dd";var _emscripten_math_exp=t=>Math.exp(t);Module._emscripten_math_exp=_emscripten_math_exp,_emscripten_math_exp.sig="dd";var _emscripten_math_expm1=t=>Math.expm1(t);Module._emscripten_math_expm1=_emscripten_math_expm1,_emscripten_math_expm1.sig="dd";var _emscripten_math_fmod=(t,e)=>t%e;Module._emscripten_math_fmod=_emscripten_math_fmod,_emscripten_math_fmod.sig="ddd";var _emscripten_math_log=t=>Math.log(t);Module._emscripten_math_log=_emscripten_math_log,_emscripten_math_log.sig="dd";var _emscripten_math_log1p=t=>Math.log1p(t);Module._emscripten_math_log1p=_emscripten_math_log1p,_emscripten_math_log1p.sig="dd";var _emscripten_math_log10=t=>Math.log10(t);Module._emscripten_math_log10=_emscripten_math_log10,_emscripten_math_log10.sig="dd";var _emscripten_math_log2=t=>Math.log2(t);Module._emscripten_math_log2=_emscripten_math_log2,_emscripten_math_log2.sig="dd";var _emscripten_math_round=t=>Math.round(t);Module._emscripten_math_round=_emscripten_math_round,_emscripten_math_round.sig="dd";var _emscripten_math_acos=t=>Math.acos(t);Module._emscripten_math_acos=_emscripten_math_acos,_emscripten_math_acos.sig="dd";var _emscripten_math_acosh=t=>Math.acosh(t);Module._emscripten_math_acosh=_emscripten_math_acosh,_emscripten_math_acosh.sig="dd";var _emscripten_math_asin=t=>Math.asin(t);Module._emscripten_math_asin=_emscripten_math_asin,_emscripten_math_asin.sig="dd";var _emscripten_math_asinh=t=>Math.asinh(t);Module._emscripten_math_asinh=_emscripten_math_asinh,_emscripten_math_asinh.sig="dd";var _emscripten_math_atan=t=>Math.atan(t);Module._emscripten_math_atan=_emscripten_math_atan,_emscripten_math_atan.sig="dd";var _emscripten_math_atanh=t=>Math.atanh(t);Module._emscripten_math_atanh=_emscripten_math_atanh,_emscripten_math_atanh.sig="dd";var _emscripten_math_atan2=(t,e)=>Math.atan2(t,e);Module._emscripten_math_atan2=_emscripten_math_atan2,_emscripten_math_atan2.sig="ddd";var _emscripten_math_cos=t=>Math.cos(t);Module._emscripten_math_cos=_emscripten_math_cos,_emscripten_math_cos.sig="dd";var _emscripten_math_cosh=t=>Math.cosh(t);Module._emscripten_math_cosh=_emscripten_math_cosh,_emscripten_math_cosh.sig="dd";var _emscripten_math_hypot=(t,e)=>{for(var n=[],_=0;_<t;++_)n.push(HEAPF64[e+_*8>>3]);return Math.hypot.apply(null,n)};Module._emscripten_math_hypot=_emscripten_math_hypot,_emscripten_math_hypot.sig="dip";var _emscripten_math_sin=t=>Math.sin(t);Module._emscripten_math_sin=_emscripten_math_sin,_emscripten_math_sin.sig="dd";var _emscripten_math_sinh=t=>Math.sinh(t);Module._emscripten_math_sinh=_emscripten_math_sinh,_emscripten_math_sinh.sig="dd";var _emscripten_math_tan=t=>Math.tan(t);Module._emscripten_math_tan=_emscripten_math_tan,_emscripten_math_tan.sig="dd";var _emscripten_math_tanh=t=>Math.tanh(t);Module._emscripten_math_tanh=_emscripten_math_tanh,_emscripten_math_tanh.sig="dd";function intArrayToString(t){for(var e=[],n=0;n<t.length;n++){var _=t[n];_>255&&(_&=255),e.push(String.fromCharCode(_))}return e.join("")}Module.intArrayToString=intArrayToString;var AsciiToString=t=>{for(var e="";;){var n=HEAPU8[t++>>0];if(!n)return e;e+=String.fromCharCode(n)}};Module.AsciiToString=AsciiToString;var UTF16Decoder=typeof TextDecoder<"u"?new TextDecoder("utf-16le"):void 0;Module.UTF16Decoder=UTF16Decoder;var UTF16ToString=(t,e)=>{for(var n=t,_=n>>1,r=_+e/2;!(_>=r)&&HEAPU16[_];)++_;if(n=_<<1,n-t>32&&UTF16Decoder)return UTF16Decoder.decode(HEAPU8.subarray(t,n));for(var a="",o=0;!(o>=e/2);++o){var l=HEAP16[t+o*2>>1];if(l==0)break;a+=String.fromCharCode(l)}return a};Module.UTF16ToString=UTF16ToString;var stringToUTF16=(t,e,n)=>{if(n===void 0&&(n=2147483647),n<2)return 0;n-=2;for(var _=e,r=n<t.length*2?n/2:t.length,a=0;a<r;++a){var o=t.charCodeAt(a);HEAP16[e>>1]=o,e+=2}return HEAP16[e>>1]=0,e-_};Module.stringToUTF16=stringToUTF16;var lengthBytesUTF16=t=>t.length*2;Module.lengthBytesUTF16=lengthBytesUTF16;var UTF32ToString=(t,e)=>{for(var n=0,_="";!(n>=e/4);){var r=HEAP32[t+n*4>>2];if(r==0)break;if(++n,r>=65536){var a=r-65536;_+=String.fromCharCode(55296|a>>10,56320|a&1023)}else _+=String.fromCharCode(r)}return _};Module.UTF32ToString=UTF32ToString;var stringToUTF32=(t,e,n)=>{if(n===void 0&&(n=2147483647),n<4)return 0;for(var _=e,r=_+n-4,a=0;a<t.length;++a){var o=t.charCodeAt(a);if(o>=55296&&o<=57343){var l=t.charCodeAt(++a);o=65536+((o&1023)<<10)|l&1023}if(HEAP32[e>>2]=o,e+=4,e+4>r)break}return HEAP32[e>>2]=0,e-_};Module.stringToUTF32=stringToUTF32;var lengthBytesUTF32=t=>{for(var e=0,n=0;n<t.length;++n){var _=t.charCodeAt(n);_>=55296&&_<=57343&&++n,e+=4}return e};Module.lengthBytesUTF32=lengthBytesUTF32;var JSEvents={inEventHandler:0,removeAllEventListeners(){for(var t=JSEvents.eventHandlers.length-1;t>=0;--t)JSEvents._removeHandler(t);JSEvents.eventHandlers=[],JSEvents.deferredCalls=[]},registerRemoveEventListeners(){JSEvents.removeEventListenersRegistered||(__ATEXIT__.push(JSEvents.removeAllEventListeners),JSEvents.removeEventListenersRegistered=!0)},deferredCalls:[],deferCall(t,e,n){function _(o,l){if(o.length!=l.length)return!1;for(var p in o)if(o[p]!=l[p])return!1;return!0}for(var r in JSEvents.deferredCalls){var a=JSEvents.deferredCalls[r];if(a.targetFunction==t&&_(a.argsList,n))return}JSEvents.deferredCalls.push({targetFunction:t,precedence:e,argsList:n}),JSEvents.deferredCalls.sort((o,l)=>o.precedence<l.precedence)},removeDeferredCalls(t){for(var e=0;e<JSEvents.deferredCalls.length;++e)JSEvents.deferredCalls[e].targetFunction==t&&(JSEvents.deferredCalls.splice(e,1),--e)},canPerformEventHandlerRequests(){return navigator.userActivation?navigator.userActivation.isActive:JSEvents.inEventHandler&&JSEvents.currentEventHandler.allowsDeferredCalls},runDeferredCalls(){if(JSEvents.canPerformEventHandlerRequests())for(var t=0;t<JSEvents.deferredCalls.length;++t){var e=JSEvents.deferredCalls[t];JSEvents.deferredCalls.splice(t,1),--t,e.targetFunction.apply(null,e.argsList)}},eventHandlers:[],removeAllHandlersOnTarget:(t,e)=>{for(var n=0;n<JSEvents.eventHandlers.length;++n)JSEvents.eventHandlers[n].target==t&&(!e||e==JSEvents.eventHandlers[n].eventTypeString)&&JSEvents._removeHandler(n--)},_removeHandler(t){var e=JSEvents.eventHandlers[t];e.target.removeEventListener(e.eventTypeString,e.eventListenerFunc,e.useCapture),JSEvents.eventHandlers.splice(t,1)},registerOrRemoveHandler(t){if(!t.target)return-4;var e=function(r){++JSEvents.inEventHandler,JSEvents.currentEventHandler=t,JSEvents.runDeferredCalls(),t.handlerFunc(r),JSEvents.runDeferredCalls(),--JSEvents.inEventHandler};if(t.callbackfunc)t.eventListenerFunc=e,t.target.addEventListener(t.eventTypeString,e,t.useCapture),JSEvents.eventHandlers.push(t),JSEvents.registerRemoveEventListeners();else for(var n=0;n<JSEvents.eventHandlers.length;++n)JSEvents.eventHandlers[n].target==t.target&&JSEvents.eventHandlers[n].eventTypeString==t.eventTypeString&&JSEvents._removeHandler(n--);return 0},getNodeNameForTarget(t){return t?t==window?"#window":t==screen?"#screen":t&&t.nodeName?t.nodeName:"":""},fullscreenEnabled(){return document.fullscreenEnabled||document.webkitFullscreenEnabled}};Module.JSEvents=JSEvents;var maybeCStringToJsString=t=>t>2?UTF8ToString(t):t;Module.maybeCStringToJsString=maybeCStringToJsString;var specialHTMLTargets=[0,typeof document<"u"?document:0,typeof window<"u"?window:0];Module.specialHTMLTargets=specialHTMLTargets;var findEventTarget=t=>{t=maybeCStringToJsString(t);var e=specialHTMLTargets[t]||(typeof document<"u"?document.querySelector(t):void 0);return e};Module.findEventTarget=findEventTarget;var registerKeyEventCallback=(t,e,n,_,r,a,o)=>{JSEvents.keyEvent||(JSEvents.keyEvent=_malloc(176));var l=c=>{var I=JSEvents.keyEvent;HEAPF64[I>>3]=c.timeStamp;var A=I>>2;HEAP32[A+2]=c.location,HEAP32[A+3]=c.ctrlKey,HEAP32[A+4]=c.shiftKey,HEAP32[A+5]=c.altKey,HEAP32[A+6]=c.metaKey,HEAP32[A+7]=c.repeat,HEAP32[A+8]=c.charCode,HEAP32[A+9]=c.keyCode,HEAP32[A+10]=c.which,stringToUTF8(c.key||"",I+44,32),stringToUTF8(c.code||"",I+76,32),stringToUTF8(c.char||"",I+108,32),stringToUTF8(c.locale||"",I+140,32),getWasmTableEntry(_)(r,I,e)&&c.preventDefault()},p={target:findEventTarget(t),allowsDeferredCalls:!0,eventTypeString:a,callbackfunc:_,handlerFunc:l,useCapture:n};return JSEvents.registerOrRemoveHandler(p)};Module.registerKeyEventCallback=registerKeyEventCallback;var findCanvasEventTarget=t=>findEventTarget(t);Module.findCanvasEventTarget=findCanvasEventTarget;var _emscripten_set_keypress_callback_on_thread=(t,e,n,_,r)=>registerKeyEventCallback(t,e,n,_,1,"keypress",r);Module._emscripten_set_keypress_callback_on_thread=_emscripten_set_keypress_callback_on_thread,_emscripten_set_keypress_callback_on_thread.sig="ippipp";var _emscripten_set_keydown_callback_on_thread=(t,e,n,_,r)=>registerKeyEventCallback(t,e,n,_,2,"keydown",r);Module._emscripten_set_keydown_callback_on_thread=_emscripten_set_keydown_callback_on_thread,_emscripten_set_keydown_callback_on_thread.sig="ippipp";var _emscripten_set_keyup_callback_on_thread=(t,e,n,_,r)=>registerKeyEventCallback(t,e,n,_,3,"keyup",r);Module._emscripten_set_keyup_callback_on_thread=_emscripten_set_keyup_callback_on_thread,_emscripten_set_keyup_callback_on_thread.sig="ippipp";var getBoundingClientRect=t=>specialHTMLTargets.indexOf(t)<0?t.getBoundingClientRect():{left:0,top:0};Module.getBoundingClientRect=getBoundingClientRect;var fillMouseEventData=(t,e,n)=>{HEAPF64[t>>3]=e.timeStamp;var _=t>>2;HEAP32[_+2]=e.screenX,HEAP32[_+3]=e.screenY,HEAP32[_+4]=e.clientX,HEAP32[_+5]=e.clientY,HEAP32[_+6]=e.ctrlKey,HEAP32[_+7]=e.shiftKey,HEAP32[_+8]=e.altKey,HEAP32[_+9]=e.metaKey,HEAP16[_*2+20]=e.button,HEAP16[_*2+21]=e.buttons,HEAP32[_+11]=e.movementX,HEAP32[_+12]=e.movementY;var r=getBoundingClientRect(n);HEAP32[_+13]=e.clientX-r.left,HEAP32[_+14]=e.clientY-r.top};Module.fillMouseEventData=fillMouseEventData;var registerMouseEventCallback=(t,e,n,_,r,a,o)=>{JSEvents.mouseEvent||(JSEvents.mouseEvent=_malloc(72)),t=findEventTarget(t);var l=(c=event)=>{fillMouseEventData(JSEvents.mouseEvent,c,t),getWasmTableEntry(_)(r,JSEvents.mouseEvent,e)&&c.preventDefault()},p={target:t,allowsDeferredCalls:a!="mousemove"&&a!="mouseenter"&&a!="mouseleave",eventTypeString:a,callbackfunc:_,handlerFunc:l,useCapture:n};return JSEvents.registerOrRemoveHandler(p)};Module.registerMouseEventCallback=registerMouseEventCallback;var _emscripten_set_click_callback_on_thread=(t,e,n,_,r)=>registerMouseEventCallback(t,e,n,_,4,"click",r);Module._emscripten_set_click_callback_on_thread=_emscripten_set_click_callback_on_thread,_emscripten_set_click_callback_on_thread.sig="ippipp";var _emscripten_set_mousedown_callback_on_thread=(t,e,n,_,r)=>registerMouseEventCallback(t,e,n,_,5,"mousedown",r);Module._emscripten_set_mousedown_callback_on_thread=_emscripten_set_mousedown_callback_on_thread,_emscripten_set_mousedown_callback_on_thread.sig="ippipp";var _emscripten_set_mouseup_callback_on_thread=(t,e,n,_,r)=>registerMouseEventCallback(t,e,n,_,6,"mouseup",r);Module._emscripten_set_mouseup_callback_on_thread=_emscripten_set_mouseup_callback_on_thread,_emscripten_set_mouseup_callback_on_thread.sig="ippipp";var _emscripten_set_dblclick_callback_on_thread=(t,e,n,_,r)=>registerMouseEventCallback(t,e,n,_,7,"dblclick",r);Module._emscripten_set_dblclick_callback_on_thread=_emscripten_set_dblclick_callback_on_thread,_emscripten_set_dblclick_callback_on_thread.sig="ippipp";var _emscripten_set_mousemove_callback_on_thread=(t,e,n,_,r)=>registerMouseEventCallback(t,e,n,_,8,"mousemove",r);Module._emscripten_set_mousemove_callback_on_thread=_emscripten_set_mousemove_callback_on_thread,_emscripten_set_mousemove_callback_on_thread.sig="ippipp";var _emscripten_set_mouseenter_callback_on_thread=(t,e,n,_,r)=>registerMouseEventCallback(t,e,n,_,33,"mouseenter",r);Module._emscripten_set_mouseenter_callback_on_thread=_emscripten_set_mouseenter_callback_on_thread,_emscripten_set_mouseenter_callback_on_thread.sig="ippipp";var _emscripten_set_mouseleave_callback_on_thread=(t,e,n,_,r)=>registerMouseEventCallback(t,e,n,_,34,"mouseleave",r);Module._emscripten_set_mouseleave_callback_on_thread=_emscripten_set_mouseleave_callback_on_thread,_emscripten_set_mouseleave_callback_on_thread.sig="ippipp";var _emscripten_set_mouseover_callback_on_thread=(t,e,n,_,r)=>registerMouseEventCallback(t,e,n,_,35,"mouseover",r);Module._emscripten_set_mouseover_callback_on_thread=_emscripten_set_mouseover_callback_on_thread,_emscripten_set_mouseover_callback_on_thread.sig="ippipp";var _emscripten_set_mouseout_callback_on_thread=(t,e,n,_,r)=>registerMouseEventCallback(t,e,n,_,36,"mouseout",r);Module._emscripten_set_mouseout_callback_on_thread=_emscripten_set_mouseout_callback_on_thread,_emscripten_set_mouseout_callback_on_thread.sig="ippipp";var _emscripten_get_mouse_status=t=>JSEvents.mouseEvent?(HEAP8.set(HEAP8.subarray(JSEvents.mouseEvent,JSEvents.mouseEvent+72),t),0):-7;Module._emscripten_get_mouse_status=_emscripten_get_mouse_status,_emscripten_get_mouse_status.sig="ip";var registerWheelEventCallback=(t,e,n,_,r,a,o)=>{JSEvents.wheelEvent||(JSEvents.wheelEvent=_malloc(104));var l=(c=event)=>{var I=JSEvents.wheelEvent;fillMouseEventData(I,c,t),HEAPF64[I+72>>3]=c.deltaX,HEAPF64[I+80>>3]=c.deltaY,HEAPF64[I+88>>3]=c.deltaZ,HEAP32[I+96>>2]=c.deltaMode,getWasmTableEntry(_)(r,I,e)&&c.preventDefault()},p={target:t,allowsDeferredCalls:!0,eventTypeString:a,callbackfunc:_,handlerFunc:l,useCapture:n};return JSEvents.registerOrRemoveHandler(p)};Module.registerWheelEventCallback=registerWheelEventCallback;var _emscripten_set_wheel_callback_on_thread=(t,e,n,_,r)=>(t=findEventTarget(t),t?typeof t.onwheel<"u"?registerWheelEventCallback(t,e,n,_,9,"wheel",r):-1:-4);Module._emscripten_set_wheel_callback_on_thread=_emscripten_set_wheel_callback_on_thread,_emscripten_set_wheel_callback_on_thread.sig="ippipp";var registerUiEventCallback=(t,e,n,_,r,a,o)=>{JSEvents.uiEvent||(JSEvents.uiEvent=_malloc(36)),t=findEventTarget(t);var l=(c=event)=>{if(c.target==t){var I=document.body;if(I){var A=JSEvents.uiEvent;HEAP32[A>>2]=c.detail,HEAP32[A+4>>2]=I.clientWidth,HEAP32[A+8>>2]=I.clientHeight,HEAP32[A+12>>2]=innerWidth,HEAP32[A+16>>2]=innerHeight,HEAP32[A+20>>2]=outerWidth,HEAP32[A+24>>2]=outerHeight,HEAP32[A+28>>2]=pageXOffset,HEAP32[A+32>>2]=pageYOffset,getWasmTableEntry(_)(r,A,e)&&c.preventDefault()}}},p={target:t,eventTypeString:a,callbackfunc:_,handlerFunc:l,useCapture:n};return JSEvents.registerOrRemoveHandler(p)};Module.registerUiEventCallback=registerUiEventCallback;var _emscripten_set_resize_callback_on_thread=(t,e,n,_,r)=>registerUiEventCallback(t,e,n,_,10,"resize",r);Module._emscripten_set_resize_callback_on_thread=_emscripten_set_resize_callback_on_thread,_emscripten_set_resize_callback_on_thread.sig="ippipp";var _emscripten_set_scroll_callback_on_thread=(t,e,n,_,r)=>registerUiEventCallback(t,e,n,_,11,"scroll",r);Module._emscripten_set_scroll_callback_on_thread=_emscripten_set_scroll_callback_on_thread,_emscripten_set_scroll_callback_on_thread.sig="ippipp";var registerFocusEventCallback=(t,e,n,_,r,a,o)=>{JSEvents.focusEvent||(JSEvents.focusEvent=_malloc(256));var l=(c=event)=>{var I=JSEvents.getNodeNameForTarget(c.target),A=c.target.id?c.target.id:"",m=JSEvents.focusEvent;stringToUTF8(I,m+0,128),stringToUTF8(A,m+128,128),getWasmTableEntry(_)(r,m,e)&&c.preventDefault()},p={target:findEventTarget(t),eventTypeString:a,callbackfunc:_,handlerFunc:l,useCapture:n};return JSEvents.registerOrRemoveHandler(p)};Module.registerFocusEventCallback=registerFocusEventCallback;var _emscripten_set_blur_callback_on_thread=(t,e,n,_,r)=>registerFocusEventCallback(t,e,n,_,12,"blur",r);Module._emscripten_set_blur_callback_on_thread=_emscripten_set_blur_callback_on_thread,_emscripten_set_blur_callback_on_thread.sig="ippipp";var _emscripten_set_focus_callback_on_thread=(t,e,n,_,r)=>registerFocusEventCallback(t,e,n,_,13,"focus",r);Module._emscripten_set_focus_callback_on_thread=_emscripten_set_focus_callback_on_thread,_emscripten_set_focus_callback_on_thread.sig="ippipp";var _emscripten_set_focusin_callback_on_thread=(t,e,n,_,r)=>registerFocusEventCallback(t,e,n,_,14,"focusin",r);Module._emscripten_set_focusin_callback_on_thread=_emscripten_set_focusin_callback_on_thread,_emscripten_set_focusin_callback_on_thread.sig="ippipp";var _emscripten_set_focusout_callback_on_thread=(t,e,n,_,r)=>registerFocusEventCallback(t,e,n,_,15,"focusout",r);Module._emscripten_set_focusout_callback_on_thread=_emscripten_set_focusout_callback_on_thread,_emscripten_set_focusout_callback_on_thread.sig="ippipp";var fillDeviceOrientationEventData=(t,e,n)=>{HEAPF64[t>>3]=e.alpha,HEAPF64[t+8>>3]=e.beta,HEAPF64[t+16>>3]=e.gamma,HEAP32[t+24>>2]=e.absolute};Module.fillDeviceOrientationEventData=fillDeviceOrientationEventData;var registerDeviceOrientationEventCallback=(t,e,n,_,r,a,o)=>{JSEvents.deviceOrientationEvent||(JSEvents.deviceOrientationEvent=_malloc(32));var l=(c=event)=>{fillDeviceOrientationEventData(JSEvents.deviceOrientationEvent,c,t),getWasmTableEntry(_)(r,JSEvents.deviceOrientationEvent,e)&&c.preventDefault()},p={target:findEventTarget(t),eventTypeString:a,callbackfunc:_,handlerFunc:l,useCapture:n};return JSEvents.registerOrRemoveHandler(p)};Module.registerDeviceOrientationEventCallback=registerDeviceOrientationEventCallback;var _emscripten_set_deviceorientation_callback_on_thread=(t,e,n,_)=>registerDeviceOrientationEventCallback(2,t,e,n,16,"deviceorientation",_);Module._emscripten_set_deviceorientation_callback_on_thread=_emscripten_set_deviceorientation_callback_on_thread,_emscripten_set_deviceorientation_callback_on_thread.sig="ipipp";var _emscripten_get_deviceorientation_status=t=>JSEvents.deviceOrientationEvent?(HEAP32.set(HEAP32.subarray(JSEvents.deviceOrientationEvent,32),t),0):-7;Module._emscripten_get_deviceorientation_status=_emscripten_get_deviceorientation_status,_emscripten_get_deviceorientation_status.sig="ip";var fillDeviceMotionEventData=(t,e,n)=>{var _=0,r=e.acceleration;_|=r&&1;var a=e.accelerationIncludingGravity;_|=a&&2;var o=e.rotationRate;_|=o&&4,r=r||{},a=a||{},o=o||{},HEAPF64[t>>3]=r.x,HEAPF64[t+8>>3]=r.y,HEAPF64[t+16>>3]=r.z,HEAPF64[t+24>>3]=a.x,HEAPF64[t+32>>3]=a.y,HEAPF64[t+40>>3]=a.z,HEAPF64[t+48>>3]=o.alpha,HEAPF64[t+56>>3]=o.beta,HEAPF64[t+64>>3]=o.gamma};Module.fillDeviceMotionEventData=fillDeviceMotionEventData;var registerDeviceMotionEventCallback=(t,e,n,_,r,a,o)=>{JSEvents.deviceMotionEvent||(JSEvents.deviceMotionEvent=_malloc(80));var l=(c=event)=>{fillDeviceMotionEventData(JSEvents.deviceMotionEvent,c,t),getWasmTableEntry(_)(r,JSEvents.deviceMotionEvent,e)&&c.preventDefault()},p={target:findEventTarget(t),eventTypeString:a,callbackfunc:_,handlerFunc:l,useCapture:n};return JSEvents.registerOrRemoveHandler(p)};Module.registerDeviceMotionEventCallback=registerDeviceMotionEventCallback;var _emscripten_set_devicemotion_callback_on_thread=(t,e,n,_)=>registerDeviceMotionEventCallback(2,t,e,n,17,"devicemotion",_);Module._emscripten_set_devicemotion_callback_on_thread=_emscripten_set_devicemotion_callback_on_thread,_emscripten_set_devicemotion_callback_on_thread.sig="ipipp";var _emscripten_get_devicemotion_status=t=>JSEvents.deviceMotionEvent?(HEAP32.set(HEAP32.subarray(JSEvents.deviceMotionEvent,80),t),0):-7;Module._emscripten_get_devicemotion_status=_emscripten_get_devicemotion_status,_emscripten_get_devicemotion_status.sig="ip";var screenOrientation=()=>{if(screen)return screen.orientation||screen.mozOrientation||screen.webkitOrientation||screen.msOrientation};Module.screenOrientation=screenOrientation;var fillOrientationChangeEventData=t=>{var e=["portrait-primary","portrait-secondary","landscape-primary","landscape-secondary"],n=["portrait","portrait","landscape","landscape"],_=screenOrientation(),r=e.indexOf(_);r==-1&&(r=n.indexOf(_)),HEAP32[t>>2]=1<<r,HEAP32[t+4>>2]=r};Module.fillOrientationChangeEventData=fillOrientationChangeEventData;var registerOrientationChangeEventCallback=(t,e,n,_,r,a,o)=>{JSEvents.orientationChangeEvent||(JSEvents.orientationChangeEvent=_malloc(8));var l=(c=event)=>{var I=JSEvents.orientationChangeEvent;fillOrientationChangeEventData(I),getWasmTableEntry(_)(r,I,e)&&c.preventDefault()};a=="orientationchange"&&screen.mozOrientation!==void 0&&(a="mozorientationchange");var p={target:t,eventTypeString:a,callbackfunc:_,handlerFunc:l,useCapture:n};return JSEvents.registerOrRemoveHandler(p)};Module.registerOrientationChangeEventCallback=registerOrientationChangeEventCallback;var _emscripten_set_orientationchange_callback_on_thread=(t,e,n,_)=>!screen||!screen.addEventListener?-1:registerOrientationChangeEventCallback(screen,t,e,n,18,"orientationchange",_);Module._emscripten_set_orientationchange_callback_on_thread=_emscripten_set_orientationchange_callback_on_thread,_emscripten_set_orientationchange_callback_on_thread.sig="ipipp";var _emscripten_get_orientation_status=t=>!screenOrientation()&&typeof orientation>"u"?-1:(fillOrientationChangeEventData(t),0);Module._emscripten_get_orientation_status=_emscripten_get_orientation_status,_emscripten_get_orientation_status.sig="ip";var _emscripten_lock_orientation=t=>{var e=[];t&1&&e.push("portrait-primary"),t&2&&e.push("portrait-secondary"),t&4&&e.push("landscape-primary"),t&8&&e.push("landscape-secondary");var n;if(screen.lockOrientation)n=screen.lockOrientation(e);else if(screen.mozLockOrientation)n=screen.mozLockOrientation(e);else if(screen.webkitLockOrientation)n=screen.webkitLockOrientation(e);else if(screen.msLockOrientation)n=screen.msLockOrientation(e);else return-1;return n?0:-6};Module._emscripten_lock_orientation=_emscripten_lock_orientation,_emscripten_lock_orientation.sig="ii";var _emscripten_unlock_orientation=()=>{if(screen.unlockOrientation)screen.unlockOrientation();else if(screen.mozUnlockOrientation)screen.mozUnlockOrientation();else if(screen.webkitUnlockOrientation)screen.webkitUnlockOrientation();else if(screen.msUnlockOrientation)screen.msUnlockOrientation();else return-1;return 0};Module._emscripten_unlock_orientation=_emscripten_unlock_orientation,_emscripten_unlock_orientation.sig="i";var fillFullscreenChangeEventData=t=>{var e=document.fullscreenElement||document.mozFullScreenElement||document.webkitFullscreenElement||document.msFullscreenElement,n=!!e;HEAP32[t>>2]=n,HEAP32[t+4>>2]=JSEvents.fullscreenEnabled();var _=n?e:JSEvents.previousFullscreenElement,r=JSEvents.getNodeNameForTarget(_),a=_&&_.id?_.id:"";stringToUTF8(r,t+8,128),stringToUTF8(a,t+136,128),HEAP32[t+264>>2]=_?_.clientWidth:0,HEAP32[t+268>>2]=_?_.clientHeight:0,HEAP32[t+272>>2]=screen.width,HEAP32[t+276>>2]=screen.height,n&&(JSEvents.previousFullscreenElement=e)};Module.fillFullscreenChangeEventData=fillFullscreenChangeEventData;var registerFullscreenChangeEventCallback=(t,e,n,_,r,a,o)=>{JSEvents.fullscreenChangeEvent||(JSEvents.fullscreenChangeEvent=_malloc(280));var l=(c=event)=>{var I=JSEvents.fullscreenChangeEvent;fillFullscreenChangeEventData(I),getWasmTableEntry(_)(r,I,e)&&c.preventDefault()},p={target:t,eventTypeString:a,callbackfunc:_,handlerFunc:l,useCapture:n};return JSEvents.registerOrRemoveHandler(p)};Module.registerFullscreenChangeEventCallback=registerFullscreenChangeEventCallback;var _emscripten_set_fullscreenchange_callback_on_thread=(t,e,n,_,r)=>JSEvents.fullscreenEnabled()?(t=findEventTarget(t),t?(registerFullscreenChangeEventCallback(t,e,n,_,19,"webkitfullscreenchange",r),registerFullscreenChangeEventCallback(t,e,n,_,19,"fullscreenchange",r)):-4):-1;Module._emscripten_set_fullscreenchange_callback_on_thread=_emscripten_set_fullscreenchange_callback_on_thread,_emscripten_set_fullscreenchange_callback_on_thread.sig="ippipp";var _emscripten_get_fullscreen_status=t=>JSEvents.fullscreenEnabled()?(fillFullscreenChangeEventData(t),0):-1;Module._emscripten_get_fullscreen_status=_emscripten_get_fullscreen_status,_emscripten_get_fullscreen_status.sig="ip";var _emscripten_get_canvas_element_size=(t,e,n)=>{var _=findCanvasEventTarget(t);if(!_)return-4;HEAP32[e>>2]=_.width,HEAP32[n>>2]=_.height};Module._emscripten_get_canvas_element_size=_emscripten_get_canvas_element_size,_emscripten_get_canvas_element_size.sig="ippp";var getCanvasElementSize=t=>withStackSave(()=>{var e=stackAlloc(8),n=e+4,_=stringToUTF8OnStack(t.id),r=_emscripten_get_canvas_element_size(_,e,n),a=[HEAP32[e>>2],HEAP32[n>>2]];return a});Module.getCanvasElementSize=getCanvasElementSize;var _emscripten_set_canvas_element_size=(t,e,n)=>{var _=findCanvasEventTarget(t);return _?(_.width=e,_.height=n,0):-4};Module._emscripten_set_canvas_element_size=_emscripten_set_canvas_element_size,_emscripten_set_canvas_element_size.sig="ipii";var setCanvasElementSize=(t,e,n)=>{t.controlTransferredOffscreen?withStackSave(()=>{var _=stringToUTF8OnStack(t.id);_emscripten_set_canvas_element_size(_,e,n)}):(t.width=e,t.height=n)};Module.setCanvasElementSize=setCanvasElementSize;var registerRestoreOldStyle=t=>{var e=getCanvasElementSize(t),n=e[0],_=e[1],r=t.style.width,a=t.style.height,o=t.style.backgroundColor,l=document.body.style.backgroundColor,p=t.style.paddingLeft,c=t.style.paddingRight,I=t.style.paddingTop,A=t.style.paddingBottom,m=t.style.marginLeft,E=t.style.marginRight,f=t.style.marginTop,R=t.style.marginBottom,h=document.body.style.margin,w=document.documentElement.style.overflow,g=document.body.scroll,O=t.style.imageRendering;function W(){var k=document.fullscreenElement||document.webkitFullscreenElement;k||(document.removeEventListener("fullscreenchange",W),document.removeEventListener("webkitfullscreenchange",W),setCanvasElementSize(t,n,_),t.style.width=r,t.style.height=a,t.style.backgroundColor=o,l||(document.body.style.backgroundColor="white"),document.body.style.backgroundColor=l,t.style.paddingLeft=p,t.style.paddingRight=c,t.style.paddingTop=I,t.style.paddingBottom=A,t.style.marginLeft=m,t.style.marginRight=E,t.style.marginTop=f,t.style.marginBottom=R,document.body.style.margin=h,document.documentElement.style.overflow=w,document.body.scroll=g,t.style.imageRendering=O,t.GLctxObject&&t.GLctxObject.GLctx.viewport(0,0,n,_),currentFullscreenStrategy.canvasResizedCallback&&getWasmTableEntry(currentFullscreenStrategy.canvasResizedCallback)(37,0,currentFullscreenStrategy.canvasResizedCallbackUserData))}return document.addEventListener("fullscreenchange",W),document.addEventListener("webkitfullscreenchange",W),W};Module.registerRestoreOldStyle=registerRestoreOldStyle;var setLetterbox=(t,e,n)=>{t.style.paddingLeft=t.style.paddingRight=n+"px",t.style.paddingTop=t.style.paddingBottom=e+"px"};Module.setLetterbox=setLetterbox;var JSEvents_resizeCanvasForFullscreen=(t,e)=>{var n=registerRestoreOldStyle(t),_=e.softFullscreen?innerWidth:screen.width,r=e.softFullscreen?innerHeight:screen.height,a=getBoundingClientRect(t),o=a.width,l=a.height,p=getCanvasElementSize(t),c=p[0],I=p[1];if(e.scaleMode==3)setLetterbox(t,(r-l)/2,(_-o)/2),_=o,r=l;else if(e.scaleMode==2)if(_*I<c*r){var A=I*_/c;setLetterbox(t,(r-A)/2,0),r=A}else{var m=c*r/I;setLetterbox(t,0,(_-m)/2),_=m}t.style.backgroundColor||(t.style.backgroundColor="black"),document.body.style.backgroundColor||(document.body.style.backgroundColor="black"),t.style.width=_+"px",t.style.height=r+"px",e.filteringMode==1&&(t.style.imageRendering="optimizeSpeed",t.style.imageRendering="-moz-crisp-edges",t.style.imageRendering="-o-crisp-edges",t.style.imageRendering="-webkit-optimize-contrast",t.style.imageRendering="optimize-contrast",t.style.imageRendering="crisp-edges",t.style.imageRendering="pixelated");var E=e.canvasResolutionScaleMode==2?devicePixelRatio:1;if(e.canvasResolutionScaleMode!=0){var f=_*E|0,R=r*E|0;setCanvasElementSize(t,f,R),t.GLctxObject&&t.GLctxObject.GLctx.viewport(0,0,f,R)}return n};Module.JSEvents_resizeCanvasForFullscreen=JSEvents_resizeCanvasForFullscreen;var JSEvents_requestFullscreen=(t,e)=>{if((e.scaleMode!=0||e.canvasResolutionScaleMode!=0)&&JSEvents_resizeCanvasForFullscreen(t,e),t.requestFullscreen)t.requestFullscreen();else if(t.webkitRequestFullscreen)t.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);else return JSEvents.fullscreenEnabled()?-3:-1;return currentFullscreenStrategy=e,e.canvasResizedCallback&&getWasmTableEntry(e.canvasResizedCallback)(37,0,e.canvasResizedCallbackUserData),0};Module.JSEvents_requestFullscreen=JSEvents_requestFullscreen;var hideEverythingExceptGivenElement=t=>{for(var e=t,n=e.parentNode,_=[];e!=document.body;){for(var r=n.children,a=0;a<r.length;++a)r[a]!=e&&(_.push({node:r[a],displayState:r[a].style.display}),r[a].style.display="none");e=n,n=n.parentNode}return _};Module.hideEverythingExceptGivenElement=hideEverythingExceptGivenElement;var restoreHiddenElements=t=>{for(var e=0;e<t.length;++e)t[e].node.style.display=t[e].displayState};Module.restoreHiddenElements=restoreHiddenElements;var currentFullscreenStrategy={};Module.currentFullscreenStrategy=currentFullscreenStrategy;var restoreOldWindowedStyle=null;Module.restoreOldWindowedStyle=restoreOldWindowedStyle;var softFullscreenResizeWebGLRenderTarget=()=>{var t=devicePixelRatio,e=currentFullscreenStrategy.canvasResolutionScaleMode==2,n=currentFullscreenStrategy.scaleMode==2,_=currentFullscreenStrategy.canvasResolutionScaleMode!=0,r=currentFullscreenStrategy.scaleMode==3,a=e?Math.round(innerWidth*t):innerWidth,o=e?Math.round(innerHeight*t):innerHeight,l=a,p=o,c=currentFullscreenStrategy.target,I=getCanvasElementSize(c),A=I[0],m=I[1],E;if(n&&(l*m<A*p?p=l*m/A|0:l*m>A*p&&(l=p*A/m|0),E=(o-p)/2|0),_&&(setCanvasElementSize(c,l,p),c.GLctxObject&&c.GLctxObject.GLctx.viewport(0,0,l,p)),e&&(E/=t,l/=t,p/=t,l=Math.round(l*1e4)/1e4,p=Math.round(p*1e4)/1e4,E=Math.round(E*1e4)/1e4),r){var f=(innerHeight-jstoi_q(c.style.height))/2,R=(innerWidth-jstoi_q(c.style.width))/2;setLetterbox(c,f,R)}else{c.style.width=l+"px",c.style.height=p+"px";var R=(innerWidth-l)/2;setLetterbox(c,E,R)}!r&&currentFullscreenStrategy.canvasResizedCallback&&getWasmTableEntry(currentFullscreenStrategy.canvasResizedCallback)(37,0,currentFullscreenStrategy.canvasResizedCallbackUserData)};Module.softFullscreenResizeWebGLRenderTarget=softFullscreenResizeWebGLRenderTarget;var doRequestFullscreen=(t,e)=>{if(!JSEvents.fullscreenEnabled())return-1;if(t=findEventTarget(t),!t)return-4;if(!t.requestFullscreen&&!t.webkitRequestFullscreen)return-3;var n=JSEvents.canPerformEventHandlerRequests();return n?JSEvents_requestFullscreen(t,e):e.deferUntilInEventHandler?(JSEvents.deferCall(JSEvents_requestFullscreen,1,[t,e]),1):-2};Module.doRequestFullscreen=doRequestFullscreen;var _emscripten_request_fullscreen=(t,e)=>{var n={scaleMode:0,canvasResolutionScaleMode:0,filteringMode:0,deferUntilInEventHandler:e,canvasResizedCallbackTargetThread:2};return doRequestFullscreen(t,n)};Module._emscripten_request_fullscreen=_emscripten_request_fullscreen,_emscripten_request_fullscreen.sig="ipi";var _emscripten_request_fullscreen_strategy=(t,e,n)=>{var _={scaleMode:HEAP32[n>>2],canvasResolutionScaleMode:HEAP32[n+4>>2],filteringMode:HEAP32[n+8>>2],deferUntilInEventHandler:e,canvasResizedCallback:HEAP32[n+12>>2],canvasResizedCallbackUserData:HEAP32[n+16>>2]};return doRequestFullscreen(t,_)};Module._emscripten_request_fullscreen_strategy=_emscripten_request_fullscreen_strategy,_emscripten_request_fullscreen_strategy.sig="ipip";var _emscripten_enter_soft_fullscreen=(t,e)=>{if(t=findEventTarget(t),!t)return-4;var n={scaleMode:HEAP32[e>>2],canvasResolutionScaleMode:HEAP32[e+4>>2],filteringMode:HEAP32[e+8>>2],canvasResizedCallback:HEAP32[e+12>>2],canvasResizedCallbackUserData:HEAP32[e+16>>2],target:t,softFullscreen:!0},_=JSEvents_resizeCanvasForFullscreen(t,n);document.documentElement.style.overflow="hidden",document.body.scroll="no",document.body.style.margin="0px";var r=hideEverythingExceptGivenElement(t);function a(){_(),restoreHiddenElements(r),removeEventListener("resize",softFullscreenResizeWebGLRenderTarget),n.canvasResizedCallback&&getWasmTableEntry(n.canvasResizedCallback)(37,0,n.canvasResizedCallbackUserData),currentFullscreenStrategy=0}return restoreOldWindowedStyle=a,currentFullscreenStrategy=n,addEventListener("resize",softFullscreenResizeWebGLRenderTarget),n.canvasResizedCallback&&getWasmTableEntry(n.canvasResizedCallback)(37,0,n.canvasResizedCallbackUserData),0};Module._emscripten_enter_soft_fullscreen=_emscripten_enter_soft_fullscreen,_emscripten_enter_soft_fullscreen.sig="ipp";var _emscripten_exit_soft_fullscreen=()=>(restoreOldWindowedStyle&&restoreOldWindowedStyle(),restoreOldWindowedStyle=null,0);Module._emscripten_exit_soft_fullscreen=_emscripten_exit_soft_fullscreen,_emscripten_exit_soft_fullscreen.sig="i";var _emscripten_exit_fullscreen=()=>{if(!JSEvents.fullscreenEnabled())return-1;JSEvents.removeDeferredCalls(JSEvents_requestFullscreen);var t=specialHTMLTargets[1];if(t.exitFullscreen)t.fullscreenElement&&t.exitFullscreen();else if(t.webkitExitFullscreen)t.webkitFullscreenElement&&t.webkitExitFullscreen();else return-1;return 0};Module._emscripten_exit_fullscreen=_emscripten_exit_fullscreen,_emscripten_exit_fullscreen.sig="i";var fillPointerlockChangeEventData=t=>{var e=document.pointerLockElement||document.mozPointerLockElement||document.webkitPointerLockElement||document.msPointerLockElement,n=!!e;HEAP32[t>>2]=n;var _=JSEvents.getNodeNameForTarget(e),r=e&&e.id?e.id:"";stringToUTF8(_,t+4,128),stringToUTF8(r,t+132,128)};Module.fillPointerlockChangeEventData=fillPointerlockChangeEventData;var registerPointerlockChangeEventCallback=(t,e,n,_,r,a,o)=>{JSEvents.pointerlockChangeEvent||(JSEvents.pointerlockChangeEvent=_malloc(260));var l=(c=event)=>{var I=JSEvents.pointerlockChangeEvent;fillPointerlockChangeEventData(I),getWasmTableEntry(_)(r,I,e)&&c.preventDefault()},p={target:t,eventTypeString:a,callbackfunc:_,handlerFunc:l,useCapture:n};return JSEvents.registerOrRemoveHandler(p)};Module.registerPointerlockChangeEventCallback=registerPointerlockChangeEventCallback;var _emscripten_set_pointerlockchange_callback_on_thread=(t,e,n,_,r)=>!document||!document.body||!document.body.requestPointerLock&&!document.body.mozRequestPointerLock&&!document.body.webkitRequestPointerLock&&!document.body.msRequestPointerLock?-1:(t=findEventTarget(t),t?(registerPointerlockChangeEventCallback(t,e,n,_,20,"mozpointerlockchange",r),registerPointerlockChangeEventCallback(t,e,n,_,20,"webkitpointerlockchange",r),registerPointerlockChangeEventCallback(t,e,n,_,20,"mspointerlockchange",r),registerPointerlockChangeEventCallback(t,e,n,_,20,"pointerlockchange",r)):-4);Module._emscripten_set_pointerlockchange_callback_on_thread=_emscripten_set_pointerlockchange_callback_on_thread,_emscripten_set_pointerlockchange_callback_on_thread.sig="ippipp";var registerPointerlockErrorEventCallback=(t,e,n,_,r,a,o)=>{var l=(c=event)=>{getWasmTableEntry(_)(r,0,e)&&c.preventDefault()},p={target:t,eventTypeString:a,callbackfunc:_,handlerFunc:l,useCapture:n};return JSEvents.registerOrRemoveHandler(p)};Module.registerPointerlockErrorEventCallback=registerPointerlockErrorEventCallback;var _emscripten_set_pointerlockerror_callback_on_thread=(t,e,n,_,r)=>!document||!document.body.requestPointerLock&&!document.body.mozRequestPointerLock&&!document.body.webkitRequestPointerLock&&!document.body.msRequestPointerLock?-1:(t=findEventTarget(t),t?(registerPointerlockErrorEventCallback(t,e,n,_,38,"mozpointerlockerror",r),registerPointerlockErrorEventCallback(t,e,n,_,38,"webkitpointerlockerror",r),registerPointerlockErrorEventCallback(t,e,n,_,38,"mspointerlockerror",r),registerPointerlockErrorEventCallback(t,e,n,_,38,"pointerlockerror",r)):-4);Module._emscripten_set_pointerlockerror_callback_on_thread=_emscripten_set_pointerlockerror_callback_on_thread,_emscripten_set_pointerlockerror_callback_on_thread.sig="ippipp";var _emscripten_get_pointerlock_status=t=>(t&&fillPointerlockChangeEventData(t),!document.body||!document.body.requestPointerLock&&!document.body.mozRequestPointerLock&&!document.body.webkitRequestPointerLock&&!document.body.msRequestPointerLock?-1:0);Module._emscripten_get_pointerlock_status=_emscripten_get_pointerlock_status,_emscripten_get_pointerlock_status.sig="ip";var requestPointerLock=t=>{if(t.requestPointerLock)t.requestPointerLock();else return document.body.requestPointerLock?-3:-1;return 0};Module.requestPointerLock=requestPointerLock;var _emscripten_request_pointerlock=(t,e)=>{if(t=findEventTarget(t),!t)return-4;if(!t.requestPointerLock)return-1;var n=JSEvents.canPerformEventHandlerRequests();return n?requestPointerLock(t):e?(JSEvents.deferCall(requestPointerLock,2,[t]),1):-2};Module._emscripten_request_pointerlock=_emscripten_request_pointerlock,_emscripten_request_pointerlock.sig="ipi";var _emscripten_exit_pointerlock=()=>{if(JSEvents.removeDeferredCalls(requestPointerLock),document.exitPointerLock)document.exitPointerLock();else return-1;return 0};Module._emscripten_exit_pointerlock=_emscripten_exit_pointerlock,_emscripten_exit_pointerlock.sig="i";var _emscripten_vibrate=t=>navigator.vibrate?(navigator.vibrate(t),0):-1;Module._emscripten_vibrate=_emscripten_vibrate,_emscripten_vibrate.sig="ii";var _emscripten_vibrate_pattern=(t,e)=>{if(!navigator.vibrate)return-1;for(var n=[],_=0;_<e;++_){var r=HEAP32[t+_*4>>2];n.push(r)}return navigator.vibrate(n),0};Module._emscripten_vibrate_pattern=_emscripten_vibrate_pattern,_emscripten_vibrate_pattern.sig="ipi";var fillVisibilityChangeEventData=t=>{var e=["hidden","visible","prerender","unloaded"],n=e.indexOf(document.visibilityState);HEAP32[t>>2]=document.hidden,HEAP32[t+4>>2]=n};Module.fillVisibilityChangeEventData=fillVisibilityChangeEventData;var registerVisibilityChangeEventCallback=(t,e,n,_,r,a,o)=>{JSEvents.visibilityChangeEvent||(JSEvents.visibilityChangeEvent=_malloc(8));var l=(c=event)=>{var I=JSEvents.visibilityChangeEvent;fillVisibilityChangeEventData(I),getWasmTableEntry(_)(r,I,e)&&c.preventDefault()},p={target:t,eventTypeString:a,callbackfunc:_,handlerFunc:l,useCapture:n};return JSEvents.registerOrRemoveHandler(p)};Module.registerVisibilityChangeEventCallback=registerVisibilityChangeEventCallback;var _emscripten_set_visibilitychange_callback_on_thread=(t,e,n,_)=>specialHTMLTargets[1]?registerVisibilityChangeEventCallback(specialHTMLTargets[1],t,e,n,21,"visibilitychange",_):-4;Module._emscripten_set_visibilitychange_callback_on_thread=_emscripten_set_visibilitychange_callback_on_thread,_emscripten_set_visibilitychange_callback_on_thread.sig="ipipp";var _emscripten_get_visibility_status=t=>typeof document.visibilityState>"u"&&typeof document.hidden>"u"?-1:(fillVisibilityChangeEventData(t),0);Module._emscripten_get_visibility_status=_emscripten_get_visibility_status,_emscripten_get_visibility_status.sig="ip";var registerTouchEventCallback=(t,e,n,_,r,a,o)=>{JSEvents.touchEvent||(JSEvents.touchEvent=_malloc(1696)),t=findEventTarget(t);var l=c=>{for(var I,A={},m=c.touches,E=0;E<m.length;++E)I=m[E],I.isChanged=I.onTarget=0,A[I.identifier]=I;for(var E=0;E<c.changedTouches.length;++E)I=c.changedTouches[E],I.isChanged=1,A[I.identifier]=I;for(var E=0;E<c.targetTouches.length;++E)A[c.targetTouches[E].identifier].onTarget=1;var f=JSEvents.touchEvent;HEAPF64[f>>3]=c.timeStamp;var R=f>>2;HEAP32[R+3]=c.ctrlKey,HEAP32[R+4]=c.shiftKey,HEAP32[R+5]=c.altKey,HEAP32[R+6]=c.metaKey,R+=7;var h=getBoundingClientRect(t),w=0;for(var E in A)if(I=A[E],HEAP32[R+0]=I.identifier,HEAP32[R+1]=I.screenX,HEAP32[R+2]=I.screenY,HEAP32[R+3]=I.clientX,HEAP32[R+4]=I.clientY,HEAP32[R+5]=I.pageX,HEAP32[R+6]=I.pageY,HEAP32[R+7]=I.isChanged,HEAP32[R+8]=I.onTarget,HEAP32[R+9]=I.clientX-h.left,HEAP32[R+10]=I.clientY-h.top,R+=13,++w>31)break;HEAP32[f+8>>2]=w,getWasmTableEntry(_)(r,f,e)&&c.preventDefault()},p={target:t,allowsDeferredCalls:a=="touchstart"||a=="touchend",eventTypeString:a,callbackfunc:_,handlerFunc:l,useCapture:n};return JSEvents.registerOrRemoveHandler(p)};Module.registerTouchEventCallback=registerTouchEventCallback;var _emscripten_set_touchstart_callback_on_thread=(t,e,n,_,r)=>registerTouchEventCallback(t,e,n,_,22,"touchstart",r);Module._emscripten_set_touchstart_callback_on_thread=_emscripten_set_touchstart_callback_on_thread,_emscripten_set_touchstart_callback_on_thread.sig="ippipp";var _emscripten_set_touchend_callback_on_thread=(t,e,n,_,r)=>registerTouchEventCallback(t,e,n,_,23,"touchend",r);Module._emscripten_set_touchend_callback_on_thread=_emscripten_set_touchend_callback_on_thread,_emscripten_set_touchend_callback_on_thread.sig="ippipp";var _emscripten_set_touchmove_callback_on_thread=(t,e,n,_,r)=>registerTouchEventCallback(t,e,n,_,24,"touchmove",r);Module._emscripten_set_touchmove_callback_on_thread=_emscripten_set_touchmove_callback_on_thread,_emscripten_set_touchmove_callback_on_thread.sig="ippipp";var _emscripten_set_touchcancel_callback_on_thread=(t,e,n,_,r)=>registerTouchEventCallback(t,e,n,_,25,"touchcancel",r);Module._emscripten_set_touchcancel_callback_on_thread=_emscripten_set_touchcancel_callback_on_thread,_emscripten_set_touchcancel_callback_on_thread.sig="ippipp";var fillGamepadEventData=(t,e)=>{HEAPF64[t>>3]=e.timestamp;for(var n=0;n<e.axes.length;++n)HEAPF64[t+n*8+16>>3]=e.axes[n];for(var n=0;n<e.buttons.length;++n)typeof e.buttons[n]=="object"?HEAPF64[t+n*8+528>>3]=e.buttons[n].value:HEAPF64[t+n*8+528>>3]=e.buttons[n];for(var n=0;n<e.buttons.length;++n)typeof e.buttons[n]=="object"?HEAP32[t+n*4+1040>>2]=e.buttons[n].pressed:HEAP32[t+n*4+1040>>2]=e.buttons[n]==1;HEAP32[t+1296>>2]=e.connected,HEAP32[t+1300>>2]=e.index,HEAP32[t+8>>2]=e.axes.length,HEAP32[t+12>>2]=e.buttons.length,stringToUTF8(e.id,t+1304,64),stringToUTF8(e.mapping,t+1368,64)};Module.fillGamepadEventData=fillGamepadEventData;var registerGamepadEventCallback=(t,e,n,_,r,a,o)=>{JSEvents.gamepadEvent||(JSEvents.gamepadEvent=_malloc(1432));var l=(c=event)=>{var I=JSEvents.gamepadEvent;fillGamepadEventData(I,c.gamepad),getWasmTableEntry(_)(r,I,e)&&c.preventDefault()},p={target:findEventTarget(t),allowsDeferredCalls:!0,eventTypeString:a,callbackfunc:_,handlerFunc:l,useCapture:n};return JSEvents.registerOrRemoveHandler(p)};Module.registerGamepadEventCallback=registerGamepadEventCallback;var _emscripten_set_gamepadconnected_callback_on_thread=(t,e,n,_)=>!navigator.getGamepads&&!navigator.webkitGetGamepads?-1:registerGamepadEventCallback(2,t,e,n,26,"gamepadconnected",_);Module._emscripten_set_gamepadconnected_callback_on_thread=_emscripten_set_gamepadconnected_callback_on_thread,_emscripten_set_gamepadconnected_callback_on_thread.sig="ipipp";var _emscripten_set_gamepaddisconnected_callback_on_thread=(t,e,n,_)=>!navigator.getGamepads&&!navigator.webkitGetGamepads?-1:registerGamepadEventCallback(2,t,e,n,27,"gamepaddisconnected",_);Module._emscripten_set_gamepaddisconnected_callback_on_thread=_emscripten_set_gamepaddisconnected_callback_on_thread,_emscripten_set_gamepaddisconnected_callback_on_thread.sig="ipipp";var _emscripten_sample_gamepad_data=()=>(JSEvents.lastGamepadState=navigator.getGamepads?navigator.getGamepads():navigator.webkitGetGamepads?navigator.webkitGetGamepads():null)?0:-1;Module._emscripten_sample_gamepad_data=_emscripten_sample_gamepad_data,_emscripten_sample_gamepad_data.sig="i";var _emscripten_get_num_gamepads=()=>JSEvents.lastGamepadState.length;Module._emscripten_get_num_gamepads=_emscripten_get_num_gamepads,_emscripten_get_num_gamepads.sig="i";var _emscripten_get_gamepad_status=(t,e)=>t<0||t>=JSEvents.lastGamepadState.length?-5:JSEvents.lastGamepadState[t]?(fillGamepadEventData(e,JSEvents.lastGamepadState[t]),0):-7;Module._emscripten_get_gamepad_status=_emscripten_get_gamepad_status,_emscripten_get_gamepad_status.sig="iip";var registerBeforeUnloadEventCallback=(t,e,n,_,r,a)=>{var o=(p=event)=>{var c=getWasmTableEntry(_)(r,0,e);if(c&&(c=UTF8ToString(c)),c)return p.preventDefault(),p.returnValue=c,c},l={target:findEventTarget(t),eventTypeString:a,callbackfunc:_,handlerFunc:o,useCapture:n};return JSEvents.registerOrRemoveHandler(l)};Module.registerBeforeUnloadEventCallback=registerBeforeUnloadEventCallback;var _emscripten_set_beforeunload_callback_on_thread=(t,e,n)=>typeof onbeforeunload>"u"?-1:n!==1?-5:registerBeforeUnloadEventCallback(2,t,!0,e,28,"beforeunload");Module._emscripten_set_beforeunload_callback_on_thread=_emscripten_set_beforeunload_callback_on_thread,_emscripten_set_beforeunload_callback_on_thread.sig="ippp";var fillBatteryEventData=(t,e)=>{HEAPF64[t>>3]=e.chargingTime,HEAPF64[t+8>>3]=e.dischargingTime,HEAPF64[t+16>>3]=e.level,HEAP32[t+24>>2]=e.charging};Module.fillBatteryEventData=fillBatteryEventData;var battery=()=>navigator.battery||navigator.mozBattery||navigator.webkitBattery;Module.battery=battery;var registerBatteryEventCallback=(t,e,n,_,r,a,o)=>{JSEvents.batteryEvent||(JSEvents.batteryEvent=_malloc(32));var l=(c=event)=>{var I=JSEvents.batteryEvent;fillBatteryEventData(I,battery()),getWasmTableEntry(_)(r,I,e)&&c.preventDefault()},p={target:findEventTarget(t),eventTypeString:a,callbackfunc:_,handlerFunc:l,useCapture:n};return JSEvents.registerOrRemoveHandler(p)};Module.registerBatteryEventCallback=registerBatteryEventCallback;var _emscripten_set_batterychargingchange_callback_on_thread=(t,e,n)=>battery()?registerBatteryEventCallback(battery(),t,!0,e,29,"chargingchange",n):-1;Module._emscripten_set_batterychargingchange_callback_on_thread=_emscripten_set_batterychargingchange_callback_on_thread,_emscripten_set_batterychargingchange_callback_on_thread.sig="ippp";var _emscripten_set_batterylevelchange_callback_on_thread=(t,e,n)=>battery()?registerBatteryEventCallback(battery(),t,!0,e,30,"levelchange",n):-1;Module._emscripten_set_batterylevelchange_callback_on_thread=_emscripten_set_batterylevelchange_callback_on_thread,_emscripten_set_batterylevelchange_callback_on_thread.sig="ippp";var _emscripten_get_battery_status=t=>battery()?(fillBatteryEventData(t,battery()),0):-1;Module._emscripten_get_battery_status=_emscripten_get_battery_status,_emscripten_get_battery_status.sig="ip";var _emscripten_set_element_css_size=(t,e,n)=>(t=findEventTarget(t),t?(t.style.width=e+"px",t.style.height=n+"px",0):-4);Module._emscripten_set_element_css_size=_emscripten_set_element_css_size,_emscripten_set_element_css_size.sig="ipdd";var _emscripten_get_element_css_size=(t,e,n)=>{if(t=findEventTarget(t),!t)return-4;var _=getBoundingClientRect(t);return HEAPF64[e>>3]=_.width,HEAPF64[n>>3]=_.height,0};Module._emscripten_get_element_css_size=_emscripten_get_element_css_size,_emscripten_get_element_css_size.sig="ippp";var _emscripten_html5_remove_all_event_listeners=()=>JSEvents.removeAllEventListeners();Module._emscripten_html5_remove_all_event_listeners=_emscripten_html5_remove_all_event_listeners,_emscripten_html5_remove_all_event_listeners.sig="v";var _emscripten_request_animation_frame=(t,e)=>requestAnimationFrame(n=>getWasmTableEntry(t)(n,e));Module._emscripten_request_animation_frame=_emscripten_request_animation_frame,_emscripten_request_animation_frame.sig="ipp";var _emscripten_cancel_animation_frame=t=>cancelAnimationFrame(t);Module._emscripten_cancel_animation_frame=_emscripten_cancel_animation_frame,_emscripten_cancel_animation_frame.sig="vi";var _emscripten_request_animation_frame_loop=(t,e)=>{function n(_){getWasmTableEntry(t)(_,e)&&requestAnimationFrame(n)}return requestAnimationFrame(n)};Module._emscripten_request_animation_frame_loop=_emscripten_request_animation_frame_loop,_emscripten_request_animation_frame_loop.sig="vpp";var _emscripten_performance_now=()=>performance.now();Module._emscripten_performance_now=_emscripten_performance_now,_emscripten_performance_now.sig="d";var _emscripten_get_device_pixel_ratio=()=>typeof devicePixelRatio=="number"&&devicePixelRatio||1;Module._emscripten_get_device_pixel_ratio=_emscripten_get_device_pixel_ratio,_emscripten_get_device_pixel_ratio.sig="d";function _random_get(t,e){try{return _getentropy(t,e),0}catch(n){if(typeof FS>"u"||n.name!=="ErrnoError")throw n;return n.errno}}Module._random_get=_random_get,_random_get.sig="ipp";var checkWasiClock=t=>t==0||t==1||t==2||t==3;Module.checkWasiClock=checkWasiClock;function _clock_time_get(t,e,n){if(e=bigintToI53Checked(e),!checkWasiClock(t))return 28;var _;if(t===0)_=Date.now();else if(nowIsMonotonic)_=_emscripten_get_now();else return 52;var r=Math.round(_*1e3*1e3);return HEAP32[n>>2]=r>>>0,HEAP32[n+4>>2]=r/Math.pow(2,32)>>>0,0}Module._clock_time_get=_clock_time_get,_clock_time_get.sig="iijp";var _clock_res_get=(t,e)=>{if(!checkWasiClock(t))return 28;var n;if(t===0)n=1e3*1e3;else if(nowIsMonotonic)n=_emscripten_get_now_res();else return 52;return HEAP32[e>>2]=n>>>0,HEAP32[e+4>>2]=n/Math.pow(2,32)>>>0,0};Module._clock_res_get=_clock_res_get,_clock_res_get.sig="iip";var wasiRightsToMuslOFlags=t=>{if(t&2&&t&64)return 2;if(t&2)return 0;if(t&64)return 1;throw new FS.ErrnoError(28)};Module.wasiRightsToMuslOFlags=wasiRightsToMuslOFlags;var wasiOFlagsToMuslOFlags=t=>{var e=0;return t&1&&(e|=64),t&8&&(e|=512),t&2&&(e|=65536),t&4&&(e|=128),e};Module.wasiOFlagsToMuslOFlags=wasiOFlagsToMuslOFlags;var createDyncallWrapper=t=>{var e=[],n=[0,97,115,109,1,0,0,0];e.push(n);var _=[t[0].replace("j","i"),"i",t.slice(1).replace(/j/g,"ii")].join(""),r=[3];generateFuncType(_,r),generateFuncType(t,r),generateFuncType("vi",r);var a=[1];uleb128Encode(r.length,a),a.push.apply(a,r),e.push(a);var o=[2,15,2,1,101,1,116,1,112,0,0,1,101,1,114,0,2];e.push(o);var l=[3,2,1,0];e.push(l);var p=[7,5,1,1,102,0,1];e.push(p);var c=[];t[0]==="j"?c=[1,1,126]:c.push(0);function I(O){c.push(32),uleb128Encode(O,c)}for(var A=1,m=1;m<t.length;m++)t[m]=="j"?(I(A+1),c.push(173,66,32,134),I(A),c.push(172,132),A+=2):(I(A),A++);c.push(32,0,17,1,0),t[0]==="j"&&(c.push(34),uleb128Encode(A,c),c.push(66,32,136,167,16,0),I(A),c.push(167)),c.push(11);var E=[1];uleb128Encode(c.length,E),E.push.apply(E,c);var f=[10];uleb128Encode(E.length,f),f.push.apply(f,E),e.push(f);var R=new Uint8Array([].concat.apply([],e)),h=new WebAssembly.Module(R),w=new WebAssembly.Instance(h,{e:{t:wasmTable,r:setTempRet0}}),g=w.exports.f;return g};Module.createDyncallWrapper=createDyncallWrapper;var _emscripten_unwind_to_js_event_loop=()=>{throw"unwind"};Module._emscripten_unwind_to_js_event_loop=_emscripten_unwind_to_js_event_loop,_emscripten_unwind_to_js_event_loop.sig="v";var setImmediateWrapped=t=>{setImmediateWrapped.mapping||(setImmediateWrapped.mapping=[]);var e=setImmediateWrapped.mapping.length;return setImmediateWrapped.mapping[e]=setImmediate(()=>{setImmediateWrapped.mapping[e]=void 0,t()}),e};Module.setImmediateWrapped=setImmediateWrapped;var clearImmediateWrapped=t=>{clearImmediate(setImmediateWrapped.mapping[t]),setImmediateWrapped.mapping[t]=void 0};Module.clearImmediateWrapped=clearImmediateWrapped;var polyfillSetImmediate=()=>{};Module.polyfillSetImmediate=polyfillSetImmediate;var _emscripten_set_immediate=(t,e)=>(polyfillSetImmediate(),emSetImmediate(function(){callUserCallback(function(){getWasmTableEntry(t)(e)})}));Module._emscripten_set_immediate=_emscripten_set_immediate,_emscripten_set_immediate.sig="ipp";var _emscripten_clear_immediate=t=>{emClearImmediate(t)};Module._emscripten_clear_immediate=_emscripten_clear_immediate,_emscripten_clear_immediate.sig="vi";var _emscripten_set_immediate_loop=(t,e)=>{polyfillSetImmediate();function n(){callUserCallback(function(){getWasmTableEntry(t)(e)&&emSetImmediate(n)})}emSetImmediate(n)};Module._emscripten_set_immediate_loop=_emscripten_set_immediate_loop,_emscripten_set_immediate_loop.sig="vpp";var _emscripten_set_timeout=(t,e,n)=>safeSetTimeout(()=>getWasmTableEntry(t)(n),e);Module._emscripten_set_timeout=_emscripten_set_timeout,_emscripten_set_timeout.sig="ipdp";var _emscripten_clear_timeout=t=>clearTimeout(t);Module._emscripten_clear_timeout=_emscripten_clear_timeout,_emscripten_clear_timeout.sig="vi";var _emscripten_set_timeout_loop=(t,e,n)=>{function _(){var r=_emscripten_get_now(),a=r+e;callUserCallback(function(){getWasmTableEntry(t)(r,n)&&setTimeout(_,a-_emscripten_get_now())})}return setTimeout(_,0)};Module._emscripten_set_timeout_loop=_emscripten_set_timeout_loop,_emscripten_set_timeout_loop.sig="vpdp";var _emscripten_set_interval=(t,e,n)=>setInterval(function(){callUserCallback(function(){getWasmTableEntry(t)(n)})},e);Module._emscripten_set_interval=_emscripten_set_interval,_emscripten_set_interval.sig="ipdp";var _emscripten_clear_interval=t=>{clearInterval(t)};Module._emscripten_clear_interval=_emscripten_clear_interval,_emscripten_clear_interval.sig="vi";var idsToPromises=(t,e)=>{for(var n=[],_=0;_<e;_++){var r=HEAP32[t+_*4>>2];n[_]=getPromise(r)}return n};Module.idsToPromises=idsToPromises;var makePromiseCallback=(t,e)=>n=>{var _=stackSave(),r=stackAlloc(POINTER_SIZE);HEAPU32[r>>2]=0;try{var a=getWasmTableEntry(t)(r,e,n),o=HEAPU32[r>>2]}catch(p){throw typeof p!="number"?0:p}finally{stackRestore(_)}switch(a){case 0:return o;case 1:return getPromise(o);case 2:var l=getPromise(o);return _emscripten_promise_destroy(o),l;case 3:throw o}};Module.makePromiseCallback=makePromiseCallback;var _emscripten_promise_then=(t,e,n,_)=>{var r=getPromise(t),a=promiseMap.allocate({promise:r.then(makePromiseCallback(e,_),makePromiseCallback(n,_))});return a};Module._emscripten_promise_then=_emscripten_promise_then,_emscripten_promise_then.sig="ppppp";var _emscripten_promise_all=(t,e,n)=>{var _=idsToPromises(t,n),r=promiseMap.allocate({promise:Promise.all(_).then(a=>{if(e)for(var o=0;o<n;o++){var l=a[o];HEAPU32[e+o*4>>2]=l}return e})});return r};Module._emscripten_promise_all=_emscripten_promise_all,_emscripten_promise_all.sig="pppp";var setPromiseResult=(t,e,n)=>{var _=e?0:3;HEAP32[t>>2]=_,HEAPU32[t+4>>2]=n};Module.setPromiseResult=setPromiseResult;var _emscripten_promise_all_settled=(t,e,n)=>{var _=idsToPromises(t,n),r=promiseMap.allocate({promise:Promise.allSettled(_).then(a=>{if(e)for(var o=e,l=0;l<n;l++,o+=8)a[l].status==="fulfilled"?setPromiseResult(o,!0,a[l].value):setPromiseResult(o,!1,a[l].reason);return e})});return r};Module._emscripten_promise_all_settled=_emscripten_promise_all_settled,_emscripten_promise_all_settled.sig="pppp";var _emscripten_promise_any=(t,e,n)=>{var _=idsToPromises(t,n),r=promiseMap.allocate({promise:Promise.any(_).catch(a=>{if(e)for(var o=0;o<n;o++)HEAPU32[e+o*4>>2]=a.errors[o];throw e})});return r};Module._emscripten_promise_any=_emscripten_promise_any,_emscripten_promise_any.sig="pppp";var _emscripten_promise_race=(t,e)=>{var n=idsToPromises(t,e),_=promiseMap.allocate({promise:Promise.race(n)});return _};Module._emscripten_promise_race=_emscripten_promise_race,_emscripten_promise_race.sig="ppp";var _emscripten_promise_await=(t,e)=>{abort("emscripten_promise_await is only available with ASYNCIFY")};Module._emscripten_promise_await=_emscripten_promise_await,_emscripten_promise_await.sig="vpp";var ___cxa_find_matching_catch_4=(t,e)=>findMatchingCatch([t,e]);Module.___cxa_find_matching_catch_4=___cxa_find_matching_catch_4,___cxa_find_matching_catch_4.sig="ppp";var _llvm_eh_typeid_for=t=>t;Module._llvm_eh_typeid_for=_llvm_eh_typeid_for,_llvm_eh_typeid_for.sig="vp";var ___cxa_get_exception_ptr=t=>{var e=new ExceptionInfo(t).get_exception_ptr();return e};Module.___cxa_get_exception_ptr=___cxa_get_exception_ptr,___cxa_get_exception_ptr.sig="pp";var ___cxa_call_unexpected=t=>abort("Unexpected exception thrown, this is not properly supported - aborting");Module.___cxa_call_unexpected=___cxa_call_unexpected,___cxa_call_unexpected.sig="vp";var _emscripten_set_main_loop_timing=(t,e)=>{if(Browser.mainLoop.timingMode=t,Browser.mainLoop.timingValue=e,!Browser.mainLoop.func)return 1;if(Browser.mainLoop.running||(Browser.mainLoop.running=!0),t==0)Browser.mainLoop.scheduler=function(){var o=Math.max(0,Browser.mainLoop.tickStartTime+e-_emscripten_get_now())|0;setTimeout(Browser.mainLoop.runner,o)},Browser.mainLoop.method="timeout";else if(t==1)Browser.mainLoop.scheduler=function(){Browser.requestAnimationFrame(Browser.mainLoop.runner)},Browser.mainLoop.method="rAF";else if(t==2){if(typeof setImmediate>"u"){var n=[],_="setimmediate",r=a=>{(a.data===_||a.data.target===_)&&(a.stopPropagation(),n.shift()())};addEventListener("message",r,!0),setImmediate=function(o){n.push(o),ENVIRONMENT_IS_WORKER?(Module.setImmediates===void 0&&(Module.setImmediates=[]),Module.setImmediates.push(o),postMessage({target:_})):postMessage(_,"*")}}Browser.mainLoop.scheduler=function(){setImmediate(Browser.mainLoop.runner)},Browser.mainLoop.method="immediate"}return 0};Module._emscripten_set_main_loop_timing=_emscripten_set_main_loop_timing,_emscripten_set_main_loop_timing.sig="iii";var setMainLoop=(t,e,n,_,r)=>{assert(!Browser.mainLoop.func,"emscripten_set_main_loop: there can only be one main loop function at once: call emscripten_cancel_main_loop to cancel the previous one before setting a new one with different parameters."),Browser.mainLoop.func=t,Browser.mainLoop.arg=_;var a=Browser.mainLoop.currentlyRunningMainloop;function o(){return!(a<Browser.mainLoop.currentlyRunningMainloop)}if(Browser.mainLoop.running=!1,Browser.mainLoop.runner=function(){if(!ABORT){if(Browser.mainLoop.queue.length>0){var p=Date.now(),c=Browser.mainLoop.queue.shift();if(c.func(c.arg),Browser.mainLoop.remainingBlockers){var I=Browser.mainLoop.remainingBlockers,A=I%1==0?I-1:Math.floor(I);c.counted?Browser.mainLoop.remainingBlockers=A:(A=A+.5,Browser.mainLoop.remainingBlockers=(8*I+A)/9)}if(Browser.mainLoop.updateStatus(),!o())return;setTimeout(Browser.mainLoop.runner,0);return}if(o()){if(Browser.mainLoop.currentFrameNumber=Browser.mainLoop.currentFrameNumber+1|0,Browser.mainLoop.timingMode==1&&Browser.mainLoop.timingValue>1&&Browser.mainLoop.currentFrameNumber%Browser.mainLoop.timingValue!=0){Browser.mainLoop.scheduler();return}else Browser.mainLoop.timingMode==0&&(Browser.mainLoop.tickStartTime=_emscripten_get_now());Browser.mainLoop.runIter(t),o()&&(typeof SDL=="object"&&SDL.audio&&SDL.audio.queueNewAudioData&&SDL.audio.queueNewAudioData(),Browser.mainLoop.scheduler())}}},r||(e&&e>0?_emscripten_set_main_loop_timing(0,1e3/e):_emscripten_set_main_loop_timing(1,1),Browser.mainLoop.scheduler()),n)throw"unwind"};Module.setMainLoop=setMainLoop;var Browser={mainLoop:{running:!1,scheduler:null,method:"",currentlyRunningMainloop:0,func:null,arg:0,timingMode:0,timingValue:0,currentFrameNumber:0,queue:[],pause(){Browser.mainLoop.scheduler=null,Browser.mainLoop.currentlyRunningMainloop++},resume(){Browser.mainLoop.currentlyRunningMainloop++;var t=Browser.mainLoop.timingMode,e=Browser.mainLoop.timingValue,n=Browser.mainLoop.func;Browser.mainLoop.func=null,setMainLoop(n,0,!1,Browser.mainLoop.arg,!0),_emscripten_set_main_loop_timing(t,e),Browser.mainLoop.scheduler()},updateStatus(){if(Module.setStatus){var t=Module.statusMessage||"Please wait...",e=Browser.mainLoop.remainingBlockers,n=Browser.mainLoop.expectedBlockers;e?e<n?Module.setStatus(t+" ("+(n-e)+"/"+n+")"):Module.setStatus(t):Module.setStatus("")}},runIter(t){if(!ABORT){if(Module.preMainLoop){var e=Module.preMainLoop();if(e===!1)return}callUserCallback(t),Module.postMainLoop&&Module.postMainLoop()}}},isFullscreen:!1,pointerLock:!1,moduleContextCreatedCallbacks:[],workers:[],init(){if(Browser.initted)return;Browser.initted=!0;var t={};t.canHandle=function(a){return!Module.noImageDecoding&&/\.(jpg|jpeg|png|bmp)$/i.test(a)},t.handle=function(a,o,l,p){var c=new Blob([a],{type:Browser.getMimetype(o)});c.size!==a.length&&(c=new Blob([new Uint8Array(a).buffer],{type:Browser.getMimetype(o)}));var I=URL.createObjectURL(c),A=new Image;A.onload=()=>{assert(A.complete,`Image ${o} could not be decoded`);var m=document.createElement("canvas");m.width=A.width,m.height=A.height;var E=m.getContext("2d");E.drawImage(A,0,0),preloadedImages[o]=m,URL.revokeObjectURL(I),l&&l(a)},A.onerror=m=>{err(`Image ${I} could not be decoded`),p&&p()},A.src=I},preloadPlugins.push(t);var e={};e.canHandle=function(a){return!Module.noAudioDecoding&&a.substr(-4)in{".ogg":1,".wav":1,".mp3":1}},e.handle=function(a,o,l,p){var c=!1;function I(R){c||(c=!0,preloadedAudios[o]=R,l&&l(a))}function A(){c||(c=!0,preloadedAudios[o]=new Audio,p&&p())}var m=new Blob([a],{type:Browser.getMimetype(o)}),E=URL.createObjectURL(m),f=new Audio;f.addEventListener("canplaythrough",()=>I(f),!1),f.onerror=function(h){if(c)return;err(`warning: browser could not fully decode audio ${o}, trying slower base64 approach`);function w(g){for(var O="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",W="=",k="",Z=0,v=0,tt=0;tt<g.length;tt++)for(Z=Z<<8|g[tt],v+=8;v>=6;){var z=Z>>v-6&63;v-=6,k+=O[z]}return v==2?(k+=O[(Z&3)<<4],k+=W+W):v==4&&(k+=O[(Z&15)<<2],k+=W),k}f.src="data:audio/x-"+o.substr(-3)+";base64,"+w(a),I(f)},f.src=E,safeSetTimeout(()=>{I(f)},1e4)},preloadPlugins.push(e);function n(){Browser.pointerLock=document.pointerLockElement===Module.canvas||document.mozPointerLockElement===Module.canvas||document.webkitPointerLockElement===Module.canvas||document.msPointerLockElement===Module.canvas}var _=Module.canvas;_&&(_.requestPointerLock=_.requestPointerLock||_.mozRequestPointerLock||_.webkitRequestPointerLock||_.msRequestPointerLock||(()=>{}),_.exitPointerLock=document.exitPointerLock||document.mozExitPointerLock||document.webkitExitPointerLock||document.msExitPointerLock||(()=>{}),_.exitPointerLock=_.exitPointerLock.bind(document),document.addEventListener("pointerlockchange",n,!1),document.addEventListener("mozpointerlockchange",n,!1),document.addEventListener("webkitpointerlockchange",n,!1),document.addEventListener("mspointerlockchange",n,!1),Module.elementPointerLock&&_.addEventListener("click",r=>{!Browser.pointerLock&&Module.canvas.requestPointerLock&&(Module.canvas.requestPointerLock(),r.preventDefault())},!1))},createContext(t,e,n,_){if(e&&Module.ctx&&t==Module.canvas)return Module.ctx;var r,a;if(e){var o={antialias:!1,alpha:!1,majorVersion:1};if(_)for(var l in _)o[l]=_[l];typeof GL<"u"&&(a=GL.createContext(t,o),a&&(r=GL.getContext(a).GLctx))}else r=t.getContext("2d");return r?(n&&(e||assert(typeof GLctx>"u","cannot set in module if GLctx is used, but we are a non-GL context that would replace it"),Module.ctx=r,e&&GL.makeContextCurrent(a),Module.useWebGL=e,Browser.moduleContextCreatedCallbacks.forEach(p=>p()),Browser.init()),r):null},destroyContext(t,e,n){},fullscreenHandlersInstalled:!1,lockPointer:void 0,resizeCanvas:void 0,requestFullscreen(t,e){Browser.lockPointer=t,Browser.resizeCanvas=e,typeof Browser.lockPointer>"u"&&(Browser.lockPointer=!0),typeof Browser.resizeCanvas>"u"&&(Browser.resizeCanvas=!1);var n=Module.canvas;function _(){Browser.isFullscreen=!1;var a=n.parentNode;(document.fullscreenElement||document.mozFullScreenElement||document.msFullscreenElement||document.webkitFullscreenElement||document.webkitCurrentFullScreenElement)===a?(n.exitFullscreen=Browser.exitFullscreen,Browser.lockPointer&&n.requestPointerLock(),Browser.isFullscreen=!0,Browser.resizeCanvas?Browser.setFullscreenCanvasSize():Browser.updateCanvasDimensions(n)):(a.parentNode.insertBefore(n,a),a.parentNode.removeChild(a),Browser.resizeCanvas?Browser.setWindowedCanvasSize():Browser.updateCanvasDimensions(n)),Module.onFullScreen&&Module.onFullScreen(Browser.isFullscreen),Module.onFullscreen&&Module.onFullscreen(Browser.isFullscreen)}Browser.fullscreenHandlersInstalled||(Browser.fullscreenHandlersInstalled=!0,document.addEventListener("fullscreenchange",_,!1),document.addEventListener("mozfullscreenchange",_,!1),document.addEventListener("webkitfullscreenchange",_,!1),document.addEventListener("MSFullscreenChange",_,!1));var r=document.createElement("div");n.parentNode.insertBefore(r,n),r.appendChild(n),r.requestFullscreen=r.requestFullscreen||r.mozRequestFullScreen||r.msRequestFullscreen||(r.webkitRequestFullscreen?()=>r.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT):null)||(r.webkitRequestFullScreen?()=>r.webkitRequestFullScreen(Element.ALLOW_KEYBOARD_INPUT):null),r.requestFullscreen()},exitFullscreen(){if(!Browser.isFullscreen)return!1;var t=document.exitFullscreen||document.cancelFullScreen||document.mozCancelFullScreen||document.msExitFullscreen||document.webkitCancelFullScreen||(()=>{});return t.apply(document,[]),!0},nextRAF:0,fakeRequestAnimationFrame(t){var e=Date.now();if(Browser.nextRAF===0)Browser.nextRAF=e+1e3/60;else for(;e+2>=Browser.nextRAF;)Browser.nextRAF+=1e3/60;var n=Math.max(Browser.nextRAF-e,0);setTimeout(t,n)},requestAnimationFrame(t){if(typeof requestAnimationFrame=="function"){requestAnimationFrame(t);return}var e=Browser.fakeRequestAnimationFrame;e(t)},safeSetTimeout(t,e){return safeSetTimeout(t,e)},safeRequestAnimationFrame(t){return Browser.requestAnimationFrame(()=>{callUserCallback(t)})},getMimetype(t){return{jpg:"image/jpeg",jpeg:"image/jpeg",png:"image/png",bmp:"image/bmp",ogg:"audio/ogg",wav:"audio/wav",mp3:"audio/mpeg"}[t.substr(t.lastIndexOf(".")+1)]},getUserMedia(t){window.getUserMedia||(window.getUserMedia=navigator.getUserMedia||navigator.mozGetUserMedia),window.getUserMedia(t)},getMovementX(t){return t.movementX||t.mozMovementX||t.webkitMovementX||0},getMovementY(t){return t.movementY||t.mozMovementY||t.webkitMovementY||0},getMouseWheelDelta(t){var e=0;switch(t.type){case"DOMMouseScroll":e=t.detail/3;break;case"mousewheel":e=t.wheelDelta/120;break;case"wheel":switch(e=t.deltaY,t.deltaMode){case 0:e/=100;break;case 1:e/=3;break;case 2:e*=80;break;default:throw"unrecognized mouse wheel delta mode: "+t.deltaMode}break;default:throw"unrecognized mouse wheel event: "+t.type}return e},mouseX:0,mouseY:0,mouseMovementX:0,mouseMovementY:0,touches:{},lastTouches:{},calculateMouseEvent(t){if(Browser.pointerLock)t.type!="mousemove"&&"mozMovementX"in t?Browser.mouseMovementX=Browser.mouseMovementY=0:(Browser.mouseMovementX=Browser.getMovementX(t),Browser.mouseMovementY=Browser.getMovementY(t)),typeof SDL<"u"?(Browser.mouseX=SDL.mouseX+Browser.mouseMovementX,Browser.mouseY=SDL.mouseY+Browser.mouseMovementY):(Browser.mouseX+=Browser.mouseMovementX,Browser.mouseY+=Browser.mouseMovementY);else{var e=Module.canvas.getBoundingClientRect(),n=Module.canvas.width,_=Module.canvas.height,r=typeof window.scrollX<"u"?window.scrollX:window.pageXOffset,a=typeof window.scrollY<"u"?window.scrollY:window.pageYOffset;if(t.type==="touchstart"||t.type==="touchend"||t.type==="touchmove"){var o=t.touch;if(o===void 0)return;var l=o.pageX-(r+e.left),p=o.pageY-(a+e.top);l=l*(n/e.width),p=p*(_/e.height);var c={x:l,y:p};if(t.type==="touchstart")Browser.lastTouches[o.identifier]=c,Browser.touches[o.identifier]=c;else if(t.type==="touchend"||t.type==="touchmove"){var I=Browser.touches[o.identifier];I||(I=c),Browser.lastTouches[o.identifier]=I,Browser.touches[o.identifier]=c}return}var A=t.pageX-(r+e.left),m=t.pageY-(a+e.top);A=A*(n/e.width),m=m*(_/e.height),Browser.mouseMovementX=A-Browser.mouseX,Browser.mouseMovementY=m-Browser.mouseY,Browser.mouseX=A,Browser.mouseY=m}},resizeListeners:[],updateResizeListeners(){var t=Module.canvas;Browser.resizeListeners.forEach(e=>e(t.width,t.height))},setCanvasSize(t,e,n){var _=Module.canvas;Browser.updateCanvasDimensions(_,t,e),n||Browser.updateResizeListeners()},windowedWidth:0,windowedHeight:0,setFullscreenCanvasSize(){if(typeof SDL<"u"){var t=HEAPU32[SDL.screen>>2];t=t|8388608,HEAP32[SDL.screen>>2]=t}Browser.updateCanvasDimensions(Module.canvas),Browser.updateResizeListeners()},setWindowedCanvasSize(){if(typeof SDL<"u"){var t=HEAPU32[SDL.screen>>2];t=t&-8388609,HEAP32[SDL.screen>>2]=t}Browser.updateCanvasDimensions(Module.canvas),Browser.updateResizeListeners()},updateCanvasDimensions(t,e,n){e&&n?(t.widthNative=e,t.heightNative=n):(e=t.widthNative,n=t.heightNative);var _=e,r=n;if(Module.forcedAspectRatio&&Module.forcedAspectRatio>0&&(_/r<Module.forcedAspectRatio?_=Math.round(r*Module.forcedAspectRatio):r=Math.round(_/Module.forcedAspectRatio)),(document.fullscreenElement||document.mozFullScreenElement||document.msFullscreenElement||document.webkitFullscreenElement||document.webkitCurrentFullScreenElement)===t.parentNode&&typeof screen<"u"){var a=Math.min(screen.width/_,screen.height/r);_=Math.round(_*a),r=Math.round(r*a)}Browser.resizeCanvas?(t.width!=_&&(t.width=_),t.height!=r&&(t.height=r),typeof t.style<"u"&&(t.style.removeProperty("width"),t.style.removeProperty("height"))):(t.width!=e&&(t.width=e),t.height!=n&&(t.height=n),typeof t.style<"u"&&(_!=e||r!=n?(t.style.setProperty("width",_+"px","important"),t.style.setProperty("height",r+"px","important")):(t.style.removeProperty("width"),t.style.removeProperty("height"))))}};Module.Browser=Browser;var _emscripten_run_preload_plugins=(t,e,n)=>{var _=UTF8ToString(t),r=FS.analyzePath(_);return r.exists?(FS.createPreloadedFile(PATH.dirname(_),PATH.basename(_),new Uint8Array(r.object.contents),!0,!0,()=>{e&&getWasmTableEntry(e)(t)},()=>{n&&getWasmTableEntry(n)(t)},!0),0):-1};Module._emscripten_run_preload_plugins=_emscripten_run_preload_plugins,_emscripten_run_preload_plugins.sig="ippp";var _emscripten_run_preload_plugins_data=(t,e,n,_,r,a)=>{var o=UTF8ToString(n);Browser.asyncPrepareDataCounter||(Browser.asyncPrepareDataCounter=0);var l="prepare_data_"+Browser.asyncPrepareDataCounter+++"."+o,p=stringToNewUTF8(l);FS.createPreloadedFile("/",l,HEAPU8.subarray(t,t+e),!0,!0,()=>{r&&getWasmTableEntry(r)(_,p)},()=>{a&&getWasmTableEntry(a)(_)},!0)};Module._emscripten_run_preload_plugins_data=_emscripten_run_preload_plugins_data,_emscripten_run_preload_plugins_data.sig="vpipppp";var _emscripten_async_run_script=(t,e)=>{safeSetTimeout(()=>_emscripten_run_script(t),e)};Module._emscripten_async_run_script=_emscripten_async_run_script,_emscripten_async_run_script.sig="vpi";var _emscripten_async_load_script=(url,onload,onerror)=>{url=UTF8ToString(url),onload=getWasmTableEntry(onload),onerror=getWasmTableEntry(onerror),assert(runDependencies===0,"async_load_script must be run when no other dependencies are active");var loadDone=()=>{onload&&(runDependencies>0?dependenciesFulfilled=onload:onload())},loadError=()=>{onerror&&onerror()};if(ENVIRONMENT_IS_NODE){readAsync(url,data=>{eval(data),loadDone()},loadError,!1);return}var script=document.createElement("script");script.onload=loadDone,script.onerror=loadError,script.src=url,document.body.appendChild(script)};Module._emscripten_async_load_script=_emscripten_async_load_script,_emscripten_async_load_script.sig="vppp";var _emscripten_get_main_loop_timing=(t,e)=>{t&&(HEAP32[t>>2]=Browser.mainLoop.timingMode),e&&(HEAP32[e>>2]=Browser.mainLoop.timingValue)};Module._emscripten_get_main_loop_timing=_emscripten_get_main_loop_timing,_emscripten_get_main_loop_timing.sig="vpp";var _emscripten_set_main_loop=(t,e,n)=>{var _=getWasmTableEntry(t);setMainLoop(_,e,n)};Module._emscripten_set_main_loop=_emscripten_set_main_loop,_emscripten_set_main_loop.sig="vpii";var _emscripten_set_main_loop_arg=(t,e,n,_)=>{var r=()=>getWasmTableEntry(t)(e);setMainLoop(r,n,_,e)};Module._emscripten_set_main_loop_arg=_emscripten_set_main_loop_arg,_emscripten_set_main_loop_arg.sig="vppii";var _emscripten_cancel_main_loop=()=>{Browser.mainLoop.pause(),Browser.mainLoop.func=null};Module._emscripten_cancel_main_loop=_emscripten_cancel_main_loop,_emscripten_cancel_main_loop.sig="v";var _emscripten_pause_main_loop=()=>{Browser.mainLoop.pause()};Module._emscripten_pause_main_loop=_emscripten_pause_main_loop,_emscripten_pause_main_loop.sig="v";var _emscripten_resume_main_loop=()=>{Browser.mainLoop.resume()};Module._emscripten_resume_main_loop=_emscripten_resume_main_loop,_emscripten_resume_main_loop.sig="v";var __emscripten_push_main_loop_blocker=(t,e,n)=>{Browser.mainLoop.queue.push({func:()=>{getWasmTableEntry(t)(e)},name:UTF8ToString(n),counted:!0}),Browser.mainLoop.updateStatus()};Module.__emscripten_push_main_loop_blocker=__emscripten_push_main_loop_blocker,__emscripten_push_main_loop_blocker.sig="vppp";var __emscripten_push_uncounted_main_loop_blocker=(t,e,n)=>{Browser.mainLoop.queue.push({func:()=>{getWasmTableEntry(t)(e)},name:UTF8ToString(n),counted:!1}),Browser.mainLoop.updateStatus()};Module.__emscripten_push_uncounted_main_loop_blocker=__emscripten_push_uncounted_main_loop_blocker,__emscripten_push_uncounted_main_loop_blocker.sig="vppp";var _emscripten_set_main_loop_expected_blockers=t=>{Browser.mainLoop.expectedBlockers=t,Browser.mainLoop.remainingBlockers=t,Browser.mainLoop.updateStatus()};Module._emscripten_set_main_loop_expected_blockers=_emscripten_set_main_loop_expected_blockers,_emscripten_set_main_loop_expected_blockers.sig="vi";var _emscripten_async_call=(t,e,n)=>{function _(){getWasmTableEntry(t)(e)}n>=0||ENVIRONMENT_IS_NODE?safeSetTimeout(_,n):Browser.safeRequestAnimationFrame(_)};Module._emscripten_async_call=_emscripten_async_call,_emscripten_async_call.sig="vppi";var _emscripten_get_window_title=()=>{var t=256;return _emscripten_get_window_title.buffer||(_emscripten_get_window_title.buffer=_malloc(t)),stringToUTF8(document.title,_emscripten_get_window_title.buffer,t),_emscripten_get_window_title.buffer};Module._emscripten_get_window_title=_emscripten_get_window_title,_emscripten_get_window_title.sig="p";var _emscripten_set_window_title=t=>document.title=UTF8ToString(t);Module._emscripten_set_window_title=_emscripten_set_window_title,_emscripten_set_window_title.sig="vp";var _emscripten_get_screen_size=(t,e)=>{HEAP32[t>>2]=screen.width,HEAP32[e>>2]=screen.height};Module._emscripten_get_screen_size=_emscripten_get_screen_size,_emscripten_get_screen_size.sig="vpp";var _emscripten_hide_mouse=()=>{for(var t=document.styleSheets[0],e=t.cssRules,n=0;n<e.length;n++)e[n].cssText.substr(0,6)=="canvas"&&(t.deleteRule(n),n--);t.insertRule("canvas.emscripten { border: 1px solid black; cursor: none; }",0)};Module._emscripten_hide_mouse=_emscripten_hide_mouse,_emscripten_hide_mouse.sig="v";var _emscripten_set_canvas_size=(t,e)=>{Browser.setCanvasSize(t,e)};Module._emscripten_set_canvas_size=_emscripten_set_canvas_size,_emscripten_set_canvas_size.sig="vii";var _emscripten_get_canvas_size=(t,e,n)=>{var _=Module.canvas;HEAP32[t>>2]=_.width,HEAP32[e>>2]=_.height,HEAP32[n>>2]=Browser.isFullscreen?1:0};Module._emscripten_get_canvas_size=_emscripten_get_canvas_size,_emscripten_get_canvas_size.sig="vppp";var _emscripten_create_worker=t=>{t=UTF8ToString(t);var e=Browser.workers.length,n={worker:new Worker(t),callbacks:[],awaited:0,buffer:0,bufferSize:0};return n.worker.onmessage=function(r){if(!ABORT){var a=Browser.workers[e];if(a){var o=r.data.callbackId,l=a.callbacks[o];if(l){r.data.finalResponse&&(a.awaited--,a.callbacks[o]=null);var p=r.data.data;p?(p.byteLength||(p=new Uint8Array(p)),(!a.buffer||a.bufferSize<p.length)&&(a.buffer&&_free(a.buffer),a.bufferSize=p.length,a.buffer=_malloc(p.length)),HEAPU8.set(p,a.buffer),l.func(a.buffer,p.length,l.arg)):l.func(0,0,l.arg)}}}},Browser.workers.push(n),e};Module._emscripten_create_worker=_emscripten_create_worker,_emscripten_create_worker.sig="ip";var _emscripten_destroy_worker=t=>{var e=Browser.workers[t];e.worker.terminate(),e.buffer&&_free(e.buffer),Browser.workers[t]=null};Module._emscripten_destroy_worker=_emscripten_destroy_worker,_emscripten_destroy_worker.sig="vi";var _emscripten_call_worker=(t,e,n,_,r,a)=>{e=UTF8ToString(e);var o=Browser.workers[t],l=-1;r&&(l=o.callbacks.length,o.callbacks.push({func:getWasmTableEntry(r),arg:a}),o.awaited++);var p={funcName:e,callbackId:l,data:n?new Uint8Array(HEAPU8.subarray(n,n+_)):0};n?o.worker.postMessage(p,[p.data.buffer]):o.worker.postMessage(p)};Module._emscripten_call_worker=_emscripten_call_worker,_emscripten_call_worker.sig="vippipp";var _emscripten_get_worker_queue_size=t=>{var e=Browser.workers[t];return e?e.awaited:-1};Module._emscripten_get_worker_queue_size=_emscripten_get_worker_queue_size,_emscripten_get_worker_queue_size.sig="ii";var _emscripten_get_preloaded_image_data=(t,e,n)=>{(t|0)===t&&(t=UTF8ToString(t)),t=PATH_FS.resolve(t);var _=preloadedImages[t];if(_){var r=_.getContext("2d"),a=r.getImageData(0,0,_.width,_.height),o=_malloc(_.width*_.height*4);return HEAPU8.set(a.data,o),HEAP32[e>>2]=_.width,HEAP32[n>>2]=_.height,o}return 0};Module._emscripten_get_preloaded_image_data=_emscripten_get_preloaded_image_data,_emscripten_get_preloaded_image_data.sig="pppp";var _emscripten_get_preloaded_image_data_from_FILE=(t,e,n)=>{var _=_fileno(t),r=FS.getStream(_);return r?_emscripten_get_preloaded_image_data(r.path,e,n):0};Module._emscripten_get_preloaded_image_data_from_FILE=_emscripten_get_preloaded_image_data_from_FILE,_emscripten_get_preloaded_image_data_from_FILE.sig="pppp";var wget={wgetRequests:{},nextWgetRequestHandle:0,getNextWgetRequestHandle(){var t=wget.nextWgetRequestHandle;return wget.nextWgetRequestHandle++,t}};Module.wget=wget;var FS_mkdirTree=(t,e)=>FS.mkdirTree(t,e);Module.FS_mkdirTree=FS_mkdirTree;var _emscripten_async_wget=(t,e,n,_)=>{var r=UTF8ToString(t),a=UTF8ToString(e);a=PATH_FS.resolve(a);function o(p){p&&callUserCallback(function(){withStackSave(function(){getWasmTableEntry(p)(stringToUTF8OnStack(a))})})}var l=PATH.dirname(a);FS_createPreloadedFile(l,PATH.basename(a),r,!0,!0,function(){o(n)},function(){o(_)},!1,!1,function(){try{FS_unlink(a)}catch{}FS_mkdirTree(l)})};Module._emscripten_async_wget=_emscripten_async_wget,_emscripten_async_wget.sig="vpppp";var _emscripten_async_wget_data=(t,e,n,_)=>{asyncLoad(UTF8ToString(t),function(r){callUserCallback(function(){var a=_malloc(r.length);HEAPU8.set(r,a),getWasmTableEntry(n)(e,a,r.length),_free(a)})},function(){_&&callUserCallback(function(){getWasmTableEntry(_)(e)})},!0)};Module._emscripten_async_wget_data=_emscripten_async_wget_data,_emscripten_async_wget_data.sig="vpppp";var _emscripten_async_wget2=(t,e,n,_,r,a,o,l)=>{var p=UTF8ToString(t),c=UTF8ToString(e);c=PATH_FS.resolve(c);var I=UTF8ToString(n),A=UTF8ToString(_),m=c.lastIndexOf("/"),E=new XMLHttpRequest;E.open(I,p,!0),E.responseType="arraybuffer";var f=wget.getNextWgetRequestHandle(),R=PATH.dirname(c);return E.onload=function(w){if(E.status>=200&&E.status<300){try{FS.unlink(c)}catch{}FS.mkdirTree(R),FS.createDataFile(c.substr(0,m),c.substr(m+1),new Uint8Array(E.response),!0,!0,!1),a&&withStackSave(function(){getWasmTableEntry(a)(f,r,stringToUTF8OnStack(c))})}else o&&getWasmTableEntry(o)(f,r,E.status);delete wget.wgetRequests[f]},E.onerror=function(w){o&&getWasmTableEntry(o)(f,r,E.status),delete wget.wgetRequests[f]},E.onprogress=function(w){if(w.lengthComputable||w.lengthComputable===void 0&&w.total!=0){var g=w.loaded/w.total*100;l&&getWasmTableEntry(l)(f,r,g)}},E.onabort=function(w){delete wget.wgetRequests[f]},I=="POST"?(E.setRequestHeader("Content-type","application/x-www-form-urlencoded"),E.send(A)):E.send(null),wget.wgetRequests[f]=E,f};Module._emscripten_async_wget2=_emscripten_async_wget2,_emscripten_async_wget2.sig="ipppppppp";var _emscripten_async_wget2_data=(t,e,n,_,r,a,o,l)=>{var p=UTF8ToString(t),c=UTF8ToString(e),I=UTF8ToString(n),A=new XMLHttpRequest;A.open(c,p,!0),A.responseType="arraybuffer";var m=wget.getNextWgetRequestHandle();function E(){o&&withStackSave(()=>{var f=0;A.statusText&&(f=stringToUTF8OnStack(A.statusText)),getWasmTableEntry(o)(m,_,A.status,f)})}return A.onload=function(R){if(A.status>=200&&A.status<300||A.status===0&&p.substr(0,4).toLowerCase()!="http"){var h=new Uint8Array(A.response),w=_malloc(h.length);HEAPU8.set(h,w),a&&getWasmTableEntry(a)(m,_,w,h.length),r&&_free(w)}else E();delete wget.wgetRequests[m]},A.onerror=function(R){E(),delete wget.wgetRequests[m]},A.onprogress=function(R){l&&getWasmTableEntry(l)(m,_,R.loaded,R.lengthComputable||R.lengthComputable===void 0?R.total:0)},A.onabort=function(R){delete wget.wgetRequests[m]},c=="POST"?(A.setRequestHeader("Content-type","application/x-www-form-urlencoded"),A.send(I)):A.send(null),wget.wgetRequests[m]=A,m};Module._emscripten_async_wget2_data=_emscripten_async_wget2_data,_emscripten_async_wget2_data.sig="ippppippp";var _emscripten_async_wget2_abort=t=>{var e=wget.wgetRequests[t];e&&e.abort()};Module._emscripten_async_wget2_abort=_emscripten_async_wget2_abort,_emscripten_async_wget2_abort.sig="vi";var __dlsym_catchup_js=(t,e)=>{var n=LDSO.loadedLibsByHandle[t],_=n.exports,r=Object.keys(_)[e],a=_[r],o=addFunction(a,a.sig);return o};Module.__dlsym_catchup_js=__dlsym_catchup_js,__dlsym_catchup_js.sig="ppi";var _setNetworkCallback=(t,e,n)=>{function _(r){try{t==="error"?withStackSave(function(){var a=stringToUTF8OnStack(r[2]);getWasmTableEntry(n)(r[0],r[1],a,e)}):getWasmTableEntry(n)(r,e)}catch(a){if(!(a instanceof ExitStatus))throw a&&typeof a=="object"&&a.stack&&err("exception thrown: "+[a,a.stack]),a}}Module.websocket.on(t,n?_:null)};Module._setNetworkCallback=_setNetworkCallback;var _emscripten_set_socket_error_callback=(t,e)=>{_setNetworkCallback("error",t,e)};Module._emscripten_set_socket_error_callback=_emscripten_set_socket_error_callback,_emscripten_set_socket_error_callback.sig="vpp";var _emscripten_set_socket_open_callback=(t,e)=>{_setNetworkCallback("open",t,e)};Module._emscripten_set_socket_open_callback=_emscripten_set_socket_open_callback,_emscripten_set_socket_open_callback.sig="vpp";var _emscripten_set_socket_listen_callback=(t,e)=>{_setNetworkCallback("listen",t,e)};Module._emscripten_set_socket_listen_callback=_emscripten_set_socket_listen_callback,_emscripten_set_socket_listen_callback.sig="vpp";var _emscripten_set_socket_connection_callback=(t,e)=>{_setNetworkCallback("connection",t,e)};Module._emscripten_set_socket_connection_callback=_emscripten_set_socket_connection_callback,_emscripten_set_socket_connection_callback.sig="vpp";var _emscripten_set_socket_message_callback=(t,e)=>{_setNetworkCallback("message",t,e)};Module._emscripten_set_socket_message_callback=_emscripten_set_socket_message_callback,_emscripten_set_socket_message_callback.sig="vpp";var _emscripten_set_socket_close_callback=(t,e)=>{_setNetworkCallback("close",t,e)};Module._emscripten_set_socket_close_callback=_emscripten_set_socket_close_callback,_emscripten_set_socket_close_callback.sig="vpp";var ALLOC_NORMAL=0;Module.ALLOC_NORMAL=ALLOC_NORMAL;var ALLOC_STACK=1;Module.ALLOC_STACK=ALLOC_STACK;var allocate=(t,e)=>{var n;return e==ALLOC_STACK?n=stackAlloc(t.length):n=_malloc(t.length),!t.subarray&&!t.slice&&(t=new Uint8Array(t)),HEAPU8.set(t,n),n};Module.allocate=allocate;var writeStringToMemory=(t,e,n)=>{warnOnce("writeStringToMemory is deprecated and should not be called! Use stringToUTF8() instead!");var _,r;n&&(r=e+lengthBytesUTF8(t),_=HEAP8[r]),stringToUTF8(t,e,1/0),n&&(HEAP8[r]=_)};Module.writeStringToMemory=writeStringToMemory;var writeAsciiToMemory=(t,e,n)=>{for(var _=0;_<t.length;++_)HEAP8[e++>>0]=t.charCodeAt(_);n||(HEAP8[e>>0]=0)};Module.writeAsciiToMemory=writeAsciiToMemory;var allocateUTF8=stringToNewUTF8;Module.allocateUTF8=allocateUTF8;var allocateUTF8OnStack=stringToUTF8OnStack;Module.allocateUTF8OnStack=allocateUTF8OnStack;var _emscripten_is_main_browser_thread=()=>!ENVIRONMENT_IS_WORKER;Module._emscripten_is_main_browser_thread=_emscripten_is_main_browser_thread;var WS={sockets:[null],socketEvent:null};Module.WS=WS;var _emscripten_websocket_get_ready_state=(t,e)=>{var n=WS.sockets[t];return n?(HEAP16[e>>1]=n.readyState,0):-3};Module._emscripten_websocket_get_ready_state=_emscripten_websocket_get_ready_state,_emscripten_websocket_get_ready_state.sig="iip";var _emscripten_websocket_get_buffered_amount=(t,e)=>{var n=WS.sockets[t];return n?(HEAPU32[e>>2]=n.bufferedAmount,0):-3};Module._emscripten_websocket_get_buffered_amount=_emscripten_websocket_get_buffered_amount,_emscripten_websocket_get_buffered_amount.sig="iip";var _emscripten_websocket_get_extensions=(t,e,n)=>{var _=WS.sockets[t];return _?e?(stringToUTF8(_.extensions,e,n),0):-5:-3};Module._emscripten_websocket_get_extensions=_emscripten_websocket_get_extensions,_emscripten_websocket_get_extensions.sig="iipi";var _emscripten_websocket_get_extensions_length=(t,e)=>{var n=WS.sockets[t];return n?e?(HEAP32[e>>2]=lengthBytesUTF8(n.extensions)+1,0):-5:-3};Module._emscripten_websocket_get_extensions_length=_emscripten_websocket_get_extensions_length,_emscripten_websocket_get_extensions_length.sig="iip";var _emscripten_websocket_get_protocol=(t,e,n)=>{var _=WS.sockets[t];return _?e?(stringToUTF8(_.protocol,e,n),0):-5:-3};Module._emscripten_websocket_get_protocol=_emscripten_websocket_get_protocol,_emscripten_websocket_get_protocol.sig="iipi";var _emscripten_websocket_get_protocol_length=(t,e)=>{var n=WS.sockets[t];return n?e?(HEAP32[e>>2]=lengthBytesUTF8(n.protocol)+1,0):-5:-3};Module._emscripten_websocket_get_protocol_length=_emscripten_websocket_get_protocol_length,_emscripten_websocket_get_protocol_length.sig="iip";var _emscripten_websocket_get_url=(t,e,n)=>{var _=WS.sockets[t];return _?e?(stringToUTF8(_.url,e,n),0):-5:-3};Module._emscripten_websocket_get_url=_emscripten_websocket_get_url,_emscripten_websocket_get_url.sig="iipi";var _emscripten_websocket_get_url_length=(t,e)=>{var n=WS.sockets[t];return n?e?(HEAP32[e>>2]=lengthBytesUTF8(n.url)+1,0):-5:-3};Module._emscripten_websocket_get_url_length=_emscripten_websocket_get_url_length,_emscripten_websocket_get_url_length.sig="iip";var _emscripten_websocket_set_onopen_callback_on_thread=(t,e,n,_)=>{WS.socketEvent||(WS.socketEvent=_malloc(1024));var r=WS.sockets[t];return r?(r.onopen=function(a){HEAPU32[WS.socketEvent>>2]=t,getWasmTableEntry(n)(0,WS.socketEvent,e)},0):-3};Module._emscripten_websocket_set_onopen_callback_on_thread=_emscripten_websocket_set_onopen_callback_on_thread,_emscripten_websocket_set_onopen_callback_on_thread.sig="iippp";var _emscripten_websocket_set_onerror_callback_on_thread=(t,e,n,_)=>{WS.socketEvent||(WS.socketEvent=_malloc(1024));var r=WS.sockets[t];return r?(r.onerror=function(a){HEAPU32[WS.socketEvent>>2]=t,getWasmTableEntry(n)(0,WS.socketEvent,e)},0):-3};Module._emscripten_websocket_set_onerror_callback_on_thread=_emscripten_websocket_set_onerror_callback_on_thread,_emscripten_websocket_set_onerror_callback_on_thread.sig="iippp";var _emscripten_websocket_set_onclose_callback_on_thread=(t,e,n,_)=>{WS.socketEvent||(WS.socketEvent=_malloc(1024));var r=WS.sockets[t];return r?(r.onclose=function(a){HEAPU32[WS.socketEvent>>2]=t,HEAPU32[WS.socketEvent+4>>2]=a.wasClean,HEAPU32[WS.socketEvent+8>>2]=a.code,stringToUTF8(a.reason,WS.socketEvent+10,512),getWasmTableEntry(n)(0,WS.socketEvent,e)},0):-3};Module._emscripten_websocket_set_onclose_callback_on_thread=_emscripten_websocket_set_onclose_callback_on_thread,_emscripten_websocket_set_onclose_callback_on_thread.sig="iippp";var _emscripten_websocket_set_onmessage_callback_on_thread=(t,e,n,_)=>{WS.socketEvent||(WS.socketEvent=_malloc(1024));var r=WS.sockets[t];return r?(r.onmessage=function(a){if(HEAPU32[WS.socketEvent>>2]=t,typeof a.data=="string"){var o=stringToNewUTF8(a.data),l=lengthBytesUTF8(a.data)+1;HEAPU32[WS.socketEvent+12>>2]=1}else{var l=a.data.byteLength,o=_malloc(l);HEAP8.set(new Uint8Array(a.data),o),HEAPU32[WS.socketEvent+12>>2]=0}HEAPU32[WS.socketEvent+4>>2]=o,HEAPU32[WS.socketEvent+8>>2]=l,getWasmTableEntry(n)(0,WS.socketEvent,e),_free(o)},0):-3};Module._emscripten_websocket_set_onmessage_callback_on_thread=_emscripten_websocket_set_onmessage_callback_on_thread,_emscripten_websocket_set_onmessage_callback_on_thread.sig="iippp";var _emscripten_websocket_new=t=>{if(typeof WebSocket>"u")return-1;if(!t)return-5;var e=t>>2,n=UTF8ToString(HEAP32[e]),_=HEAP32[e+1],r=_?new WebSocket(n,UTF8ToString(_).split(",")):new WebSocket(n);r.binaryType="arraybuffer";var a=WS.sockets.length;return WS.sockets[a]=r,a};Module._emscripten_websocket_new=_emscripten_websocket_new,_emscripten_websocket_new.sig="ip";var _emscripten_websocket_send_utf8_text=(t,e)=>{var n=WS.sockets[t];if(!n)return-3;var _=UTF8ToString(e);return n.send(_),0};Module._emscripten_websocket_send_utf8_text=_emscripten_websocket_send_utf8_text,_emscripten_websocket_send_utf8_text.sig="iip";var _emscripten_websocket_send_binary=(t,e,n)=>{var _=WS.sockets[t];return _?(_.send(HEAPU8.subarray(e,e+n)),0):-3};Module._emscripten_websocket_send_binary=_emscripten_websocket_send_binary,_emscripten_websocket_send_binary.sig="iipi";var _emscripten_websocket_close=(t,e,n)=>{var _=WS.sockets[t];if(!_)return-3;var r=n?UTF8ToString(n):void 0;return n?_.close(e||void 0,UTF8ToString(n)):e?_.close(e):_.close(),0};Module._emscripten_websocket_close=_emscripten_websocket_close,_emscripten_websocket_close.sig="iiip";var _emscripten_websocket_delete=t=>{var e=WS.sockets[t];return e?(e.onopen=e.onerror=e.onclose=e.onmessage=null,delete WS.sockets[t],0):-3};Module._emscripten_websocket_delete=_emscripten_websocket_delete,_emscripten_websocket_delete.sig="ii";var _emscripten_websocket_is_supported=()=>typeof WebSocket<"u";Module._emscripten_websocket_is_supported=_emscripten_websocket_is_supported,_emscripten_websocket_is_supported.sig="i";var _emscripten_websocket_deinitialize=()=>{for(var t in WS.sockets){var e=WS.sockets[t];e&&(e.close(),_emscripten_websocket_delete(t))}WS.sockets=[]};Module._emscripten_websocket_deinitialize=_emscripten_websocket_deinitialize,_emscripten_websocket_deinitialize.sig="v";var _emscripten_webgl_enable_ANGLE_instanced_arrays=t=>webgl_enable_ANGLE_instanced_arrays(GL.contexts[t].GLctx);Module._emscripten_webgl_enable_ANGLE_instanced_arrays=_emscripten_webgl_enable_ANGLE_instanced_arrays,_emscripten_webgl_enable_ANGLE_instanced_arrays.sig="ii";var _emscripten_webgl_enable_OES_vertex_array_object=t=>webgl_enable_OES_vertex_array_object(GL.contexts[t].GLctx);Module._emscripten_webgl_enable_OES_vertex_array_object=_emscripten_webgl_enable_OES_vertex_array_object,_emscripten_webgl_enable_OES_vertex_array_object.sig="ii";var _emscripten_webgl_enable_WEBGL_draw_buffers=t=>webgl_enable_WEBGL_draw_buffers(GL.contexts[t].GLctx);Module._emscripten_webgl_enable_WEBGL_draw_buffers=_emscripten_webgl_enable_WEBGL_draw_buffers,_emscripten_webgl_enable_WEBGL_draw_buffers.sig="ii";var _emscripten_webgl_enable_WEBGL_multi_draw=t=>webgl_enable_WEBGL_multi_draw(GL.contexts[t].GLctx);Module._emscripten_webgl_enable_WEBGL_multi_draw=_emscripten_webgl_enable_WEBGL_multi_draw,_emscripten_webgl_enable_WEBGL_multi_draw.sig="ii";var _glVertexPointer=(t,e,n,_)=>{throw"Legacy GL function (glVertexPointer) called. If you want legacy GL emulation, you need to compile with -sLEGACY_GL_EMULATION to enable legacy GL emulation."};Module._glVertexPointer=_glVertexPointer,_glVertexPointer.sig="viiip";var _glMatrixMode=()=>{throw"Legacy GL function (glMatrixMode) called. If you want legacy GL emulation, you need to compile with -sLEGACY_GL_EMULATION to enable legacy GL emulation."};Module._glMatrixMode=_glMatrixMode,_glMatrixMode.sig="vi";var _glBegin=()=>{throw"Legacy GL function (glBegin) called. If you want legacy GL emulation, you need to compile with -sLEGACY_GL_EMULATION to enable legacy GL emulation."};Module._glBegin=_glBegin,_glBegin.sig="vi";var _glLoadIdentity=()=>{throw"Legacy GL function (glLoadIdentity) called. If you want legacy GL emulation, you need to compile with -sLEGACY_GL_EMULATION to enable legacy GL emulation."};Module._glLoadIdentity=_glLoadIdentity,_glLoadIdentity.sig="v";var _glVertexAttribDivisorNV=_glVertexAttribDivisor;Module._glVertexAttribDivisorNV=_glVertexAttribDivisorNV;var _glDrawArraysInstancedNV=_glDrawArraysInstanced;Module._glDrawArraysInstancedNV=_glDrawArraysInstancedNV;var _glDrawElementsInstancedNV=_glDrawElementsInstanced;Module._glDrawElementsInstancedNV=_glDrawElementsInstancedNV;var _glVertexAttribDivisorEXT=_glVertexAttribDivisor;Module._glVertexAttribDivisorEXT=_glVertexAttribDivisorEXT;var _glDrawArraysInstancedEXT=_glDrawArraysInstanced;Module._glDrawArraysInstancedEXT=_glDrawArraysInstancedEXT;var _glDrawElementsInstancedEXT=_glDrawElementsInstanced;Module._glDrawElementsInstancedEXT=_glDrawElementsInstancedEXT;var _glVertexAttribDivisorARB=_glVertexAttribDivisor;Module._glVertexAttribDivisorARB=_glVertexAttribDivisorARB;var _glDrawArraysInstancedARB=_glDrawArraysInstanced;Module._glDrawArraysInstancedARB=_glDrawArraysInstancedARB;var _glDrawElementsInstancedARB=_glDrawElementsInstanced;Module._glDrawElementsInstancedARB=_glDrawElementsInstancedARB;var _glDrawBuffersEXT=_glDrawBuffers;Module._glDrawBuffersEXT=_glDrawBuffersEXT;var _glMultiDrawArraysWEBGL=(t,e,n,_)=>{GLctx.multiDrawWebgl.multiDrawArraysWEBGL(t,HEAP32,e>>2,HEAP32,n>>2,_)};Module._glMultiDrawArraysWEBGL=_glMultiDrawArraysWEBGL,_glMultiDrawArraysWEBGL.sig="vippi";var _glMultiDrawArrays=_glMultiDrawArraysWEBGL;Module._glMultiDrawArrays=_glMultiDrawArrays,_glMultiDrawArrays.sig="vippi";var _glMultiDrawArraysANGLE=_glMultiDrawArraysWEBGL;Module._glMultiDrawArraysANGLE=_glMultiDrawArraysANGLE;var _glMultiDrawArraysInstancedWEBGL=(t,e,n,_,r)=>{GLctx.multiDrawWebgl.multiDrawArraysInstancedWEBGL(t,HEAP32,e>>2,HEAP32,n>>2,HEAP32,_>>2,r)};Module._glMultiDrawArraysInstancedWEBGL=_glMultiDrawArraysInstancedWEBGL,_glMultiDrawArraysInstancedWEBGL.sig="viiiii";var _glMultiDrawArraysInstancedANGLE=_glMultiDrawArraysInstancedWEBGL;Module._glMultiDrawArraysInstancedANGLE=_glMultiDrawArraysInstancedANGLE;var _glMultiDrawElementsWEBGL=(t,e,n,_,r)=>{GLctx.multiDrawWebgl.multiDrawElementsWEBGL(t,HEAP32,e>>2,n,HEAP32,_>>2,r)};Module._glMultiDrawElementsWEBGL=_glMultiDrawElementsWEBGL,_glMultiDrawElementsWEBGL.sig="vipipi";var _glMultiDrawElements=_glMultiDrawElementsWEBGL;Module._glMultiDrawElements=_glMultiDrawElements,_glMultiDrawElements.sig="vipipi";var _glMultiDrawElementsANGLE=_glMultiDrawElementsWEBGL;Module._glMultiDrawElementsANGLE=_glMultiDrawElementsANGLE;var _glMultiDrawElementsInstancedWEBGL=(t,e,n,_,r,a)=>{GLctx.multiDrawWebgl.multiDrawElementsInstancedWEBGL(t,HEAP32,e>>2,n,HEAP32,_>>2,HEAP32,r>>2,a)};Module._glMultiDrawElementsInstancedWEBGL=_glMultiDrawElementsInstancedWEBGL,_glMultiDrawElementsInstancedWEBGL.sig="viiiiii";var _glMultiDrawElementsInstancedANGLE=_glMultiDrawElementsInstancedWEBGL;Module._glMultiDrawElementsInstancedANGLE=_glMultiDrawElementsInstancedANGLE;function _glClearDepth(t){GLctx.clearDepth(t)}Module._glClearDepth=_glClearDepth,_glClearDepth.sig="vd";function _glDepthRange(t,e){GLctx.depthRange(t,e)}Module._glDepthRange=_glDepthRange,_glDepthRange.sig="vdd";var _emscripten_glGenVertexArrays=_glGenVertexArrays;Module._emscripten_glGenVertexArrays=_emscripten_glGenVertexArrays;var _emscripten_glDeleteVertexArrays=_glDeleteVertexArrays;Module._emscripten_glDeleteVertexArrays=_emscripten_glDeleteVertexArrays;var _emscripten_glBindVertexArray=_glBindVertexArray;Module._emscripten_glBindVertexArray=_emscripten_glBindVertexArray;var _emscripten_glIsVertexArray=_glIsVertexArray;Module._emscripten_glIsVertexArray=_emscripten_glIsVertexArray;var _emscripten_glVertexPointer=_glVertexPointer;Module._emscripten_glVertexPointer=_emscripten_glVertexPointer;var _emscripten_glMatrixMode=_glMatrixMode;Module._emscripten_glMatrixMode=_emscripten_glMatrixMode;var _emscripten_glBegin=_glBegin;Module._emscripten_glBegin=_emscripten_glBegin;var _emscripten_glLoadIdentity=_glLoadIdentity;Module._emscripten_glLoadIdentity=_emscripten_glLoadIdentity;var _emscripten_glVertexAttribDivisor=_glVertexAttribDivisor;Module._emscripten_glVertexAttribDivisor=_emscripten_glVertexAttribDivisor;var _emscripten_glDrawArraysInstanced=_glDrawArraysInstanced;Module._emscripten_glDrawArraysInstanced=_emscripten_glDrawArraysInstanced;var _emscripten_glDrawElementsInstanced=_glDrawElementsInstanced;Module._emscripten_glDrawElementsInstanced=_emscripten_glDrawElementsInstanced;var _emscripten_glVertexAttribDivisorNV=_glVertexAttribDivisorNV;Module._emscripten_glVertexAttribDivisorNV=_emscripten_glVertexAttribDivisorNV;var _emscripten_glDrawArraysInstancedNV=_glDrawArraysInstancedNV;Module._emscripten_glDrawArraysInstancedNV=_emscripten_glDrawArraysInstancedNV;var _emscripten_glDrawElementsInstancedNV=_glDrawElementsInstancedNV;Module._emscripten_glDrawElementsInstancedNV=_emscripten_glDrawElementsInstancedNV;var _emscripten_glVertexAttribDivisorEXT=_glVertexAttribDivisorEXT;Module._emscripten_glVertexAttribDivisorEXT=_emscripten_glVertexAttribDivisorEXT;var _emscripten_glDrawArraysInstancedEXT=_glDrawArraysInstancedEXT;Module._emscripten_glDrawArraysInstancedEXT=_emscripten_glDrawArraysInstancedEXT;var _emscripten_glDrawElementsInstancedEXT=_glDrawElementsInstancedEXT;Module._emscripten_glDrawElementsInstancedEXT=_emscripten_glDrawElementsInstancedEXT;var _emscripten_glVertexAttribDivisorARB=_glVertexAttribDivisorARB;Module._emscripten_glVertexAttribDivisorARB=_emscripten_glVertexAttribDivisorARB;var _emscripten_glDrawArraysInstancedARB=_glDrawArraysInstancedARB;Module._emscripten_glDrawArraysInstancedARB=_emscripten_glDrawArraysInstancedARB;var _emscripten_glDrawElementsInstancedARB=_glDrawElementsInstancedARB;Module._emscripten_glDrawElementsInstancedARB=_emscripten_glDrawElementsInstancedARB;var _emscripten_glDrawBuffers=_glDrawBuffers;Module._emscripten_glDrawBuffers=_emscripten_glDrawBuffers;var _emscripten_glDrawBuffersEXT=_glDrawBuffersEXT;Module._emscripten_glDrawBuffersEXT=_emscripten_glDrawBuffersEXT;var _emscripten_glMultiDrawArrays=_glMultiDrawArrays;Module._emscripten_glMultiDrawArrays=_emscripten_glMultiDrawArrays;var _emscripten_glMultiDrawArraysANGLE=_glMultiDrawArraysANGLE;Module._emscripten_glMultiDrawArraysANGLE=_emscripten_glMultiDrawArraysANGLE;var _emscripten_glMultiDrawArraysWEBGL=_glMultiDrawArraysWEBGL;Module._emscripten_glMultiDrawArraysWEBGL=_emscripten_glMultiDrawArraysWEBGL;var _emscripten_glMultiDrawArraysInstancedANGLE=_glMultiDrawArraysInstancedANGLE;Module._emscripten_glMultiDrawArraysInstancedANGLE=_emscripten_glMultiDrawArraysInstancedANGLE;var _emscripten_glMultiDrawArraysInstancedWEBGL=_glMultiDrawArraysInstancedWEBGL;Module._emscripten_glMultiDrawArraysInstancedWEBGL=_emscripten_glMultiDrawArraysInstancedWEBGL;var _emscripten_glMultiDrawElements=_glMultiDrawElements;Module._emscripten_glMultiDrawElements=_emscripten_glMultiDrawElements;var _emscripten_glMultiDrawElementsANGLE=_glMultiDrawElementsANGLE;Module._emscripten_glMultiDrawElementsANGLE=_emscripten_glMultiDrawElementsANGLE;var _emscripten_glMultiDrawElementsWEBGL=_glMultiDrawElementsWEBGL;Module._emscripten_glMultiDrawElementsWEBGL=_emscripten_glMultiDrawElementsWEBGL;var _emscripten_glMultiDrawElementsInstancedANGLE=_glMultiDrawElementsInstancedANGLE;Module._emscripten_glMultiDrawElementsInstancedANGLE=_emscripten_glMultiDrawElementsInstancedANGLE;var _emscripten_glMultiDrawElementsInstancedWEBGL=_glMultiDrawElementsInstancedWEBGL;Module._emscripten_glMultiDrawElementsInstancedWEBGL=_emscripten_glMultiDrawElementsInstancedWEBGL;var _emscripten_glClearDepth=_glClearDepth;Module._emscripten_glClearDepth=_emscripten_glClearDepth;var _emscripten_glDepthRange=_glDepthRange;Module._emscripten_glDepthRange=_emscripten_glDepthRange;var writeGLArray=(t,e,n,_)=>{for(var r=t.length,a=n<r?n:r,o=_?HEAPF32:HEAP32,l=0;l<a;++l)o[(e>>2)+l]=t[l];return r};Module.writeGLArray=writeGLArray;var _emscripten_webgl_init_context_attributes=t=>{for(var e=t>>2,n=0;n<14;++n)HEAP32[e+n]=0;HEAP32[e+0]=HEAP32[e+1]=HEAP32[e+3]=HEAP32[e+4]=HEAP32[e+8]=HEAP32[e+10]=1};Module._emscripten_webgl_init_context_attributes=_emscripten_webgl_init_context_attributes,_emscripten_webgl_init_context_attributes.sig="vp";var emscripten_webgl_power_preferences=["default","low-power","high-performance"];Module.emscripten_webgl_power_preferences=emscripten_webgl_power_preferences;var _emscripten_webgl_do_create_context=(t,e)=>{var n=e>>2,_=HEAP32[n+6],r={alpha:!!HEAP32[n+0],depth:!!HEAP32[n+1],stencil:!!HEAP32[n+2],antialias:!!HEAP32[n+3],premultipliedAlpha:!!HEAP32[n+4],preserveDrawingBuffer:!!HEAP32[n+5],powerPreference:emscripten_webgl_power_preferences[_],failIfMajorPerformanceCaveat:!!HEAP32[n+7],majorVersion:HEAP32[n+8],minorVersion:HEAP32[n+9],enableExtensionsByDefault:HEAP32[n+10],explicitSwapControl:HEAP32[n+11],proxyContextToMainThread:HEAP32[n+12],renderViaOffscreenBackBuffer:HEAP32[n+13]},a=findCanvasEventTarget(t);if(!a||r.explicitSwapControl)return 0;var o=GL.createContext(a,r);return o};Module._emscripten_webgl_do_create_context=_emscripten_webgl_do_create_context,_emscripten_webgl_do_create_context.sig="ipp";var _emscripten_webgl_create_context=_emscripten_webgl_do_create_context;Module._emscripten_webgl_create_context=_emscripten_webgl_create_context,_emscripten_webgl_create_context.sig="ipp";var _emscripten_webgl_do_get_current_context=()=>GL.currentContext?GL.currentContext.handle:0;Module._emscripten_webgl_do_get_current_context=_emscripten_webgl_do_get_current_context,_emscripten_webgl_do_get_current_context.sig="i";var _emscripten_webgl_get_current_context=_emscripten_webgl_do_get_current_context;Module._emscripten_webgl_get_current_context=_emscripten_webgl_get_current_context,_emscripten_webgl_get_current_context.sig="i";var _emscripten_webgl_do_commit_frame=()=>!GL.currentContext||!GL.currentContext.GLctx||!GL.currentContext.attributes.explicitSwapControl?-3:0;Module._emscripten_webgl_do_commit_frame=_emscripten_webgl_do_commit_frame,_emscripten_webgl_do_commit_frame.sig="i";var _emscripten_webgl_commit_frame=_emscripten_webgl_do_commit_frame;Module._emscripten_webgl_commit_frame=_emscripten_webgl_commit_frame,_emscripten_webgl_commit_frame.sig="i";var _emscripten_webgl_make_context_current=t=>{var e=GL.makeContextCurrent(t);return e?0:-5};Module._emscripten_webgl_make_context_current=_emscripten_webgl_make_context_current,_emscripten_webgl_make_context_current.sig="ii";var _emscripten_webgl_get_drawing_buffer_size=(t,e,n)=>{var _=GL.getContext(t);return!_||!_.GLctx||!e||!n?-5:(HEAP32[e>>2]=_.GLctx.drawingBufferWidth,HEAP32[n>>2]=_.GLctx.drawingBufferHeight,0)};Module._emscripten_webgl_get_drawing_buffer_size=_emscripten_webgl_get_drawing_buffer_size,_emscripten_webgl_get_drawing_buffer_size.sig="iipp";var _emscripten_webgl_get_context_attributes=(t,e)=>{if(!e)return-5;if(t=GL.contexts[t],!t)return-3;var n=t.GLctx;if(!n)return-3;n=n.getContextAttributes(),HEAP32[e>>2]=n.alpha,HEAP32[e+4>>2]=n.depth,HEAP32[e+8>>2]=n.stencil,HEAP32[e+12>>2]=n.antialias,HEAP32[e+16>>2]=n.premultipliedAlpha,HEAP32[e+20>>2]=n.preserveDrawingBuffer;var _=n.powerPreference&&emscripten_webgl_power_preferences.indexOf(n.powerPreference);return HEAP32[e+24>>2]=_,HEAP32[e+28>>2]=n.failIfMajorPerformanceCaveat,HEAP32[e+32>>2]=t.version,HEAP32[e+36>>2]=0,HEAP32[e+40>>2]=t.attributes.enableExtensionsByDefault,0};Module._emscripten_webgl_get_context_attributes=_emscripten_webgl_get_context_attributes,_emscripten_webgl_get_context_attributes.sig="iip";var _emscripten_webgl_destroy_context=t=>{GL.currentContext==t&&(GL.currentContext=0),GL.deleteContext(t)};Module._emscripten_webgl_destroy_context=_emscripten_webgl_destroy_context,_emscripten_webgl_destroy_context.sig="ii";var _emscripten_webgl_enable_extension=(t,e)=>{var n=GL.getContext(t),_=UTF8ToString(e);_.startsWith("GL_")&&(_=_.substr(3)),_=="ANGLE_instanced_arrays"&&webgl_enable_ANGLE_instanced_arrays(GLctx),_=="OES_vertex_array_object"&&webgl_enable_OES_vertex_array_object(GLctx),_=="WEBGL_draw_buffers"&&webgl_enable_WEBGL_draw_buffers(GLctx),_=="WEBGL_multi_draw"&&webgl_enable_WEBGL_multi_draw(GLctx);var r=n.GLctx.getExtension(_);return!!r};Module._emscripten_webgl_enable_extension=_emscripten_webgl_enable_extension,_emscripten_webgl_enable_extension.sig="iip";var _emscripten_supports_offscreencanvas=()=>0;Module._emscripten_supports_offscreencanvas=_emscripten_supports_offscreencanvas,_emscripten_supports_offscreencanvas.sig="i";var registerWebGlEventCallback=(t,e,n,_,r,a,o)=>{var l=(c=event)=>{getWasmTableEntry(_)(r,0,e)&&c.preventDefault()},p={target:findEventTarget(t),eventTypeString:a,callbackfunc:_,handlerFunc:l,useCapture:n};JSEvents.registerOrRemoveHandler(p)};Module.registerWebGlEventCallback=registerWebGlEventCallback;var _emscripten_set_webglcontextlost_callback_on_thread=(t,e,n,_,r)=>(registerWebGlEventCallback(t,e,n,_,31,"webglcontextlost",r),0);Module._emscripten_set_webglcontextlost_callback_on_thread=_emscripten_set_webglcontextlost_callback_on_thread,_emscripten_set_webglcontextlost_callback_on_thread.sig="ippipp";var _emscripten_set_webglcontextrestored_callback_on_thread=(t,e,n,_,r)=>(registerWebGlEventCallback(t,e,n,_,32,"webglcontextrestored",r),0);Module._emscripten_set_webglcontextrestored_callback_on_thread=_emscripten_set_webglcontextrestored_callback_on_thread,_emscripten_set_webglcontextrestored_callback_on_thread.sig="ippipp";var _emscripten_is_webgl_context_lost=t=>!GL.contexts[t]||GL.contexts[t].GLctx.isContextLost();Module._emscripten_is_webgl_context_lost=_emscripten_is_webgl_context_lost,_emscripten_is_webgl_context_lost.sig="ii";var _emscripten_webgl_get_supported_extensions=()=>stringToNewUTF8(GLctx.getSupportedExtensions().join(" "));Module._emscripten_webgl_get_supported_extensions=_emscripten_webgl_get_supported_extensions,_emscripten_webgl_get_supported_extensions.sig="p";var _emscripten_webgl_get_program_parameter_d=(t,e)=>GLctx.getProgramParameter(GL.programs[t],e);Module._emscripten_webgl_get_program_parameter_d=_emscripten_webgl_get_program_parameter_d,_emscripten_webgl_get_program_parameter_d.sig="dii";var _emscripten_webgl_get_program_info_log_utf8=t=>stringToNewUTF8(GLctx.getProgramInfoLog(GL.programs[t]));Module._emscripten_webgl_get_program_info_log_utf8=_emscripten_webgl_get_program_info_log_utf8,_emscripten_webgl_get_program_info_log_utf8.sig="pi";var _emscripten_webgl_get_shader_parameter_d=(t,e)=>GLctx.getShaderParameter(GL.shaders[t],e);Module._emscripten_webgl_get_shader_parameter_d=_emscripten_webgl_get_shader_parameter_d,_emscripten_webgl_get_shader_parameter_d.sig="dii";var _emscripten_webgl_get_shader_info_log_utf8=t=>stringToNewUTF8(GLctx.getShaderInfoLog(GL.shaders[t]));Module._emscripten_webgl_get_shader_info_log_utf8=_emscripten_webgl_get_shader_info_log_utf8,_emscripten_webgl_get_shader_info_log_utf8.sig="pi";var _emscripten_webgl_get_shader_source_utf8=t=>stringToNewUTF8(GLctx.getShaderSource(GL.shaders[t]));Module._emscripten_webgl_get_shader_source_utf8=_emscripten_webgl_get_shader_source_utf8,_emscripten_webgl_get_shader_source_utf8.sig="pi";var _emscripten_webgl_get_vertex_attrib_d=(t,e)=>GLctx.getVertexAttrib(t,e);Module._emscripten_webgl_get_vertex_attrib_d=_emscripten_webgl_get_vertex_attrib_d,_emscripten_webgl_get_vertex_attrib_d.sig="dii";var _emscripten_webgl_get_vertex_attrib_o=(t,e)=>{var n=GLctx.getVertexAttrib(t,e);return n&&n.name};Module._emscripten_webgl_get_vertex_attrib_o=_emscripten_webgl_get_vertex_attrib_o,_emscripten_webgl_get_vertex_attrib_o.sig="iii";var _emscripten_webgl_get_vertex_attrib_v=(t,e,n,_,r)=>writeGLArray(GLctx.getVertexAttrib(t,e),n,_,r);Module._emscripten_webgl_get_vertex_attrib_v=_emscripten_webgl_get_vertex_attrib_v,_emscripten_webgl_get_vertex_attrib_v.sig="iiipii";var _emscripten_webgl_get_uniform_d=(t,e)=>GLctx.getUniform(GL.programs[t],webglGetUniformLocation(e));Module._emscripten_webgl_get_uniform_d=_emscripten_webgl_get_uniform_d,_emscripten_webgl_get_uniform_d.sig="dii";var _emscripten_webgl_get_uniform_v=(t,e,n,_,r)=>writeGLArray(GLctx.getUniform(GL.programs[t],webglGetUniformLocation(e)),n,_,r);Module._emscripten_webgl_get_uniform_v=_emscripten_webgl_get_uniform_v,_emscripten_webgl_get_uniform_v.sig="iiipii";var _emscripten_webgl_get_parameter_v=(t,e,n,_)=>writeGLArray(GLctx.getParameter(t),e,n,_);Module._emscripten_webgl_get_parameter_v=_emscripten_webgl_get_parameter_v,_emscripten_webgl_get_parameter_v.sig="iipii";var _emscripten_webgl_get_parameter_d=t=>GLctx.getParameter(t);Module._emscripten_webgl_get_parameter_d=_emscripten_webgl_get_parameter_d,_emscripten_webgl_get_parameter_d.sig="di";var _emscripten_webgl_get_parameter_o=t=>{var e=GLctx.getParameter(t);return e&&e.name};Module._emscripten_webgl_get_parameter_o=_emscripten_webgl_get_parameter_o,_emscripten_webgl_get_parameter_o.sig="ii";var _emscripten_webgl_get_parameter_utf8=t=>stringToNewUTF8(GLctx.getParameter(t));Module._emscripten_webgl_get_parameter_utf8=_emscripten_webgl_get_parameter_utf8,_emscripten_webgl_get_parameter_utf8.sig="pi";var _emscripten_webgl_get_parameter_i64v=(t,e)=>writeI53ToI64(e,GLctx.getParameter(t));Module._emscripten_webgl_get_parameter_i64v=_emscripten_webgl_get_parameter_i64v,_emscripten_webgl_get_parameter_i64v.sig="vip";var EGL={errorCode:12288,defaultDisplayInitialized:!1,currentContext:0,currentReadSurface:0,currentDrawSurface:0,contextAttributes:{alpha:!1,depth:!1,stencil:!1,antialias:!1},stringCache:{},setErrorCode(t){EGL.errorCode=t},chooseConfig(t,e,n,_,r){if(t!=62e3)return EGL.setErrorCode(12296),0;if(e)for(;;){var a=HEAP32[e>>2];if(a==12321){var o=HEAP32[e+4>>2];EGL.contextAttributes.alpha=o>0}else if(a==12325){var l=HEAP32[e+4>>2];EGL.contextAttributes.depth=l>0}else if(a==12326){var p=HEAP32[e+4>>2];EGL.contextAttributes.stencil=p>0}else if(a==12337){var c=HEAP32[e+4>>2];EGL.contextAttributes.antialias=c>0}else if(a==12338){var c=HEAP32[e+4>>2];EGL.contextAttributes.antialias=c==1}else if(a==12544){var I=HEAP32[e+4>>2];EGL.contextAttributes.lowLatency=I!=12547}else if(a==12344)break;e+=8}return(!n||!_)&&!r?(EGL.setErrorCode(12300),0):(r&&(HEAP32[r>>2]=1),n&&_>0&&(HEAP32[n>>2]=62002),EGL.setErrorCode(12288),1)}};Module.EGL=EGL;var _eglGetDisplay=t=>(EGL.setErrorCode(12288),62e3);Module._eglGetDisplay=_eglGetDisplay,_eglGetDisplay.sig="pi";var _eglInitialize=(t,e,n)=>t!=62e3?(EGL.setErrorCode(12296),0):(e&&(HEAP32[e>>2]=1),n&&(HEAP32[n>>2]=4),EGL.defaultDisplayInitialized=!0,EGL.setErrorCode(12288),1);Module._eglInitialize=_eglInitialize,_eglInitialize.sig="ippp";var _eglTerminate=t=>t!=62e3?(EGL.setErrorCode(12296),0):(EGL.currentContext=0,EGL.currentReadSurface=0,EGL.currentDrawSurface=0,EGL.defaultDisplayInitialized=!1,EGL.setErrorCode(12288),1);Module._eglTerminate=_eglTerminate,_eglTerminate.sig="ip";var _eglGetConfigs=(t,e,n,_)=>EGL.chooseConfig(t,0,e,n,_);Module._eglGetConfigs=_eglGetConfigs,_eglGetConfigs.sig="ippip";var _eglChooseConfig=(t,e,n,_,r)=>EGL.chooseConfig(t,e,n,_,r);Module._eglChooseConfig=_eglChooseConfig,_eglChooseConfig.sig="ipppip";var _eglGetConfigAttrib=(t,e,n,_)=>{if(t!=62e3)return EGL.setErrorCode(12296),0;if(e!=62002)return EGL.setErrorCode(12293),0;if(!_)return EGL.setErrorCode(12300),0;switch(EGL.setErrorCode(12288),n){case 12320:return HEAP32[_>>2]=EGL.contextAttributes.alpha?32:24,1;case 12321:return HEAP32[_>>2]=EGL.contextAttributes.alpha?8:0,1;case 12322:return HEAP32[_>>2]=8,1;case 12323:return HEAP32[_>>2]=8,1;case 12324:return HEAP32[_>>2]=8,1;case 12325:return HEAP32[_>>2]=EGL.contextAttributes.depth?24:0,1;case 12326:return HEAP32[_>>2]=EGL.contextAttributes.stencil?8:0,1;case 12327:return HEAP32[_>>2]=12344,1;case 12328:return HEAP32[_>>2]=62002,1;case 12329:return HEAP32[_>>2]=0,1;case 12330:return HEAP32[_>>2]=4096,1;case 12331:return HEAP32[_>>2]=16777216,1;case 12332:return HEAP32[_>>2]=4096,1;case 12333:return HEAP32[_>>2]=0,1;case 12334:return HEAP32[_>>2]=0,1;case 12335:return HEAP32[_>>2]=12344,1;case 12337:return HEAP32[_>>2]=EGL.contextAttributes.antialias?4:0,1;case 12338:return HEAP32[_>>2]=EGL.contextAttributes.antialias?1:0,1;case 12339:return HEAP32[_>>2]=4,1;case 12340:return HEAP32[_>>2]=12344,1;case 12341:case 12342:case 12343:return HEAP32[_>>2]=-1,1;case 12345:case 12346:return HEAP32[_>>2]=0,1;case 12347:return HEAP32[_>>2]=0,1;case 12348:return HEAP32[_>>2]=1,1;case 12349:case 12350:return HEAP32[_>>2]=0,1;case 12351:return HEAP32[_>>2]=12430,1;case 12352:return HEAP32[_>>2]=4,1;case 12354:return HEAP32[_>>2]=0,1;default:return EGL.setErrorCode(12292),0}};Module._eglGetConfigAttrib=_eglGetConfigAttrib,_eglGetConfigAttrib.sig="ippip";var _eglCreateWindowSurface=(t,e,n,_)=>t!=62e3?(EGL.setErrorCode(12296),0):e!=62002?(EGL.setErrorCode(12293),0):(EGL.setErrorCode(12288),62006);Module._eglCreateWindowSurface=_eglCreateWindowSurface,_eglCreateWindowSurface.sig="pppip";var _eglDestroySurface=(t,e)=>t!=62e3?(EGL.setErrorCode(12296),0):e!=62006?(EGL.setErrorCode(12301),1):(EGL.currentReadSurface==e&&(EGL.currentReadSurface=0),EGL.currentDrawSurface==e&&(EGL.currentDrawSurface=0),EGL.setErrorCode(12288),1);Module._eglDestroySurface=_eglDestroySurface,_eglDestroySurface.sig="ipp";var _eglCreateContext=(t,e,n,_)=>{if(t!=62e3)return EGL.setErrorCode(12296),0;for(var r=1;;){var a=HEAP32[_>>2];if(a==12440)r=HEAP32[_+4>>2];else{if(a==12344)break;return EGL.setErrorCode(12292),0}_+=8}return r!=2?(EGL.setErrorCode(12293),0):(EGL.contextAttributes.majorVersion=r-1,EGL.contextAttributes.minorVersion=0,EGL.context=GL.createContext(Module.canvas,EGL.contextAttributes),EGL.context!=0?(EGL.setErrorCode(12288),GL.makeContextCurrent(EGL.context),Module.useWebGL=!0,Browser.moduleContextCreatedCallbacks.forEach(function(o){o()}),GL.makeContextCurrent(null),62004):(EGL.setErrorCode(12297),0))};Module._eglCreateContext=_eglCreateContext,_eglCreateContext.sig="ppppp";var _eglDestroyContext=(t,e)=>t!=62e3?(EGL.setErrorCode(12296),0):e!=62004?(EGL.setErrorCode(12294),0):(GL.deleteContext(EGL.context),EGL.setErrorCode(12288),EGL.currentContext==e&&(EGL.currentContext=0),1);Module._eglDestroyContext=_eglDestroyContext,_eglDestroyContext.sig="ipp";var _eglQuerySurface=(t,e,n,_)=>{if(t!=62e3)return EGL.setErrorCode(12296),0;if(e!=62006)return EGL.setErrorCode(12301),0;if(!_)return EGL.setErrorCode(12300),0;switch(EGL.setErrorCode(12288),n){case 12328:return HEAP32[_>>2]=62002,1;case 12376:return 1;case 12375:return HEAP32[_>>2]=Module.canvas.width,1;case 12374:return HEAP32[_>>2]=Module.canvas.height,1;case 12432:return HEAP32[_>>2]=-1,1;case 12433:return HEAP32[_>>2]=-1,1;case 12434:return HEAP32[_>>2]=-1,1;case 12422:return HEAP32[_>>2]=12420,1;case 12441:return HEAP32[_>>2]=12442,1;case 12435:return HEAP32[_>>2]=12437,1;case 12416:case 12417:case 12418:case 12419:return 1;default:return EGL.setErrorCode(12292),0}};Module._eglQuerySurface=_eglQuerySurface,_eglQuerySurface.sig="ippip";var _eglQueryContext=(t,e,n,_)=>{if(t!=62e3)return EGL.setErrorCode(12296),0;if(e!=62004)return EGL.setErrorCode(12294),0;if(!_)return EGL.setErrorCode(12300),0;switch(EGL.setErrorCode(12288),n){case 12328:return HEAP32[_>>2]=62002,1;case 12439:return HEAP32[_>>2]=12448,1;case 12440:return HEAP32[_>>2]=EGL.contextAttributes.majorVersion+1,1;case 12422:return HEAP32[_>>2]=12420,1;default:return EGL.setErrorCode(12292),0}};Module._eglQueryContext=_eglQueryContext,_eglQueryContext.sig="ippip";var _eglGetError=()=>EGL.errorCode;Module._eglGetError=_eglGetError,_eglGetError.sig="i";var _eglQueryString=(t,e)=>{if(t!=62e3)return EGL.setErrorCode(12296),0;if(EGL.setErrorCode(12288),EGL.stringCache[e])return EGL.stringCache[e];var n;switch(e){case 12371:n=stringToNewUTF8("Emscripten");break;case 12372:n=stringToNewUTF8("1.4 Emscripten EGL");break;case 12373:n=stringToNewUTF8("");break;case 12429:n=stringToNewUTF8("OpenGL_ES");break;default:return EGL.setErrorCode(12300),0}return EGL.stringCache[e]=n,n};Module._eglQueryString=_eglQueryString,_eglQueryString.sig="ppi";var _eglBindAPI=t=>t==12448?(EGL.setErrorCode(12288),1):(EGL.setErrorCode(12300),0);Module._eglBindAPI=_eglBindAPI,_eglBindAPI.sig="ii";var _eglQueryAPI=()=>(EGL.setErrorCode(12288),12448);Module._eglQueryAPI=_eglQueryAPI,_eglQueryAPI.sig="i";var _eglWaitClient=()=>(EGL.setErrorCode(12288),1);Module._eglWaitClient=_eglWaitClient,_eglWaitClient.sig="i";var _eglWaitNative=t=>(EGL.setErrorCode(12288),1);Module._eglWaitNative=_eglWaitNative,_eglWaitNative.sig="ii";var _eglWaitGL=_eglWaitClient;Module._eglWaitGL=_eglWaitGL,_eglWaitGL.sig="i";var _eglSwapInterval=(t,e)=>t!=62e3?(EGL.setErrorCode(12296),0):(e==0?_emscripten_set_main_loop_timing(0,0):_emscripten_set_main_loop_timing(1,e),EGL.setErrorCode(12288),1);Module._eglSwapInterval=_eglSwapInterval,_eglSwapInterval.sig="ipi";var _eglMakeCurrent=(t,e,n,_)=>t!=62e3?(EGL.setErrorCode(12296),0):_!=0&&_!=62004?(EGL.setErrorCode(12294),0):n!=0&&n!=62006||e!=0&&e!=62006?(EGL.setErrorCode(12301),0):(GL.makeContextCurrent(_?EGL.context:null),EGL.currentContext=_,EGL.currentDrawSurface=e,EGL.currentReadSurface=n,EGL.setErrorCode(12288),1);Module._eglMakeCurrent=_eglMakeCurrent,_eglMakeCurrent.sig="ipppp";var _eglGetCurrentContext=()=>EGL.currentContext;Module._eglGetCurrentContext=_eglGetCurrentContext,_eglGetCurrentContext.sig="p";var _eglGetCurrentSurface=t=>t==12378?EGL.currentReadSurface:t==12377?EGL.currentDrawSurface:(EGL.setErrorCode(12300),0);Module._eglGetCurrentSurface=_eglGetCurrentSurface,_eglGetCurrentSurface.sig="pi";var _eglGetCurrentDisplay=()=>EGL.currentContext?62e3:0;Module._eglGetCurrentDisplay=_eglGetCurrentDisplay,_eglGetCurrentDisplay.sig="p";var _eglSwapBuffers=(t,e)=>{if(!EGL.defaultDisplayInitialized)EGL.setErrorCode(12289);else if(!Module.ctx)EGL.setErrorCode(12290);else if(Module.ctx.isContextLost())EGL.setErrorCode(12302);else return EGL.setErrorCode(12288),1;return 0};Module._eglSwapBuffers=_eglSwapBuffers,_eglSwapBuffers.sig="ipp";var _eglReleaseThread=()=>(EGL.currentContext=0,EGL.currentReadSurface=0,EGL.currentDrawSurface=0,EGL.setErrorCode(12288),1);Module._eglReleaseThread=_eglReleaseThread,_eglReleaseThread.sig="i",Module.createInvoke||(Module.createInvoke=Module.createInvokeFunction),registerWasmPlugin();var FSNode=function(t,e,n,_){t||(t=this),this.parent=t,this.mount=t.mount,this.mounted=null,this.id=FS.nextInode++,this.name=e,this.mode=n,this.node_ops={},this.stream_ops={},this.rdev=_},readMode=365,writeMode=146;Object.defineProperties(FSNode.prototype,{read:{get:function(){return(this.mode&readMode)===readMode},set:function(t){t?this.mode|=readMode:this.mode&=~readMode}},write:{get:function(){return(this.mode&writeMode)===writeMode},set:function(t){t?this.mode|=writeMode:this.mode&=~writeMode}},isFolder:{get:function(){return FS.isDir(this.mode)}},isDevice:{get:function(){return FS.isChrdev(this.mode)}}}),FS.FSNode=FSNode,FS.createPreloadedFile=FS_createPreloadedFile,FS.staticInit(),Module.FS_createPath=FS.createPath,Module.FS_createDataFile=FS.createDataFile,Module.FS_createPreloadedFile=FS.createPreloadedFile,Module.FS_unlink=FS.unlink,Module.FS_createLazyFile=FS.createLazyFile,Module.FS_createDevice=FS.createDevice,ENVIRONMENT_IS_NODE&&NODEFS.staticInit(),ERRNO_CODES={EPERM:63,ENOENT:44,ESRCH:71,EINTR:27,EIO:29,ENXIO:60,E2BIG:1,ENOEXEC:45,EBADF:8,ECHILD:12,EAGAIN:6,EWOULDBLOCK:6,ENOMEM:48,EACCES:2,EFAULT:21,ENOTBLK:105,EBUSY:10,EEXIST:20,EXDEV:75,ENODEV:43,ENOTDIR:54,EISDIR:31,EINVAL:28,ENFILE:41,EMFILE:33,ENOTTY:59,ETXTBSY:74,EFBIG:22,ENOSPC:51,ESPIPE:70,EROFS:69,EMLINK:34,EPIPE:64,EDOM:18,ERANGE:68,ENOMSG:49,EIDRM:24,ECHRNG:106,EL2NSYNC:156,EL3HLT:107,EL3RST:108,ELNRNG:109,EUNATCH:110,ENOCSI:111,EL2HLT:112,EDEADLK:16,ENOLCK:46,EBADE:113,EBADR:114,EXFULL:115,ENOANO:104,EBADRQC:103,EBADSLT:102,EDEADLOCK:16,EBFONT:101,ENOSTR:100,ENODATA:116,ETIME:117,ENOSR:118,ENONET:119,ENOPKG:120,EREMOTE:121,ENOLINK:47,EADV:122,ESRMNT:123,ECOMM:124,EPROTO:65,EMULTIHOP:36,EDOTDOT:125,EBADMSG:9,ENOTUNIQ:126,EBADFD:127,EREMCHG:128,ELIBACC:129,ELIBBAD:130,ELIBSCN:131,ELIBMAX:132,ELIBEXEC:133,ENOSYS:52,ENOTEMPTY:55,ENAMETOOLONG:37,ELOOP:32,EOPNOTSUPP:138,EPFNOSUPPORT:139,ECONNRESET:15,ENOBUFS:42,EAFNOSUPPORT:5,EPROTOTYPE:67,ENOTSOCK:57,ENOPROTOOPT:50,ESHUTDOWN:140,ECONNREFUSED:14,EADDRINUSE:3,ECONNABORTED:13,ENETUNREACH:40,ENETDOWN:38,ETIMEDOUT:73,EHOSTDOWN:142,EHOSTUNREACH:23,EINPROGRESS:26,EALREADY:7,EDESTADDRREQ:17,EMSGSIZE:35,EPROTONOSUPPORT:66,ESOCKTNOSUPPORT:137,EADDRNOTAVAIL:4,ENETRESET:39,EISCONN:30,ENOTCONN:53,ETOOMANYREFS:141,EUSERS:136,EDQUOT:19,ESTALE:72,ENOTSUP:138,ENOMEDIUM:148,EILSEQ:25,EOVERFLOW:61,ECANCELED:11,ENOTRECOVERABLE:56,EOWNERDEAD:62,ESTRPIPE:135};for(var GLctx,i=0;i<32;++i)tempFixedLengthArray.push(new Array(i));for(var miniTempWebGLFloatBuffersStorage=new Float32Array(288),i=0;i<288;++i)miniTempWebGLFloatBuffers[i]=miniTempWebGLFloatBuffersStorage.subarray(0,i+1);for(var miniTempWebGLIntBuffersStorage=new Int32Array(288),i=0;i<288;++i)miniTempWebGLIntBuffers[i]=miniTempWebGLIntBuffersStorage.subarray(0,i+1);handleAllocatorInit();var emSetImmediate,emClearImmediate;if(typeof setImmediate<"u")emSetImmediate=setImmediateWrapped,emClearImmediate=clearImmediateWrapped;else if(typeof addEventListener=="function"){var __setImmediate_id_counter=0,__setImmediate_queue=[],__setImmediate_message_id="_si",__setImmediate_cb=t=>{t.data===__setImmediate_message_id&&(t.stopPropagation(),__setImmediate_queue.shift()(),++__setImmediate_id_counter)};addEventListener("message",__setImmediate_cb,!0),emSetImmediate=t=>(postMessage(__setImmediate_message_id,"*"),__setImmediate_id_counter+__setImmediate_queue.push(t)-1),emClearImmediate=t=>{var e=t-__setImmediate_id_counter;e>=0&&e<__setImmediate_queue.length&&(__setImmediate_queue[e]=()=>{})}}Module.requestFullscreen=(t,e)=>Browser.requestFullscreen(t,e),Module.requestAnimationFrame=t=>Browser.requestAnimationFrame(t),Module.setCanvasSize=(t,e,n)=>Browser.setCanvasSize(t,e,n),Module.pauseMainLoop=()=>Browser.mainLoop.pause(),Module.resumeMainLoop=()=>Browser.mainLoop.resume(),Module.getUserMedia=()=>Browser.getUserMedia(),Module.createContext=(t,e,n,_)=>Browser.createContext(t,e,n,_);var preloadedImages={},preloadedAudios={},wasmImports={JsArray_count_js,JsArray_index_js,JsArray_inplace_repeat_js,JsArray_repeat_js,JsArray_reverse_js,JsArray_reversed_iterator,JsBuffer_DecodeString_js,JsBuffer_get_info,JsDoubleProxy_unwrap_helper,JsException_new_helper,JsMap_GetIter_js,JsMap_clear_js,JsObjMap_GetIter_js,JsObjMap_ass_subscript_js,JsObjMap_contains_js,JsObjMap_length_js,JsObjMap_subscript_js,JsProxy_Bool_js,JsProxy_DelAttr_js,JsProxy_Dir_js,JsProxy_GetAsyncIter_js,JsProxy_GetAttr_js,JsProxy_GetIter_js,JsProxy_SetAttr_js,JsProxy_compute_typeflags,JsProxy_subscript_js,JsvArray_Check,JsvArray_Delete,JsvArray_Extend,JsvArray_Get,JsvArray_Insert,JsvArray_New,JsvArray_Push,JsvArray_Set,JsvArray_ShallowCopy,JsvArray_slice,JsvArray_slice_assign,JsvAsyncGenerator_Check,JsvBuffer_assignFromPtr,JsvBuffer_assignToPtr,JsvBuffer_intoFile,JsvBuffer_readFromFile,JsvBuffer_writeToFile,JsvError_Throw,JsvFunction_CallBound,JsvFunction_Call_OneArg,JsvFunction_Check,JsvFunction_Construct,JsvGenerator_Check,JsvMap_New,JsvMap_Set,JsvNoValue_Check,JsvNum_fromDigits,JsvNum_fromDouble,JsvNum_fromInt,JsvObject_CallMethod,JsvObject_CallMethod_NoArgs,JsvObject_CallMethod_OneArg,JsvObject_CallMethod_TwoArgs,JsvObject_Entries,JsvObject_Keys,JsvObject_New,JsvObject_SetAttr,JsvObject_Values,JsvObject_toString,JsvPromise_Check,JsvPromise_Resolve,JsvPromise_Syncify_handleError,JsvSet_Add,JsvSet_New,JsvUTF8ToString,Jsv_constructorName,Jsv_equal,Jsv_greater_than,Jsv_greater_than_equal,Jsv_less_than,Jsv_less_than_equal,Jsv_not_equal,Jsv_to_bool,Jsv_typeof,_JsArray_PostProcess_helper,_JsArray_PushEntry_helper,_PyEM_CountFuncParams,_PyEM_TrampolineCall_JS,_PyEM_detect_type_reflection,_PyImport_InitFunc_TrampolineCall,_Py_CheckEmscriptenSignals_Helper,_Py_emscripten_runtime,_Unwind_Backtrace:__Unwind_Backtrace,_Unwind_DeleteException:__Unwind_DeleteException,_Unwind_FindEnclosingFunction:__Unwind_FindEnclosingFunction,_Unwind_GetIPInfo:__Unwind_GetIPInfo,_Unwind_RaiseException:__Unwind_RaiseException,__asctime_r:___asctime_r,__assert_fail:___assert_fail,__call_sighandler:___call_sighandler,__cxa_begin_catch:___cxa_begin_catch,__cxa_call_unexpected:___cxa_call_unexpected,__cxa_current_primary_exception:___cxa_current_primary_exception,__cxa_end_catch:___cxa_end_catch,__cxa_find_matching_catch_2:___cxa_find_matching_catch_2,__cxa_find_matching_catch_3:___cxa_find_matching_catch_3,__cxa_find_matching_catch_4:___cxa_find_matching_catch_4,__cxa_get_exception_ptr:___cxa_get_exception_ptr,__cxa_rethrow:___cxa_rethrow,__cxa_rethrow_primary_exception:___cxa_rethrow_primary_exception,__cxa_throw:___cxa_throw,__cxa_uncaught_exceptions:___cxa_uncaught_exceptions,__global_base:___global_base,__heap_base:___heap_base,__hiwire_deduplicate_delete,__hiwire_deduplicate_get,__hiwire_deduplicate_new,__hiwire_deduplicate_set,__indirect_function_table:wasmTable,__memory_base:___memory_base,__resumeException:___resumeException,__stack_high:___stack_high,__stack_low:___stack_low,__stack_pointer:___stack_pointer,__syscall__newselect:___syscall__newselect,__syscall_accept4:___syscall_accept4,__syscall_bind:___syscall_bind,__syscall_chdir:___syscall_chdir,__syscall_chmod:___syscall_chmod,__syscall_connect:___syscall_connect,__syscall_dup:___syscall_dup,__syscall_dup3:___syscall_dup3,__syscall_faccessat:___syscall_faccessat,__syscall_fadvise64:___syscall_fadvise64,__syscall_fallocate:___syscall_fallocate,__syscall_fchdir:___syscall_fchdir,__syscall_fchmod:___syscall_fchmod,__syscall_fchmodat:___syscall_fchmodat,__syscall_fchown32:___syscall_fchown32,__syscall_fchownat:___syscall_fchownat,__syscall_fcntl64:___syscall_fcntl64,__syscall_fdatasync:___syscall_fdatasync,__syscall_fstat64:___syscall_fstat64,__syscall_fstatfs64:___syscall_fstatfs64,__syscall_ftruncate64:___syscall_ftruncate64,__syscall_getcwd:___syscall_getcwd,__syscall_getdents64:___syscall_getdents64,__syscall_getpeername:___syscall_getpeername,__syscall_getsockname:___syscall_getsockname,__syscall_getsockopt:___syscall_getsockopt,__syscall_ioctl:___syscall_ioctl,__syscall_listen:___syscall_listen,__syscall_lstat64:___syscall_lstat64,__syscall_mkdirat:___syscall_mkdirat,__syscall_mknodat:___syscall_mknodat,__syscall_newfstatat:___syscall_newfstatat,__syscall_openat:___syscall_openat,__syscall_pipe:___syscall_pipe,__syscall_poll:___syscall_poll,__syscall_readlinkat:___syscall_readlinkat,__syscall_recvfrom:___syscall_recvfrom,__syscall_recvmsg:___syscall_recvmsg,__syscall_renameat:___syscall_renameat,__syscall_rmdir:___syscall_rmdir,__syscall_sendmsg:___syscall_sendmsg,__syscall_sendto:___syscall_sendto,__syscall_socket:___syscall_socket,__syscall_stat64:___syscall_stat64,__syscall_statfs64:___syscall_statfs64,__syscall_symlink:___syscall_symlink,__syscall_symlinkat:___syscall_symlinkat,__syscall_truncate64:___syscall_truncate64,__syscall_unlinkat:___syscall_unlinkat,__syscall_utimensat:___syscall_utimensat,__table_base:___table_base,_agen_handle_result_js,_dlopen_js:__dlopen_js,_dlsym_catchup_js:__dlsym_catchup_js,_dlsym_js:__dlsym_js,_emscripten_dlopen_js:__emscripten_dlopen_js,_emscripten_fs_load_embedded_files:__emscripten_fs_load_embedded_files,_emscripten_get_now_is_monotonic:__emscripten_get_now_is_monotonic,_emscripten_get_progname:__emscripten_get_progname,_emscripten_push_main_loop_blocker:__emscripten_push_main_loop_blocker,_emscripten_push_uncounted_main_loop_blocker:__emscripten_push_uncounted_main_loop_blocker,_emscripten_throw_longjmp:__emscripten_throw_longjmp,_glGenObject:__glGenObject,_glGetActiveAttribOrUniform:__glGetActiveAttribOrUniform,_gmtime_js:__gmtime_js,_localtime_js:__localtime_js,_mktime_js:__mktime_js,_mmap_js:__mmap_js,_msync_js:__msync_js,_munmap_js:__munmap_js,_pyproxyGen_make_result,_pyproxy_get_buffer_result,_python2js_add_to_cache,_python2js_addto_postprocess_list,_python2js_buffer_inner,_python2js_cache_lookup,_python2js_handle_postprocess_list,_python2js_ucs1,_python2js_ucs2,_python2js_ucs4,_setitimer_js:__setitimer_js,_timegm_js:__timegm_js,_tzset_js:__tzset_js,abort:_abort,array_to_js,clock_res_get:_clock_res_get,clock_time_get:_clock_time_get,create_once_callable,create_promise_handles,destroy_jsarray_entries,destroy_proxies,destroy_proxies_js,destroy_proxy,eglBindAPI:_eglBindAPI,eglChooseConfig:_eglChooseConfig,eglCreateContext:_eglCreateContext,eglCreateWindowSurface:_eglCreateWindowSurface,eglDestroyContext:_eglDestroyContext,eglDestroySurface:_eglDestroySurface,eglGetConfigAttrib:_eglGetConfigAttrib,eglGetConfigs:_eglGetConfigs,eglGetCurrentContext:_eglGetCurrentContext,eglGetCurrentDisplay:_eglGetCurrentDisplay,eglGetCurrentSurface:_eglGetCurrentSurface,eglGetDisplay:_eglGetDisplay,eglGetError:_eglGetError,eglInitialize:_eglInitialize,eglMakeCurrent:_eglMakeCurrent,eglQueryAPI:_eglQueryAPI,eglQueryContext:_eglQueryContext,eglQueryString:_eglQueryString,eglQuerySurface:_eglQuerySurface,eglReleaseThread:_eglReleaseThread,eglSwapBuffers:_eglSwapBuffers,eglSwapInterval:_eglSwapInterval,eglTerminate:_eglTerminate,eglWaitClient:_eglWaitClient,eglWaitGL:_eglWaitGL,eglWaitNative:_eglWaitNative,emscripten_asm_const_async_on_main_thread:_emscripten_asm_const_async_on_main_thread,emscripten_asm_const_double:_emscripten_asm_const_double,emscripten_asm_const_double_sync_on_main_thread:_emscripten_asm_const_double_sync_on_main_thread,emscripten_asm_const_int:_emscripten_asm_const_int,emscripten_asm_const_int_sync_on_main_thread:_emscripten_asm_const_int_sync_on_main_thread,emscripten_asm_const_ptr:_emscripten_asm_const_ptr,emscripten_async_call:_emscripten_async_call,emscripten_async_load_script:_emscripten_async_load_script,emscripten_async_run_script:_emscripten_async_run_script,emscripten_async_wget:_emscripten_async_wget,emscripten_async_wget2:_emscripten_async_wget2,emscripten_async_wget2_abort:_emscripten_async_wget2_abort,emscripten_async_wget2_data:_emscripten_async_wget2_data,emscripten_async_wget_data:_emscripten_async_wget_data,emscripten_call_worker:_emscripten_call_worker,emscripten_cancel_animation_frame:_emscripten_cancel_animation_frame,emscripten_cancel_main_loop:_emscripten_cancel_main_loop,emscripten_clear_immediate:_emscripten_clear_immediate,emscripten_clear_interval:_emscripten_clear_interval,emscripten_clear_timeout:_emscripten_clear_timeout,emscripten_console_error:_emscripten_console_error,emscripten_console_log:_emscripten_console_log,emscripten_console_warn:_emscripten_console_warn,emscripten_create_worker:_emscripten_create_worker,emscripten_date_now:_emscripten_date_now,emscripten_debugger:_emscripten_debugger,emscripten_destroy_worker:_emscripten_destroy_worker,emscripten_enter_soft_fullscreen:_emscripten_enter_soft_fullscreen,emscripten_err:_emscripten_err,emscripten_errn:_emscripten_errn,emscripten_exit_fullscreen:_emscripten_exit_fullscreen,emscripten_exit_pointerlock:_emscripten_exit_pointerlock,emscripten_exit_soft_fullscreen:_emscripten_exit_soft_fullscreen,emscripten_exit_with_live_runtime:_emscripten_exit_with_live_runtime,emscripten_force_exit:_emscripten_force_exit,emscripten_get_battery_status:_emscripten_get_battery_status,emscripten_get_callstack:_emscripten_get_callstack,emscripten_get_canvas_element_size:_emscripten_get_canvas_element_size,emscripten_get_canvas_size:_emscripten_get_canvas_size,emscripten_get_compiler_setting:_emscripten_get_compiler_setting,emscripten_get_device_pixel_ratio:_emscripten_get_device_pixel_ratio,emscripten_get_devicemotion_status:_emscripten_get_devicemotion_status,emscripten_get_deviceorientation_status:_emscripten_get_deviceorientation_status,emscripten_get_element_css_size:_emscripten_get_element_css_size,emscripten_get_fullscreen_status:_emscripten_get_fullscreen_status,emscripten_get_gamepad_status:_emscripten_get_gamepad_status,emscripten_get_heap_max:_emscripten_get_heap_max,emscripten_get_main_loop_timing:_emscripten_get_main_loop_timing,emscripten_get_module_name:_emscripten_get_module_name,emscripten_get_mouse_status:_emscripten_get_mouse_status,emscripten_get_now:_emscripten_get_now,emscripten_get_now_res:_emscripten_get_now_res,emscripten_get_num_gamepads:_emscripten_get_num_gamepads,emscripten_get_orientation_status:_emscripten_get_orientation_status,emscripten_get_pointerlock_status:_emscripten_get_pointerlock_status,emscripten_get_preloaded_image_data:_emscripten_get_preloaded_image_data,emscripten_get_preloaded_image_data_from_FILE:_emscripten_get_preloaded_image_data_from_FILE,emscripten_get_screen_size:_emscripten_get_screen_size,emscripten_get_visibility_status:_emscripten_get_visibility_status,emscripten_get_window_title:_emscripten_get_window_title,emscripten_get_worker_queue_size:_emscripten_get_worker_queue_size,emscripten_glActiveTexture:_emscripten_glActiveTexture,emscripten_glAttachShader:_emscripten_glAttachShader,emscripten_glBegin:_emscripten_glBegin,emscripten_glBeginQueryEXT:_emscripten_glBeginQueryEXT,emscripten_glBindAttribLocation:_emscripten_glBindAttribLocation,emscripten_glBindBuffer:_emscripten_glBindBuffer,emscripten_glBindFramebuffer:_emscripten_glBindFramebuffer,emscripten_glBindRenderbuffer:_emscripten_glBindRenderbuffer,emscripten_glBindTexture:_emscripten_glBindTexture,emscripten_glBindVertexArray:_emscripten_glBindVertexArray,emscripten_glBindVertexArrayOES:_emscripten_glBindVertexArrayOES,emscripten_glBlendColor:_emscripten_glBlendColor,emscripten_glBlendEquation:_emscripten_glBlendEquation,emscripten_glBlendEquationSeparate:_emscripten_glBlendEquationSeparate,emscripten_glBlendFunc:_emscripten_glBlendFunc,emscripten_glBlendFuncSeparate:_emscripten_glBlendFuncSeparate,emscripten_glBufferData:_emscripten_glBufferData,emscripten_glBufferSubData:_emscripten_glBufferSubData,emscripten_glCheckFramebufferStatus:_emscripten_glCheckFramebufferStatus,emscripten_glClear:_emscripten_glClear,emscripten_glClearColor:_emscripten_glClearColor,emscripten_glClearDepth:_emscripten_glClearDepth,emscripten_glClearDepthf:_emscripten_glClearDepthf,emscripten_glClearStencil:_emscripten_glClearStencil,emscripten_glColorMask:_emscripten_glColorMask,emscripten_glCompileShader:_emscripten_glCompileShader,emscripten_glCompressedTexImage2D:_emscripten_glCompressedTexImage2D,emscripten_glCompressedTexSubImage2D:_emscripten_glCompressedTexSubImage2D,emscripten_glCopyTexImage2D:_emscripten_glCopyTexImage2D,emscripten_glCopyTexSubImage2D:_emscripten_glCopyTexSubImage2D,emscripten_glCreateProgram:_emscripten_glCreateProgram,emscripten_glCreateShader:_emscripten_glCreateShader,emscripten_glCullFace:_emscripten_glCullFace,emscripten_glDeleteBuffers:_emscripten_glDeleteBuffers,emscripten_glDeleteFramebuffers:_emscripten_glDeleteFramebuffers,emscripten_glDeleteProgram:_emscripten_glDeleteProgram,emscripten_glDeleteQueriesEXT:_emscripten_glDeleteQueriesEXT,emscripten_glDeleteRenderbuffers:_emscripten_glDeleteRenderbuffers,emscripten_glDeleteShader:_emscripten_glDeleteShader,emscripten_glDeleteTextures:_emscripten_glDeleteTextures,emscripten_glDeleteVertexArrays:_emscripten_glDeleteVertexArrays,emscripten_glDeleteVertexArraysOES:_emscripten_glDeleteVertexArraysOES,emscripten_glDepthFunc:_emscripten_glDepthFunc,emscripten_glDepthMask:_emscripten_glDepthMask,emscripten_glDepthRange:_emscripten_glDepthRange,emscripten_glDepthRangef:_emscripten_glDepthRangef,emscripten_glDetachShader:_emscripten_glDetachShader,emscripten_glDisable:_emscripten_glDisable,emscripten_glDisableVertexAttribArray:_emscripten_glDisableVertexAttribArray,emscripten_glDrawArrays:_emscripten_glDrawArrays,emscripten_glDrawArraysInstanced:_emscripten_glDrawArraysInstanced,emscripten_glDrawArraysInstancedANGLE:_emscripten_glDrawArraysInstancedANGLE,emscripten_glDrawArraysInstancedARB:_emscripten_glDrawArraysInstancedARB,emscripten_glDrawArraysInstancedEXT:_emscripten_glDrawArraysInstancedEXT,emscripten_glDrawArraysInstancedNV:_emscripten_glDrawArraysInstancedNV,emscripten_glDrawBuffers:_emscripten_glDrawBuffers,emscripten_glDrawBuffersEXT:_emscripten_glDrawBuffersEXT,emscripten_glDrawBuffersWEBGL:_emscripten_glDrawBuffersWEBGL,emscripten_glDrawElements:_emscripten_glDrawElements,emscripten_glDrawElementsInstanced:_emscripten_glDrawElementsInstanced,emscripten_glDrawElementsInstancedANGLE:_emscripten_glDrawElementsInstancedANGLE,emscripten_glDrawElementsInstancedARB:_emscripten_glDrawElementsInstancedARB,emscripten_glDrawElementsInstancedEXT:_emscripten_glDrawElementsInstancedEXT,emscripten_glDrawElementsInstancedNV:_emscripten_glDrawElementsInstancedNV,emscripten_glEnable:_emscripten_glEnable,emscripten_glEnableVertexAttribArray:_emscripten_glEnableVertexAttribArray,emscripten_glEndQueryEXT:_emscripten_glEndQueryEXT,emscripten_glFinish:_emscripten_glFinish,emscripten_glFlush:_emscripten_glFlush,emscripten_glFramebufferRenderbuffer:_emscripten_glFramebufferRenderbuffer,emscripten_glFramebufferTexture2D:_emscripten_glFramebufferTexture2D,emscripten_glFrontFace:_emscripten_glFrontFace,emscripten_glGenBuffers:_emscripten_glGenBuffers,emscripten_glGenFramebuffers:_emscripten_glGenFramebuffers,emscripten_glGenQueriesEXT:_emscripten_glGenQueriesEXT,emscripten_glGenRenderbuffers:_emscripten_glGenRenderbuffers,emscripten_glGenTextures:_emscripten_glGenTextures,emscripten_glGenVertexArrays:_emscripten_glGenVertexArrays,emscripten_glGenVertexArraysOES:_emscripten_glGenVertexArraysOES,emscripten_glGenerateMipmap:_emscripten_glGenerateMipmap,emscripten_glGetActiveAttrib:_emscripten_glGetActiveAttrib,emscripten_glGetActiveUniform:_emscripten_glGetActiveUniform,emscripten_glGetAttachedShaders:_emscripten_glGetAttachedShaders,emscripten_glGetAttribLocation:_emscripten_glGetAttribLocation,emscripten_glGetBooleanv:_emscripten_glGetBooleanv,emscripten_glGetBufferParameteriv:_emscripten_glGetBufferParameteriv,emscripten_glGetError:_emscripten_glGetError,emscripten_glGetFloatv:_emscripten_glGetFloatv,emscripten_glGetFramebufferAttachmentParameteriv:_emscripten_glGetFramebufferAttachmentParameteriv,emscripten_glGetIntegerv:_emscripten_glGetIntegerv,emscripten_glGetProgramInfoLog:_emscripten_glGetProgramInfoLog,emscripten_glGetProgramiv:_emscripten_glGetProgramiv,emscripten_glGetQueryObjecti64vEXT:_emscripten_glGetQueryObjecti64vEXT,emscripten_glGetQueryObjectivEXT:_emscripten_glGetQueryObjectivEXT,emscripten_glGetQueryObjectui64vEXT:_emscripten_glGetQueryObjectui64vEXT,emscripten_glGetQueryObjectuivEXT:_emscripten_glGetQueryObjectuivEXT,emscripten_glGetQueryivEXT:_emscripten_glGetQueryivEXT,emscripten_glGetRenderbufferParameteriv:_emscripten_glGetRenderbufferParameteriv,emscripten_glGetShaderInfoLog:_emscripten_glGetShaderInfoLog,emscripten_glGetShaderPrecisionFormat:_emscripten_glGetShaderPrecisionFormat,emscripten_glGetShaderSource:_emscripten_glGetShaderSource,emscripten_glGetShaderiv:_emscripten_glGetShaderiv,emscripten_glGetString:_emscripten_glGetString,emscripten_glGetTexParameterfv:_emscripten_glGetTexParameterfv,emscripten_glGetTexParameteriv:_emscripten_glGetTexParameteriv,emscripten_glGetUniformLocation:_emscripten_glGetUniformLocation,emscripten_glGetUniformfv:_emscripten_glGetUniformfv,emscripten_glGetUniformiv:_emscripten_glGetUniformiv,emscripten_glGetVertexAttribPointerv:_emscripten_glGetVertexAttribPointerv,emscripten_glGetVertexAttribfv:_emscripten_glGetVertexAttribfv,emscripten_glGetVertexAttribiv:_emscripten_glGetVertexAttribiv,emscripten_glHint:_emscripten_glHint,emscripten_glIsBuffer:_emscripten_glIsBuffer,emscripten_glIsEnabled:_emscripten_glIsEnabled,emscripten_glIsFramebuffer:_emscripten_glIsFramebuffer,emscripten_glIsProgram:_emscripten_glIsProgram,emscripten_glIsQueryEXT:_emscripten_glIsQueryEXT,emscripten_glIsRenderbuffer:_emscripten_glIsRenderbuffer,emscripten_glIsShader:_emscripten_glIsShader,emscripten_glIsTexture:_emscripten_glIsTexture,emscripten_glIsVertexArray:_emscripten_glIsVertexArray,emscripten_glIsVertexArrayOES:_emscripten_glIsVertexArrayOES,emscripten_glLineWidth:_emscripten_glLineWidth,emscripten_glLinkProgram:_emscripten_glLinkProgram,emscripten_glLoadIdentity:_emscripten_glLoadIdentity,emscripten_glMatrixMode:_emscripten_glMatrixMode,emscripten_glMultiDrawArrays:_emscripten_glMultiDrawArrays,emscripten_glMultiDrawArraysANGLE:_emscripten_glMultiDrawArraysANGLE,emscripten_glMultiDrawArraysInstancedANGLE:_emscripten_glMultiDrawArraysInstancedANGLE,emscripten_glMultiDrawArraysInstancedWEBGL:_emscripten_glMultiDrawArraysInstancedWEBGL,emscripten_glMultiDrawArraysWEBGL:_emscripten_glMultiDrawArraysWEBGL,emscripten_glMultiDrawElements:_emscripten_glMultiDrawElements,emscripten_glMultiDrawElementsANGLE:_emscripten_glMultiDrawElementsANGLE,emscripten_glMultiDrawElementsInstancedANGLE:_emscripten_glMultiDrawElementsInstancedANGLE,emscripten_glMultiDrawElementsInstancedWEBGL:_emscripten_glMultiDrawElementsInstancedWEBGL,emscripten_glMultiDrawElementsWEBGL:_emscripten_glMultiDrawElementsWEBGL,emscripten_glPixelStorei:_emscripten_glPixelStorei,emscripten_glPolygonOffset:_emscripten_glPolygonOffset,emscripten_glQueryCounterEXT:_emscripten_glQueryCounterEXT,emscripten_glReadPixels:_emscripten_glReadPixels,emscripten_glReleaseShaderCompiler:_emscripten_glReleaseShaderCompiler,emscripten_glRenderbufferStorage:_emscripten_glRenderbufferStorage,emscripten_glSampleCoverage:_emscripten_glSampleCoverage,emscripten_glScissor:_emscripten_glScissor,emscripten_glShaderBinary:_emscripten_glShaderBinary,emscripten_glShaderSource:_emscripten_glShaderSource,emscripten_glStencilFunc:_emscripten_glStencilFunc,emscripten_glStencilFuncSeparate:_emscripten_glStencilFuncSeparate,emscripten_glStencilMask:_emscripten_glStencilMask,emscripten_glStencilMaskSeparate:_emscripten_glStencilMaskSeparate,emscripten_glStencilOp:_emscripten_glStencilOp,emscripten_glStencilOpSeparate:_emscripten_glStencilOpSeparate,emscripten_glTexImage2D:_emscripten_glTexImage2D,emscripten_glTexParameterf:_emscripten_glTexParameterf,emscripten_glTexParameterfv:_emscripten_glTexParameterfv,emscripten_glTexParameteri:_emscripten_glTexParameteri,emscripten_glTexParameteriv:_emscripten_glTexParameteriv,emscripten_glTexSubImage2D:_emscripten_glTexSubImage2D,emscripten_glUniform1f:_emscripten_glUniform1f,emscripten_glUniform1fv:_emscripten_glUniform1fv,emscripten_glUniform1i:_emscripten_glUniform1i,emscripten_glUniform1iv:_emscripten_glUniform1iv,emscripten_glUniform2f:_emscripten_glUniform2f,emscripten_glUniform2fv:_emscripten_glUniform2fv,emscripten_glUniform2i:_emscripten_glUniform2i,emscripten_glUniform2iv:_emscripten_glUniform2iv,emscripten_glUniform3f:_emscripten_glUniform3f,emscripten_glUniform3fv:_emscripten_glUniform3fv,emscripten_glUniform3i:_emscripten_glUniform3i,emscripten_glUniform3iv:_emscripten_glUniform3iv,emscripten_glUniform4f:_emscripten_glUniform4f,emscripten_glUniform4fv:_emscripten_glUniform4fv,emscripten_glUniform4i:_emscripten_glUniform4i,emscripten_glUniform4iv:_emscripten_glUniform4iv,emscripten_glUniformMatrix2fv:_emscripten_glUniformMatrix2fv,emscripten_glUniformMatrix3fv:_emscripten_glUniformMatrix3fv,emscripten_glUniformMatrix4fv:_emscripten_glUniformMatrix4fv,emscripten_glUseProgram:_emscripten_glUseProgram,emscripten_glValidateProgram:_emscripten_glValidateProgram,emscripten_glVertexAttrib1f:_emscripten_glVertexAttrib1f,emscripten_glVertexAttrib1fv:_emscripten_glVertexAttrib1fv,emscripten_glVertexAttrib2f:_emscripten_glVertexAttrib2f,emscripten_glVertexAttrib2fv:_emscripten_glVertexAttrib2fv,emscripten_glVertexAttrib3f:_emscripten_glVertexAttrib3f,emscripten_glVertexAttrib3fv:_emscripten_glVertexAttrib3fv,emscripten_glVertexAttrib4f:_emscripten_glVertexAttrib4f,emscripten_glVertexAttrib4fv:_emscripten_glVertexAttrib4fv,emscripten_glVertexAttribDivisor:_emscripten_glVertexAttribDivisor,emscripten_glVertexAttribDivisorANGLE:_emscripten_glVertexAttribDivisorANGLE,emscripten_glVertexAttribDivisorARB:_emscripten_glVertexAttribDivisorARB,emscripten_glVertexAttribDivisorEXT:_emscripten_glVertexAttribDivisorEXT,emscripten_glVertexAttribDivisorNV:_emscripten_glVertexAttribDivisorNV,emscripten_glVertexAttribPointer:_emscripten_glVertexAttribPointer,emscripten_glVertexPointer:_emscripten_glVertexPointer,emscripten_glViewport:_emscripten_glViewport,emscripten_has_asyncify:_emscripten_has_asyncify,emscripten_hide_mouse:_emscripten_hide_mouse,emscripten_html5_remove_all_event_listeners:_emscripten_html5_remove_all_event_listeners,emscripten_is_main_browser_thread:_emscripten_is_main_browser_thread,emscripten_is_webgl_context_lost:_emscripten_is_webgl_context_lost,emscripten_lock_orientation:_emscripten_lock_orientation,emscripten_log:_emscripten_log,emscripten_math_acos:_emscripten_math_acos,emscripten_math_acosh:_emscripten_math_acosh,emscripten_math_asin:_emscripten_math_asin,emscripten_math_asinh:_emscripten_math_asinh,emscripten_math_atan:_emscripten_math_atan,emscripten_math_atan2:_emscripten_math_atan2,emscripten_math_atanh:_emscripten_math_atanh,emscripten_math_cbrt:_emscripten_math_cbrt,emscripten_math_cos:_emscripten_math_cos,emscripten_math_cosh:_emscripten_math_cosh,emscripten_math_exp:_emscripten_math_exp,emscripten_math_expm1:_emscripten_math_expm1,emscripten_math_fmod:_emscripten_math_fmod,emscripten_math_hypot:_emscripten_math_hypot,emscripten_math_log:_emscripten_math_log,emscripten_math_log10:_emscripten_math_log10,emscripten_math_log1p:_emscripten_math_log1p,emscripten_math_log2:_emscripten_math_log2,emscripten_math_pow:_emscripten_math_pow,emscripten_math_random:_emscripten_math_random,emscripten_math_round:_emscripten_math_round,emscripten_math_sign:_emscripten_math_sign,emscripten_math_sin:_emscripten_math_sin,emscripten_math_sinh:_emscripten_math_sinh,emscripten_math_sqrt:_emscripten_math_sqrt,emscripten_math_tan:_emscripten_math_tan,emscripten_math_tanh:_emscripten_math_tanh,emscripten_memcpy_js:_emscripten_memcpy_js,emscripten_notify_memory_growth:_emscripten_notify_memory_growth,emscripten_out:_emscripten_out,emscripten_outn:_emscripten_outn,emscripten_pause_main_loop:_emscripten_pause_main_loop,emscripten_pc_get_column:_emscripten_pc_get_column,emscripten_pc_get_file:_emscripten_pc_get_file,emscripten_pc_get_function:_emscripten_pc_get_function,emscripten_pc_get_line:_emscripten_pc_get_line,emscripten_performance_now:_emscripten_performance_now,emscripten_print_double:_emscripten_print_double,emscripten_promise_all:_emscripten_promise_all,emscripten_promise_all_settled:_emscripten_promise_all_settled,emscripten_promise_any:_emscripten_promise_any,emscripten_promise_await:_emscripten_promise_await,emscripten_promise_create:_emscripten_promise_create,emscripten_promise_destroy:_emscripten_promise_destroy,emscripten_promise_race:_emscripten_promise_race,emscripten_promise_resolve:_emscripten_promise_resolve,emscripten_promise_then:_emscripten_promise_then,emscripten_random:_emscripten_random,emscripten_request_animation_frame:_emscripten_request_animation_frame,emscripten_request_animation_frame_loop:_emscripten_request_animation_frame_loop,emscripten_request_fullscreen:_emscripten_request_fullscreen,emscripten_request_fullscreen_strategy:_emscripten_request_fullscreen_strategy,emscripten_request_pointerlock:_emscripten_request_pointerlock,emscripten_resize_heap:_emscripten_resize_heap,emscripten_resume_main_loop:_emscripten_resume_main_loop,emscripten_return_address:_emscripten_return_address,emscripten_run_preload_plugins:_emscripten_run_preload_plugins,emscripten_run_preload_plugins_data:_emscripten_run_preload_plugins_data,emscripten_run_script:_emscripten_run_script,emscripten_run_script_int:_emscripten_run_script_int,emscripten_run_script_string:_emscripten_run_script_string,emscripten_runtime_keepalive_check:_emscripten_runtime_keepalive_check,emscripten_runtime_keepalive_pop:_emscripten_runtime_keepalive_pop,emscripten_runtime_keepalive_push:_emscripten_runtime_keepalive_push,emscripten_sample_gamepad_data:_emscripten_sample_gamepad_data,emscripten_set_batterychargingchange_callback_on_thread:_emscripten_set_batterychargingchange_callback_on_thread,emscripten_set_batterylevelchange_callback_on_thread:_emscripten_set_batterylevelchange_callback_on_thread,emscripten_set_beforeunload_callback_on_thread:_emscripten_set_beforeunload_callback_on_thread,emscripten_set_blur_callback_on_thread:_emscripten_set_blur_callback_on_thread,emscripten_set_canvas_element_size:_emscripten_set_canvas_element_size,emscripten_set_canvas_size:_emscripten_set_canvas_size,emscripten_set_click_callback_on_thread:_emscripten_set_click_callback_on_thread,emscripten_set_dblclick_callback_on_thread:_emscripten_set_dblclick_callback_on_thread,emscripten_set_devicemotion_callback_on_thread:_emscripten_set_devicemotion_callback_on_thread,emscripten_set_deviceorientation_callback_on_thread:_emscripten_set_deviceorientation_callback_on_thread,emscripten_set_element_css_size:_emscripten_set_element_css_size,emscripten_set_focus_callback_on_thread:_emscripten_set_focus_callback_on_thread,emscripten_set_focusin_callback_on_thread:_emscripten_set_focusin_callback_on_thread,emscripten_set_focusout_callback_on_thread:_emscripten_set_focusout_callback_on_thread,emscripten_set_fullscreenchange_callback_on_thread:_emscripten_set_fullscreenchange_callback_on_thread,emscripten_set_gamepadconnected_callback_on_thread:_emscripten_set_gamepadconnected_callback_on_thread,emscripten_set_gamepaddisconnected_callback_on_thread:_emscripten_set_gamepaddisconnected_callback_on_thread,emscripten_set_immediate:_emscripten_set_immediate,emscripten_set_immediate_loop:_emscripten_set_immediate_loop,emscripten_set_interval:_emscripten_set_interval,emscripten_set_keydown_callback_on_thread:_emscripten_set_keydown_callback_on_thread,emscripten_set_keypress_callback_on_thread:_emscripten_set_keypress_callback_on_thread,emscripten_set_keyup_callback_on_thread:_emscripten_set_keyup_callback_on_thread,emscripten_set_main_loop:_emscripten_set_main_loop,emscripten_set_main_loop_arg:_emscripten_set_main_loop_arg,emscripten_set_main_loop_expected_blockers:_emscripten_set_main_loop_expected_blockers,emscripten_set_main_loop_timing:_emscripten_set_main_loop_timing,emscripten_set_mousedown_callback_on_thread:_emscripten_set_mousedown_callback_on_thread,emscripten_set_mouseenter_callback_on_thread:_emscripten_set_mouseenter_callback_on_thread,emscripten_set_mouseleave_callback_on_thread:_emscripten_set_mouseleave_callback_on_thread,emscripten_set_mousemove_callback_on_thread:_emscripten_set_mousemove_callback_on_thread,emscripten_set_mouseout_callback_on_thread:_emscripten_set_mouseout_callback_on_thread,emscripten_set_mouseover_callback_on_thread:_emscripten_set_mouseover_callback_on_thread,emscripten_set_mouseup_callback_on_thread:_emscripten_set_mouseup_callback_on_thread,emscripten_set_orientationchange_callback_on_thread:_emscripten_set_orientationchange_callback_on_thread,emscripten_set_pointerlockchange_callback_on_thread:_emscripten_set_pointerlockchange_callback_on_thread,emscripten_set_pointerlockerror_callback_on_thread:_emscripten_set_pointerlockerror_callback_on_thread,emscripten_set_resize_callback_on_thread:_emscripten_set_resize_callback_on_thread,emscripten_set_scroll_callback_on_thread:_emscripten_set_scroll_callback_on_thread,emscripten_set_socket_close_callback:_emscripten_set_socket_close_callback,emscripten_set_socket_connection_callback:_emscripten_set_socket_connection_callback,emscripten_set_socket_error_callback:_emscripten_set_socket_error_callback,emscripten_set_socket_listen_callback:_emscripten_set_socket_listen_callback,emscripten_set_socket_message_callback:_emscripten_set_socket_message_callback,emscripten_set_socket_open_callback:_emscripten_set_socket_open_callback,emscripten_set_timeout:_emscripten_set_timeout,emscripten_set_timeout_loop:_emscripten_set_timeout_loop,emscripten_set_touchcancel_callback_on_thread:_emscripten_set_touchcancel_callback_on_thread,emscripten_set_touchend_callback_on_thread:_emscripten_set_touchend_callback_on_thread,emscripten_set_touchmove_callback_on_thread:_emscripten_set_touchmove_callback_on_thread,emscripten_set_touchstart_callback_on_thread:_emscripten_set_touchstart_callback_on_thread,emscripten_set_visibilitychange_callback_on_thread:_emscripten_set_visibilitychange_callback_on_thread,emscripten_set_webglcontextlost_callback_on_thread:_emscripten_set_webglcontextlost_callback_on_thread,emscripten_set_webglcontextrestored_callback_on_thread:_emscripten_set_webglcontextrestored_callback_on_thread,emscripten_set_wheel_callback_on_thread:_emscripten_set_wheel_callback_on_thread,emscripten_set_window_title:_emscripten_set_window_title,emscripten_stack_snapshot:_emscripten_stack_snapshot,emscripten_stack_unwind_buffer:_emscripten_stack_unwind_buffer,emscripten_supports_offscreencanvas:_emscripten_supports_offscreencanvas,emscripten_throw_number:_emscripten_throw_number,emscripten_throw_string:_emscripten_throw_string,emscripten_unlock_orientation:_emscripten_unlock_orientation,emscripten_unwind_to_js_event_loop:_emscripten_unwind_to_js_event_loop,emscripten_vibrate:_emscripten_vibrate,emscripten_vibrate_pattern:_emscripten_vibrate_pattern,emscripten_webgl_commit_frame:_emscripten_webgl_commit_frame,emscripten_webgl_create_context:_emscripten_webgl_create_context,emscripten_webgl_destroy_context:_emscripten_webgl_destroy_context,emscripten_webgl_do_commit_frame:_emscripten_webgl_do_commit_frame,emscripten_webgl_do_create_context:_emscripten_webgl_do_create_context,emscripten_webgl_do_get_current_context:_emscripten_webgl_do_get_current_context,emscripten_webgl_enable_ANGLE_instanced_arrays:_emscripten_webgl_enable_ANGLE_instanced_arrays,emscripten_webgl_enable_OES_vertex_array_object:_emscripten_webgl_enable_OES_vertex_array_object,emscripten_webgl_enable_WEBGL_draw_buffers:_emscripten_webgl_enable_WEBGL_draw_buffers,emscripten_webgl_enable_WEBGL_multi_draw:_emscripten_webgl_enable_WEBGL_multi_draw,emscripten_webgl_enable_extension:_emscripten_webgl_enable_extension,emscripten_webgl_get_context_attributes:_emscripten_webgl_get_context_attributes,emscripten_webgl_get_current_context:_emscripten_webgl_get_current_context,emscripten_webgl_get_drawing_buffer_size:_emscripten_webgl_get_drawing_buffer_size,emscripten_webgl_get_parameter_d:_emscripten_webgl_get_parameter_d,emscripten_webgl_get_parameter_i64v:_emscripten_webgl_get_parameter_i64v,emscripten_webgl_get_parameter_o:_emscripten_webgl_get_parameter_o,emscripten_webgl_get_parameter_utf8:_emscripten_webgl_get_parameter_utf8,emscripten_webgl_get_parameter_v:_emscripten_webgl_get_parameter_v,emscripten_webgl_get_program_info_log_utf8:_emscripten_webgl_get_program_info_log_utf8,emscripten_webgl_get_program_parameter_d:_emscripten_webgl_get_program_parameter_d,emscripten_webgl_get_shader_info_log_utf8:_emscripten_webgl_get_shader_info_log_utf8,emscripten_webgl_get_shader_parameter_d:_emscripten_webgl_get_shader_parameter_d,emscripten_webgl_get_shader_source_utf8:_emscripten_webgl_get_shader_source_utf8,emscripten_webgl_get_supported_extensions:_emscripten_webgl_get_supported_extensions,emscripten_webgl_get_uniform_d:_emscripten_webgl_get_uniform_d,emscripten_webgl_get_uniform_v:_emscripten_webgl_get_uniform_v,emscripten_webgl_get_vertex_attrib_d:_emscripten_webgl_get_vertex_attrib_d,emscripten_webgl_get_vertex_attrib_o:_emscripten_webgl_get_vertex_attrib_o,emscripten_webgl_get_vertex_attrib_v:_emscripten_webgl_get_vertex_attrib_v,emscripten_webgl_init_context_attributes:_emscripten_webgl_init_context_attributes,emscripten_webgl_make_context_current:_emscripten_webgl_make_context_current,emscripten_websocket_close:_emscripten_websocket_close,emscripten_websocket_deinitialize:_emscripten_websocket_deinitialize,emscripten_websocket_delete:_emscripten_websocket_delete,emscripten_websocket_get_buffered_amount:_emscripten_websocket_get_buffered_amount,emscripten_websocket_get_extensions:_emscripten_websocket_get_extensions,emscripten_websocket_get_extensions_length:_emscripten_websocket_get_extensions_length,emscripten_websocket_get_protocol:_emscripten_websocket_get_protocol,emscripten_websocket_get_protocol_length:_emscripten_websocket_get_protocol_length,emscripten_websocket_get_ready_state:_emscripten_websocket_get_ready_state,emscripten_websocket_get_url:_emscripten_websocket_get_url,emscripten_websocket_get_url_length:_emscripten_websocket_get_url_length,emscripten_websocket_is_supported:_emscripten_websocket_is_supported,emscripten_websocket_new:_emscripten_websocket_new,emscripten_websocket_send_binary:_emscripten_websocket_send_binary,emscripten_websocket_send_utf8_text:_emscripten_websocket_send_utf8_text,emscripten_websocket_set_onclose_callback_on_thread:_emscripten_websocket_set_onclose_callback_on_thread,emscripten_websocket_set_onerror_callback_on_thread:_emscripten_websocket_set_onerror_callback_on_thread,emscripten_websocket_set_onmessage_callback_on_thread:_emscripten_websocket_set_onmessage_callback_on_thread,emscripten_websocket_set_onopen_callback_on_thread:_emscripten_websocket_set_onopen_callback_on_thread,endprotoent:_endprotoent,environ_get:_environ_get,environ_sizes_get:_environ_sizes_get,exit:_exit,fail_test,fd_close:_fd_close,fd_fdstat_get:_fd_fdstat_get,fd_pread:_fd_pread,fd_pwrite:_fd_pwrite,fd_read:_fd_read,fd_seek:_fd_seek,fd_sync:_fd_sync,fd_write:_fd_write,ffi_call_js,ffi_closure_alloc_js,ffi_closure_free_js,ffi_prep_closure_loc_js,gc_register_proxies,get_async_js_call_done_callback,get_length_helper,get_length_string,getaddrinfo:_getaddrinfo,getentropy:_getentropy,gethostbyaddr:_gethostbyaddr,gethostbyname:_gethostbyname,gethostbyname_r:_gethostbyname_r,getnameinfo:_getnameinfo,getprotobyname:_getprotobyname,getprotobynumber:_getprotobynumber,getprotoent:_getprotoent,glActiveTexture:_glActiveTexture,glAttachShader:_glAttachShader,glBegin:_glBegin,glBeginQueryEXT:_glBeginQueryEXT,glBindAttribLocation:_glBindAttribLocation,glBindBuffer:_glBindBuffer,glBindFramebuffer:_glBindFramebuffer,glBindRenderbuffer:_glBindRenderbuffer,glBindTexture:_glBindTexture,glBindVertexArray:_glBindVertexArray,glBindVertexArrayOES:_glBindVertexArrayOES,glBlendColor:_glBlendColor,glBlendEquation:_glBlendEquation,glBlendEquationSeparate:_glBlendEquationSeparate,glBlendFunc:_glBlendFunc,glBlendFuncSeparate:_glBlendFuncSeparate,glBufferData:_glBufferData,glBufferSubData:_glBufferSubData,glCheckFramebufferStatus:_glCheckFramebufferStatus,glClear:_glClear,glClearColor:_glClearColor,glClearDepth:_glClearDepth,glClearDepthf:_glClearDepthf,glClearStencil:_glClearStencil,glColorMask:_glColorMask,glCompileShader:_glCompileShader,glCompressedTexImage2D:_glCompressedTexImage2D,glCompressedTexSubImage2D:_glCompressedTexSubImage2D,glCopyTexImage2D:_glCopyTexImage2D,glCopyTexSubImage2D:_glCopyTexSubImage2D,glCreateProgram:_glCreateProgram,glCreateShader:_glCreateShader,glCullFace:_glCullFace,glDeleteBuffers:_glDeleteBuffers,glDeleteFramebuffers:_glDeleteFramebuffers,glDeleteProgram:_glDeleteProgram,glDeleteQueriesEXT:_glDeleteQueriesEXT,glDeleteRenderbuffers:_glDeleteRenderbuffers,glDeleteShader:_glDeleteShader,glDeleteTextures:_glDeleteTextures,glDeleteVertexArrays:_glDeleteVertexArrays,glDeleteVertexArraysOES:_glDeleteVertexArraysOES,glDepthFunc:_glDepthFunc,glDepthMask:_glDepthMask,glDepthRange:_glDepthRange,glDepthRangef:_glDepthRangef,glDetachShader:_glDetachShader,glDisable:_glDisable,glDisableVertexAttribArray:_glDisableVertexAttribArray,glDrawArrays:_glDrawArrays,glDrawArraysInstanced:_glDrawArraysInstanced,glDrawArraysInstancedANGLE:_glDrawArraysInstancedANGLE,glDrawArraysInstancedARB:_glDrawArraysInstancedARB,glDrawArraysInstancedEXT:_glDrawArraysInstancedEXT,glDrawArraysInstancedNV:_glDrawArraysInstancedNV,glDrawBuffers:_glDrawBuffers,glDrawBuffersEXT:_glDrawBuffersEXT,glDrawBuffersWEBGL:_glDrawBuffersWEBGL,glDrawElements:_glDrawElements,glDrawElementsInstanced:_glDrawElementsInstanced,glDrawElementsInstancedANGLE:_glDrawElementsInstancedANGLE,glDrawElementsInstancedARB:_glDrawElementsInstancedARB,glDrawElementsInstancedEXT:_glDrawElementsInstancedEXT,glDrawElementsInstancedNV:_glDrawElementsInstancedNV,glEnable:_glEnable,glEnableVertexAttribArray:_glEnableVertexAttribArray,glEndQueryEXT:_glEndQueryEXT,glFinish:_glFinish,glFlush:_glFlush,glFramebufferRenderbuffer:_glFramebufferRenderbuffer,glFramebufferTexture2D:_glFramebufferTexture2D,glFrontFace:_glFrontFace,glGenBuffers:_glGenBuffers,glGenFramebuffers:_glGenFramebuffers,glGenQueriesEXT:_glGenQueriesEXT,glGenRenderbuffers:_glGenRenderbuffers,glGenTextures:_glGenTextures,glGenVertexArrays:_glGenVertexArrays,glGenVertexArraysOES:_glGenVertexArraysOES,glGenerateMipmap:_glGenerateMipmap,glGetActiveAttrib:_glGetActiveAttrib,glGetActiveUniform:_glGetActiveUniform,glGetAttachedShaders:_glGetAttachedShaders,glGetAttribLocation:_glGetAttribLocation,glGetBooleanv:_glGetBooleanv,glGetBufferParameteriv:_glGetBufferParameteriv,glGetError:_glGetError,glGetFloatv:_glGetFloatv,glGetFramebufferAttachmentParameteriv:_glGetFramebufferAttachmentParameteriv,glGetIntegerv:_glGetIntegerv,glGetProgramInfoLog:_glGetProgramInfoLog,glGetProgramiv:_glGetProgramiv,glGetQueryObjecti64vEXT:_glGetQueryObjecti64vEXT,glGetQueryObjectivEXT:_glGetQueryObjectivEXT,glGetQueryObjectui64vEXT:_glGetQueryObjectui64vEXT,glGetQueryObjectuivEXT:_glGetQueryObjectuivEXT,glGetQueryivEXT:_glGetQueryivEXT,glGetRenderbufferParameteriv:_glGetRenderbufferParameteriv,glGetShaderInfoLog:_glGetShaderInfoLog,glGetShaderPrecisionFormat:_glGetShaderPrecisionFormat,glGetShaderSource:_glGetShaderSource,glGetShaderiv:_glGetShaderiv,glGetString:_glGetString,glGetTexParameterfv:_glGetTexParameterfv,glGetTexParameteriv:_glGetTexParameteriv,glGetUniformLocation:_glGetUniformLocation,glGetUniformfv:_glGetUniformfv,glGetUniformiv:_glGetUniformiv,glGetVertexAttribPointerv:_glGetVertexAttribPointerv,glGetVertexAttribfv:_glGetVertexAttribfv,glGetVertexAttribiv:_glGetVertexAttribiv,glHint:_glHint,glIsBuffer:_glIsBuffer,glIsEnabled:_glIsEnabled,glIsFramebuffer:_glIsFramebuffer,glIsProgram:_glIsProgram,glIsQueryEXT:_glIsQueryEXT,glIsRenderbuffer:_glIsRenderbuffer,glIsShader:_glIsShader,glIsTexture:_glIsTexture,glIsVertexArray:_glIsVertexArray,glIsVertexArrayOES:_glIsVertexArrayOES,glLineWidth:_glLineWidth,glLinkProgram:_glLinkProgram,glLoadIdentity:_glLoadIdentity,glMatrixMode:_glMatrixMode,glMultiDrawArrays:_glMultiDrawArrays,glMultiDrawArraysANGLE:_glMultiDrawArraysANGLE,glMultiDrawArraysInstancedANGLE:_glMultiDrawArraysInstancedANGLE,glMultiDrawArraysInstancedWEBGL:_glMultiDrawArraysInstancedWEBGL,glMultiDrawArraysWEBGL:_glMultiDrawArraysWEBGL,glMultiDrawElements:_glMultiDrawElements,glMultiDrawElementsANGLE:_glMultiDrawElementsANGLE,glMultiDrawElementsInstancedANGLE:_glMultiDrawElementsInstancedANGLE,glMultiDrawElementsInstancedWEBGL:_glMultiDrawElementsInstancedWEBGL,glMultiDrawElementsWEBGL:_glMultiDrawElementsWEBGL,glPixelStorei:_glPixelStorei,glPolygonOffset:_glPolygonOffset,glQueryCounterEXT:_glQueryCounterEXT,glReadPixels:_glReadPixels,glReleaseShaderCompiler:_glReleaseShaderCompiler,glRenderbufferStorage:_glRenderbufferStorage,glSampleCoverage:_glSampleCoverage,glScissor:_glScissor,glShaderBinary:_glShaderBinary,glShaderSource:_glShaderSource,glStencilFunc:_glStencilFunc,glStencilFuncSeparate:_glStencilFuncSeparate,glStencilMask:_glStencilMask,glStencilMaskSeparate:_glStencilMaskSeparate,glStencilOp:_glStencilOp,glStencilOpSeparate:_glStencilOpSeparate,glTexImage2D:_glTexImage2D,glTexParameterf:_glTexParameterf,glTexParameterfv:_glTexParameterfv,glTexParameteri:_glTexParameteri,glTexParameteriv:_glTexParameteriv,glTexSubImage2D:_glTexSubImage2D,glUniform1f:_glUniform1f,glUniform1fv:_glUniform1fv,glUniform1i:_glUniform1i,glUniform1iv:_glUniform1iv,glUniform2f:_glUniform2f,glUniform2fv:_glUniform2fv,glUniform2i:_glUniform2i,glUniform2iv:_glUniform2iv,glUniform3f:_glUniform3f,glUniform3fv:_glUniform3fv,glUniform3i:_glUniform3i,glUniform3iv:_glUniform3iv,glUniform4f:_glUniform4f,glUniform4fv:_glUniform4fv,glUniform4i:_glUniform4i,glUniform4iv:_glUniform4iv,glUniformMatrix2fv:_glUniformMatrix2fv,glUniformMatrix3fv:_glUniformMatrix3fv,glUniformMatrix4fv:_glUniformMatrix4fv,glUseProgram:_glUseProgram,glValidateProgram:_glValidateProgram,glVertexAttrib1f:_glVertexAttrib1f,glVertexAttrib1fv:_glVertexAttrib1fv,glVertexAttrib2f:_glVertexAttrib2f,glVertexAttrib2fv:_glVertexAttrib2fv,glVertexAttrib3f:_glVertexAttrib3f,glVertexAttrib3fv:_glVertexAttrib3fv,glVertexAttrib4f:_glVertexAttrib4f,glVertexAttrib4fv:_glVertexAttrib4fv,glVertexAttribDivisor:_glVertexAttribDivisor,glVertexAttribDivisorANGLE:_glVertexAttribDivisorANGLE,glVertexAttribDivisorARB:_glVertexAttribDivisorARB,glVertexAttribDivisorEXT:_glVertexAttribDivisorEXT,glVertexAttribDivisorNV:_glVertexAttribDivisorNV,glVertexAttribPointer:_glVertexAttribPointer,glVertexPointer:_glVertexPointer,glViewport:_glViewport,handle_next_result_js,hiwire_invalid_ref,invoke_diii,invoke_fiii,invoke_i,invoke_ii,invoke_iii,invoke_iiii,invoke_iiiii,invoke_iiiiid,invoke_iiiiii,invoke_iiiiiii,invoke_iiiiiiii,invoke_iiiiiiiiiii,invoke_iiiiiiiiiiii,invoke_iiiiiiiiiiiii,invoke_iiiiij,invoke_iiiiijj,invoke_j,invoke_ji,invoke_jii,invoke_jiii,invoke_jiiii,invoke_v,invoke_vi,invoke_vii,invoke_viid,invoke_viif,invoke_viii,invoke_viiidi,invoke_viiifi,invoke_viiii,invoke_viiiii,invoke_viiiiii,invoke_viiiiiii,invoke_viiiiiiiiii,invoke_viiiiiiiiiiiiiii,invoke_viijii,invoke_viijj,is_comlink_proxy,js2python_convert,js2python_immutable_js,js2python_init,js2python_js,jslib_init_buffers_js,jslib_init_js,llvm_eh_typeid_for:_llvm_eh_typeid_for,memory:wasmMemory,new_error,proc_exit:_proc_exit,proxy_cache_get,proxy_cache_set,pyodide_js_init,pyproxy_AsPyObject,pyproxy_Check,pyproxy_new,pyproxy_new_ex,python2js__default_converter_js,python2js_buffer_init,python2js_custom__create_jscontext,random_get:_random_get,raw_call_js,setNetworkCallback:_setNetworkCallback,set_pyodide_module,setprotoent:_setprotoent,strftime:_strftime,strftime_l:_strftime_l,strptime:_strptime,strptime_l:_strptime_l,system:_system,throw_no_gil,wrap_async_generator,wrap_generator},wasmExports=createWasm(),___wasm_call_ctors=()=>(___wasm_call_ctors=wasmExports.__wasm_call_ctors)(),___wasm_apply_data_relocs=Module.___wasm_apply_data_relocs=()=>(___wasm_apply_data_relocs=Module.___wasm_apply_data_relocs=wasmExports.__wasm_apply_data_relocs)(),_set_method_docstring=Module._set_method_docstring=(t,e)=>(_set_method_docstring=Module._set_method_docstring=wasmExports.set_method_docstring)(t,e),_PyObject_GetAttrString=Module._PyObject_GetAttrString=(t,e)=>(_PyObject_GetAttrString=Module._PyObject_GetAttrString=wasmExports.PyObject_GetAttrString)(t,e),__PyUnicode_FromId=Module.__PyUnicode_FromId=t=>(__PyUnicode_FromId=Module.__PyUnicode_FromId=wasmExports._PyUnicode_FromId)(t),_PyObject_VectorcallMethod=Module._PyObject_VectorcallMethod=(t,e,n,_)=>(_PyObject_VectorcallMethod=Module._PyObject_VectorcallMethod=wasmExports.PyObject_VectorcallMethod)(t,e,n,_),_PyUnicode_AsUTF8AndSize=Module._PyUnicode_AsUTF8AndSize=(t,e)=>(_PyUnicode_AsUTF8AndSize=Module._PyUnicode_AsUTF8AndSize=wasmExports.PyUnicode_AsUTF8AndSize)(t,e),_malloc=t=>(_malloc=wasmExports.malloc)(t),_memcpy=(t,e,n)=>(_memcpy=wasmExports.memcpy)(t,e,n),__Py_Dealloc=Module.__Py_Dealloc=t=>(__Py_Dealloc=Module.__Py_Dealloc=wasmExports._Py_Dealloc)(t),_PyErr_Format=Module._PyErr_Format=(t,e,n)=>(_PyErr_Format=Module._PyErr_Format=wasmExports.PyErr_Format)(t,e,n),_add_methods_and_set_docstrings=Module._add_methods_and_set_docstrings=(t,e,n)=>(_add_methods_and_set_docstrings=Module._add_methods_and_set_docstrings=wasmExports.add_methods_and_set_docstrings)(t,e,n),_PyModule_AddFunctions=Module._PyModule_AddFunctions=(t,e)=>(_PyModule_AddFunctions=Module._PyModule_AddFunctions=wasmExports.PyModule_AddFunctions)(t,e),_docstring_init=Module._docstring_init=()=>(_docstring_init=Module._docstring_init=wasmExports.docstring_init)(),_PyImport_ImportModule=Module._PyImport_ImportModule=t=>(_PyImport_ImportModule=Module._PyImport_ImportModule=wasmExports.PyImport_ImportModule)(t),_dump_traceback=Module._dump_traceback=()=>(_dump_traceback=Module._dump_traceback=wasmExports.dump_traceback)(),_fileno=t=>(_fileno=wasmExports.fileno)(t),_PyGILState_GetThisThreadState=Module._PyGILState_GetThisThreadState=()=>(_PyGILState_GetThisThreadState=Module._PyGILState_GetThisThreadState=wasmExports.PyGILState_GetThisThreadState)(),__Py_DumpTraceback=Module.__Py_DumpTraceback=(t,e)=>(__Py_DumpTraceback=Module.__Py_DumpTraceback=wasmExports._Py_DumpTraceback)(t,e),_set_error=Module._set_error=t=>(_set_error=Module._set_error=wasmExports.set_error)(t),_PyErr_SetObject=Module._PyErr_SetObject=(t,e)=>(_PyErr_SetObject=Module._PyErr_SetObject=wasmExports.PyErr_SetObject)(t,e),_restore_sys_last_exception=Module._restore_sys_last_exception=t=>(_restore_sys_last_exception=Module._restore_sys_last_exception=wasmExports.restore_sys_last_exception)(t),_PySys_GetObject=Module._PySys_GetObject=t=>(_PySys_GetObject=Module._PySys_GetObject=wasmExports.PySys_GetObject)(t),_PyErr_Restore=Module._PyErr_Restore=(t,e,n)=>(_PyErr_Restore=Module._PyErr_Restore=wasmExports.PyErr_Restore)(t,e,n),_wrap_exception=Module._wrap_exception=()=>(_wrap_exception=Module._wrap_exception=wasmExports.wrap_exception)(),_PyErr_Fetch=Module._PyErr_Fetch=(t,e,n)=>(_PyErr_Fetch=Module._PyErr_Fetch=wasmExports.PyErr_Fetch)(t,e,n),_PyErr_NormalizeException=Module._PyErr_NormalizeException=(t,e,n)=>(_PyErr_NormalizeException=Module._PyErr_NormalizeException=wasmExports.PyErr_NormalizeException)(t,e,n),_PyErr_SetString=Module._PyErr_SetString=(t,e)=>(_PyErr_SetString=Module._PyErr_SetString=wasmExports.PyErr_SetString)(t,e),_PyException_SetTraceback=Module._PyException_SetTraceback=(t,e)=>(_PyException_SetTraceback=Module._PyException_SetTraceback=wasmExports.PyException_SetTraceback)(t,e),_PySys_SetObject=Module._PySys_SetObject=(t,e)=>(_PySys_SetObject=Module._PySys_SetObject=wasmExports.PySys_SetObject)(t,e),__PyObject_GetAttrId=Module.__PyObject_GetAttrId=(t,e)=>(__PyObject_GetAttrId=Module.__PyObject_GetAttrId=wasmExports._PyObject_GetAttrId)(t,e),_PyUnicode_AsUTF8=Module._PyUnicode_AsUTF8=t=>(_PyUnicode_AsUTF8=Module._PyUnicode_AsUTF8=wasmExports.PyUnicode_AsUTF8)(t),__PyObject_CallMethodIdObjArgs=Module.__PyObject_CallMethodIdObjArgs=(t,e,n)=>(__PyObject_CallMethodIdObjArgs=Module.__PyObject_CallMethodIdObjArgs=wasmExports._PyObject_CallMethodIdObjArgs)(t,e,n),_PyUnicode_New=Module._PyUnicode_New=(t,e)=>(_PyUnicode_New=Module._PyUnicode_New=wasmExports.PyUnicode_New)(t,e),_PyUnicode_Join=Module._PyUnicode_Join=(t,e)=>(_PyUnicode_Join=Module._PyUnicode_Join=wasmExports.PyUnicode_Join)(t,e),_JsvNull_Check=Module._JsvNull_Check=t=>(_JsvNull_Check=Module._JsvNull_Check=wasmExports.JsvNull_Check)(t),_PySys_WriteStderr=Module._PySys_WriteStderr=(t,e)=>(_PySys_WriteStderr=Module._PySys_WriteStderr=wasmExports.PySys_WriteStderr)(t,e),_PyErr_Print=Module._PyErr_Print=()=>(_PyErr_Print=Module._PyErr_Print=wasmExports.PyErr_Print)(),_PyErr_Display=Module._PyErr_Display=(t,e,n)=>(_PyErr_Display=Module._PyErr_Display=wasmExports.PyErr_Display)(t,e,n),_pythonexc2js=Module._pythonexc2js=()=>(_pythonexc2js=Module._pythonexc2js=wasmExports.pythonexc2js)(),_trigger_fatal_error=Module._trigger_fatal_error=(t,e)=>(_trigger_fatal_error=Module._trigger_fatal_error=wasmExports.trigger_fatal_error)(t,e),_raw_call=Module._raw_call=(t,e)=>(_raw_call=Module._raw_call=wasmExports.raw_call)(t,e),_JsProxy_Val=Module._JsProxy_Val=t=>(_JsProxy_Val=Module._JsProxy_Val=wasmExports.JsProxy_Val)(t),_error_handling_init=Module._error_handling_init=t=>(_error_handling_init=Module._error_handling_init=wasmExports.error_handling_init)(t),_hiwire_new_deduplicate=Module._hiwire_new_deduplicate=t=>(_hiwire_new_deduplicate=Module._hiwire_new_deduplicate=wasmExports.hiwire_new_deduplicate)(t),_hiwire_new=Module._hiwire_new=t=>(_hiwire_new=Module._hiwire_new=wasmExports.hiwire_new)(t),_hiwire_incref_deduplicate=Module._hiwire_incref_deduplicate=t=>(_hiwire_incref_deduplicate=Module._hiwire_incref_deduplicate=wasmExports.hiwire_incref_deduplicate)(t),_hiwire_decref=Module._hiwire_decref=t=>(_hiwire_decref=Module._hiwire_decref=wasmExports.hiwire_decref)(t),_PyInit__pyodide_core=Module._PyInit__pyodide_core=()=>(_PyInit__pyodide_core=Module._PyInit__pyodide_core=wasmExports.PyInit__pyodide_core)(),_PyErr_Occurred=Module._PyErr_Occurred=()=>(_PyErr_Occurred=Module._PyErr_Occurred=wasmExports.PyErr_Occurred)(),__PyErr_FormatFromCause=Module.__PyErr_FormatFromCause=(t,e,n)=>(__PyErr_FormatFromCause=Module.__PyErr_FormatFromCause=wasmExports._PyErr_FormatFromCause)(t,e,n),_PyModule_Create2=Module._PyModule_Create2=(t,e)=>(_PyModule_Create2=Module._PyModule_Create2=wasmExports.PyModule_Create2)(t,e),_jslib_init=Module._jslib_init=()=>(_jslib_init=Module._jslib_init=wasmExports.jslib_init)(),_python2js_init=Module._python2js_init=t=>(_python2js_init=Module._python2js_init=wasmExports.python2js_init)(t),_JsProxy_init=Module._JsProxy_init=t=>(_JsProxy_init=Module._JsProxy_init=wasmExports.JsProxy_init)(t),_pyproxy_init=Module._pyproxy_init=t=>(_pyproxy_init=Module._pyproxy_init=wasmExports.pyproxy_init)(t),_PyImport_GetModuleDict=Module._PyImport_GetModuleDict=()=>(_PyImport_GetModuleDict=Module._PyImport_GetModuleDict=wasmExports.PyImport_GetModuleDict)(),_PyDict_SetItemString=Module._PyDict_SetItemString=(t,e,n)=>(_PyDict_SetItemString=Module._PyDict_SetItemString=wasmExports.PyDict_SetItemString)(t,e,n),_python2js=Module._python2js=t=>(_python2js=Module._python2js=wasmExports.python2js)(t),_pyodide_export=Module._pyodide_export=()=>(_pyodide_export=Module._pyodide_export=wasmExports.pyodide_export)(),_py_version_major=Module._py_version_major=()=>(_py_version_major=Module._py_version_major=wasmExports.py_version_major)(),_set_new_cframe=Module._set_new_cframe=t=>(_set_new_cframe=Module._set_new_cframe=wasmExports.set_new_cframe)(t),_PyUnicode_Data=Module._PyUnicode_Data=t=>(_PyUnicode_Data=Module._PyUnicode_Data=wasmExports.PyUnicode_Data)(t),__js2python_none=Module.__js2python_none=()=>(__js2python_none=Module.__js2python_none=wasmExports._js2python_none)(),__js2python_true=Module.__js2python_true=()=>(__js2python_true=Module.__js2python_true=wasmExports._js2python_true)(),__js2python_false=Module.__js2python_false=()=>(__js2python_false=Module.__js2python_false=wasmExports._js2python_false)(),__js2python_pyproxy=Module.__js2python_pyproxy=t=>(__js2python_pyproxy=Module.__js2python_pyproxy=wasmExports._js2python_pyproxy)(t),_js2python_immutable=Module._js2python_immutable=t=>(_js2python_immutable=Module._js2python_immutable=wasmExports.js2python_immutable)(t),_js2python=Module._js2python=t=>(_js2python=Module._js2python=wasmExports.js2python)(t),_JsProxy_getflags=Module._JsProxy_getflags=t=>(_JsProxy_getflags=Module._JsProxy_getflags=wasmExports.JsProxy_getflags)(t),_PyLong_AsLong=Module._PyLong_AsLong=t=>(_PyLong_AsLong=Module._PyLong_AsLong=wasmExports.PyLong_AsLong)(t),_handle_next_result=Module._handle_next_result=(t,e,n)=>(_handle_next_result=Module._handle_next_result=wasmExports.handle_next_result)(t,e,n),_free=Module._free=t=>(_free=Module._free=wasmExports.free)(t),_JsProxy_create_with_type=Module._JsProxy_create_with_type=(t,e,n)=>(_JsProxy_create_with_type=Module._JsProxy_create_with_type=wasmExports.JsProxy_create_with_type)(t,e,n),_JsProxy_create_objmap=Module._JsProxy_create_objmap=(t,e)=>(_JsProxy_create_objmap=Module._JsProxy_create_objmap=wasmExports.JsProxy_create_objmap)(t,e),_JsProxy_am_send=Module._JsProxy_am_send=(t,e,n)=>(_JsProxy_am_send=Module._JsProxy_am_send=wasmExports.JsProxy_am_send)(t,e,n),_hiwire_get=Module._hiwire_get=t=>(_hiwire_get=Module._hiwire_get=wasmExports.hiwire_get)(t),_python2js_track_proxies=Module._python2js_track_proxies=(t,e,n)=>(_python2js_track_proxies=Module._python2js_track_proxies=wasmExports.python2js_track_proxies)(t,e,n),_JsvObject_CallMethodId_OneArg=Module._JsvObject_CallMethodId_OneArg=(t,e,n)=>(_JsvObject_CallMethodId_OneArg=Module._JsvObject_CallMethodId_OneArg=wasmExports.JsvObject_CallMethodId_OneArg)(t,e,n),_JsProxy_IterNext=Module._JsProxy_IterNext=t=>(_JsProxy_IterNext=Module._JsProxy_IterNext=wasmExports.JsProxy_IterNext)(t),__PyGen_SetStopIterationValue=Module.__PyGen_SetStopIterationValue=t=>(__PyGen_SetStopIterationValue=Module.__PyGen_SetStopIterationValue=wasmExports._PyGen_SetStopIterationValue)(t),_JsGenerator_send=Module._JsGenerator_send=(t,e)=>(_JsGenerator_send=Module._JsGenerator_send=wasmExports.JsGenerator_send)(t,e),_PyErr_SetNone=Module._PyErr_SetNone=t=>(_PyErr_SetNone=Module._PyErr_SetNone=wasmExports.PyErr_SetNone)(t),_JsException_js_error_getter=Module._JsException_js_error_getter=(t,e)=>(_JsException_js_error_getter=Module._JsException_js_error_getter=wasmExports.JsException_js_error_getter)(t,e),_process_throw_args=Module._process_throw_args=(t,e,n,_)=>(_process_throw_args=Module._process_throw_args=wasmExports.process_throw_args)(t,e,n,_),_PyException_GetTraceback=Module._PyException_GetTraceback=t=>(_PyException_GetTraceback=Module._PyException_GetTraceback=wasmExports.PyException_GetTraceback)(t),_PyErr_ExceptionMatches=Module._PyErr_ExceptionMatches=t=>(_PyErr_ExceptionMatches=Module._PyErr_ExceptionMatches=wasmExports.PyErr_ExceptionMatches)(t),_PyErr_Clear=Module._PyErr_Clear=()=>(_PyErr_Clear=Module._PyErr_Clear=wasmExports.PyErr_Clear)(),_JsvObject_CallMethodId_NoArgs=Module._JsvObject_CallMethodId_NoArgs=(t,e)=>(_JsvObject_CallMethodId_NoArgs=Module._JsvObject_CallMethodId_NoArgs=wasmExports.JsvObject_CallMethodId_NoArgs)(t,e),__agen_handle_result_js_c=Module.__agen_handle_result_js_c=(t,e,n,_,r)=>(__agen_handle_result_js_c=Module.__agen_handle_result_js_c=wasmExports._agen_handle_result_js_c)(t,e,n,_,r),_PyObject_CallOneArg=Module._PyObject_CallOneArg=(t,e)=>(_PyObject_CallOneArg=Module._PyObject_CallOneArg=wasmExports.PyObject_CallOneArg)(t,e),_PyErr_GivenExceptionMatches=Module._PyErr_GivenExceptionMatches=(t,e)=>(_PyErr_GivenExceptionMatches=Module._PyErr_GivenExceptionMatches=wasmExports.PyErr_GivenExceptionMatches)(t,e),__agen_handle_result=Module.__agen_handle_result=(t,e)=>(__agen_handle_result=Module.__agen_handle_result=wasmExports._agen_handle_result)(t,e),_PyObject_CallNoArgs=Module._PyObject_CallNoArgs=t=>(_PyObject_CallNoArgs=Module._PyObject_CallNoArgs=wasmExports.PyObject_CallNoArgs)(t),_JsArray_sq_item=Module._JsArray_sq_item=(t,e)=>(_JsArray_sq_item=Module._JsArray_sq_item=wasmExports.JsArray_sq_item)(t,e),_JsArray_sq_ass_item=Module._JsArray_sq_ass_item=(t,e,n)=>(_JsArray_sq_ass_item=Module._JsArray_sq_ass_item=wasmExports.JsArray_sq_ass_item)(t,e,n),_JsTypedArray_sq_ass_item=Module._JsTypedArray_sq_ass_item=(t,e,n)=>(_JsTypedArray_sq_ass_item=Module._JsTypedArray_sq_ass_item=wasmExports.JsTypedArray_sq_ass_item)(t,e,n),_JsMap_update=Module._JsMap_update=(t,e,n)=>(_JsMap_update=Module._JsMap_update=wasmExports.JsMap_update)(t,e,n),__PyArg_ParseTuple_SizeT=Module.__PyArg_ParseTuple_SizeT=(t,e,n)=>(__PyArg_ParseTuple_SizeT=Module.__PyArg_ParseTuple_SizeT=wasmExports._PyArg_ParseTuple_SizeT)(t,e,n),_JsProxy_syncify_not_supported=Module._JsProxy_syncify_not_supported=(t,e)=>(_JsProxy_syncify_not_supported=Module._JsProxy_syncify_not_supported=wasmExports.JsProxy_syncify_not_supported)(t,e),_JsProxy_syncify=Module._JsProxy_syncify=(t,e)=>(_JsProxy_syncify=Module._JsProxy_syncify=wasmExports.JsProxy_syncify)(t,e),_JsvPromise_Syncify=Module._JsvPromise_Syncify=t=>(_JsvPromise_Syncify=Module._JsvPromise_Syncify=wasmExports.JsvPromise_Syncify)(t),_JsMethod_ConvertArgs=Module._JsMethod_ConvertArgs=(t,e,n,_)=>(_JsMethod_ConvertArgs=Module._JsMethod_ConvertArgs=wasmExports.JsMethod_ConvertArgs)(t,e,n,_),_PyTuple_GetItem=Module._PyTuple_GetItem=(t,e)=>(_PyTuple_GetItem=Module._PyTuple_GetItem=wasmExports.PyTuple_GetItem)(t,e),_PyTuple_Size=Module._PyTuple_Size=t=>(_PyTuple_Size=Module._PyTuple_Size=wasmExports.PyTuple_Size)(t),_Buffer_dealloc=Module._Buffer_dealloc=t=>(_Buffer_dealloc=Module._Buffer_dealloc=wasmExports.Buffer_dealloc)(t),_PyMem_Free=Module._PyMem_Free=t=>(_PyMem_Free=Module._PyMem_Free=wasmExports.PyMem_Free)(t),_JsBuffer_CopyIntoMemoryView=Module._JsBuffer_CopyIntoMemoryView=(t,e,n,_)=>(_JsBuffer_CopyIntoMemoryView=Module._JsBuffer_CopyIntoMemoryView=wasmExports.JsBuffer_CopyIntoMemoryView)(t,e,n,_),_PyMem_Malloc=Module._PyMem_Malloc=t=>(_PyMem_Malloc=Module._PyMem_Malloc=wasmExports.PyMem_Malloc)(t),_PyMemoryView_FromObject=Module._PyMemoryView_FromObject=t=>(_PyMemoryView_FromObject=Module._PyMemoryView_FromObject=wasmExports.PyMemoryView_FromObject)(t),_JsBuffer_cinit=Module._JsBuffer_cinit=t=>(_JsBuffer_cinit=Module._JsBuffer_cinit=wasmExports.JsBuffer_cinit)(t),_JsRef_new=Module._JsRef_new=t=>(_JsRef_new=Module._JsRef_new=wasmExports.JsRef_new)(t),_PyTuple_Pack=Module._PyTuple_Pack=(t,e)=>(_PyTuple_Pack=Module._PyTuple_Pack=wasmExports.PyTuple_Pack)(t,e),_PyLong_FromLong=Module._PyLong_FromLong=t=>(_PyLong_FromLong=Module._PyLong_FromLong=wasmExports.PyLong_FromLong)(t),_PyDict_GetItemWithError=Module._PyDict_GetItemWithError=(t,e)=>(_PyDict_GetItemWithError=Module._PyDict_GetItemWithError=wasmExports.PyDict_GetItemWithError)(t,e),_PyObject_SelfIter=Module._PyObject_SelfIter=t=>(_PyObject_SelfIter=Module._PyObject_SelfIter=wasmExports.PyObject_SelfIter)(t),_PyVectorcall_Call=Module._PyVectorcall_Call=(t,e,n)=>(_PyVectorcall_Call=Module._PyVectorcall_Call=wasmExports.PyVectorcall_Call)(t,e,n),_PyErr_NoMemory=Module._PyErr_NoMemory=()=>(_PyErr_NoMemory=Module._PyErr_NoMemory=wasmExports.PyErr_NoMemory)(),_PyType_FromSpecWithBases=Module._PyType_FromSpecWithBases=(t,e)=>(_PyType_FromSpecWithBases=Module._PyType_FromSpecWithBases=wasmExports.PyType_FromSpecWithBases)(t,e),__PyObject_SetAttrId=Module.__PyObject_SetAttrId=(t,e,n)=>(__PyObject_SetAttrId=Module.__PyObject_SetAttrId=wasmExports._PyObject_SetAttrId)(t,e,n),_PyDict_SetItem=Module._PyDict_SetItem=(t,e,n)=>(_PyDict_SetItem=Module._PyDict_SetItem=wasmExports.PyDict_SetItem)(t,e,n),_JsProxy_create_with_this=Module._JsProxy_create_with_this=(t,e)=>(_JsProxy_create_with_this=Module._JsProxy_create_with_this=wasmExports.JsProxy_create_with_this)(t,e),_JsProxy_create=Module._JsProxy_create=t=>(_JsProxy_create=Module._JsProxy_create=wasmExports.JsProxy_create)(t),_JsProxy_Check=Module._JsProxy_Check=t=>(_JsProxy_Check=Module._JsProxy_Check=wasmExports.JsProxy_Check)(t),_PyType_IsSubtype=Module._PyType_IsSubtype=(t,e)=>(_PyType_IsSubtype=Module._PyType_IsSubtype=wasmExports.PyType_IsSubtype)(t,e),_JsProxy_init_docstrings=Module._JsProxy_init_docstrings=()=>(_JsProxy_init_docstrings=Module._JsProxy_init_docstrings=wasmExports.JsProxy_init_docstrings)(),_PyDict_New=Module._PyDict_New=()=>(_PyDict_New=Module._PyDict_New=wasmExports.PyDict_New)(),_PyObject_SetAttrString=Module._PyObject_SetAttrString=(t,e,n)=>(_PyObject_SetAttrString=Module._PyObject_SetAttrString=wasmExports.PyObject_SetAttrString)(t,e,n),_PyModule_AddObject=Module._PyModule_AddObject=(t,e,n)=>(_PyModule_AddObject=Module._PyModule_AddObject=wasmExports.PyModule_AddObject)(t,e,n),_PyType_Ready=Module._PyType_Ready=t=>(_PyType_Ready=Module._PyType_Ready=wasmExports.PyType_Ready)(t),_JsvObject_CallMethodId_TwoArgs=Module._JsvObject_CallMethodId_TwoArgs=(t,e,n,_)=>(_JsvObject_CallMethodId_TwoArgs=Module._JsvObject_CallMethodId_TwoArgs=wasmExports.JsvObject_CallMethodId_TwoArgs)(t,e,n,_),_PyObject_Repr=Module._PyObject_Repr=t=>(_PyObject_Repr=Module._PyObject_Repr=wasmExports.PyObject_Repr)(t),_PyIndex_Check=Module._PyIndex_Check=t=>(_PyIndex_Check=Module._PyIndex_Check=wasmExports.PyIndex_Check)(t),_PyNumber_AsSsize_t=Module._PyNumber_AsSsize_t=(t,e)=>(_PyNumber_AsSsize_t=Module._PyNumber_AsSsize_t=wasmExports.PyNumber_AsSsize_t)(t,e),_PySlice_Unpack=Module._PySlice_Unpack=(t,e,n,_)=>(_PySlice_Unpack=Module._PySlice_Unpack=wasmExports.PySlice_Unpack)(t,e,n,_),_PySlice_AdjustIndices=Module._PySlice_AdjustIndices=(t,e,n,_)=>(_PySlice_AdjustIndices=Module._PySlice_AdjustIndices=wasmExports.PySlice_AdjustIndices)(t,e,n,_),_PySequence_Fast=Module._PySequence_Fast=(t,e)=>(_PySequence_Fast=Module._PySequence_Fast=wasmExports.PySequence_Fast)(t,e),__PyArg_ParseTupleAndKeywords_SizeT=Module.__PyArg_ParseTupleAndKeywords_SizeT=(t,e,n,_,r)=>(__PyArg_ParseTupleAndKeywords_SizeT=Module.__PyArg_ParseTupleAndKeywords_SizeT=wasmExports._PyArg_ParseTupleAndKeywords_SizeT)(t,e,n,_,r),_PySet_New=Module._PySet_New=t=>(_PySet_New=Module._PySet_New=wasmExports.PySet_New)(t),__PySet_Update=Module.__PySet_Update=(t,e)=>(__PySet_Update=Module.__PySet_Update=wasmExports._PySet_Update)(t,e),_PyUnicode_FromString=Module._PyUnicode_FromString=t=>(_PyUnicode_FromString=Module._PyUnicode_FromString=wasmExports.PyUnicode_FromString)(t),_PySet_Discard=Module._PySet_Discard=(t,e)=>(_PySet_Discard=Module._PySet_Discard=wasmExports.PySet_Discard)(t,e),_PyList_New=Module._PyList_New=t=>(_PyList_New=Module._PyList_New=wasmExports.PyList_New)(t),__PyList_Extend=Module.__PyList_Extend=(t,e)=>(__PyList_Extend=Module.__PyList_Extend=wasmExports._PyList_Extend)(t,e),_PyList_Sort=Module._PyList_Sort=t=>(_PyList_Sort=Module._PyList_Sort=wasmExports.PyList_Sort)(t),__PyArg_ParseStack_SizeT=Module.__PyArg_ParseStack_SizeT=(t,e,n,_)=>(__PyArg_ParseStack_SizeT=Module.__PyArg_ParseStack_SizeT=wasmExports._PyArg_ParseStack_SizeT)(t,e,n,_),_JsvObject_CallMethodId=Module._JsvObject_CallMethodId=(t,e,n)=>(_JsvObject_CallMethodId=Module._JsvObject_CallMethodId=wasmExports.JsvObject_CallMethodId)(t,e,n),_PyObject_GetIter=Module._PyObject_GetIter=t=>(_PyObject_GetIter=Module._PyObject_GetIter=wasmExports.PyObject_GetIter)(t),_PyObject_RichCompareBool=Module._PyObject_RichCompareBool=(t,e,n)=>(_PyObject_RichCompareBool=Module._PyObject_RichCompareBool=wasmExports.PyObject_RichCompareBool)(t,e,n),__PyArg_ParseStackAndKeywords_SizeT=Module.__PyArg_ParseStackAndKeywords_SizeT=(t,e,n,_,r)=>(__PyArg_ParseStackAndKeywords_SizeT=Module.__PyArg_ParseStackAndKeywords_SizeT=wasmExports._PyArg_ParseStackAndKeywords_SizeT)(t,e,n,_,r),_JsRef_toVal=Module._JsRef_toVal=t=>(_JsRef_toVal=Module._JsRef_toVal=wasmExports.JsRef_toVal)(t),_Py_EnterRecursiveCall=Module._Py_EnterRecursiveCall=t=>(_Py_EnterRecursiveCall=Module._Py_EnterRecursiveCall=wasmExports.Py_EnterRecursiveCall)(t),_Py_LeaveRecursiveCall=Module._Py_LeaveRecursiveCall=()=>(_Py_LeaveRecursiveCall=Module._Py_LeaveRecursiveCall=wasmExports.Py_LeaveRecursiveCall)(),_hiwire_pop=Module._hiwire_pop=t=>(_hiwire_pop=Module._hiwire_pop=wasmExports.hiwire_pop)(t),_puts=Module._puts=t=>(_puts=Module._puts=wasmExports.puts)(t),_PyObject_GenericGetAttr=Module._PyObject_GenericGetAttr=(t,e)=>(_PyObject_GenericGetAttr=Module._PyObject_GenericGetAttr=wasmExports.PyObject_GenericGetAttr)(t,e),_strcmp=Module._strcmp=(t,e)=>(_strcmp=Module._strcmp=wasmExports.strcmp)(t,e),_strncmp=Module._strncmp=(t,e,n)=>(_strncmp=Module._strncmp=wasmExports.strncmp)(t,e,n),_PyObject_GenericSetAttr=Module._PyObject_GenericSetAttr=(t,e,n)=>(_PyObject_GenericSetAttr=Module._PyObject_GenericSetAttr=wasmExports.PyObject_GenericSetAttr)(t,e,n),__Py_HashBytes=Module.__Py_HashBytes=(t,e)=>(__Py_HashBytes=Module.__Py_HashBytes=wasmExports._Py_HashBytes)(t,e),__PyArg_CheckPositional=Module.__PyArg_CheckPositional=(t,e,n,_)=>(__PyArg_CheckPositional=Module.__PyArg_CheckPositional=wasmExports._PyArg_CheckPositional)(t,e,n,_),__PyNumber_Index=Module.__PyNumber_Index=t=>(__PyNumber_Index=Module.__PyNumber_Index=wasmExports._PyNumber_Index)(t),_PyLong_AsSsize_t=Module._PyLong_AsSsize_t=t=>(_PyLong_AsSsize_t=Module._PyLong_AsSsize_t=wasmExports.PyLong_AsSsize_t)(t),_PyLong_FromSsize_t=Module._PyLong_FromSsize_t=t=>(_PyLong_FromSsize_t=Module._PyLong_FromSsize_t=wasmExports.PyLong_FromSsize_t)(t),_PyObject_GetItem=Module._PyObject_GetItem=(t,e)=>(_PyObject_GetItem=Module._PyObject_GetItem=wasmExports.PyObject_GetItem)(t,e),_PyObject_DelItem=Module._PyObject_DelItem=(t,e)=>(_PyObject_DelItem=Module._PyObject_DelItem=wasmExports.PyObject_DelItem)(t,e),_PyObject_SetItem=Module._PyObject_SetItem=(t,e,n)=>(_PyObject_SetItem=Module._PyObject_SetItem=wasmExports.PyObject_SetItem)(t,e,n),_PyObject_GetBuffer=Module._PyObject_GetBuffer=(t,e,n)=>(_PyObject_GetBuffer=Module._PyObject_GetBuffer=wasmExports.PyObject_GetBuffer)(t,e,n),_PyBuffer_Release=Module._PyBuffer_Release=t=>(_PyBuffer_Release=Module._PyBuffer_Release=wasmExports.PyBuffer_Release)(t),_PyBytes_FromStringAndSize=Module._PyBytes_FromStringAndSize=(t,e)=>(_PyBytes_FromStringAndSize=Module._PyBytes_FromStringAndSize=wasmExports.PyBytes_FromStringAndSize)(t,e),_check_gil=Module._check_gil=()=>(_check_gil=Module._check_gil=wasmExports.check_gil)(),_PyGILState_Check=Module._PyGILState_Check=()=>(_PyGILState_Check=Module._PyGILState_Check=wasmExports.PyGILState_Check)(),_pyproxy_getflags=Module._pyproxy_getflags=t=>(_pyproxy_getflags=Module._pyproxy_getflags=wasmExports.pyproxy_getflags)(t),_PyObject_HasAttr=Module._PyObject_HasAttr=(t,e)=>(_PyObject_HasAttr=Module._PyObject_HasAttr=wasmExports.PyObject_HasAttr)(t,e),__PyObject_NextNotImplemented=Module.__PyObject_NextNotImplemented=t=>(__PyObject_NextNotImplemented=Module.__PyObject_NextNotImplemented=wasmExports._PyObject_NextNotImplemented)(t),_PyObject_IsSubclass=Module._PyObject_IsSubclass=(t,e)=>(_PyObject_IsSubclass=Module._PyObject_IsSubclass=wasmExports.PyObject_IsSubclass)(t,e),__pyproxy_repr=Module.__pyproxy_repr=t=>(__pyproxy_repr=Module.__pyproxy_repr=wasmExports._pyproxy_repr)(t),_PyObject_Str=Module._PyObject_Str=t=>(_PyObject_Str=Module._PyObject_Str=wasmExports.PyObject_Str)(t),__pyproxy_type=Module.__pyproxy_type=t=>(__pyproxy_type=Module.__pyproxy_type=wasmExports._pyproxy_type)(t),__pyproxy_hasattr=Module.__pyproxy_hasattr=(t,e)=>(__pyproxy_hasattr=Module.__pyproxy_hasattr=wasmExports._pyproxy_hasattr)(t,e),__pyproxy_getattr=Module.__pyproxy_getattr=(t,e,n)=>(__pyproxy_getattr=Module.__pyproxy_getattr=wasmExports._pyproxy_getattr)(t,e,n),__PyObject_GetMethod=Module.__PyObject_GetMethod=(t,e,n)=>(__PyObject_GetMethod=Module.__PyObject_GetMethod=wasmExports._PyObject_GetMethod)(t,e,n),__pyproxy_setattr=Module.__pyproxy_setattr=(t,e,n)=>(__pyproxy_setattr=Module.__pyproxy_setattr=wasmExports._pyproxy_setattr)(t,e,n),_PyObject_SetAttr=Module._PyObject_SetAttr=(t,e,n)=>(_PyObject_SetAttr=Module._PyObject_SetAttr=wasmExports.PyObject_SetAttr)(t,e,n),__pyproxy_delattr=Module.__pyproxy_delattr=(t,e)=>(__pyproxy_delattr=Module.__pyproxy_delattr=wasmExports._pyproxy_delattr)(t,e),__pyproxy_getitem=Module.__pyproxy_getitem=(t,e)=>(__pyproxy_getitem=Module.__pyproxy_getitem=wasmExports._pyproxy_getitem)(t,e),__pyproxy_setitem=Module.__pyproxy_setitem=(t,e,n)=>(__pyproxy_setitem=Module.__pyproxy_setitem=wasmExports._pyproxy_setitem)(t,e,n),__pyproxy_delitem=Module.__pyproxy_delitem=(t,e)=>(__pyproxy_delitem=Module.__pyproxy_delitem=wasmExports._pyproxy_delitem)(t,e),__pyproxy_slice_assign=Module.__pyproxy_slice_assign=(t,e,n,_)=>(__pyproxy_slice_assign=Module.__pyproxy_slice_assign=wasmExports._pyproxy_slice_assign)(t,e,n,_),_PySequence_Size=Module._PySequence_Size=t=>(_PySequence_Size=Module._PySequence_Size=wasmExports.PySequence_Size)(t),_PySequence_GetSlice=Module._PySequence_GetSlice=(t,e,n)=>(_PySequence_GetSlice=Module._PySequence_GetSlice=wasmExports.PySequence_GetSlice)(t,e,n),_PySequence_SetSlice=Module._PySequence_SetSlice=(t,e,n,_)=>(_PySequence_SetSlice=Module._PySequence_SetSlice=wasmExports.PySequence_SetSlice)(t,e,n,_),_python2js_with_depth=Module._python2js_with_depth=(t,e,n)=>(_python2js_with_depth=Module._python2js_with_depth=wasmExports.python2js_with_depth)(t,e,n),__pyproxy_pop=Module.__pyproxy_pop=(t,e)=>(__pyproxy_pop=Module.__pyproxy_pop=wasmExports._pyproxy_pop)(t,e),__pyproxy_contains=Module.__pyproxy_contains=(t,e)=>(__pyproxy_contains=Module.__pyproxy_contains=wasmExports._pyproxy_contains)(t,e),_PySequence_Contains=Module._PySequence_Contains=(t,e)=>(_PySequence_Contains=Module._PySequence_Contains=wasmExports.PySequence_Contains)(t,e),__pyproxy_ownKeys=Module.__pyproxy_ownKeys=t=>(__pyproxy_ownKeys=Module.__pyproxy_ownKeys=wasmExports._pyproxy_ownKeys)(t),_PyObject_Dir=Module._PyObject_Dir=t=>(_PyObject_Dir=Module._PyObject_Dir=wasmExports.PyObject_Dir)(t),_PyList_Size=Module._PyList_Size=t=>(_PyList_Size=Module._PyList_Size=wasmExports.PyList_Size)(t),_PyList_GetItem=Module._PyList_GetItem=(t,e)=>(_PyList_GetItem=Module._PyList_GetItem=wasmExports.PyList_GetItem)(t,e),__pyproxy_apply=Module.__pyproxy_apply=(t,e,n,_,r)=>(__pyproxy_apply=Module.__pyproxy_apply=wasmExports._pyproxy_apply)(t,e,n,_,r),_PyTuple_New=Module._PyTuple_New=t=>(_PyTuple_New=Module._PyTuple_New=wasmExports.PyTuple_New)(t),_PyObject_Vectorcall=Module._PyObject_Vectorcall=(t,e,n,_)=>(_PyObject_Vectorcall=Module._PyObject_Vectorcall=wasmExports.PyObject_Vectorcall)(t,e,n,_),__iscoroutinefunction=Module.__iscoroutinefunction=t=>(__iscoroutinefunction=Module.__iscoroutinefunction=wasmExports._iscoroutinefunction)(t),__pyproxy_iter_next=Module.__pyproxy_iter_next=t=>(__pyproxy_iter_next=Module.__pyproxy_iter_next=wasmExports._pyproxy_iter_next)(t),_PyIter_Next=Module._PyIter_Next=t=>(_PyIter_Next=Module._PyIter_Next=wasmExports.PyIter_Next)(t),__pyproxyGen_Send=Module.__pyproxyGen_Send=(t,e)=>(__pyproxyGen_Send=Module.__pyproxyGen_Send=wasmExports._pyproxyGen_Send)(t,e),_PyIter_Send=Module._PyIter_Send=(t,e,n)=>(_PyIter_Send=Module._PyIter_Send=wasmExports.PyIter_Send)(t,e,n),__pyproxyGen_return=Module.__pyproxyGen_return=(t,e)=>(__pyproxyGen_return=Module.__pyproxyGen_return=wasmExports._pyproxyGen_return)(t,e),__PyGen_FetchStopIterationValue=Module.__PyGen_FetchStopIterationValue=t=>(__PyGen_FetchStopIterationValue=Module.__PyGen_FetchStopIterationValue=wasmExports._PyGen_FetchStopIterationValue)(t),__pyproxyGen_throw=Module.__pyproxyGen_throw=(t,e)=>(__pyproxyGen_throw=Module.__pyproxyGen_throw=wasmExports._pyproxyGen_throw)(t,e),__pyproxyGen_asend=Module.__pyproxyGen_asend=(t,e)=>(__pyproxyGen_asend=Module.__pyproxyGen_asend=wasmExports._pyproxyGen_asend)(t,e),__pyproxyGen_areturn=Module.__pyproxyGen_areturn=t=>(__pyproxyGen_areturn=Module.__pyproxyGen_areturn=wasmExports._pyproxyGen_areturn)(t),__pyproxyGen_athrow=Module.__pyproxyGen_athrow=(t,e)=>(__pyproxyGen_athrow=Module.__pyproxyGen_athrow=wasmExports._pyproxyGen_athrow)(t,e),__pyproxy_aiter_next=Module.__pyproxy_aiter_next=t=>(__pyproxy_aiter_next=Module.__pyproxy_aiter_next=wasmExports._pyproxy_aiter_next)(t),_FutureDoneCallback_call_resolve=Module._FutureDoneCallback_call_resolve=(t,e)=>(_FutureDoneCallback_call_resolve=Module._FutureDoneCallback_call_resolve=wasmExports.FutureDoneCallback_call_resolve)(t,e),_FutureDoneCallback_call_reject=Module._FutureDoneCallback_call_reject=t=>(_FutureDoneCallback_call_reject=Module._FutureDoneCallback_call_reject=wasmExports.FutureDoneCallback_call_reject)(t),_FutureDoneCallback_call=Module._FutureDoneCallback_call=(t,e,n)=>(_FutureDoneCallback_call=Module._FutureDoneCallback_call=wasmExports.FutureDoneCallback_call)(t,e,n),_PyArg_UnpackTuple=Module._PyArg_UnpackTuple=(t,e,n,_,r)=>(_PyArg_UnpackTuple=Module._PyArg_UnpackTuple=wasmExports.PyArg_UnpackTuple)(t,e,n,_,r),__pyproxy_ensure_future=Module.__pyproxy_ensure_future=(t,e,n)=>(__pyproxy_ensure_future=Module.__pyproxy_ensure_future=wasmExports._pyproxy_ensure_future)(t,e,n),__pyproxy_get_buffer=Module.__pyproxy_get_buffer=t=>(__pyproxy_get_buffer=Module.__pyproxy_get_buffer=wasmExports._pyproxy_get_buffer)(t),_PyBuffer_FillContiguousStrides=Module._PyBuffer_FillContiguousStrides=(t,e,n,_,r)=>(_PyBuffer_FillContiguousStrides=Module._PyBuffer_FillContiguousStrides=wasmExports.PyBuffer_FillContiguousStrides)(t,e,n,_,r),_PyBuffer_IsContiguous=Module._PyBuffer_IsContiguous=(t,e)=>(_PyBuffer_IsContiguous=Module._PyBuffer_IsContiguous=wasmExports.PyBuffer_IsContiguous)(t,e),__python2js_buffer=Module.__python2js_buffer=t=>(__python2js_buffer=Module.__python2js_buffer=wasmExports._python2js_buffer)(t),_jslib_init_buffers=Module._jslib_init_buffers=()=>(_jslib_init_buffers=Module._jslib_init_buffers=wasmExports.jslib_init_buffers)(),_JsRef_pop=Module._JsRef_pop=t=>(_JsRef_pop=Module._JsRef_pop=wasmExports.JsRef_pop)(t),_JsrString_FromId=Module._JsrString_FromId=t=>(_JsrString_FromId=Module._JsrString_FromId=wasmExports.JsrString_FromId)(t),_hiwire_intern=Module._hiwire_intern=t=>(_hiwire_intern=Module._hiwire_intern=wasmExports.hiwire_intern)(t),_JsvString_FromId=Module._JsvString_FromId=t=>(_JsvString_FromId=Module._JsvString_FromId=wasmExports.JsvString_FromId)(t),__python2js=Module.__python2js=(t,e)=>(__python2js=Module.__python2js=wasmExports._python2js)(t,e),_python2js_inner=Module._python2js_inner=(t,e,n,_)=>(_python2js_inner=Module._python2js_inner=wasmExports.python2js_inner)(t,e,n,_),_PySequence_GetItem=Module._PySequence_GetItem=(t,e)=>(_PySequence_GetItem=Module._PySequence_GetItem=wasmExports.PySequence_GetItem)(t,e),_PyDict_Next=Module._PyDict_Next=(t,e,n,_)=>(_PyDict_Next=Module._PyDict_Next=wasmExports.PyDict_Next)(t,e,n,_),_PyObject_CheckBuffer=Module._PyObject_CheckBuffer=t=>(_PyObject_CheckBuffer=Module._PyObject_CheckBuffer=wasmExports.PyObject_CheckBuffer)(t),_PyFloat_AsDouble=Module._PyFloat_AsDouble=t=>(_PyFloat_AsDouble=Module._PyFloat_AsDouble=wasmExports.PyFloat_AsDouble)(t),_python2js__default_converter=Module._python2js__default_converter=(t,e)=>(_python2js__default_converter=Module._python2js__default_converter=wasmExports.python2js__default_converter)(t,e),_python2js_custom=Module._python2js_custom=(t,e,n,_,r)=>(_python2js_custom=Module._python2js_custom=wasmExports.python2js_custom)(t,e,n,_,r),_PyLong_AsLongAndOverflow=Module._PyLong_AsLongAndOverflow=(t,e)=>(_PyLong_AsLongAndOverflow=Module._PyLong_AsLongAndOverflow=wasmExports.PyLong_AsLongAndOverflow)(t,e),__PyLong_NumBits=Module.__PyLong_NumBits=t=>(__PyLong_NumBits=Module.__PyLong_NumBits=wasmExports._PyLong_NumBits)(t),__PyLong_AsByteArray=Module.__PyLong_AsByteArray=(t,e,n,_,r)=>(__PyLong_AsByteArray=Module.__PyLong_AsByteArray=wasmExports._PyLong_AsByteArray)(t,e,n,_,r),_py_version_minor=Module._py_version_minor=()=>(_py_version_minor=Module._py_version_minor=wasmExports.py_version_minor)(),_py_version_micro=Module._py_version_micro=()=>(_py_version_micro=Module._py_version_micro=wasmExports.py_version_micro)(),_saveExceptionState=Module._saveExceptionState=(t,e)=>(_saveExceptionState=Module._saveExceptionState=wasmExports.saveExceptionState)(t,e),_restoreExceptionState=Module._restoreExceptionState=(t,e)=>(_restoreExceptionState=Module._restoreExceptionState=wasmExports.restoreExceptionState)(t,e),_savePythonState=Module._savePythonState=(t,e)=>(_savePythonState=Module._savePythonState=wasmExports.savePythonState)(t,e),_PyThreadState_GetFrame=Module._PyThreadState_GetFrame=t=>(_PyThreadState_GetFrame=Module._PyThreadState_GetFrame=wasmExports.PyThreadState_GetFrame)(t),_restorePythonState=Module._restorePythonState=(t,e)=>(_restorePythonState=Module._restorePythonState=wasmExports.restorePythonState)(t,e),_captureThreadState=Module._captureThreadState=()=>(_captureThreadState=Module._captureThreadState=wasmExports.captureThreadState)(),_PyThreadState_Get=Module._PyThreadState_Get=()=>(_PyThreadState_Get=Module._PyThreadState_Get=wasmExports.PyThreadState_Get)(),_restoreThreadState=Module._restoreThreadState=t=>(_restoreThreadState=Module._restoreThreadState=wasmExports.restoreThreadState)(t),_get_cframe=Module._get_cframe=()=>(_get_cframe=Module._get_cframe=wasmExports.get_cframe)(),_restore_cframe=Module._restore_cframe=t=>(_restore_cframe=Module._restore_cframe=wasmExports.restore_cframe)(t),_main=Module._main=(t,e)=>(_main=Module._main=wasmExports.__main_argc_argv)(t,e),_PyImport_AppendInittab=Module._PyImport_AppendInittab=(t,e)=>(_PyImport_AppendInittab=Module._PyImport_AppendInittab=wasmExports.PyImport_AppendInittab)(t,e),_PyPreConfig_InitPythonConfig=Module._PyPreConfig_InitPythonConfig=t=>(_PyPreConfig_InitPythonConfig=Module._PyPreConfig_InitPythonConfig=wasmExports.PyPreConfig_InitPythonConfig)(t),_Py_PreInitializeFromBytesArgs=Module._Py_PreInitializeFromBytesArgs=(t,e,n,_)=>(_Py_PreInitializeFromBytesArgs=Module._Py_PreInitializeFromBytesArgs=wasmExports.Py_PreInitializeFromBytesArgs)(t,e,n,_),_PyStatus_Exception=Module._PyStatus_Exception=t=>(_PyStatus_Exception=Module._PyStatus_Exception=wasmExports.PyStatus_Exception)(t),_PyConfig_InitPythonConfig=Module._PyConfig_InitPythonConfig=t=>(_PyConfig_InitPythonConfig=Module._PyConfig_InitPythonConfig=wasmExports.PyConfig_InitPythonConfig)(t),_PyConfig_SetBytesArgv=Module._PyConfig_SetBytesArgv=(t,e,n,_)=>(_PyConfig_SetBytesArgv=Module._PyConfig_SetBytesArgv=wasmExports.PyConfig_SetBytesArgv)(t,e,n,_),_PyConfig_SetBytesString=Module._PyConfig_SetBytesString=(t,e,n,_)=>(_PyConfig_SetBytesString=Module._PyConfig_SetBytesString=wasmExports.PyConfig_SetBytesString)(t,e,n,_),_Py_InitializeFromConfig=Module._Py_InitializeFromConfig=(t,e)=>(_Py_InitializeFromConfig=Module._Py_InitializeFromConfig=wasmExports.Py_InitializeFromConfig)(t,e),_PyConfig_Clear=Module._PyConfig_Clear=t=>(_PyConfig_Clear=Module._PyConfig_Clear=wasmExports.PyConfig_Clear)(t),_Py_ExitStatusException=Module._Py_ExitStatusException=t=>(_Py_ExitStatusException=Module._Py_ExitStatusException=wasmExports.Py_ExitStatusException)(t),_run_main=Module._run_main=()=>(_run_main=Module._run_main=wasmExports.run_main)(),_Py_GetBuildInfo=Module._Py_GetBuildInfo=()=>(_Py_GetBuildInfo=Module._Py_GetBuildInfo=wasmExports.Py_GetBuildInfo)(),_PyOS_snprintf=Module._PyOS_snprintf=(t,e,n,_)=>(_PyOS_snprintf=Module._PyOS_snprintf=wasmExports.PyOS_snprintf)(t,e,n,_),__Py_gitversion=Module.__Py_gitversion=()=>(__Py_gitversion=Module.__Py_gitversion=wasmExports._Py_gitversion)(),__Py_gitidentifier=Module.__Py_gitidentifier=()=>(__Py_gitidentifier=Module.__Py_gitidentifier=wasmExports._Py_gitidentifier)(),_PyToken_OneChar=Module._PyToken_OneChar=t=>(_PyToken_OneChar=Module._PyToken_OneChar=wasmExports.PyToken_OneChar)(t),_PyToken_TwoChars=Module._PyToken_TwoChars=(t,e)=>(_PyToken_TwoChars=Module._PyToken_TwoChars=wasmExports.PyToken_TwoChars)(t,e),_PyToken_ThreeChars=Module._PyToken_ThreeChars=(t,e,n)=>(_PyToken_ThreeChars=Module._PyToken_ThreeChars=wasmExports.PyToken_ThreeChars)(t,e,n),_strlen=Module._strlen=t=>(_strlen=Module._strlen=wasmExports.strlen)(t),_PyUnicode_DecodeUTF8=Module._PyUnicode_DecodeUTF8=(t,e,n)=>(_PyUnicode_DecodeUTF8=Module._PyUnicode_DecodeUTF8=wasmExports.PyUnicode_DecodeUTF8)(t,e,n),__PyArena_Malloc=Module.__PyArena_Malloc=(t,e)=>(__PyArena_Malloc=Module.__PyArena_Malloc=wasmExports._PyArena_Malloc)(t,e),_strncpy=Module._strncpy=(t,e,n)=>(_strncpy=Module._strncpy=wasmExports.strncpy)(t,e,n),_PyMem_Realloc=Module._PyMem_Realloc=(t,e)=>(_PyMem_Realloc=Module._PyMem_Realloc=wasmExports.PyMem_Realloc)(t,e),_PyMem_Calloc=Module._PyMem_Calloc=(t,e)=>(_PyMem_Calloc=Module._PyMem_Calloc=wasmExports.PyMem_Calloc)(t,e),__PyArena_AddPyObject=Module.__PyArena_AddPyObject=(t,e)=>(__PyArena_AddPyObject=Module.__PyArena_AddPyObject=wasmExports._PyArena_AddPyObject)(t,e),_PyBytes_AsString=Module._PyBytes_AsString=t=>(_PyBytes_AsString=Module._PyBytes_AsString=wasmExports.PyBytes_AsString)(t),_PyUnicode_InternFromString=Module._PyUnicode_InternFromString=t=>(_PyUnicode_InternFromString=Module._PyUnicode_InternFromString=wasmExports.PyUnicode_InternFromString)(t),__PyObject_FastCall=Module.__PyObject_FastCall=(t,e,n)=>(__PyObject_FastCall=Module.__PyObject_FastCall=wasmExports._PyObject_FastCall)(t,e,n),__PyType_Name=Module.__PyType_Name=t=>(__PyType_Name=Module.__PyType_Name=wasmExports._PyType_Name)(t),_PyUnicode_InternInPlace=Module._PyUnicode_InternInPlace=t=>(_PyUnicode_InternInPlace=Module._PyUnicode_InternInPlace=wasmExports.PyUnicode_InternInPlace)(t),_PyBytes_AsStringAndSize=Module._PyBytes_AsStringAndSize=(t,e,n)=>(_PyBytes_AsStringAndSize=Module._PyBytes_AsStringAndSize=wasmExports.PyBytes_AsStringAndSize)(t,e,n),_strchr=Module._strchr=(t,e)=>(_strchr=Module._strchr=wasmExports.strchr)(t,e),_PyUnicode_CompareWithASCIIString=Module._PyUnicode_CompareWithASCIIString=(t,e)=>(_PyUnicode_CompareWithASCIIString=Module._PyUnicode_CompareWithASCIIString=wasmExports.PyUnicode_CompareWithASCIIString)(t,e),___errno_location=()=>(___errno_location=wasmExports.__errno_location)(),_PyOS_strtoul=Module._PyOS_strtoul=(t,e,n)=>(_PyOS_strtoul=Module._PyOS_strtoul=wasmExports.PyOS_strtoul)(t,e,n),_PyLong_FromString=Module._PyLong_FromString=(t,e,n)=>(_PyLong_FromString=Module._PyLong_FromString=wasmExports.PyLong_FromString)(t,e,n),_PyOS_strtol=Module._PyOS_strtol=(t,e,n)=>(_PyOS_strtol=Module._PyOS_strtol=wasmExports.PyOS_strtol)(t,e,n),_PyOS_string_to_double=Module._PyOS_string_to_double=(t,e,n)=>(_PyOS_string_to_double=Module._PyOS_string_to_double=wasmExports.PyOS_string_to_double)(t,e,n),_PyComplex_FromCComplex=Module._PyComplex_FromCComplex=t=>(_PyComplex_FromCComplex=Module._PyComplex_FromCComplex=wasmExports.PyComplex_FromCComplex)(t),_PyFloat_FromDouble=Module._PyFloat_FromDouble=t=>(_PyFloat_FromDouble=Module._PyFloat_FromDouble=wasmExports.PyFloat_FromDouble)(t),_Py_BuildValue=Module._Py_BuildValue=(t,e)=>(_Py_BuildValue=Module._Py_BuildValue=wasmExports.Py_BuildValue)(t,e),_PyUnicode_FromFormatV=Module._PyUnicode_FromFormatV=(t,e)=>(_PyUnicode_FromFormatV=Module._PyUnicode_FromFormatV=wasmExports.PyUnicode_FromFormatV)(t,e),__PyErr_ProgramDecodedTextObject=Module.__PyErr_ProgramDecodedTextObject=(t,e,n)=>(__PyErr_ProgramDecodedTextObject=Module.__PyErr_ProgramDecodedTextObject=wasmExports._PyErr_ProgramDecodedTextObject)(t,e,n),_PyUnicode_FromStringAndSize=Module._PyUnicode_FromStringAndSize=(t,e)=>(_PyUnicode_FromStringAndSize=Module._PyUnicode_FromStringAndSize=wasmExports.PyUnicode_FromStringAndSize)(t,e),__PyUnicode_Ready=Module.__PyUnicode_Ready=t=>(__PyUnicode_Ready=Module.__PyUnicode_Ready=wasmExports._PyUnicode_Ready)(t),_strcpy=Module._strcpy=(t,e)=>(_strcpy=Module._strcpy=wasmExports.strcpy)(t,e),_PyBytes_ConcatAndDel=Module._PyBytes_ConcatAndDel=(t,e)=>(_PyBytes_ConcatAndDel=Module._PyBytes_ConcatAndDel=wasmExports.PyBytes_ConcatAndDel)(t,e),__PyErr_BadInternalCall=Module.__PyErr_BadInternalCall=(t,e)=>(__PyErr_BadInternalCall=Module.__PyErr_BadInternalCall=wasmExports._PyErr_BadInternalCall)(t,e),_PyUnicode_DecodeUTF8Stateful=Module._PyUnicode_DecodeUTF8Stateful=(t,e,n,_)=>(_PyUnicode_DecodeUTF8Stateful=Module._PyUnicode_DecodeUTF8Stateful=wasmExports.PyUnicode_DecodeUTF8Stateful)(t,e,n,_),__PyBytes_DecodeEscape=Module.__PyBytes_DecodeEscape=(t,e,n,_)=>(__PyBytes_DecodeEscape=Module.__PyBytes_DecodeEscape=wasmExports._PyBytes_DecodeEscape)(t,e,n,_),_siprintf=Module._siprintf=(t,e,n)=>(_siprintf=Module._siprintf=wasmExports.siprintf)(t,e,n),__PyUnicode_DecodeUnicodeEscapeInternal=Module.__PyUnicode_DecodeUnicodeEscapeInternal=(t,e,n,_,r)=>(__PyUnicode_DecodeUnicodeEscapeInternal=Module.__PyUnicode_DecodeUnicodeEscapeInternal=wasmExports._PyUnicode_DecodeUnicodeEscapeInternal)(t,e,n,_,r),_PyUnicode_AppendAndDel=Module._PyUnicode_AppendAndDel=(t,e)=>(_PyUnicode_AppendAndDel=Module._PyUnicode_AppendAndDel=wasmExports.PyUnicode_AppendAndDel)(t,e),_PyUnicode_FromFormat=Module._PyUnicode_FromFormat=(t,e)=>(_PyUnicode_FromFormat=Module._PyUnicode_FromFormat=wasmExports.PyUnicode_FromFormat)(t,e),_PyErr_WarnExplicitObject=Module._PyErr_WarnExplicitObject=(t,e,n,_,r,a)=>(_PyErr_WarnExplicitObject=Module._PyErr_WarnExplicitObject=wasmExports.PyErr_WarnExplicitObject)(t,e,n,_,r,a),_PySys_Audit=Module._PySys_Audit=(t,e,n)=>(_PySys_Audit=Module._PySys_Audit=wasmExports.PySys_Audit)(t,e,n),_fflush=Module._fflush=t=>(_fflush=Module._fflush=wasmExports.fflush)(t),_fputs=Module._fputs=(t,e)=>(_fputs=Module._fputs=wasmExports.fputs)(t,e),_PyMem_RawFree=Module._PyMem_RawFree=t=>(_PyMem_RawFree=Module._PyMem_RawFree=wasmExports.PyMem_RawFree)(t),_PyEval_RestoreThread=Module._PyEval_RestoreThread=t=>(_PyEval_RestoreThread=Module._PyEval_RestoreThread=wasmExports.PyEval_RestoreThread)(t),_PyEval_SaveThread=Module._PyEval_SaveThread=()=>(_PyEval_SaveThread=Module._PyEval_SaveThread=wasmExports.PyEval_SaveThread)(),_PyMem_RawRealloc=Module._PyMem_RawRealloc=(t,e)=>(_PyMem_RawRealloc=Module._PyMem_RawRealloc=wasmExports.PyMem_RawRealloc)(t,e),_clearerr=Module._clearerr=t=>(_clearerr=Module._clearerr=wasmExports.clearerr)(t),_fgets=Module._fgets=(t,e,n)=>(_fgets=Module._fgets=wasmExports.fgets)(t,e,n),_feof=Module._feof=t=>(_feof=Module._feof=wasmExports.feof)(t),__PyOS_InterruptOccurred=Module.__PyOS_InterruptOccurred=t=>(__PyOS_InterruptOccurred=Module.__PyOS_InterruptOccurred=wasmExports._PyOS_InterruptOccurred)(t),_PyErr_CheckSignals=Module._PyErr_CheckSignals=()=>(_PyErr_CheckSignals=Module._PyErr_CheckSignals=wasmExports.PyErr_CheckSignals)(),_PyOS_Readline=Module._PyOS_Readline=(t,e,n)=>(_PyOS_Readline=Module._PyOS_Readline=wasmExports.PyOS_Readline)(t,e,n),_PyThread_allocate_lock=Module._PyThread_allocate_lock=()=>(_PyThread_allocate_lock=Module._PyThread_allocate_lock=wasmExports.PyThread_allocate_lock)(),_PyThread_acquire_lock=Module._PyThread_acquire_lock=(t,e)=>(_PyThread_acquire_lock=Module._PyThread_acquire_lock=wasmExports.PyThread_acquire_lock)(t,e),_isatty=Module._isatty=t=>(_isatty=Module._isatty=wasmExports.isatty)(t),_PyThread_release_lock=Module._PyThread_release_lock=t=>(_PyThread_release_lock=Module._PyThread_release_lock=wasmExports.PyThread_release_lock)(t),_PyUnicode_Decode=Module._PyUnicode_Decode=(t,e,n,_)=>(_PyUnicode_Decode=Module._PyUnicode_Decode=wasmExports.PyUnicode_Decode)(t,e,n,_),_PyUnicode_AsUTF8String=Module._PyUnicode_AsUTF8String=t=>(_PyUnicode_AsUTF8String=Module._PyUnicode_AsUTF8String=wasmExports.PyUnicode_AsUTF8String)(t),__Py_FatalErrorFunc=Module.__Py_FatalErrorFunc=(t,e)=>(__Py_FatalErrorFunc=Module.__Py_FatalErrorFunc=wasmExports._Py_FatalErrorFunc)(t,e),_memcmp=Module._memcmp=(t,e,n)=>(_memcmp=Module._memcmp=wasmExports.memcmp)(t,e,n),__PyUnicode_ScanIdentifier=Module.__PyUnicode_ScanIdentifier=t=>(__PyUnicode_ScanIdentifier=Module.__PyUnicode_ScanIdentifier=wasmExports._PyUnicode_ScanIdentifier)(t),_PyUnicode_Substring=Module._PyUnicode_Substring=(t,e,n)=>(_PyUnicode_Substring=Module._PyUnicode_Substring=wasmExports.PyUnicode_Substring)(t,e,n),__PyUnicode_IsPrintable=Module.__PyUnicode_IsPrintable=t=>(__PyUnicode_IsPrintable=Module.__PyUnicode_IsPrintable=wasmExports._PyUnicode_IsPrintable)(t),_isxdigit=Module._isxdigit=t=>(_isxdigit=Module._isxdigit=wasmExports.isxdigit)(t),__Py_dup=Module.__Py_dup=t=>(__Py_dup=Module.__Py_dup=wasmExports._Py_dup)(t),_fdopen=Module._fdopen=(t,e)=>(_fdopen=Module._fdopen=wasmExports.fdopen)(t,e),_fclose=Module._fclose=t=>(_fclose=Module._fclose=wasmExports.fclose)(t),_tolower=Module._tolower=t=>(_tolower=Module._tolower=wasmExports.tolower)(t),_getc=Module._getc=t=>(_getc=Module._getc=wasmExports.getc)(t),_ungetc=Module._ungetc=(t,e)=>(_ungetc=Module._ungetc=wasmExports.ungetc)(t,e),_Py_UniversalNewlineFgets=Module._Py_UniversalNewlineFgets=(t,e,n,_)=>(_Py_UniversalNewlineFgets=Module._Py_UniversalNewlineFgets=wasmExports.Py_UniversalNewlineFgets)(t,e,n,_),_ftell=Module._ftell=t=>(_ftell=Module._ftell=wasmExports.ftell)(t),_lseek=Module._lseek=(t,e,n)=>(_lseek=Module._lseek=wasmExports.lseek)(t,e,n),_PyErr_SetFromErrnoWithFilename=Module._PyErr_SetFromErrnoWithFilename=(t,e)=>(_PyErr_SetFromErrnoWithFilename=Module._PyErr_SetFromErrnoWithFilename=wasmExports.PyErr_SetFromErrnoWithFilename)(t,e),__PyObject_CallMethod=Module.__PyObject_CallMethod=(t,e,n,_)=>(__PyObject_CallMethod=Module.__PyObject_CallMethod=wasmExports._PyObject_CallMethod)(t,e,n,_),_PyObject_GetAttr=Module._PyObject_GetAttr=(t,e)=>(_PyObject_GetAttr=Module._PyObject_GetAttr=wasmExports.PyObject_GetAttr)(t,e),__PyObject_MakeTpCall=Module.__PyObject_MakeTpCall=(t,e,n,_,r)=>(__PyObject_MakeTpCall=Module.__PyObject_MakeTpCall=wasmExports._PyObject_MakeTpCall)(t,e,n,_,r),__Py_CheckFunctionResult=Module.__Py_CheckFunctionResult=(t,e,n,_)=>(__Py_CheckFunctionResult=Module.__Py_CheckFunctionResult=wasmExports._Py_CheckFunctionResult)(t,e,n,_),_strcspn=Module._strcspn=(t,e)=>(_strcspn=Module._strcspn=wasmExports.strcspn)(t,e),__Py_BuildValue_SizeT=Module.__Py_BuildValue_SizeT=(t,e)=>(__Py_BuildValue_SizeT=Module.__Py_BuildValue_SizeT=wasmExports._Py_BuildValue_SizeT)(t,e),_PyObject_Type=Module._PyObject_Type=t=>(_PyObject_Type=Module._PyObject_Type=wasmExports.PyObject_Type)(t),__PyErr_SetString=Module.__PyErr_SetString=(t,e,n)=>(__PyErr_SetString=Module.__PyErr_SetString=wasmExports._PyErr_SetString)(t,e,n),_PyObject_Size=Module._PyObject_Size=t=>(_PyObject_Size=Module._PyObject_Size=wasmExports.PyObject_Size)(t),_PyMapping_Size=Module._PyMapping_Size=t=>(_PyMapping_Size=Module._PyMapping_Size=wasmExports.PyMapping_Size)(t),_PyObject_Length=Module._PyObject_Length=t=>(_PyObject_Length=Module._PyObject_Length=wasmExports.PyObject_Length)(t),__PyObject_HasLen=Module.__PyObject_HasLen=t=>(__PyObject_HasLen=Module.__PyObject_HasLen=wasmExports._PyObject_HasLen)(t),_PyObject_LengthHint=Module._PyObject_LengthHint=(t,e)=>(_PyObject_LengthHint=Module._PyObject_LengthHint=wasmExports.PyObject_LengthHint)(t,e),__PyErr_ExceptionMatches=Module.__PyErr_ExceptionMatches=(t,e)=>(__PyErr_ExceptionMatches=Module.__PyErr_ExceptionMatches=wasmExports._PyErr_ExceptionMatches)(t,e),__PyErr_Clear=Module.__PyErr_Clear=t=>(__PyErr_Clear=Module.__PyErr_Clear=wasmExports._PyErr_Clear)(t),__PyObject_LookupSpecial=Module.__PyObject_LookupSpecial=(t,e)=>(__PyObject_LookupSpecial=Module.__PyObject_LookupSpecial=wasmExports._PyObject_LookupSpecial)(t,e),_Py_GenericAlias=Module._Py_GenericAlias=(t,e)=>(_Py_GenericAlias=Module._Py_GenericAlias=wasmExports.Py_GenericAlias)(t,e),__PyObject_LookupAttr=Module.__PyObject_LookupAttr=(t,e,n)=>(__PyObject_LookupAttr=Module.__PyObject_LookupAttr=wasmExports._PyObject_LookupAttr)(t,e,n),__PyLong_Sign=Module.__PyLong_Sign=t=>(__PyLong_Sign=Module.__PyLong_Sign=wasmExports._PyLong_Sign)(t),__PyErr_Format=Module.__PyErr_Format=(t,e,n,_)=>(__PyErr_Format=Module.__PyErr_Format=wasmExports._PyErr_Format)(t,e,n,_),_PySequence_SetItem=Module._PySequence_SetItem=(t,e,n)=>(_PySequence_SetItem=Module._PySequence_SetItem=wasmExports.PySequence_SetItem)(t,e,n),_PySequence_DelItem=Module._PySequence_DelItem=(t,e)=>(_PySequence_DelItem=Module._PySequence_DelItem=wasmExports.PySequence_DelItem)(t,e),_PyObject_DelItemString=Module._PyObject_DelItemString=(t,e)=>(_PyObject_DelItemString=Module._PyObject_DelItemString=wasmExports.PyObject_DelItemString)(t,e),_PyObject_CheckReadBuffer=Module._PyObject_CheckReadBuffer=t=>(_PyObject_CheckReadBuffer=Module._PyObject_CheckReadBuffer=wasmExports.PyObject_CheckReadBuffer)(t),_PyObject_AsCharBuffer=Module._PyObject_AsCharBuffer=(t,e,n)=>(_PyObject_AsCharBuffer=Module._PyObject_AsCharBuffer=wasmExports.PyObject_AsCharBuffer)(t,e,n),_PyObject_AsReadBuffer=Module._PyObject_AsReadBuffer=(t,e,n)=>(_PyObject_AsReadBuffer=Module._PyObject_AsReadBuffer=wasmExports.PyObject_AsReadBuffer)(t,e,n),_PyObject_AsWriteBuffer=Module._PyObject_AsWriteBuffer=(t,e,n)=>(_PyObject_AsWriteBuffer=Module._PyObject_AsWriteBuffer=wasmExports.PyObject_AsWriteBuffer)(t,e,n),_PyBuffer_GetPointer=Module._PyBuffer_GetPointer=(t,e)=>(_PyBuffer_GetPointer=Module._PyBuffer_GetPointer=wasmExports.PyBuffer_GetPointer)(t,e),__Py_add_one_to_index_F=Module.__Py_add_one_to_index_F=(t,e,n)=>(__Py_add_one_to_index_F=Module.__Py_add_one_to_index_F=wasmExports._Py_add_one_to_index_F)(t,e,n),__Py_add_one_to_index_C=Module.__Py_add_one_to_index_C=(t,e,n)=>(__Py_add_one_to_index_C=Module.__Py_add_one_to_index_C=wasmExports._Py_add_one_to_index_C)(t,e,n),_PyBuffer_SizeFromFormat=Module._PyBuffer_SizeFromFormat=t=>(_PyBuffer_SizeFromFormat=Module._PyBuffer_SizeFromFormat=wasmExports.PyBuffer_SizeFromFormat)(t),_PyObject_CallFunctionObjArgs=Module._PyObject_CallFunctionObjArgs=(t,e)=>(_PyObject_CallFunctionObjArgs=Module._PyObject_CallFunctionObjArgs=wasmExports.PyObject_CallFunctionObjArgs)(t,e),_PyBuffer_FromContiguous=Module._PyBuffer_FromContiguous=(t,e,n,_)=>(_PyBuffer_FromContiguous=Module._PyBuffer_FromContiguous=wasmExports.PyBuffer_FromContiguous)(t,e,n,_),_memset=Module._memset=(t,e,n)=>(_memset=Module._memset=wasmExports.memset)(t,e,n),_PyObject_CopyData=Module._PyObject_CopyData=(t,e)=>(_PyObject_CopyData=Module._PyObject_CopyData=wasmExports.PyObject_CopyData)(t,e),_PyBuffer_FillInfo=Module._PyBuffer_FillInfo=(t,e,n,_,r,a)=>(_PyBuffer_FillInfo=Module._PyBuffer_FillInfo=wasmExports.PyBuffer_FillInfo)(t,e,n,_,r,a),_PyObject_Format=Module._PyObject_Format=(t,e)=>(_PyObject_Format=Module._PyObject_Format=wasmExports.PyObject_Format)(t,e),_PyNumber_Check=Module._PyNumber_Check=t=>(_PyNumber_Check=Module._PyNumber_Check=wasmExports.PyNumber_Check)(t),_PyNumber_Or=Module._PyNumber_Or=(t,e)=>(_PyNumber_Or=Module._PyNumber_Or=wasmExports.PyNumber_Or)(t,e),_PyNumber_Xor=Module._PyNumber_Xor=(t,e)=>(_PyNumber_Xor=Module._PyNumber_Xor=wasmExports.PyNumber_Xor)(t,e),_PyNumber_And=Module._PyNumber_And=(t,e)=>(_PyNumber_And=Module._PyNumber_And=wasmExports.PyNumber_And)(t,e),_PyNumber_Lshift=Module._PyNumber_Lshift=(t,e)=>(_PyNumber_Lshift=Module._PyNumber_Lshift=wasmExports.PyNumber_Lshift)(t,e),_PyNumber_Rshift=Module._PyNumber_Rshift=(t,e)=>(_PyNumber_Rshift=Module._PyNumber_Rshift=wasmExports.PyNumber_Rshift)(t,e),_PyNumber_Subtract=Module._PyNumber_Subtract=(t,e)=>(_PyNumber_Subtract=Module._PyNumber_Subtract=wasmExports.PyNumber_Subtract)(t,e),_PyNumber_Divmod=Module._PyNumber_Divmod=(t,e)=>(_PyNumber_Divmod=Module._PyNumber_Divmod=wasmExports.PyNumber_Divmod)(t,e),_PyNumber_Add=Module._PyNumber_Add=(t,e)=>(_PyNumber_Add=Module._PyNumber_Add=wasmExports.PyNumber_Add)(t,e),_PyNumber_Multiply=Module._PyNumber_Multiply=(t,e)=>(_PyNumber_Multiply=Module._PyNumber_Multiply=wasmExports.PyNumber_Multiply)(t,e),_PyNumber_MatrixMultiply=Module._PyNumber_MatrixMultiply=(t,e)=>(_PyNumber_MatrixMultiply=Module._PyNumber_MatrixMultiply=wasmExports.PyNumber_MatrixMultiply)(t,e),_PyNumber_FloorDivide=Module._PyNumber_FloorDivide=(t,e)=>(_PyNumber_FloorDivide=Module._PyNumber_FloorDivide=wasmExports.PyNumber_FloorDivide)(t,e),_PyNumber_TrueDivide=Module._PyNumber_TrueDivide=(t,e)=>(_PyNumber_TrueDivide=Module._PyNumber_TrueDivide=wasmExports.PyNumber_TrueDivide)(t,e),_PyNumber_Remainder=Module._PyNumber_Remainder=(t,e)=>(_PyNumber_Remainder=Module._PyNumber_Remainder=wasmExports.PyNumber_Remainder)(t,e),_PyNumber_Power=Module._PyNumber_Power=(t,e,n)=>(_PyNumber_Power=Module._PyNumber_Power=wasmExports.PyNumber_Power)(t,e,n),_PyNumber_InPlaceOr=Module._PyNumber_InPlaceOr=(t,e)=>(_PyNumber_InPlaceOr=Module._PyNumber_InPlaceOr=wasmExports.PyNumber_InPlaceOr)(t,e),_PyNumber_InPlaceXor=Module._PyNumber_InPlaceXor=(t,e)=>(_PyNumber_InPlaceXor=Module._PyNumber_InPlaceXor=wasmExports.PyNumber_InPlaceXor)(t,e),_PyNumber_InPlaceAnd=Module._PyNumber_InPlaceAnd=(t,e)=>(_PyNumber_InPlaceAnd=Module._PyNumber_InPlaceAnd=wasmExports.PyNumber_InPlaceAnd)(t,e),_PyNumber_InPlaceLshift=Module._PyNumber_InPlaceLshift=(t,e)=>(_PyNumber_InPlaceLshift=Module._PyNumber_InPlaceLshift=wasmExports.PyNumber_InPlaceLshift)(t,e),_PyNumber_InPlaceRshift=Module._PyNumber_InPlaceRshift=(t,e)=>(_PyNumber_InPlaceRshift=Module._PyNumber_InPlaceRshift=wasmExports.PyNumber_InPlaceRshift)(t,e),_PyNumber_InPlaceSubtract=Module._PyNumber_InPlaceSubtract=(t,e)=>(_PyNumber_InPlaceSubtract=Module._PyNumber_InPlaceSubtract=wasmExports.PyNumber_InPlaceSubtract)(t,e),_PyNumber_InPlaceMatrixMultiply=Module._PyNumber_InPlaceMatrixMultiply=(t,e)=>(_PyNumber_InPlaceMatrixMultiply=Module._PyNumber_InPlaceMatrixMultiply=wasmExports.PyNumber_InPlaceMatrixMultiply)(t,e),_PyNumber_InPlaceFloorDivide=Module._PyNumber_InPlaceFloorDivide=(t,e)=>(_PyNumber_InPlaceFloorDivide=Module._PyNumber_InPlaceFloorDivide=wasmExports.PyNumber_InPlaceFloorDivide)(t,e),_PyNumber_InPlaceTrueDivide=Module._PyNumber_InPlaceTrueDivide=(t,e)=>(_PyNumber_InPlaceTrueDivide=Module._PyNumber_InPlaceTrueDivide=wasmExports.PyNumber_InPlaceTrueDivide)(t,e),_PyNumber_InPlaceRemainder=Module._PyNumber_InPlaceRemainder=(t,e)=>(_PyNumber_InPlaceRemainder=Module._PyNumber_InPlaceRemainder=wasmExports.PyNumber_InPlaceRemainder)(t,e),_PyNumber_InPlaceAdd=Module._PyNumber_InPlaceAdd=(t,e)=>(_PyNumber_InPlaceAdd=Module._PyNumber_InPlaceAdd=wasmExports.PyNumber_InPlaceAdd)(t,e),_PyNumber_InPlaceMultiply=Module._PyNumber_InPlaceMultiply=(t,e)=>(_PyNumber_InPlaceMultiply=Module._PyNumber_InPlaceMultiply=wasmExports.PyNumber_InPlaceMultiply)(t,e),_PyNumber_InPlacePower=Module._PyNumber_InPlacePower=(t,e,n)=>(_PyNumber_InPlacePower=Module._PyNumber_InPlacePower=wasmExports.PyNumber_InPlacePower)(t,e,n),_PyNumber_Negative=Module._PyNumber_Negative=t=>(_PyNumber_Negative=Module._PyNumber_Negative=wasmExports.PyNumber_Negative)(t),_PyNumber_Positive=Module._PyNumber_Positive=t=>(_PyNumber_Positive=Module._PyNumber_Positive=wasmExports.PyNumber_Positive)(t),_PyNumber_Invert=Module._PyNumber_Invert=t=>(_PyNumber_Invert=Module._PyNumber_Invert=wasmExports.PyNumber_Invert)(t),_PyNumber_Absolute=Module._PyNumber_Absolute=t=>(_PyNumber_Absolute=Module._PyNumber_Absolute=wasmExports.PyNumber_Absolute)(t),_PyErr_WarnFormat=Module._PyErr_WarnFormat=(t,e,n,_)=>(_PyErr_WarnFormat=Module._PyErr_WarnFormat=wasmExports.PyErr_WarnFormat)(t,e,n,_),_PyNumber_Index=Module._PyNumber_Index=t=>(_PyNumber_Index=Module._PyNumber_Index=wasmExports.PyNumber_Index)(t),__PyLong_Copy=Module.__PyLong_Copy=t=>(__PyLong_Copy=Module.__PyLong_Copy=wasmExports._PyLong_Copy)(t),_PyNumber_Long=Module._PyNumber_Long=t=>(_PyNumber_Long=Module._PyNumber_Long=wasmExports.PyNumber_Long)(t),_PyErr_WarnEx=Module._PyErr_WarnEx=(t,e,n)=>(_PyErr_WarnEx=Module._PyErr_WarnEx=wasmExports.PyErr_WarnEx)(t,e,n),_PyLong_FromUnicodeObject=Module._PyLong_FromUnicodeObject=(t,e)=>(_PyLong_FromUnicodeObject=Module._PyLong_FromUnicodeObject=wasmExports.PyLong_FromUnicodeObject)(t,e),__PyLong_FromBytes=Module.__PyLong_FromBytes=(t,e,n)=>(__PyLong_FromBytes=Module.__PyLong_FromBytes=wasmExports._PyLong_FromBytes)(t,e,n),_PyNumber_Float=Module._PyNumber_Float=t=>(_PyNumber_Float=Module._PyNumber_Float=wasmExports.PyNumber_Float)(t),_PyLong_AsDouble=Module._PyLong_AsDouble=t=>(_PyLong_AsDouble=Module._PyLong_AsDouble=wasmExports.PyLong_AsDouble)(t),_PyFloat_FromString=Module._PyFloat_FromString=t=>(_PyFloat_FromString=Module._PyFloat_FromString=wasmExports.PyFloat_FromString)(t),_PyNumber_ToBase=Module._PyNumber_ToBase=(t,e)=>(_PyNumber_ToBase=Module._PyNumber_ToBase=wasmExports.PyNumber_ToBase)(t,e),__PyLong_Format=Module.__PyLong_Format=(t,e)=>(__PyLong_Format=Module.__PyLong_Format=wasmExports._PyLong_Format)(t,e),_PySequence_Check=Module._PySequence_Check=t=>(_PySequence_Check=Module._PySequence_Check=wasmExports.PySequence_Check)(t),_PySequence_Length=Module._PySequence_Length=t=>(_PySequence_Length=Module._PySequence_Length=wasmExports.PySequence_Length)(t),_PySequence_Concat=Module._PySequence_Concat=(t,e)=>(_PySequence_Concat=Module._PySequence_Concat=wasmExports.PySequence_Concat)(t,e),_PySequence_Repeat=Module._PySequence_Repeat=(t,e)=>(_PySequence_Repeat=Module._PySequence_Repeat=wasmExports.PySequence_Repeat)(t,e),_PySequence_InPlaceConcat=Module._PySequence_InPlaceConcat=(t,e)=>(_PySequence_InPlaceConcat=Module._PySequence_InPlaceConcat=wasmExports.PySequence_InPlaceConcat)(t,e),_PySequence_InPlaceRepeat=Module._PySequence_InPlaceRepeat=(t,e)=>(_PySequence_InPlaceRepeat=Module._PySequence_InPlaceRepeat=wasmExports.PySequence_InPlaceRepeat)(t,e),__PySlice_FromIndices=Module.__PySlice_FromIndices=(t,e)=>(__PySlice_FromIndices=Module.__PySlice_FromIndices=wasmExports._PySlice_FromIndices)(t,e),_PySequence_DelSlice=Module._PySequence_DelSlice=(t,e,n)=>(_PySequence_DelSlice=Module._PySequence_DelSlice=wasmExports.PySequence_DelSlice)(t,e,n),_PySequence_Tuple=Module._PySequence_Tuple=t=>(_PySequence_Tuple=Module._PySequence_Tuple=wasmExports.PySequence_Tuple)(t),_PyList_AsTuple=Module._PyList_AsTuple=t=>(_PyList_AsTuple=Module._PyList_AsTuple=wasmExports.PyList_AsTuple)(t),__PyTuple_Resize=Module.__PyTuple_Resize=(t,e)=>(__PyTuple_Resize=Module.__PyTuple_Resize=wasmExports._PyTuple_Resize)(t,e),_PySeqIter_New=Module._PySeqIter_New=t=>(_PySeqIter_New=Module._PySeqIter_New=wasmExports.PySeqIter_New)(t),_PySequence_List=Module._PySequence_List=t=>(_PySequence_List=Module._PySequence_List=wasmExports.PySequence_List)(t),__PySequence_IterSearch=Module.__PySequence_IterSearch=(t,e,n)=>(__PySequence_IterSearch=Module.__PySequence_IterSearch=wasmExports._PySequence_IterSearch)(t,e,n),_PySequence_Count=Module._PySequence_Count=(t,e)=>(_PySequence_Count=Module._PySequence_Count=wasmExports.PySequence_Count)(t,e),_PySequence_In=Module._PySequence_In=(t,e)=>(_PySequence_In=Module._PySequence_In=wasmExports.PySequence_In)(t,e),_PySequence_Index=Module._PySequence_Index=(t,e)=>(_PySequence_Index=Module._PySequence_Index=wasmExports.PySequence_Index)(t,e),_PyMapping_Check=Module._PyMapping_Check=t=>(_PyMapping_Check=Module._PyMapping_Check=wasmExports.PyMapping_Check)(t),_PyMapping_Length=Module._PyMapping_Length=t=>(_PyMapping_Length=Module._PyMapping_Length=wasmExports.PyMapping_Length)(t),_PyMapping_GetItemString=Module._PyMapping_GetItemString=(t,e)=>(_PyMapping_GetItemString=Module._PyMapping_GetItemString=wasmExports.PyMapping_GetItemString)(t,e),_PyMapping_SetItemString=Module._PyMapping_SetItemString=(t,e,n)=>(_PyMapping_SetItemString=Module._PyMapping_SetItemString=wasmExports.PyMapping_SetItemString)(t,e,n),_PyMapping_HasKeyString=Module._PyMapping_HasKeyString=(t,e)=>(_PyMapping_HasKeyString=Module._PyMapping_HasKeyString=wasmExports.PyMapping_HasKeyString)(t,e),_PyMapping_HasKey=Module._PyMapping_HasKey=(t,e)=>(_PyMapping_HasKey=Module._PyMapping_HasKey=wasmExports.PyMapping_HasKey)(t,e),_PyMapping_Keys=Module._PyMapping_Keys=t=>(_PyMapping_Keys=Module._PyMapping_Keys=wasmExports.PyMapping_Keys)(t),_PyDict_Keys=Module._PyDict_Keys=t=>(_PyDict_Keys=Module._PyDict_Keys=wasmExports.PyDict_Keys)(t),_PyMapping_Items=Module._PyMapping_Items=t=>(_PyMapping_Items=Module._PyMapping_Items=wasmExports.PyMapping_Items)(t),_PyDict_Items=Module._PyDict_Items=t=>(_PyDict_Items=Module._PyDict_Items=wasmExports.PyDict_Items)(t),_PyMapping_Values=Module._PyMapping_Values=t=>(_PyMapping_Values=Module._PyMapping_Values=wasmExports.PyMapping_Values)(t),_PyDict_Values=Module._PyDict_Values=t=>(_PyDict_Values=Module._PyDict_Values=wasmExports.PyDict_Values)(t),_PyObject_IsInstance=Module._PyObject_IsInstance=(t,e)=>(_PyObject_IsInstance=Module._PyObject_IsInstance=wasmExports.PyObject_IsInstance)(t,e),__Py_CheckRecursiveCall=Module.__Py_CheckRecursiveCall=(t,e)=>(__Py_CheckRecursiveCall=Module.__Py_CheckRecursiveCall=wasmExports._Py_CheckRecursiveCall)(t,e),_PyObject_IsTrue=Module._PyObject_IsTrue=t=>(_PyObject_IsTrue=Module._PyObject_IsTrue=wasmExports.PyObject_IsTrue)(t),__PyObject_RealIsInstance=Module.__PyObject_RealIsInstance=(t,e)=>(__PyObject_RealIsInstance=Module.__PyObject_RealIsInstance=wasmExports._PyObject_RealIsInstance)(t,e),__PyObject_RealIsSubclass=Module.__PyObject_RealIsSubclass=(t,e)=>(__PyObject_RealIsSubclass=Module.__PyObject_RealIsSubclass=wasmExports._PyObject_RealIsSubclass)(t,e),_PyIter_Check=Module._PyIter_Check=t=>(_PyIter_Check=Module._PyIter_Check=wasmExports.PyIter_Check)(t),_PyObject_GetAIter=Module._PyObject_GetAIter=t=>(_PyObject_GetAIter=Module._PyObject_GetAIter=wasmExports.PyObject_GetAIter)(t),_PyAIter_Check=Module._PyAIter_Check=t=>(_PyAIter_Check=Module._PyAIter_Check=wasmExports.PyAIter_Check)(t),__PySequence_BytesToCharpArray=Module.__PySequence_BytesToCharpArray=t=>(__PySequence_BytesToCharpArray=Module.__PySequence_BytesToCharpArray=wasmExports._PySequence_BytesToCharpArray)(t),__Py_FreeCharPArray=Module.__Py_FreeCharPArray=t=>(__Py_FreeCharPArray=Module.__Py_FreeCharPArray=wasmExports._Py_FreeCharPArray)(t),__PyAccu_Init=Module.__PyAccu_Init=t=>(__PyAccu_Init=Module.__PyAccu_Init=wasmExports._PyAccu_Init)(t),__PyAccu_Accumulate=Module.__PyAccu_Accumulate=(t,e)=>(__PyAccu_Accumulate=Module.__PyAccu_Accumulate=wasmExports._PyAccu_Accumulate)(t,e),_PyList_Append=Module._PyList_Append=(t,e)=>(_PyList_Append=Module._PyList_Append=wasmExports.PyList_Append)(t,e),_PyList_SetSlice=Module._PyList_SetSlice=(t,e,n,_)=>(_PyList_SetSlice=Module._PyList_SetSlice=wasmExports.PyList_SetSlice)(t,e,n,_),__PyAccu_FinishAsList=Module.__PyAccu_FinishAsList=t=>(__PyAccu_FinishAsList=Module.__PyAccu_FinishAsList=wasmExports._PyAccu_FinishAsList)(t),__PyAccu_Finish=Module.__PyAccu_Finish=t=>(__PyAccu_Finish=Module.__PyAccu_Finish=wasmExports._PyAccu_Finish)(t),__PyAccu_Destroy=Module.__PyAccu_Destroy=t=>(__PyAccu_Destroy=Module.__PyAccu_Destroy=wasmExports._PyAccu_Destroy)(t),_PyBool_FromLong=Module._PyBool_FromLong=t=>(_PyBool_FromLong=Module._PyBool_FromLong=wasmExports.PyBool_FromLong)(t),__Py_FatalRefcountErrorFunc=Module.__Py_FatalRefcountErrorFunc=(t,e)=>(__Py_FatalRefcountErrorFunc=Module.__Py_FatalRefcountErrorFunc=wasmExports._Py_FatalRefcountErrorFunc)(t,e),__PyArg_NoKeywords=Module.__PyArg_NoKeywords=(t,e)=>(__PyArg_NoKeywords=Module.__PyArg_NoKeywords=wasmExports._PyArg_NoKeywords)(t,e),__PyArg_NoKwnames=Module.__PyArg_NoKwnames=(t,e)=>(__PyArg_NoKwnames=Module.__PyArg_NoKwnames=wasmExports._PyArg_NoKwnames)(t,e),_memrchr=Module._memrchr=(t,e,n)=>(_memrchr=Module._memrchr=wasmExports.memrchr)(t,e,n),_memchr=Module._memchr=(t,e,n)=>(_memchr=Module._memchr=wasmExports.memchr)(t,e,n),__PyEval_SliceIndex=Module.__PyEval_SliceIndex=(t,e)=>(__PyEval_SliceIndex=Module.__PyEval_SliceIndex=wasmExports._PyEval_SliceIndex)(t,e),_PyByteArray_FromObject=Module._PyByteArray_FromObject=t=>(_PyByteArray_FromObject=Module._PyByteArray_FromObject=wasmExports.PyByteArray_FromObject)(t),_PyByteArray_FromStringAndSize=Module._PyByteArray_FromStringAndSize=(t,e)=>(_PyByteArray_FromStringAndSize=Module._PyByteArray_FromStringAndSize=wasmExports.PyByteArray_FromStringAndSize)(t,e),__PyObject_New=Module.__PyObject_New=t=>(__PyObject_New=Module.__PyObject_New=wasmExports._PyObject_New)(t),_PyObject_Malloc=Module._PyObject_Malloc=t=>(_PyObject_Malloc=Module._PyObject_Malloc=wasmExports.PyObject_Malloc)(t),_PyByteArray_Size=Module._PyByteArray_Size=t=>(_PyByteArray_Size=Module._PyByteArray_Size=wasmExports.PyByteArray_Size)(t),_PyByteArray_AsString=Module._PyByteArray_AsString=t=>(_PyByteArray_AsString=Module._PyByteArray_AsString=wasmExports.PyByteArray_AsString)(t),_PyByteArray_Resize=Module._PyByteArray_Resize=(t,e)=>(_PyByteArray_Resize=Module._PyByteArray_Resize=wasmExports.PyByteArray_Resize)(t,e),_PyObject_Free=Module._PyObject_Free=t=>(_PyObject_Free=Module._PyObject_Free=wasmExports.PyObject_Free)(t),_PyObject_Realloc=Module._PyObject_Realloc=(t,e)=>(_PyObject_Realloc=Module._PyObject_Realloc=wasmExports.PyObject_Realloc)(t,e),_PyByteArray_Concat=Module._PyByteArray_Concat=(t,e)=>(_PyByteArray_Concat=Module._PyByteArray_Concat=wasmExports.PyByteArray_Concat)(t,e),__Py_GetConfig=Module.__Py_GetConfig=()=>(__Py_GetConfig=Module.__Py_GetConfig=wasmExports._Py_GetConfig)(),__PyObject_GC_New=Module.__PyObject_GC_New=t=>(__PyObject_GC_New=Module.__PyObject_GC_New=wasmExports._PyObject_GC_New)(t),__PyArg_UnpackKeywords=Module.__PyArg_UnpackKeywords=(t,e,n,_,r,a,o,l,p)=>(__PyArg_UnpackKeywords=Module.__PyArg_UnpackKeywords=wasmExports._PyArg_UnpackKeywords)(t,e,n,_,r,a,o,l,p),__PyArg_BadArgument=Module.__PyArg_BadArgument=(t,e,n,_)=>(__PyArg_BadArgument=Module.__PyArg_BadArgument=wasmExports._PyArg_BadArgument)(t,e,n,_),_PyUnicode_AsEncodedString=Module._PyUnicode_AsEncodedString=(t,e,n)=>(_PyUnicode_AsEncodedString=Module._PyUnicode_AsEncodedString=wasmExports.PyUnicode_AsEncodedString)(t,e,n),_PyBuffer_ToContiguous=Module._PyBuffer_ToContiguous=(t,e,n,_)=>(_PyBuffer_ToContiguous=Module._PyBuffer_ToContiguous=wasmExports.PyBuffer_ToContiguous)(t,e,n,_),_PyObject_GC_Del=Module._PyObject_GC_Del=t=>(_PyObject_GC_Del=Module._PyObject_GC_Del=wasmExports.PyObject_GC_Del)(t),__PyBytes_FormatEx=Module.__PyBytes_FormatEx=(t,e,n,_)=>(__PyBytes_FormatEx=Module.__PyBytes_FormatEx=wasmExports._PyBytes_FormatEx)(t,e,n,_),__PyBytes_Repeat=Module.__PyBytes_Repeat=(t,e,n,_)=>(__PyBytes_Repeat=Module.__PyBytes_Repeat=wasmExports._PyBytes_Repeat)(t,e,n,_),_memmove=Module._memmove=(t,e,n)=>(_memmove=Module._memmove=wasmExports.memmove)(t,e,n),__PyObject_GetState=Module.__PyObject_GetState=t=>(__PyObject_GetState=Module.__PyObject_GetState=wasmExports._PyObject_GetState)(t),_PyUnicode_DecodeLatin1=Module._PyUnicode_DecodeLatin1=(t,e,n)=>(_PyUnicode_DecodeLatin1=Module._PyUnicode_DecodeLatin1=wasmExports.PyUnicode_DecodeLatin1)(t,e,n),__PyLong_AsInt=Module.__PyLong_AsInt=t=>(__PyLong_AsInt=Module.__PyLong_AsInt=wasmExports._PyLong_AsInt)(t),_PyUnicode_GetDefaultEncoding=Module._PyUnicode_GetDefaultEncoding=()=>(_PyUnicode_GetDefaultEncoding=Module._PyUnicode_GetDefaultEncoding=wasmExports.PyUnicode_GetDefaultEncoding)(),_PyUnicode_FromEncodedObject=Module._PyUnicode_FromEncodedObject=(t,e,n)=>(_PyUnicode_FromEncodedObject=Module._PyUnicode_FromEncodedObject=wasmExports.PyUnicode_FromEncodedObject)(t,e,n),__PyBytes_FromHex=Module.__PyBytes_FromHex=(t,e)=>(__PyBytes_FromHex=Module.__PyBytes_FromHex=wasmExports._PyBytes_FromHex)(t,e),__Py_strhex_with_sep=Module.__Py_strhex_with_sep=(t,e,n,_)=>(__Py_strhex_with_sep=Module.__Py_strhex_with_sep=wasmExports._Py_strhex_with_sep)(t,e,n,_),_PyList_Reverse=Module._PyList_Reverse=t=>(_PyList_Reverse=Module._PyList_Reverse=wasmExports.PyList_Reverse)(t),__PyEval_GetBuiltin=Module.__PyEval_GetBuiltin=t=>(__PyEval_GetBuiltin=Module.__PyEval_GetBuiltin=wasmExports._PyEval_GetBuiltin)(t),_PyType_GenericAlloc=Module._PyType_GenericAlloc=(t,e)=>(_PyType_GenericAlloc=Module._PyType_GenericAlloc=wasmExports.PyType_GenericAlloc)(t,e),_PyType_GenericNew=Module._PyType_GenericNew=(t,e,n)=>(_PyType_GenericNew=Module._PyType_GenericNew=wasmExports.PyType_GenericNew)(t,e,n),__Py_NewReference=Module.__Py_NewReference=t=>(__Py_NewReference=Module.__Py_NewReference=wasmExports._Py_NewReference)(t),_PyObject_Calloc=Module._PyObject_Calloc=(t,e)=>(_PyObject_Calloc=Module._PyObject_Calloc=wasmExports.PyObject_Calloc)(t,e),_PyBytes_FromString=Module._PyBytes_FromString=t=>(_PyBytes_FromString=Module._PyBytes_FromString=wasmExports.PyBytes_FromString)(t),_PyBytes_FromFormatV=Module._PyBytes_FromFormatV=(t,e)=>(_PyBytes_FromFormatV=Module._PyBytes_FromFormatV=wasmExports.PyBytes_FromFormatV)(t,e),__PyBytesWriter_Resize=Module.__PyBytesWriter_Resize=(t,e,n)=>(__PyBytesWriter_Resize=Module.__PyBytesWriter_Resize=wasmExports._PyBytesWriter_Resize)(t,e,n),__PyBytesWriter_Finish=Module.__PyBytesWriter_Finish=(t,e)=>(__PyBytesWriter_Finish=Module.__PyBytesWriter_Finish=wasmExports._PyBytesWriter_Finish)(t,e),__PyBytesWriter_Init=Module.__PyBytesWriter_Init=t=>(__PyBytesWriter_Init=Module.__PyBytesWriter_Init=wasmExports._PyBytesWriter_Init)(t),__PyBytesWriter_Alloc=Module.__PyBytesWriter_Alloc=(t,e)=>(__PyBytesWriter_Alloc=Module.__PyBytesWriter_Alloc=wasmExports._PyBytesWriter_Alloc)(t,e),__PyBytesWriter_WriteBytes=Module.__PyBytesWriter_WriteBytes=(t,e,n,_)=>(__PyBytesWriter_WriteBytes=Module.__PyBytesWriter_WriteBytes=wasmExports._PyBytesWriter_WriteBytes)(t,e,n,_),__PyBytes_Resize=Module.__PyBytes_Resize=(t,e)=>(__PyBytes_Resize=Module.__PyBytes_Resize=wasmExports._PyBytes_Resize)(t,e),__PyBytesWriter_Dealloc=Module.__PyBytesWriter_Dealloc=t=>(__PyBytesWriter_Dealloc=Module.__PyBytesWriter_Dealloc=wasmExports._PyBytesWriter_Dealloc)(t),_PyBytes_FromFormat=Module._PyBytes_FromFormat=(t,e)=>(_PyBytes_FromFormat=Module._PyBytes_FromFormat=wasmExports.PyBytes_FromFormat)(t,e),_PyObject_ASCII=Module._PyObject_ASCII=t=>(_PyObject_ASCII=Module._PyObject_ASCII=wasmExports.PyObject_ASCII)(t),__PyLong_FormatBytesWriter=Module.__PyLong_FormatBytesWriter=(t,e,n,_,r)=>(__PyLong_FormatBytesWriter=Module.__PyLong_FormatBytesWriter=wasmExports._PyLong_FormatBytesWriter)(t,e,n,_,r),__PyUnicode_FormatLong=Module.__PyUnicode_FormatLong=(t,e,n,_)=>(__PyUnicode_FormatLong=Module.__PyUnicode_FormatLong=wasmExports._PyUnicode_FormatLong)(t,e,n,_),_PyOS_double_to_string=Module._PyOS_double_to_string=(t,e,n,_,r)=>(_PyOS_double_to_string=Module._PyOS_double_to_string=wasmExports.PyOS_double_to_string)(t,e,n,_,r),__PyBytesWriter_Prepare=Module.__PyBytesWriter_Prepare=(t,e,n)=>(__PyBytesWriter_Prepare=Module.__PyBytesWriter_Prepare=wasmExports._PyBytesWriter_Prepare)(t,e,n),_PyBytes_DecodeEscape=Module._PyBytes_DecodeEscape=(t,e,n,_,r)=>(_PyBytes_DecodeEscape=Module._PyBytes_DecodeEscape=wasmExports.PyBytes_DecodeEscape)(t,e,n,_,r),_PyBytes_Size=Module._PyBytes_Size=t=>(_PyBytes_Size=Module._PyBytes_Size=wasmExports.PyBytes_Size)(t),__PyBytes_Find=Module.__PyBytes_Find=(t,e,n,_,r)=>(__PyBytes_Find=Module.__PyBytes_Find=wasmExports._PyBytes_Find)(t,e,n,_,r),__PyBytes_ReverseFind=Module.__PyBytes_ReverseFind=(t,e,n,_,r)=>(__PyBytes_ReverseFind=Module.__PyBytes_ReverseFind=wasmExports._PyBytes_ReverseFind)(t,e,n,_,r),_PyBytes_Repr=Module._PyBytes_Repr=(t,e)=>(_PyBytes_Repr=Module._PyBytes_Repr=wasmExports.PyBytes_Repr)(t,e),__PyBytes_Join=Module.__PyBytes_Join=(t,e)=>(__PyBytes_Join=Module.__PyBytes_Join=wasmExports._PyBytes_Join)(t,e),_PyBytes_FromObject=Module._PyBytes_FromObject=t=>(_PyBytes_FromObject=Module._PyBytes_FromObject=wasmExports.PyBytes_FromObject)(t),_PyErr_BadArgument=Module._PyErr_BadArgument=()=>(_PyErr_BadArgument=Module._PyErr_BadArgument=wasmExports.PyErr_BadArgument)(),_PyBytes_Concat=Module._PyBytes_Concat=(t,e)=>(_PyBytes_Concat=Module._PyBytes_Concat=wasmExports.PyBytes_Concat)(t,e),__PyErr_FormatFromCauseTstate=Module.__PyErr_FormatFromCauseTstate=(t,e,n,_)=>(__PyErr_FormatFromCauseTstate=Module.__PyErr_FormatFromCauseTstate=wasmExports._PyErr_FormatFromCauseTstate)(t,e,n,_),__Py_FatalErrorFormat=Module.__Py_FatalErrorFormat=(t,e,n)=>(__Py_FatalErrorFormat=Module.__Py_FatalErrorFormat=wasmExports._Py_FatalErrorFormat)(t,e,n),__PyObject_FastCallDictTstate=Module.__PyObject_FastCallDictTstate=(t,e,n,_,r)=>(__PyObject_FastCallDictTstate=Module.__PyObject_FastCallDictTstate=wasmExports._PyObject_FastCallDictTstate)(t,e,n,_,r),_PyVectorcall_Function=Module._PyVectorcall_Function=t=>(_PyVectorcall_Function=Module._PyVectorcall_Function=wasmExports.PyVectorcall_Function)(t),__PyErr_NoMemory=Module.__PyErr_NoMemory=t=>(__PyErr_NoMemory=Module.__PyErr_NoMemory=wasmExports._PyErr_NoMemory)(t),_PyObject_VectorcallDict=Module._PyObject_VectorcallDict=(t,e,n,_)=>(_PyObject_VectorcallDict=Module._PyObject_VectorcallDict=wasmExports.PyObject_VectorcallDict)(t,e,n,_),__PyStack_AsDict=Module.__PyStack_AsDict=(t,e)=>(__PyStack_AsDict=Module.__PyStack_AsDict=wasmExports._PyStack_AsDict)(t,e),__PyObject_Call=Module.__PyObject_Call=(t,e,n,_)=>(__PyObject_Call=Module.__PyObject_Call=wasmExports._PyObject_Call)(t,e,n,_),_PyObject_Call=Module._PyObject_Call=(t,e,n)=>(_PyObject_Call=Module._PyObject_Call=wasmExports.PyObject_Call)(t,e,n),_PyCFunction_Call=Module._PyCFunction_Call=(t,e,n)=>(_PyCFunction_Call=Module._PyCFunction_Call=wasmExports.PyCFunction_Call)(t,e,n),__PyFunction_Vectorcall=Module.__PyFunction_Vectorcall=(t,e,n,_)=>(__PyFunction_Vectorcall=Module.__PyFunction_Vectorcall=wasmExports._PyFunction_Vectorcall)(t,e,n,_),_PyEval_CallObjectWithKeywords=Module._PyEval_CallObjectWithKeywords=(t,e,n)=>(_PyEval_CallObjectWithKeywords=Module._PyEval_CallObjectWithKeywords=wasmExports.PyEval_CallObjectWithKeywords)(t,e,n),_PyObject_CallObject=Module._PyObject_CallObject=(t,e)=>(_PyObject_CallObject=Module._PyObject_CallObject=wasmExports.PyObject_CallObject)(t,e),__PyObject_Call_Prepend=Module.__PyObject_Call_Prepend=(t,e,n,_,r)=>(__PyObject_Call_Prepend=Module.__PyObject_Call_Prepend=wasmExports._PyObject_Call_Prepend)(t,e,n,_,r),_PyObject_CallFunction=Module._PyObject_CallFunction=(t,e,n)=>(_PyObject_CallFunction=Module._PyObject_CallFunction=wasmExports.PyObject_CallFunction)(t,e,n),__Py_VaBuildStack_SizeT=Module.__Py_VaBuildStack_SizeT=(t,e,n,_,r)=>(__Py_VaBuildStack_SizeT=Module.__Py_VaBuildStack_SizeT=wasmExports._Py_VaBuildStack_SizeT)(t,e,n,_,r),__Py_VaBuildStack=Module.__Py_VaBuildStack=(t,e,n,_,r)=>(__Py_VaBuildStack=Module.__Py_VaBuildStack=wasmExports._Py_VaBuildStack)(t,e,n,_,r),_PyEval_CallFunction=Module._PyEval_CallFunction=(t,e,n)=>(_PyEval_CallFunction=Module._PyEval_CallFunction=wasmExports.PyEval_CallFunction)(t,e,n),__PyObject_CallFunction_SizeT=Module.__PyObject_CallFunction_SizeT=(t,e,n)=>(__PyObject_CallFunction_SizeT=Module.__PyObject_CallFunction_SizeT=wasmExports._PyObject_CallFunction_SizeT)(t,e,n),_PyObject_CallMethod=Module._PyObject_CallMethod=(t,e,n,_)=>(_PyObject_CallMethod=Module._PyObject_CallMethod=wasmExports.PyObject_CallMethod)(t,e,n,_),_PyCallable_Check=Module._PyCallable_Check=t=>(_PyCallable_Check=Module._PyCallable_Check=wasmExports.PyCallable_Check)(t),_PyEval_CallMethod=Module._PyEval_CallMethod=(t,e,n,_)=>(_PyEval_CallMethod=Module._PyEval_CallMethod=wasmExports.PyEval_CallMethod)(t,e,n,_),__PyObject_CallMethodId=Module.__PyObject_CallMethodId=(t,e,n,_)=>(__PyObject_CallMethodId=Module.__PyObject_CallMethodId=wasmExports._PyObject_CallMethodId)(t,e,n,_),__PyObject_CallMethod_SizeT=Module.__PyObject_CallMethod_SizeT=(t,e,n,_)=>(__PyObject_CallMethod_SizeT=Module.__PyObject_CallMethod_SizeT=wasmExports._PyObject_CallMethod_SizeT)(t,e,n,_),__PyObject_CallMethodId_SizeT=Module.__PyObject_CallMethodId_SizeT=(t,e,n,_)=>(__PyObject_CallMethodId_SizeT=Module.__PyObject_CallMethodId_SizeT=wasmExports._PyObject_CallMethodId_SizeT)(t,e,n,_),_PyObject_CallMethodObjArgs=Module._PyObject_CallMethodObjArgs=(t,e,n)=>(_PyObject_CallMethodObjArgs=Module._PyObject_CallMethodObjArgs=wasmExports.PyObject_CallMethodObjArgs)(t,e,n),_PyCapsule_New=Module._PyCapsule_New=(t,e,n)=>(_PyCapsule_New=Module._PyCapsule_New=wasmExports.PyCapsule_New)(t,e,n),_PyCapsule_IsValid=Module._PyCapsule_IsValid=(t,e)=>(_PyCapsule_IsValid=Module._PyCapsule_IsValid=wasmExports.PyCapsule_IsValid)(t,e),_PyCapsule_GetPointer=Module._PyCapsule_GetPointer=(t,e)=>(_PyCapsule_GetPointer=Module._PyCapsule_GetPointer=wasmExports.PyCapsule_GetPointer)(t,e),_PyCapsule_GetName=Module._PyCapsule_GetName=t=>(_PyCapsule_GetName=Module._PyCapsule_GetName=wasmExports.PyCapsule_GetName)(t),_PyCapsule_GetDestructor=Module._PyCapsule_GetDestructor=t=>(_PyCapsule_GetDestructor=Module._PyCapsule_GetDestructor=wasmExports.PyCapsule_GetDestructor)(t),_PyCapsule_GetContext=Module._PyCapsule_GetContext=t=>(_PyCapsule_GetContext=Module._PyCapsule_GetContext=wasmExports.PyCapsule_GetContext)(t),_PyCapsule_SetPointer=Module._PyCapsule_SetPointer=(t,e)=>(_PyCapsule_SetPointer=Module._PyCapsule_SetPointer=wasmExports.PyCapsule_SetPointer)(t,e),_PyCapsule_SetName=Module._PyCapsule_SetName=(t,e)=>(_PyCapsule_SetName=Module._PyCapsule_SetName=wasmExports.PyCapsule_SetName)(t,e),_PyCapsule_SetDestructor=Module._PyCapsule_SetDestructor=(t,e)=>(_PyCapsule_SetDestructor=Module._PyCapsule_SetDestructor=wasmExports.PyCapsule_SetDestructor)(t,e),_PyCapsule_SetContext=Module._PyCapsule_SetContext=(t,e)=>(_PyCapsule_SetContext=Module._PyCapsule_SetContext=wasmExports.PyCapsule_SetContext)(t,e),_PyCapsule_Import=Module._PyCapsule_Import=(t,e)=>(_PyCapsule_Import=Module._PyCapsule_Import=wasmExports.PyCapsule_Import)(t,e),_PyCell_New=Module._PyCell_New=t=>(_PyCell_New=Module._PyCell_New=wasmExports.PyCell_New)(t),_PyCell_Get=Module._PyCell_Get=t=>(_PyCell_Get=Module._PyCell_Get=wasmExports.PyCell_Get)(t),_PyCell_Set=Module._PyCell_Set=(t,e)=>(_PyCell_Set=Module._PyCell_Set=wasmExports.PyCell_Set)(t,e),_PyObject_RichCompare=Module._PyObject_RichCompare=(t,e,n)=>(_PyObject_RichCompare=Module._PyObject_RichCompare=wasmExports.PyObject_RichCompare)(t,e,n),_PyMethod_Function=Module._PyMethod_Function=t=>(_PyMethod_Function=Module._PyMethod_Function=wasmExports.PyMethod_Function)(t),_PyMethod_Self=Module._PyMethod_Self=t=>(_PyMethod_Self=Module._PyMethod_Self=wasmExports.PyMethod_Self)(t),_PyMethod_New=Module._PyMethod_New=(t,e)=>(_PyMethod_New=Module._PyMethod_New=wasmExports.PyMethod_New)(t,e),_PyObject_ClearWeakRefs=Module._PyObject_ClearWeakRefs=t=>(_PyObject_ClearWeakRefs=Module._PyObject_ClearWeakRefs=wasmExports.PyObject_ClearWeakRefs)(t),__Py_HashPointer=Module.__Py_HashPointer=t=>(__Py_HashPointer=Module.__Py_HashPointer=wasmExports._Py_HashPointer)(t),_PyObject_Hash=Module._PyObject_Hash=t=>(_PyObject_Hash=Module._PyObject_Hash=wasmExports.PyObject_Hash)(t),__PyType_Lookup=Module.__PyType_Lookup=(t,e)=>(__PyType_Lookup=Module.__PyType_Lookup=wasmExports._PyType_Lookup)(t,e),_PyInstanceMethod_New=Module._PyInstanceMethod_New=t=>(_PyInstanceMethod_New=Module._PyInstanceMethod_New=wasmExports.PyInstanceMethod_New)(t),_PyInstanceMethod_Function=Module._PyInstanceMethod_Function=t=>(_PyInstanceMethod_Function=Module._PyInstanceMethod_Function=wasmExports.PyInstanceMethod_Function)(t),__PyCode_Validate=Module.__PyCode_Validate=t=>(__PyCode_Validate=Module.__PyCode_Validate=wasmExports._PyCode_Validate)(t),__PyCode_New=Module.__PyCode_New=t=>(__PyCode_New=Module.__PyCode_New=wasmExports._PyCode_New)(t),__PyObject_NewVar=Module.__PyObject_NewVar=(t,e)=>(__PyObject_NewVar=Module.__PyObject_NewVar=wasmExports._PyObject_NewVar)(t,e),_PyFrozenSet_New=Module._PyFrozenSet_New=t=>(_PyFrozenSet_New=Module._PyFrozenSet_New=wasmExports.PyFrozenSet_New)(t),_PyCode_NewWithPosOnlyArgs=Module._PyCode_NewWithPosOnlyArgs=(t,e,n,_,r,a,o,l,p,c,I,A,m,E,f,R,h,w)=>(_PyCode_NewWithPosOnlyArgs=Module._PyCode_NewWithPosOnlyArgs=wasmExports.PyCode_NewWithPosOnlyArgs)(t,e,n,_,r,a,o,l,p,c,I,A,m,E,f,R,h,w),_PyUnicode_Compare=Module._PyUnicode_Compare=(t,e)=>(_PyUnicode_Compare=Module._PyUnicode_Compare=wasmExports.PyUnicode_Compare)(t,e),_PyCode_New=Module._PyCode_New=(t,e,n,_,r,a,o,l,p,c,I,A,m,E,f,R,h)=>(_PyCode_New=Module._PyCode_New=wasmExports.PyCode_New)(t,e,n,_,r,a,o,l,p,c,I,A,m,E,f,R,h),_PyCode_NewEmpty=Module._PyCode_NewEmpty=(t,e,n)=>(_PyCode_NewEmpty=Module._PyCode_NewEmpty=wasmExports.PyCode_NewEmpty)(t,e,n),_PyUnicode_DecodeFSDefault=Module._PyUnicode_DecodeFSDefault=t=>(_PyUnicode_DecodeFSDefault=Module._PyUnicode_DecodeFSDefault=wasmExports.PyUnicode_DecodeFSDefault)(t),_PyCode_Addr2Line=Module._PyCode_Addr2Line=(t,e)=>(_PyCode_Addr2Line=Module._PyCode_Addr2Line=wasmExports.PyCode_Addr2Line)(t,e),__PyCode_CheckLineNumber=Module.__PyCode_CheckLineNumber=(t,e)=>(__PyCode_CheckLineNumber=Module.__PyCode_CheckLineNumber=wasmExports._PyCode_CheckLineNumber)(t,e),_PyCode_Addr2Location=Module._PyCode_Addr2Location=(t,e,n,_,r,a)=>(_PyCode_Addr2Location=Module._PyCode_Addr2Location=wasmExports.PyCode_Addr2Location)(t,e,n,_,r,a),__PyCode_GetExtra=Module.__PyCode_GetExtra=(t,e,n)=>(__PyCode_GetExtra=Module.__PyCode_GetExtra=wasmExports._PyCode_GetExtra)(t,e,n),__PyCode_SetExtra=Module.__PyCode_SetExtra=(t,e,n)=>(__PyCode_SetExtra=Module.__PyCode_SetExtra=wasmExports._PyCode_SetExtra)(t,e,n),_PyCode_GetVarnames=Module._PyCode_GetVarnames=t=>(_PyCode_GetVarnames=Module._PyCode_GetVarnames=wasmExports.PyCode_GetVarnames)(t),_PyCode_GetCellvars=Module._PyCode_GetCellvars=t=>(_PyCode_GetCellvars=Module._PyCode_GetCellvars=wasmExports.PyCode_GetCellvars)(t),_PyCode_GetFreevars=Module._PyCode_GetFreevars=t=>(_PyCode_GetFreevars=Module._PyCode_GetFreevars=wasmExports.PyCode_GetFreevars)(t),_PyCode_GetCode=Module._PyCode_GetCode=t=>(_PyCode_GetCode=Module._PyCode_GetCode=wasmExports.PyCode_GetCode)(t),__PyCode_ConstantKey=Module.__PyCode_ConstantKey=t=>(__PyCode_ConstantKey=Module.__PyCode_ConstantKey=wasmExports._PyCode_ConstantKey)(t),_PyComplex_AsCComplex=Module._PyComplex_AsCComplex=(t,e)=>(_PyComplex_AsCComplex=Module._PyComplex_AsCComplex=wasmExports.PyComplex_AsCComplex)(t,e),__PySet_NextEntry=Module.__PySet_NextEntry=(t,e,n,_)=>(__PySet_NextEntry=Module.__PySet_NextEntry=wasmExports._PySet_NextEntry)(t,e,n,_),_PyLong_FromVoidPtr=Module._PyLong_FromVoidPtr=t=>(_PyLong_FromVoidPtr=Module._PyLong_FromVoidPtr=wasmExports.PyLong_FromVoidPtr)(t),__PyUnicode_Copy=Module.__PyUnicode_Copy=t=>(__PyUnicode_Copy=Module.__PyUnicode_Copy=wasmExports._PyUnicode_Copy)(t),__Py_c_sum=Module.__Py_c_sum=(t,e,n)=>(__Py_c_sum=Module.__Py_c_sum=wasmExports._Py_c_sum)(t,e,n),__Py_c_diff=Module.__Py_c_diff=(t,e,n)=>(__Py_c_diff=Module.__Py_c_diff=wasmExports._Py_c_diff)(t,e,n),__Py_c_neg=Module.__Py_c_neg=(t,e)=>(__Py_c_neg=Module.__Py_c_neg=wasmExports._Py_c_neg)(t,e),__Py_c_prod=Module.__Py_c_prod=(t,e,n)=>(__Py_c_prod=Module.__Py_c_prod=wasmExports._Py_c_prod)(t,e,n),__Py_c_quot=Module.__Py_c_quot=(t,e,n)=>(__Py_c_quot=Module.__Py_c_quot=wasmExports._Py_c_quot)(t,e,n),__Py_c_pow=Module.__Py_c_pow=(t,e,n)=>(__Py_c_pow=Module.__Py_c_pow=wasmExports._Py_c_pow)(t,e,n),_hypot=Module._hypot=(t,e)=>(_hypot=Module._hypot=wasmExports.hypot)(t,e),_atan2=Module._atan2=(t,e)=>(_atan2=Module._atan2=wasmExports.atan2)(t,e),_pow=Module._pow=(t,e)=>(_pow=Module._pow=wasmExports.pow)(t,e),_log=Module._log=t=>(_log=Module._log=wasmExports.log)(t),_exp=Module._exp=t=>(_exp=Module._exp=wasmExports.exp)(t),_sin=Module._sin=t=>(_sin=Module._sin=wasmExports.sin)(t),_cos=Module._cos=t=>(_cos=Module._cos=wasmExports.cos)(t),__Py_c_abs=Module.__Py_c_abs=t=>(__Py_c_abs=Module.__Py_c_abs=wasmExports._Py_c_abs)(t),_PyComplex_FromDoubles=Module._PyComplex_FromDoubles=(t,e)=>(_PyComplex_FromDoubles=Module._PyComplex_FromDoubles=wasmExports.PyComplex_FromDoubles)(t,e),_PyComplex_RealAsDouble=Module._PyComplex_RealAsDouble=t=>(_PyComplex_RealAsDouble=Module._PyComplex_RealAsDouble=wasmExports.PyComplex_RealAsDouble)(t),_PyComplex_ImagAsDouble=Module._PyComplex_ImagAsDouble=t=>(_PyComplex_ImagAsDouble=Module._PyComplex_ImagAsDouble=wasmExports.PyComplex_ImagAsDouble)(t),__Py_HashDouble=Module.__Py_HashDouble=(t,e)=>(__Py_HashDouble=Module.__Py_HashDouble=wasmExports._Py_HashDouble)(t,e),__PyUnicode_TransformDecimalAndSpaceToASCII=Module.__PyUnicode_TransformDecimalAndSpaceToASCII=t=>(__PyUnicode_TransformDecimalAndSpaceToASCII=Module.__PyUnicode_TransformDecimalAndSpaceToASCII=wasmExports._PyUnicode_TransformDecimalAndSpaceToASCII)(t),__Py_string_to_number_with_underscores=Module.__Py_string_to_number_with_underscores=(t,e,n,_,r,a)=>(__Py_string_to_number_with_underscores=Module.__Py_string_to_number_with_underscores=wasmExports._Py_string_to_number_with_underscores)(t,e,n,_,r,a),__PyUnicodeWriter_Init=Module.__PyUnicodeWriter_Init=t=>(__PyUnicodeWriter_Init=Module.__PyUnicodeWriter_Init=wasmExports._PyUnicodeWriter_Init)(t),__PyUnicodeWriter_Dealloc=Module.__PyUnicodeWriter_Dealloc=t=>(__PyUnicodeWriter_Dealloc=Module.__PyUnicodeWriter_Dealloc=wasmExports._PyUnicodeWriter_Dealloc)(t),__PyUnicodeWriter_Finish=Module.__PyUnicodeWriter_Finish=t=>(__PyUnicodeWriter_Finish=Module.__PyUnicodeWriter_Finish=wasmExports._PyUnicodeWriter_Finish)(t),_PyCMethod_New=Module._PyCMethod_New=(t,e,n,_)=>(_PyCMethod_New=Module._PyCMethod_New=wasmExports.PyCMethod_New)(t,e,n,_),_PyMember_GetOne=Module._PyMember_GetOne=(t,e)=>(_PyMember_GetOne=Module._PyMember_GetOne=wasmExports.PyMember_GetOne)(t,e),_PyMember_SetOne=Module._PyMember_SetOne=(t,e,n)=>(_PyMember_SetOne=Module._PyMember_SetOne=wasmExports.PyMember_SetOne)(t,e,n),_PyTuple_GetSlice=Module._PyTuple_GetSlice=(t,e,n)=>(_PyTuple_GetSlice=Module._PyTuple_GetSlice=wasmExports.PyTuple_GetSlice)(t,e,n),_PyDescr_NewMethod=Module._PyDescr_NewMethod=(t,e)=>(_PyDescr_NewMethod=Module._PyDescr_NewMethod=wasmExports.PyDescr_NewMethod)(t,e),__PyObject_FunctionStr=Module.__PyObject_FunctionStr=t=>(__PyObject_FunctionStr=Module.__PyObject_FunctionStr=wasmExports._PyObject_FunctionStr)(t),_PyDescr_NewClassMethod=Module._PyDescr_NewClassMethod=(t,e)=>(_PyDescr_NewClassMethod=Module._PyDescr_NewClassMethod=wasmExports.PyDescr_NewClassMethod)(t,e),_PyDescr_NewMember=Module._PyDescr_NewMember=(t,e)=>(_PyDescr_NewMember=Module._PyDescr_NewMember=wasmExports.PyDescr_NewMember)(t,e),_PyDescr_NewGetSet=Module._PyDescr_NewGetSet=(t,e)=>(_PyDescr_NewGetSet=Module._PyDescr_NewGetSet=wasmExports.PyDescr_NewGetSet)(t,e),_PyDescr_NewWrapper=Module._PyDescr_NewWrapper=(t,e,n)=>(_PyDescr_NewWrapper=Module._PyDescr_NewWrapper=wasmExports.PyDescr_NewWrapper)(t,e,n),_PyDescr_IsData=Module._PyDescr_IsData=t=>(_PyDescr_IsData=Module._PyDescr_IsData=wasmExports.PyDescr_IsData)(t),_PyDictProxy_New=Module._PyDictProxy_New=t=>(_PyDictProxy_New=Module._PyDictProxy_New=wasmExports.PyDictProxy_New)(t),_PyObject_GC_UnTrack=Module._PyObject_GC_UnTrack=t=>(_PyObject_GC_UnTrack=Module._PyObject_GC_UnTrack=wasmExports.PyObject_GC_UnTrack)(t),__PyTrash_cond=Module.__PyTrash_cond=(t,e)=>(__PyTrash_cond=Module.__PyTrash_cond=wasmExports._PyTrash_cond)(t,e),__PyTrash_begin=Module.__PyTrash_begin=(t,e)=>(__PyTrash_begin=Module.__PyTrash_begin=wasmExports._PyTrash_begin)(t,e),__PyTrash_end=Module.__PyTrash_end=t=>(__PyTrash_end=Module.__PyTrash_end=wasmExports._PyTrash_end)(t),_PyWrapper_New=Module._PyWrapper_New=(t,e)=>(_PyWrapper_New=Module._PyWrapper_New=wasmExports.PyWrapper_New)(t,e),_PyType_GetQualName=Module._PyType_GetQualName=t=>(_PyType_GetQualName=Module._PyType_GetQualName=wasmExports.PyType_GetQualName)(t),__PyType_GetDocFromInternalDoc=Module.__PyType_GetDocFromInternalDoc=(t,e)=>(__PyType_GetDocFromInternalDoc=Module.__PyType_GetDocFromInternalDoc=wasmExports._PyType_GetDocFromInternalDoc)(t,e),__PyType_GetTextSignatureFromInternalDoc=Module.__PyType_GetTextSignatureFromInternalDoc=(t,e)=>(__PyType_GetTextSignatureFromInternalDoc=Module.__PyType_GetTextSignatureFromInternalDoc=wasmExports._PyType_GetTextSignatureFromInternalDoc)(t,e),_PyDict_Contains=Module._PyDict_Contains=(t,e)=>(_PyDict_Contains=Module._PyDict_Contains=wasmExports.PyDict_Contains)(t,e),__PyArg_UnpackStack=Module.__PyArg_UnpackStack=(t,e,n,_,r,a)=>(__PyArg_UnpackStack=Module.__PyArg_UnpackStack=wasmExports._PyArg_UnpackStack)(t,e,n,_,r,a),__PyObject_IsAbstract=Module.__PyObject_IsAbstract=t=>(__PyObject_IsAbstract=Module.__PyObject_IsAbstract=wasmExports._PyObject_IsAbstract)(t),__PyUnicode_EqualToASCIIString=Module.__PyUnicode_EqualToASCIIString=(t,e)=>(__PyUnicode_EqualToASCIIString=Module.__PyUnicode_EqualToASCIIString=wasmExports._PyUnicode_EqualToASCIIString)(t,e),_PyException_GetCause=Module._PyException_GetCause=t=>(_PyException_GetCause=Module._PyException_GetCause=wasmExports.PyException_GetCause)(t),_PyException_SetCause=Module._PyException_SetCause=(t,e)=>(_PyException_SetCause=Module._PyException_SetCause=wasmExports.PyException_SetCause)(t,e),_PyException_GetContext=Module._PyException_GetContext=t=>(_PyException_GetContext=Module._PyException_GetContext=wasmExports.PyException_GetContext)(t),_PyException_SetContext=Module._PyException_SetContext=(t,e)=>(_PyException_SetContext=Module._PyException_SetContext=wasmExports.PyException_SetContext)(t,e),_PyExceptionClass_Name=Module._PyExceptionClass_Name=t=>(_PyExceptionClass_Name=Module._PyExceptionClass_Name=wasmExports.PyExceptionClass_Name)(t),_PyUnicodeEncodeError_GetEncoding=Module._PyUnicodeEncodeError_GetEncoding=t=>(_PyUnicodeEncodeError_GetEncoding=Module._PyUnicodeEncodeError_GetEncoding=wasmExports.PyUnicodeEncodeError_GetEncoding)(t),_PyUnicodeDecodeError_GetEncoding=Module._PyUnicodeDecodeError_GetEncoding=t=>(_PyUnicodeDecodeError_GetEncoding=Module._PyUnicodeDecodeError_GetEncoding=wasmExports.PyUnicodeDecodeError_GetEncoding)(t),_PyUnicodeEncodeError_GetObject=Module._PyUnicodeEncodeError_GetObject=t=>(_PyUnicodeEncodeError_GetObject=Module._PyUnicodeEncodeError_GetObject=wasmExports.PyUnicodeEncodeError_GetObject)(t),_PyUnicodeDecodeError_GetObject=Module._PyUnicodeDecodeError_GetObject=t=>(_PyUnicodeDecodeError_GetObject=Module._PyUnicodeDecodeError_GetObject=wasmExports.PyUnicodeDecodeError_GetObject)(t),_PyUnicodeTranslateError_GetObject=Module._PyUnicodeTranslateError_GetObject=t=>(_PyUnicodeTranslateError_GetObject=Module._PyUnicodeTranslateError_GetObject=wasmExports.PyUnicodeTranslateError_GetObject)(t),_PyUnicodeEncodeError_GetStart=Module._PyUnicodeEncodeError_GetStart=(t,e)=>(_PyUnicodeEncodeError_GetStart=Module._PyUnicodeEncodeError_GetStart=wasmExports.PyUnicodeEncodeError_GetStart)(t,e),_PyUnicodeDecodeError_GetStart=Module._PyUnicodeDecodeError_GetStart=(t,e)=>(_PyUnicodeDecodeError_GetStart=Module._PyUnicodeDecodeError_GetStart=wasmExports.PyUnicodeDecodeError_GetStart)(t,e),_PyUnicodeTranslateError_GetStart=Module._PyUnicodeTranslateError_GetStart=(t,e)=>(_PyUnicodeTranslateError_GetStart=Module._PyUnicodeTranslateError_GetStart=wasmExports.PyUnicodeTranslateError_GetStart)(t,e),_PyUnicodeEncodeError_SetStart=Module._PyUnicodeEncodeError_SetStart=(t,e)=>(_PyUnicodeEncodeError_SetStart=Module._PyUnicodeEncodeError_SetStart=wasmExports.PyUnicodeEncodeError_SetStart)(t,e),_PyUnicodeDecodeError_SetStart=Module._PyUnicodeDecodeError_SetStart=(t,e)=>(_PyUnicodeDecodeError_SetStart=Module._PyUnicodeDecodeError_SetStart=wasmExports.PyUnicodeDecodeError_SetStart)(t,e),_PyUnicodeTranslateError_SetStart=Module._PyUnicodeTranslateError_SetStart=(t,e)=>(_PyUnicodeTranslateError_SetStart=Module._PyUnicodeTranslateError_SetStart=wasmExports.PyUnicodeTranslateError_SetStart)(t,e),_PyUnicodeEncodeError_GetEnd=Module._PyUnicodeEncodeError_GetEnd=(t,e)=>(_PyUnicodeEncodeError_GetEnd=Module._PyUnicodeEncodeError_GetEnd=wasmExports.PyUnicodeEncodeError_GetEnd)(t,e),_PyUnicodeDecodeError_GetEnd=Module._PyUnicodeDecodeError_GetEnd=(t,e)=>(_PyUnicodeDecodeError_GetEnd=Module._PyUnicodeDecodeError_GetEnd=wasmExports.PyUnicodeDecodeError_GetEnd)(t,e),_PyUnicodeTranslateError_GetEnd=Module._PyUnicodeTranslateError_GetEnd=(t,e)=>(_PyUnicodeTranslateError_GetEnd=Module._PyUnicodeTranslateError_GetEnd=wasmExports.PyUnicodeTranslateError_GetEnd)(t,e),_PyUnicodeEncodeError_SetEnd=Module._PyUnicodeEncodeError_SetEnd=(t,e)=>(_PyUnicodeEncodeError_SetEnd=Module._PyUnicodeEncodeError_SetEnd=wasmExports.PyUnicodeEncodeError_SetEnd)(t,e),_PyUnicodeDecodeError_SetEnd=Module._PyUnicodeDecodeError_SetEnd=(t,e)=>(_PyUnicodeDecodeError_SetEnd=Module._PyUnicodeDecodeError_SetEnd=wasmExports.PyUnicodeDecodeError_SetEnd)(t,e),_PyUnicodeTranslateError_SetEnd=Module._PyUnicodeTranslateError_SetEnd=(t,e)=>(_PyUnicodeTranslateError_SetEnd=Module._PyUnicodeTranslateError_SetEnd=wasmExports.PyUnicodeTranslateError_SetEnd)(t,e),_PyUnicodeEncodeError_GetReason=Module._PyUnicodeEncodeError_GetReason=t=>(_PyUnicodeEncodeError_GetReason=Module._PyUnicodeEncodeError_GetReason=wasmExports.PyUnicodeEncodeError_GetReason)(t),_PyUnicodeDecodeError_GetReason=Module._PyUnicodeDecodeError_GetReason=t=>(_PyUnicodeDecodeError_GetReason=Module._PyUnicodeDecodeError_GetReason=wasmExports.PyUnicodeDecodeError_GetReason)(t),_PyUnicodeTranslateError_GetReason=Module._PyUnicodeTranslateError_GetReason=t=>(_PyUnicodeTranslateError_GetReason=Module._PyUnicodeTranslateError_GetReason=wasmExports.PyUnicodeTranslateError_GetReason)(t),_PyUnicodeEncodeError_SetReason=Module._PyUnicodeEncodeError_SetReason=(t,e)=>(_PyUnicodeEncodeError_SetReason=Module._PyUnicodeEncodeError_SetReason=wasmExports.PyUnicodeEncodeError_SetReason)(t,e),_PyUnicodeDecodeError_SetReason=Module._PyUnicodeDecodeError_SetReason=(t,e)=>(_PyUnicodeDecodeError_SetReason=Module._PyUnicodeDecodeError_SetReason=wasmExports.PyUnicodeDecodeError_SetReason)(t,e),_PyUnicodeTranslateError_SetReason=Module._PyUnicodeTranslateError_SetReason=(t,e)=>(_PyUnicodeTranslateError_SetReason=Module._PyUnicodeTranslateError_SetReason=wasmExports.PyUnicodeTranslateError_SetReason)(t,e),_PyUnicodeDecodeError_Create=Module._PyUnicodeDecodeError_Create=(t,e,n,_,r,a)=>(_PyUnicodeDecodeError_Create=Module._PyUnicodeDecodeError_Create=wasmExports.PyUnicodeDecodeError_Create)(t,e,n,_,r,a),__PyUnicodeTranslateError_Create=Module.__PyUnicodeTranslateError_Create=(t,e,n,_)=>(__PyUnicodeTranslateError_Create=Module.__PyUnicodeTranslateError_Create=wasmExports._PyUnicodeTranslateError_Create)(t,e,n,_),_PyModule_GetDict=Module._PyModule_GetDict=t=>(_PyModule_GetDict=Module._PyModule_GetDict=wasmExports.PyModule_GetDict)(t),_PyErr_NewException=Module._PyErr_NewException=(t,e,n)=>(_PyErr_NewException=Module._PyErr_NewException=wasmExports.PyErr_NewException)(t,e,n),__PyErr_TrySetFromCause=Module.__PyErr_TrySetFromCause=(t,e)=>(__PyErr_TrySetFromCause=Module.__PyErr_TrySetFromCause=wasmExports._PyErr_TrySetFromCause)(t,e),_PySet_Add=Module._PySet_Add=(t,e)=>(_PySet_Add=Module._PySet_Add=wasmExports.PySet_Add)(t,e),_PySet_Contains=Module._PySet_Contains=(t,e)=>(_PySet_Contains=Module._PySet_Contains=wasmExports.PySet_Contains)(t,e),_PyDict_Copy=Module._PyDict_Copy=t=>(_PyDict_Copy=Module._PyDict_Copy=wasmExports.PyDict_Copy)(t),_PyUnicode_ReadChar=Module._PyUnicode_ReadChar=(t,e)=>(_PyUnicode_ReadChar=Module._PyUnicode_ReadChar=wasmExports.PyUnicode_ReadChar)(t,e),_PyObject_GenericGetDict=Module._PyObject_GenericGetDict=(t,e)=>(_PyObject_GenericGetDict=Module._PyObject_GenericGetDict=wasmExports.PyObject_GenericGetDict)(t,e),_PyObject_GenericSetDict=Module._PyObject_GenericSetDict=(t,e,n)=>(_PyObject_GenericSetDict=Module._PyObject_GenericSetDict=wasmExports.PyObject_GenericSetDict)(t,e,n),__PyUnicodeWriter_WriteASCIIString=Module.__PyUnicodeWriter_WriteASCIIString=(t,e,n)=>(__PyUnicodeWriter_WriteASCIIString=Module.__PyUnicodeWriter_WriteASCIIString=wasmExports._PyUnicodeWriter_WriteASCIIString)(t,e,n),_PyObject_GC_Track=Module._PyObject_GC_Track=t=>(_PyObject_GC_Track=Module._PyObject_GC_Track=wasmExports.PyObject_GC_Track)(t),__PyUnicodeWriter_WriteStr=Module.__PyUnicodeWriter_WriteStr=(t,e)=>(__PyUnicodeWriter_WriteStr=Module.__PyUnicodeWriter_WriteStr=wasmExports._PyUnicodeWriter_WriteStr)(t,e),__PyGen_Finalize=Module.__PyGen_Finalize=t=>(__PyGen_Finalize=Module.__PyGen_Finalize=wasmExports._PyGen_Finalize)(t),_PyErr_WriteUnraisable=Module._PyErr_WriteUnraisable=t=>(_PyErr_WriteUnraisable=Module._PyErr_WriteUnraisable=wasmExports.PyErr_WriteUnraisable)(t),_PyObject_CallFinalizerFromDealloc=Module._PyObject_CallFinalizerFromDealloc=t=>(_PyObject_CallFinalizerFromDealloc=Module._PyObject_CallFinalizerFromDealloc=wasmExports.PyObject_CallFinalizerFromDealloc)(t),__PyObject_GC_NewVar=Module.__PyObject_GC_NewVar=(t,e)=>(__PyObject_GC_NewVar=Module.__PyObject_GC_NewVar=wasmExports._PyObject_GC_NewVar)(t,e),_PyGen_NewWithQualName=Module._PyGen_NewWithQualName=(t,e,n)=>(_PyGen_NewWithQualName=Module._PyGen_NewWithQualName=wasmExports.PyGen_NewWithQualName)(t,e,n),_PyFrame_GetCode=Module._PyFrame_GetCode=t=>(_PyFrame_GetCode=Module._PyFrame_GetCode=wasmExports.PyFrame_GetCode)(t),_PyGen_New=Module._PyGen_New=t=>(_PyGen_New=Module._PyGen_New=wasmExports.PyGen_New)(t),_PyCoro_New=Module._PyCoro_New=(t,e,n)=>(_PyCoro_New=Module._PyCoro_New=wasmExports.PyCoro_New)(t,e,n),_PyAsyncGen_New=Module._PyAsyncGen_New=(t,e,n)=>(_PyAsyncGen_New=Module._PyAsyncGen_New=wasmExports.PyAsyncGen_New)(t,e,n),__PyErr_ChainStackItem=Module.__PyErr_ChainStackItem=t=>(__PyErr_ChainStackItem=Module.__PyErr_ChainStackItem=wasmExports._PyErr_ChainStackItem)(t),__PyEval_EvalFrameDefault=Module.__PyEval_EvalFrameDefault=(t,e,n)=>(__PyEval_EvalFrameDefault=Module.__PyEval_EvalFrameDefault=wasmExports._PyEval_EvalFrameDefault)(t,e,n),_PyFile_FromFd=Module._PyFile_FromFd=(t,e,n,_,r,a,o,l)=>(_PyFile_FromFd=Module._PyFile_FromFd=wasmExports.PyFile_FromFd)(t,e,n,_,r,a,o,l),_PyFile_GetLine=Module._PyFile_GetLine=(t,e)=>(_PyFile_GetLine=Module._PyFile_GetLine=wasmExports.PyFile_GetLine)(t,e),_PyFile_WriteObject=Module._PyFile_WriteObject=(t,e,n)=>(_PyFile_WriteObject=Module._PyFile_WriteObject=wasmExports.PyFile_WriteObject)(t,e,n),_PyFile_WriteString=Module._PyFile_WriteString=(t,e)=>(_PyFile_WriteString=Module._PyFile_WriteString=wasmExports.PyFile_WriteString)(t,e),_PyObject_AsFileDescriptor=Module._PyObject_AsFileDescriptor=t=>(_PyObject_AsFileDescriptor=Module._PyObject_AsFileDescriptor=wasmExports.PyObject_AsFileDescriptor)(t),__PyLong_FileDescriptor_Converter=Module.__PyLong_FileDescriptor_Converter=(t,e)=>(__PyLong_FileDescriptor_Converter=Module.__PyLong_FileDescriptor_Converter=wasmExports._PyLong_FileDescriptor_Converter)(t,e),_flockfile=Module._flockfile=t=>(_flockfile=Module._flockfile=wasmExports.flockfile)(t),_getc_unlocked=Module._getc_unlocked=t=>(_getc_unlocked=Module._getc_unlocked=wasmExports.getc_unlocked)(t),_funlockfile=Module._funlockfile=t=>(_funlockfile=Module._funlockfile=wasmExports.funlockfile)(t),_PyFile_NewStdPrinter=Module._PyFile_NewStdPrinter=t=>(_PyFile_NewStdPrinter=Module._PyFile_NewStdPrinter=wasmExports.PyFile_NewStdPrinter)(t),_PyFile_SetOpenCodeHook=Module._PyFile_SetOpenCodeHook=(t,e)=>(_PyFile_SetOpenCodeHook=Module._PyFile_SetOpenCodeHook=wasmExports.PyFile_SetOpenCodeHook)(t,e),_Py_IsInitialized=Module._Py_IsInitialized=()=>(_Py_IsInitialized=Module._Py_IsInitialized=wasmExports.Py_IsInitialized)(),_PyFile_OpenCodeObject=Module._PyFile_OpenCodeObject=t=>(_PyFile_OpenCodeObject=Module._PyFile_OpenCodeObject=wasmExports.PyFile_OpenCodeObject)(t),_PyFile_OpenCode=Module._PyFile_OpenCode=t=>(_PyFile_OpenCode=Module._PyFile_OpenCode=wasmExports.PyFile_OpenCode)(t),__PyUnicode_AsUTF8String=Module.__PyUnicode_AsUTF8String=(t,e)=>(__PyUnicode_AsUTF8String=Module.__PyUnicode_AsUTF8String=wasmExports._PyUnicode_AsUTF8String)(t,e),__Py_write=Module.__Py_write=(t,e,n)=>(__Py_write=Module.__Py_write=wasmExports._Py_write)(t,e,n),_PyFloat_GetMax=Module._PyFloat_GetMax=()=>(_PyFloat_GetMax=Module._PyFloat_GetMax=wasmExports.PyFloat_GetMax)(),_PyFloat_GetMin=Module._PyFloat_GetMin=()=>(_PyFloat_GetMin=Module._PyFloat_GetMin=wasmExports.PyFloat_GetMin)(),_PyFloat_GetInfo=Module._PyFloat_GetInfo=()=>(_PyFloat_GetInfo=Module._PyFloat_GetInfo=wasmExports.PyFloat_GetInfo)(),_PyStructSequence_New=Module._PyStructSequence_New=t=>(_PyStructSequence_New=Module._PyStructSequence_New=wasmExports.PyStructSequence_New)(t),__PyUnicode_FromASCII=Module.__PyUnicode_FromASCII=(t,e)=>(__PyUnicode_FromASCII=Module.__PyUnicode_FromASCII=wasmExports._PyUnicode_FromASCII)(t,e),_frexp=Module._frexp=(t,e)=>(_frexp=Module._frexp=wasmExports.frexp)(t,e),_modf=Module._modf=(t,e)=>(_modf=Module._modf=wasmExports.modf)(t,e),_PyLong_FromDouble=Module._PyLong_FromDouble=t=>(_PyLong_FromDouble=Module._PyLong_FromDouble=wasmExports.PyLong_FromDouble)(t),__PyLong_Lshift=Module.__PyLong_Lshift=(t,e)=>(__PyLong_Lshift=Module.__PyLong_Lshift=wasmExports._PyLong_Lshift)(t,e),_PyStructSequence_InitType2=Module._PyStructSequence_InitType2=(t,e)=>(_PyStructSequence_InitType2=Module._PyStructSequence_InitType2=wasmExports.PyStructSequence_InitType2)(t,e),__PyFloat_DebugMallocStats=Module.__PyFloat_DebugMallocStats=t=>(__PyFloat_DebugMallocStats=Module.__PyFloat_DebugMallocStats=wasmExports._PyFloat_DebugMallocStats)(t),__PyDebugAllocatorStats=Module.__PyDebugAllocatorStats=(t,e,n,_)=>(__PyDebugAllocatorStats=Module.__PyDebugAllocatorStats=wasmExports._PyDebugAllocatorStats)(t,e,n,_),_PyFloat_Pack2=Module._PyFloat_Pack2=(t,e,n)=>(_PyFloat_Pack2=Module._PyFloat_Pack2=wasmExports.PyFloat_Pack2)(t,e,n),_ldexp=Module._ldexp=(t,e)=>(_ldexp=Module._ldexp=wasmExports.ldexp)(t,e),_PyFloat_Pack4=Module._PyFloat_Pack4=(t,e,n)=>(_PyFloat_Pack4=Module._PyFloat_Pack4=wasmExports.PyFloat_Pack4)(t,e,n),_PyFloat_Pack8=Module._PyFloat_Pack8=(t,e,n)=>(_PyFloat_Pack8=Module._PyFloat_Pack8=wasmExports.PyFloat_Pack8)(t,e,n),_PyFloat_Unpack2=Module._PyFloat_Unpack2=(t,e)=>(_PyFloat_Unpack2=Module._PyFloat_Unpack2=wasmExports.PyFloat_Unpack2)(t,e),__Py_dg_infinity=Module.__Py_dg_infinity=t=>(__Py_dg_infinity=Module.__Py_dg_infinity=wasmExports._Py_dg_infinity)(t),__Py_dg_stdnan=Module.__Py_dg_stdnan=t=>(__Py_dg_stdnan=Module.__Py_dg_stdnan=wasmExports._Py_dg_stdnan)(t),_PyFloat_Unpack4=Module._PyFloat_Unpack4=(t,e)=>(_PyFloat_Unpack4=Module._PyFloat_Unpack4=wasmExports.PyFloat_Unpack4)(t,e),_PyFloat_Unpack8=Module._PyFloat_Unpack8=(t,e)=>(_PyFloat_Unpack8=Module._PyFloat_Unpack8=wasmExports.PyFloat_Unpack8)(t,e),_fmod=Module._fmod=(t,e)=>(_fmod=Module._fmod=wasmExports.fmod)(t,e),_PyErr_SetFromErrno=Module._PyErr_SetFromErrno=t=>(_PyErr_SetFromErrno=Module._PyErr_SetFromErrno=wasmExports.PyErr_SetFromErrno)(t),_round=Module._round=t=>(_round=Module._round=wasmExports.round)(t),__Py_dg_dtoa=Module.__Py_dg_dtoa=(t,e,n,_,r,a)=>(__Py_dg_dtoa=Module.__Py_dg_dtoa=wasmExports._Py_dg_dtoa)(t,e,n,_,r,a),__Py_dg_strtod=Module.__Py_dg_strtod=(t,e)=>(__Py_dg_strtod=Module.__Py_dg_strtod=wasmExports._Py_dg_strtod)(t,e),__Py_dg_freedtoa=Module.__Py_dg_freedtoa=t=>(__Py_dg_freedtoa=Module.__Py_dg_freedtoa=wasmExports._Py_dg_freedtoa)(t),__Py_parse_inf_or_nan=Module.__Py_parse_inf_or_nan=(t,e)=>(__Py_parse_inf_or_nan=Module.__Py_parse_inf_or_nan=wasmExports._Py_parse_inf_or_nan)(t,e),_strtol=Module._strtol=(t,e,n)=>(_strtol=Module._strtol=wasmExports.strtol)(t,e,n),__PyFloat_FormatAdvancedWriter=Module.__PyFloat_FormatAdvancedWriter=(t,e,n,_,r)=>(__PyFloat_FormatAdvancedWriter=Module.__PyFloat_FormatAdvancedWriter=wasmExports._PyFloat_FormatAdvancedWriter)(t,e,n,_,r),_PyFrame_GetLineNumber=Module._PyFrame_GetLineNumber=t=>(_PyFrame_GetLineNumber=Module._PyFrame_GetLineNumber=wasmExports.PyFrame_GetLineNumber)(t),_PyFrame_New=Module._PyFrame_New=(t,e,n,_)=>(_PyFrame_New=Module._PyFrame_New=wasmExports.PyFrame_New)(t,e,n,_),_PyFrame_FastToLocalsWithError=Module._PyFrame_FastToLocalsWithError=t=>(_PyFrame_FastToLocalsWithError=Module._PyFrame_FastToLocalsWithError=wasmExports.PyFrame_FastToLocalsWithError)(t),_PyFrame_FastToLocals=Module._PyFrame_FastToLocals=t=>(_PyFrame_FastToLocals=Module._PyFrame_FastToLocals=wasmExports.PyFrame_FastToLocals)(t),_PyFrame_LocalsToFast=Module._PyFrame_LocalsToFast=(t,e)=>(_PyFrame_LocalsToFast=Module._PyFrame_LocalsToFast=wasmExports.PyFrame_LocalsToFast)(t,e),__PyFrame_IsEntryFrame=Module.__PyFrame_IsEntryFrame=t=>(__PyFrame_IsEntryFrame=Module.__PyFrame_IsEntryFrame=wasmExports._PyFrame_IsEntryFrame)(t),_PyFrame_GetBack=Module._PyFrame_GetBack=t=>(_PyFrame_GetBack=Module._PyFrame_GetBack=wasmExports.PyFrame_GetBack)(t),_PyFrame_GetLocals=Module._PyFrame_GetLocals=t=>(_PyFrame_GetLocals=Module._PyFrame_GetLocals=wasmExports.PyFrame_GetLocals)(t),_PyFrame_GetGlobals=Module._PyFrame_GetGlobals=t=>(_PyFrame_GetGlobals=Module._PyFrame_GetGlobals=wasmExports.PyFrame_GetGlobals)(t),_PyFrame_GetBuiltins=Module._PyFrame_GetBuiltins=t=>(_PyFrame_GetBuiltins=Module._PyFrame_GetBuiltins=wasmExports.PyFrame_GetBuiltins)(t),_PyFrame_GetLasti=Module._PyFrame_GetLasti=t=>(_PyFrame_GetLasti=Module._PyFrame_GetLasti=wasmExports.PyFrame_GetLasti)(t),_PyFrame_GetGenerator=Module._PyFrame_GetGenerator=t=>(_PyFrame_GetGenerator=Module._PyFrame_GetGenerator=wasmExports.PyFrame_GetGenerator)(t),_PyCompile_OpcodeStackEffect=Module._PyCompile_OpcodeStackEffect=(t,e)=>(_PyCompile_OpcodeStackEffect=Module._PyCompile_OpcodeStackEffect=wasmExports.PyCompile_OpcodeStackEffect)(t,e),_PyFunction_NewWithQualName=Module._PyFunction_NewWithQualName=(t,e,n)=>(_PyFunction_NewWithQualName=Module._PyFunction_NewWithQualName=wasmExports.PyFunction_NewWithQualName)(t,e,n),_PyFunction_New=Module._PyFunction_New=(t,e)=>(_PyFunction_New=Module._PyFunction_New=wasmExports.PyFunction_New)(t,e),_PyFunction_GetCode=Module._PyFunction_GetCode=t=>(_PyFunction_GetCode=Module._PyFunction_GetCode=wasmExports.PyFunction_GetCode)(t),_PyFunction_GetGlobals=Module._PyFunction_GetGlobals=t=>(_PyFunction_GetGlobals=Module._PyFunction_GetGlobals=wasmExports.PyFunction_GetGlobals)(t),_PyFunction_GetModule=Module._PyFunction_GetModule=t=>(_PyFunction_GetModule=Module._PyFunction_GetModule=wasmExports.PyFunction_GetModule)(t),_PyFunction_GetDefaults=Module._PyFunction_GetDefaults=t=>(_PyFunction_GetDefaults=Module._PyFunction_GetDefaults=wasmExports.PyFunction_GetDefaults)(t),_PyFunction_SetDefaults=Module._PyFunction_SetDefaults=(t,e)=>(_PyFunction_SetDefaults=Module._PyFunction_SetDefaults=wasmExports.PyFunction_SetDefaults)(t,e),_PyFunction_GetKwDefaults=Module._PyFunction_GetKwDefaults=t=>(_PyFunction_GetKwDefaults=Module._PyFunction_GetKwDefaults=wasmExports.PyFunction_GetKwDefaults)(t),_PyFunction_SetKwDefaults=Module._PyFunction_SetKwDefaults=(t,e)=>(_PyFunction_SetKwDefaults=Module._PyFunction_SetKwDefaults=wasmExports.PyFunction_SetKwDefaults)(t,e),_PyFunction_GetClosure=Module._PyFunction_GetClosure=t=>(_PyFunction_GetClosure=Module._PyFunction_GetClosure=wasmExports.PyFunction_GetClosure)(t),_PyFunction_SetClosure=Module._PyFunction_SetClosure=(t,e)=>(_PyFunction_SetClosure=Module._PyFunction_SetClosure=wasmExports.PyFunction_SetClosure)(t,e),_PyFunction_GetAnnotations=Module._PyFunction_GetAnnotations=t=>(_PyFunction_GetAnnotations=Module._PyFunction_GetAnnotations=wasmExports.PyFunction_GetAnnotations)(t),_PyFunction_SetAnnotations=Module._PyFunction_SetAnnotations=(t,e)=>(_PyFunction_SetAnnotations=Module._PyFunction_SetAnnotations=wasmExports.PyFunction_SetAnnotations)(t,e),_PyClassMethod_New=Module._PyClassMethod_New=t=>(_PyClassMethod_New=Module._PyClassMethod_New=wasmExports.PyClassMethod_New)(t),_PyStaticMethod_New=Module._PyStaticMethod_New=t=>(_PyStaticMethod_New=Module._PyStaticMethod_New=wasmExports.PyStaticMethod_New)(t),__PyInterpreterState_LookUpID=Module.__PyInterpreterState_LookUpID=t=>(__PyInterpreterState_LookUpID=Module.__PyInterpreterState_LookUpID=wasmExports._PyInterpreterState_LookUpID)(t),__PyInterpreterState_IDDecref=Module.__PyInterpreterState_IDDecref=t=>(__PyInterpreterState_IDDecref=Module.__PyInterpreterState_IDDecref=wasmExports._PyInterpreterState_IDDecref)(t),_PyLong_FromLongLong=Module._PyLong_FromLongLong=t=>(_PyLong_FromLongLong=Module._PyLong_FromLongLong=wasmExports.PyLong_FromLongLong)(t),_PyLong_AsLongLongAndOverflow=Module._PyLong_AsLongLongAndOverflow=(t,e)=>(_PyLong_AsLongLongAndOverflow=Module._PyLong_AsLongLongAndOverflow=wasmExports.PyLong_AsLongLongAndOverflow)(t,e),_PyArg_ParseTupleAndKeywords=Module._PyArg_ParseTupleAndKeywords=(t,e,n,_,r)=>(_PyArg_ParseTupleAndKeywords=Module._PyArg_ParseTupleAndKeywords=wasmExports.PyArg_ParseTupleAndKeywords)(t,e,n,_,r),__PyInterpreterState_IDIncref=Module.__PyInterpreterState_IDIncref=t=>(__PyInterpreterState_IDIncref=Module.__PyInterpreterState_IDIncref=wasmExports._PyInterpreterState_IDIncref)(t),__PyInterpreterID_New=Module.__PyInterpreterID_New=t=>(__PyInterpreterID_New=Module.__PyInterpreterID_New=wasmExports._PyInterpreterID_New)(t),__PyInterpreterState_GetIDObject=Module.__PyInterpreterState_GetIDObject=t=>(__PyInterpreterState_GetIDObject=Module.__PyInterpreterState_GetIDObject=wasmExports._PyInterpreterState_GetIDObject)(t),__PyInterpreterState_IDInitref=Module.__PyInterpreterState_IDInitref=t=>(__PyInterpreterState_IDInitref=Module.__PyInterpreterState_IDInitref=wasmExports._PyInterpreterState_IDInitref)(t),_PyInterpreterState_GetID=Module._PyInterpreterState_GetID=t=>(_PyInterpreterState_GetID=Module._PyInterpreterState_GetID=wasmExports.PyInterpreterState_GetID)(t),__PyInterpreterID_LookUp=Module.__PyInterpreterID_LookUp=t=>(__PyInterpreterID_LookUp=Module.__PyInterpreterID_LookUp=wasmExports._PyInterpreterID_LookUp)(t),_PyLong_AsLongLong=Module._PyLong_AsLongLong=t=>(_PyLong_AsLongLong=Module._PyLong_AsLongLong=wasmExports.PyLong_AsLongLong)(t),_PyCallIter_New=Module._PyCallIter_New=(t,e)=>(_PyCallIter_New=Module._PyCallIter_New=wasmExports.PyCallIter_New)(t,e),__PyList_DebugMallocStats=Module.__PyList_DebugMallocStats=t=>(__PyList_DebugMallocStats=Module.__PyList_DebugMallocStats=wasmExports._PyList_DebugMallocStats)(t),_PyList_SetItem=Module._PyList_SetItem=(t,e,n)=>(_PyList_SetItem=Module._PyList_SetItem=wasmExports.PyList_SetItem)(t,e,n),_PyList_Insert=Module._PyList_Insert=(t,e,n)=>(_PyList_Insert=Module._PyList_Insert=wasmExports.PyList_Insert)(t,e,n),_PyList_GetSlice=Module._PyList_GetSlice=(t,e,n)=>(_PyList_GetSlice=Module._PyList_GetSlice=wasmExports.PyList_GetSlice)(t,e,n),_Py_ReprEnter=Module._Py_ReprEnter=t=>(_Py_ReprEnter=Module._Py_ReprEnter=wasmExports.Py_ReprEnter)(t),__PyUnicodeWriter_WriteChar=Module.__PyUnicodeWriter_WriteChar=(t,e)=>(__PyUnicodeWriter_WriteChar=Module.__PyUnicodeWriter_WriteChar=wasmExports._PyUnicodeWriter_WriteChar)(t,e),_Py_ReprLeave=Module._Py_ReprLeave=t=>(_Py_ReprLeave=Module._Py_ReprLeave=wasmExports.Py_ReprLeave)(t),__PyEval_SliceIndexNotNone=Module.__PyEval_SliceIndexNotNone=(t,e)=>(__PyEval_SliceIndexNotNone=Module.__PyEval_SliceIndexNotNone=wasmExports._PyEval_SliceIndexNotNone)(t,e),_PyObject_HashNotImplemented=Module._PyObject_HashNotImplemented=t=>(_PyObject_HashNotImplemented=Module._PyObject_HashNotImplemented=wasmExports.PyObject_HashNotImplemented)(t),__PyLong_New=Module.__PyLong_New=t=>(__PyLong_New=Module.__PyLong_New=wasmExports._PyLong_New)(t),_PyLong_FromUnsignedLong=Module._PyLong_FromUnsignedLong=t=>(_PyLong_FromUnsignedLong=Module._PyLong_FromUnsignedLong=wasmExports.PyLong_FromUnsignedLong)(t),_PyLong_FromUnsignedLongLong=Module._PyLong_FromUnsignedLongLong=t=>(_PyLong_FromUnsignedLongLong=Module._PyLong_FromUnsignedLongLong=wasmExports.PyLong_FromUnsignedLongLong)(t),_PyLong_FromSize_t=Module._PyLong_FromSize_t=t=>(_PyLong_FromSize_t=Module._PyLong_FromSize_t=wasmExports.PyLong_FromSize_t)(t),_PyLong_AsUnsignedLong=Module._PyLong_AsUnsignedLong=t=>(_PyLong_AsUnsignedLong=Module._PyLong_AsUnsignedLong=wasmExports.PyLong_AsUnsignedLong)(t),_PyLong_AsSize_t=Module._PyLong_AsSize_t=t=>(_PyLong_AsSize_t=Module._PyLong_AsSize_t=wasmExports.PyLong_AsSize_t)(t),_PyLong_AsUnsignedLongMask=Module._PyLong_AsUnsignedLongMask=t=>(_PyLong_AsUnsignedLongMask=Module._PyLong_AsUnsignedLongMask=wasmExports.PyLong_AsUnsignedLongMask)(t),__PyLong_FromByteArray=Module.__PyLong_FromByteArray=(t,e,n,_)=>(__PyLong_FromByteArray=Module.__PyLong_FromByteArray=wasmExports._PyLong_FromByteArray)(t,e,n,_),_PyLong_AsVoidPtr=Module._PyLong_AsVoidPtr=t=>(_PyLong_AsVoidPtr=Module._PyLong_AsVoidPtr=wasmExports.PyLong_AsVoidPtr)(t),_PyLong_AsUnsignedLongLong=Module._PyLong_AsUnsignedLongLong=t=>(_PyLong_AsUnsignedLongLong=Module._PyLong_AsUnsignedLongLong=wasmExports.PyLong_AsUnsignedLongLong)(t),_PyLong_AsUnsignedLongLongMask=Module._PyLong_AsUnsignedLongLongMask=t=>(_PyLong_AsUnsignedLongLongMask=Module._PyLong_AsUnsignedLongLongMask=wasmExports.PyLong_AsUnsignedLongLongMask)(t),__PyLong_UnsignedShort_Converter=Module.__PyLong_UnsignedShort_Converter=(t,e)=>(__PyLong_UnsignedShort_Converter=Module.__PyLong_UnsignedShort_Converter=wasmExports._PyLong_UnsignedShort_Converter)(t,e),__PyLong_UnsignedInt_Converter=Module.__PyLong_UnsignedInt_Converter=(t,e)=>(__PyLong_UnsignedInt_Converter=Module.__PyLong_UnsignedInt_Converter=wasmExports._PyLong_UnsignedInt_Converter)(t,e),__PyLong_UnsignedLong_Converter=Module.__PyLong_UnsignedLong_Converter=(t,e)=>(__PyLong_UnsignedLong_Converter=Module.__PyLong_UnsignedLong_Converter=wasmExports._PyLong_UnsignedLong_Converter)(t,e),__PyLong_UnsignedLongLong_Converter=Module.__PyLong_UnsignedLongLong_Converter=(t,e)=>(__PyLong_UnsignedLongLong_Converter=Module.__PyLong_UnsignedLongLong_Converter=wasmExports._PyLong_UnsignedLongLong_Converter)(t,e),__PyLong_Size_t_Converter=Module.__PyLong_Size_t_Converter=(t,e)=>(__PyLong_Size_t_Converter=Module.__PyLong_Size_t_Converter=wasmExports._PyLong_Size_t_Converter)(t,e),__PyUnicodeWriter_PrepareInternal=Module.__PyUnicodeWriter_PrepareInternal=(t,e,n)=>(__PyUnicodeWriter_PrepareInternal=Module.__PyUnicodeWriter_PrepareInternal=wasmExports._PyUnicodeWriter_PrepareInternal)(t,e,n),__PyLong_FormatWriter=Module.__PyLong_FormatWriter=(t,e,n,_)=>(__PyLong_FormatWriter=Module.__PyLong_FormatWriter=wasmExports._PyLong_FormatWriter)(t,e,n,_),__PyLong_Frexp=Module.__PyLong_Frexp=(t,e)=>(__PyLong_Frexp=Module.__PyLong_Frexp=wasmExports._PyLong_Frexp)(t,e),__PyLong_Rshift=Module.__PyLong_Rshift=(t,e)=>(__PyLong_Rshift=Module.__PyLong_Rshift=wasmExports._PyLong_Rshift)(t,e),__PyLong_GCD=Module.__PyLong_GCD=(t,e)=>(__PyLong_GCD=Module.__PyLong_GCD=wasmExports._PyLong_GCD)(t,e),__PyLong_DivmodNear=Module.__PyLong_DivmodNear=(t,e)=>(__PyLong_DivmodNear=Module.__PyLong_DivmodNear=wasmExports._PyLong_DivmodNear)(t,e),_PyLong_GetInfo=Module._PyLong_GetInfo=()=>(_PyLong_GetInfo=Module._PyLong_GetInfo=wasmExports.PyLong_GetInfo)(),__PyUnicode_Equal=Module.__PyUnicode_Equal=(t,e)=>(__PyUnicode_Equal=Module.__PyUnicode_Equal=wasmExports._PyUnicode_Equal)(t,e),_PyObject_Bytes=Module._PyObject_Bytes=t=>(_PyObject_Bytes=Module._PyObject_Bytes=wasmExports.PyObject_Bytes)(t),__PyLong_FormatAdvancedWriter=Module.__PyLong_FormatAdvancedWriter=(t,e,n,_,r)=>(__PyLong_FormatAdvancedWriter=Module.__PyLong_FormatAdvancedWriter=wasmExports._PyLong_FormatAdvancedWriter)(t,e,n,_,r),__PyDict_DebugMallocStats=Module.__PyDict_DebugMallocStats=t=>(__PyDict_DebugMallocStats=Module.__PyDict_DebugMallocStats=wasmExports._PyDict_DebugMallocStats)(t),__PyDict_CheckConsistency=Module.__PyDict_CheckConsistency=(t,e)=>(__PyDict_CheckConsistency=Module.__PyDict_CheckConsistency=wasmExports._PyDict_CheckConsistency)(t,e),__PyObject_AssertFailed=Module.__PyObject_AssertFailed=(t,e,n,_,r,a)=>(__PyObject_AssertFailed=Module.__PyObject_AssertFailed=wasmExports._PyObject_AssertFailed)(t,e,n,_,r,a),__PyDict_HasOnlyStringKeys=Module.__PyDict_HasOnlyStringKeys=t=>(__PyDict_HasOnlyStringKeys=Module.__PyDict_HasOnlyStringKeys=wasmExports._PyDict_HasOnlyStringKeys)(t),__PyDict_Next=Module.__PyDict_Next=(t,e,n,_,r)=>(__PyDict_Next=Module.__PyDict_Next=wasmExports._PyDict_Next)(t,e,n,_,r),__PyDict_MaybeUntrack=Module.__PyDict_MaybeUntrack=t=>(__PyDict_MaybeUntrack=Module.__PyDict_MaybeUntrack=wasmExports._PyDict_MaybeUntrack)(t),_PyObject_IS_GC=Module._PyObject_IS_GC=t=>(_PyObject_IS_GC=Module._PyObject_IS_GC=wasmExports.PyObject_IS_GC)(t),__PyDict_NewPresized=Module.__PyDict_NewPresized=t=>(__PyDict_NewPresized=Module.__PyDict_NewPresized=wasmExports._PyDict_NewPresized)(t),_PyDict_GetItem=Module._PyDict_GetItem=(t,e)=>(_PyDict_GetItem=Module._PyDict_GetItem=wasmExports.PyDict_GetItem)(t,e),__PyErr_Fetch=Module.__PyErr_Fetch=(t,e,n,_)=>(__PyErr_Fetch=Module.__PyErr_Fetch=wasmExports._PyErr_Fetch)(t,e,n,_),__PyErr_Restore=Module.__PyErr_Restore=(t,e,n,_)=>(__PyErr_Restore=Module.__PyErr_Restore=wasmExports._PyErr_Restore)(t,e,n,_),__PyDict_GetItem_KnownHash=Module.__PyDict_GetItem_KnownHash=(t,e,n)=>(__PyDict_GetItem_KnownHash=Module.__PyDict_GetItem_KnownHash=wasmExports._PyDict_GetItem_KnownHash)(t,e,n),__PyDict_GetItemWithError=Module.__PyDict_GetItemWithError=(t,e)=>(__PyDict_GetItemWithError=Module.__PyDict_GetItemWithError=wasmExports._PyDict_GetItemWithError)(t,e),__PyDict_GetItemIdWithError=Module.__PyDict_GetItemIdWithError=(t,e)=>(__PyDict_GetItemIdWithError=Module.__PyDict_GetItemIdWithError=wasmExports._PyDict_GetItemIdWithError)(t,e),__PyDict_GetItemStringWithError=Module.__PyDict_GetItemStringWithError=(t,e)=>(__PyDict_GetItemStringWithError=Module.__PyDict_GetItemStringWithError=wasmExports._PyDict_GetItemStringWithError)(t,e),__PyDict_SetItem_KnownHash=Module.__PyDict_SetItem_KnownHash=(t,e,n,_)=>(__PyDict_SetItem_KnownHash=Module.__PyDict_SetItem_KnownHash=wasmExports._PyDict_SetItem_KnownHash)(t,e,n,_),_PyDict_DelItem=Module._PyDict_DelItem=(t,e)=>(_PyDict_DelItem=Module._PyDict_DelItem=wasmExports.PyDict_DelItem)(t,e),__PyErr_SetKeyError=Module.__PyErr_SetKeyError=t=>(__PyErr_SetKeyError=Module.__PyErr_SetKeyError=wasmExports._PyErr_SetKeyError)(t),__PyDict_DelItem_KnownHash=Module.__PyDict_DelItem_KnownHash=(t,e,n)=>(__PyDict_DelItem_KnownHash=Module.__PyDict_DelItem_KnownHash=wasmExports._PyDict_DelItem_KnownHash)(t,e,n),__PyDict_DelItemIf=Module.__PyDict_DelItemIf=(t,e,n)=>(__PyDict_DelItemIf=Module.__PyDict_DelItemIf=wasmExports._PyDict_DelItemIf)(t,e,n),_PyDict_Clear=Module._PyDict_Clear=t=>(_PyDict_Clear=Module._PyDict_Clear=wasmExports.PyDict_Clear)(t),__PyDict_Pop=Module.__PyDict_Pop=(t,e,n)=>(__PyDict_Pop=Module.__PyDict_Pop=wasmExports._PyDict_Pop)(t,e,n),_PyDict_MergeFromSeq2=Module._PyDict_MergeFromSeq2=(t,e,n)=>(_PyDict_MergeFromSeq2=Module._PyDict_MergeFromSeq2=wasmExports.PyDict_MergeFromSeq2)(t,e,n),_PyDict_SetDefault=Module._PyDict_SetDefault=(t,e,n)=>(_PyDict_SetDefault=Module._PyDict_SetDefault=wasmExports.PyDict_SetDefault)(t,e,n),_PyDict_Update=Module._PyDict_Update=(t,e)=>(_PyDict_Update=Module._PyDict_Update=wasmExports.PyDict_Update)(t,e),_PyDict_Merge=Module._PyDict_Merge=(t,e,n)=>(_PyDict_Merge=Module._PyDict_Merge=wasmExports.PyDict_Merge)(t,e,n),__PyDict_MergeEx=Module.__PyDict_MergeEx=(t,e,n)=>(__PyDict_MergeEx=Module.__PyDict_MergeEx=wasmExports._PyDict_MergeEx)(t,e,n),_PyDict_Size=Module._PyDict_Size=t=>(_PyDict_Size=Module._PyDict_Size=wasmExports.PyDict_Size)(t),__PyDict_SizeOf=Module.__PyDict_SizeOf=t=>(__PyDict_SizeOf=Module.__PyDict_SizeOf=wasmExports._PyDict_SizeOf)(t),__PyDict_Contains_KnownHash=Module.__PyDict_Contains_KnownHash=(t,e,n)=>(__PyDict_Contains_KnownHash=Module.__PyDict_Contains_KnownHash=wasmExports._PyDict_Contains_KnownHash)(t,e,n),__PyDict_ContainsId=Module.__PyDict_ContainsId=(t,e)=>(__PyDict_ContainsId=Module.__PyDict_ContainsId=wasmExports._PyDict_ContainsId)(t,e),_PyArg_ValidateKeywordArguments=Module._PyArg_ValidateKeywordArguments=t=>(_PyArg_ValidateKeywordArguments=Module._PyArg_ValidateKeywordArguments=wasmExports.PyArg_ValidateKeywordArguments)(t),_PyDict_GetItemString=Module._PyDict_GetItemString=(t,e)=>(_PyDict_GetItemString=Module._PyDict_GetItemString=wasmExports.PyDict_GetItemString)(t,e),__PyDict_SetItemId=Module.__PyDict_SetItemId=(t,e,n)=>(__PyDict_SetItemId=Module.__PyDict_SetItemId=wasmExports._PyDict_SetItemId)(t,e,n),__PyDict_DelItemId=Module.__PyDict_DelItemId=(t,e)=>(__PyDict_DelItemId=Module.__PyDict_DelItemId=wasmExports._PyDict_DelItemId)(t,e),_PyDict_DelItemString=Module._PyDict_DelItemString=(t,e)=>(_PyDict_DelItemString=Module._PyDict_DelItemString=wasmExports.PyDict_DelItemString)(t,e),__PyDictView_New=Module.__PyDictView_New=(t,e)=>(__PyDictView_New=Module.__PyDictView_New=wasmExports._PyDictView_New)(t,e),__PyDictView_Intersect=Module.__PyDictView_Intersect=(t,e)=>(__PyDictView_Intersect=Module.__PyDictView_Intersect=wasmExports._PyDictView_Intersect)(t,e),_PyODict_New=Module._PyODict_New=()=>(_PyODict_New=Module._PyODict_New=wasmExports.PyODict_New)(),_PyODict_SetItem=Module._PyODict_SetItem=(t,e,n)=>(_PyODict_SetItem=Module._PyODict_SetItem=wasmExports.PyODict_SetItem)(t,e,n),__PyErr_ChainExceptions=Module.__PyErr_ChainExceptions=(t,e,n)=>(__PyErr_ChainExceptions=Module.__PyErr_ChainExceptions=wasmExports._PyErr_ChainExceptions)(t,e,n),_PyODict_DelItem=Module._PyODict_DelItem=(t,e)=>(_PyODict_DelItem=Module._PyODict_DelItem=wasmExports.PyODict_DelItem)(t,e),_PyMemoryView_FromMemory=Module._PyMemoryView_FromMemory=(t,e,n)=>(_PyMemoryView_FromMemory=Module._PyMemoryView_FromMemory=wasmExports.PyMemoryView_FromMemory)(t,e,n),_PyMemoryView_FromBuffer=Module._PyMemoryView_FromBuffer=t=>(_PyMemoryView_FromBuffer=Module._PyMemoryView_FromBuffer=wasmExports.PyMemoryView_FromBuffer)(t),_PyMemoryView_GetContiguous=Module._PyMemoryView_GetContiguous=(t,e,n)=>(_PyMemoryView_GetContiguous=Module._PyMemoryView_GetContiguous=wasmExports.PyMemoryView_GetContiguous)(t,e,n),_PyUnicode_AsASCIIString=Module._PyUnicode_AsASCIIString=t=>(_PyUnicode_AsASCIIString=Module._PyUnicode_AsASCIIString=wasmExports.PyUnicode_AsASCIIString)(t),_PyCFunction_New=Module._PyCFunction_New=(t,e)=>(_PyCFunction_New=Module._PyCFunction_New=wasmExports.PyCFunction_New)(t,e),_PyCFunction_NewEx=Module._PyCFunction_NewEx=(t,e,n)=>(_PyCFunction_NewEx=Module._PyCFunction_NewEx=wasmExports.PyCFunction_NewEx)(t,e,n),_PyCFunction_GetFunction=Module._PyCFunction_GetFunction=t=>(_PyCFunction_GetFunction=Module._PyCFunction_GetFunction=wasmExports.PyCFunction_GetFunction)(t),_PyCFunction_GetSelf=Module._PyCFunction_GetSelf=t=>(_PyCFunction_GetSelf=Module._PyCFunction_GetSelf=wasmExports.PyCFunction_GetSelf)(t),_PyCFunction_GetFlags=Module._PyCFunction_GetFlags=t=>(_PyCFunction_GetFlags=Module._PyCFunction_GetFlags=wasmExports.PyCFunction_GetFlags)(t),_PyModuleDef_Init=Module._PyModuleDef_Init=t=>(_PyModuleDef_Init=Module._PyModuleDef_Init=wasmExports.PyModuleDef_Init)(t),_PyModule_NewObject=Module._PyModule_NewObject=t=>(_PyModule_NewObject=Module._PyModule_NewObject=wasmExports.PyModule_NewObject)(t),_PyModule_New=Module._PyModule_New=t=>(_PyModule_New=Module._PyModule_New=wasmExports.PyModule_New)(t),__PyImport_IsInitialized=Module.__PyImport_IsInitialized=t=>(__PyImport_IsInitialized=Module.__PyImport_IsInitialized=wasmExports._PyImport_IsInitialized)(t),__PyModule_CreateInitialized=Module.__PyModule_CreateInitialized=(t,e)=>(__PyModule_CreateInitialized=Module.__PyModule_CreateInitialized=wasmExports._PyModule_CreateInitialized)(t,e),_strrchr=Module._strrchr=(t,e)=>(_strrchr=Module._strrchr=wasmExports.strrchr)(t,e),_PyModule_GetNameObject=Module._PyModule_GetNameObject=t=>(_PyModule_GetNameObject=Module._PyModule_GetNameObject=wasmExports.PyModule_GetNameObject)(t),_PyModule_SetDocString=Module._PyModule_SetDocString=(t,e)=>(_PyModule_SetDocString=Module._PyModule_SetDocString=wasmExports.PyModule_SetDocString)(t,e),_PyModule_FromDefAndSpec2=Module._PyModule_FromDefAndSpec2=(t,e,n)=>(_PyModule_FromDefAndSpec2=Module._PyModule_FromDefAndSpec2=wasmExports.PyModule_FromDefAndSpec2)(t,e,n),_PyModule_ExecDef=Module._PyModule_ExecDef=(t,e)=>(_PyModule_ExecDef=Module._PyModule_ExecDef=wasmExports.PyModule_ExecDef)(t,e),_PyModule_GetName=Module._PyModule_GetName=t=>(_PyModule_GetName=Module._PyModule_GetName=wasmExports.PyModule_GetName)(t),_PyModule_GetFilenameObject=Module._PyModule_GetFilenameObject=t=>(_PyModule_GetFilenameObject=Module._PyModule_GetFilenameObject=wasmExports.PyModule_GetFilenameObject)(t),_PyModule_GetFilename=Module._PyModule_GetFilename=t=>(_PyModule_GetFilename=Module._PyModule_GetFilename=wasmExports.PyModule_GetFilename)(t),_PyModule_GetDef=Module._PyModule_GetDef=t=>(_PyModule_GetDef=Module._PyModule_GetDef=wasmExports.PyModule_GetDef)(t),_PyModule_GetState=Module._PyModule_GetState=t=>(_PyModule_GetState=Module._PyModule_GetState=wasmExports.PyModule_GetState)(t),__PyModule_Clear=Module.__PyModule_Clear=t=>(__PyModule_Clear=Module.__PyModule_Clear=wasmExports._PyModule_Clear)(t),__PyModule_ClearDict=Module.__PyModule_ClearDict=t=>(__PyModule_ClearDict=Module.__PyModule_ClearDict=wasmExports._PyModule_ClearDict)(t),__PyModuleSpec_IsInitializing=Module.__PyModuleSpec_IsInitializing=t=>(__PyModuleSpec_IsInitializing=Module.__PyModuleSpec_IsInitializing=wasmExports._PyModuleSpec_IsInitializing)(t),_PySys_FormatStderr=Module._PySys_FormatStderr=(t,e)=>(_PySys_FormatStderr=Module._PySys_FormatStderr=wasmExports.PySys_FormatStderr)(t,e),__PyNamespace_New=Module.__PyNamespace_New=t=>(__PyNamespace_New=Module.__PyNamespace_New=wasmExports._PyNamespace_New)(t),__PyObject_CheckConsistency=Module.__PyObject_CheckConsistency=(t,e)=>(__PyObject_CheckConsistency=Module.__PyObject_CheckConsistency=wasmExports._PyObject_CheckConsistency)(t,e),__PyType_CheckConsistency=Module.__PyType_CheckConsistency=t=>(__PyType_CheckConsistency=Module.__PyType_CheckConsistency=wasmExports._PyType_CheckConsistency)(t),__PyUnicode_CheckConsistency=Module.__PyUnicode_CheckConsistency=(t,e)=>(__PyUnicode_CheckConsistency=Module.__PyUnicode_CheckConsistency=wasmExports._PyUnicode_CheckConsistency)(t,e),__PyObject_IsFreed=Module.__PyObject_IsFreed=t=>(__PyObject_IsFreed=Module.__PyObject_IsFreed=wasmExports._PyObject_IsFreed)(t),_fiprintf=Module._fiprintf=(t,e,n)=>(_fiprintf=Module._fiprintf=wasmExports.fiprintf)(t,e,n),_fwrite=Module._fwrite=(t,e,n,_)=>(_fwrite=Module._fwrite=wasmExports.fwrite)(t,e,n,_),_fputc=Module._fputc=(t,e)=>(_fputc=Module._fputc=wasmExports.fputc)(t,e),__PyObject_Dump=Module.__PyObject_Dump=t=>(__PyObject_Dump=Module.__PyObject_Dump=wasmExports._PyObject_Dump)(t),_Py_IncRef=Module._Py_IncRef=t=>(_Py_IncRef=Module._Py_IncRef=wasmExports.Py_IncRef)(t),_Py_DecRef=Module._Py_DecRef=t=>(_Py_DecRef=Module._Py_DecRef=wasmExports.Py_DecRef)(t),__Py_IncRef=Module.__Py_IncRef=t=>(__Py_IncRef=Module.__Py_IncRef=wasmExports._Py_IncRef)(t),__Py_DecRef=Module.__Py_DecRef=t=>(__Py_DecRef=Module.__Py_DecRef=wasmExports._Py_DecRef)(t),_PyObject_Init=Module._PyObject_Init=(t,e)=>(_PyObject_Init=Module._PyObject_Init=wasmExports.PyObject_Init)(t,e),_PyObject_InitVar=Module._PyObject_InitVar=(t,e,n)=>(_PyObject_InitVar=Module._PyObject_InitVar=wasmExports.PyObject_InitVar)(t,e,n),_PyObject_CallFinalizer=Module._PyObject_CallFinalizer=t=>(_PyObject_CallFinalizer=Module._PyObject_CallFinalizer=wasmExports.PyObject_CallFinalizer)(t),_PyObject_Print=Module._PyObject_Print=(t,e,n)=>(_PyObject_Print=Module._PyObject_Print=wasmExports.PyObject_Print)(t,e,n),_ferror=Module._ferror=t=>(_ferror=Module._ferror=wasmExports.ferror)(t),__Py_BreakPoint=Module.__Py_BreakPoint=()=>(__Py_BreakPoint=Module.__Py_BreakPoint=wasmExports._Py_BreakPoint)(),_PyGILState_Ensure=Module._PyGILState_Ensure=()=>(_PyGILState_Ensure=Module._PyGILState_Ensure=wasmExports.PyGILState_Ensure)(),_PyGILState_Release=Module._PyGILState_Release=t=>(_PyGILState_Release=Module._PyGILState_Release=wasmExports.PyGILState_Release)(t),__PyUnicode_AsASCIIString=Module.__PyUnicode_AsASCIIString=(t,e)=>(__PyUnicode_AsASCIIString=Module.__PyUnicode_AsASCIIString=wasmExports._PyUnicode_AsASCIIString)(t,e),_PyUnicode_DecodeASCII=Module._PyUnicode_DecodeASCII=(t,e,n)=>(_PyUnicode_DecodeASCII=Module._PyUnicode_DecodeASCII=wasmExports.PyUnicode_DecodeASCII)(t,e,n),__PyObject_GenericGetAttrWithDict=Module.__PyObject_GenericGetAttrWithDict=(t,e,n,_)=>(__PyObject_GenericGetAttrWithDict=Module.__PyObject_GenericGetAttrWithDict=wasmExports._PyObject_GenericGetAttrWithDict)(t,e,n,_),_PyObject_HasAttrString=Module._PyObject_HasAttrString=(t,e)=>(_PyObject_HasAttrString=Module._PyObject_HasAttrString=wasmExports.PyObject_HasAttrString)(t,e),__PyObject_LookupAttrId=Module.__PyObject_LookupAttrId=(t,e,n)=>(__PyObject_LookupAttrId=Module.__PyObject_LookupAttrId=wasmExports._PyObject_LookupAttrId)(t,e,n),__PyObject_GetDictPtr=Module.__PyObject_GetDictPtr=t=>(__PyObject_GetDictPtr=Module.__PyObject_GetDictPtr=wasmExports._PyObject_GetDictPtr)(t),__PyObject_GenericSetAttrWithDict=Module.__PyObject_GenericSetAttrWithDict=(t,e,n,_)=>(__PyObject_GenericSetAttrWithDict=Module.__PyObject_GenericSetAttrWithDict=wasmExports._PyObject_GenericSetAttrWithDict)(t,e,n,_),_PyObject_Not=Module._PyObject_Not=t=>(_PyObject_Not=Module._PyObject_Not=wasmExports.PyObject_Not)(t),_PyEval_GetLocals=Module._PyEval_GetLocals=()=>(_PyEval_GetLocals=Module._PyEval_GetLocals=wasmExports.PyEval_GetLocals)(),__PyObject_DebugTypeStats=Module.__PyObject_DebugTypeStats=t=>(__PyObject_DebugTypeStats=Module.__PyObject_DebugTypeStats=wasmExports._PyObject_DebugTypeStats)(t),__PyTuple_DebugMallocStats=Module.__PyTuple_DebugMallocStats=t=>(__PyTuple_DebugMallocStats=Module.__PyTuple_DebugMallocStats=wasmExports._PyTuple_DebugMallocStats)(t),_PyThreadState_GetDict=Module._PyThreadState_GetDict=()=>(_PyThreadState_GetDict=Module._PyThreadState_GetDict=wasmExports.PyThreadState_GetDict)(),_PyObject_GET_WEAKREFS_LISTPTR=Module._PyObject_GET_WEAKREFS_LISTPTR=t=>(_PyObject_GET_WEAKREFS_LISTPTR=Module._PyObject_GET_WEAKREFS_LISTPTR=wasmExports.PyObject_GET_WEAKREFS_LISTPTR)(t),_Py_NewRef=Module._Py_NewRef=t=>(_Py_NewRef=Module._Py_NewRef=wasmExports.Py_NewRef)(t),_Py_XNewRef=Module._Py_XNewRef=t=>(_Py_XNewRef=Module._Py_XNewRef=wasmExports.Py_XNewRef)(t),_Py_Is=Module._Py_Is=(t,e)=>(_Py_Is=Module._Py_Is=wasmExports.Py_Is)(t,e),_Py_IsNone=Module._Py_IsNone=t=>(_Py_IsNone=Module._Py_IsNone=wasmExports.Py_IsNone)(t),_Py_IsTrue=Module._Py_IsTrue=t=>(_Py_IsTrue=Module._Py_IsTrue=wasmExports.Py_IsTrue)(t),_Py_IsFalse=Module._Py_IsFalse=t=>(_Py_IsFalse=Module._Py_IsFalse=wasmExports.Py_IsFalse)(t),__PyMem_SetDefaultAllocator=Module.__PyMem_SetDefaultAllocator=(t,e)=>(__PyMem_SetDefaultAllocator=Module.__PyMem_SetDefaultAllocator=wasmExports._PyMem_SetDefaultAllocator)(t,e),__PyMem_GetAllocatorName=Module.__PyMem_GetAllocatorName=(t,e)=>(__PyMem_GetAllocatorName=Module.__PyMem_GetAllocatorName=wasmExports._PyMem_GetAllocatorName)(t,e),__PyMem_SetupAllocators=Module.__PyMem_SetupAllocators=t=>(__PyMem_SetupAllocators=Module.__PyMem_SetupAllocators=wasmExports._PyMem_SetupAllocators)(t),_calloc=Module._calloc=(t,e)=>(_calloc=Module._calloc=wasmExports.calloc)(t,e),_realloc=Module._realloc=(t,e)=>(_realloc=Module._realloc=wasmExports.realloc)(t,e),_PyMem_SetAllocator=Module._PyMem_SetAllocator=(t,e)=>(_PyMem_SetAllocator=Module._PyMem_SetAllocator=wasmExports.PyMem_SetAllocator)(t,e),_PyMem_SetupDebugHooks=Module._PyMem_SetupDebugHooks=()=>(_PyMem_SetupDebugHooks=Module._PyMem_SetupDebugHooks=wasmExports.PyMem_SetupDebugHooks)(),__PyMem_GetCurrentAllocatorName=Module.__PyMem_GetCurrentAllocatorName=()=>(__PyMem_GetCurrentAllocatorName=Module.__PyMem_GetCurrentAllocatorName=wasmExports._PyMem_GetCurrentAllocatorName)(),_PyMem_GetAllocator=Module._PyMem_GetAllocator=(t,e)=>(_PyMem_GetAllocator=Module._PyMem_GetAllocator=wasmExports.PyMem_GetAllocator)(t,e),_PyObject_GetArenaAllocator=Module._PyObject_GetArenaAllocator=t=>(_PyObject_GetArenaAllocator=Module._PyObject_GetArenaAllocator=wasmExports.PyObject_GetArenaAllocator)(t),_PyObject_SetArenaAllocator=Module._PyObject_SetArenaAllocator=t=>(_PyObject_SetArenaAllocator=Module._PyObject_SetArenaAllocator=wasmExports.PyObject_SetArenaAllocator)(t),_PyMem_RawMalloc=Module._PyMem_RawMalloc=t=>(_PyMem_RawMalloc=Module._PyMem_RawMalloc=wasmExports.PyMem_RawMalloc)(t),_PyMem_RawCalloc=Module._PyMem_RawCalloc=(t,e)=>(_PyMem_RawCalloc=Module._PyMem_RawCalloc=wasmExports.PyMem_RawCalloc)(t,e),__PyMem_RawWcsdup=Module.__PyMem_RawWcsdup=t=>(__PyMem_RawWcsdup=Module.__PyMem_RawWcsdup=wasmExports._PyMem_RawWcsdup)(t),_wcslen=Module._wcslen=t=>(_wcslen=Module._wcslen=wasmExports.wcslen)(t),__PyMem_RawStrdup=Module.__PyMem_RawStrdup=t=>(__PyMem_RawStrdup=Module.__PyMem_RawStrdup=wasmExports._PyMem_RawStrdup)(t),__PyMem_Strdup=Module.__PyMem_Strdup=t=>(__PyMem_Strdup=Module.__PyMem_Strdup=wasmExports._PyMem_Strdup)(t),__Py_GetAllocatedBlocks=Module.__Py_GetAllocatedBlocks=()=>(__Py_GetAllocatedBlocks=Module.__Py_GetAllocatedBlocks=wasmExports._Py_GetAllocatedBlocks)(),_PyPickleBuffer_FromObject=Module._PyPickleBuffer_FromObject=t=>(_PyPickleBuffer_FromObject=Module._PyPickleBuffer_FromObject=wasmExports.PyPickleBuffer_FromObject)(t),_PyPickleBuffer_GetBuffer=Module._PyPickleBuffer_GetBuffer=t=>(_PyPickleBuffer_GetBuffer=Module._PyPickleBuffer_GetBuffer=wasmExports.PyPickleBuffer_GetBuffer)(t),_PyPickleBuffer_Release=Module._PyPickleBuffer_Release=t=>(_PyPickleBuffer_Release=Module._PyPickleBuffer_Release=wasmExports.PyPickleBuffer_Release)(t),__PySlice_GetLongIndices=Module.__PySlice_GetLongIndices=(t,e,n,_,r)=>(__PySlice_GetLongIndices=Module.__PySlice_GetLongIndices=wasmExports._PySlice_GetLongIndices)(t,e,n,_,r),_PySet_Size=Module._PySet_Size=t=>(_PySet_Size=Module._PySet_Size=wasmExports.PySet_Size)(t),_PySet_Clear=Module._PySet_Clear=t=>(_PySet_Clear=Module._PySet_Clear=wasmExports.PySet_Clear)(t),_PySet_Pop=Module._PySet_Pop=t=>(_PySet_Pop=Module._PySet_Pop=wasmExports.PySet_Pop)(t),__PyUnicode_EQ=Module.__PyUnicode_EQ=(t,e)=>(__PyUnicode_EQ=Module.__PyUnicode_EQ=wasmExports._PyUnicode_EQ)(t,e),_PySlice_New=Module._PySlice_New=(t,e,n)=>(_PySlice_New=Module._PySlice_New=wasmExports.PySlice_New)(t,e,n),_PySlice_GetIndices=Module._PySlice_GetIndices=(t,e,n,_,r)=>(_PySlice_GetIndices=Module._PySlice_GetIndices=wasmExports.PySlice_GetIndices)(t,e,n,_,r),_PySlice_GetIndicesEx=Module._PySlice_GetIndicesEx=(t,e,n,_,r,a)=>(_PySlice_GetIndicesEx=Module._PySlice_GetIndicesEx=wasmExports.PySlice_GetIndicesEx)(t,e,n,_,r,a),_PyStructSequence_SetItem=Module._PyStructSequence_SetItem=(t,e,n)=>(_PyStructSequence_SetItem=Module._PyStructSequence_SetItem=wasmExports.PyStructSequence_SetItem)(t,e,n),_PyStructSequence_GetItem=Module._PyStructSequence_GetItem=(t,e)=>(_PyStructSequence_GetItem=Module._PyStructSequence_GetItem=wasmExports.PyStructSequence_GetItem)(t,e),__PyStructSequence_InitType=Module.__PyStructSequence_InitType=(t,e,n)=>(__PyStructSequence_InitType=Module.__PyStructSequence_InitType=wasmExports._PyStructSequence_InitType)(t,e,n),_PyStructSequence_InitType=Module._PyStructSequence_InitType=(t,e)=>(_PyStructSequence_InitType=Module._PyStructSequence_InitType=wasmExports.PyStructSequence_InitType)(t,e),__PyStructSequence_NewType=Module.__PyStructSequence_NewType=(t,e)=>(__PyStructSequence_NewType=Module.__PyStructSequence_NewType=wasmExports._PyStructSequence_NewType)(t,e),_PyStructSequence_NewType=Module._PyStructSequence_NewType=t=>(_PyStructSequence_NewType=Module._PyStructSequence_NewType=wasmExports.PyStructSequence_NewType)(t),_PyTuple_SetItem=Module._PyTuple_SetItem=(t,e,n)=>(_PyTuple_SetItem=Module._PyTuple_SetItem=wasmExports.PyTuple_SetItem)(t,e,n),__PyTuple_MaybeUntrack=Module.__PyTuple_MaybeUntrack=t=>(__PyTuple_MaybeUntrack=Module.__PyTuple_MaybeUntrack=wasmExports._PyTuple_MaybeUntrack)(t),__PyObject_GC_Resize=Module.__PyObject_GC_Resize=(t,e)=>(__PyObject_GC_Resize=Module.__PyObject_GC_Resize=wasmExports._PyObject_GC_Resize)(t,e),_PyType_ClearCache=Module._PyType_ClearCache=()=>(_PyType_ClearCache=Module._PyType_ClearCache=wasmExports.PyType_ClearCache)(),_PyType_Modified=Module._PyType_Modified=t=>(_PyType_Modified=Module._PyType_Modified=wasmExports.PyType_Modified)(t),__PyObject_LookupSpecialId=Module.__PyObject_LookupSpecialId=(t,e)=>(__PyObject_LookupSpecialId=Module.__PyObject_LookupSpecialId=wasmExports._PyObject_LookupSpecialId)(t,e),_PyType_GetFlags=Module._PyType_GetFlags=t=>(_PyType_GetFlags=Module._PyType_GetFlags=wasmExports.PyType_GetFlags)(t),_PyType_SUPPORTS_WEAKREFS=Module._PyType_SUPPORTS_WEAKREFS=t=>(_PyType_SUPPORTS_WEAKREFS=Module._PyType_SUPPORTS_WEAKREFS=wasmExports.PyType_SUPPORTS_WEAKREFS)(t),__PyType_CalculateMetaclass=Module.__PyType_CalculateMetaclass=(t,e)=>(__PyType_CalculateMetaclass=Module.__PyType_CalculateMetaclass=wasmExports._PyType_CalculateMetaclass)(t,e),_PyType_FromModuleAndSpec=Module._PyType_FromModuleAndSpec=(t,e,n)=>(_PyType_FromModuleAndSpec=Module._PyType_FromModuleAndSpec=wasmExports.PyType_FromModuleAndSpec)(t,e,n),__PyWeakref_ClearRef=Module.__PyWeakref_ClearRef=t=>(__PyWeakref_ClearRef=Module.__PyWeakref_ClearRef=wasmExports._PyWeakref_ClearRef)(t),_PyType_FromSpec=Module._PyType_FromSpec=t=>(_PyType_FromSpec=Module._PyType_FromSpec=wasmExports.PyType_FromSpec)(t),_PyType_GetName=Module._PyType_GetName=t=>(_PyType_GetName=Module._PyType_GetName=wasmExports.PyType_GetName)(t),_PyType_GetSlot=Module._PyType_GetSlot=(t,e)=>(_PyType_GetSlot=Module._PyType_GetSlot=wasmExports.PyType_GetSlot)(t,e),_PyType_GetModule=Module._PyType_GetModule=t=>(_PyType_GetModule=Module._PyType_GetModule=wasmExports.PyType_GetModule)(t),_PyType_GetModuleState=Module._PyType_GetModuleState=t=>(_PyType_GetModuleState=Module._PyType_GetModuleState=wasmExports.PyType_GetModuleState)(t),_PyType_GetModuleByDef=Module._PyType_GetModuleByDef=(t,e)=>(_PyType_GetModuleByDef=Module._PyType_GetModuleByDef=wasmExports.PyType_GetModuleByDef)(t,e),__PyType_LookupId=Module.__PyType_LookupId=(t,e)=>(__PyType_LookupId=Module.__PyType_LookupId=wasmExports._PyType_LookupId)(t,e),_PyArg_ParseTuple=Module._PyArg_ParseTuple=(t,e,n)=>(_PyArg_ParseTuple=Module._PyArg_ParseTuple=wasmExports.PyArg_ParseTuple)(t,e,n),_PyUnicode_IsIdentifier=Module._PyUnicode_IsIdentifier=t=>(_PyUnicode_IsIdentifier=Module._PyUnicode_IsIdentifier=wasmExports.PyUnicode_IsIdentifier)(t),_PyEval_GetGlobals=Module._PyEval_GetGlobals=()=>(_PyEval_GetGlobals=Module._PyEval_GetGlobals=wasmExports.PyEval_GetGlobals)(),_PyWeakref_NewRef=Module._PyWeakref_NewRef=(t,e)=>(_PyWeakref_NewRef=Module._PyWeakref_NewRef=wasmExports.PyWeakref_NewRef)(t,e),_PyImport_GetModule=Module._PyImport_GetModule=t=>(_PyImport_GetModule=Module._PyImport_GetModule=wasmExports.PyImport_GetModule)(t),_PyImport_Import=Module._PyImport_Import=t=>(_PyImport_Import=Module._PyImport_Import=wasmExports.PyImport_Import)(t),__Py_GetErrorHandler=Module.__Py_GetErrorHandler=t=>(__Py_GetErrorHandler=Module.__Py_GetErrorHandler=wasmExports._Py_GetErrorHandler)(t),__PyUnicode_FastCopyCharacters=Module.__PyUnicode_FastCopyCharacters=(t,e,n,_,r)=>(__PyUnicode_FastCopyCharacters=Module.__PyUnicode_FastCopyCharacters=wasmExports._PyUnicode_FastCopyCharacters)(t,e,n,_,r),_PyUnicode_CopyCharacters=Module._PyUnicode_CopyCharacters=(t,e,n,_,r)=>(_PyUnicode_CopyCharacters=Module._PyUnicode_CopyCharacters=wasmExports.PyUnicode_CopyCharacters)(t,e,n,_,r),_PyUnicode_Resize=Module._PyUnicode_Resize=(t,e)=>(_PyUnicode_Resize=Module._PyUnicode_Resize=wasmExports.PyUnicode_Resize)(t,e),_PyUnicode_FromUnicode=Module._PyUnicode_FromUnicode=(t,e)=>(_PyUnicode_FromUnicode=Module._PyUnicode_FromUnicode=wasmExports.PyUnicode_FromUnicode)(t,e),_PyUnicode_FromWideChar=Module._PyUnicode_FromWideChar=(t,e)=>(_PyUnicode_FromWideChar=Module._PyUnicode_FromWideChar=wasmExports.PyUnicode_FromWideChar)(t,e),_PyUnicode_FromKindAndData=Module._PyUnicode_FromKindAndData=(t,e,n)=>(_PyUnicode_FromKindAndData=Module._PyUnicode_FromKindAndData=wasmExports.PyUnicode_FromKindAndData)(t,e,n),__PyUnicode_FindMaxChar=Module.__PyUnicode_FindMaxChar=(t,e,n)=>(__PyUnicode_FindMaxChar=Module.__PyUnicode_FindMaxChar=wasmExports._PyUnicode_FindMaxChar)(t,e,n),_PyUnicode_AsUCS4=Module._PyUnicode_AsUCS4=(t,e,n,_)=>(_PyUnicode_AsUCS4=Module._PyUnicode_AsUCS4=wasmExports.PyUnicode_AsUCS4)(t,e,n,_),_PyUnicode_AsUCS4Copy=Module._PyUnicode_AsUCS4Copy=t=>(_PyUnicode_AsUCS4Copy=Module._PyUnicode_AsUCS4Copy=wasmExports.PyUnicode_AsUCS4Copy)(t),_PyUnicode_Fill=Module._PyUnicode_Fill=(t,e,n,_)=>(_PyUnicode_Fill=Module._PyUnicode_Fill=wasmExports.PyUnicode_Fill)(t,e,n,_),__PyUnicodeWriter_WriteLatin1String=Module.__PyUnicodeWriter_WriteLatin1String=(t,e,n)=>(__PyUnicodeWriter_WriteLatin1String=Module.__PyUnicodeWriter_WriteLatin1String=wasmExports._PyUnicodeWriter_WriteLatin1String)(t,e,n),_PyUnicode_AsWideChar=Module._PyUnicode_AsWideChar=(t,e,n)=>(_PyUnicode_AsWideChar=Module._PyUnicode_AsWideChar=wasmExports.PyUnicode_AsWideChar)(t,e,n),_PyUnicode_AsWideCharString=Module._PyUnicode_AsWideCharString=(t,e)=>(_PyUnicode_AsWideCharString=Module._PyUnicode_AsWideCharString=wasmExports.PyUnicode_AsWideCharString)(t,e),__PyUnicode_WideCharString_Converter=Module.__PyUnicode_WideCharString_Converter=(t,e)=>(__PyUnicode_WideCharString_Converter=Module.__PyUnicode_WideCharString_Converter=wasmExports._PyUnicode_WideCharString_Converter)(t,e),_PyUnicode_AsUnicodeAndSize=Module._PyUnicode_AsUnicodeAndSize=(t,e)=>(_PyUnicode_AsUnicodeAndSize=Module._PyUnicode_AsUnicodeAndSize=wasmExports.PyUnicode_AsUnicodeAndSize)(t,e),__PyUnicode_AsUnicode=Module.__PyUnicode_AsUnicode=t=>(__PyUnicode_AsUnicode=Module.__PyUnicode_AsUnicode=wasmExports._PyUnicode_AsUnicode)(t),__PyUnicode_WideCharString_Opt_Converter=Module.__PyUnicode_WideCharString_Opt_Converter=(t,e)=>(__PyUnicode_WideCharString_Opt_Converter=Module.__PyUnicode_WideCharString_Opt_Converter=wasmExports._PyUnicode_WideCharString_Opt_Converter)(t,e),_PyUnicode_FromOrdinal=Module._PyUnicode_FromOrdinal=t=>(_PyUnicode_FromOrdinal=Module._PyUnicode_FromOrdinal=wasmExports.PyUnicode_FromOrdinal)(t),_PyUnicode_FromObject=Module._PyUnicode_FromObject=t=>(_PyUnicode_FromObject=Module._PyUnicode_FromObject=wasmExports.PyUnicode_FromObject)(t),__PyInterpreterState_GetConfig=Module.__PyInterpreterState_GetConfig=t=>(__PyInterpreterState_GetConfig=Module.__PyInterpreterState_GetConfig=wasmExports._PyInterpreterState_GetConfig)(t),__PyCodec_Lookup=Module.__PyCodec_Lookup=t=>(__PyCodec_Lookup=Module.__PyCodec_Lookup=wasmExports._PyCodec_Lookup)(t),_PyCodec_LookupError=Module._PyCodec_LookupError=t=>(_PyCodec_LookupError=Module._PyCodec_LookupError=wasmExports.PyCodec_LookupError)(t),_PyUnicode_DecodeUTF16Stateful=Module._PyUnicode_DecodeUTF16Stateful=(t,e,n,_,r)=>(_PyUnicode_DecodeUTF16Stateful=Module._PyUnicode_DecodeUTF16Stateful=wasmExports.PyUnicode_DecodeUTF16Stateful)(t,e,n,_,r),_PyUnicode_DecodeUTF32Stateful=Module._PyUnicode_DecodeUTF32Stateful=(t,e,n,_,r)=>(_PyUnicode_DecodeUTF32Stateful=Module._PyUnicode_DecodeUTF32Stateful=wasmExports.PyUnicode_DecodeUTF32Stateful)(t,e,n,_,r),__PyCodec_DecodeText=Module.__PyCodec_DecodeText=(t,e,n)=>(__PyCodec_DecodeText=Module.__PyCodec_DecodeText=wasmExports._PyCodec_DecodeText)(t,e,n),_PyUnicode_DecodeUTF16=Module._PyUnicode_DecodeUTF16=(t,e,n,_)=>(_PyUnicode_DecodeUTF16=Module._PyUnicode_DecodeUTF16=wasmExports.PyUnicode_DecodeUTF16)(t,e,n,_),_PyUnicode_DecodeUTF32=Module._PyUnicode_DecodeUTF32=(t,e,n,_)=>(_PyUnicode_DecodeUTF32=Module._PyUnicode_DecodeUTF32=wasmExports.PyUnicode_DecodeUTF32)(t,e,n,_),_PyUnicode_AsDecodedObject=Module._PyUnicode_AsDecodedObject=(t,e,n)=>(_PyUnicode_AsDecodedObject=Module._PyUnicode_AsDecodedObject=wasmExports.PyUnicode_AsDecodedObject)(t,e,n),_PyCodec_Decode=Module._PyCodec_Decode=(t,e,n)=>(_PyCodec_Decode=Module._PyCodec_Decode=wasmExports.PyCodec_Decode)(t,e,n),_PyUnicode_AsDecodedUnicode=Module._PyUnicode_AsDecodedUnicode=(t,e,n)=>(_PyUnicode_AsDecodedUnicode=Module._PyUnicode_AsDecodedUnicode=wasmExports.PyUnicode_AsDecodedUnicode)(t,e,n),_PyUnicode_AsEncodedObject=Module._PyUnicode_AsEncodedObject=(t,e,n)=>(_PyUnicode_AsEncodedObject=Module._PyUnicode_AsEncodedObject=wasmExports.PyUnicode_AsEncodedObject)(t,e,n),_PyCodec_Encode=Module._PyCodec_Encode=(t,e,n)=>(_PyCodec_Encode=Module._PyCodec_Encode=wasmExports.PyCodec_Encode)(t,e,n),_PyUnicode_EncodeLocale=Module._PyUnicode_EncodeLocale=(t,e)=>(_PyUnicode_EncodeLocale=Module._PyUnicode_EncodeLocale=wasmExports.PyUnicode_EncodeLocale)(t,e),__Py_EncodeLocaleEx=Module.__Py_EncodeLocaleEx=(t,e,n,_,r,a)=>(__Py_EncodeLocaleEx=Module.__Py_EncodeLocaleEx=wasmExports._Py_EncodeLocaleEx)(t,e,n,_,r,a),_PyCodec_StrictErrors=Module._PyCodec_StrictErrors=t=>(_PyCodec_StrictErrors=Module._PyCodec_StrictErrors=wasmExports.PyCodec_StrictErrors)(t),_PyUnicode_EncodeFSDefault=Module._PyUnicode_EncodeFSDefault=t=>(_PyUnicode_EncodeFSDefault=Module._PyUnicode_EncodeFSDefault=wasmExports.PyUnicode_EncodeFSDefault)(t),__PyUnicode_EncodeUTF16=Module.__PyUnicode_EncodeUTF16=(t,e,n)=>(__PyUnicode_EncodeUTF16=Module.__PyUnicode_EncodeUTF16=wasmExports._PyUnicode_EncodeUTF16)(t,e,n),__PyUnicode_EncodeUTF32=Module.__PyUnicode_EncodeUTF32=(t,e,n)=>(__PyUnicode_EncodeUTF32=Module.__PyUnicode_EncodeUTF32=wasmExports._PyUnicode_EncodeUTF32)(t,e,n),__PyUnicode_AsLatin1String=Module.__PyUnicode_AsLatin1String=(t,e)=>(__PyUnicode_AsLatin1String=Module.__PyUnicode_AsLatin1String=wasmExports._PyUnicode_AsLatin1String)(t,e),__PyCodec_EncodeText=Module.__PyCodec_EncodeText=(t,e,n)=>(__PyCodec_EncodeText=Module.__PyCodec_EncodeText=wasmExports._PyCodec_EncodeText)(t,e,n),_wcscmp=Module._wcscmp=(t,e)=>(_wcscmp=Module._wcscmp=wasmExports.wcscmp)(t,e),_PyUnicode_AsEncodedUnicode=Module._PyUnicode_AsEncodedUnicode=(t,e,n)=>(_PyUnicode_AsEncodedUnicode=Module._PyUnicode_AsEncodedUnicode=wasmExports.PyUnicode_AsEncodedUnicode)(t,e,n),_PyUnicode_DecodeLocaleAndSize=Module._PyUnicode_DecodeLocaleAndSize=(t,e,n)=>(_PyUnicode_DecodeLocaleAndSize=Module._PyUnicode_DecodeLocaleAndSize=wasmExports.PyUnicode_DecodeLocaleAndSize)(t,e,n),__Py_DecodeLocaleEx=Module.__Py_DecodeLocaleEx=(t,e,n,_,r,a)=>(__Py_DecodeLocaleEx=Module.__Py_DecodeLocaleEx=wasmExports._Py_DecodeLocaleEx)(t,e,n,_,r,a),_PyUnicode_DecodeLocale=Module._PyUnicode_DecodeLocale=(t,e)=>(_PyUnicode_DecodeLocale=Module._PyUnicode_DecodeLocale=wasmExports.PyUnicode_DecodeLocale)(t,e),_PyUnicode_DecodeFSDefaultAndSize=Module._PyUnicode_DecodeFSDefaultAndSize=(t,e)=>(_PyUnicode_DecodeFSDefaultAndSize=Module._PyUnicode_DecodeFSDefaultAndSize=wasmExports.PyUnicode_DecodeFSDefaultAndSize)(t,e),_PyUnicode_FSConverter=Module._PyUnicode_FSConverter=(t,e)=>(_PyUnicode_FSConverter=Module._PyUnicode_FSConverter=wasmExports.PyUnicode_FSConverter)(t,e),_PyOS_FSPath=Module._PyOS_FSPath=t=>(_PyOS_FSPath=Module._PyOS_FSPath=wasmExports.PyOS_FSPath)(t),_PyUnicode_FSDecoder=Module._PyUnicode_FSDecoder=(t,e)=>(_PyUnicode_FSDecoder=Module._PyUnicode_FSDecoder=wasmExports.PyUnicode_FSDecoder)(t,e),_PyUnicode_AsUnicode=Module._PyUnicode_AsUnicode=t=>(_PyUnicode_AsUnicode=Module._PyUnicode_AsUnicode=wasmExports.PyUnicode_AsUnicode)(t),_PyUnicode_GetSize=Module._PyUnicode_GetSize=t=>(_PyUnicode_GetSize=Module._PyUnicode_GetSize=wasmExports.PyUnicode_GetSize)(t),_PyUnicode_GetLength=Module._PyUnicode_GetLength=t=>(_PyUnicode_GetLength=Module._PyUnicode_GetLength=wasmExports.PyUnicode_GetLength)(t),_PyUnicode_WriteChar=Module._PyUnicode_WriteChar=(t,e,n)=>(_PyUnicode_WriteChar=Module._PyUnicode_WriteChar=wasmExports.PyUnicode_WriteChar)(t,e,n),_PyUnicode_DecodeUTF7=Module._PyUnicode_DecodeUTF7=(t,e,n)=>(_PyUnicode_DecodeUTF7=Module._PyUnicode_DecodeUTF7=wasmExports.PyUnicode_DecodeUTF7)(t,e,n),_PyUnicode_DecodeUTF7Stateful=Module._PyUnicode_DecodeUTF7Stateful=(t,e,n,_)=>(_PyUnicode_DecodeUTF7Stateful=Module._PyUnicode_DecodeUTF7Stateful=wasmExports.PyUnicode_DecodeUTF7Stateful)(t,e,n,_),__PyUnicode_EncodeUTF7=Module.__PyUnicode_EncodeUTF7=(t,e,n,_)=>(__PyUnicode_EncodeUTF7=Module.__PyUnicode_EncodeUTF7=wasmExports._PyUnicode_EncodeUTF7)(t,e,n,_),__Py_DecodeUTF8Ex=Module.__Py_DecodeUTF8Ex=(t,e,n,_,r,a)=>(__Py_DecodeUTF8Ex=Module.__Py_DecodeUTF8Ex=wasmExports._Py_DecodeUTF8Ex)(t,e,n,_,r,a),__Py_DecodeUTF8_surrogateescape=Module.__Py_DecodeUTF8_surrogateescape=(t,e,n)=>(__Py_DecodeUTF8_surrogateescape=Module.__Py_DecodeUTF8_surrogateescape=wasmExports._Py_DecodeUTF8_surrogateescape)(t,e,n),__Py_EncodeUTF8Ex=Module.__Py_EncodeUTF8Ex=(t,e,n,_,r,a)=>(__Py_EncodeUTF8Ex=Module.__Py_EncodeUTF8Ex=wasmExports._Py_EncodeUTF8Ex)(t,e,n,_,r,a),_PyUnicode_AsUTF32String=Module._PyUnicode_AsUTF32String=t=>(_PyUnicode_AsUTF32String=Module._PyUnicode_AsUTF32String=wasmExports.PyUnicode_AsUTF32String)(t),_PyUnicode_AsUTF16String=Module._PyUnicode_AsUTF16String=t=>(_PyUnicode_AsUTF16String=Module._PyUnicode_AsUTF16String=wasmExports.PyUnicode_AsUTF16String)(t),__PyUnicode_DecodeUnicodeEscapeStateful=Module.__PyUnicode_DecodeUnicodeEscapeStateful=(t,e,n,_)=>(__PyUnicode_DecodeUnicodeEscapeStateful=Module.__PyUnicode_DecodeUnicodeEscapeStateful=wasmExports._PyUnicode_DecodeUnicodeEscapeStateful)(t,e,n,_),_PyUnicode_DecodeUnicodeEscape=Module._PyUnicode_DecodeUnicodeEscape=(t,e,n)=>(_PyUnicode_DecodeUnicodeEscape=Module._PyUnicode_DecodeUnicodeEscape=wasmExports.PyUnicode_DecodeUnicodeEscape)(t,e,n),_PyUnicode_AsUnicodeEscapeString=Module._PyUnicode_AsUnicodeEscapeString=t=>(_PyUnicode_AsUnicodeEscapeString=Module._PyUnicode_AsUnicodeEscapeString=wasmExports.PyUnicode_AsUnicodeEscapeString)(t),__PyUnicode_DecodeRawUnicodeEscapeStateful=Module.__PyUnicode_DecodeRawUnicodeEscapeStateful=(t,e,n,_)=>(__PyUnicode_DecodeRawUnicodeEscapeStateful=Module.__PyUnicode_DecodeRawUnicodeEscapeStateful=wasmExports._PyUnicode_DecodeRawUnicodeEscapeStateful)(t,e,n,_),_PyUnicode_DecodeRawUnicodeEscape=Module._PyUnicode_DecodeRawUnicodeEscape=(t,e,n)=>(_PyUnicode_DecodeRawUnicodeEscape=Module._PyUnicode_DecodeRawUnicodeEscape=wasmExports.PyUnicode_DecodeRawUnicodeEscape)(t,e,n),_PyUnicode_AsRawUnicodeEscapeString=Module._PyUnicode_AsRawUnicodeEscapeString=t=>(_PyUnicode_AsRawUnicodeEscapeString=Module._PyUnicode_AsRawUnicodeEscapeString=wasmExports.PyUnicode_AsRawUnicodeEscapeString)(t),_PyUnicode_AsLatin1String=Module._PyUnicode_AsLatin1String=t=>(_PyUnicode_AsLatin1String=Module._PyUnicode_AsLatin1String=wasmExports.PyUnicode_AsLatin1String)(t),__PyUnicodeWriter_PrepareKindInternal=Module.__PyUnicodeWriter_PrepareKindInternal=(t,e)=>(__PyUnicodeWriter_PrepareKindInternal=Module.__PyUnicodeWriter_PrepareKindInternal=wasmExports._PyUnicodeWriter_PrepareKindInternal)(t,e),_PyUnicode_DecodeCharmap=Module._PyUnicode_DecodeCharmap=(t,e,n,_)=>(_PyUnicode_DecodeCharmap=Module._PyUnicode_DecodeCharmap=wasmExports.PyUnicode_DecodeCharmap)(t,e,n,_),_PyUnicode_BuildEncodingMap=Module._PyUnicode_BuildEncodingMap=t=>(_PyUnicode_BuildEncodingMap=Module._PyUnicode_BuildEncodingMap=wasmExports.PyUnicode_BuildEncodingMap)(t),__PyUnicode_EncodeCharmap=Module.__PyUnicode_EncodeCharmap=(t,e,n)=>(__PyUnicode_EncodeCharmap=Module.__PyUnicode_EncodeCharmap=wasmExports._PyUnicode_EncodeCharmap)(t,e,n),_PyUnicode_AsCharmapString=Module._PyUnicode_AsCharmapString=(t,e)=>(_PyUnicode_AsCharmapString=Module._PyUnicode_AsCharmapString=wasmExports.PyUnicode_AsCharmapString)(t,e),_PyUnicode_Translate=Module._PyUnicode_Translate=(t,e,n)=>(_PyUnicode_Translate=Module._PyUnicode_Translate=wasmExports.PyUnicode_Translate)(t,e,n),__PyUnicode_IsWhitespace=Module.__PyUnicode_IsWhitespace=t=>(__PyUnicode_IsWhitespace=Module.__PyUnicode_IsWhitespace=wasmExports._PyUnicode_IsWhitespace)(t),__PyUnicode_ToDecimalDigit=Module.__PyUnicode_ToDecimalDigit=t=>(__PyUnicode_ToDecimalDigit=Module.__PyUnicode_ToDecimalDigit=wasmExports._PyUnicode_ToDecimalDigit)(t),__PyUnicode_InsertThousandsGrouping=Module.__PyUnicode_InsertThousandsGrouping=(t,e,n,_,r,a,o,l,p)=>(__PyUnicode_InsertThousandsGrouping=Module.__PyUnicode_InsertThousandsGrouping=wasmExports._PyUnicode_InsertThousandsGrouping)(t,e,n,_,r,a,o,l,p),_PyUnicode_Count=Module._PyUnicode_Count=(t,e,n,_)=>(_PyUnicode_Count=Module._PyUnicode_Count=wasmExports.PyUnicode_Count)(t,e,n,_),_PyUnicode_Find=Module._PyUnicode_Find=(t,e,n,_,r)=>(_PyUnicode_Find=Module._PyUnicode_Find=wasmExports.PyUnicode_Find)(t,e,n,_,r),_PyUnicode_FindChar=Module._PyUnicode_FindChar=(t,e,n,_,r)=>(_PyUnicode_FindChar=Module._PyUnicode_FindChar=wasmExports.PyUnicode_FindChar)(t,e,n,_,r),_PyUnicode_Tailmatch=Module._PyUnicode_Tailmatch=(t,e,n,_,r)=>(_PyUnicode_Tailmatch=Module._PyUnicode_Tailmatch=wasmExports.PyUnicode_Tailmatch)(t,e,n,_,r),__PyUnicode_JoinArray=Module.__PyUnicode_JoinArray=(t,e,n)=>(__PyUnicode_JoinArray=Module.__PyUnicode_JoinArray=wasmExports._PyUnicode_JoinArray)(t,e,n),__PyUnicode_FastFill=Module.__PyUnicode_FastFill=(t,e,n,_)=>(__PyUnicode_FastFill=Module.__PyUnicode_FastFill=wasmExports._PyUnicode_FastFill)(t,e,n,_),_PyUnicode_Splitlines=Module._PyUnicode_Splitlines=(t,e)=>(_PyUnicode_Splitlines=Module._PyUnicode_Splitlines=wasmExports.PyUnicode_Splitlines)(t,e),__PyUnicode_IsLinebreak=Module.__PyUnicode_IsLinebreak=t=>(__PyUnicode_IsLinebreak=Module.__PyUnicode_IsLinebreak=wasmExports._PyUnicode_IsLinebreak)(t),_wmemcmp=Module._wmemcmp=(t,e,n)=>(_wmemcmp=Module._wmemcmp=wasmExports.wmemcmp)(t,e,n),__PyUnicode_EqualToASCIIId=Module.__PyUnicode_EqualToASCIIId=(t,e)=>(__PyUnicode_EqualToASCIIId=Module.__PyUnicode_EqualToASCIIId=wasmExports._PyUnicode_EqualToASCIIId)(t,e),_PyUnicode_RichCompare=Module._PyUnicode_RichCompare=(t,e,n)=>(_PyUnicode_RichCompare=Module._PyUnicode_RichCompare=wasmExports.PyUnicode_RichCompare)(t,e,n),_PyUnicode_Contains=Module._PyUnicode_Contains=(t,e)=>(_PyUnicode_Contains=Module._PyUnicode_Contains=wasmExports.PyUnicode_Contains)(t,e),_PyUnicode_Concat=Module._PyUnicode_Concat=(t,e)=>(_PyUnicode_Concat=Module._PyUnicode_Concat=wasmExports.PyUnicode_Concat)(t,e),_PyUnicode_Append=Module._PyUnicode_Append=(t,e)=>(_PyUnicode_Append=Module._PyUnicode_Append=wasmExports.PyUnicode_Append)(t,e),__PyUnicode_IsXidStart=Module.__PyUnicode_IsXidStart=t=>(__PyUnicode_IsXidStart=Module.__PyUnicode_IsXidStart=wasmExports._PyUnicode_IsXidStart)(t),__PyUnicode_IsXidContinue=Module.__PyUnicode_IsXidContinue=t=>(__PyUnicode_IsXidContinue=Module.__PyUnicode_IsXidContinue=wasmExports._PyUnicode_IsXidContinue)(t),__PyUnicode_XStrip=Module.__PyUnicode_XStrip=(t,e,n)=>(__PyUnicode_XStrip=Module.__PyUnicode_XStrip=wasmExports._PyUnicode_XStrip)(t,e,n),_PyUnicode_Replace=Module._PyUnicode_Replace=(t,e,n,_)=>(_PyUnicode_Replace=Module._PyUnicode_Replace=wasmExports.PyUnicode_Replace)(t,e,n,_),_PyUnicode_Split=Module._PyUnicode_Split=(t,e,n)=>(_PyUnicode_Split=Module._PyUnicode_Split=wasmExports.PyUnicode_Split)(t,e,n),_PyUnicode_Partition=Module._PyUnicode_Partition=(t,e)=>(_PyUnicode_Partition=Module._PyUnicode_Partition=wasmExports.PyUnicode_Partition)(t,e),_PyUnicode_RPartition=Module._PyUnicode_RPartition=(t,e)=>(_PyUnicode_RPartition=Module._PyUnicode_RPartition=wasmExports.PyUnicode_RPartition)(t,e),_PyUnicode_RSplit=Module._PyUnicode_RSplit=(t,e,n)=>(_PyUnicode_RSplit=Module._PyUnicode_RSplit=wasmExports.PyUnicode_RSplit)(t,e,n),__PyUnicodeWriter_WriteSubstring=Module.__PyUnicodeWriter_WriteSubstring=(t,e,n,_)=>(__PyUnicodeWriter_WriteSubstring=Module.__PyUnicodeWriter_WriteSubstring=wasmExports._PyUnicodeWriter_WriteSubstring)(t,e,n,_),_PyUnicode_Format=Module._PyUnicode_Format=(t,e)=>(_PyUnicode_Format=Module._PyUnicode_Format=wasmExports.PyUnicode_Format)(t,e),__PyErr_WriteUnraisableMsg=Module.__PyErr_WriteUnraisableMsg=(t,e)=>(__PyErr_WriteUnraisableMsg=Module.__PyErr_WriteUnraisableMsg=wasmExports._PyErr_WriteUnraisableMsg)(t,e),_PyUnicode_InternImmortal=Module._PyUnicode_InternImmortal=t=>(_PyUnicode_InternImmortal=Module._PyUnicode_InternImmortal=wasmExports.PyUnicode_InternImmortal)(t),_PyInit__string=Module._PyInit__string=()=>(_PyInit__string=Module._PyInit__string=wasmExports.PyInit__string)(),__PyUnicode_IsLowercase=Module.__PyUnicode_IsLowercase=t=>(__PyUnicode_IsLowercase=Module.__PyUnicode_IsLowercase=wasmExports._PyUnicode_IsLowercase)(t),__PyUnicode_IsUppercase=Module.__PyUnicode_IsUppercase=t=>(__PyUnicode_IsUppercase=Module.__PyUnicode_IsUppercase=wasmExports._PyUnicode_IsUppercase)(t),__PyUnicode_IsTitlecase=Module.__PyUnicode_IsTitlecase=t=>(__PyUnicode_IsTitlecase=Module.__PyUnicode_IsTitlecase=wasmExports._PyUnicode_IsTitlecase)(t),__PyUnicode_IsDecimalDigit=Module.__PyUnicode_IsDecimalDigit=t=>(__PyUnicode_IsDecimalDigit=Module.__PyUnicode_IsDecimalDigit=wasmExports._PyUnicode_IsDecimalDigit)(t),__PyUnicode_IsDigit=Module.__PyUnicode_IsDigit=t=>(__PyUnicode_IsDigit=Module.__PyUnicode_IsDigit=wasmExports._PyUnicode_IsDigit)(t),__PyUnicode_IsNumeric=Module.__PyUnicode_IsNumeric=t=>(__PyUnicode_IsNumeric=Module.__PyUnicode_IsNumeric=wasmExports._PyUnicode_IsNumeric)(t),__PyUnicode_IsAlpha=Module.__PyUnicode_IsAlpha=t=>(__PyUnicode_IsAlpha=Module.__PyUnicode_IsAlpha=wasmExports._PyUnicode_IsAlpha)(t),__PyUnicode_FormatAdvancedWriter=Module.__PyUnicode_FormatAdvancedWriter=(t,e,n,_,r)=>(__PyUnicode_FormatAdvancedWriter=Module.__PyUnicode_FormatAdvancedWriter=wasmExports._PyUnicode_FormatAdvancedWriter)(t,e,n,_,r),__PyUnicode_ToTitleFull=Module.__PyUnicode_ToTitleFull=(t,e)=>(__PyUnicode_ToTitleFull=Module.__PyUnicode_ToTitleFull=wasmExports._PyUnicode_ToTitleFull)(t,e),__PyUnicode_IsCaseIgnorable=Module.__PyUnicode_IsCaseIgnorable=t=>(__PyUnicode_IsCaseIgnorable=Module.__PyUnicode_IsCaseIgnorable=wasmExports._PyUnicode_IsCaseIgnorable)(t),__PyUnicode_IsCased=Module.__PyUnicode_IsCased=t=>(__PyUnicode_IsCased=Module.__PyUnicode_IsCased=wasmExports._PyUnicode_IsCased)(t),__PyUnicode_ToLowerFull=Module.__PyUnicode_ToLowerFull=(t,e)=>(__PyUnicode_ToLowerFull=Module.__PyUnicode_ToLowerFull=wasmExports._PyUnicode_ToLowerFull)(t,e),__PyUnicode_ToFoldedFull=Module.__PyUnicode_ToFoldedFull=(t,e)=>(__PyUnicode_ToFoldedFull=Module.__PyUnicode_ToFoldedFull=wasmExports._PyUnicode_ToFoldedFull)(t,e),__PyUnicode_ToUpperFull=Module.__PyUnicode_ToUpperFull=(t,e)=>(__PyUnicode_ToUpperFull=Module.__PyUnicode_ToUpperFull=wasmExports._PyUnicode_ToUpperFull)(t,e),__PyUnicode_ToNumeric=Module.__PyUnicode_ToNumeric=t=>(__PyUnicode_ToNumeric=Module.__PyUnicode_ToNumeric=wasmExports._PyUnicode_ToNumeric)(t),__PyUnicode_ToTitlecase=Module.__PyUnicode_ToTitlecase=t=>(__PyUnicode_ToTitlecase=Module.__PyUnicode_ToTitlecase=wasmExports._PyUnicode_ToTitlecase)(t),__PyUnicode_ToDigit=Module.__PyUnicode_ToDigit=t=>(__PyUnicode_ToDigit=Module.__PyUnicode_ToDigit=wasmExports._PyUnicode_ToDigit)(t),__PyUnicode_ToUppercase=Module.__PyUnicode_ToUppercase=t=>(__PyUnicode_ToUppercase=Module.__PyUnicode_ToUppercase=wasmExports._PyUnicode_ToUppercase)(t),__PyUnicode_ToLowercase=Module.__PyUnicode_ToLowercase=t=>(__PyUnicode_ToLowercase=Module.__PyUnicode_ToLowercase=wasmExports._PyUnicode_ToLowercase)(t),__PyWeakref_GetWeakrefCount=Module.__PyWeakref_GetWeakrefCount=t=>(__PyWeakref_GetWeakrefCount=Module.__PyWeakref_GetWeakrefCount=wasmExports._PyWeakref_GetWeakrefCount)(t),_PyWeakref_NewProxy=Module._PyWeakref_NewProxy=(t,e)=>(_PyWeakref_NewProxy=Module._PyWeakref_NewProxy=wasmExports.PyWeakref_NewProxy)(t,e),_PyWeakref_GetObject=Module._PyWeakref_GetObject=t=>(_PyWeakref_GetObject=Module._PyWeakref_GetObject=wasmExports.PyWeakref_GetObject)(t),_PyErr_ResourceWarning=Module._PyErr_ResourceWarning=(t,e,n,_)=>(_PyErr_ResourceWarning=Module._PyErr_ResourceWarning=wasmExports.PyErr_ResourceWarning)(t,e,n,_),_PyErr_WarnExplicit=Module._PyErr_WarnExplicit=(t,e,n,_,r,a)=>(_PyErr_WarnExplicit=Module._PyErr_WarnExplicit=wasmExports.PyErr_WarnExplicit)(t,e,n,_,r,a),_PyErr_WarnExplicitFormat=Module._PyErr_WarnExplicitFormat=(t,e,n,_,r,a,o)=>(_PyErr_WarnExplicitFormat=Module._PyErr_WarnExplicitFormat=wasmExports.PyErr_WarnExplicitFormat)(t,e,n,_,r,a,o),__Py_IsFinalizing=Module.__Py_IsFinalizing=()=>(__Py_IsFinalizing=Module.__Py_IsFinalizing=wasmExports._Py_IsFinalizing)(),__PyWarnings_Init=Module.__PyWarnings_Init=()=>(__PyWarnings_Init=Module.__PyWarnings_Init=wasmExports._PyWarnings_Init)(),__PySys_GetAttr=Module.__PySys_GetAttr=(t,e)=>(__PySys_GetAttr=Module.__PySys_GetAttr=wasmExports._PySys_GetAttr)(t,e),__Py_DisplaySourceLine=Module.__Py_DisplaySourceLine=(t,e,n,_,r,a)=>(__Py_DisplaySourceLine=Module.__Py_DisplaySourceLine=wasmExports._Py_DisplaySourceLine)(t,e,n,_,r,a),_PyModule_AddObjectRef=Module._PyModule_AddObjectRef=(t,e,n)=>(_PyModule_AddObjectRef=Module._PyModule_AddObjectRef=wasmExports.PyModule_AddObjectRef)(t,e,n),_PyInit__ast=Module._PyInit__ast=()=>(_PyInit__ast=Module._PyInit__ast=wasmExports.PyInit__ast)(),_Py_GetRecursionLimit=Module._Py_GetRecursionLimit=()=>(_Py_GetRecursionLimit=Module._Py_GetRecursionLimit=wasmExports.Py_GetRecursionLimit)(),_PyModule_AddIntConstant=Module._PyModule_AddIntConstant=(t,e,n)=>(_PyModule_AddIntConstant=Module._PyModule_AddIntConstant=wasmExports.PyModule_AddIntConstant)(t,e,n),_PyInit__tokenize=Module._PyInit__tokenize=()=>(_PyInit__tokenize=Module._PyInit__tokenize=wasmExports.PyInit__tokenize)(),_PyModule_AddType=Module._PyModule_AddType=(t,e)=>(_PyModule_AddType=Module._PyModule_AddType=wasmExports.PyModule_AddType)(t,e),_snprintf=Module._snprintf=(t,e,n,_)=>(_snprintf=Module._snprintf=wasmExports.snprintf)(t,e,n,_),_PyImport_ImportModuleLevelObject=Module._PyImport_ImportModuleLevelObject=(t,e,n,_,r)=>(_PyImport_ImportModuleLevelObject=Module._PyImport_ImportModuleLevelObject=wasmExports.PyImport_ImportModuleLevelObject)(t,e,n,_,r),_PyEval_MergeCompilerFlags=Module._PyEval_MergeCompilerFlags=t=>(_PyEval_MergeCompilerFlags=Module._PyEval_MergeCompilerFlags=wasmExports.PyEval_MergeCompilerFlags)(t),__PyArena_New=Module.__PyArena_New=()=>(__PyArena_New=Module.__PyArena_New=wasmExports._PyArena_New)(),__PyArena_Free=Module.__PyArena_Free=t=>(__PyArena_Free=Module.__PyArena_Free=wasmExports._PyArena_Free)(t),__PyAST_Compile=Module.__PyAST_Compile=(t,e,n,_,r)=>(__PyAST_Compile=Module.__PyAST_Compile=wasmExports._PyAST_Compile)(t,e,n,_,r),__Py_SourceAsString=Module.__Py_SourceAsString=(t,e,n,_,r)=>(__Py_SourceAsString=Module.__Py_SourceAsString=wasmExports._Py_SourceAsString)(t,e,n,_,r),_Py_CompileStringObject=Module._Py_CompileStringObject=(t,e,n,_,r)=>(_Py_CompileStringObject=Module._Py_CompileStringObject=wasmExports.Py_CompileStringObject)(t,e,n,_,r),_PyEval_GetBuiltins=Module._PyEval_GetBuiltins=()=>(_PyEval_GetBuiltins=Module._PyEval_GetBuiltins=wasmExports.PyEval_GetBuiltins)(),_PyEval_EvalCode=Module._PyEval_EvalCode=(t,e,n)=>(_PyEval_EvalCode=Module._PyEval_EvalCode=wasmExports.PyEval_EvalCode)(t,e,n),_PyRun_StringFlags=Module._PyRun_StringFlags=(t,e,n,_,r)=>(_PyRun_StringFlags=Module._PyRun_StringFlags=wasmExports.PyRun_StringFlags)(t,e,n,_,r),_PyEval_EvalCodeEx=Module._PyEval_EvalCodeEx=(t,e,n,_,r,a,o,l,p,c,I)=>(_PyEval_EvalCodeEx=Module._PyEval_EvalCodeEx=wasmExports.PyEval_EvalCodeEx)(t,e,n,_,r,a,o,l,p,c,I),__PyArg_UnpackKeywordsWithVararg=Module.__PyArg_UnpackKeywordsWithVararg=(t,e,n,_,r,a,o,l,p,c)=>(__PyArg_UnpackKeywordsWithVararg=Module.__PyArg_UnpackKeywordsWithVararg=wasmExports._PyArg_UnpackKeywordsWithVararg)(t,e,n,_,r,a,o,l,p,c),__PyEval_SetSwitchInterval=Module.__PyEval_SetSwitchInterval=t=>(__PyEval_SetSwitchInterval=Module.__PyEval_SetSwitchInterval=wasmExports._PyEval_SetSwitchInterval)(t),__PyEval_GetSwitchInterval=Module.__PyEval_GetSwitchInterval=()=>(__PyEval_GetSwitchInterval=Module.__PyEval_GetSwitchInterval=wasmExports._PyEval_GetSwitchInterval)(),__Py_FatalError_TstateNULL=Module.__Py_FatalError_TstateNULL=t=>(__Py_FatalError_TstateNULL=Module.__Py_FatalError_TstateNULL=wasmExports._Py_FatalError_TstateNULL)(t),_PyEval_ThreadsInitialized=Module._PyEval_ThreadsInitialized=()=>(_PyEval_ThreadsInitialized=Module._PyEval_ThreadsInitialized=wasmExports.PyEval_ThreadsInitialized)(),_PyThread_init_thread=Module._PyThread_init_thread=()=>(_PyThread_init_thread=Module._PyThread_init_thread=wasmExports.PyThread_init_thread)(),_pthread_mutex_init=Module._pthread_mutex_init=(t,e)=>(_pthread_mutex_init=Module._pthread_mutex_init=wasmExports.pthread_mutex_init)(t,e),_pthread_mutex_lock=Module._pthread_mutex_lock=t=>(_pthread_mutex_lock=Module._pthread_mutex_lock=wasmExports.pthread_mutex_lock)(t),_pthread_cond_timedwait=Module._pthread_cond_timedwait=(t,e,n)=>(_pthread_cond_timedwait=Module._pthread_cond_timedwait=wasmExports.pthread_cond_timedwait)(t,e,n),_pthread_mutex_unlock=Module._pthread_mutex_unlock=t=>(_pthread_mutex_unlock=Module._pthread_mutex_unlock=wasmExports.pthread_mutex_unlock)(t),_pthread_cond_signal=Module._pthread_cond_signal=t=>(_pthread_cond_signal=Module._pthread_cond_signal=wasmExports.pthread_cond_signal)(t),_PyThread_exit_thread=Module._PyThread_exit_thread=()=>(_PyThread_exit_thread=Module._PyThread_exit_thread=wasmExports.PyThread_exit_thread)(),_PyThread_get_thread_ident=Module._PyThread_get_thread_ident=()=>(_PyThread_get_thread_ident=Module._PyThread_get_thread_ident=wasmExports.PyThread_get_thread_ident)(),_pthread_cond_destroy=Module._pthread_cond_destroy=t=>(_pthread_cond_destroy=Module._pthread_cond_destroy=wasmExports.pthread_cond_destroy)(t),_pthread_mutex_destroy=Module._pthread_mutex_destroy=t=>(_pthread_mutex_destroy=Module._pthread_mutex_destroy=wasmExports.pthread_mutex_destroy)(t),_PyEval_InitThreads=Module._PyEval_InitThreads=()=>(_PyEval_InitThreads=Module._PyEval_InitThreads=wasmExports.PyEval_InitThreads)(),_PyEval_AcquireLock=Module._PyEval_AcquireLock=()=>(_PyEval_AcquireLock=Module._PyEval_AcquireLock=wasmExports.PyEval_AcquireLock)(),_PyEval_ReleaseLock=Module._PyEval_ReleaseLock=()=>(_PyEval_ReleaseLock=Module._PyEval_ReleaseLock=wasmExports.PyEval_ReleaseLock)(),_pthread_cond_wait=Module._pthread_cond_wait=(t,e)=>(_pthread_cond_wait=Module._pthread_cond_wait=wasmExports.pthread_cond_wait)(t,e),_PyEval_AcquireThread=Module._PyEval_AcquireThread=t=>(_PyEval_AcquireThread=Module._PyEval_AcquireThread=wasmExports.PyEval_AcquireThread)(t),__PyThreadState_Swap=Module.__PyThreadState_Swap=(t,e)=>(__PyThreadState_Swap=Module.__PyThreadState_Swap=wasmExports._PyThreadState_Swap)(t,e),_PyEval_ReleaseThread=Module._PyEval_ReleaseThread=t=>(_PyEval_ReleaseThread=Module._PyEval_ReleaseThread=wasmExports.PyEval_ReleaseThread)(t),__PyThread_at_fork_reinit=Module.__PyThread_at_fork_reinit=t=>(__PyThread_at_fork_reinit=Module.__PyThread_at_fork_reinit=wasmExports._PyThread_at_fork_reinit)(t),__PyThreadState_DeleteExcept=Module.__PyThreadState_DeleteExcept=(t,e)=>(__PyThreadState_DeleteExcept=Module.__PyThreadState_DeleteExcept=wasmExports._PyThreadState_DeleteExcept)(t,e),__PyEval_SignalAsyncExc=Module.__PyEval_SignalAsyncExc=t=>(__PyEval_SignalAsyncExc=Module.__PyEval_SignalAsyncExc=wasmExports._PyEval_SignalAsyncExc)(t),__PyEval_SignalReceived=Module.__PyEval_SignalReceived=t=>(__PyEval_SignalReceived=Module.__PyEval_SignalReceived=wasmExports._PyEval_SignalReceived)(t),__PyEval_AddPendingCall=Module.__PyEval_AddPendingCall=(t,e,n)=>(__PyEval_AddPendingCall=Module.__PyEval_AddPendingCall=wasmExports._PyEval_AddPendingCall)(t,e,n),_Py_AddPendingCall=Module._Py_AddPendingCall=(t,e)=>(_Py_AddPendingCall=Module._Py_AddPendingCall=wasmExports.Py_AddPendingCall)(t,e),__PyErr_Print=Module.__PyErr_Print=t=>(__PyErr_Print=Module.__PyErr_Print=wasmExports._PyErr_Print)(t),_Py_MakePendingCalls=Module._Py_MakePendingCalls=()=>(_Py_MakePendingCalls=Module._Py_MakePendingCalls=wasmExports.Py_MakePendingCalls)(),__PyErr_CheckSignalsTstate=Module.__PyErr_CheckSignalsTstate=t=>(__PyErr_CheckSignalsTstate=Module.__PyErr_CheckSignalsTstate=wasmExports._PyErr_CheckSignalsTstate)(t),_PyThread_free_lock=Module._PyThread_free_lock=t=>(_PyThread_free_lock=Module._PyThread_free_lock=wasmExports.PyThread_free_lock)(t),_Py_SetRecursionLimit=Module._Py_SetRecursionLimit=t=>(_Py_SetRecursionLimit=Module._Py_SetRecursionLimit=wasmExports.Py_SetRecursionLimit)(t),_PyEval_EvalFrame=Module._PyEval_EvalFrame=t=>(_PyEval_EvalFrame=Module._PyEval_EvalFrame=wasmExports.PyEval_EvalFrame)(t),_PyEval_EvalFrameEx=Module._PyEval_EvalFrameEx=(t,e)=>(_PyEval_EvalFrameEx=Module._PyEval_EvalFrameEx=wasmExports.PyEval_EvalFrameEx)(t,e),_PyTraceBack_Here=Module._PyTraceBack_Here=t=>(_PyTraceBack_Here=Module._PyTraceBack_Here=wasmExports.PyTraceBack_Here)(t),__PyErr_SetNone=Module.__PyErr_SetNone=(t,e)=>(__PyErr_SetNone=Module.__PyErr_SetNone=wasmExports._PyErr_SetNone)(t,e),_PyErr_SetImportError=Module._PyErr_SetImportError=(t,e,n)=>(_PyErr_SetImportError=Module._PyErr_SetImportError=wasmExports.PyErr_SetImportError)(t,e,n),_PyErr_SetExcInfo=Module._PyErr_SetExcInfo=(t,e,n)=>(_PyErr_SetExcInfo=Module._PyErr_SetExcInfo=wasmExports.PyErr_SetExcInfo)(t,e,n),__PyErr_NormalizeException=Module.__PyErr_NormalizeException=(t,e,n,_)=>(__PyErr_NormalizeException=Module.__PyErr_NormalizeException=wasmExports._PyErr_NormalizeException)(t,e,n,_),__PyErr_GetTopmostException=Module.__PyErr_GetTopmostException=t=>(__PyErr_GetTopmostException=Module.__PyErr_GetTopmostException=wasmExports._PyErr_GetTopmostException)(t),__PyErr_SetObject=Module.__PyErr_SetObject=(t,e,n)=>(__PyErr_SetObject=Module.__PyErr_SetObject=wasmExports._PyErr_SetObject)(t,e,n),_PyThreadState_EnterTracing=Module._PyThreadState_EnterTracing=t=>(_PyThreadState_EnterTracing=Module._PyThreadState_EnterTracing=wasmExports.PyThreadState_EnterTracing)(t),_PyThreadState_LeaveTracing=Module._PyThreadState_LeaveTracing=t=>(_PyThreadState_LeaveTracing=Module._PyThreadState_LeaveTracing=wasmExports.PyThreadState_LeaveTracing)(t),__PyEval_SetProfile=Module.__PyEval_SetProfile=(t,e,n)=>(__PyEval_SetProfile=Module.__PyEval_SetProfile=wasmExports._PyEval_SetProfile)(t,e,n),_PyEval_SetProfile=Module._PyEval_SetProfile=(t,e)=>(_PyEval_SetProfile=Module._PyEval_SetProfile=wasmExports.PyEval_SetProfile)(t,e),__PyEval_SetTrace=Module.__PyEval_SetTrace=(t,e,n)=>(__PyEval_SetTrace=Module.__PyEval_SetTrace=wasmExports._PyEval_SetTrace)(t,e,n),_PyEval_SetTrace=Module._PyEval_SetTrace=(t,e)=>(_PyEval_SetTrace=Module._PyEval_SetTrace=wasmExports.PyEval_SetTrace)(t,e),_PyEval_GetFrame=Module._PyEval_GetFrame=()=>(_PyEval_GetFrame=Module._PyEval_GetFrame=wasmExports.PyEval_GetFrame)(),__PyEval_GetBuiltinId=Module.__PyEval_GetBuiltinId=t=>(__PyEval_GetBuiltinId=Module.__PyEval_GetBuiltinId=wasmExports._PyEval_GetBuiltinId)(t),_PyEval_GetFuncName=Module._PyEval_GetFuncName=t=>(_PyEval_GetFuncName=Module._PyEval_GetFuncName=wasmExports.PyEval_GetFuncName)(t),_PyEval_GetFuncDesc=Module._PyEval_GetFuncDesc=t=>(_PyEval_GetFuncDesc=Module._PyEval_GetFuncDesc=wasmExports.PyEval_GetFuncDesc)(t),__PyEval_RequestCodeExtraIndex=Module.__PyEval_RequestCodeExtraIndex=t=>(__PyEval_RequestCodeExtraIndex=Module.__PyEval_RequestCodeExtraIndex=wasmExports._PyEval_RequestCodeExtraIndex)(t),_PyCodec_Register=Module._PyCodec_Register=t=>(_PyCodec_Register=Module._PyCodec_Register=wasmExports.PyCodec_Register)(t),_PyCodec_Unregister=Module._PyCodec_Unregister=t=>(_PyCodec_Unregister=Module._PyCodec_Unregister=wasmExports.PyCodec_Unregister)(t),_PyInterpreterState_Get=Module._PyInterpreterState_Get=()=>(_PyInterpreterState_Get=Module._PyInterpreterState_Get=wasmExports.PyInterpreterState_Get)(),_PyCodec_KnownEncoding=Module._PyCodec_KnownEncoding=t=>(_PyCodec_KnownEncoding=Module._PyCodec_KnownEncoding=wasmExports.PyCodec_KnownEncoding)(t),__PyCodecInfo_GetIncrementalDecoder=Module.__PyCodecInfo_GetIncrementalDecoder=(t,e)=>(__PyCodecInfo_GetIncrementalDecoder=Module.__PyCodecInfo_GetIncrementalDecoder=wasmExports._PyCodecInfo_GetIncrementalDecoder)(t,e),__PyCodecInfo_GetIncrementalEncoder=Module.__PyCodecInfo_GetIncrementalEncoder=(t,e)=>(__PyCodecInfo_GetIncrementalEncoder=Module.__PyCodecInfo_GetIncrementalEncoder=wasmExports._PyCodecInfo_GetIncrementalEncoder)(t,e),_PyCodec_Encoder=Module._PyCodec_Encoder=t=>(_PyCodec_Encoder=Module._PyCodec_Encoder=wasmExports.PyCodec_Encoder)(t),_PyCodec_Decoder=Module._PyCodec_Decoder=t=>(_PyCodec_Decoder=Module._PyCodec_Decoder=wasmExports.PyCodec_Decoder)(t),_PyCodec_IncrementalEncoder=Module._PyCodec_IncrementalEncoder=(t,e)=>(_PyCodec_IncrementalEncoder=Module._PyCodec_IncrementalEncoder=wasmExports.PyCodec_IncrementalEncoder)(t,e),_PyCodec_IncrementalDecoder=Module._PyCodec_IncrementalDecoder=(t,e)=>(_PyCodec_IncrementalDecoder=Module._PyCodec_IncrementalDecoder=wasmExports.PyCodec_IncrementalDecoder)(t,e),_PyCodec_StreamReader=Module._PyCodec_StreamReader=(t,e,n)=>(_PyCodec_StreamReader=Module._PyCodec_StreamReader=wasmExports.PyCodec_StreamReader)(t,e,n),_PyCodec_StreamWriter=Module._PyCodec_StreamWriter=(t,e,n)=>(_PyCodec_StreamWriter=Module._PyCodec_StreamWriter=wasmExports.PyCodec_StreamWriter)(t,e,n),__PyCodec_LookupTextEncoding=Module.__PyCodec_LookupTextEncoding=(t,e)=>(__PyCodec_LookupTextEncoding=Module.__PyCodec_LookupTextEncoding=wasmExports._PyCodec_LookupTextEncoding)(t,e),_PyCodec_RegisterError=Module._PyCodec_RegisterError=(t,e)=>(_PyCodec_RegisterError=Module._PyCodec_RegisterError=wasmExports.PyCodec_RegisterError)(t,e),_PyCodec_IgnoreErrors=Module._PyCodec_IgnoreErrors=t=>(_PyCodec_IgnoreErrors=Module._PyCodec_IgnoreErrors=wasmExports.PyCodec_IgnoreErrors)(t),_PyCodec_ReplaceErrors=Module._PyCodec_ReplaceErrors=t=>(_PyCodec_ReplaceErrors=Module._PyCodec_ReplaceErrors=wasmExports.PyCodec_ReplaceErrors)(t),_PyCodec_XMLCharRefReplaceErrors=Module._PyCodec_XMLCharRefReplaceErrors=t=>(_PyCodec_XMLCharRefReplaceErrors=Module._PyCodec_XMLCharRefReplaceErrors=wasmExports.PyCodec_XMLCharRefReplaceErrors)(t),_PyCodec_BackslashReplaceErrors=Module._PyCodec_BackslashReplaceErrors=t=>(_PyCodec_BackslashReplaceErrors=Module._PyCodec_BackslashReplaceErrors=wasmExports.PyCodec_BackslashReplaceErrors)(t),_PyCodec_NameReplaceErrors=Module._PyCodec_NameReplaceErrors=t=>(_PyCodec_NameReplaceErrors=Module._PyCodec_NameReplaceErrors=wasmExports.PyCodec_NameReplaceErrors)(t),_PyCompile_OpcodeStackEffectWithJump=Module._PyCompile_OpcodeStackEffectWithJump=(t,e,n)=>(_PyCompile_OpcodeStackEffectWithJump=Module._PyCompile_OpcodeStackEffectWithJump=wasmExports.PyCompile_OpcodeStackEffectWithJump)(t,e,n),_PyCode_Optimize=Module._PyCode_Optimize=(t,e,n,_)=>(_PyCode_Optimize=Module._PyCode_Optimize=wasmExports.PyCode_Optimize)(t,e,n,_),_PySymtable_Lookup=Module._PySymtable_Lookup=(t,e)=>(_PySymtable_Lookup=Module._PySymtable_Lookup=wasmExports.PySymtable_Lookup)(t,e),_PyErr_ProgramTextObject=Module._PyErr_ProgramTextObject=(t,e)=>(_PyErr_ProgramTextObject=Module._PyErr_ProgramTextObject=wasmExports.PyErr_ProgramTextObject)(t,e),__PyContext_NewHamtForTests=Module.__PyContext_NewHamtForTests=()=>(__PyContext_NewHamtForTests=Module.__PyContext_NewHamtForTests=wasmExports._PyContext_NewHamtForTests)(),_PyContext_New=Module._PyContext_New=()=>(_PyContext_New=Module._PyContext_New=wasmExports.PyContext_New)(),_PyContext_Copy=Module._PyContext_Copy=t=>(_PyContext_Copy=Module._PyContext_Copy=wasmExports.PyContext_Copy)(t),_PyContext_CopyCurrent=Module._PyContext_CopyCurrent=()=>(_PyContext_CopyCurrent=Module._PyContext_CopyCurrent=wasmExports.PyContext_CopyCurrent)(),_PyContext_Enter=Module._PyContext_Enter=t=>(_PyContext_Enter=Module._PyContext_Enter=wasmExports.PyContext_Enter)(t),_PyContext_Exit=Module._PyContext_Exit=t=>(_PyContext_Exit=Module._PyContext_Exit=wasmExports.PyContext_Exit)(t),_PyContextVar_New=Module._PyContextVar_New=(t,e)=>(_PyContextVar_New=Module._PyContextVar_New=wasmExports.PyContextVar_New)(t,e),_PyContextVar_Get=Module._PyContextVar_Get=(t,e,n)=>(_PyContextVar_Get=Module._PyContextVar_Get=wasmExports.PyContextVar_Get)(t,e,n),_PyContextVar_Set=Module._PyContextVar_Set=(t,e)=>(_PyContextVar_Set=Module._PyContextVar_Set=wasmExports.PyContextVar_Set)(t,e),_PyContextVar_Reset=Module._PyContextVar_Reset=(t,e)=>(_PyContextVar_Reset=Module._PyContextVar_Reset=wasmExports.PyContextVar_Reset)(t,e),__PyErr_GetExcInfo=Module.__PyErr_GetExcInfo=(t,e,n,_)=>(__PyErr_GetExcInfo=Module.__PyErr_GetExcInfo=wasmExports._PyErr_GetExcInfo)(t,e,n,_),__PyErr_GetHandledException=Module.__PyErr_GetHandledException=t=>(__PyErr_GetHandledException=Module.__PyErr_GetHandledException=wasmExports._PyErr_GetHandledException)(t),_PyErr_GetHandledException=Module._PyErr_GetHandledException=()=>(_PyErr_GetHandledException=Module._PyErr_GetHandledException=wasmExports.PyErr_GetHandledException)(),__PyErr_SetHandledException=Module.__PyErr_SetHandledException=(t,e)=>(__PyErr_SetHandledException=Module.__PyErr_SetHandledException=wasmExports._PyErr_SetHandledException)(t,e),_PyErr_SetHandledException=Module._PyErr_SetHandledException=t=>(_PyErr_SetHandledException=Module._PyErr_SetHandledException=wasmExports.PyErr_SetHandledException)(t),_PyErr_GetExcInfo=Module._PyErr_GetExcInfo=(t,e,n)=>(_PyErr_GetExcInfo=Module._PyErr_GetExcInfo=wasmExports.PyErr_GetExcInfo)(t,e,n),__PyErr_StackItemToExcInfoTuple=Module.__PyErr_StackItemToExcInfoTuple=t=>(__PyErr_StackItemToExcInfoTuple=Module.__PyErr_StackItemToExcInfoTuple=wasmExports._PyErr_StackItemToExcInfoTuple)(t),_PyErr_SetFromErrnoWithFilenameObject=Module._PyErr_SetFromErrnoWithFilenameObject=(t,e)=>(_PyErr_SetFromErrnoWithFilenameObject=Module._PyErr_SetFromErrnoWithFilenameObject=wasmExports.PyErr_SetFromErrnoWithFilenameObject)(t,e),_PyErr_SetFromErrnoWithFilenameObjects=Module._PyErr_SetFromErrnoWithFilenameObjects=(t,e,n)=>(_PyErr_SetFromErrnoWithFilenameObjects=Module._PyErr_SetFromErrnoWithFilenameObjects=wasmExports.PyErr_SetFromErrnoWithFilenameObjects)(t,e,n),_strerror=Module._strerror=t=>(_strerror=Module._strerror=wasmExports.strerror)(t),_PyErr_SetImportErrorSubclass=Module._PyErr_SetImportErrorSubclass=(t,e,n,_)=>(_PyErr_SetImportErrorSubclass=Module._PyErr_SetImportErrorSubclass=wasmExports.PyErr_SetImportErrorSubclass)(t,e,n,_),_PyErr_BadInternalCall=Module._PyErr_BadInternalCall=()=>(_PyErr_BadInternalCall=Module._PyErr_BadInternalCall=wasmExports.PyErr_BadInternalCall)(),_PyErr_FormatV=Module._PyErr_FormatV=(t,e,n)=>(_PyErr_FormatV=Module._PyErr_FormatV=wasmExports.PyErr_FormatV)(t,e,n),_PyErr_NewExceptionWithDoc=Module._PyErr_NewExceptionWithDoc=(t,e,n,_)=>(_PyErr_NewExceptionWithDoc=Module._PyErr_NewExceptionWithDoc=wasmExports.PyErr_NewExceptionWithDoc)(t,e,n,_),_PyTraceBack_Print=Module._PyTraceBack_Print=(t,e)=>(_PyTraceBack_Print=Module._PyTraceBack_Print=wasmExports.PyTraceBack_Print)(t,e),__PyTraceBack_FromFrame=Module.__PyTraceBack_FromFrame=(t,e)=>(__PyTraceBack_FromFrame=Module.__PyTraceBack_FromFrame=wasmExports._PyTraceBack_FromFrame)(t,e),_PyErr_SyntaxLocation=Module._PyErr_SyntaxLocation=(t,e)=>(_PyErr_SyntaxLocation=Module._PyErr_SyntaxLocation=wasmExports.PyErr_SyntaxLocation)(t,e),_PyErr_SyntaxLocationEx=Module._PyErr_SyntaxLocationEx=(t,e,n)=>(_PyErr_SyntaxLocationEx=Module._PyErr_SyntaxLocationEx=wasmExports.PyErr_SyntaxLocationEx)(t,e,n),_PyErr_SyntaxLocationObject=Module._PyErr_SyntaxLocationObject=(t,e,n)=>(_PyErr_SyntaxLocationObject=Module._PyErr_SyntaxLocationObject=wasmExports.PyErr_SyntaxLocationObject)(t,e,n),_PyErr_RangedSyntaxLocationObject=Module._PyErr_RangedSyntaxLocationObject=(t,e,n,_,r)=>(_PyErr_RangedSyntaxLocationObject=Module._PyErr_RangedSyntaxLocationObject=wasmExports.PyErr_RangedSyntaxLocationObject)(t,e,n,_,r),_PyErr_ProgramText=Module._PyErr_ProgramText=(t,e)=>(_PyErr_ProgramText=Module._PyErr_ProgramText=wasmExports.PyErr_ProgramText)(t,e),__Py_fopen_obj=Module.__Py_fopen_obj=(t,e)=>(__Py_fopen_obj=Module.__Py_fopen_obj=wasmExports._Py_fopen_obj)(t,e),_Py_FrozenMain=Module._Py_FrozenMain=(t,e)=>(_Py_FrozenMain=Module._Py_FrozenMain=wasmExports.Py_FrozenMain)(t,e),__PyRuntime_Initialize=Module.__PyRuntime_Initialize=t=>(__PyRuntime_Initialize=Module.__PyRuntime_Initialize=wasmExports._PyRuntime_Initialize)(t),_Py_GETENV=Module._Py_GETENV=t=>(_Py_GETENV=Module._Py_GETENV=wasmExports.Py_GETENV)(t),_Py_GetVersion=Module._Py_GetVersion=()=>(_Py_GetVersion=Module._Py_GetVersion=wasmExports.Py_GetVersion)(),_Py_GetCopyright=Module._Py_GetCopyright=()=>(_Py_GetCopyright=Module._Py_GetCopyright=wasmExports.Py_GetCopyright)(),_PyImport_ImportFrozenModule=Module._PyImport_ImportFrozenModule=t=>(_PyImport_ImportFrozenModule=Module._PyImport_ImportFrozenModule=wasmExports.PyImport_ImportFrozenModule)(t),_PyRun_AnyFileExFlags=Module._PyRun_AnyFileExFlags=(t,e,n,_)=>(_PyRun_AnyFileExFlags=Module._PyRun_AnyFileExFlags=wasmExports.PyRun_AnyFileExFlags)(t,e,n,_),_Py_FinalizeEx=Module._Py_FinalizeEx=()=>(_Py_FinalizeEx=Module._Py_FinalizeEx=wasmExports.Py_FinalizeEx)(),_PyArg_Parse=Module._PyArg_Parse=(t,e,n)=>(_PyArg_Parse=Module._PyArg_Parse=wasmExports.PyArg_Parse)(t,e,n),__PyArg_Parse_SizeT=Module.__PyArg_Parse_SizeT=(t,e,n)=>(__PyArg_Parse_SizeT=Module.__PyArg_Parse_SizeT=wasmExports._PyArg_Parse_SizeT)(t,e,n),__PyArg_ParseStack=Module.__PyArg_ParseStack=(t,e,n,_)=>(__PyArg_ParseStack=Module.__PyArg_ParseStack=wasmExports._PyArg_ParseStack)(t,e,n,_),_PyArg_VaParse=Module._PyArg_VaParse=(t,e,n)=>(_PyArg_VaParse=Module._PyArg_VaParse=wasmExports.PyArg_VaParse)(t,e,n),__PyArg_VaParse_SizeT=Module.__PyArg_VaParse_SizeT=(t,e,n)=>(__PyArg_VaParse_SizeT=Module.__PyArg_VaParse_SizeT=wasmExports._PyArg_VaParse_SizeT)(t,e,n),_PyArg_VaParseTupleAndKeywords=Module._PyArg_VaParseTupleAndKeywords=(t,e,n,_,r)=>(_PyArg_VaParseTupleAndKeywords=Module._PyArg_VaParseTupleAndKeywords=wasmExports.PyArg_VaParseTupleAndKeywords)(t,e,n,_,r),__PyArg_VaParseTupleAndKeywords_SizeT=Module.__PyArg_VaParseTupleAndKeywords_SizeT=(t,e,n,_,r)=>(__PyArg_VaParseTupleAndKeywords_SizeT=Module.__PyArg_VaParseTupleAndKeywords_SizeT=wasmExports._PyArg_VaParseTupleAndKeywords_SizeT)(t,e,n,_,r),__PyArg_ParseTupleAndKeywordsFast=Module.__PyArg_ParseTupleAndKeywordsFast=(t,e,n,_)=>(__PyArg_ParseTupleAndKeywordsFast=Module.__PyArg_ParseTupleAndKeywordsFast=wasmExports._PyArg_ParseTupleAndKeywordsFast)(t,e,n,_),__PyArg_ParseTupleAndKeywordsFast_SizeT=Module.__PyArg_ParseTupleAndKeywordsFast_SizeT=(t,e,n,_)=>(__PyArg_ParseTupleAndKeywordsFast_SizeT=Module.__PyArg_ParseTupleAndKeywordsFast_SizeT=wasmExports._PyArg_ParseTupleAndKeywordsFast_SizeT)(t,e,n,_),__PyArg_ParseStackAndKeywords=Module.__PyArg_ParseStackAndKeywords=(t,e,n,_,r)=>(__PyArg_ParseStackAndKeywords=Module.__PyArg_ParseStackAndKeywords=wasmExports._PyArg_ParseStackAndKeywords)(t,e,n,_,r),__PyArg_VaParseTupleAndKeywordsFast=Module.__PyArg_VaParseTupleAndKeywordsFast=(t,e,n,_)=>(__PyArg_VaParseTupleAndKeywordsFast=Module.__PyArg_VaParseTupleAndKeywordsFast=wasmExports._PyArg_VaParseTupleAndKeywordsFast)(t,e,n,_),__PyArg_VaParseTupleAndKeywordsFast_SizeT=Module.__PyArg_VaParseTupleAndKeywordsFast_SizeT=(t,e,n,_)=>(__PyArg_VaParseTupleAndKeywordsFast_SizeT=Module.__PyArg_VaParseTupleAndKeywordsFast_SizeT=wasmExports._PyArg_VaParseTupleAndKeywordsFast_SizeT)(t,e,n,_),__PyArg_NoPositional=Module.__PyArg_NoPositional=(t,e)=>(__PyArg_NoPositional=Module.__PyArg_NoPositional=wasmExports._PyArg_NoPositional)(t,e),_Py_GetCompiler=Module._Py_GetCompiler=()=>(_Py_GetCompiler=Module._Py_GetCompiler=wasmExports.Py_GetCompiler)(),_Py_GetPlatform=Module._Py_GetPlatform=()=>(_Py_GetPlatform=Module._Py_GetPlatform=wasmExports.Py_GetPlatform)(),__Py_hashtable_hash_ptr=Module.__Py_hashtable_hash_ptr=t=>(__Py_hashtable_hash_ptr=Module.__Py_hashtable_hash_ptr=wasmExports._Py_hashtable_hash_ptr)(t),__Py_HashPointerRaw=Module.__Py_HashPointerRaw=t=>(__Py_HashPointerRaw=Module.__Py_HashPointerRaw=wasmExports._Py_HashPointerRaw)(t),__Py_hashtable_compare_direct=Module.__Py_hashtable_compare_direct=(t,e)=>(__Py_hashtable_compare_direct=Module.__Py_hashtable_compare_direct=wasmExports._Py_hashtable_compare_direct)(t,e),__Py_hashtable_size=Module.__Py_hashtable_size=t=>(__Py_hashtable_size=Module.__Py_hashtable_size=wasmExports._Py_hashtable_size)(t),__Py_hashtable_steal=Module.__Py_hashtable_steal=(t,e)=>(__Py_hashtable_steal=Module.__Py_hashtable_steal=wasmExports._Py_hashtable_steal)(t,e),__Py_hashtable_set=Module.__Py_hashtable_set=(t,e,n)=>(__Py_hashtable_set=Module.__Py_hashtable_set=wasmExports._Py_hashtable_set)(t,e,n),__Py_hashtable_get=Module.__Py_hashtable_get=(t,e)=>(__Py_hashtable_get=Module.__Py_hashtable_get=wasmExports._Py_hashtable_get)(t,e),__Py_hashtable_foreach=Module.__Py_hashtable_foreach=(t,e,n)=>(__Py_hashtable_foreach=Module.__Py_hashtable_foreach=wasmExports._Py_hashtable_foreach)(t,e,n),__Py_hashtable_new_full=Module.__Py_hashtable_new_full=(t,e,n,_,r)=>(__Py_hashtable_new_full=Module.__Py_hashtable_new_full=wasmExports._Py_hashtable_new_full)(t,e,n,_,r),__Py_hashtable_new=Module.__Py_hashtable_new=(t,e)=>(__Py_hashtable_new=Module.__Py_hashtable_new=wasmExports._Py_hashtable_new)(t,e),__Py_hashtable_clear=Module.__Py_hashtable_clear=t=>(__Py_hashtable_clear=Module.__Py_hashtable_clear=wasmExports._Py_hashtable_clear)(t),__Py_hashtable_destroy=Module.__Py_hashtable_destroy=t=>(__Py_hashtable_destroy=Module.__Py_hashtable_destroy=wasmExports._Py_hashtable_destroy)(t),__PyImport_AcquireLock=Module.__PyImport_AcquireLock=()=>(__PyImport_AcquireLock=Module.__PyImport_AcquireLock=wasmExports._PyImport_AcquireLock)(),__PyImport_ReleaseLock=Module.__PyImport_ReleaseLock=()=>(__PyImport_ReleaseLock=Module.__PyImport_ReleaseLock=wasmExports._PyImport_ReleaseLock)(),__PyImport_GetModuleId=Module.__PyImport_GetModuleId=t=>(__PyImport_GetModuleId=Module.__PyImport_GetModuleId=wasmExports._PyImport_GetModuleId)(t),__PyImport_SetModule=Module.__PyImport_SetModule=(t,e)=>(__PyImport_SetModule=Module.__PyImport_SetModule=wasmExports._PyImport_SetModule)(t,e),__PyImport_SetModuleString=Module.__PyImport_SetModuleString=(t,e)=>(__PyImport_SetModuleString=Module.__PyImport_SetModuleString=wasmExports._PyImport_SetModuleString)(t,e),_PyImport_GetMagicNumber=Module._PyImport_GetMagicNumber=()=>(_PyImport_GetMagicNumber=Module._PyImport_GetMagicNumber=wasmExports.PyImport_GetMagicNumber)(),_PyImport_GetMagicTag=Module._PyImport_GetMagicTag=()=>(_PyImport_GetMagicTag=Module._PyImport_GetMagicTag=wasmExports.PyImport_GetMagicTag)(),__PyImport_FixupExtensionObject=Module.__PyImport_FixupExtensionObject=(t,e,n,_)=>(__PyImport_FixupExtensionObject=Module.__PyImport_FixupExtensionObject=wasmExports._PyImport_FixupExtensionObject)(t,e,n,_),__PyState_AddModule=Module.__PyState_AddModule=(t,e,n)=>(__PyState_AddModule=Module.__PyState_AddModule=wasmExports._PyState_AddModule)(t,e,n),__PyImport_FixupBuiltin=Module.__PyImport_FixupBuiltin=(t,e,n)=>(__PyImport_FixupBuiltin=Module.__PyImport_FixupBuiltin=wasmExports._PyImport_FixupBuiltin)(t,e,n),_PyImport_AddModuleObject=Module._PyImport_AddModuleObject=t=>(_PyImport_AddModuleObject=Module._PyImport_AddModuleObject=wasmExports.PyImport_AddModuleObject)(t),_PyImport_AddModule=Module._PyImport_AddModule=t=>(_PyImport_AddModule=Module._PyImport_AddModule=wasmExports.PyImport_AddModule)(t),_PyImport_ExecCodeModule=Module._PyImport_ExecCodeModule=(t,e)=>(_PyImport_ExecCodeModule=Module._PyImport_ExecCodeModule=wasmExports.PyImport_ExecCodeModule)(t,e),_PyImport_ExecCodeModuleObject=Module._PyImport_ExecCodeModuleObject=(t,e,n,_)=>(_PyImport_ExecCodeModuleObject=Module._PyImport_ExecCodeModuleObject=wasmExports.PyImport_ExecCodeModuleObject)(t,e,n,_),_PyImport_ExecCodeModuleWithPathnames=Module._PyImport_ExecCodeModuleWithPathnames=(t,e,n,_)=>(_PyImport_ExecCodeModuleWithPathnames=Module._PyImport_ExecCodeModuleWithPathnames=wasmExports.PyImport_ExecCodeModuleWithPathnames)(t,e,n,_),_PyImport_ExecCodeModuleEx=Module._PyImport_ExecCodeModuleEx=(t,e,n)=>(_PyImport_ExecCodeModuleEx=Module._PyImport_ExecCodeModuleEx=wasmExports.PyImport_ExecCodeModuleEx)(t,e,n),_PyImport_GetImporter=Module._PyImport_GetImporter=t=>(_PyImport_GetImporter=Module._PyImport_GetImporter=wasmExports.PyImport_GetImporter)(t),_PyImport_ImportFrozenModuleObject=Module._PyImport_ImportFrozenModuleObject=t=>(_PyImport_ImportFrozenModuleObject=Module._PyImport_ImportFrozenModuleObject=wasmExports.PyImport_ImportFrozenModuleObject)(t),_PyMarshal_ReadObjectFromString=Module._PyMarshal_ReadObjectFromString=(t,e)=>(_PyMarshal_ReadObjectFromString=Module._PyMarshal_ReadObjectFromString=wasmExports.PyMarshal_ReadObjectFromString)(t,e),_PyImport_ImportModuleNoBlock=Module._PyImport_ImportModuleNoBlock=t=>(_PyImport_ImportModuleNoBlock=Module._PyImport_ImportModuleNoBlock=wasmExports.PyImport_ImportModuleNoBlock)(t),__PyTime_GetPerfCounter=Module.__PyTime_GetPerfCounter=()=>(__PyTime_GetPerfCounter=Module.__PyTime_GetPerfCounter=wasmExports._PyTime_GetPerfCounter)(),__PyTime_AsMicroseconds=Module.__PyTime_AsMicroseconds=(t,e)=>(__PyTime_AsMicroseconds=Module.__PyTime_AsMicroseconds=wasmExports._PyTime_AsMicroseconds)(t,e),_PyImport_ImportModuleLevel=Module._PyImport_ImportModuleLevel=(t,e,n,_,r)=>(_PyImport_ImportModuleLevel=Module._PyImport_ImportModuleLevel=wasmExports.PyImport_ImportModuleLevel)(t,e,n,_,r),_PyImport_ReloadModule=Module._PyImport_ReloadModule=t=>(_PyImport_ReloadModule=Module._PyImport_ReloadModule=wasmExports.PyImport_ReloadModule)(t),_PyInit__imp=Module._PyInit__imp=()=>(_PyInit__imp=Module._PyInit__imp=wasmExports.PyInit__imp)(),_PyImport_ExtendInittab=Module._PyImport_ExtendInittab=t=>(_PyImport_ExtendInittab=Module._PyImport_ExtendInittab=wasmExports.PyImport_ExtendInittab)(t),__PyImport_GetModuleAttr=Module.__PyImport_GetModuleAttr=(t,e)=>(__PyImport_GetModuleAttr=Module.__PyImport_GetModuleAttr=wasmExports._PyImport_GetModuleAttr)(t,e),__PyImport_GetModuleAttrString=Module.__PyImport_GetModuleAttrString=(t,e)=>(__PyImport_GetModuleAttrString=Module.__PyImport_GetModuleAttrString=wasmExports._PyImport_GetModuleAttrString)(t,e),_getenv=Module._getenv=t=>(_getenv=Module._getenv=wasmExports.getenv)(t),_PyStatus_Ok=Module._PyStatus_Ok=t=>(_PyStatus_Ok=Module._PyStatus_Ok=wasmExports.PyStatus_Ok)(t),_PyStatus_Error=Module._PyStatus_Error=(t,e)=>(_PyStatus_Error=Module._PyStatus_Error=wasmExports.PyStatus_Error)(t,e),_PyStatus_NoMemory=Module._PyStatus_NoMemory=t=>(_PyStatus_NoMemory=Module._PyStatus_NoMemory=wasmExports.PyStatus_NoMemory)(t),_PyStatus_Exit=Module._PyStatus_Exit=(t,e)=>(_PyStatus_Exit=Module._PyStatus_Exit=wasmExports.PyStatus_Exit)(t,e),_PyStatus_IsError=Module._PyStatus_IsError=t=>(_PyStatus_IsError=Module._PyStatus_IsError=wasmExports.PyStatus_IsError)(t),_PyStatus_IsExit=Module._PyStatus_IsExit=t=>(_PyStatus_IsExit=Module._PyStatus_IsExit=wasmExports.PyStatus_IsExit)(t),__PyWideStringList_Clear=Module.__PyWideStringList_Clear=t=>(__PyWideStringList_Clear=Module.__PyWideStringList_Clear=wasmExports._PyWideStringList_Clear)(t),__PyWideStringList_Copy=Module.__PyWideStringList_Copy=(t,e)=>(__PyWideStringList_Copy=Module.__PyWideStringList_Copy=wasmExports._PyWideStringList_Copy)(t,e),_PyWideStringList_Insert=Module._PyWideStringList_Insert=(t,e,n,_)=>(_PyWideStringList_Insert=Module._PyWideStringList_Insert=wasmExports.PyWideStringList_Insert)(t,e,n,_),_PyWideStringList_Append=Module._PyWideStringList_Append=(t,e,n)=>(_PyWideStringList_Append=Module._PyWideStringList_Append=wasmExports.PyWideStringList_Append)(t,e,n),__PyWideStringList_Extend=Module.__PyWideStringList_Extend=(t,e,n)=>(__PyWideStringList_Extend=Module.__PyWideStringList_Extend=wasmExports._PyWideStringList_Extend)(t,e,n),__PyWideStringList_AsList=Module.__PyWideStringList_AsList=t=>(__PyWideStringList_AsList=Module.__PyWideStringList_AsList=wasmExports._PyWideStringList_AsList)(t),_Py_SetStandardStreamEncoding=Module._Py_SetStandardStreamEncoding=(t,e)=>(_Py_SetStandardStreamEncoding=Module._Py_SetStandardStreamEncoding=wasmExports.Py_SetStandardStreamEncoding)(t,e),__Py_ClearStandardStreamEncoding=Module.__Py_ClearStandardStreamEncoding=()=>(__Py_ClearStandardStreamEncoding=Module.__Py_ClearStandardStreamEncoding=wasmExports._Py_ClearStandardStreamEncoding)(),__Py_ClearArgcArgv=Module.__Py_ClearArgcArgv=()=>(__Py_ClearArgcArgv=Module.__Py_ClearArgcArgv=wasmExports._Py_ClearArgcArgv)(),_Py_GetArgcArgv=Module._Py_GetArgcArgv=(t,e)=>(_Py_GetArgcArgv=Module._Py_GetArgcArgv=wasmExports.Py_GetArgcArgv)(t,e),__PyConfig_InitCompatConfig=Module.__PyConfig_InitCompatConfig=t=>(__PyConfig_InitCompatConfig=Module.__PyConfig_InitCompatConfig=wasmExports._PyConfig_InitCompatConfig)(t),_PyConfig_InitIsolatedConfig=Module._PyConfig_InitIsolatedConfig=t=>(_PyConfig_InitIsolatedConfig=Module._PyConfig_InitIsolatedConfig=wasmExports.PyConfig_InitIsolatedConfig)(t),_PyConfig_SetString=Module._PyConfig_SetString=(t,e,n,_)=>(_PyConfig_SetString=Module._PyConfig_SetString=wasmExports.PyConfig_SetString)(t,e,n,_),__Py_PreInitializeFromConfig=Module.__Py_PreInitializeFromConfig=(t,e,n)=>(__Py_PreInitializeFromConfig=Module.__Py_PreInitializeFromConfig=wasmExports._Py_PreInitializeFromConfig)(t,e,n),_Py_DecodeLocale=Module._Py_DecodeLocale=(t,e)=>(_Py_DecodeLocale=Module._Py_DecodeLocale=wasmExports.Py_DecodeLocale)(t,e),__PyConfig_AsDict=Module.__PyConfig_AsDict=t=>(__PyConfig_AsDict=Module.__PyConfig_AsDict=wasmExports._PyConfig_AsDict)(t),__PyConfig_FromDict=Module.__PyConfig_FromDict=(t,e)=>(__PyConfig_FromDict=Module.__PyConfig_FromDict=wasmExports._PyConfig_FromDict)(t,e),__Py_get_xoption=Module.__Py_get_xoption=(t,e)=>(__Py_get_xoption=Module.__Py_get_xoption=wasmExports._Py_get_xoption)(t,e),_wcschr=Module._wcschr=(t,e)=>(_wcschr=Module._wcschr=wasmExports.wcschr)(t,e),_setvbuf=Module._setvbuf=(t,e,n,_)=>(_setvbuf=Module._setvbuf=wasmExports.setvbuf)(t,e,n,_),__PyArgv_AsWstrList=Module.__PyArgv_AsWstrList=(t,e,n)=>(__PyArgv_AsWstrList=Module.__PyArgv_AsWstrList=wasmExports._PyArgv_AsWstrList)(t,e,n),_PyConfig_SetArgv=Module._PyConfig_SetArgv=(t,e,n,_)=>(_PyConfig_SetArgv=Module._PyConfig_SetArgv=wasmExports.PyConfig_SetArgv)(t,e,n,_),_PyConfig_SetWideStringList=Module._PyConfig_SetWideStringList=(t,e,n,_,r)=>(_PyConfig_SetWideStringList=Module._PyConfig_SetWideStringList=wasmExports.PyConfig_SetWideStringList)(t,e,n,_,r),_iprintf=Module._iprintf=(t,e)=>(_iprintf=Module._iprintf=wasmExports.iprintf)(t,e),_wcstok=Module._wcstok=(t,e,n)=>(_wcstok=Module._wcstok=wasmExports.wcstok)(t,e,n),__Py_get_env_flag=Module.__Py_get_env_flag=(t,e,n)=>(__Py_get_env_flag=Module.__Py_get_env_flag=wasmExports._Py_get_env_flag)(t,e,n),__Py_GetEnv=Module.__Py_GetEnv=(t,e)=>(__Py_GetEnv=Module.__Py_GetEnv=wasmExports._Py_GetEnv)(t,e),_strtoul=Module._strtoul=(t,e,n)=>(_strtoul=Module._strtoul=wasmExports.strtoul)(t,e,n),__Py_str_to_int=Module.__Py_str_to_int=(t,e)=>(__Py_str_to_int=Module.__Py_str_to_int=wasmExports._Py_str_to_int)(t,e),_wcstol=Module._wcstol=(t,e,n)=>(_wcstol=Module._wcstol=wasmExports.wcstol)(t,e,n),__Py_GetForceASCII=Module.__Py_GetForceASCII=()=>(__Py_GetForceASCII=Module.__Py_GetForceASCII=wasmExports._Py_GetForceASCII)(),_setlocale=Module._setlocale=(t,e)=>(_setlocale=Module._setlocale=wasmExports.setlocale)(t,e),__Py_IsLocaleCoercionTarget=Module.__Py_IsLocaleCoercionTarget=t=>(__Py_IsLocaleCoercionTarget=Module.__Py_IsLocaleCoercionTarget=wasmExports._Py_IsLocaleCoercionTarget)(t),_PyConfig_Read=Module._PyConfig_Read=(t,e)=>(_PyConfig_Read=Module._PyConfig_Read=wasmExports.PyConfig_Read)(t,e),__Py_GetConfigsAsDict=Module.__Py_GetConfigsAsDict=()=>(__Py_GetConfigsAsDict=Module.__Py_GetConfigsAsDict=wasmExports._Py_GetConfigsAsDict)(),__Py_GetLocaleEncoding=Module.__Py_GetLocaleEncoding=()=>(__Py_GetLocaleEncoding=Module.__Py_GetLocaleEncoding=wasmExports._Py_GetLocaleEncoding)(),_PyMarshal_WriteLongToFile=Module._PyMarshal_WriteLongToFile=(t,e,n)=>(_PyMarshal_WriteLongToFile=Module._PyMarshal_WriteLongToFile=wasmExports.PyMarshal_WriteLongToFile)(t,e,n),_PyMarshal_WriteObjectToFile=Module._PyMarshal_WriteObjectToFile=(t,e,n)=>(_PyMarshal_WriteObjectToFile=Module._PyMarshal_WriteObjectToFile=wasmExports.PyMarshal_WriteObjectToFile)(t,e,n),_PyMarshal_ReadShortFromFile=Module._PyMarshal_ReadShortFromFile=t=>(_PyMarshal_ReadShortFromFile=Module._PyMarshal_ReadShortFromFile=wasmExports.PyMarshal_ReadShortFromFile)(t),_PyMarshal_ReadLongFromFile=Module._PyMarshal_ReadLongFromFile=t=>(_PyMarshal_ReadLongFromFile=Module._PyMarshal_ReadLongFromFile=wasmExports.PyMarshal_ReadLongFromFile)(t),_PyMarshal_ReadLastObjectFromFile=Module._PyMarshal_ReadLastObjectFromFile=t=>(_PyMarshal_ReadLastObjectFromFile=Module._PyMarshal_ReadLastObjectFromFile=wasmExports.PyMarshal_ReadLastObjectFromFile)(t),__Py_fstat_noraise=Module.__Py_fstat_noraise=(t,e)=>(__Py_fstat_noraise=Module.__Py_fstat_noraise=wasmExports._Py_fstat_noraise)(t,e),_fread=Module._fread=(t,e,n,_)=>(_fread=Module._fread=wasmExports.fread)(t,e,n,_),_PyMarshal_ReadObjectFromFile=Module._PyMarshal_ReadObjectFromFile=t=>(_PyMarshal_ReadObjectFromFile=Module._PyMarshal_ReadObjectFromFile=wasmExports.PyMarshal_ReadObjectFromFile)(t),_PyMarshal_WriteObjectToString=Module._PyMarshal_WriteObjectToString=(t,e)=>(_PyMarshal_WriteObjectToString=Module._PyMarshal_WriteObjectToString=wasmExports.PyMarshal_WriteObjectToString)(t,e),_PyMarshal_Init=Module._PyMarshal_Init=()=>(_PyMarshal_Init=Module._PyMarshal_Init=wasmExports.PyMarshal_Init)(),__Py_convert_optional_to_ssize_t=Module.__Py_convert_optional_to_ssize_t=(t,e)=>(__Py_convert_optional_to_ssize_t=Module.__Py_convert_optional_to_ssize_t=wasmExports._Py_convert_optional_to_ssize_t)(t,e),_Py_VaBuildValue=Module._Py_VaBuildValue=(t,e)=>(_Py_VaBuildValue=Module._Py_VaBuildValue=wasmExports.Py_VaBuildValue)(t,e),__Py_VaBuildValue_SizeT=Module.__Py_VaBuildValue_SizeT=(t,e)=>(__Py_VaBuildValue_SizeT=Module.__Py_VaBuildValue_SizeT=wasmExports._Py_VaBuildValue_SizeT)(t,e),_PyModule_AddStringConstant=Module._PyModule_AddStringConstant=(t,e,n)=>(_PyModule_AddStringConstant=Module._PyModule_AddStringConstant=wasmExports.PyModule_AddStringConstant)(t,e,n),_vsnprintf=Module._vsnprintf=(t,e,n,_)=>(_vsnprintf=Module._vsnprintf=wasmExports.vsnprintf)(t,e,n,_),_PyOS_vsnprintf=Module._PyOS_vsnprintf=(t,e,n,_)=>(_PyOS_vsnprintf=Module._PyOS_vsnprintf=wasmExports.PyOS_vsnprintf)(t,e,n,_),__PyPathConfig_ClearGlobal=Module.__PyPathConfig_ClearGlobal=()=>(__PyPathConfig_ClearGlobal=Module.__PyPathConfig_ClearGlobal=wasmExports._PyPathConfig_ClearGlobal)(),_wcscpy=Module._wcscpy=(t,e)=>(_wcscpy=Module._wcscpy=wasmExports.wcscpy)(t,e),_Py_SetPath=Module._Py_SetPath=t=>(_Py_SetPath=Module._Py_SetPath=wasmExports.Py_SetPath)(t),_Py_SetPythonHome=Module._Py_SetPythonHome=t=>(_Py_SetPythonHome=Module._Py_SetPythonHome=wasmExports.Py_SetPythonHome)(t),_Py_SetProgramName=Module._Py_SetProgramName=t=>(_Py_SetProgramName=Module._Py_SetProgramName=wasmExports.Py_SetProgramName)(t),__Py_SetProgramFullPath=Module.__Py_SetProgramFullPath=t=>(__Py_SetProgramFullPath=Module.__Py_SetProgramFullPath=wasmExports._Py_SetProgramFullPath)(t),_Py_GetPath=Module._Py_GetPath=()=>(_Py_GetPath=Module._Py_GetPath=wasmExports.Py_GetPath)(),_Py_GetPrefix=Module._Py_GetPrefix=()=>(_Py_GetPrefix=Module._Py_GetPrefix=wasmExports.Py_GetPrefix)(),_Py_GetExecPrefix=Module._Py_GetExecPrefix=()=>(_Py_GetExecPrefix=Module._Py_GetExecPrefix=wasmExports.Py_GetExecPrefix)(),_Py_GetProgramFullPath=Module._Py_GetProgramFullPath=()=>(_Py_GetProgramFullPath=Module._Py_GetProgramFullPath=wasmExports.Py_GetProgramFullPath)(),_Py_GetPythonHome=Module._Py_GetPythonHome=()=>(_Py_GetPythonHome=Module._Py_GetPythonHome=wasmExports.Py_GetPythonHome)(),_Py_GetProgramName=Module._Py_GetProgramName=()=>(_Py_GetProgramName=Module._Py_GetProgramName=wasmExports.Py_GetProgramName)(),__Py_wgetcwd=Module.__Py_wgetcwd=(t,e)=>(__Py_wgetcwd=Module.__Py_wgetcwd=wasmExports._Py_wgetcwd)(t,e),__Py_wreadlink=Module.__Py_wreadlink=(t,e,n)=>(__Py_wreadlink=Module.__Py_wreadlink=wasmExports._Py_wreadlink)(t,e,n),_wcsrchr=Module._wcsrchr=(t,e)=>(_wcsrchr=Module._wcsrchr=wasmExports.wcsrchr)(t,e),_wcsncpy=Module._wcsncpy=(t,e,n)=>(_wcsncpy=Module._wcsncpy=wasmExports.wcsncpy)(t,e,n),__Py_wrealpath=Module.__Py_wrealpath=(t,e,n)=>(__Py_wrealpath=Module.__Py_wrealpath=wasmExports._Py_wrealpath)(t,e,n),_wcsncmp=Module._wcsncmp=(t,e,n)=>(_wcsncmp=Module._wcsncmp=wasmExports.wcsncmp)(t,e,n),__PyPreConfig_InitCompatConfig=Module.__PyPreConfig_InitCompatConfig=t=>(__PyPreConfig_InitCompatConfig=Module.__PyPreConfig_InitCompatConfig=wasmExports._PyPreConfig_InitCompatConfig)(t),_PyPreConfig_InitIsolatedConfig=Module._PyPreConfig_InitIsolatedConfig=t=>(_PyPreConfig_InitIsolatedConfig=Module._PyPreConfig_InitIsolatedConfig=wasmExports.PyPreConfig_InitIsolatedConfig)(t),__Py_SetLocaleFromEnv=Module.__Py_SetLocaleFromEnv=t=>(__Py_SetLocaleFromEnv=Module.__Py_SetLocaleFromEnv=wasmExports._Py_SetLocaleFromEnv)(t),__Py_LegacyLocaleDetected=Module.__Py_LegacyLocaleDetected=t=>(__Py_LegacyLocaleDetected=Module.__Py_LegacyLocaleDetected=wasmExports._Py_LegacyLocaleDetected)(t),__Py_CoerceLegacyLocale=Module.__Py_CoerceLegacyLocale=t=>(__Py_CoerceLegacyLocale=Module.__Py_CoerceLegacyLocale=wasmExports._Py_CoerceLegacyLocale)(t),_PyHash_GetFuncDef=Module._PyHash_GetFuncDef=()=>(_PyHash_GetFuncDef=Module._PyHash_GetFuncDef=wasmExports.PyHash_GetFuncDef)(),__PyRuntimeState_Init=Module.__PyRuntimeState_Init=(t,e)=>(__PyRuntimeState_Init=Module.__PyRuntimeState_Init=wasmExports._PyRuntimeState_Init)(t,e),__PyRuntime_Finalize=Module.__PyRuntime_Finalize=()=>(__PyRuntime_Finalize=Module.__PyRuntime_Finalize=wasmExports._PyRuntime_Finalize)(),__PyRuntimeState_Fini=Module.__PyRuntimeState_Fini=t=>(__PyRuntimeState_Fini=Module.__PyRuntimeState_Fini=wasmExports._PyRuntimeState_Fini)(t),__Py_IsCoreInitialized=Module.__Py_IsCoreInitialized=()=>(__Py_IsCoreInitialized=Module.__Py_IsCoreInitialized=wasmExports._Py_IsCoreInitialized)(),_nl_langinfo=Module._nl_langinfo=t=>(_nl_langinfo=Module._nl_langinfo=wasmExports.nl_langinfo)(t),__Py_ResetForceASCII=Module.__Py_ResetForceASCII=()=>(__Py_ResetForceASCII=Module.__Py_ResetForceASCII=wasmExports._Py_ResetForceASCII)(),_setenv=Module._setenv=(t,e,n)=>(_setenv=Module._setenv=wasmExports.setenv)(t,e,n),__PyInterpreterState_SetConfig=Module.__PyInterpreterState_SetConfig=t=>(__PyInterpreterState_SetConfig=Module.__PyInterpreterState_SetConfig=wasmExports._PyInterpreterState_SetConfig)(t),__Py_PreInitializeFromPyArgv=Module.__Py_PreInitializeFromPyArgv=(t,e,n)=>(__Py_PreInitializeFromPyArgv=Module.__Py_PreInitializeFromPyArgv=wasmExports._Py_PreInitializeFromPyArgv)(t,e,n),_Py_PreInitializeFromArgs=Module._Py_PreInitializeFromArgs=(t,e,n,_)=>(_Py_PreInitializeFromArgs=Module._Py_PreInitializeFromArgs=wasmExports.Py_PreInitializeFromArgs)(t,e,n,_),_Py_PreInitialize=Module._Py_PreInitialize=(t,e)=>(_Py_PreInitialize=Module._Py_PreInitialize=wasmExports.Py_PreInitialize)(t,e),__PyInterpreterState_Enable=Module.__PyInterpreterState_Enable=(t,e)=>(__PyInterpreterState_Enable=Module.__PyInterpreterState_Enable=wasmExports._PyInterpreterState_Enable)(t,e),_PyInterpreterState_New=Module._PyInterpreterState_New=()=>(_PyInterpreterState_New=Module._PyInterpreterState_New=wasmExports.PyInterpreterState_New)(),_PyThreadState_New=Module._PyThreadState_New=t=>(_PyThreadState_New=Module._PyThreadState_New=wasmExports.PyThreadState_New)(t),_PyThreadState_Swap=Module._PyThreadState_Swap=t=>(_PyThreadState_Swap=Module._PyThreadState_Swap=wasmExports.PyThreadState_Swap)(t),_Py_InitializeEx=Module._Py_InitializeEx=t=>(_Py_InitializeEx=Module._Py_InitializeEx=wasmExports.Py_InitializeEx)(t),_Py_FatalError=Module._Py_FatalError=t=>(_Py_FatalError=Module._Py_FatalError=wasmExports.Py_FatalError)(t),_Py_Initialize=Module._Py_Initialize=()=>(_Py_Initialize=Module._Py_Initialize=wasmExports.Py_Initialize)(),__Py_InitializeMain=Module.__Py_InitializeMain=t=>(__Py_InitializeMain=Module.__Py_InitializeMain=wasmExports._Py_InitializeMain)(t),_PyGC_Collect=Module._PyGC_Collect=()=>(_PyGC_Collect=Module._PyGC_Collect=wasmExports.PyGC_Collect)(),_PyInterpreterState_Delete=Module._PyInterpreterState_Delete=t=>(_PyInterpreterState_Delete=Module._PyInterpreterState_Delete=wasmExports.PyInterpreterState_Delete)(t),_Py_Finalize=Module._Py_Finalize=()=>(_Py_Finalize=Module._Py_Finalize=wasmExports.Py_Finalize)(),__Py_NewInterpreter=Module.__Py_NewInterpreter=t=>(__Py_NewInterpreter=Module.__Py_NewInterpreter=wasmExports._Py_NewInterpreter)(t),_PyErr_PrintEx=Module._PyErr_PrintEx=t=>(_PyErr_PrintEx=Module._PyErr_PrintEx=wasmExports.PyErr_PrintEx)(t),_PyThreadState_Clear=Module._PyThreadState_Clear=t=>(_PyThreadState_Clear=Module._PyThreadState_Clear=wasmExports.PyThreadState_Clear)(t),_PyThreadState_Delete=Module._PyThreadState_Delete=t=>(_PyThreadState_Delete=Module._PyThreadState_Delete=wasmExports.PyThreadState_Delete)(t),_Py_NewInterpreter=Module._Py_NewInterpreter=()=>(_Py_NewInterpreter=Module._Py_NewInterpreter=wasmExports.Py_NewInterpreter)(),_Py_EndInterpreter=Module._Py_EndInterpreter=t=>(_Py_EndInterpreter=Module._Py_EndInterpreter=wasmExports.Py_EndInterpreter)(t),__Py_DumpExtensionModules=Module.__Py_DumpExtensionModules=(t,e)=>(__Py_DumpExtensionModules=Module.__Py_DumpExtensionModules=wasmExports._Py_DumpExtensionModules)(t,e),__Py_write_noraise=Module.__Py_write_noraise=(t,e,n)=>(__Py_write_noraise=Module.__Py_write_noraise=wasmExports._Py_write_noraise)(t,e,n),__Py_DumpASCII=Module.__Py_DumpASCII=(t,e)=>(__Py_DumpASCII=Module.__Py_DumpASCII=wasmExports._Py_DumpASCII)(t,e),__Py_DumpDecimal=Module.__Py_DumpDecimal=(t,e)=>(__Py_DumpDecimal=Module.__Py_DumpDecimal=wasmExports._Py_DumpDecimal)(t,e),__Py_DumpHexadecimal=Module.__Py_DumpHexadecimal=(t,e,n)=>(__Py_DumpHexadecimal=Module.__Py_DumpHexadecimal=wasmExports._Py_DumpHexadecimal)(t,e,n),__Py_DumpTracebackThreads=Module.__Py_DumpTracebackThreads=(t,e,n)=>(__Py_DumpTracebackThreads=Module.__Py_DumpTracebackThreads=wasmExports._Py_DumpTracebackThreads)(t,e,n),_vfprintf=Module._vfprintf=(t,e,n)=>(_vfprintf=Module._vfprintf=wasmExports.vfprintf)(t,e,n),_Py_AtExit=Module._Py_AtExit=t=>(_Py_AtExit=Module._Py_AtExit=wasmExports.Py_AtExit)(t),_Py_Exit=Module._Py_Exit=t=>(_Py_Exit=Module._Py_Exit=wasmExports.Py_Exit)(t),_Py_FdIsInteractive=Module._Py_FdIsInteractive=(t,e)=>(_Py_FdIsInteractive=Module._Py_FdIsInteractive=wasmExports.Py_FdIsInteractive)(t,e),__Py_FdIsInteractive=Module.__Py_FdIsInteractive=(t,e)=>(__Py_FdIsInteractive=Module.__Py_FdIsInteractive=wasmExports._Py_FdIsInteractive)(t,e),_PyOS_getsig=Module._PyOS_getsig=t=>(_PyOS_getsig=Module._PyOS_getsig=wasmExports.PyOS_getsig)(t),_signal=Module._signal=(t,e)=>(_signal=Module._signal=wasmExports.signal)(t,e),_PyOS_setsig=Module._PyOS_setsig=(t,e)=>(_PyOS_setsig=Module._PyOS_setsig=wasmExports.PyOS_setsig)(t,e),_siginterrupt=Module._siginterrupt=(t,e)=>(_siginterrupt=Module._siginterrupt=wasmExports.siginterrupt)(t,e),_fcntl=Module._fcntl=(t,e,n)=>(_fcntl=Module._fcntl=wasmExports.fcntl)(t,e,n),_PyOS_mystrnicmp=Module._PyOS_mystrnicmp=(t,e,n)=>(_PyOS_mystrnicmp=Module._PyOS_mystrnicmp=wasmExports.PyOS_mystrnicmp)(t,e,n),_PyInterpreterState_Clear=Module._PyInterpreterState_Clear=t=>(_PyInterpreterState_Clear=Module._PyInterpreterState_Clear=wasmExports.PyInterpreterState_Clear)(t),_PyInterpreterState_ThreadHead=Module._PyInterpreterState_ThreadHead=t=>(_PyInterpreterState_ThreadHead=Module._PyInterpreterState_ThreadHead=wasmExports.PyInterpreterState_ThreadHead)(t),__PyInterpreterState_RequiresIDRef=Module.__PyInterpreterState_RequiresIDRef=t=>(__PyInterpreterState_RequiresIDRef=Module.__PyInterpreterState_RequiresIDRef=wasmExports._PyInterpreterState_RequiresIDRef)(t),__PyInterpreterState_RequireIDRef=Module.__PyInterpreterState_RequireIDRef=(t,e)=>(__PyInterpreterState_RequireIDRef=Module.__PyInterpreterState_RequireIDRef=wasmExports._PyInterpreterState_RequireIDRef)(t,e),__PyInterpreterState_GetMainModule=Module.__PyInterpreterState_GetMainModule=t=>(__PyInterpreterState_GetMainModule=Module.__PyInterpreterState_GetMainModule=wasmExports._PyInterpreterState_GetMainModule)(t),_PyInterpreterState_GetDict=Module._PyInterpreterState_GetDict=t=>(_PyInterpreterState_GetDict=Module._PyInterpreterState_GetDict=wasmExports.PyInterpreterState_GetDict)(t),_PyThread_tss_get=Module._PyThread_tss_get=t=>(_PyThread_tss_get=Module._PyThread_tss_get=wasmExports.PyThread_tss_get)(t),_PyThread_tss_set=Module._PyThread_tss_set=(t,e)=>(_PyThread_tss_set=Module._PyThread_tss_set=wasmExports.PyThread_tss_set)(t,e),__PyThreadState_SetCurrent=Module.__PyThreadState_SetCurrent=t=>(__PyThreadState_SetCurrent=Module.__PyThreadState_SetCurrent=wasmExports._PyThreadState_SetCurrent)(t),__PyThreadState_Prealloc=Module.__PyThreadState_Prealloc=t=>(__PyThreadState_Prealloc=Module.__PyThreadState_Prealloc=wasmExports._PyThreadState_Prealloc)(t),__PyThreadState_Init=Module.__PyThreadState_Init=t=>(__PyThreadState_Init=Module.__PyThreadState_Init=wasmExports._PyThreadState_Init)(t),_PyState_FindModule=Module._PyState_FindModule=t=>(_PyState_FindModule=Module._PyState_FindModule=wasmExports.PyState_FindModule)(t),_PyState_AddModule=Module._PyState_AddModule=(t,e)=>(_PyState_AddModule=Module._PyState_AddModule=wasmExports.PyState_AddModule)(t,e),_PyState_RemoveModule=Module._PyState_RemoveModule=t=>(_PyState_RemoveModule=Module._PyState_RemoveModule=wasmExports.PyState_RemoveModule)(t),__PyThreadState_DeleteCurrent=Module.__PyThreadState_DeleteCurrent=t=>(__PyThreadState_DeleteCurrent=Module.__PyThreadState_DeleteCurrent=wasmExports._PyThreadState_DeleteCurrent)(t),_PyThreadState_DeleteCurrent=Module._PyThreadState_DeleteCurrent=()=>(_PyThreadState_DeleteCurrent=Module._PyThreadState_DeleteCurrent=wasmExports.PyThreadState_DeleteCurrent)(),__PyThreadState_UncheckedGet=Module.__PyThreadState_UncheckedGet=()=>(__PyThreadState_UncheckedGet=Module.__PyThreadState_UncheckedGet=wasmExports._PyThreadState_UncheckedGet)(),__PyThreadState_GetDict=Module.__PyThreadState_GetDict=t=>(__PyThreadState_GetDict=Module.__PyThreadState_GetDict=wasmExports._PyThreadState_GetDict)(t),_PyThreadState_GetInterpreter=Module._PyThreadState_GetInterpreter=t=>(_PyThreadState_GetInterpreter=Module._PyThreadState_GetInterpreter=wasmExports.PyThreadState_GetInterpreter)(t),_PyThreadState_GetID=Module._PyThreadState_GetID=t=>(_PyThreadState_GetID=Module._PyThreadState_GetID=wasmExports.PyThreadState_GetID)(t),_PyThreadState_SetAsyncExc=Module._PyThreadState_SetAsyncExc=(t,e)=>(_PyThreadState_SetAsyncExc=Module._PyThreadState_SetAsyncExc=wasmExports.PyThreadState_SetAsyncExc)(t,e),_PyInterpreterState_Head=Module._PyInterpreterState_Head=()=>(_PyInterpreterState_Head=Module._PyInterpreterState_Head=wasmExports.PyInterpreterState_Head)(),_PyInterpreterState_Main=Module._PyInterpreterState_Main=()=>(_PyInterpreterState_Main=Module._PyInterpreterState_Main=wasmExports.PyInterpreterState_Main)(),_PyInterpreterState_Next=Module._PyInterpreterState_Next=t=>(_PyInterpreterState_Next=Module._PyInterpreterState_Next=wasmExports.PyInterpreterState_Next)(t),_PyThreadState_Next=Module._PyThreadState_Next=t=>(_PyThreadState_Next=Module._PyThreadState_Next=wasmExports.PyThreadState_Next)(t),__PyThread_CurrentFrames=Module.__PyThread_CurrentFrames=()=>(__PyThread_CurrentFrames=Module.__PyThread_CurrentFrames=wasmExports._PyThread_CurrentFrames)(),__PyThread_CurrentExceptions=Module.__PyThread_CurrentExceptions=()=>(__PyThread_CurrentExceptions=Module.__PyThread_CurrentExceptions=wasmExports._PyThread_CurrentExceptions)(),_PyThread_tss_create=Module._PyThread_tss_create=t=>(_PyThread_tss_create=Module._PyThread_tss_create=wasmExports.PyThread_tss_create)(t),__PyGILState_GetInterpreterStateUnsafe=Module.__PyGILState_GetInterpreterStateUnsafe=()=>(__PyGILState_GetInterpreterStateUnsafe=Module.__PyGILState_GetInterpreterStateUnsafe=wasmExports._PyGILState_GetInterpreterStateUnsafe)(),_PyThread_tss_delete=Module._PyThread_tss_delete=t=>(_PyThread_tss_delete=Module._PyThread_tss_delete=wasmExports.PyThread_tss_delete)(t),_PyThread_tss_is_created=Module._PyThread_tss_is_created=t=>(_PyThread_tss_is_created=Module._PyThread_tss_is_created=wasmExports.PyThread_tss_is_created)(t),__PyObject_CheckCrossInterpreterData=Module.__PyObject_CheckCrossInterpreterData=t=>(__PyObject_CheckCrossInterpreterData=Module.__PyObject_CheckCrossInterpreterData=wasmExports._PyObject_CheckCrossInterpreterData)(t),__PyCrossInterpreterData_Lookup=Module.__PyCrossInterpreterData_Lookup=t=>(__PyCrossInterpreterData_Lookup=Module.__PyCrossInterpreterData_Lookup=wasmExports._PyCrossInterpreterData_Lookup)(t),__PyObject_GetCrossInterpreterData=Module.__PyObject_GetCrossInterpreterData=(t,e)=>(__PyObject_GetCrossInterpreterData=Module.__PyObject_GetCrossInterpreterData=wasmExports._PyObject_GetCrossInterpreterData)(t,e),__PyCrossInterpreterData_Release=Module.__PyCrossInterpreterData_Release=t=>(__PyCrossInterpreterData_Release=Module.__PyCrossInterpreterData_Release=wasmExports._PyCrossInterpreterData_Release)(t),__PyCrossInterpreterData_NewObject=Module.__PyCrossInterpreterData_NewObject=t=>(__PyCrossInterpreterData_NewObject=Module.__PyCrossInterpreterData_NewObject=wasmExports._PyCrossInterpreterData_NewObject)(t),__PyCrossInterpreterData_RegisterClass=Module.__PyCrossInterpreterData_RegisterClass=(t,e)=>(__PyCrossInterpreterData_RegisterClass=Module.__PyCrossInterpreterData_RegisterClass=wasmExports._PyCrossInterpreterData_RegisterClass)(t,e),__PyInterpreterState_GetEvalFrameFunc=Module.__PyInterpreterState_GetEvalFrameFunc=t=>(__PyInterpreterState_GetEvalFrameFunc=Module.__PyInterpreterState_GetEvalFrameFunc=wasmExports._PyInterpreterState_GetEvalFrameFunc)(t),__PyInterpreterState_SetEvalFrameFunc=Module.__PyInterpreterState_SetEvalFrameFunc=(t,e)=>(__PyInterpreterState_SetEvalFrameFunc=Module.__PyInterpreterState_SetEvalFrameFunc=wasmExports._PyInterpreterState_SetEvalFrameFunc)(t,e),__PyInterpreterState_GetConfigCopy=Module.__PyInterpreterState_GetConfigCopy=t=>(__PyInterpreterState_GetConfigCopy=Module.__PyInterpreterState_GetConfigCopy=wasmExports._PyInterpreterState_GetConfigCopy)(t),__PyRun_AnyFileObject=Module.__PyRun_AnyFileObject=(t,e,n,_)=>(__PyRun_AnyFileObject=Module.__PyRun_AnyFileObject=wasmExports._PyRun_AnyFileObject)(t,e,n,_),__PyRun_InteractiveLoopObject=Module.__PyRun_InteractiveLoopObject=(t,e,n)=>(__PyRun_InteractiveLoopObject=Module.__PyRun_InteractiveLoopObject=wasmExports._PyRun_InteractiveLoopObject)(t,e,n),__PyRun_SimpleFileObject=Module.__PyRun_SimpleFileObject=(t,e,n,_)=>(__PyRun_SimpleFileObject=Module.__PyRun_SimpleFileObject=wasmExports._PyRun_SimpleFileObject)(t,e,n,_),_rewind=Module._rewind=t=>(_rewind=Module._rewind=wasmExports.rewind)(t),_PyRun_InteractiveLoopFlags=Module._PyRun_InteractiveLoopFlags=(t,e,n)=>(_PyRun_InteractiveLoopFlags=Module._PyRun_InteractiveLoopFlags=wasmExports.PyRun_InteractiveLoopFlags)(t,e,n),_PyRun_InteractiveOneObject=Module._PyRun_InteractiveOneObject=(t,e,n)=>(_PyRun_InteractiveOneObject=Module._PyRun_InteractiveOneObject=wasmExports.PyRun_InteractiveOneObject)(t,e,n),_PyRun_InteractiveOneFlags=Module._PyRun_InteractiveOneFlags=(t,e,n)=>(_PyRun_InteractiveOneFlags=Module._PyRun_InteractiveOneFlags=wasmExports.PyRun_InteractiveOneFlags)(t,e,n),_PyRun_SimpleFileExFlags=Module._PyRun_SimpleFileExFlags=(t,e,n,_)=>(_PyRun_SimpleFileExFlags=Module._PyRun_SimpleFileExFlags=wasmExports.PyRun_SimpleFileExFlags)(t,e,n,_),_PyRun_SimpleStringFlags=Module._PyRun_SimpleStringFlags=(t,e)=>(_PyRun_SimpleStringFlags=Module._PyRun_SimpleStringFlags=wasmExports.PyRun_SimpleStringFlags)(t,e),__Py_HandleSystemExit=Module.__Py_HandleSystemExit=t=>(__Py_HandleSystemExit=Module.__Py_HandleSystemExit=wasmExports._Py_HandleSystemExit)(t),__PyErr_Display=Module.__PyErr_Display=(t,e,n,_)=>(__PyErr_Display=Module.__PyErr_Display=wasmExports._PyErr_Display)(t,e,n,_),__Py_WriteIndentedMargin=Module.__Py_WriteIndentedMargin=(t,e,n)=>(__Py_WriteIndentedMargin=Module.__Py_WriteIndentedMargin=wasmExports._Py_WriteIndentedMargin)(t,e,n),__Py_WriteIndent=Module.__Py_WriteIndent=(t,e)=>(__Py_WriteIndent=Module.__Py_WriteIndent=wasmExports._Py_WriteIndent)(t,e),_PyRun_FileExFlags=Module._PyRun_FileExFlags=(t,e,n,_,r,a,o)=>(_PyRun_FileExFlags=Module._PyRun_FileExFlags=wasmExports.PyRun_FileExFlags)(t,e,n,_,r,a,o),_Py_CompileStringExFlags=Module._Py_CompileStringExFlags=(t,e,n,_,r)=>(_Py_CompileStringExFlags=Module._Py_CompileStringExFlags=wasmExports.Py_CompileStringExFlags)(t,e,n,_,r),_PyRun_AnyFile=Module._PyRun_AnyFile=(t,e)=>(_PyRun_AnyFile=Module._PyRun_AnyFile=wasmExports.PyRun_AnyFile)(t,e),_PyRun_AnyFileEx=Module._PyRun_AnyFileEx=(t,e,n)=>(_PyRun_AnyFileEx=Module._PyRun_AnyFileEx=wasmExports.PyRun_AnyFileEx)(t,e,n),_PyRun_AnyFileFlags=Module._PyRun_AnyFileFlags=(t,e,n)=>(_PyRun_AnyFileFlags=Module._PyRun_AnyFileFlags=wasmExports.PyRun_AnyFileFlags)(t,e,n),_PyRun_File=Module._PyRun_File=(t,e,n,_,r)=>(_PyRun_File=Module._PyRun_File=wasmExports.PyRun_File)(t,e,n,_,r),_PyRun_FileEx=Module._PyRun_FileEx=(t,e,n,_,r,a)=>(_PyRun_FileEx=Module._PyRun_FileEx=wasmExports.PyRun_FileEx)(t,e,n,_,r,a),_PyRun_FileFlags=Module._PyRun_FileFlags=(t,e,n,_,r,a)=>(_PyRun_FileFlags=Module._PyRun_FileFlags=wasmExports.PyRun_FileFlags)(t,e,n,_,r,a),_PyRun_SimpleFile=Module._PyRun_SimpleFile=(t,e)=>(_PyRun_SimpleFile=Module._PyRun_SimpleFile=wasmExports.PyRun_SimpleFile)(t,e),_PyRun_SimpleFileEx=Module._PyRun_SimpleFileEx=(t,e,n)=>(_PyRun_SimpleFileEx=Module._PyRun_SimpleFileEx=wasmExports.PyRun_SimpleFileEx)(t,e,n),_PyRun_String=Module._PyRun_String=(t,e,n,_)=>(_PyRun_String=Module._PyRun_String=wasmExports.PyRun_String)(t,e,n,_),_PyRun_SimpleString=Module._PyRun_SimpleString=t=>(_PyRun_SimpleString=Module._PyRun_SimpleString=wasmExports.PyRun_SimpleString)(t),_Py_CompileString=Module._Py_CompileString=(t,e,n)=>(_Py_CompileString=Module._Py_CompileString=wasmExports.Py_CompileString)(t,e,n),_Py_CompileStringFlags=Module._Py_CompileStringFlags=(t,e,n,_)=>(_Py_CompileStringFlags=Module._Py_CompileStringFlags=wasmExports.Py_CompileStringFlags)(t,e,n,_),_PyRun_InteractiveOne=Module._PyRun_InteractiveOne=(t,e)=>(_PyRun_InteractiveOne=Module._PyRun_InteractiveOne=wasmExports.PyRun_InteractiveOne)(t,e),_PyRun_InteractiveLoop=Module._PyRun_InteractiveLoop=(t,e)=>(_PyRun_InteractiveLoop=Module._PyRun_InteractiveLoop=wasmExports.PyRun_InteractiveLoop)(t,e),__PyTraceBack_Print_Indented=Module.__PyTraceBack_Print_Indented=(t,e,n,_,r,a)=>(__PyTraceBack_Print_Indented=Module.__PyTraceBack_Print_Indented=wasmExports._PyTraceBack_Print_Indented)(t,e,n,_,r,a),__PyTime_Add=Module.__PyTime_Add=(t,e)=>(__PyTime_Add=Module.__PyTime_Add=wasmExports._PyTime_Add)(t,e),__PyTime_MulDiv=Module.__PyTime_MulDiv=(t,e,n)=>(__PyTime_MulDiv=Module.__PyTime_MulDiv=wasmExports._PyTime_MulDiv)(t,e,n),__PyLong_AsTime_t=Module.__PyLong_AsTime_t=t=>(__PyLong_AsTime_t=Module.__PyLong_AsTime_t=wasmExports._PyLong_AsTime_t)(t),__PyLong_FromTime_t=Module.__PyLong_FromTime_t=t=>(__PyLong_FromTime_t=Module.__PyLong_FromTime_t=wasmExports._PyLong_FromTime_t)(t),__PyTime_ObjectToTime_t=Module.__PyTime_ObjectToTime_t=(t,e,n)=>(__PyTime_ObjectToTime_t=Module.__PyTime_ObjectToTime_t=wasmExports._PyTime_ObjectToTime_t)(t,e,n),__PyTime_ObjectToTimespec=Module.__PyTime_ObjectToTimespec=(t,e,n,_)=>(__PyTime_ObjectToTimespec=Module.__PyTime_ObjectToTimespec=wasmExports._PyTime_ObjectToTimespec)(t,e,n,_),__PyTime_ObjectToTimeval=Module.__PyTime_ObjectToTimeval=(t,e,n,_)=>(__PyTime_ObjectToTimeval=Module.__PyTime_ObjectToTimeval=wasmExports._PyTime_ObjectToTimeval)(t,e,n,_),__PyTime_FromSeconds=Module.__PyTime_FromSeconds=t=>(__PyTime_FromSeconds=Module.__PyTime_FromSeconds=wasmExports._PyTime_FromSeconds)(t),__PyTime_FromNanoseconds=Module.__PyTime_FromNanoseconds=t=>(__PyTime_FromNanoseconds=Module.__PyTime_FromNanoseconds=wasmExports._PyTime_FromNanoseconds)(t),__PyTime_FromNanosecondsObject=Module.__PyTime_FromNanosecondsObject=(t,e)=>(__PyTime_FromNanosecondsObject=Module.__PyTime_FromNanosecondsObject=wasmExports._PyTime_FromNanosecondsObject)(t,e),__PyTime_FromTimespec=Module.__PyTime_FromTimespec=(t,e)=>(__PyTime_FromTimespec=Module.__PyTime_FromTimespec=wasmExports._PyTime_FromTimespec)(t,e),__PyTime_FromTimeval=Module.__PyTime_FromTimeval=(t,e)=>(__PyTime_FromTimeval=Module.__PyTime_FromTimeval=wasmExports._PyTime_FromTimeval)(t,e),__PyTime_FromSecondsObject=Module.__PyTime_FromSecondsObject=(t,e,n)=>(__PyTime_FromSecondsObject=Module.__PyTime_FromSecondsObject=wasmExports._PyTime_FromSecondsObject)(t,e,n),__PyTime_FromMillisecondsObject=Module.__PyTime_FromMillisecondsObject=(t,e,n)=>(__PyTime_FromMillisecondsObject=Module.__PyTime_FromMillisecondsObject=wasmExports._PyTime_FromMillisecondsObject)(t,e,n),__PyTime_AsSecondsDouble=Module.__PyTime_AsSecondsDouble=t=>(__PyTime_AsSecondsDouble=Module.__PyTime_AsSecondsDouble=wasmExports._PyTime_AsSecondsDouble)(t),__PyTime_AsNanosecondsObject=Module.__PyTime_AsNanosecondsObject=t=>(__PyTime_AsNanosecondsObject=Module.__PyTime_AsNanosecondsObject=wasmExports._PyTime_AsNanosecondsObject)(t),__PyTime_AsNanoseconds=Module.__PyTime_AsNanoseconds=t=>(__PyTime_AsNanoseconds=Module.__PyTime_AsNanoseconds=wasmExports._PyTime_AsNanoseconds)(t),__PyTime_AsMilliseconds=Module.__PyTime_AsMilliseconds=(t,e)=>(__PyTime_AsMilliseconds=Module.__PyTime_AsMilliseconds=wasmExports._PyTime_AsMilliseconds)(t,e),__PyTime_AsTimeval=Module.__PyTime_AsTimeval=(t,e,n)=>(__PyTime_AsTimeval=Module.__PyTime_AsTimeval=wasmExports._PyTime_AsTimeval)(t,e,n),__PyTime_AsTimeval_clamp=Module.__PyTime_AsTimeval_clamp=(t,e,n)=>(__PyTime_AsTimeval_clamp=Module.__PyTime_AsTimeval_clamp=wasmExports._PyTime_AsTimeval_clamp)(t,e,n),__PyTime_AsTimevalTime_t=Module.__PyTime_AsTimevalTime_t=(t,e,n,_)=>(__PyTime_AsTimevalTime_t=Module.__PyTime_AsTimevalTime_t=wasmExports._PyTime_AsTimevalTime_t)(t,e,n,_),__PyTime_AsTimespec_clamp=Module.__PyTime_AsTimespec_clamp=(t,e)=>(__PyTime_AsTimespec_clamp=Module.__PyTime_AsTimespec_clamp=wasmExports._PyTime_AsTimespec_clamp)(t,e),__PyTime_AsTimespec=Module.__PyTime_AsTimespec=(t,e)=>(__PyTime_AsTimespec=Module.__PyTime_AsTimespec=wasmExports._PyTime_AsTimespec)(t,e),__PyTime_GetSystemClock=Module.__PyTime_GetSystemClock=()=>(__PyTime_GetSystemClock=Module.__PyTime_GetSystemClock=wasmExports._PyTime_GetSystemClock)(),_clock_gettime=Module._clock_gettime=(t,e)=>(_clock_gettime=Module._clock_gettime=wasmExports.clock_gettime)(t,e),__PyTime_GetSystemClockWithInfo=Module.__PyTime_GetSystemClockWithInfo=(t,e)=>(__PyTime_GetSystemClockWithInfo=Module.__PyTime_GetSystemClockWithInfo=wasmExports._PyTime_GetSystemClockWithInfo)(t,e),_clock_getres=Module._clock_getres=(t,e)=>(_clock_getres=Module._clock_getres=wasmExports.clock_getres)(t,e),__PyTime_GetMonotonicClock=Module.__PyTime_GetMonotonicClock=()=>(__PyTime_GetMonotonicClock=Module.__PyTime_GetMonotonicClock=wasmExports._PyTime_GetMonotonicClock)(),__PyTime_GetMonotonicClockWithInfo=Module.__PyTime_GetMonotonicClockWithInfo=(t,e)=>(__PyTime_GetMonotonicClockWithInfo=Module.__PyTime_GetMonotonicClockWithInfo=wasmExports._PyTime_GetMonotonicClockWithInfo)(t,e),__PyTime_GetPerfCounterWithInfo=Module.__PyTime_GetPerfCounterWithInfo=(t,e)=>(__PyTime_GetPerfCounterWithInfo=Module.__PyTime_GetPerfCounterWithInfo=wasmExports._PyTime_GetPerfCounterWithInfo)(t,e),__PyTime_localtime=Module.__PyTime_localtime=(t,e)=>(__PyTime_localtime=Module.__PyTime_localtime=wasmExports._PyTime_localtime)(t,e),_localtime_r=Module._localtime_r=(t,e)=>(_localtime_r=Module._localtime_r=wasmExports.localtime_r)(t,e),__PyTime_gmtime=Module.__PyTime_gmtime=(t,e)=>(__PyTime_gmtime=Module.__PyTime_gmtime=wasmExports._PyTime_gmtime)(t,e),_gmtime_r=Module._gmtime_r=(t,e)=>(_gmtime_r=Module._gmtime_r=wasmExports.gmtime_r)(t,e),__PyDeadline_Init=Module.__PyDeadline_Init=t=>(__PyDeadline_Init=Module.__PyDeadline_Init=wasmExports._PyDeadline_Init)(t),__PyDeadline_Get=Module.__PyDeadline_Get=t=>(__PyDeadline_Get=Module.__PyDeadline_Get=wasmExports._PyDeadline_Get)(t),__PyOS_URandom=Module.__PyOS_URandom=(t,e)=>(__PyOS_URandom=Module.__PyOS_URandom=wasmExports._PyOS_URandom)(t,e),__Py_open=Module.__Py_open=(t,e)=>(__Py_open=Module.__Py_open=wasmExports._Py_open)(t,e),_close=Module._close=t=>(_close=Module._close=wasmExports.close)(t),__Py_fstat=Module.__Py_fstat=(t,e)=>(__Py_fstat=Module.__Py_fstat=wasmExports._Py_fstat)(t,e),__Py_read=Module.__Py_read=(t,e,n)=>(__Py_read=Module.__Py_read=wasmExports._Py_read)(t,e,n),__Py_open_noraise=Module.__Py_open_noraise=(t,e)=>(__Py_open_noraise=Module.__Py_open_noraise=wasmExports._Py_open_noraise)(t,e),_read=Module._read=(t,e,n)=>(_read=Module._read=wasmExports.read)(t,e,n),__PyOS_URandomNonblock=Module.__PyOS_URandomNonblock=(t,e)=>(__PyOS_URandomNonblock=Module.__PyOS_URandomNonblock=wasmExports._PyOS_URandomNonblock)(t,e),_PySys_AddAuditHook=Module._PySys_AddAuditHook=(t,e)=>(_PySys_AddAuditHook=Module._PySys_AddAuditHook=wasmExports.PySys_AddAuditHook)(t,e),__PySys_GetSizeOf=Module.__PySys_GetSizeOf=t=>(__PySys_GetSizeOf=Module.__PySys_GetSizeOf=wasmExports._PySys_GetSizeOf)(t),_PySys_ResetWarnOptions=Module._PySys_ResetWarnOptions=()=>(_PySys_ResetWarnOptions=Module._PySys_ResetWarnOptions=wasmExports.PySys_ResetWarnOptions)(),_PySys_AddWarnOptionUnicode=Module._PySys_AddWarnOptionUnicode=t=>(_PySys_AddWarnOptionUnicode=Module._PySys_AddWarnOptionUnicode=wasmExports.PySys_AddWarnOptionUnicode)(t),_PySys_AddWarnOption=Module._PySys_AddWarnOption=t=>(_PySys_AddWarnOption=Module._PySys_AddWarnOption=wasmExports.PySys_AddWarnOption)(t),_PySys_HasWarnOptions=Module._PySys_HasWarnOptions=()=>(_PySys_HasWarnOptions=Module._PySys_HasWarnOptions=wasmExports.PySys_HasWarnOptions)(),_PySys_AddXOption=Module._PySys_AddXOption=t=>(_PySys_AddXOption=Module._PySys_AddXOption=wasmExports.PySys_AddXOption)(t),_PySys_GetXOptions=Module._PySys_GetXOptions=()=>(_PySys_GetXOptions=Module._PySys_GetXOptions=wasmExports.PySys_GetXOptions)(),_PyThread_GetInfo=Module._PyThread_GetInfo=()=>(_PyThread_GetInfo=Module._PyThread_GetInfo=wasmExports.PyThread_GetInfo)(),_PySys_SetPath=Module._PySys_SetPath=t=>(_PySys_SetPath=Module._PySys_SetPath=wasmExports.PySys_SetPath)(t),_PySys_SetArgvEx=Module._PySys_SetArgvEx=(t,e,n)=>(_PySys_SetArgvEx=Module._PySys_SetArgvEx=wasmExports.PySys_SetArgvEx)(t,e,n),_PySys_SetArgv=Module._PySys_SetArgv=(t,e)=>(_PySys_SetArgv=Module._PySys_SetArgv=wasmExports.PySys_SetArgv)(t,e),_PySys_WriteStdout=Module._PySys_WriteStdout=(t,e)=>(_PySys_WriteStdout=Module._PySys_WriteStdout=wasmExports.PySys_WriteStdout)(t,e),_PySys_FormatStdout=Module._PySys_FormatStdout=(t,e)=>(_PySys_FormatStdout=Module._PySys_FormatStdout=wasmExports.PySys_FormatStdout)(t,e),_pthread_condattr_init=Module._pthread_condattr_init=t=>(_pthread_condattr_init=Module._pthread_condattr_init=wasmExports.pthread_condattr_init)(t),_pthread_condattr_setclock=Module._pthread_condattr_setclock=(t,e)=>(_pthread_condattr_setclock=Module._pthread_condattr_setclock=wasmExports.pthread_condattr_setclock)(t,e),_pthread_cond_init=Module._pthread_cond_init=(t,e)=>(_pthread_cond_init=Module._pthread_cond_init=wasmExports.pthread_cond_init)(t,e),_gettimeofday=Module._gettimeofday=(t,e)=>(_gettimeofday=Module._gettimeofday=wasmExports.gettimeofday)(t,e),_PyThread_start_new_thread=Module._PyThread_start_new_thread=(t,e)=>(_PyThread_start_new_thread=Module._PyThread_start_new_thread=wasmExports.PyThread_start_new_thread)(t,e),_pthread_attr_init=Module._pthread_attr_init=t=>(_pthread_attr_init=Module._pthread_attr_init=wasmExports.pthread_attr_init)(t),_pthread_attr_setstacksize=Module._pthread_attr_setstacksize=(t,e)=>(_pthread_attr_setstacksize=Module._pthread_attr_setstacksize=wasmExports.pthread_attr_setstacksize)(t,e),_pthread_attr_destroy=Module._pthread_attr_destroy=t=>(_pthread_attr_destroy=Module._pthread_attr_destroy=wasmExports.pthread_attr_destroy)(t),_pthread_create=Module._pthread_create=(t,e,n,_)=>(_pthread_create=Module._pthread_create=wasmExports.pthread_create)(t,e,n,_),_pthread_detach=Module._pthread_detach=t=>(_pthread_detach=Module._pthread_detach=wasmExports.pthread_detach)(t),_pthread_self=Module._pthread_self=()=>(_pthread_self=Module._pthread_self=wasmExports.pthread_self)(),_pthread_exit=Module._pthread_exit=t=>(_pthread_exit=Module._pthread_exit=wasmExports.pthread_exit)(t),_PyThread_acquire_lock_timed=Module._PyThread_acquire_lock_timed=(t,e,n)=>(_PyThread_acquire_lock_timed=Module._PyThread_acquire_lock_timed=wasmExports.PyThread_acquire_lock_timed)(t,e,n),_pthread_mutex_trylock=Module._pthread_mutex_trylock=t=>(_pthread_mutex_trylock=Module._pthread_mutex_trylock=wasmExports.pthread_mutex_trylock)(t),_PyThread_create_key=Module._PyThread_create_key=()=>(_PyThread_create_key=Module._PyThread_create_key=wasmExports.PyThread_create_key)(),_pthread_key_create=Module._pthread_key_create=(t,e)=>(_pthread_key_create=Module._pthread_key_create=wasmExports.pthread_key_create)(t,e),_pthread_key_delete=Module._pthread_key_delete=t=>(_pthread_key_delete=Module._pthread_key_delete=wasmExports.pthread_key_delete)(t),_PyThread_delete_key=Module._PyThread_delete_key=t=>(_PyThread_delete_key=Module._PyThread_delete_key=wasmExports.PyThread_delete_key)(t),_PyThread_delete_key_value=Module._PyThread_delete_key_value=t=>(_PyThread_delete_key_value=Module._PyThread_delete_key_value=wasmExports.PyThread_delete_key_value)(t),_pthread_setspecific=Module._pthread_setspecific=(t,e)=>(_pthread_setspecific=Module._pthread_setspecific=wasmExports.pthread_setspecific)(t,e),_PyThread_set_key_value=Module._PyThread_set_key_value=(t,e)=>(_PyThread_set_key_value=Module._PyThread_set_key_value=wasmExports.PyThread_set_key_value)(t,e),_PyThread_get_key_value=Module._PyThread_get_key_value=t=>(_PyThread_get_key_value=Module._PyThread_get_key_value=wasmExports.PyThread_get_key_value)(t),_pthread_getspecific=Module._pthread_getspecific=t=>(_pthread_getspecific=Module._pthread_getspecific=wasmExports.pthread_getspecific)(t),_PyThread_ReInitTLS=Module._PyThread_ReInitTLS=()=>(_PyThread_ReInitTLS=Module._PyThread_ReInitTLS=wasmExports.PyThread_ReInitTLS)(),_PyThread_get_stacksize=Module._PyThread_get_stacksize=()=>(_PyThread_get_stacksize=Module._PyThread_get_stacksize=wasmExports.PyThread_get_stacksize)(),_PyThread_set_stacksize=Module._PyThread_set_stacksize=t=>(_PyThread_set_stacksize=Module._PyThread_set_stacksize=wasmExports.PyThread_set_stacksize)(t),_PyThread_tss_alloc=Module._PyThread_tss_alloc=()=>(_PyThread_tss_alloc=Module._PyThread_tss_alloc=wasmExports.PyThread_tss_alloc)(),_PyThread_tss_free=Module._PyThread_tss_free=t=>(_PyThread_tss_free=Module._PyThread_tss_free=wasmExports.PyThread_tss_free)(t),_confstr=Module._confstr=(t,e,n)=>(_confstr=Module._confstr=wasmExports.confstr)(t,e,n),__PyTraceback_Add=Module.__PyTraceback_Add=(t,e,n)=>(__PyTraceback_Add=Module.__PyTraceback_Add=wasmExports._PyTraceback_Add)(t,e,n),_PyOS_mystricmp=Module._PyOS_mystricmp=(t,e)=>(_PyOS_mystricmp=Module._PyOS_mystricmp=wasmExports.PyOS_mystricmp)(t,e),__Py_strhex=Module.__Py_strhex=(t,e)=>(__Py_strhex=Module.__Py_strhex=wasmExports._Py_strhex)(t,e),__Py_strhex_bytes=Module.__Py_strhex_bytes=(t,e)=>(__Py_strhex_bytes=Module.__Py_strhex_bytes=wasmExports._Py_strhex_bytes)(t,e),__Py_strhex_bytes_with_sep=Module.__Py_strhex_bytes_with_sep=(t,e,n,_)=>(__Py_strhex_bytes_with_sep=Module.__Py_strhex_bytes_with_sep=wasmExports._Py_strhex_bytes_with_sep)(t,e,n,_),_localeconv=Module._localeconv=()=>(_localeconv=Module._localeconv=wasmExports.localeconv)(),__Py_GetLocaleconvNumeric=Module.__Py_GetLocaleconvNumeric=(t,e,n)=>(__Py_GetLocaleconvNumeric=Module.__Py_GetLocaleconvNumeric=wasmExports._Py_GetLocaleconvNumeric)(t,e,n),__Py_device_encoding=Module.__Py_device_encoding=t=>(__Py_device_encoding=Module.__Py_device_encoding=wasmExports._Py_device_encoding)(t),__Py_GetLocaleEncodingObject=Module.__Py_GetLocaleEncodingObject=()=>(__Py_GetLocaleEncodingObject=Module.__Py_GetLocaleEncodingObject=wasmExports._Py_GetLocaleEncodingObject)(),_mbstowcs=Module._mbstowcs=(t,e,n)=>(_mbstowcs=Module._mbstowcs=wasmExports.mbstowcs)(t,e,n),_mbrtowc=Module._mbrtowc=(t,e,n,_)=>(_mbrtowc=Module._mbrtowc=wasmExports.mbrtowc)(t,e,n,_),_Py_EncodeLocale=Module._Py_EncodeLocale=(t,e)=>(_Py_EncodeLocale=Module._Py_EncodeLocale=wasmExports.Py_EncodeLocale)(t,e),__Py_EncodeLocaleRaw=Module.__Py_EncodeLocaleRaw=(t,e)=>(__Py_EncodeLocaleRaw=Module.__Py_EncodeLocaleRaw=wasmExports._Py_EncodeLocaleRaw)(t,e),_fstat=Module._fstat=(t,e)=>(_fstat=Module._fstat=wasmExports.fstat)(t,e),_stat=Module._stat=(t,e)=>(_stat=Module._stat=wasmExports.stat)(t,e),__Py_stat=Module.__Py_stat=(t,e)=>(__Py_stat=Module.__Py_stat=wasmExports._Py_stat)(t,e),__Py_get_inheritable=Module.__Py_get_inheritable=t=>(__Py_get_inheritable=Module.__Py_get_inheritable=wasmExports._Py_get_inheritable)(t),__Py_set_inheritable=Module.__Py_set_inheritable=(t,e,n)=>(__Py_set_inheritable=Module.__Py_set_inheritable=wasmExports._Py_set_inheritable)(t,e,n),__Py_set_inheritable_async_safe=Module.__Py_set_inheritable_async_safe=(t,e,n)=>(__Py_set_inheritable_async_safe=Module.__Py_set_inheritable_async_safe=wasmExports._Py_set_inheritable_async_safe)(t,e,n),_open=Module._open=(t,e,n)=>(_open=Module._open=wasmExports.open)(t,e,n),__Py_wfopen=Module.__Py_wfopen=(t,e)=>(__Py_wfopen=Module.__Py_wfopen=wasmExports._Py_wfopen)(t,e),_wcstombs=Module._wcstombs=(t,e,n)=>(_wcstombs=Module._wcstombs=wasmExports.wcstombs)(t,e,n),_fopen=Module._fopen=(t,e)=>(_fopen=Module._fopen=wasmExports.fopen)(t,e),_write=Module._write=(t,e,n)=>(_write=Module._write=wasmExports.write)(t,e,n),_readlink=Module._readlink=(t,e,n)=>(_readlink=Module._readlink=wasmExports.readlink)(t,e,n),_realpath=Module._realpath=(t,e)=>(_realpath=Module._realpath=wasmExports.realpath)(t,e),_getcwd=Module._getcwd=(t,e)=>(_getcwd=Module._getcwd=wasmExports.getcwd)(t,e),__Py_normpath=Module.__Py_normpath=(t,e)=>(__Py_normpath=Module.__Py_normpath=wasmExports._Py_normpath)(t,e),__Py_get_blocking=Module.__Py_get_blocking=t=>(__Py_get_blocking=Module.__Py_get_blocking=wasmExports._Py_get_blocking)(t),__Py_set_blocking=Module.__Py_set_blocking=(t,e)=>(__Py_set_blocking=Module.__Py_set_blocking=wasmExports._Py_set_blocking)(t,e),__Py_closerange=Module.__Py_closerange=(t,e)=>(__Py_closerange=Module.__Py_closerange=wasmExports._Py_closerange)(t,e),__Py_UTF8_Edit_Cost=Module.__Py_UTF8_Edit_Cost=(t,e,n)=>(__Py_UTF8_Edit_Cost=Module.__Py_UTF8_Edit_Cost=wasmExports._Py_UTF8_Edit_Cost)(t,e,n),_dlopen=Module._dlopen=(t,e)=>(_dlopen=Module._dlopen=wasmExports.dlopen)(t,e),_dlerror=Module._dlerror=()=>(_dlerror=Module._dlerror=wasmExports.dlerror)(),_dlsym=Module._dlsym=(t,e)=>(_dlsym=Module._dlsym=wasmExports.dlsym)(t,e),_PyErr_SetInterruptEx=Module._PyErr_SetInterruptEx=t=>(_PyErr_SetInterruptEx=Module._PyErr_SetInterruptEx=wasmExports.PyErr_SetInterruptEx)(t),_PyInit__ctypes=Module._PyInit__ctypes=()=>(_PyInit__ctypes=Module._PyInit__ctypes=wasmExports.PyInit__ctypes)(),_PyInit__posixsubprocess=Module._PyInit__posixsubprocess=()=>(_PyInit__posixsubprocess=Module._PyInit__posixsubprocess=wasmExports.PyInit__posixsubprocess)(),_PyInit__bz2=Module._PyInit__bz2=()=>(_PyInit__bz2=Module._PyInit__bz2=wasmExports.PyInit__bz2)(),_PyInit_zlib=Module._PyInit_zlib=()=>(_PyInit_zlib=Module._PyInit_zlib=wasmExports.PyInit_zlib)(),_PyInit__xxsubinterpreters=Module._PyInit__xxsubinterpreters=()=>(_PyInit__xxsubinterpreters=Module._PyInit__xxsubinterpreters=wasmExports.PyInit__xxsubinterpreters)(),_PyInit_array=Module._PyInit_array=()=>(_PyInit_array=Module._PyInit_array=wasmExports.PyInit_array)(),_PyInit__asyncio=Module._PyInit__asyncio=()=>(_PyInit__asyncio=Module._PyInit__asyncio=wasmExports.PyInit__asyncio)(),_PyInit__bisect=Module._PyInit__bisect=()=>(_PyInit__bisect=Module._PyInit__bisect=wasmExports.PyInit__bisect)(),_PyInit__contextvars=Module._PyInit__contextvars=()=>(_PyInit__contextvars=Module._PyInit__contextvars=wasmExports.PyInit__contextvars)(),_PyInit__csv=Module._PyInit__csv=()=>(_PyInit__csv=Module._PyInit__csv=wasmExports.PyInit__csv)(),_PyInit__heapq=Module._PyInit__heapq=()=>(_PyInit__heapq=Module._PyInit__heapq=wasmExports.PyInit__heapq)(),_PyInit__json=Module._PyInit__json=()=>(_PyInit__json=Module._PyInit__json=wasmExports.PyInit__json)(),_PyInit__lsprof=Module._PyInit__lsprof=()=>(_PyInit__lsprof=Module._PyInit__lsprof=wasmExports.PyInit__lsprof)(),_PyInit__opcode=Module._PyInit__opcode=()=>(_PyInit__opcode=Module._PyInit__opcode=wasmExports.PyInit__opcode)(),_PyInit__pickle=Module._PyInit__pickle=()=>(_PyInit__pickle=Module._PyInit__pickle=wasmExports.PyInit__pickle)(),_PyInit__queue=Module._PyInit__queue=()=>(_PyInit__queue=Module._PyInit__queue=wasmExports.PyInit__queue)(),_PyInit__random=Module._PyInit__random=()=>(_PyInit__random=Module._PyInit__random=wasmExports.PyInit__random)(),_PyInit__struct=Module._PyInit__struct=()=>(_PyInit__struct=Module._PyInit__struct=wasmExports.PyInit__struct)(),_PyInit__typing=Module._PyInit__typing=()=>(_PyInit__typing=Module._PyInit__typing=wasmExports.PyInit__typing)(),_PyInit__zoneinfo=Module._PyInit__zoneinfo=()=>(_PyInit__zoneinfo=Module._PyInit__zoneinfo=wasmExports.PyInit__zoneinfo)(),_PyInit_audioop=Module._PyInit_audioop=()=>(_PyInit_audioop=Module._PyInit_audioop=wasmExports.PyInit_audioop)(),_PyInit_math=Module._PyInit_math=()=>(_PyInit_math=Module._PyInit_math=wasmExports.PyInit_math)(),_PyInit_cmath=Module._PyInit_cmath=()=>(_PyInit_cmath=Module._PyInit_cmath=wasmExports.PyInit_cmath)(),_PyInit__statistics=Module._PyInit__statistics=()=>(_PyInit__statistics=Module._PyInit__statistics=wasmExports.PyInit__statistics)(),_PyInit__datetime=Module._PyInit__datetime=()=>(_PyInit__datetime=Module._PyInit__datetime=wasmExports.PyInit__datetime)(),_PyInit__decimal=Module._PyInit__decimal=()=>(_PyInit__decimal=Module._PyInit__decimal=wasmExports.PyInit__decimal)(),_PyInit_binascii=Module._PyInit_binascii=()=>(_PyInit_binascii=Module._PyInit_binascii=wasmExports.PyInit_binascii)(),_PyInit__md5=Module._PyInit__md5=()=>(_PyInit__md5=Module._PyInit__md5=wasmExports.PyInit__md5)(),_PyInit__sha1=Module._PyInit__sha1=()=>(_PyInit__sha1=Module._PyInit__sha1=wasmExports.PyInit__sha1)(),_PyInit__sha256=Module._PyInit__sha256=()=>(_PyInit__sha256=Module._PyInit__sha256=wasmExports.PyInit__sha256)(),_PyInit__sha512=Module._PyInit__sha512=()=>(_PyInit__sha512=Module._PyInit__sha512=wasmExports.PyInit__sha512)(),_PyInit__sha3=Module._PyInit__sha3=()=>(_PyInit__sha3=Module._PyInit__sha3=wasmExports.PyInit__sha3)(),_PyInit__blake2=Module._PyInit__blake2=()=>(_PyInit__blake2=Module._PyInit__blake2=wasmExports.PyInit__blake2)(),_PyInit_pyexpat=Module._PyInit_pyexpat=()=>(_PyInit_pyexpat=Module._PyInit_pyexpat=wasmExports.PyInit_pyexpat)(),_PyInit__elementtree=Module._PyInit__elementtree=()=>(_PyInit__elementtree=Module._PyInit__elementtree=wasmExports.PyInit__elementtree)(),_PyInit__codecs_cn=Module._PyInit__codecs_cn=()=>(_PyInit__codecs_cn=Module._PyInit__codecs_cn=wasmExports.PyInit__codecs_cn)(),_PyInit__codecs_hk=Module._PyInit__codecs_hk=()=>(_PyInit__codecs_hk=Module._PyInit__codecs_hk=wasmExports.PyInit__codecs_hk)(),_PyInit__codecs_iso2022=Module._PyInit__codecs_iso2022=()=>(_PyInit__codecs_iso2022=Module._PyInit__codecs_iso2022=wasmExports.PyInit__codecs_iso2022)(),_PyInit__codecs_jp=Module._PyInit__codecs_jp=()=>(_PyInit__codecs_jp=Module._PyInit__codecs_jp=wasmExports.PyInit__codecs_jp)(),_PyInit__codecs_kr=Module._PyInit__codecs_kr=()=>(_PyInit__codecs_kr=Module._PyInit__codecs_kr=wasmExports.PyInit__codecs_kr)(),_PyInit__codecs_tw=Module._PyInit__codecs_tw=()=>(_PyInit__codecs_tw=Module._PyInit__codecs_tw=wasmExports.PyInit__codecs_tw)(),_PyInit__multibytecodec=Module._PyInit__multibytecodec=()=>(_PyInit__multibytecodec=Module._PyInit__multibytecodec=wasmExports.PyInit__multibytecodec)(),_PyInit_unicodedata=Module._PyInit_unicodedata=()=>(_PyInit_unicodedata=Module._PyInit_unicodedata=wasmExports.PyInit_unicodedata)(),_PyInit__crypt=Module._PyInit__crypt=()=>(_PyInit__crypt=Module._PyInit__crypt=wasmExports.PyInit__crypt)(),_PyInit_mmap=Module._PyInit_mmap=()=>(_PyInit_mmap=Module._PyInit_mmap=wasmExports.PyInit_mmap)(),_PyInit_select=Module._PyInit_select=()=>(_PyInit_select=Module._PyInit_select=wasmExports.PyInit_select)(),_PyInit__socket=Module._PyInit__socket=()=>(_PyInit__socket=Module._PyInit__socket=wasmExports.PyInit__socket)(),_PyInit_atexit=Module._PyInit_atexit=()=>(_PyInit_atexit=Module._PyInit_atexit=wasmExports.PyInit_atexit)(),_PyInit_faulthandler=Module._PyInit_faulthandler=()=>(_PyInit_faulthandler=Module._PyInit_faulthandler=wasmExports.PyInit_faulthandler)(),_PyInit_posix=Module._PyInit_posix=()=>(_PyInit_posix=Module._PyInit_posix=wasmExports.PyInit_posix)(),_PyInit__signal=Module._PyInit__signal=()=>(_PyInit__signal=Module._PyInit__signal=wasmExports.PyInit__signal)(),_PyInit__tracemalloc=Module._PyInit__tracemalloc=()=>(_PyInit__tracemalloc=Module._PyInit__tracemalloc=wasmExports.PyInit__tracemalloc)(),_PyInit__codecs=Module._PyInit__codecs=()=>(_PyInit__codecs=Module._PyInit__codecs=wasmExports.PyInit__codecs)(),_PyInit__collections=Module._PyInit__collections=()=>(_PyInit__collections=Module._PyInit__collections=wasmExports.PyInit__collections)(),_PyInit_errno=Module._PyInit_errno=()=>(_PyInit_errno=Module._PyInit_errno=wasmExports.PyInit_errno)(),_PyInit__io=Module._PyInit__io=()=>(_PyInit__io=Module._PyInit__io=wasmExports.PyInit__io)(),_PyInit_itertools=Module._PyInit_itertools=()=>(_PyInit_itertools=Module._PyInit_itertools=wasmExports.PyInit_itertools)(),_PyInit__sre=Module._PyInit__sre=()=>(_PyInit__sre=Module._PyInit__sre=wasmExports.PyInit__sre)(),_PyInit__thread=Module._PyInit__thread=()=>(_PyInit__thread=Module._PyInit__thread=wasmExports.PyInit__thread)(),_PyInit_time=Module._PyInit_time=()=>(_PyInit_time=Module._PyInit_time=wasmExports.PyInit_time)(),_PyInit__weakref=Module._PyInit__weakref=()=>(_PyInit__weakref=Module._PyInit__weakref=wasmExports.PyInit__weakref)(),_PyInit__abc=Module._PyInit__abc=()=>(_PyInit__abc=Module._PyInit__abc=wasmExports.PyInit__abc)(),_PyInit__functools=Module._PyInit__functools=()=>(_PyInit__functools=Module._PyInit__functools=wasmExports.PyInit__functools)(),_PyInit__locale=Module._PyInit__locale=()=>(_PyInit__locale=Module._PyInit__locale=wasmExports.PyInit__locale)(),_PyInit__operator=Module._PyInit__operator=()=>(_PyInit__operator=Module._PyInit__operator=wasmExports.PyInit__operator)(),_PyInit__stat=Module._PyInit__stat=()=>(_PyInit__stat=Module._PyInit__stat=wasmExports.PyInit__stat)(),_PyInit__symtable=Module._PyInit__symtable=()=>(_PyInit__symtable=Module._PyInit__symtable=wasmExports.PyInit__symtable)(),_PyInit_xxsubtype=Module._PyInit_xxsubtype=()=>(_PyInit_xxsubtype=Module._PyInit_xxsubtype=wasmExports.PyInit_xxsubtype)(),_PyInit_gc=Module._PyInit_gc=()=>(_PyInit_gc=Module._PyInit_gc=wasmExports.PyInit_gc)(),_Py_RunMain=Module._Py_RunMain=()=>(_Py_RunMain=Module._Py_RunMain=wasmExports.Py_RunMain)(),_perror=Module._perror=t=>(_perror=Module._perror=wasmExports.perror)(t),_getpid=Module._getpid=()=>(_getpid=Module._getpid=wasmExports.getpid)(),_kill=Module._kill=(t,e)=>(_kill=Module._kill=wasmExports.kill)(t,e),_Py_Main=Module._Py_Main=(t,e)=>(_Py_Main=Module._Py_Main=wasmExports.Py_Main)(t,e),_Py_BytesMain=Module._Py_BytesMain=(t,e)=>(_Py_BytesMain=Module._Py_BytesMain=wasmExports.Py_BytesMain)(t,e),_PyGC_Enable=Module._PyGC_Enable=()=>(_PyGC_Enable=Module._PyGC_Enable=wasmExports.PyGC_Enable)(),_PyGC_Disable=Module._PyGC_Disable=()=>(_PyGC_Disable=Module._PyGC_Disable=wasmExports.PyGC_Disable)(),_PyGC_IsEnabled=Module._PyGC_IsEnabled=()=>(_PyGC_IsEnabled=Module._PyGC_IsEnabled=wasmExports.PyGC_IsEnabled)(),_PyObject_GC_IsTracked=Module._PyObject_GC_IsTracked=t=>(_PyObject_GC_IsTracked=Module._PyObject_GC_IsTracked=wasmExports.PyObject_GC_IsTracked)(t),_PyObject_GC_IsFinalized=Module._PyObject_GC_IsFinalized=t=>(_PyObject_GC_IsFinalized=Module._PyObject_GC_IsFinalized=wasmExports.PyObject_GC_IsFinalized)(t),_strcat=Module._strcat=(t,e)=>(_strcat=Module._strcat=wasmExports.strcat)(t,e),_ffi_closure_free=Module._ffi_closure_free=t=>(_ffi_closure_free=Module._ffi_closure_free=wasmExports.ffi_closure_free)(t),_ffi_closure_alloc=Module._ffi_closure_alloc=(t,e)=>(_ffi_closure_alloc=Module._ffi_closure_alloc=wasmExports.ffi_closure_alloc)(t,e),_ffi_prep_cif=Module._ffi_prep_cif=(t,e,n,_,r)=>(_ffi_prep_cif=Module._ffi_prep_cif=wasmExports.ffi_prep_cif)(t,e,n,_,r),_ffi_prep_closure_loc=Module._ffi_prep_closure_loc=(t,e,n,_,r)=>(_ffi_prep_closure_loc=Module._ffi_prep_closure_loc=wasmExports.ffi_prep_closure_loc)(t,e,n,_,r),_ffi_prep_cif_var=Module._ffi_prep_cif_var=(t,e,n,_,r,a)=>(_ffi_prep_cif_var=Module._ffi_prep_cif_var=wasmExports.ffi_prep_cif_var)(t,e,n,_,r,a),_ffi_call=Module._ffi_call=(t,e,n,_)=>(_ffi_call=Module._ffi_call=wasmExports.ffi_call)(t,e,n,_),_dlclose=Module._dlclose=t=>(_dlclose=Module._dlclose=wasmExports.dlclose)(t),___extenddftf2=Module.___extenddftf2=(t,e)=>(___extenddftf2=Module.___extenddftf2=wasmExports.__extenddftf2)(t,e),___trunctfdf2=Module.___trunctfdf2=(t,e)=>(___trunctfdf2=Module.___trunctfdf2=wasmExports.__trunctfdf2)(t,e),__Py_Gid_Converter=Module.__Py_Gid_Converter=(t,e)=>(__Py_Gid_Converter=Module.__Py_Gid_Converter=wasmExports._Py_Gid_Converter)(t,e),__Py_Uid_Converter=Module.__Py_Uid_Converter=(t,e)=>(__Py_Uid_Converter=Module.__Py_Uid_Converter=wasmExports._Py_Uid_Converter)(t,e),_PyOS_BeforeFork=Module._PyOS_BeforeFork=()=>(_PyOS_BeforeFork=Module._PyOS_BeforeFork=wasmExports.PyOS_BeforeFork)(),_PyOS_AfterFork_Parent=Module._PyOS_AfterFork_Parent=()=>(_PyOS_AfterFork_Parent=Module._PyOS_AfterFork_Parent=wasmExports.PyOS_AfterFork_Parent)(),_fork=Module._fork=()=>(_fork=Module._fork=wasmExports.fork)(),_PyOS_AfterFork_Child=Module._PyOS_AfterFork_Child=()=>(_PyOS_AfterFork_Child=Module._PyOS_AfterFork_Child=wasmExports.PyOS_AfterFork_Child)(),__exit=Module.__exit=t=>(__exit=Module.__exit=wasmExports._exit)(t),_dup=Module._dup=t=>(_dup=Module._dup=wasmExports.dup)(t),_dup2=Module._dup2=(t,e)=>(_dup2=Module._dup2=wasmExports.dup2)(t,e),_chdir=Module._chdir=t=>(_chdir=Module._chdir=wasmExports.chdir)(t),_umask=Module._umask=t=>(_umask=Module._umask=wasmExports.umask)(t),__Py_RestoreSignals=Module.__Py_RestoreSignals=()=>(__Py_RestoreSignals=Module.__Py_RestoreSignals=wasmExports._Py_RestoreSignals)(),_setsid=Module._setsid=()=>(_setsid=Module._setsid=wasmExports.setsid)(),_setpgid=Module._setpgid=(t,e)=>(_setpgid=Module._setpgid=wasmExports.setpgid)(t,e),_setregid=Module._setregid=(t,e)=>(_setregid=Module._setregid=wasmExports.setregid)(t,e),_setreuid=Module._setreuid=(t,e)=>(_setreuid=Module._setreuid=wasmExports.setreuid)(t,e),_execve=Module._execve=(t,e,n)=>(_execve=Module._execve=wasmExports.execve)(t,e,n),_execv=Module._execv=(t,e)=>(_execv=Module._execv=wasmExports.execv)(t,e),_opendir=Module._opendir=t=>(_opendir=Module._opendir=wasmExports.opendir)(t),_sysconf=Module._sysconf=t=>(_sysconf=Module._sysconf=wasmExports.sysconf)(t),_dirfd=Module._dirfd=t=>(_dirfd=Module._dirfd=wasmExports.dirfd)(t),_readdir=Module._readdir=t=>(_readdir=Module._readdir=wasmExports.readdir)(t),_closedir=Module._closedir=t=>(_closedir=Module._closedir=wasmExports.closedir)(t),_BZ2_bzCompressEnd=Module._BZ2_bzCompressEnd=t=>(_BZ2_bzCompressEnd=Module._BZ2_bzCompressEnd=wasmExports.BZ2_bzCompressEnd)(t),_BZ2_bzCompressInit=Module._BZ2_bzCompressInit=(t,e,n,_)=>(_BZ2_bzCompressInit=Module._BZ2_bzCompressInit=wasmExports.BZ2_bzCompressInit)(t,e,n,_),_BZ2_bzCompress=Module._BZ2_bzCompress=(t,e)=>(_BZ2_bzCompress=Module._BZ2_bzCompress=wasmExports.BZ2_bzCompress)(t,e),_BZ2_bzDecompressEnd=Module._BZ2_bzDecompressEnd=t=>(_BZ2_bzDecompressEnd=Module._BZ2_bzDecompressEnd=wasmExports.BZ2_bzDecompressEnd)(t),_BZ2_bzDecompressInit=Module._BZ2_bzDecompressInit=(t,e,n)=>(_BZ2_bzDecompressInit=Module._BZ2_bzDecompressInit=wasmExports.BZ2_bzDecompressInit)(t,e,n),_BZ2_bzDecompress=Module._BZ2_bzDecompress=t=>(_BZ2_bzDecompress=Module._BZ2_bzDecompress=wasmExports.BZ2_bzDecompress)(t),_adler32=Module._adler32=(t,e,n)=>(_adler32=Module._adler32=wasmExports.adler32)(t,e,n),_deflateInit2_=Module._deflateInit2_=(t,e,n,_,r,a,o,l)=>(_deflateInit2_=Module._deflateInit2_=wasmExports.deflateInit2_)(t,e,n,_,r,a,o,l),_deflateEnd=Module._deflateEnd=t=>(_deflateEnd=Module._deflateEnd=wasmExports.deflateEnd)(t),_deflate=Module._deflate=(t,e)=>(_deflate=Module._deflate=wasmExports.deflate)(t,e),_deflateSetDictionary=Module._deflateSetDictionary=(t,e,n)=>(_deflateSetDictionary=Module._deflateSetDictionary=wasmExports.deflateSetDictionary)(t,e,n),_crc32=Module._crc32=(t,e,n)=>(_crc32=Module._crc32=wasmExports.crc32)(t,e,n),_inflateInit2_=Module._inflateInit2_=(t,e,n,_)=>(_inflateInit2_=Module._inflateInit2_=wasmExports.inflateInit2_)(t,e,n,_),_inflateEnd=Module._inflateEnd=t=>(_inflateEnd=Module._inflateEnd=wasmExports.inflateEnd)(t),_inflate=Module._inflate=(t,e)=>(_inflate=Module._inflate=wasmExports.inflate)(t,e),_inflateSetDictionary=Module._inflateSetDictionary=(t,e,n)=>(_inflateSetDictionary=Module._inflateSetDictionary=wasmExports.inflateSetDictionary)(t,e,n),_zlibVersion=Module._zlibVersion=()=>(_zlibVersion=Module._zlibVersion=wasmExports.zlibVersion)(),_deflateCopy=Module._deflateCopy=(t,e)=>(_deflateCopy=Module._deflateCopy=wasmExports.deflateCopy)(t,e),_inflateCopy=Module._inflateCopy=(t,e)=>(_inflateCopy=Module._inflateCopy=wasmExports.inflateCopy)(t,e),_isalpha=Module._isalpha=t=>(_isalpha=Module._isalpha=wasmExports.isalpha)(t),_acos=Module._acos=t=>(_acos=Module._acos=wasmExports.acos)(t),_acosh=Module._acosh=t=>(_acosh=Module._acosh=wasmExports.acosh)(t),_asin=Module._asin=t=>(_asin=Module._asin=wasmExports.asin)(t),_asinh=Module._asinh=t=>(_asinh=Module._asinh=wasmExports.asinh)(t),_atan=Module._atan=t=>(_atan=Module._atan=wasmExports.atan)(t),_atanh=Module._atanh=t=>(_atanh=Module._atanh=wasmExports.atanh)(t),_cbrt=Module._cbrt=t=>(_cbrt=Module._cbrt=wasmExports.cbrt)(t),_copysign=Module._copysign=(t,e)=>(_copysign=Module._copysign=wasmExports.copysign)(t,e),_cosh=Module._cosh=t=>(_cosh=Module._cosh=wasmExports.cosh)(t),_erf=Module._erf=t=>(_erf=Module._erf=wasmExports.erf)(t),_erfc=Module._erfc=t=>(_erfc=Module._erfc=wasmExports.erfc)(t),_exp2=Module._exp2=t=>(_exp2=Module._exp2=wasmExports.exp2)(t),_expm1=Module._expm1=t=>(_expm1=Module._expm1=wasmExports.expm1)(t),_fabs=Module._fabs=t=>(_fabs=Module._fabs=wasmExports.fabs)(t),_sinh=Module._sinh=t=>(_sinh=Module._sinh=wasmExports.sinh)(t),_sqrt=Module._sqrt=t=>(_sqrt=Module._sqrt=wasmExports.sqrt)(t),_tan=Module._tan=t=>(_tan=Module._tan=wasmExports.tan)(t),_tanh=Module._tanh=t=>(_tanh=Module._tanh=wasmExports.tanh)(t),_nextafter=Module._nextafter=(t,e)=>(_nextafter=Module._nextafter=wasmExports.nextafter)(t,e),_log1p=Module._log1p=t=>(_log1p=Module._log1p=wasmExports.log1p)(t),_log10=Module._log10=t=>(_log10=Module._log10=wasmExports.log10)(t),_log2=Module._log2=t=>(_log2=Module._log2=wasmExports.log2)(t),_explicit_bzero=Module._explicit_bzero=(t,e)=>(_explicit_bzero=Module._explicit_bzero=wasmExports.explicit_bzero)(t,e),_strncat=Module._strncat=(t,e,n)=>(_strncat=Module._strncat=wasmExports.strncat)(t,e,n),_crypt_r=Module._crypt_r=(t,e,n)=>(_crypt_r=Module._crypt_r=wasmExports.crypt_r)(t,e,n),_mmap=Module._mmap=(t,e,n,_,r,a)=>(_mmap=Module._mmap=wasmExports.mmap)(t,e,n,_,r,a),_munmap=Module._munmap=(t,e)=>(_munmap=Module._munmap=wasmExports.munmap)(t,e),_msync=Module._msync=(t,e,n)=>(_msync=Module._msync=wasmExports.msync)(t,e,n),_madvise=Module._madvise=(t,e,n)=>(_madvise=Module._madvise=wasmExports.madvise)(t,e,n),_ftruncate=Module._ftruncate=(t,e)=>(_ftruncate=Module._ftruncate=wasmExports.ftruncate)(t,e),_mremap=Module._mremap=(t,e,n,_,r)=>(_mremap=Module._mremap=wasmExports.mremap)(t,e,n,_,r),_poll=Module._poll=(t,e,n)=>(_poll=Module._poll=wasmExports.poll)(t,e,n),_select=Module._select=(t,e,n,_,r)=>(_select=Module._select=wasmExports.select)(t,e,n,_,r),_getsockname=Module._getsockname=(t,e,n)=>(_getsockname=Module._getsockname=wasmExports.getsockname)(t,e,n),_socket=Module._socket=(t,e,n)=>(_socket=Module._socket=wasmExports.socket)(t,e,n),_getsockopt=Module._getsockopt=(t,e,n,_,r)=>(_getsockopt=Module._getsockopt=wasmExports.getsockopt)(t,e,n,_,r),_bind=Module._bind=(t,e,n)=>(_bind=Module._bind=wasmExports.bind)(t,e,n),_getpeername=Module._getpeername=(t,e,n)=>(_getpeername=Module._getpeername=wasmExports.getpeername)(t,e,n),_listen=Module._listen=(t,e)=>(_listen=Module._listen=wasmExports.listen)(t,e),_setsockopt=Module._setsockopt=(t,e,n,_,r)=>(_setsockopt=Module._setsockopt=wasmExports.setsockopt)(t,e,n,_,r),_accept4=Module._accept4=(t,e,n,_)=>(_accept4=Module._accept4=wasmExports.accept4)(t,e,n,_),_accept=Module._accept=(t,e,n)=>(_accept=Module._accept=wasmExports.accept)(t,e,n),_inet_ntop=Module._inet_ntop=(t,e,n,_)=>(_inet_ntop=Module._inet_ntop=wasmExports.inet_ntop)(t,e,n,_),_ntohs=t=>(_ntohs=wasmExports.ntohs)(t),_htons=t=>(_htons=wasmExports.htons)(t),_gai_strerror=Module._gai_strerror=t=>(_gai_strerror=Module._gai_strerror=wasmExports.gai_strerror)(t),_freeaddrinfo=Module._freeaddrinfo=t=>(_freeaddrinfo=Module._freeaddrinfo=wasmExports.freeaddrinfo)(t),_inet_pton=Module._inet_pton=(t,e,n)=>(_inet_pton=Module._inet_pton=wasmExports.inet_pton)(t,e,n),_connect=Module._connect=(t,e,n)=>(_connect=Module._connect=wasmExports.connect)(t,e,n),_recv=Module._recv=(t,e,n,_)=>(_recv=Module._recv=wasmExports.recv)(t,e,n,_),_recvfrom=Module._recvfrom=(t,e,n,_,r,a)=>(_recvfrom=Module._recvfrom=wasmExports.recvfrom)(t,e,n,_,r,a),_send=Module._send=(t,e,n,_)=>(_send=Module._send=wasmExports.send)(t,e,n,_),_sendto=Module._sendto=(t,e,n,_,r,a)=>(_sendto=Module._sendto=wasmExports.sendto)(t,e,n,_,r,a),_recvmsg=Module._recvmsg=(t,e,n)=>(_recvmsg=Module._recvmsg=wasmExports.recvmsg)(t,e,n),_sendmsg=Module._sendmsg=(t,e,n)=>(_sendmsg=Module._sendmsg=wasmExports.sendmsg)(t,e,n),_gethostname=Module._gethostname=(t,e)=>(_gethostname=Module._gethostname=wasmExports.gethostname)(t,e),_getservbyname=Module._getservbyname=(t,e)=>(_getservbyname=Module._getservbyname=wasmExports.getservbyname)(t,e),_getservbyport=Module._getservbyport=(t,e)=>(_getservbyport=Module._getservbyport=wasmExports.getservbyport)(t,e),_ntohl=Module._ntohl=t=>(_ntohl=Module._ntohl=wasmExports.ntohl)(t),_htonl=t=>(_htonl=wasmExports.htonl)(t),_inet_aton=Module._inet_aton=(t,e)=>(_inet_aton=Module._inet_aton=wasmExports.inet_aton)(t,e),_inet_ntoa=Module._inet_ntoa=t=>(_inet_ntoa=Module._inet_ntoa=wasmExports.inet_ntoa)(t),_if_nameindex=Module._if_nameindex=()=>(_if_nameindex=Module._if_nameindex=wasmExports.if_nameindex)(),_if_freenameindex=Module._if_freenameindex=t=>(_if_freenameindex=Module._if_freenameindex=wasmExports.if_freenameindex)(t),_if_nametoindex=Module._if_nametoindex=t=>(_if_nametoindex=Module._if_nametoindex=wasmExports.if_nametoindex)(t),_if_indextoname=Module._if_indextoname=(t,e)=>(_if_indextoname=Module._if_indextoname=wasmExports.if_indextoname)(t,e),___h_errno_location=Module.___h_errno_location=()=>(___h_errno_location=Module.___h_errno_location=wasmExports.__h_errno_location)(),_hstrerror=Module._hstrerror=t=>(_hstrerror=Module._hstrerror=wasmExports.hstrerror)(t),_getrlimit=Module._getrlimit=(t,e)=>(_getrlimit=Module._getrlimit=wasmExports.getrlimit)(t,e),_setrlimit=Module._setrlimit=(t,e)=>(_setrlimit=Module._setrlimit=wasmExports.setrlimit)(t,e),_raise=Module._raise=t=>(_raise=Module._raise=wasmExports.raise)(t),_sigfillset=Module._sigfillset=t=>(_sigfillset=Module._sigfillset=wasmExports.sigfillset)(t),_pthread_sigmask=Module._pthread_sigmask=(t,e,n)=>(_pthread_sigmask=Module._pthread_sigmask=wasmExports.pthread_sigmask)(t,e,n),_PyOS_AfterFork=Module._PyOS_AfterFork=()=>(_PyOS_AfterFork=Module._PyOS_AfterFork=wasmExports.PyOS_AfterFork)(),__PyLong_FromUid=Module.__PyLong_FromUid=t=>(__PyLong_FromUid=Module.__PyLong_FromUid=wasmExports._PyLong_FromUid)(t),__PyLong_FromGid=Module.__PyLong_FromGid=t=>(__PyLong_FromGid=Module.__PyLong_FromGid=wasmExports._PyLong_FromGid)(t),__Py_Sigset_Converter=Module.__Py_Sigset_Converter=(t,e)=>(__Py_Sigset_Converter=Module.__Py_Sigset_Converter=wasmExports._Py_Sigset_Converter)(t,e),_sigemptyset=Module._sigemptyset=t=>(_sigemptyset=Module._sigemptyset=wasmExports.sigemptyset)(t),_sigaddset=Module._sigaddset=(t,e)=>(_sigaddset=Module._sigaddset=wasmExports.sigaddset)(t,e),_access=Module._access=(t,e)=>(_access=Module._access=wasmExports.access)(t,e),_ttyname_r=Module._ttyname_r=(t,e,n)=>(_ttyname_r=Module._ttyname_r=wasmExports.ttyname_r)(t,e,n),_fchdir=Module._fchdir=t=>(_fchdir=Module._fchdir=wasmExports.fchdir)(t),_fchmod=Module._fchmod=(t,e)=>(_fchmod=Module._fchmod=wasmExports.fchmod)(t,e),_fchmodat=Module._fchmodat=(t,e,n,_)=>(_fchmodat=Module._fchmodat=wasmExports.fchmodat)(t,e,n,_),_chmod=Module._chmod=(t,e)=>(_chmod=Module._chmod=wasmExports.chmod)(t,e),_fchown=Module._fchown=(t,e,n)=>(_fchown=Module._fchown=wasmExports.fchown)(t,e,n),_fchownat=Module._fchownat=(t,e,n,_,r)=>(_fchownat=Module._fchownat=wasmExports.fchownat)(t,e,n,_,r),_chown=Module._chown=(t,e,n)=>(_chown=Module._chown=wasmExports.chown)(t,e,n),_chroot=Module._chroot=t=>(_chroot=Module._chroot=wasmExports.chroot)(t),_ctermid=Module._ctermid=t=>(_ctermid=Module._ctermid=wasmExports.ctermid)(t),_fdopendir=Module._fdopendir=t=>(_fdopendir=Module._fdopendir=wasmExports.fdopendir)(t),_rewinddir=Module._rewinddir=t=>(_rewinddir=Module._rewinddir=wasmExports.rewinddir)(t),_mkdirat=Module._mkdirat=(t,e,n)=>(_mkdirat=Module._mkdirat=wasmExports.mkdirat)(t,e,n),_mkdir=Module._mkdir=(t,e)=>(_mkdir=Module._mkdir=wasmExports.mkdir)(t,e),_getpriority=Module._getpriority=(t,e)=>(_getpriority=Module._getpriority=wasmExports.getpriority)(t,e),_readlinkat=Module._readlinkat=(t,e,n,_)=>(_readlinkat=Module._readlinkat=wasmExports.readlinkat)(t,e,n,_),_unlinkat=Module._unlinkat=(t,e,n)=>(_unlinkat=Module._unlinkat=wasmExports.unlinkat)(t,e,n),_rmdir=Module._rmdir=t=>(_rmdir=Module._rmdir=wasmExports.rmdir)(t),_symlink=Module._symlink=(t,e)=>(_symlink=Module._symlink=wasmExports.symlink)(t,e),_uname=Module._uname=t=>(_uname=Module._uname=wasmExports.uname)(t),_futimesat=Module._futimesat=(t,e,n)=>(_futimesat=Module._futimesat=wasmExports.futimesat)(t,e,n),_futimens=Module._futimens=(t,e)=>(_futimens=Module._futimens=wasmExports.futimens)(t,e),_times=Module._times=t=>(_times=Module._times=wasmExports.times)(t),_fexecve=Module._fexecve=(t,e,n)=>(_fexecve=Module._fexecve=wasmExports.fexecve)(t,e,n),_sched_yield=Module._sched_yield=()=>(_sched_yield=Module._sched_yield=wasmExports.sched_yield)(),_login_tty=Module._login_tty=t=>(_login_tty=Module._login_tty=wasmExports.login_tty)(t),_getgid=Module._getgid=()=>(_getgid=Module._getgid=wasmExports.getgid)(),_getpgrp=Module._getpgrp=()=>(_getpgrp=Module._getpgrp=wasmExports.getpgrp)(),_getppid=Module._getppid=()=>(_getppid=Module._getppid=wasmExports.getppid)(),_getuid=Module._getuid=()=>(_getuid=Module._getuid=wasmExports.getuid)(),_getlogin=Module._getlogin=()=>(_getlogin=Module._getlogin=wasmExports.getlogin)(),_killpg=Module._killpg=(t,e)=>(_killpg=Module._killpg=wasmExports.killpg)(t,e),_setuid=Module._setuid=t=>(_setuid=Module._setuid=wasmExports.setuid)(t),_setgid=Module._setgid=t=>(_setgid=Module._setgid=wasmExports.setgid)(t),_getpgid=Module._getpgid=t=>(_getpgid=Module._getpgid=wasmExports.getpgid)(t),_setpgrp=Module._setpgrp=()=>(_setpgrp=Module._setpgrp=wasmExports.setpgrp)(),_wait=Module._wait=t=>(_wait=Module._wait=wasmExports.wait)(t),_waitid=Module._waitid=(t,e,n,_)=>(_waitid=Module._waitid=wasmExports.waitid)(t,e,n,_),_waitpid=Module._waitpid=(t,e,n)=>(_waitpid=Module._waitpid=wasmExports.waitpid)(t,e,n),_getsid=Module._getsid=t=>(_getsid=Module._getsid=wasmExports.getsid)(t),_tcgetpgrp=Module._tcgetpgrp=t=>(_tcgetpgrp=Module._tcgetpgrp=wasmExports.tcgetpgrp)(t),_tcsetpgrp=Module._tcsetpgrp=(t,e)=>(_tcsetpgrp=Module._tcsetpgrp=wasmExports.tcsetpgrp)(t,e),_openat=Module._openat=(t,e,n,_)=>(_openat=Module._openat=wasmExports.openat)(t,e,n,_),_dup3=Module._dup3=(t,e,n)=>(_dup3=Module._dup3=wasmExports.dup3)(t,e,n),_lockf=Module._lockf=(t,e,n)=>(_lockf=Module._lockf=wasmExports.lockf)(t,e,n),_readv=Module._readv=(t,e,n)=>(_readv=Module._readv=wasmExports.readv)(t,e,n),_pread=Module._pread=(t,e,n,_)=>(_pread=Module._pread=wasmExports.pread)(t,e,n,_),_writev=Module._writev=(t,e,n)=>(_writev=Module._writev=wasmExports.writev)(t,e,n),_pwrite=Module._pwrite=(t,e,n,_)=>(_pwrite=Module._pwrite=wasmExports.pwrite)(t,e,n,_),_pipe=Module._pipe=t=>(_pipe=Module._pipe=wasmExports.pipe)(t),_truncate=Module._truncate=(t,e)=>(_truncate=Module._truncate=wasmExports.truncate)(t,e),_posix_fadvise=Module._posix_fadvise=(t,e,n,_)=>(_posix_fadvise=Module._posix_fadvise=wasmExports.posix_fadvise)(t,e,n,_),_unsetenv=Module._unsetenv=t=>(_unsetenv=Module._unsetenv=wasmExports.unsetenv)(t),_fsync=Module._fsync=t=>(_fsync=Module._fsync=wasmExports.fsync)(t),_sync=Module._sync=()=>(_sync=Module._sync=wasmExports.sync)(),_fdatasync=Module._fdatasync=t=>(_fdatasync=Module._fdatasync=wasmExports.fdatasync)(t),_fstatvfs=Module._fstatvfs=(t,e)=>(_fstatvfs=Module._fstatvfs=wasmExports.fstatvfs)(t,e),_statvfs=Module._statvfs=(t,e)=>(_statvfs=Module._statvfs=wasmExports.statvfs)(t,e),_fpathconf=Module._fpathconf=(t,e)=>(_fpathconf=Module._fpathconf=wasmExports.fpathconf)(t,e),_pathconf=Module._pathconf=(t,e)=>(_pathconf=Module._pathconf=wasmExports.pathconf)(t,e),_getloadavg=Module._getloadavg=(t,e)=>(_getloadavg=Module._getloadavg=wasmExports.getloadavg)(t,e),_lstat=Module._lstat=(t,e)=>(_lstat=Module._lstat=wasmExports.lstat)(t,e),_fstatat=Module._fstatat=(t,e,n,_)=>(_fstatat=Module._fstatat=wasmExports.fstatat)(t,e,n,_),_renameat=Module._renameat=(t,e,n,_)=>(_renameat=Module._renameat=wasmExports.renameat)(t,e,n,_),_rename=Module._rename=(t,e)=>(_rename=Module._rename=wasmExports.rename)(t,e),_unlink=Module._unlink=t=>(_unlink=Module._unlink=wasmExports.unlink)(t),_utimes=Module._utimes=(t,e)=>(_utimes=Module._utimes=wasmExports.utimes)(t,e),_qsort=Module._qsort=(t,e,n,_)=>(_qsort=Module._qsort=wasmExports.qsort)(t,e,n,_),__PyErr_CheckSignals=Module.__PyErr_CheckSignals=()=>(__PyErr_CheckSignals=Module.__PyErr_CheckSignals=wasmExports._PyErr_CheckSignals)(),_PyErr_SetInterrupt=Module._PyErr_SetInterrupt=()=>(_PyErr_SetInterrupt=Module._PyErr_SetInterrupt=wasmExports.PyErr_SetInterrupt)(),_PyOS_InterruptOccurred=Module._PyOS_InterruptOccurred=()=>(_PyOS_InterruptOccurred=Module._PyOS_InterruptOccurred=wasmExports.PyOS_InterruptOccurred)(),__PyOS_IsMainThread=Module.__PyOS_IsMainThread=()=>(__PyOS_IsMainThread=Module.__PyOS_IsMainThread=wasmExports._PyOS_IsMainThread)(),_getitimer=Module._getitimer=(t,e)=>(_getitimer=Module._getitimer=wasmExports.getitimer)(t,e),_strsignal=Module._strsignal=t=>(_strsignal=Module._strsignal=wasmExports.strsignal)(t),_strstr=Module._strstr=(t,e)=>(_strstr=Module._strstr=wasmExports.strstr)(t,e),_pause=Module._pause=()=>(_pause=Module._pause=wasmExports.pause)(),_sigpending=Module._sigpending=t=>(_sigpending=Module._sigpending=wasmExports.sigpending)(t),_sigwait=Module._sigwait=(t,e)=>(_sigwait=Module._sigwait=wasmExports.sigwait)(t,e),_sigwaitinfo=Module._sigwaitinfo=(t,e)=>(_sigwaitinfo=Module._sigwaitinfo=wasmExports.sigwaitinfo)(t,e),_sigtimedwait=Module._sigtimedwait=(t,e,n)=>(_sigtimedwait=Module._sigtimedwait=wasmExports.sigtimedwait)(t,e,n),_sigismember=Module._sigismember=(t,e)=>(_sigismember=Module._sigismember=wasmExports.sigismember)(t,e),___libc_current_sigrtmin=Module.___libc_current_sigrtmin=()=>(___libc_current_sigrtmin=Module.___libc_current_sigrtmin=wasmExports.__libc_current_sigrtmin)(),___libc_current_sigrtmax=Module.___libc_current_sigrtmax=()=>(___libc_current_sigrtmax=Module.___libc_current_sigrtmax=wasmExports.__libc_current_sigrtmax)(),_PyTraceMalloc_Track=Module._PyTraceMalloc_Track=(t,e,n)=>(_PyTraceMalloc_Track=Module._PyTraceMalloc_Track=wasmExports.PyTraceMalloc_Track)(t,e,n),_PyTraceMalloc_Untrack=Module._PyTraceMalloc_Untrack=(t,e)=>(_PyTraceMalloc_Untrack=Module._PyTraceMalloc_Untrack=wasmExports.PyTraceMalloc_Untrack)(t,e),__PyTraceMalloc_GetTraceback=Module.__PyTraceMalloc_GetTraceback=(t,e)=>(__PyTraceMalloc_GetTraceback=Module.__PyTraceMalloc_GetTraceback=wasmExports._PyTraceMalloc_GetTraceback)(t,e),_isalnum=Module._isalnum=t=>(_isalnum=Module._isalnum=wasmExports.isalnum)(t),_toupper=Module._toupper=t=>(_toupper=Module._toupper=wasmExports.toupper)(t),_clock_settime=Module._clock_settime=(t,e)=>(_clock_settime=Module._clock_settime=wasmExports.clock_settime)(t,e),_pthread_getcpuclockid=Module._pthread_getcpuclockid=(t,e)=>(_pthread_getcpuclockid=Module._pthread_getcpuclockid=wasmExports.pthread_getcpuclockid)(t,e),_clock_nanosleep=Module._clock_nanosleep=(t,e,n,_)=>(_clock_nanosleep=Module._clock_nanosleep=wasmExports.clock_nanosleep)(t,e,n,_),_time=Module._time=t=>(_time=Module._time=wasmExports.time)(t),_mktime=Module._mktime=t=>(_mktime=Module._mktime=wasmExports.mktime)(t),_clock=Module._clock=()=>(_clock=Module._clock=wasmExports.clock)(),_wcscoll=Module._wcscoll=(t,e)=>(_wcscoll=Module._wcscoll=wasmExports.wcscoll)(t,e),_wcsxfrm=Module._wcsxfrm=(t,e,n)=>(_wcsxfrm=Module._wcsxfrm=wasmExports.wcsxfrm)(t,e,n),_gettext=Module._gettext=t=>(_gettext=Module._gettext=wasmExports.gettext)(t),_dgettext=Module._dgettext=(t,e)=>(_dgettext=Module._dgettext=wasmExports.dgettext)(t,e),_dcgettext=Module._dcgettext=(t,e,n)=>(_dcgettext=Module._dcgettext=wasmExports.dcgettext)(t,e,n),_textdomain=Module._textdomain=t=>(_textdomain=Module._textdomain=wasmExports.textdomain)(t),_bindtextdomain=Module._bindtextdomain=(t,e)=>(_bindtextdomain=Module._bindtextdomain=wasmExports.bindtextdomain)(t,e),_bind_textdomain_codeset=Module._bind_textdomain_codeset=(t,e)=>(_bind_textdomain_codeset=Module._bind_textdomain_codeset=wasmExports.bind_textdomain_codeset)(t,e),_isupper=Module._isupper=t=>(_isupper=Module._isupper=wasmExports.isupper)(t),___small_fprintf=Module.___small_fprintf=(t,e,n)=>(___small_fprintf=Module.___small_fprintf=wasmExports.__small_fprintf)(t,e,n),__Py_Get_Getpath_CodeObject=Module.__Py_Get_Getpath_CodeObject=()=>(__Py_Get_Getpath_CodeObject=Module.__Py_Get_Getpath_CodeObject=wasmExports._Py_Get_Getpath_CodeObject)(),_ffi_prep_closure=Module._ffi_prep_closure=(t,e,n,_)=>(_ffi_prep_closure=Module._ffi_prep_closure=wasmExports.ffi_prep_closure)(t,e,n,_),_ffi_get_struct_offsets=Module._ffi_get_struct_offsets=(t,e,n)=>(_ffi_get_struct_offsets=Module._ffi_get_struct_offsets=wasmExports.ffi_get_struct_offsets)(t,e,n),_ffi_java_raw_size=Module._ffi_java_raw_size=t=>(_ffi_java_raw_size=Module._ffi_java_raw_size=wasmExports.ffi_java_raw_size)(t),_ffi_java_raw_to_ptrarray=Module._ffi_java_raw_to_ptrarray=(t,e,n)=>(_ffi_java_raw_to_ptrarray=Module._ffi_java_raw_to_ptrarray=wasmExports.ffi_java_raw_to_ptrarray)(t,e,n),_ffi_java_ptrarray_to_raw=Module._ffi_java_ptrarray_to_raw=(t,e,n)=>(_ffi_java_ptrarray_to_raw=Module._ffi_java_ptrarray_to_raw=wasmExports.ffi_java_ptrarray_to_raw)(t,e,n),_ffi_java_raw_call=Module._ffi_java_raw_call=(t,e,n,_)=>(_ffi_java_raw_call=Module._ffi_java_raw_call=wasmExports.ffi_java_raw_call)(t,e,n,_),_ffi_prep_java_raw_closure_loc=Module._ffi_prep_java_raw_closure_loc=(t,e,n,_,r)=>(_ffi_prep_java_raw_closure_loc=Module._ffi_prep_java_raw_closure_loc=wasmExports.ffi_prep_java_raw_closure_loc)(t,e,n,_,r),_ffi_prep_java_raw_closure=Module._ffi_prep_java_raw_closure=(t,e,n,_)=>(_ffi_prep_java_raw_closure=Module._ffi_prep_java_raw_closure=wasmExports.ffi_prep_java_raw_closure)(t,e,n,_),_ffi_tramp_is_supported=Module._ffi_tramp_is_supported=()=>(_ffi_tramp_is_supported=Module._ffi_tramp_is_supported=wasmExports.ffi_tramp_is_supported)(),_ffi_tramp_alloc=Module._ffi_tramp_alloc=t=>(_ffi_tramp_alloc=Module._ffi_tramp_alloc=wasmExports.ffi_tramp_alloc)(t),_ffi_tramp_set_parms=Module._ffi_tramp_set_parms=(t,e,n)=>(_ffi_tramp_set_parms=Module._ffi_tramp_set_parms=wasmExports.ffi_tramp_set_parms)(t,e,n),_ffi_tramp_get_addr=Module._ffi_tramp_get_addr=t=>(_ffi_tramp_get_addr=Module._ffi_tramp_get_addr=wasmExports.ffi_tramp_get_addr)(t),_ffi_tramp_free=Module._ffi_tramp_free=t=>(_ffi_tramp_free=Module._ffi_tramp_free=wasmExports.ffi_tramp_free)(t),__hiwire_immortal_get=Module.__hiwire_immortal_get=t=>(__hiwire_immortal_get=Module.__hiwire_immortal_get=wasmExports._hiwire_immortal_get)(t),__hiwire_get=Module.__hiwire_get=t=>(__hiwire_get=Module.__hiwire_get=wasmExports._hiwire_get)(t),_hiwire_incref=Module._hiwire_incref=t=>(_hiwire_incref=Module._hiwire_incref=wasmExports.hiwire_incref)(t),__hiwire_immortal_add=Module.__hiwire_immortal_add=t=>(__hiwire_immortal_add=Module.__hiwire_immortal_add=wasmExports._hiwire_immortal_add)(t),__hiwire_table_init=Module.__hiwire_table_init=()=>(__hiwire_table_init=Module.__hiwire_table_init=wasmExports._hiwire_table_init)(),__hiwire_set=Module.__hiwire_set=(t,e)=>(__hiwire_set=Module.__hiwire_set=wasmExports._hiwire_set)(t,e),_hiwire_num_refs=Module._hiwire_num_refs=()=>(_hiwire_num_refs=Module._hiwire_num_refs=wasmExports.hiwire_num_refs)(),__hiwire_slot_info=Module.__hiwire_slot_info=t=>(__hiwire_slot_info=Module.__hiwire_slot_info=wasmExports._hiwire_slot_info)(t),__hiwire_delete=Module.__hiwire_delete=t=>(__hiwire_delete=Module.__hiwire_delete=wasmExports._hiwire_delete)(t),__hiwire_immortal_table_init=Module.__hiwire_immortal_table_init=()=>(__hiwire_immortal_table_init=Module.__hiwire_immortal_table_init=wasmExports._hiwire_immortal_table_init)(),_adler32_z=Module._adler32_z=(t,e,n)=>(_adler32_z=Module._adler32_z=wasmExports.adler32_z)(t,e,n),_adler32_combine=Module._adler32_combine=(t,e,n)=>(_adler32_combine=Module._adler32_combine=wasmExports.adler32_combine)(t,e,n),_adler32_combine64=Module._adler32_combine64=(t,e,n)=>(_adler32_combine64=Module._adler32_combine64=wasmExports.adler32_combine64)(t,e,n),_compress2=Module._compress2=(t,e,n,_,r)=>(_compress2=Module._compress2=wasmExports.compress2)(t,e,n,_,r),_deflateInit_=Module._deflateInit_=(t,e,n,_)=>(_deflateInit_=Module._deflateInit_=wasmExports.deflateInit_)(t,e,n,_),_compress=Module._compress=(t,e,n,_)=>(_compress=Module._compress=wasmExports.compress)(t,e,n,_),_compressBound=Module._compressBound=t=>(_compressBound=Module._compressBound=wasmExports.compressBound)(t),_get_crc_table=Module._get_crc_table=()=>(_get_crc_table=Module._get_crc_table=wasmExports.get_crc_table)(),_crc32_z=Module._crc32_z=(t,e,n)=>(_crc32_z=Module._crc32_z=wasmExports.crc32_z)(t,e,n),_crc32_combine64=Module._crc32_combine64=(t,e,n)=>(_crc32_combine64=Module._crc32_combine64=wasmExports.crc32_combine64)(t,e,n),_crc32_combine=Module._crc32_combine=(t,e,n)=>(_crc32_combine=Module._crc32_combine=wasmExports.crc32_combine)(t,e,n),_crc32_combine_gen64=Module._crc32_combine_gen64=t=>(_crc32_combine_gen64=Module._crc32_combine_gen64=wasmExports.crc32_combine_gen64)(t),_crc32_combine_gen=Module._crc32_combine_gen=t=>(_crc32_combine_gen=Module._crc32_combine_gen=wasmExports.crc32_combine_gen)(t),_crc32_combine_op=Module._crc32_combine_op=(t,e,n)=>(_crc32_combine_op=Module._crc32_combine_op=wasmExports.crc32_combine_op)(t,e,n),_zcalloc=Module._zcalloc=(t,e,n)=>(_zcalloc=Module._zcalloc=wasmExports.zcalloc)(t,e,n),_zcfree=Module._zcfree=(t,e)=>(_zcfree=Module._zcfree=wasmExports.zcfree)(t,e),_deflateReset=Module._deflateReset=t=>(_deflateReset=Module._deflateReset=wasmExports.deflateReset)(t),_deflateResetKeep=Module._deflateResetKeep=t=>(_deflateResetKeep=Module._deflateResetKeep=wasmExports.deflateResetKeep)(t),_deflateGetDictionary=Module._deflateGetDictionary=(t,e,n)=>(_deflateGetDictionary=Module._deflateGetDictionary=wasmExports.deflateGetDictionary)(t,e,n),__tr_init=Module.__tr_init=t=>(__tr_init=Module.__tr_init=wasmExports._tr_init)(t),_deflateSetHeader=Module._deflateSetHeader=(t,e)=>(_deflateSetHeader=Module._deflateSetHeader=wasmExports.deflateSetHeader)(t,e),_deflatePending=Module._deflatePending=(t,e,n)=>(_deflatePending=Module._deflatePending=wasmExports.deflatePending)(t,e,n),_deflatePrime=Module._deflatePrime=(t,e,n)=>(_deflatePrime=Module._deflatePrime=wasmExports.deflatePrime)(t,e,n),__tr_flush_bits=Module.__tr_flush_bits=t=>(__tr_flush_bits=Module.__tr_flush_bits=wasmExports._tr_flush_bits)(t),_deflateParams=Module._deflateParams=(t,e,n)=>(_deflateParams=Module._deflateParams=wasmExports.deflateParams)(t,e,n),__tr_align=Module.__tr_align=t=>(__tr_align=Module.__tr_align=wasmExports._tr_align)(t),__tr_stored_block=Module.__tr_stored_block=(t,e,n,_)=>(__tr_stored_block=Module.__tr_stored_block=wasmExports._tr_stored_block)(t,e,n,_),_deflateTune=Module._deflateTune=(t,e,n,_,r)=>(_deflateTune=Module._deflateTune=wasmExports.deflateTune)(t,e,n,_,r),_deflateBound=Module._deflateBound=(t,e)=>(_deflateBound=Module._deflateBound=wasmExports.deflateBound)(t,e),__tr_flush_block=Module.__tr_flush_block=(t,e,n,_)=>(__tr_flush_block=Module.__tr_flush_block=wasmExports._tr_flush_block)(t,e,n,_),_gzclose=Module._gzclose=t=>(_gzclose=Module._gzclose=wasmExports.gzclose)(t),_gzclose_r=Module._gzclose_r=t=>(_gzclose_r=Module._gzclose_r=wasmExports.gzclose_r)(t),_gzclose_w=Module._gzclose_w=t=>(_gzclose_w=Module._gzclose_w=wasmExports.gzclose_w)(t),_gzopen=Module._gzopen=(t,e)=>(_gzopen=Module._gzopen=wasmExports.gzopen)(t,e),_gzopen64=Module._gzopen64=(t,e)=>(_gzopen64=Module._gzopen64=wasmExports.gzopen64)(t,e),_gzdopen=Module._gzdopen=(t,e)=>(_gzdopen=Module._gzdopen=wasmExports.gzdopen)(t,e),_gzbuffer=Module._gzbuffer=(t,e)=>(_gzbuffer=Module._gzbuffer=wasmExports.gzbuffer)(t,e),_gzrewind=Module._gzrewind=t=>(_gzrewind=Module._gzrewind=wasmExports.gzrewind)(t),_gzseek64=Module._gzseek64=(t,e,n)=>(_gzseek64=Module._gzseek64=wasmExports.gzseek64)(t,e,n),_gz_error=Module._gz_error=(t,e,n)=>(_gz_error=Module._gz_error=wasmExports.gz_error)(t,e,n),_gzseek=Module._gzseek=(t,e,n)=>(_gzseek=Module._gzseek=wasmExports.gzseek)(t,e,n),_gztell64=Module._gztell64=t=>(_gztell64=Module._gztell64=wasmExports.gztell64)(t),_gztell=Module._gztell=t=>(_gztell=Module._gztell=wasmExports.gztell)(t),_gzoffset64=Module._gzoffset64=t=>(_gzoffset64=Module._gzoffset64=wasmExports.gzoffset64)(t),_gzoffset=Module._gzoffset=t=>(_gzoffset=Module._gzoffset=wasmExports.gzoffset)(t),_gzeof=Module._gzeof=t=>(_gzeof=Module._gzeof=wasmExports.gzeof)(t),_gzerror=Module._gzerror=(t,e)=>(_gzerror=Module._gzerror=wasmExports.gzerror)(t,e),_gzclearerr=Module._gzclearerr=t=>(_gzclearerr=Module._gzclearerr=wasmExports.gzclearerr)(t),_gzread=Module._gzread=(t,e,n)=>(_gzread=Module._gzread=wasmExports.gzread)(t,e,n),_gzfread=Module._gzfread=(t,e,n,_)=>(_gzfread=Module._gzfread=wasmExports.gzfread)(t,e,n,_),_gzgetc=Module._gzgetc=t=>(_gzgetc=Module._gzgetc=wasmExports.gzgetc)(t),_gzgetc_=Module._gzgetc_=t=>(_gzgetc_=Module._gzgetc_=wasmExports.gzgetc_)(t),_gzungetc=Module._gzungetc=(t,e)=>(_gzungetc=Module._gzungetc=wasmExports.gzungetc)(t,e),_gzgets=Module._gzgets=(t,e,n)=>(_gzgets=Module._gzgets=wasmExports.gzgets)(t,e,n),_gzdirect=Module._gzdirect=t=>(_gzdirect=Module._gzdirect=wasmExports.gzdirect)(t),_inflateReset=Module._inflateReset=t=>(_inflateReset=Module._inflateReset=wasmExports.inflateReset)(t),_gzwrite=Module._gzwrite=(t,e,n)=>(_gzwrite=Module._gzwrite=wasmExports.gzwrite)(t,e,n),_gzfwrite=Module._gzfwrite=(t,e,n,_)=>(_gzfwrite=Module._gzfwrite=wasmExports.gzfwrite)(t,e,n,_),_gzputc=Module._gzputc=(t,e)=>(_gzputc=Module._gzputc=wasmExports.gzputc)(t,e),_gzputs=Module._gzputs=(t,e)=>(_gzputs=Module._gzputs=wasmExports.gzputs)(t,e),_gzvprintf=Module._gzvprintf=(t,e,n)=>(_gzvprintf=Module._gzvprintf=wasmExports.gzvprintf)(t,e,n),_gzprintf=Module._gzprintf=(t,e,n)=>(_gzprintf=Module._gzprintf=wasmExports.gzprintf)(t,e,n),_gzflush=Module._gzflush=(t,e)=>(_gzflush=Module._gzflush=wasmExports.gzflush)(t,e),_gzsetparams=Module._gzsetparams=(t,e,n)=>(_gzsetparams=Module._gzsetparams=wasmExports.gzsetparams)(t,e,n),_inflateBackInit_=Module._inflateBackInit_=(t,e,n,_,r)=>(_inflateBackInit_=Module._inflateBackInit_=wasmExports.inflateBackInit_)(t,e,n,_,r),_inflateBack=Module._inflateBack=(t,e,n,_,r)=>(_inflateBack=Module._inflateBack=wasmExports.inflateBack)(t,e,n,_,r),_inflate_table=Module._inflate_table=(t,e,n,_,r,a)=>(_inflate_table=Module._inflate_table=wasmExports.inflate_table)(t,e,n,_,r,a),_inflate_fast=Module._inflate_fast=(t,e)=>(_inflate_fast=Module._inflate_fast=wasmExports.inflate_fast)(t,e),_inflateBackEnd=Module._inflateBackEnd=t=>(_inflateBackEnd=Module._inflateBackEnd=wasmExports.inflateBackEnd)(t),_inflateResetKeep=Module._inflateResetKeep=t=>(_inflateResetKeep=Module._inflateResetKeep=wasmExports.inflateResetKeep)(t),_inflateReset2=Module._inflateReset2=(t,e)=>(_inflateReset2=Module._inflateReset2=wasmExports.inflateReset2)(t,e),_inflateInit_=Module._inflateInit_=(t,e,n)=>(_inflateInit_=Module._inflateInit_=wasmExports.inflateInit_)(t,e,n),_inflatePrime=Module._inflatePrime=(t,e,n)=>(_inflatePrime=Module._inflatePrime=wasmExports.inflatePrime)(t,e,n),_inflateGetDictionary=Module._inflateGetDictionary=(t,e,n)=>(_inflateGetDictionary=Module._inflateGetDictionary=wasmExports.inflateGetDictionary)(t,e,n),_inflateGetHeader=Module._inflateGetHeader=(t,e)=>(_inflateGetHeader=Module._inflateGetHeader=wasmExports.inflateGetHeader)(t,e),_inflateSync=Module._inflateSync=t=>(_inflateSync=Module._inflateSync=wasmExports.inflateSync)(t),_inflateSyncPoint=Module._inflateSyncPoint=t=>(_inflateSyncPoint=Module._inflateSyncPoint=wasmExports.inflateSyncPoint)(t),_inflateUndermine=Module._inflateUndermine=(t,e)=>(_inflateUndermine=Module._inflateUndermine=wasmExports.inflateUndermine)(t,e),_inflateValidate=Module._inflateValidate=(t,e)=>(_inflateValidate=Module._inflateValidate=wasmExports.inflateValidate)(t,e),_inflateMark=Module._inflateMark=t=>(_inflateMark=Module._inflateMark=wasmExports.inflateMark)(t),_inflateCodesUsed=Module._inflateCodesUsed=t=>(_inflateCodesUsed=Module._inflateCodesUsed=wasmExports.inflateCodesUsed)(t),__tr_tally=Module.__tr_tally=(t,e,n)=>(__tr_tally=Module.__tr_tally=wasmExports._tr_tally)(t,e,n),_uncompress2=Module._uncompress2=(t,e,n,_)=>(_uncompress2=Module._uncompress2=wasmExports.uncompress2)(t,e,n,_),_uncompress=Module._uncompress=(t,e,n,_)=>(_uncompress=Module._uncompress=wasmExports.uncompress)(t,e,n,_),_zlibCompileFlags=Module._zlibCompileFlags=()=>(_zlibCompileFlags=Module._zlibCompileFlags=wasmExports.zlibCompileFlags)(),_zError=Module._zError=t=>(_zError=Module._zError=wasmExports.zError)(t),_BZ2_blockSort=Module._BZ2_blockSort=t=>(_BZ2_blockSort=Module._BZ2_blockSort=wasmExports.BZ2_blockSort)(t),_BZ2_bz__AssertH__fail=Module._BZ2_bz__AssertH__fail=t=>(_BZ2_bz__AssertH__fail=Module._BZ2_bz__AssertH__fail=wasmExports.BZ2_bz__AssertH__fail)(t),_BZ2_bzlibVersion=Module._BZ2_bzlibVersion=()=>(_BZ2_bzlibVersion=Module._BZ2_bzlibVersion=wasmExports.BZ2_bzlibVersion)(),_BZ2_compressBlock=Module._BZ2_compressBlock=(t,e)=>(_BZ2_compressBlock=Module._BZ2_compressBlock=wasmExports.BZ2_compressBlock)(t,e),_BZ2_indexIntoF=Module._BZ2_indexIntoF=(t,e)=>(_BZ2_indexIntoF=Module._BZ2_indexIntoF=wasmExports.BZ2_indexIntoF)(t,e),_BZ2_decompress=Module._BZ2_decompress=t=>(_BZ2_decompress=Module._BZ2_decompress=wasmExports.BZ2_decompress)(t),_BZ2_bzWriteOpen=Module._BZ2_bzWriteOpen=(t,e,n,_,r)=>(_BZ2_bzWriteOpen=Module._BZ2_bzWriteOpen=wasmExports.BZ2_bzWriteOpen)(t,e,n,_,r),_BZ2_bzWrite=Module._BZ2_bzWrite=(t,e,n,_)=>(_BZ2_bzWrite=Module._BZ2_bzWrite=wasmExports.BZ2_bzWrite)(t,e,n,_),_BZ2_bzWriteClose=Module._BZ2_bzWriteClose=(t,e,n,_,r)=>(_BZ2_bzWriteClose=Module._BZ2_bzWriteClose=wasmExports.BZ2_bzWriteClose)(t,e,n,_,r),_BZ2_bzWriteClose64=Module._BZ2_bzWriteClose64=(t,e,n,_,r,a,o)=>(_BZ2_bzWriteClose64=Module._BZ2_bzWriteClose64=wasmExports.BZ2_bzWriteClose64)(t,e,n,_,r,a,o),_BZ2_bzReadOpen=Module._BZ2_bzReadOpen=(t,e,n,_,r,a)=>(_BZ2_bzReadOpen=Module._BZ2_bzReadOpen=wasmExports.BZ2_bzReadOpen)(t,e,n,_,r,a),_BZ2_bzReadClose=Module._BZ2_bzReadClose=(t,e)=>(_BZ2_bzReadClose=Module._BZ2_bzReadClose=wasmExports.BZ2_bzReadClose)(t,e),_BZ2_bzRead=Module._BZ2_bzRead=(t,e,n,_)=>(_BZ2_bzRead=Module._BZ2_bzRead=wasmExports.BZ2_bzRead)(t,e,n,_),_fgetc=Module._fgetc=t=>(_fgetc=Module._fgetc=wasmExports.fgetc)(t),_BZ2_bzReadGetUnused=Module._BZ2_bzReadGetUnused=(t,e,n,_)=>(_BZ2_bzReadGetUnused=Module._BZ2_bzReadGetUnused=wasmExports.BZ2_bzReadGetUnused)(t,e,n,_),_BZ2_bzBuffToBuffCompress=Module._BZ2_bzBuffToBuffCompress=(t,e,n,_,r,a,o)=>(_BZ2_bzBuffToBuffCompress=Module._BZ2_bzBuffToBuffCompress=wasmExports.BZ2_bzBuffToBuffCompress)(t,e,n,_,r,a,o),_BZ2_bzBuffToBuffDecompress=Module._BZ2_bzBuffToBuffDecompress=(t,e,n,_,r,a)=>(_BZ2_bzBuffToBuffDecompress=Module._BZ2_bzBuffToBuffDecompress=wasmExports.BZ2_bzBuffToBuffDecompress)(t,e,n,_,r,a),_BZ2_bzopen=Module._BZ2_bzopen=(t,e)=>(_BZ2_bzopen=Module._BZ2_bzopen=wasmExports.BZ2_bzopen)(t,e),_BZ2_bzdopen=Module._BZ2_bzdopen=(t,e)=>(_BZ2_bzdopen=Module._BZ2_bzdopen=wasmExports.BZ2_bzdopen)(t,e),_BZ2_bzread=Module._BZ2_bzread=(t,e,n)=>(_BZ2_bzread=Module._BZ2_bzread=wasmExports.BZ2_bzread)(t,e,n),_BZ2_bzwrite=Module._BZ2_bzwrite=(t,e,n)=>(_BZ2_bzwrite=Module._BZ2_bzwrite=wasmExports.BZ2_bzwrite)(t,e,n),_BZ2_bzflush=Module._BZ2_bzflush=t=>(_BZ2_bzflush=Module._BZ2_bzflush=wasmExports.BZ2_bzflush)(t),_BZ2_bzclose=Module._BZ2_bzclose=t=>(_BZ2_bzclose=Module._BZ2_bzclose=wasmExports.BZ2_bzclose)(t),_BZ2_bzerror=Module._BZ2_bzerror=(t,e)=>(_BZ2_bzerror=Module._BZ2_bzerror=wasmExports.BZ2_bzerror)(t,e),_BZ2_bsInitWrite=Module._BZ2_bsInitWrite=t=>(_BZ2_bsInitWrite=Module._BZ2_bsInitWrite=wasmExports.BZ2_bsInitWrite)(t),_BZ2_hbMakeCodeLengths=Module._BZ2_hbMakeCodeLengths=(t,e,n,_)=>(_BZ2_hbMakeCodeLengths=Module._BZ2_hbMakeCodeLengths=wasmExports.BZ2_hbMakeCodeLengths)(t,e,n,_),_BZ2_hbAssignCodes=Module._BZ2_hbAssignCodes=(t,e,n,_,r)=>(_BZ2_hbAssignCodes=Module._BZ2_hbAssignCodes=wasmExports.BZ2_hbAssignCodes)(t,e,n,_,r),_BZ2_hbCreateDecodeTables=Module._BZ2_hbCreateDecodeTables=(t,e,n,_,r,a,o)=>(_BZ2_hbCreateDecodeTables=Module._BZ2_hbCreateDecodeTables=wasmExports.BZ2_hbCreateDecodeTables)(t,e,n,_,r,a,o),_emscripten_GetProcAddress=Module._emscripten_GetProcAddress=t=>(_emscripten_GetProcAddress=Module._emscripten_GetProcAddress=wasmExports.emscripten_GetProcAddress)(t),_emscripten_webgl1_get_proc_address=Module._emscripten_webgl1_get_proc_address=t=>(_emscripten_webgl1_get_proc_address=Module._emscripten_webgl1_get_proc_address=wasmExports.emscripten_webgl1_get_proc_address)(t),__webgl1_match_ext_proc_address_without_suffix=Module.__webgl1_match_ext_proc_address_without_suffix=t=>(__webgl1_match_ext_proc_address_without_suffix=Module.__webgl1_match_ext_proc_address_without_suffix=wasmExports._webgl1_match_ext_proc_address_without_suffix)(t),_emscripten_webgl_get_proc_address=Module._emscripten_webgl_get_proc_address=t=>(_emscripten_webgl_get_proc_address=Module._emscripten_webgl_get_proc_address=wasmExports.emscripten_webgl_get_proc_address)(t),_SDL_GL_GetProcAddress=Module._SDL_GL_GetProcAddress=t=>(_SDL_GL_GetProcAddress=Module._SDL_GL_GetProcAddress=wasmExports.SDL_GL_GetProcAddress)(t),_eglGetProcAddress=Module._eglGetProcAddress=t=>(_eglGetProcAddress=Module._eglGetProcAddress=wasmExports.eglGetProcAddress)(t),_glfwGetProcAddress=Module._glfwGetProcAddress=t=>(_glfwGetProcAddress=Module._glfwGetProcAddress=wasmExports.glfwGetProcAddress)(t),_getdate=Module._getdate=t=>(_getdate=Module._getdate=wasmExports.getdate)(t),_stime=Module._stime=t=>(_stime=Module._stime=wasmExports.stime)(t),_clock_getcpuclockid=Module._clock_getcpuclockid=(t,e)=>(_clock_getcpuclockid=Module._clock_getcpuclockid=wasmExports.clock_getcpuclockid)(t,e),_getpwnam=Module._getpwnam=t=>(_getpwnam=Module._getpwnam=wasmExports.getpwnam)(t),_getpwuid=Module._getpwuid=t=>(_getpwuid=Module._getpwuid=wasmExports.getpwuid)(t),_getpwnam_r=Module._getpwnam_r=(t,e,n,_,r)=>(_getpwnam_r=Module._getpwnam_r=wasmExports.getpwnam_r)(t,e,n,_,r),_getpwuid_r=Module._getpwuid_r=(t,e,n,_,r)=>(_getpwuid_r=Module._getpwuid_r=wasmExports.getpwuid_r)(t,e,n,_,r),_setpwent=Module._setpwent=()=>(_setpwent=Module._setpwent=wasmExports.setpwent)(),_endpwent=Module._endpwent=()=>(_endpwent=Module._endpwent=wasmExports.endpwent)(),_getpwent=Module._getpwent=()=>(_getpwent=Module._getpwent=wasmExports.getpwent)(),_getgrnam=Module._getgrnam=t=>(_getgrnam=Module._getgrnam=wasmExports.getgrnam)(t),_getgrgid=Module._getgrgid=t=>(_getgrgid=Module._getgrgid=wasmExports.getgrgid)(t),_getgrnam_r=Module._getgrnam_r=(t,e,n,_,r)=>(_getgrnam_r=Module._getgrnam_r=wasmExports.getgrnam_r)(t,e,n,_,r),_getgrgid_r=Module._getgrgid_r=(t,e,n,_,r)=>(_getgrgid_r=Module._getgrgid_r=wasmExports.getgrgid_r)(t,e,n,_,r),_getgrent=Module._getgrent=()=>(_getgrent=Module._getgrent=wasmExports.getgrent)(),_endgrent=Module._endgrent=()=>(_endgrent=Module._endgrent=wasmExports.endgrent)(),_setgrent=Module._setgrent=()=>(_setgrent=Module._setgrent=wasmExports.setgrent)(),_flock=Module._flock=(t,e)=>(_flock=Module._flock=wasmExports.flock)(t,e),_vfork=Module._vfork=()=>(_vfork=Module._vfork=wasmExports.vfork)(),_posix_spawn=Module._posix_spawn=(t,e,n,_,r,a)=>(_posix_spawn=Module._posix_spawn=wasmExports.posix_spawn)(t,e,n,_,r,a),_popen=Module._popen=(t,e)=>(_popen=Module._popen=wasmExports.popen)(t,e),_pclose=Module._pclose=t=>(_pclose=Module._pclose=wasmExports.pclose)(t),_setgroups=Module._setgroups=(t,e)=>(_setgroups=Module._setgroups=wasmExports.setgroups)(t,e),_sigaltstack=Module._sigaltstack=(t,e)=>(_sigaltstack=Module._sigaltstack=wasmExports.sigaltstack)(t,e),___syscall_uname=Module.___syscall_uname=t=>(___syscall_uname=Module.___syscall_uname=wasmExports.__syscall_uname)(t),___syscall_setpgid=Module.___syscall_setpgid=(t,e)=>(___syscall_setpgid=Module.___syscall_setpgid=wasmExports.__syscall_setpgid)(t,e),___syscall_sync=Module.___syscall_sync=()=>(___syscall_sync=Module.___syscall_sync=wasmExports.__syscall_sync)(),___syscall_getsid=Module.___syscall_getsid=t=>(___syscall_getsid=Module.___syscall_getsid=wasmExports.__syscall_getsid)(t),___syscall_getpgid=Module.___syscall_getpgid=t=>(___syscall_getpgid=Module.___syscall_getpgid=wasmExports.__syscall_getpgid)(t),___syscall_getpid=Module.___syscall_getpid=()=>(___syscall_getpid=Module.___syscall_getpid=wasmExports.__syscall_getpid)(),___syscall_getppid=Module.___syscall_getppid=()=>(___syscall_getppid=Module.___syscall_getppid=wasmExports.__syscall_getppid)(),___syscall_linkat=Module.___syscall_linkat=(t,e,n,_,r)=>(___syscall_linkat=Module.___syscall_linkat=wasmExports.__syscall_linkat)(t,e,n,_,r),___syscall_getgroups32=Module.___syscall_getgroups32=(t,e)=>(___syscall_getgroups32=Module.___syscall_getgroups32=wasmExports.__syscall_getgroups32)(t,e),___syscall_setsid=Module.___syscall_setsid=()=>(___syscall_setsid=Module.___syscall_setsid=wasmExports.__syscall_setsid)(),___syscall_umask=Module.___syscall_umask=t=>(___syscall_umask=Module.___syscall_umask=wasmExports.__syscall_umask)(t),___syscall_setrlimit=Module.___syscall_setrlimit=(t,e)=>(___syscall_setrlimit=Module.___syscall_setrlimit=wasmExports.__syscall_setrlimit)(t,e),___syscall_getrusage=Module.___syscall_getrusage=(t,e)=>(___syscall_getrusage=Module.___syscall_getrusage=wasmExports.__syscall_getrusage)(t,e),___syscall_getpriority=Module.___syscall_getpriority=(t,e)=>(___syscall_getpriority=Module.___syscall_getpriority=wasmExports.__syscall_getpriority)(t,e),___syscall_setpriority=Module.___syscall_setpriority=(t,e,n)=>(___syscall_setpriority=Module.___syscall_setpriority=wasmExports.__syscall_setpriority)(t,e,n),___syscall_setdomainname=Module.___syscall_setdomainname=(t,e)=>(___syscall_setdomainname=Module.___syscall_setdomainname=wasmExports.__syscall_setdomainname)(t,e),___syscall_getuid32=Module.___syscall_getuid32=()=>(___syscall_getuid32=Module.___syscall_getuid32=wasmExports.__syscall_getuid32)(),___syscall_getgid32=Module.___syscall_getgid32=()=>(___syscall_getgid32=Module.___syscall_getgid32=wasmExports.__syscall_getgid32)(),___syscall_geteuid32=Module.___syscall_geteuid32=()=>(___syscall_geteuid32=Module.___syscall_geteuid32=wasmExports.__syscall_geteuid32)(),___syscall_getegid32=Module.___syscall_getegid32=()=>(___syscall_getegid32=Module.___syscall_getegid32=wasmExports.__syscall_getegid32)(),___syscall_getresuid32=Module.___syscall_getresuid32=(t,e,n)=>(___syscall_getresuid32=Module.___syscall_getresuid32=wasmExports.__syscall_getresuid32)(t,e,n),___syscall_getresgid32=Module.___syscall_getresgid32=(t,e,n)=>(___syscall_getresgid32=Module.___syscall_getresgid32=wasmExports.__syscall_getresgid32)(t,e,n),___syscall_pause=Module.___syscall_pause=()=>(___syscall_pause=Module.___syscall_pause=wasmExports.__syscall_pause)(),___syscall_madvise=Module.___syscall_madvise=(t,e,n)=>(___syscall_madvise=Module.___syscall_madvise=wasmExports.__syscall_madvise)(t,e,n),___syscall_mlock=Module.___syscall_mlock=(t,e)=>(___syscall_mlock=Module.___syscall_mlock=wasmExports.__syscall_mlock)(t,e),___syscall_munlock=Module.___syscall_munlock=(t,e)=>(___syscall_munlock=Module.___syscall_munlock=wasmExports.__syscall_munlock)(t,e),___syscall_mprotect=Module.___syscall_mprotect=(t,e,n)=>(___syscall_mprotect=Module.___syscall_mprotect=wasmExports.__syscall_mprotect)(t,e,n),___syscall_mremap=Module.___syscall_mremap=(t,e,n,_,r)=>(___syscall_mremap=Module.___syscall_mremap=wasmExports.__syscall_mremap)(t,e,n,_,r),___syscall_mlockall=Module.___syscall_mlockall=t=>(___syscall_mlockall=Module.___syscall_mlockall=wasmExports.__syscall_mlockall)(t),___syscall_munlockall=Module.___syscall_munlockall=()=>(___syscall_munlockall=Module.___syscall_munlockall=wasmExports.__syscall_munlockall)(),___syscall_prlimit64=Module.___syscall_prlimit64=(t,e,n,_)=>(___syscall_prlimit64=Module.___syscall_prlimit64=wasmExports.__syscall_prlimit64)(t,e,n,_),___syscall_ugetrlimit=Module.___syscall_ugetrlimit=(t,e)=>(___syscall_ugetrlimit=Module.___syscall_ugetrlimit=wasmExports.__syscall_ugetrlimit)(t,e),___syscall_setsockopt=Module.___syscall_setsockopt=(t,e,n,_,r,a)=>(___syscall_setsockopt=Module.___syscall_setsockopt=wasmExports.__syscall_setsockopt)(t,e,n,_,r,a),___syscall_acct=Module.___syscall_acct=t=>(___syscall_acct=Module.___syscall_acct=wasmExports.__syscall_acct)(t),___syscall_mincore=Module.___syscall_mincore=(t,e,n)=>(___syscall_mincore=Module.___syscall_mincore=wasmExports.__syscall_mincore)(t,e,n),___syscall_pipe2=Module.___syscall_pipe2=(t,e)=>(___syscall_pipe2=Module.___syscall_pipe2=wasmExports.__syscall_pipe2)(t,e),___syscall_pselect6=Module.___syscall_pselect6=(t,e,n,_,r,a)=>(___syscall_pselect6=Module.___syscall_pselect6=wasmExports.__syscall_pselect6)(t,e,n,_,r,a),___syscall_recvmmsg=Module.___syscall_recvmmsg=(t,e,n,_,r)=>(___syscall_recvmmsg=Module.___syscall_recvmmsg=wasmExports.__syscall_recvmmsg)(t,e,n,_,r),___syscall_sendmmsg=Module.___syscall_sendmmsg=(t,e,n,_,r)=>(___syscall_sendmmsg=Module.___syscall_sendmmsg=wasmExports.__syscall_sendmmsg)(t,e,n,_,r),___syscall_shutdown=Module.___syscall_shutdown=(t,e,n,_,r,a)=>(___syscall_shutdown=Module.___syscall_shutdown=wasmExports.__syscall_shutdown)(t,e,n,_,r,a),___syscall_socketpair=Module.___syscall_socketpair=(t,e,n,_,r,a)=>(___syscall_socketpair=Module.___syscall_socketpair=wasmExports.__syscall_socketpair)(t,e,n,_,r,a),___syscall_wait4=Module.___syscall_wait4=(t,e,n,_)=>(___syscall_wait4=Module.___syscall_wait4=wasmExports.__syscall_wait4)(t,e,n,_),_atexit=Module._atexit=t=>(_atexit=Module._atexit=wasmExports.atexit)(t),___cxa_atexit=Module.___cxa_atexit=(t,e,n)=>(___cxa_atexit=Module.___cxa_atexit=wasmExports.__cxa_atexit)(t,e,n),___cxa_finalize=Module.___cxa_finalize=t=>(___cxa_finalize=Module.___cxa_finalize=wasmExports.__cxa_finalize)(t),__Exit=Module.__Exit=t=>(__Exit=Module.__Exit=wasmExports._Exit)(t),_cosf=Module._cosf=t=>(_cosf=Module._cosf=wasmExports.cosf)(t),_sinf=Module._sinf=t=>(_sinf=Module._sinf=wasmExports.sinf)(t),_expf=Module._expf=t=>(_expf=Module._expf=wasmExports.expf)(t),___multf3=Module.___multf3=(t,e,n,_,r)=>(___multf3=Module.___multf3=wasmExports.__multf3)(t,e,n,_,r),___addtf3=Module.___addtf3=(t,e,n,_,r)=>(___addtf3=Module.___addtf3=wasmExports.__addtf3)(t,e,n,_,r),___subtf3=Module.___subtf3=(t,e,n,_,r)=>(___subtf3=Module.___subtf3=wasmExports.__subtf3)(t,e,n,_,r),___ctype_b_loc=Module.___ctype_b_loc=()=>(___ctype_b_loc=Module.___ctype_b_loc=wasmExports.__ctype_b_loc)(),___ctype_get_mb_cur_max=Module.___ctype_get_mb_cur_max=()=>(___ctype_get_mb_cur_max=Module.___ctype_get_mb_cur_max=wasmExports.__ctype_get_mb_cur_max)(),___get_tp=Module.___get_tp=()=>(___get_tp=Module.___get_tp=wasmExports.__get_tp)(),___ctype_tolower_loc=Module.___ctype_tolower_loc=()=>(___ctype_tolower_loc=Module.___ctype_tolower_loc=wasmExports.__ctype_tolower_loc)(),___ctype_toupper_loc=Module.___ctype_toupper_loc=()=>(___ctype_toupper_loc=Module.___ctype_toupper_loc=wasmExports.__ctype_toupper_loc)(),___emscripten_environ_constructor=Module.___emscripten_environ_constructor=()=>(___emscripten_environ_constructor=Module.___emscripten_environ_constructor=wasmExports.__emscripten_environ_constructor)(),_emscripten_builtin_malloc=Module._emscripten_builtin_malloc=t=>(_emscripten_builtin_malloc=Module._emscripten_builtin_malloc=wasmExports.emscripten_builtin_malloc)(t),___flt_rounds=Module.___flt_rounds=()=>(___flt_rounds=Module.___flt_rounds=wasmExports.__flt_rounds)(),_fegetround=Module._fegetround=()=>(_fegetround=Module._fegetround=wasmExports.fegetround)(),___fmodeflags=Module.___fmodeflags=t=>(___fmodeflags=Module.___fmodeflags=wasmExports.__fmodeflags)(t),___fpclassify=Module.___fpclassify=t=>(___fpclassify=Module.___fpclassify=wasmExports.__fpclassify)(t),___fpclassifyf=Module.___fpclassifyf=t=>(___fpclassifyf=Module.___fpclassifyf=wasmExports.__fpclassifyf)(t),___fpclassifyl=Module.___fpclassifyl=(t,e)=>(___fpclassifyl=Module.___fpclassifyl=wasmExports.__fpclassifyl)(t,e),___divtf3=Module.___divtf3=(t,e,n,_,r)=>(___divtf3=Module.___divtf3=wasmExports.__divtf3)(t,e,n,_,r),___mo_lookup=Module.___mo_lookup=(t,e,n)=>(___mo_lookup=Module.___mo_lookup=wasmExports.__mo_lookup)(t,e,n),___overflow=Module.___overflow=(t,e)=>(___overflow=Module.___overflow=wasmExports.__overflow)(t,e),_scalbn=Module._scalbn=(t,e)=>(_scalbn=Module._scalbn=wasmExports.scalbn)(t,e),_floor=Module._floor=t=>(_floor=Module._floor=wasmExports.floor)(t),___lttf2=Module.___lttf2=(t,e,n,_)=>(___lttf2=Module.___lttf2=wasmExports.__lttf2)(t,e,n,_),___fixtfdi=Module.___fixtfdi=(t,e)=>(___fixtfdi=Module.___fixtfdi=wasmExports.__fixtfdi)(t,e),___gttf2=Module.___gttf2=(t,e,n,_)=>(___gttf2=Module.___gttf2=wasmExports.__gttf2)(t,e,n,_),___fixtfsi=Module.___fixtfsi=(t,e)=>(___fixtfsi=Module.___fixtfsi=wasmExports.__fixtfsi)(t,e),___floatsitf=Module.___floatsitf=(t,e)=>(___floatsitf=Module.___floatsitf=wasmExports.__floatsitf)(t,e),___signbit=Module.___signbit=t=>(___signbit=Module.___signbit=wasmExports.__signbit)(t),___signbitf=Module.___signbitf=t=>(___signbitf=Module.___signbitf=wasmExports.__signbitf)(t),___signbitl=Module.___signbitl=(t,e)=>(___signbitl=Module.___signbitl=wasmExports.__signbitl)(t,e),___wasi_syscall_ret=Module.___wasi_syscall_ret=t=>(___wasi_syscall_ret=Module.___wasi_syscall_ret=wasmExports.__wasi_syscall_ret)(t),___synccall=Module.___synccall=(t,e)=>(___synccall=Module.___synccall=wasmExports.__synccall)(t,e),_fabsl=Module._fabsl=(t,e,n)=>(_fabsl=Module._fabsl=wasmExports.fabsl)(t,e,n),___getf2=Module.___getf2=(t,e,n,_)=>(___getf2=Module.___getf2=wasmExports.__getf2)(t,e,n,_),___uflow=Module.___uflow=t=>(___uflow=Module.___uflow=wasmExports.__uflow)(t),___fxstat=Module.___fxstat=(t,e,n)=>(___fxstat=Module.___fxstat=wasmExports.__fxstat)(t,e,n),___fxstatat=Module.___fxstatat=(t,e,n,_,r)=>(___fxstatat=Module.___fxstatat=wasmExports.__fxstatat)(t,e,n,_,r),___lxstat=Module.___lxstat=(t,e,n)=>(___lxstat=Module.___lxstat=wasmExports.__lxstat)(t,e,n),___xstat=Module.___xstat=(t,e,n)=>(___xstat=Module.___xstat=wasmExports.__xstat)(t,e,n),___xmknod=Module.___xmknod=(t,e,n,_)=>(___xmknod=Module.___xmknod=wasmExports.__xmknod)(t,e,n,_),_mknod=Module._mknod=(t,e,n)=>(_mknod=Module._mknod=wasmExports.mknod)(t,e,n),___xmknodat=Module.___xmknodat=(t,e,n,_,r)=>(___xmknodat=Module.___xmknodat=wasmExports.__xmknodat)(t,e,n,_,r),_mknodat=Module._mknodat=(t,e,n,_)=>(_mknodat=Module._mknodat=wasmExports.mknodat)(t,e,n,_),_a64l=Module._a64l=t=>(_a64l=Module._a64l=wasmExports.a64l)(t),_l64a=Module._l64a=t=>(_l64a=Module._l64a=wasmExports.l64a)(t),_abs=Module._abs=t=>(_abs=Module._abs=wasmExports.abs)(t),_acct=Module._acct=t=>(_acct=Module._acct=wasmExports.acct)(t),_acosf=Module._acosf=t=>(_acosf=Module._acosf=wasmExports.acosf)(t),_sqrtf=Module._sqrtf=t=>(_sqrtf=Module._sqrtf=wasmExports.sqrtf)(t),_acoshf=Module._acoshf=t=>(_acoshf=Module._acoshf=wasmExports.acoshf)(t),_log1pf=Module._log1pf=t=>(_log1pf=Module._log1pf=wasmExports.log1pf)(t),_logf=Module._logf=t=>(_logf=Module._logf=wasmExports.logf)(t),_acoshl=Module._acoshl=(t,e,n)=>(_acoshl=Module._acoshl=wasmExports.acoshl)(t,e,n),_acosl=Module._acosl=(t,e,n)=>(_acosl=Module._acosl=wasmExports.acosl)(t,e,n),___eqtf2=Module.___eqtf2=(t,e,n,_)=>(___eqtf2=Module.___eqtf2=wasmExports.__eqtf2)(t,e,n,_),___netf2=Module.___netf2=(t,e,n,_)=>(___netf2=Module.___netf2=wasmExports.__netf2)(t,e,n,_),_sqrtl=Module._sqrtl=(t,e,n)=>(_sqrtl=Module._sqrtl=wasmExports.sqrtl)(t,e,n),_alarm=Module._alarm=t=>(_alarm=Module._alarm=wasmExports.alarm)(t),_setitimer=Module._setitimer=(t,e,n)=>(_setitimer=Module._setitimer=wasmExports.setitimer)(t,e,n),_aligned_alloc=Module._aligned_alloc=(t,e)=>(_aligned_alloc=Module._aligned_alloc=wasmExports.aligned_alloc)(t,e),_posix_memalign=Module._posix_memalign=(t,e,n)=>(_posix_memalign=Module._posix_memalign=wasmExports.posix_memalign)(t,e,n),_alphasort=Module._alphasort=(t,e)=>(_alphasort=Module._alphasort=wasmExports.alphasort)(t,e),_strcoll=Module._strcoll=(t,e)=>(_strcoll=Module._strcoll=wasmExports.strcoll)(t,e),_asctime=Module._asctime=t=>(_asctime=Module._asctime=wasmExports.asctime)(t),___nl_langinfo_l=Module.___nl_langinfo_l=(t,e)=>(___nl_langinfo_l=Module.___nl_langinfo_l=wasmExports.__nl_langinfo_l)(t,e),_asctime_r=Module._asctime_r=(t,e)=>(_asctime_r=Module._asctime_r=wasmExports.asctime_r)(t,e),_asinf=Module._asinf=t=>(_asinf=Module._asinf=wasmExports.asinf)(t),_fabsf=Module._fabsf=t=>(_fabsf=Module._fabsf=wasmExports.fabsf)(t),_asinhf=Module._asinhf=t=>(_asinhf=Module._asinhf=wasmExports.asinhf)(t),_asinhl=Module._asinhl=(t,e,n)=>(_asinhl=Module._asinhl=wasmExports.asinhl)(t,e,n),_asinl=Module._asinl=(t,e,n)=>(_asinl=Module._asinl=wasmExports.asinl)(t,e,n),_asprintf=Module._asprintf=(t,e,n)=>(_asprintf=Module._asprintf=wasmExports.asprintf)(t,e,n),_vasprintf=Module._vasprintf=(t,e,n)=>(_vasprintf=Module._vasprintf=wasmExports.vasprintf)(t,e,n),___lock=Module.___lock=t=>(___lock=Module.___lock=wasmExports.__lock)(t),___unlock=Module.___unlock=t=>(___unlock=Module.___unlock=wasmExports.__unlock)(t),_at_quick_exit=Module._at_quick_exit=t=>(_at_quick_exit=Module._at_quick_exit=wasmExports.at_quick_exit)(t),_atan2f=Module._atan2f=(t,e)=>(_atan2f=Module._atan2f=wasmExports.atan2f)(t,e),_atanf=Module._atanf=t=>(_atanf=Module._atanf=wasmExports.atanf)(t),_atan2l=Module._atan2l=(t,e,n,_,r)=>(_atan2l=Module._atan2l=wasmExports.atan2l)(t,e,n,_,r),_atanl=Module._atanl=(t,e,n)=>(_atanl=Module._atanl=wasmExports.atanl)(t,e,n),_atanhf=Module._atanhf=t=>(_atanhf=Module._atanhf=wasmExports.atanhf)(t),_atanhl=Module._atanhl=(t,e,n)=>(_atanhl=Module._atanhl=wasmExports.atanhl)(t,e,n),_log1pl=Module._log1pl=(t,e,n)=>(_log1pl=Module._log1pl=wasmExports.log1pl)(t,e,n),____cxa_finalize=Module.____cxa_finalize=t=>(____cxa_finalize=Module.____cxa_finalize=wasmExports.___cxa_finalize)(t),____cxa_atexit=Module.____cxa_atexit=(t,e,n)=>(____cxa_atexit=Module.____cxa_atexit=wasmExports.___cxa_atexit)(t,e,n),___libc_calloc=Module.___libc_calloc=(t,e)=>(___libc_calloc=Module.___libc_calloc=wasmExports.__libc_calloc)(t,e),___atexit=Module.___atexit=t=>(___atexit=Module.___atexit=wasmExports.__atexit)(t),_atof=Module._atof=t=>(_atof=Module._atof=wasmExports.atof)(t),_strtod=Module._strtod=(t,e)=>(_strtod=Module._strtod=wasmExports.strtod)(t,e),_atoi=Module._atoi=t=>(_atoi=Module._atoi=wasmExports.atoi)(t),_isspace=Module._isspace=t=>(_isspace=Module._isspace=wasmExports.isspace)(t),_isdigit=Module._isdigit=t=>(_isdigit=Module._isdigit=wasmExports.isdigit)(t),_atol=Module._atol=t=>(_atol=Module._atol=wasmExports.atol)(t),_atoll=Module._atoll=t=>(_atoll=Module._atoll=wasmExports.atoll)(t),_basename=Module._basename=t=>(_basename=Module._basename=wasmExports.basename)(t),___xpg_basename=Module.___xpg_basename=t=>(___xpg_basename=Module.___xpg_basename=wasmExports.__xpg_basename)(t),_bcmp=Module._bcmp=(t,e,n)=>(_bcmp=Module._bcmp=wasmExports.bcmp)(t,e,n),_bcopy=Module._bcopy=(t,e,n)=>(_bcopy=Module._bcopy=wasmExports.bcopy)(t,e,n),_strcasecmp=Module._strcasecmp=(t,e)=>(_strcasecmp=Module._strcasecmp=wasmExports.strcasecmp)(t,e),_bsearch=Module._bsearch=(t,e,n,_,r)=>(_bsearch=Module._bsearch=wasmExports.bsearch)(t,e,n,_,r),_btowc=Module._btowc=t=>(_btowc=Module._btowc=wasmExports.btowc)(t),_bzero=Module._bzero=(t,e)=>(_bzero=Module._bzero=wasmExports.bzero)(t,e),_c16rtomb=Module._c16rtomb=(t,e,n)=>(_c16rtomb=Module._c16rtomb=wasmExports.c16rtomb)(t,e,n),_wcrtomb=Module._wcrtomb=(t,e,n)=>(_wcrtomb=Module._wcrtomb=wasmExports.wcrtomb)(t,e,n),_c32rtomb=Module._c32rtomb=(t,e,n)=>(_c32rtomb=Module._c32rtomb=wasmExports.c32rtomb)(t,e,n),_cabs=Module._cabs=t=>(_cabs=Module._cabs=wasmExports.cabs)(t),_cabsf=Module._cabsf=t=>(_cabsf=Module._cabsf=wasmExports.cabsf)(t),_hypotf=Module._hypotf=(t,e)=>(_hypotf=Module._hypotf=wasmExports.hypotf)(t,e),_cabsl=Module._cabsl=(t,e)=>(_cabsl=Module._cabsl=wasmExports.cabsl)(t,e),_hypotl=Module._hypotl=(t,e,n,_,r)=>(_hypotl=Module._hypotl=wasmExports.hypotl)(t,e,n,_,r),_cacos=Module._cacos=(t,e)=>(_cacos=Module._cacos=wasmExports.cacos)(t,e),_casin=Module._casin=(t,e)=>(_casin=Module._casin=wasmExports.casin)(t,e),_cacosf=Module._cacosf=(t,e)=>(_cacosf=Module._cacosf=wasmExports.cacosf)(t,e),_casinf=Module._casinf=(t,e)=>(_casinf=Module._casinf=wasmExports.casinf)(t,e),_cacosh=Module._cacosh=(t,e)=>(_cacosh=Module._cacosh=wasmExports.cacosh)(t,e),_cacoshf=Module._cacoshf=(t,e)=>(_cacoshf=Module._cacoshf=wasmExports.cacoshf)(t,e),_cacoshl=Module._cacoshl=(t,e)=>(_cacoshl=Module._cacoshl=wasmExports.cacoshl)(t,e),_cacosl=Module._cacosl=(t,e)=>(_cacosl=Module._cacosl=wasmExports.cacosl)(t,e),_casinl=Module._casinl=(t,e)=>(_casinl=Module._casinl=wasmExports.casinl)(t,e),_call_once=Module._call_once=(t,e)=>(_call_once=Module._call_once=wasmExports.call_once)(t,e),_carg=Module._carg=t=>(_carg=Module._carg=wasmExports.carg)(t),_cargf=Module._cargf=t=>(_cargf=Module._cargf=wasmExports.cargf)(t),_cargl=Module._cargl=(t,e)=>(_cargl=Module._cargl=wasmExports.cargl)(t,e),_csqrt=Module._csqrt=(t,e)=>(_csqrt=Module._csqrt=wasmExports.csqrt)(t,e),_clog=Module._clog=(t,e)=>(_clog=Module._clog=wasmExports.clog)(t,e),_csqrtf=Module._csqrtf=(t,e)=>(_csqrtf=Module._csqrtf=wasmExports.csqrtf)(t,e),_clogf=Module._clogf=(t,e)=>(_clogf=Module._clogf=wasmExports.clogf)(t,e),_casinh=Module._casinh=(t,e)=>(_casinh=Module._casinh=wasmExports.casinh)(t,e),_casinhf=Module._casinhf=(t,e)=>(_casinhf=Module._casinhf=wasmExports.casinhf)(t,e),_casinhl=Module._casinhl=(t,e)=>(_casinhl=Module._casinhl=wasmExports.casinhl)(t,e),_csqrtl=Module._csqrtl=(t,e)=>(_csqrtl=Module._csqrtl=wasmExports.csqrtl)(t,e),_clogl=Module._clogl=(t,e)=>(_clogl=Module._clogl=wasmExports.clogl)(t,e),_catan=Module._catan=(t,e)=>(_catan=Module._catan=wasmExports.catan)(t,e),_catanf=Module._catanf=(t,e)=>(_catanf=Module._catanf=wasmExports.catanf)(t,e),_catanh=Module._catanh=(t,e)=>(_catanh=Module._catanh=wasmExports.catanh)(t,e),_catanhf=Module._catanhf=(t,e)=>(_catanhf=Module._catanhf=wasmExports.catanhf)(t,e),_catanhl=Module._catanhl=(t,e)=>(_catanhl=Module._catanhl=wasmExports.catanhl)(t,e),_catanl=Module._catanl=(t,e)=>(_catanl=Module._catanl=wasmExports.catanl)(t,e),_logl=Module._logl=(t,e,n)=>(_logl=Module._logl=wasmExports.logl)(t,e,n),___trunctfsf2=Module.___trunctfsf2=(t,e)=>(___trunctfsf2=Module.___trunctfsf2=wasmExports.__trunctfsf2)(t,e),___extendsftf2=Module.___extendsftf2=(t,e)=>(___extendsftf2=Module.___extendsftf2=wasmExports.__extendsftf2)(t,e),_catclose=Module._catclose=t=>(_catclose=Module._catclose=wasmExports.catclose)(t),_catgets=Module._catgets=(t,e,n,_)=>(_catgets=Module._catgets=wasmExports.catgets)(t,e,n,_),_catopen=Module._catopen=(t,e)=>(_catopen=Module._catopen=wasmExports.catopen)(t,e),_cbrtf=Module._cbrtf=t=>(_cbrtf=Module._cbrtf=wasmExports.cbrtf)(t),_cbrtl=Module._cbrtl=(t,e,n)=>(_cbrtl=Module._cbrtl=wasmExports.cbrtl)(t,e,n),_ccos=Module._ccos=(t,e)=>(_ccos=Module._ccos=wasmExports.ccos)(t,e),_ccosh=Module._ccosh=(t,e)=>(_ccosh=Module._ccosh=wasmExports.ccosh)(t,e),_ccosf=Module._ccosf=(t,e)=>(_ccosf=Module._ccosf=wasmExports.ccosf)(t,e),_ccoshf=Module._ccoshf=(t,e)=>(_ccoshf=Module._ccoshf=wasmExports.ccoshf)(t,e),_coshf=Module._coshf=t=>(_coshf=Module._coshf=wasmExports.coshf)(t),_sinhf=Module._sinhf=t=>(_sinhf=Module._sinhf=wasmExports.sinhf)(t),_copysignf=Module._copysignf=(t,e)=>(_copysignf=Module._copysignf=wasmExports.copysignf)(t,e),_ccoshl=Module._ccoshl=(t,e)=>(_ccoshl=Module._ccoshl=wasmExports.ccoshl)(t,e),_ccosl=Module._ccosl=(t,e)=>(_ccosl=Module._ccosl=wasmExports.ccosl)(t,e),_ceil=Module._ceil=t=>(_ceil=Module._ceil=wasmExports.ceil)(t),_ceilf=Module._ceilf=t=>(_ceilf=Module._ceilf=wasmExports.ceilf)(t),_ceill=Module._ceill=(t,e,n)=>(_ceill=Module._ceill=wasmExports.ceill)(t,e,n),_cexp=Module._cexp=(t,e)=>(_cexp=Module._cexp=wasmExports.cexp)(t,e),_cexpf=Module._cexpf=(t,e)=>(_cexpf=Module._cexpf=wasmExports.cexpf)(t,e),_cexpl=Module._cexpl=(t,e)=>(_cexpl=Module._cexpl=wasmExports.cexpl)(t,e),_cfgetospeed=Module._cfgetospeed=t=>(_cfgetospeed=Module._cfgetospeed=wasmExports.cfgetospeed)(t),_cfgetispeed=Module._cfgetispeed=t=>(_cfgetispeed=Module._cfgetispeed=wasmExports.cfgetispeed)(t),_cfmakeraw=Module._cfmakeraw=t=>(_cfmakeraw=Module._cfmakeraw=wasmExports.cfmakeraw)(t),_cfsetospeed=Module._cfsetospeed=(t,e)=>(_cfsetospeed=Module._cfsetospeed=wasmExports.cfsetospeed)(t,e),_cfsetispeed=Module._cfsetispeed=(t,e)=>(_cfsetispeed=Module._cfsetispeed=wasmExports.cfsetispeed)(t,e),_cfsetspeed=Module._cfsetspeed=(t,e)=>(_cfsetspeed=Module._cfsetspeed=wasmExports.cfsetspeed)(t,e),_cimag=Module._cimag=t=>(_cimag=Module._cimag=wasmExports.cimag)(t),_cimagf=Module._cimagf=t=>(_cimagf=Module._cimagf=wasmExports.cimagf)(t),_cimagl=Module._cimagl=(t,e)=>(_cimagl=Module._cimagl=wasmExports.cimagl)(t,e),_clearenv=Module._clearenv=()=>(_clearenv=Module._clearenv=wasmExports.clearenv)(),_clearerr_unlocked=Module._clearerr_unlocked=t=>(_clearerr_unlocked=Module._clearerr_unlocked=wasmExports.clearerr_unlocked)(t),_emscripten_thread_sleep=Module._emscripten_thread_sleep=t=>(_emscripten_thread_sleep=Module._emscripten_thread_sleep=wasmExports.emscripten_thread_sleep)(t),_cnd_broadcast=Module._cnd_broadcast=t=>(_cnd_broadcast=Module._cnd_broadcast=wasmExports.cnd_broadcast)(t),_cnd_destroy=Module._cnd_destroy=t=>(_cnd_destroy=Module._cnd_destroy=wasmExports.cnd_destroy)(t),_cnd_init=Module._cnd_init=t=>(_cnd_init=Module._cnd_init=wasmExports.cnd_init)(t),_cnd_signal=Module._cnd_signal=t=>(_cnd_signal=Module._cnd_signal=wasmExports.cnd_signal)(t),_cnd_timedwait=Module._cnd_timedwait=(t,e,n)=>(_cnd_timedwait=Module._cnd_timedwait=wasmExports.cnd_timedwait)(t,e,n),_cnd_wait=Module._cnd_wait=(t,e)=>(_cnd_wait=Module._cnd_wait=wasmExports.cnd_wait)(t,e),_conj=Module._conj=(t,e)=>(_conj=Module._conj=wasmExports.conj)(t,e),_conjf=Module._conjf=(t,e)=>(_conjf=Module._conjf=wasmExports.conjf)(t,e),_conjl=Module._conjl=(t,e)=>(_conjl=Module._conjl=wasmExports.conjl)(t,e),_copysignl=Module._copysignl=(t,e,n,_,r)=>(_copysignl=Module._copysignl=wasmExports.copysignl)(t,e,n,_,r),_expm1f=Module._expm1f=t=>(_expm1f=Module._expm1f=wasmExports.expm1f)(t),_coshl=Module._coshl=(t,e,n)=>(_coshl=Module._coshl=wasmExports.coshl)(t,e,n),_cosl=Module._cosl=(t,e,n)=>(_cosl=Module._cosl=wasmExports.cosl)(t,e,n),_cpow=Module._cpow=(t,e,n)=>(_cpow=Module._cpow=wasmExports.cpow)(t,e,n),___muldc3=Module.___muldc3=(t,e,n,_,r)=>(___muldc3=Module.___muldc3=wasmExports.__muldc3)(t,e,n,_,r),_cpowf=Module._cpowf=(t,e,n)=>(_cpowf=Module._cpowf=wasmExports.cpowf)(t,e,n),___mulsc3=Module.___mulsc3=(t,e,n,_,r)=>(___mulsc3=Module.___mulsc3=wasmExports.__mulsc3)(t,e,n,_,r),_cpowl=Module._cpowl=(t,e,n)=>(_cpowl=Module._cpowl=wasmExports.cpowl)(t,e,n),___unordtf2=Module.___unordtf2=(t,e,n,_)=>(___unordtf2=Module.___unordtf2=wasmExports.__unordtf2)(t,e,n,_),___multc3=Module.___multc3=(t,e,n,_,r,a,o,l,p)=>(___multc3=Module.___multc3=wasmExports.__multc3)(t,e,n,_,r,a,o,l,p),_cproj=Module._cproj=(t,e)=>(_cproj=Module._cproj=wasmExports.cproj)(t,e),_cprojf=Module._cprojf=(t,e)=>(_cprojf=Module._cprojf=wasmExports.cprojf)(t,e),_cprojl=Module._cprojl=(t,e)=>(_cprojl=Module._cprojl=wasmExports.cprojl)(t,e),_creal=Module._creal=t=>(_creal=Module._creal=wasmExports.creal)(t),_crealf=Module._crealf=t=>(_crealf=Module._crealf=wasmExports.crealf)(t),_creall=Module._creall=(t,e)=>(_creall=Module._creall=wasmExports.creall)(t,e),_creat=Module._creat=(t,e)=>(_creat=Module._creat=wasmExports.creat)(t,e),_crypt=Module._crypt=(t,e)=>(_crypt=Module._crypt=wasmExports.crypt)(t,e),___crypt_blowfish=Module.___crypt_blowfish=(t,e,n)=>(___crypt_blowfish=Module.___crypt_blowfish=wasmExports.__crypt_blowfish)(t,e,n),___crypt_des=Module.___crypt_des=(t,e,n)=>(___crypt_des=Module.___crypt_des=wasmExports.__crypt_des)(t,e,n),___crypt_md5=Module.___crypt_md5=(t,e,n)=>(___crypt_md5=Module.___crypt_md5=wasmExports.__crypt_md5)(t,e,n),_strnlen=Module._strnlen=(t,e)=>(_strnlen=Module._strnlen=wasmExports.strnlen)(t,e),___crypt_sha256=Module.___crypt_sha256=(t,e,n)=>(___crypt_sha256=Module.___crypt_sha256=wasmExports.__crypt_sha256)(t,e,n),___crypt_sha512=Module.___crypt_sha512=(t,e,n)=>(___crypt_sha512=Module.___crypt_sha512=wasmExports.__crypt_sha512)(t,e,n),_sprintf=Module._sprintf=(t,e,n)=>(_sprintf=Module._sprintf=wasmExports.sprintf)(t,e,n),_csin=Module._csin=(t,e)=>(_csin=Module._csin=wasmExports.csin)(t,e),_csinh=Module._csinh=(t,e)=>(_csinh=Module._csinh=wasmExports.csinh)(t,e),_csinf=Module._csinf=(t,e)=>(_csinf=Module._csinf=wasmExports.csinf)(t,e),_csinhf=Module._csinhf=(t,e)=>(_csinhf=Module._csinhf=wasmExports.csinhf)(t,e),_csinhl=Module._csinhl=(t,e)=>(_csinhl=Module._csinhl=wasmExports.csinhl)(t,e),_csinl=Module._csinl=(t,e)=>(_csinl=Module._csinl=wasmExports.csinl)(t,e),_ctan=Module._ctan=(t,e)=>(_ctan=Module._ctan=wasmExports.ctan)(t,e),_ctanh=Module._ctanh=(t,e)=>(_ctanh=Module._ctanh=wasmExports.ctanh)(t,e),_ctanf=Module._ctanf=(t,e)=>(_ctanf=Module._ctanf=wasmExports.ctanf)(t,e),_ctanhf=Module._ctanhf=(t,e)=>(_ctanhf=Module._ctanhf=wasmExports.ctanhf)(t,e),_tanf=Module._tanf=t=>(_tanf=Module._tanf=wasmExports.tanf)(t),_ctanhl=Module._ctanhl=(t,e)=>(_ctanhl=Module._ctanhl=wasmExports.ctanhl)(t,e),_ctanl=Module._ctanl=(t,e)=>(_ctanl=Module._ctanl=wasmExports.ctanl)(t,e),_ctime=Module._ctime=t=>(_ctime=Module._ctime=wasmExports.ctime)(t),_localtime=Module._localtime=t=>(_localtime=Module._localtime=wasmExports.localtime)(t),_ctime_r=Module._ctime_r=(t,e)=>(_ctime_r=Module._ctime_r=wasmExports.ctime_r)(t,e),_dcngettext=Module._dcngettext=(t,e,n,_,r)=>(_dcngettext=Module._dcngettext=wasmExports.dcngettext)(t,e,n,_,r),___gettextdomain=Module.___gettextdomain=()=>(___gettextdomain=Module.___gettextdomain=wasmExports.__gettextdomain)(),_dngettext=Module._dngettext=(t,e,n,_)=>(_dngettext=Module._dngettext=wasmExports.dngettext)(t,e,n,_),_difftime=Module._difftime=(t,e)=>(_difftime=Module._difftime=wasmExports.difftime)(t,e),_dirname=Module._dirname=t=>(_dirname=Module._dirname=wasmExports.dirname)(t),_div=Module._div=(t,e,n)=>(_div=Module._div=wasmExports.div)(t,e,n),_dladdr=Module._dladdr=(t,e)=>(_dladdr=Module._dladdr=wasmExports.dladdr)(t,e),___libc_free=Module.___libc_free=t=>(___libc_free=Module.___libc_free=wasmExports.__libc_free)(t),___libc_malloc=Module.___libc_malloc=t=>(___libc_malloc=Module.___libc_malloc=wasmExports.__libc_malloc)(t),___dl_seterr=(t,e)=>(___dl_seterr=wasmExports.__dl_seterr)(t,e),_dn_comp=Module._dn_comp=(t,e,n,_,r)=>(_dn_comp=Module._dn_comp=wasmExports.dn_comp)(t,e,n,_,r),_dn_expand=Module._dn_expand=(t,e,n,_,r)=>(_dn_expand=Module._dn_expand=wasmExports.dn_expand)(t,e,n,_,r),_dn_skipname=Module._dn_skipname=(t,e)=>(_dn_skipname=Module._dn_skipname=wasmExports.dn_skipname)(t,e),_dprintf=Module._dprintf=(t,e,n)=>(_dprintf=Module._dprintf=wasmExports.dprintf)(t,e,n),_vdprintf=Module._vdprintf=(t,e,n)=>(_vdprintf=Module._vdprintf=wasmExports.vdprintf)(t,e,n),_erand48=Module._erand48=t=>(_erand48=Module._erand48=wasmExports.erand48)(t),_drand48=Module._drand48=()=>(_drand48=Module._drand48=wasmExports.drand48)(),___wasi_fd_is_valid=Module.___wasi_fd_is_valid=t=>(___wasi_fd_is_valid=Module.___wasi_fd_is_valid=wasmExports.__wasi_fd_is_valid)(t),___duplocale=Module.___duplocale=t=>(___duplocale=Module.___duplocale=wasmExports.__duplocale)(t),_duplocale=Module._duplocale=t=>(_duplocale=Module._duplocale=wasmExports.duplocale)(t),_new_dlevent=Module._new_dlevent=(t,e)=>(_new_dlevent=Module._new_dlevent=wasmExports.new_dlevent)(t,e),_pthread_setcancelstate=Module._pthread_setcancelstate=(t,e)=>(_pthread_setcancelstate=Module._pthread_setcancelstate=wasmExports.pthread_setcancelstate)(t,e),_emscripten_dlopen=Module._emscripten_dlopen=(t,e,n,_,r)=>(_emscripten_dlopen=Module._emscripten_dlopen=wasmExports.emscripten_dlopen)(t,e,n,_,r),_emscripten_dlopen_promise=Module._emscripten_dlopen_promise=(t,e)=>(_emscripten_dlopen_promise=Module._emscripten_dlopen_promise=wasmExports.emscripten_dlopen_promise)(t,e),_strspn=Module._strspn=(t,e)=>(_strspn=Module._strspn=wasmExports.strspn)(t,e),_ecvt=Module._ecvt=(t,e,n,_)=>(_ecvt=Module._ecvt=wasmExports.ecvt)(t,e,n,_),_emscripten_atomic_exchange_u8=Module._emscripten_atomic_exchange_u8=(t,e)=>(_emscripten_atomic_exchange_u8=Module._emscripten_atomic_exchange_u8=wasmExports.emscripten_atomic_exchange_u8)(t,e),_emscripten_atomic_exchange_u16=Module._emscripten_atomic_exchange_u16=(t,e)=>(_emscripten_atomic_exchange_u16=Module._emscripten_atomic_exchange_u16=wasmExports.emscripten_atomic_exchange_u16)(t,e),_emscripten_atomic_exchange_u32=Module._emscripten_atomic_exchange_u32=(t,e)=>(_emscripten_atomic_exchange_u32=Module._emscripten_atomic_exchange_u32=wasmExports.emscripten_atomic_exchange_u32)(t,e),_emscripten_atomic_exchange_u64=Module._emscripten_atomic_exchange_u64=(t,e)=>(_emscripten_atomic_exchange_u64=Module._emscripten_atomic_exchange_u64=wasmExports.emscripten_atomic_exchange_u64)(t,e),_emscripten_atomic_cas_u8=Module._emscripten_atomic_cas_u8=(t,e,n)=>(_emscripten_atomic_cas_u8=Module._emscripten_atomic_cas_u8=wasmExports.emscripten_atomic_cas_u8)(t,e,n),_emscripten_atomic_cas_u16=Module._emscripten_atomic_cas_u16=(t,e,n)=>(_emscripten_atomic_cas_u16=Module._emscripten_atomic_cas_u16=wasmExports.emscripten_atomic_cas_u16)(t,e,n),_emscripten_atomic_cas_u32=Module._emscripten_atomic_cas_u32=(t,e,n)=>(_emscripten_atomic_cas_u32=Module._emscripten_atomic_cas_u32=wasmExports.emscripten_atomic_cas_u32)(t,e,n),_emscripten_atomic_cas_u64=Module._emscripten_atomic_cas_u64=(t,e,n)=>(_emscripten_atomic_cas_u64=Module._emscripten_atomic_cas_u64=wasmExports.emscripten_atomic_cas_u64)(t,e,n),_emscripten_atomic_load_u8=Module._emscripten_atomic_load_u8=t=>(_emscripten_atomic_load_u8=Module._emscripten_atomic_load_u8=wasmExports.emscripten_atomic_load_u8)(t),_emscripten_atomic_load_u16=Module._emscripten_atomic_load_u16=t=>(_emscripten_atomic_load_u16=Module._emscripten_atomic_load_u16=wasmExports.emscripten_atomic_load_u16)(t),_emscripten_atomic_load_u32=Module._emscripten_atomic_load_u32=t=>(_emscripten_atomic_load_u32=Module._emscripten_atomic_load_u32=wasmExports.emscripten_atomic_load_u32)(t),_emscripten_atomic_load_f32=Module._emscripten_atomic_load_f32=t=>(_emscripten_atomic_load_f32=Module._emscripten_atomic_load_f32=wasmExports.emscripten_atomic_load_f32)(t),_emscripten_atomic_load_u64=Module._emscripten_atomic_load_u64=t=>(_emscripten_atomic_load_u64=Module._emscripten_atomic_load_u64=wasmExports.emscripten_atomic_load_u64)(t),_emscripten_atomic_load_f64=Module._emscripten_atomic_load_f64=t=>(_emscripten_atomic_load_f64=Module._emscripten_atomic_load_f64=wasmExports.emscripten_atomic_load_f64)(t),_emscripten_atomic_store_u8=Module._emscripten_atomic_store_u8=(t,e)=>(_emscripten_atomic_store_u8=Module._emscripten_atomic_store_u8=wasmExports.emscripten_atomic_store_u8)(t,e),_emscripten_atomic_store_u16=Module._emscripten_atomic_store_u16=(t,e)=>(_emscripten_atomic_store_u16=Module._emscripten_atomic_store_u16=wasmExports.emscripten_atomic_store_u16)(t,e),_emscripten_atomic_store_u32=Module._emscripten_atomic_store_u32=(t,e)=>(_emscripten_atomic_store_u32=Module._emscripten_atomic_store_u32=wasmExports.emscripten_atomic_store_u32)(t,e),_emscripten_atomic_store_f32=Module._emscripten_atomic_store_f32=(t,e)=>(_emscripten_atomic_store_f32=Module._emscripten_atomic_store_f32=wasmExports.emscripten_atomic_store_f32)(t,e),_emscripten_atomic_store_u64=Module._emscripten_atomic_store_u64=(t,e)=>(_emscripten_atomic_store_u64=Module._emscripten_atomic_store_u64=wasmExports.emscripten_atomic_store_u64)(t,e),_emscripten_atomic_store_f64=Module._emscripten_atomic_store_f64=(t,e)=>(_emscripten_atomic_store_f64=Module._emscripten_atomic_store_f64=wasmExports.emscripten_atomic_store_f64)(t,e),_emscripten_atomic_fence=Module._emscripten_atomic_fence=()=>(_emscripten_atomic_fence=Module._emscripten_atomic_fence=wasmExports.emscripten_atomic_fence)(),_emscripten_atomic_or_u8=Module._emscripten_atomic_or_u8=(t,e)=>(_emscripten_atomic_or_u8=Module._emscripten_atomic_or_u8=wasmExports.emscripten_atomic_or_u8)(t,e),_emscripten_atomic_add_u8=Module._emscripten_atomic_add_u8=(t,e)=>(_emscripten_atomic_add_u8=Module._emscripten_atomic_add_u8=wasmExports.emscripten_atomic_add_u8)(t,e),_emscripten_atomic_add_u16=Module._emscripten_atomic_add_u16=(t,e)=>(_emscripten_atomic_add_u16=Module._emscripten_atomic_add_u16=wasmExports.emscripten_atomic_add_u16)(t,e),_emscripten_atomic_add_u32=Module._emscripten_atomic_add_u32=(t,e)=>(_emscripten_atomic_add_u32=Module._emscripten_atomic_add_u32=wasmExports.emscripten_atomic_add_u32)(t,e),_emscripten_atomic_add_u64=Module._emscripten_atomic_add_u64=(t,e)=>(_emscripten_atomic_add_u64=Module._emscripten_atomic_add_u64=wasmExports.emscripten_atomic_add_u64)(t,e),_emscripten_atomic_sub_u8=Module._emscripten_atomic_sub_u8=(t,e)=>(_emscripten_atomic_sub_u8=Module._emscripten_atomic_sub_u8=wasmExports.emscripten_atomic_sub_u8)(t,e),_emscripten_atomic_sub_u16=Module._emscripten_atomic_sub_u16=(t,e)=>(_emscripten_atomic_sub_u16=Module._emscripten_atomic_sub_u16=wasmExports.emscripten_atomic_sub_u16)(t,e),_emscripten_atomic_sub_u32=Module._emscripten_atomic_sub_u32=(t,e)=>(_emscripten_atomic_sub_u32=Module._emscripten_atomic_sub_u32=wasmExports.emscripten_atomic_sub_u32)(t,e),_emscripten_atomic_sub_u64=Module._emscripten_atomic_sub_u64=(t,e)=>(_emscripten_atomic_sub_u64=Module._emscripten_atomic_sub_u64=wasmExports.emscripten_atomic_sub_u64)(t,e),_emscripten_atomic_and_u8=Module._emscripten_atomic_and_u8=(t,e)=>(_emscripten_atomic_and_u8=Module._emscripten_atomic_and_u8=wasmExports.emscripten_atomic_and_u8)(t,e),_emscripten_atomic_and_u16=Module._emscripten_atomic_and_u16=(t,e)=>(_emscripten_atomic_and_u16=Module._emscripten_atomic_and_u16=wasmExports.emscripten_atomic_and_u16)(t,e),_emscripten_atomic_and_u32=Module._emscripten_atomic_and_u32=(t,e)=>(_emscripten_atomic_and_u32=Module._emscripten_atomic_and_u32=wasmExports.emscripten_atomic_and_u32)(t,e),_emscripten_atomic_and_u64=Module._emscripten_atomic_and_u64=(t,e)=>(_emscripten_atomic_and_u64=Module._emscripten_atomic_and_u64=wasmExports.emscripten_atomic_and_u64)(t,e),_emscripten_atomic_or_u16=Module._emscripten_atomic_or_u16=(t,e)=>(_emscripten_atomic_or_u16=Module._emscripten_atomic_or_u16=wasmExports.emscripten_atomic_or_u16)(t,e),_emscripten_atomic_or_u32=Module._emscripten_atomic_or_u32=(t,e)=>(_emscripten_atomic_or_u32=Module._emscripten_atomic_or_u32=wasmExports.emscripten_atomic_or_u32)(t,e),_emscripten_atomic_or_u64=Module._emscripten_atomic_or_u64=(t,e)=>(_emscripten_atomic_or_u64=Module._emscripten_atomic_or_u64=wasmExports.emscripten_atomic_or_u64)(t,e),_emscripten_atomic_xor_u8=Module._emscripten_atomic_xor_u8=(t,e)=>(_emscripten_atomic_xor_u8=Module._emscripten_atomic_xor_u8=wasmExports.emscripten_atomic_xor_u8)(t,e),_emscripten_atomic_xor_u16=Module._emscripten_atomic_xor_u16=(t,e)=>(_emscripten_atomic_xor_u16=Module._emscripten_atomic_xor_u16=wasmExports.emscripten_atomic_xor_u16)(t,e),_emscripten_atomic_xor_u32=Module._emscripten_atomic_xor_u32=(t,e)=>(_emscripten_atomic_xor_u32=Module._emscripten_atomic_xor_u32=wasmExports.emscripten_atomic_xor_u32)(t,e),_emscripten_atomic_xor_u64=Module._emscripten_atomic_xor_u64=(t,e)=>(_emscripten_atomic_xor_u64=Module._emscripten_atomic_xor_u64=wasmExports.emscripten_atomic_xor_u64)(t,e),_emscripten_console_logf=Module._emscripten_console_logf=(t,e)=>(_emscripten_console_logf=Module._emscripten_console_logf=wasmExports.emscripten_console_logf)(t,e),_emscripten_console_errorf=Module._emscripten_console_errorf=(t,e)=>(_emscripten_console_errorf=Module._emscripten_console_errorf=wasmExports.emscripten_console_errorf)(t,e),_emscripten_console_warnf=Module._emscripten_console_warnf=(t,e)=>(_emscripten_console_warnf=Module._emscripten_console_warnf=wasmExports.emscripten_console_warnf)(t,e),_emscripten_outf=Module._emscripten_outf=(t,e)=>(_emscripten_outf=Module._emscripten_outf=wasmExports.emscripten_outf)(t,e),_emscripten_errf=Module._emscripten_errf=(t,e)=>(_emscripten_errf=Module._emscripten_errf=wasmExports.emscripten_errf)(t,e),_emscripten_fiber_init=Module._emscripten_fiber_init=(t,e,n,_,r,a,o)=>(_emscripten_fiber_init=Module._emscripten_fiber_init=wasmExports.emscripten_fiber_init)(t,e,n,_,r,a,o),_emscripten_fiber_init_from_current_context=Module._emscripten_fiber_init_from_current_context=(t,e,n)=>(_emscripten_fiber_init_from_current_context=Module._emscripten_fiber_init_from_current_context=wasmExports.emscripten_fiber_init_from_current_context)(t,e,n),_emscripten_stack_get_base=Module._emscripten_stack_get_base=()=>(_emscripten_stack_get_base=Module._emscripten_stack_get_base=wasmExports.emscripten_stack_get_base)(),_emscripten_stack_get_end=Module._emscripten_stack_get_end=()=>(_emscripten_stack_get_end=Module._emscripten_stack_get_end=wasmExports.emscripten_stack_get_end)(),_emscripten_get_heap_size=Module._emscripten_get_heap_size=()=>(_emscripten_get_heap_size=Module._emscripten_get_heap_size=wasmExports.emscripten_get_heap_size)(),_emscripten_builtin_memcpy=Module._emscripten_builtin_memcpy=(t,e,n)=>(_emscripten_builtin_memcpy=Module._emscripten_builtin_memcpy=wasmExports.emscripten_builtin_memcpy)(t,e,n),___memset=Module.___memset=(t,e,n)=>(___memset=Module.___memset=wasmExports.__memset)(t,e,n),_emscripten_builtin_memset=Module._emscripten_builtin_memset=(t,e,n)=>(_emscripten_builtin_memset=Module._emscripten_builtin_memset=wasmExports.emscripten_builtin_memset)(t,e,n),___syscall_munmap=Module.___syscall_munmap=(t,e)=>(___syscall_munmap=Module.___syscall_munmap=wasmExports.__syscall_munmap)(t,e),_emscripten_builtin_free=Module._emscripten_builtin_free=t=>(_emscripten_builtin_free=Module._emscripten_builtin_free=wasmExports.emscripten_builtin_free)(t),___syscall_msync=Module.___syscall_msync=(t,e,n)=>(___syscall_msync=Module.___syscall_msync=wasmExports.__syscall_msync)(t,e,n),___syscall_mmap2=Module.___syscall_mmap2=(t,e,n,_,r,a)=>(___syscall_mmap2=Module.___syscall_mmap2=wasmExports.__syscall_mmap2)(t,e,n,_,r,a),_emscripten_builtin_memalign=(t,e)=>(_emscripten_builtin_memalign=wasmExports.emscripten_builtin_memalign)(t,e),_emscripten_scan_stack=Module._emscripten_scan_stack=t=>(_emscripten_scan_stack=Module._emscripten_scan_stack=wasmExports.emscripten_scan_stack)(t),_emscripten_stack_get_current=Module._emscripten_stack_get_current=()=>(_emscripten_stack_get_current=Module._emscripten_stack_get_current=wasmExports.emscripten_stack_get_current)(),___clock=Module.___clock=()=>(___clock=Module.___clock=wasmExports.__clock)(),___time=Module.___time=t=>(___time=Module.___time=wasmExports.__time)(t),___clock_getres=Module.___clock_getres=(t,e)=>(___clock_getres=Module.___clock_getres=wasmExports.__clock_getres)(t,e),___gettimeofday=Module.___gettimeofday=(t,e)=>(___gettimeofday=Module.___gettimeofday=wasmExports.__gettimeofday)(t,e),_dysize=Module._dysize=t=>(_dysize=Module._dysize=wasmExports.dysize)(t),_setkey=Module._setkey=t=>(_setkey=Module._setkey=wasmExports.setkey)(t),_encrypt=Module._encrypt=(t,e)=>(_encrypt=Module._encrypt=wasmExports.encrypt)(t,e),_sethostent=Module._sethostent=t=>(_sethostent=Module._sethostent=wasmExports.sethostent)(t),_gethostent=Module._gethostent=()=>(_gethostent=Module._gethostent=wasmExports.gethostent)(),_getnetent=Module._getnetent=()=>(_getnetent=Module._getnetent=wasmExports.getnetent)(),_endhostent=Module._endhostent=()=>(_endhostent=Module._endhostent=wasmExports.endhostent)(),_setnetent=Module._setnetent=t=>(_setnetent=Module._setnetent=wasmExports.setnetent)(t),_endnetent=Module._endnetent=()=>(_endnetent=Module._endnetent=wasmExports.endnetent)(),_erff=Module._erff=t=>(_erff=Module._erff=wasmExports.erff)(t),_erfcf=Module._erfcf=t=>(_erfcf=Module._erfcf=wasmExports.erfcf)(t),_erfl=Module._erfl=(t,e,n)=>(_erfl=Module._erfl=wasmExports.erfl)(t,e,n),_erfcl=Module._erfcl=(t,e,n)=>(_erfcl=Module._erfcl=wasmExports.erfcl)(t,e,n),_vwarn=Module._vwarn=(t,e)=>(_vwarn=Module._vwarn=wasmExports.vwarn)(t,e),_fprintf=Module._fprintf=(t,e,n)=>(_fprintf=Module._fprintf=wasmExports.fprintf)(t,e,n),_vwarnx=Module._vwarnx=(t,e)=>(_vwarnx=Module._vwarnx=wasmExports.vwarnx)(t,e),_putc=Module._putc=(t,e)=>(_putc=Module._putc=wasmExports.putc)(t,e),_verr=Module._verr=(t,e,n)=>(_verr=Module._verr=wasmExports.verr)(t,e,n),_verrx=Module._verrx=(t,e,n)=>(_verrx=Module._verrx=wasmExports.verrx)(t,e,n),_warn=Module._warn=(t,e)=>(_warn=Module._warn=wasmExports.warn)(t,e),_warnx=Module._warnx=(t,e)=>(_warnx=Module._warnx=wasmExports.warnx)(t,e),_err=Module._err=(t,e,n)=>(_err=Module._err=wasmExports.err)(t,e,n),_errx=Module._errx=(t,e,n)=>(_errx=Module._errx=wasmExports.errx)(t,e,n),_ether_aton_r=Module._ether_aton_r=(t,e)=>(_ether_aton_r=Module._ether_aton_r=wasmExports.ether_aton_r)(t,e),_ether_aton=Module._ether_aton=t=>(_ether_aton=Module._ether_aton=wasmExports.ether_aton)(t),_ether_ntoa_r=Module._ether_ntoa_r=(t,e)=>(_ether_ntoa_r=Module._ether_ntoa_r=wasmExports.ether_ntoa_r)(t,e),_ether_ntoa=Module._ether_ntoa=t=>(_ether_ntoa=Module._ether_ntoa=wasmExports.ether_ntoa)(t),_ether_line=Module._ether_line=(t,e,n)=>(_ether_line=Module._ether_line=wasmExports.ether_line)(t,e,n),_ether_ntohost=Module._ether_ntohost=(t,e)=>(_ether_ntohost=Module._ether_ntohost=wasmExports.ether_ntohost)(t,e),_ether_hostton=Module._ether_hostton=(t,e)=>(_ether_hostton=Module._ether_hostton=wasmExports.ether_hostton)(t,e),_execl=Module._execl=(t,e,n)=>(_execl=Module._execl=wasmExports.execl)(t,e,n),_execle=Module._execle=(t,e,n)=>(_execle=Module._execle=wasmExports.execle)(t,e,n),_execlp=Module._execlp=(t,e,n)=>(_execlp=Module._execlp=wasmExports.execlp)(t,e,n),_execvp=Module._execvp=(t,e)=>(_execvp=Module._execvp=wasmExports.execvp)(t,e),_execvpe=Module._execvpe=(t,e,n)=>(_execvpe=Module._execvpe=wasmExports.execvpe)(t,e,n),_exp10=Module._exp10=t=>(_exp10=Module._exp10=wasmExports.exp10)(t),_pow10=Module._pow10=t=>(_pow10=Module._pow10=wasmExports.pow10)(t),_exp10f=Module._exp10f=t=>(_exp10f=Module._exp10f=wasmExports.exp10f)(t),_modff=Module._modff=(t,e)=>(_modff=Module._modff=wasmExports.modff)(t,e),_exp2f=Module._exp2f=t=>(_exp2f=Module._exp2f=wasmExports.exp2f)(t),_pow10f=Module._pow10f=t=>(_pow10f=Module._pow10f=wasmExports.pow10f)(t),_exp10l=Module._exp10l=(t,e,n)=>(_exp10l=Module._exp10l=wasmExports.exp10l)(t,e,n),_modfl=Module._modfl=(t,e,n,_)=>(_modfl=Module._modfl=wasmExports.modfl)(t,e,n,_),_exp2l=Module._exp2l=(t,e,n)=>(_exp2l=Module._exp2l=wasmExports.exp2l)(t,e,n),_powl=Module._powl=(t,e,n,_,r)=>(_powl=Module._powl=wasmExports.powl)(t,e,n,_,r),_pow10l=Module._pow10l=(t,e,n)=>(_pow10l=Module._pow10l=wasmExports.pow10l)(t,e,n),___letf2=Module.___letf2=(t,e,n,_)=>(___letf2=Module.___letf2=wasmExports.__letf2)(t,e,n,_),_scalbnl=Module._scalbnl=(t,e,n,_)=>(_scalbnl=Module._scalbnl=wasmExports.scalbnl)(t,e,n,_),_expl=Module._expl=(t,e,n)=>(_expl=Module._expl=wasmExports.expl)(t,e,n),_expm1l=Module._expm1l=(t,e,n)=>(_expm1l=Module._expm1l=wasmExports.expm1l)(t,e,n),__flushlbf=Module.__flushlbf=()=>(__flushlbf=Module.__flushlbf=wasmExports._flushlbf)(),___fsetlocking=Module.___fsetlocking=(t,e)=>(___fsetlocking=Module.___fsetlocking=wasmExports.__fsetlocking)(t,e),___fwriting=Module.___fwriting=t=>(___fwriting=Module.___fwriting=wasmExports.__fwriting)(t),___freading=Module.___freading=t=>(___freading=Module.___freading=wasmExports.__freading)(t),___freadable=Module.___freadable=t=>(___freadable=Module.___freadable=wasmExports.__freadable)(t),___fwritable=Module.___fwritable=t=>(___fwritable=Module.___fwritable=wasmExports.__fwritable)(t),___flbf=Module.___flbf=t=>(___flbf=Module.___flbf=wasmExports.__flbf)(t),___fbufsize=Module.___fbufsize=t=>(___fbufsize=Module.___fbufsize=wasmExports.__fbufsize)(t),___fpending=Module.___fpending=t=>(___fpending=Module.___fpending=wasmExports.__fpending)(t),___fpurge=Module.___fpurge=t=>(___fpurge=Module.___fpurge=wasmExports.__fpurge)(t),_fpurge=Module._fpurge=t=>(_fpurge=Module._fpurge=wasmExports.fpurge)(t),___freadahead=Module.___freadahead=t=>(___freadahead=Module.___freadahead=wasmExports.__freadahead)(t),___freadptr=Module.___freadptr=(t,e)=>(___freadptr=Module.___freadptr=wasmExports.__freadptr)(t,e),___freadptrinc=Module.___freadptrinc=(t,e)=>(___freadptrinc=Module.___freadptrinc=wasmExports.__freadptrinc)(t,e),___fseterr=Module.___fseterr=t=>(___fseterr=Module.___fseterr=wasmExports.__fseterr)(t),_faccessat=Module._faccessat=(t,e,n,_)=>(_faccessat=Module._faccessat=wasmExports.faccessat)(t,e,n,_),_fcvt=Module._fcvt=(t,e,n,_)=>(_fcvt=Module._fcvt=wasmExports.fcvt)(t,e,n,_),_fdim=Module._fdim=(t,e)=>(_fdim=Module._fdim=wasmExports.fdim)(t,e),_fdimf=Module._fdimf=(t,e)=>(_fdimf=Module._fdimf=wasmExports.fdimf)(t,e),_fdiml=Module._fdiml=(t,e,n,_,r)=>(_fdiml=Module._fdiml=wasmExports.fdiml)(t,e,n,_,r),_fegetexceptflag=Module._fegetexceptflag=(t,e)=>(_fegetexceptflag=Module._fegetexceptflag=wasmExports.fegetexceptflag)(t,e),_fetestexcept=Module._fetestexcept=t=>(_fetestexcept=Module._fetestexcept=wasmExports.fetestexcept)(t),_feholdexcept=Module._feholdexcept=t=>(_feholdexcept=Module._feholdexcept=wasmExports.feholdexcept)(t),_fegetenv=Module._fegetenv=t=>(_fegetenv=Module._fegetenv=wasmExports.fegetenv)(t),_feclearexcept=Module._feclearexcept=t=>(_feclearexcept=Module._feclearexcept=wasmExports.feclearexcept)(t),_feraiseexcept=Module._feraiseexcept=t=>(_feraiseexcept=Module._feraiseexcept=wasmExports.feraiseexcept)(t),___fesetround=Module.___fesetround=t=>(___fesetround=Module.___fesetround=wasmExports.__fesetround)(t),_fesetenv=Module._fesetenv=t=>(_fesetenv=Module._fesetenv=wasmExports.fesetenv)(t),_feof_unlocked=Module._feof_unlocked=t=>(_feof_unlocked=Module._feof_unlocked=wasmExports.feof_unlocked)(t),__IO_feof_unlocked=Module.__IO_feof_unlocked=t=>(__IO_feof_unlocked=Module.__IO_feof_unlocked=wasmExports._IO_feof_unlocked)(t),_ferror_unlocked=Module._ferror_unlocked=t=>(_ferror_unlocked=Module._ferror_unlocked=wasmExports.ferror_unlocked)(t),__IO_ferror_unlocked=Module.__IO_ferror_unlocked=t=>(__IO_ferror_unlocked=Module.__IO_ferror_unlocked=wasmExports._IO_ferror_unlocked)(t),_fesetexceptflag=Module._fesetexceptflag=(t,e)=>(_fesetexceptflag=Module._fesetexceptflag=wasmExports.fesetexceptflag)(t,e),_fesetround=Module._fesetround=t=>(_fesetround=Module._fesetround=wasmExports.fesetround)(t),_feupdateenv=Module._feupdateenv=t=>(_feupdateenv=Module._feupdateenv=wasmExports.feupdateenv)(t),_fflush_unlocked=Module._fflush_unlocked=t=>(_fflush_unlocked=Module._fflush_unlocked=wasmExports.fflush_unlocked)(t),_ffs=Module._ffs=t=>(_ffs=Module._ffs=wasmExports.ffs)(t),_ffsl=Module._ffsl=t=>(_ffsl=Module._ffsl=wasmExports.ffsl)(t),_ffsll=Module._ffsll=t=>(_ffsll=Module._ffsll=wasmExports.ffsll)(t),_emscripten_futex_wake=Module._emscripten_futex_wake=(t,e)=>(_emscripten_futex_wake=Module._emscripten_futex_wake=wasmExports.emscripten_futex_wake)(t,e),_fgetln=Module._fgetln=(t,e)=>(_fgetln=Module._fgetln=wasmExports.fgetln)(t,e),_getline=Module._getline=(t,e,n)=>(_getline=Module._getline=wasmExports.getline)(t,e,n),_fgetpos=Module._fgetpos=(t,e)=>(_fgetpos=Module._fgetpos=wasmExports.fgetpos)(t,e),_fgets_unlocked=Module._fgets_unlocked=(t,e,n)=>(_fgets_unlocked=Module._fgets_unlocked=wasmExports.fgets_unlocked)(t,e,n),___fgetwc_unlocked=Module.___fgetwc_unlocked=t=>(___fgetwc_unlocked=Module.___fgetwc_unlocked=wasmExports.__fgetwc_unlocked)(t),_fwide=Module._fwide=(t,e)=>(_fwide=Module._fwide=wasmExports.fwide)(t,e),_mbtowc=Module._mbtowc=(t,e,n)=>(_mbtowc=Module._mbtowc=wasmExports.mbtowc)(t,e,n),_fgetwc=Module._fgetwc=t=>(_fgetwc=Module._fgetwc=wasmExports.fgetwc)(t),_fgetwc_unlocked=Module._fgetwc_unlocked=t=>(_fgetwc_unlocked=Module._fgetwc_unlocked=wasmExports.fgetwc_unlocked)(t),_getwc_unlocked=Module._getwc_unlocked=t=>(_getwc_unlocked=Module._getwc_unlocked=wasmExports.getwc_unlocked)(t),_fgetws=Module._fgetws=(t,e,n)=>(_fgetws=Module._fgetws=wasmExports.fgetws)(t,e,n),_fgetws_unlocked=Module._fgetws_unlocked=(t,e,n)=>(_fgetws_unlocked=Module._fgetws_unlocked=wasmExports.fgetws_unlocked)(t,e,n),_fileno_unlocked=Module._fileno_unlocked=t=>(_fileno_unlocked=Module._fileno_unlocked=wasmExports.fileno_unlocked)(t),_finite=Module._finite=t=>(_finite=Module._finite=wasmExports.finite)(t),_finitef=Module._finitef=t=>(_finitef=Module._finitef=wasmExports.finitef)(t),___floatunsitf=Module.___floatunsitf=(t,e)=>(___floatunsitf=Module.___floatunsitf=wasmExports.__floatunsitf)(t,e),_fmodl=Module._fmodl=(t,e,n,_,r)=>(_fmodl=Module._fmodl=wasmExports.fmodl)(t,e,n,_,r),_ftrylockfile=Module._ftrylockfile=t=>(_ftrylockfile=Module._ftrylockfile=wasmExports.ftrylockfile)(t),_floorf=Module._floorf=t=>(_floorf=Module._floorf=wasmExports.floorf)(t),_floorl=Module._floorl=(t,e,n)=>(_floorl=Module._floorl=wasmExports.floorl)(t,e,n),_fma=Module._fma=(t,e,n)=>(_fma=Module._fma=wasmExports.fma)(t,e,n),_fmaf=Module._fmaf=(t,e,n)=>(_fmaf=Module._fmaf=wasmExports.fmaf)(t,e,n),_fmal=Module._fmal=(t,e,n,_,r,a,o)=>(_fmal=Module._fmal=wasmExports.fmal)(t,e,n,_,r,a,o),_frexpl=Module._frexpl=(t,e,n,_)=>(_frexpl=Module._frexpl=wasmExports.frexpl)(t,e,n,_),_nextafterl=Module._nextafterl=(t,e,n,_,r)=>(_nextafterl=Module._nextafterl=wasmExports.nextafterl)(t,e,n,_,r),_ilogbl=Module._ilogbl=(t,e)=>(_ilogbl=Module._ilogbl=wasmExports.ilogbl)(t,e),_fmax=Module._fmax=(t,e)=>(_fmax=Module._fmax=wasmExports.fmax)(t,e),_fmaxf=Module._fmaxf=(t,e)=>(_fmaxf=Module._fmaxf=wasmExports.fmaxf)(t,e),_fmaxl=Module._fmaxl=(t,e,n,_,r)=>(_fmaxl=Module._fmaxl=wasmExports.fmaxl)(t,e,n,_,r),_fmemopen=Module._fmemopen=(t,e,n)=>(_fmemopen=Module._fmemopen=wasmExports.fmemopen)(t,e,n),_fmin=Module._fmin=(t,e)=>(_fmin=Module._fmin=wasmExports.fmin)(t,e),_fminf=Module._fminf=(t,e)=>(_fminf=Module._fminf=wasmExports.fminf)(t,e),_fminl=Module._fminl=(t,e,n,_,r)=>(_fminl=Module._fminl=wasmExports.fminl)(t,e,n,_,r),_fmodf=Module._fmodf=(t,e)=>(_fmodf=Module._fmodf=wasmExports.fmodf)(t,e),_fmtmsg=Module._fmtmsg=(t,e,n,_,r,a)=>(_fmtmsg=Module._fmtmsg=wasmExports.fmtmsg)(t,e,n,_,r,a),_fnmatch=Module._fnmatch=(t,e,n)=>(_fnmatch=Module._fnmatch=wasmExports.fnmatch)(t,e,n),_towupper=Module._towupper=t=>(_towupper=Module._towupper=wasmExports.towupper)(t),_towlower=Module._towlower=t=>(_towlower=Module._towlower=wasmExports.towlower)(t),_wctype=Module._wctype=t=>(_wctype=Module._wctype=wasmExports.wctype)(t),_iswctype=Module._iswctype=(t,e)=>(_iswctype=Module._iswctype=wasmExports.iswctype)(t,e),_fopencookie=Module._fopencookie=(t,e,n)=>(_fopencookie=Module._fopencookie=wasmExports.fopencookie)(t,e,n),_forkpty=Module._forkpty=(t,e,n,_)=>(_forkpty=Module._forkpty=wasmExports.forkpty)(t,e,n,_),_openpty=Module._openpty=(t,e,n,_,r)=>(_openpty=Module._openpty=wasmExports.openpty)(t,e,n,_,r),_pipe2=Module._pipe2=(t,e)=>(_pipe2=Module._pipe2=wasmExports.pipe2)(t,e),_vfiprintf=Module._vfiprintf=(t,e,n)=>(_vfiprintf=Module._vfiprintf=wasmExports.vfiprintf)(t,e,n),___small_vfprintf=Module.___small_vfprintf=(t,e,n)=>(___small_vfprintf=Module.___small_vfprintf=wasmExports.__small_vfprintf)(t,e,n),_fputs_unlocked=Module._fputs_unlocked=(t,e)=>(_fputs_unlocked=Module._fputs_unlocked=wasmExports.fputs_unlocked)(t,e),___fputwc_unlocked=Module.___fputwc_unlocked=(t,e)=>(___fputwc_unlocked=Module.___fputwc_unlocked=wasmExports.__fputwc_unlocked)(t,e),_wctomb=Module._wctomb=(t,e)=>(_wctomb=Module._wctomb=wasmExports.wctomb)(t,e),_fputwc=Module._fputwc=(t,e)=>(_fputwc=Module._fputwc=wasmExports.fputwc)(t,e),_fputwc_unlocked=Module._fputwc_unlocked=(t,e)=>(_fputwc_unlocked=Module._fputwc_unlocked=wasmExports.fputwc_unlocked)(t,e),_putwc_unlocked=Module._putwc_unlocked=(t,e)=>(_putwc_unlocked=Module._putwc_unlocked=wasmExports.putwc_unlocked)(t,e),_fputws=Module._fputws=(t,e)=>(_fputws=Module._fputws=wasmExports.fputws)(t,e),_wcsrtombs=Module._wcsrtombs=(t,e,n,_)=>(_wcsrtombs=Module._wcsrtombs=wasmExports.wcsrtombs)(t,e,n,_),_fputws_unlocked=Module._fputws_unlocked=(t,e)=>(_fputws_unlocked=Module._fputws_unlocked=wasmExports.fputws_unlocked)(t,e),_fread_unlocked=Module._fread_unlocked=(t,e,n,_)=>(_fread_unlocked=Module._fread_unlocked=wasmExports.fread_unlocked)(t,e,n,_),_freelocale=Module._freelocale=t=>(_freelocale=Module._freelocale=wasmExports.freelocale)(t),___freelocale=Module.___freelocale=t=>(___freelocale=Module.___freelocale=wasmExports.__freelocale)(t),_freopen=Module._freopen=(t,e,n)=>(_freopen=Module._freopen=wasmExports.freopen)(t,e,n),_frexpf=Module._frexpf=(t,e)=>(_frexpf=Module._frexpf=wasmExports.frexpf)(t,e),_fscanf=Module._fscanf=(t,e,n)=>(_fscanf=Module._fscanf=wasmExports.fscanf)(t,e,n),_vfscanf=Module._vfscanf=(t,e,n)=>(_vfscanf=Module._vfscanf=wasmExports.vfscanf)(t,e,n),___isoc99_fscanf=Module.___isoc99_fscanf=(t,e,n)=>(___isoc99_fscanf=Module.___isoc99_fscanf=wasmExports.__isoc99_fscanf)(t,e,n),_fseek=Module._fseek=(t,e,n)=>(_fseek=Module._fseek=wasmExports.fseek)(t,e,n),_fseeko=Module._fseeko=(t,e,n)=>(_fseeko=Module._fseeko=wasmExports.fseeko)(t,e,n),_fsetpos=Module._fsetpos=(t,e)=>(_fsetpos=Module._fsetpos=wasmExports.fsetpos)(t,e),_ftello=Module._ftello=t=>(_ftello=Module._ftello=wasmExports.ftello)(t),_ftime=Module._ftime=t=>(_ftime=Module._ftime=wasmExports.ftime)(t),_utimensat=Module._utimensat=(t,e,n,_)=>(_utimensat=Module._utimensat=wasmExports.utimensat)(t,e,n,_),_fwprintf=Module._fwprintf=(t,e,n)=>(_fwprintf=Module._fwprintf=wasmExports.fwprintf)(t,e,n),_vfwprintf=Module._vfwprintf=(t,e,n)=>(_vfwprintf=Module._vfwprintf=wasmExports.vfwprintf)(t,e,n),_fwrite_unlocked=Module._fwrite_unlocked=(t,e,n,_)=>(_fwrite_unlocked=Module._fwrite_unlocked=wasmExports.fwrite_unlocked)(t,e,n,_),_fwscanf=Module._fwscanf=(t,e,n)=>(_fwscanf=Module._fwscanf=wasmExports.fwscanf)(t,e,n),_vfwscanf=Module._vfwscanf=(t,e,n)=>(_vfwscanf=Module._vfwscanf=wasmExports.vfwscanf)(t,e,n),___isoc99_fwscanf=Module.___isoc99_fwscanf=(t,e,n)=>(___isoc99_fwscanf=Module.___isoc99_fwscanf=wasmExports.__isoc99_fwscanf)(t,e,n),_gcvt=Module._gcvt=(t,e,n)=>(_gcvt=Module._gcvt=wasmExports.gcvt)(t,e,n),_get_current_dir_name=Module._get_current_dir_name=()=>(_get_current_dir_name=Module._get_current_dir_name=wasmExports.get_current_dir_name)(),_strdup=Module._strdup=t=>(_strdup=Module._strdup=wasmExports.strdup)(t),__IO_getc=Module.__IO_getc=t=>(__IO_getc=Module.__IO_getc=wasmExports._IO_getc)(t),_fgetc_unlocked=Module._fgetc_unlocked=t=>(_fgetc_unlocked=Module._fgetc_unlocked=wasmExports.fgetc_unlocked)(t),__IO_getc_unlocked=Module.__IO_getc_unlocked=t=>(__IO_getc_unlocked=Module.__IO_getc_unlocked=wasmExports._IO_getc_unlocked)(t),_getchar=Module._getchar=()=>(_getchar=Module._getchar=wasmExports.getchar)(),_getchar_unlocked=Module._getchar_unlocked=()=>(_getchar_unlocked=Module._getchar_unlocked=wasmExports.getchar_unlocked)(),_getdelim=Module._getdelim=(t,e,n,_)=>(_getdelim=Module._getdelim=wasmExports.getdelim)(t,e,n,_),___getdelim=Module.___getdelim=(t,e,n,_)=>(___getdelim=Module.___getdelim=wasmExports.__getdelim)(t,e,n,_),_getdents=Module._getdents=(t,e,n)=>(_getdents=Module._getdents=wasmExports.getdents)(t,e,n),_getdomainname=Module._getdomainname=(t,e)=>(_getdomainname=Module._getdomainname=wasmExports.getdomainname)(t,e),_getegid=Module._getegid=()=>(_getegid=Module._getegid=wasmExports.getegid)(),_geteuid=Module._geteuid=()=>(_geteuid=Module._geteuid=wasmExports.geteuid)(),_getgroups=Module._getgroups=(t,e)=>(_getgroups=Module._getgroups=wasmExports.getgroups)(t,e),_gethostid=Module._gethostid=()=>(_gethostid=Module._gethostid=wasmExports.gethostid)(),_freeifaddrs=Module._freeifaddrs=t=>(_freeifaddrs=Module._freeifaddrs=wasmExports.freeifaddrs)(t),_getifaddrs=Module._getifaddrs=t=>(_getifaddrs=Module._getifaddrs=wasmExports.getifaddrs)(t),___getitimer=Module.___getitimer=(t,e,n)=>(___getitimer=Module.___getitimer=wasmExports.__getitimer)(t,e,n),_getlogin_r=Module._getlogin_r=(t,e)=>(_getlogin_r=Module._getlogin_r=wasmExports.getlogin_r)(t,e),_getopt=Module._getopt=(t,e,n)=>(_getopt=Module._getopt=wasmExports.getopt)(t,e,n),___posix_getopt=Module.___posix_getopt=(t,e,n)=>(___posix_getopt=Module.___posix_getopt=wasmExports.__posix_getopt)(t,e,n),_getopt_long=Module._getopt_long=(t,e,n,_,r)=>(_getopt_long=Module._getopt_long=wasmExports.getopt_long)(t,e,n,_,r),_getopt_long_only=Module._getopt_long_only=(t,e,n,_,r)=>(_getopt_long_only=Module._getopt_long_only=wasmExports.getopt_long_only)(t,e,n,_,r),_mblen=Module._mblen=(t,e)=>(_mblen=Module._mblen=wasmExports.mblen)(t,e),_getpagesize=Module._getpagesize=()=>(_getpagesize=Module._getpagesize=wasmExports.getpagesize)(),_getresgid=Module._getresgid=(t,e,n)=>(_getresgid=Module._getresgid=wasmExports.getresgid)(t,e,n),_getresuid=Module._getresuid=(t,e,n)=>(_getresuid=Module._getresuid=wasmExports.getresuid)(t,e,n),_getrusage=Module._getrusage=(t,e)=>(_getrusage=Module._getrusage=wasmExports.getrusage)(t,e),_gets=Module._gets=t=>(_gets=Module._gets=wasmExports.gets)(t),_getservbyname_r=Module._getservbyname_r=(t,e,n,_,r,a)=>(_getservbyname_r=Module._getservbyname_r=wasmExports.getservbyname_r)(t,e,n,_,r,a),_getservbyport_r=Module._getservbyport_r=(t,e,n,_,r,a)=>(_getservbyport_r=Module._getservbyport_r=wasmExports.getservbyport_r)(t,e,n,_,r,a),_getsubopt=Module._getsubopt=(t,e,n)=>(_getsubopt=Module._getsubopt=wasmExports.getsubopt)(t,e,n),_gettid=Module._gettid=()=>(_gettid=Module._gettid=wasmExports.gettid)(),_getw=Module._getw=t=>(_getw=Module._getw=wasmExports.getw)(t),_getwc=Module._getwc=t=>(_getwc=Module._getwc=wasmExports.getwc)(t),_getwchar=Module._getwchar=()=>(_getwchar=Module._getwchar=wasmExports.getwchar)(),_getwchar_unlocked=Module._getwchar_unlocked=()=>(_getwchar_unlocked=Module._getwchar_unlocked=wasmExports.getwchar_unlocked)(),_glob=Module._glob=(t,e,n,_)=>(_glob=Module._glob=wasmExports.glob)(t,e,n,_),_globfree=Module._globfree=t=>(_globfree=Module._globfree=wasmExports.globfree)(t),_gmtime=Module._gmtime=t=>(_gmtime=Module._gmtime=wasmExports.gmtime)(t),_herror=Module._herror=t=>(_herror=Module._herror=wasmExports.herror)(t),_hcreate=Module._hcreate=t=>(_hcreate=Module._hcreate=wasmExports.hcreate)(t),_hdestroy=Module._hdestroy=()=>(_hdestroy=Module._hdestroy=wasmExports.hdestroy)(),_hsearch=Module._hsearch=(t,e)=>(_hsearch=Module._hsearch=wasmExports.hsearch)(t,e),_hcreate_r=Module._hcreate_r=(t,e)=>(_hcreate_r=Module._hcreate_r=wasmExports.hcreate_r)(t,e),_hdestroy_r=Module._hdestroy_r=t=>(_hdestroy_r=Module._hdestroy_r=wasmExports.hdestroy_r)(t),_hsearch_r=Module._hsearch_r=(t,e,n,_)=>(_hsearch_r=Module._hsearch_r=wasmExports.hsearch_r)(t,e,n,_),_iconv_open=Module._iconv_open=(t,e)=>(_iconv_open=Module._iconv_open=wasmExports.iconv_open)(t,e),_iconv=Module._iconv=(t,e,n,_,r)=>(_iconv=Module._iconv=wasmExports.iconv)(t,e,n,_,r),_iconv_close=Module._iconv_close=t=>(_iconv_close=Module._iconv_close=wasmExports.iconv_close)(t),_ioctl=Module._ioctl=(t,e,n)=>(_ioctl=Module._ioctl=wasmExports.ioctl)(t,e,n),_ilogb=Module._ilogb=t=>(_ilogb=Module._ilogb=wasmExports.ilogb)(t),_ilogbf=Module._ilogbf=t=>(_ilogbf=Module._ilogbf=wasmExports.ilogbf)(t),_imaxabs=Module._imaxabs=t=>(_imaxabs=Module._imaxabs=wasmExports.imaxabs)(t),_imaxdiv=Module._imaxdiv=(t,e,n)=>(_imaxdiv=Module._imaxdiv=wasmExports.imaxdiv)(t,e,n),_index=Module._index=(t,e)=>(_index=Module._index=wasmExports.index)(t,e),_inet_addr=Module._inet_addr=t=>(_inet_addr=Module._inet_addr=wasmExports.inet_addr)(t),_inet_network=Module._inet_network=t=>(_inet_network=Module._inet_network=wasmExports.inet_network)(t),_inet_makeaddr=Module._inet_makeaddr=(t,e)=>(_inet_makeaddr=Module._inet_makeaddr=wasmExports.inet_makeaddr)(t,e),_inet_lnaof=Module._inet_lnaof=t=>(_inet_lnaof=Module._inet_lnaof=wasmExports.inet_lnaof)(t),_inet_netof=Module._inet_netof=t=>(_inet_netof=Module._inet_netof=wasmExports.inet_netof)(t),_insque=Module._insque=(t,e)=>(_insque=Module._insque=wasmExports.insque)(t,e),_remque=Module._remque=t=>(_remque=Module._remque=wasmExports.remque)(t),___intscan=Module.___intscan=(t,e,n,_)=>(___intscan=Module.___intscan=wasmExports.__intscan)(t,e,n,_),___multi3=Module.___multi3=(t,e,n,_,r)=>(___multi3=Module.___multi3=wasmExports.__multi3)(t,e,n,_,r),___isalnum_l=Module.___isalnum_l=(t,e)=>(___isalnum_l=Module.___isalnum_l=wasmExports.__isalnum_l)(t,e),_isalnum_l=Module._isalnum_l=(t,e)=>(_isalnum_l=Module._isalnum_l=wasmExports.isalnum_l)(t,e),___isalpha_l=Module.___isalpha_l=(t,e)=>(___isalpha_l=Module.___isalpha_l=wasmExports.__isalpha_l)(t,e),_isalpha_l=Module._isalpha_l=(t,e)=>(_isalpha_l=Module._isalpha_l=wasmExports.isalpha_l)(t,e),_isascii=Module._isascii=t=>(_isascii=Module._isascii=wasmExports.isascii)(t),_isblank=Module._isblank=t=>(_isblank=Module._isblank=wasmExports.isblank)(t),___isblank_l=Module.___isblank_l=(t,e)=>(___isblank_l=Module.___isblank_l=wasmExports.__isblank_l)(t,e),_isblank_l=Module._isblank_l=(t,e)=>(_isblank_l=Module._isblank_l=wasmExports.isblank_l)(t,e),_iscntrl=Module._iscntrl=t=>(_iscntrl=Module._iscntrl=wasmExports.iscntrl)(t),___iscntrl_l=Module.___iscntrl_l=(t,e)=>(___iscntrl_l=Module.___iscntrl_l=wasmExports.__iscntrl_l)(t,e),_iscntrl_l=Module._iscntrl_l=(t,e)=>(_iscntrl_l=Module._iscntrl_l=wasmExports.iscntrl_l)(t,e),___isdigit_l=Module.___isdigit_l=(t,e)=>(___isdigit_l=Module.___isdigit_l=wasmExports.__isdigit_l)(t,e),_isdigit_l=Module._isdigit_l=(t,e)=>(_isdigit_l=Module._isdigit_l=wasmExports.isdigit_l)(t,e),_isgraph=Module._isgraph=t=>(_isgraph=Module._isgraph=wasmExports.isgraph)(t),___isgraph_l=Module.___isgraph_l=(t,e)=>(___isgraph_l=Module.___isgraph_l=wasmExports.__isgraph_l)(t,e),_isgraph_l=Module._isgraph_l=(t,e)=>(_isgraph_l=Module._isgraph_l=wasmExports.isgraph_l)(t,e),_islower=Module._islower=t=>(_islower=Module._islower=wasmExports.islower)(t),___islower_l=Module.___islower_l=(t,e)=>(___islower_l=Module.___islower_l=wasmExports.__islower_l)(t,e),_islower_l=Module._islower_l=(t,e)=>(_islower_l=Module._islower_l=wasmExports.islower_l)(t,e),_isprint=Module._isprint=t=>(_isprint=Module._isprint=wasmExports.isprint)(t),___isprint_l=Module.___isprint_l=(t,e)=>(___isprint_l=Module.___isprint_l=wasmExports.__isprint_l)(t,e),_isprint_l=Module._isprint_l=(t,e)=>(_isprint_l=Module._isprint_l=wasmExports.isprint_l)(t,e),_ispunct=Module._ispunct=t=>(_ispunct=Module._ispunct=wasmExports.ispunct)(t),___ispunct_l=Module.___ispunct_l=(t,e)=>(___ispunct_l=Module.___ispunct_l=wasmExports.__ispunct_l)(t,e),_ispunct_l=Module._ispunct_l=(t,e)=>(_ispunct_l=Module._ispunct_l=wasmExports.ispunct_l)(t,e),_issetugid=Module._issetugid=()=>(_issetugid=Module._issetugid=wasmExports.issetugid)(),___isspace_l=Module.___isspace_l=(t,e)=>(___isspace_l=Module.___isspace_l=wasmExports.__isspace_l)(t,e),_isspace_l=Module._isspace_l=(t,e)=>(_isspace_l=Module._isspace_l=wasmExports.isspace_l)(t,e),___isupper_l=Module.___isupper_l=(t,e)=>(___isupper_l=Module.___isupper_l=wasmExports.__isupper_l)(t,e),_isupper_l=Module._isupper_l=(t,e)=>(_isupper_l=Module._isupper_l=wasmExports.isupper_l)(t,e),_iswalnum=Module._iswalnum=t=>(_iswalnum=Module._iswalnum=wasmExports.iswalnum)(t),_iswdigit=Module._iswdigit=t=>(_iswdigit=Module._iswdigit=wasmExports.iswdigit)(t),_iswalpha=Module._iswalpha=t=>(_iswalpha=Module._iswalpha=wasmExports.iswalpha)(t),___iswalnum_l=Module.___iswalnum_l=(t,e)=>(___iswalnum_l=Module.___iswalnum_l=wasmExports.__iswalnum_l)(t,e),_iswalnum_l=Module._iswalnum_l=(t,e)=>(_iswalnum_l=Module._iswalnum_l=wasmExports.iswalnum_l)(t,e),___iswalpha_l=Module.___iswalpha_l=(t,e)=>(___iswalpha_l=Module.___iswalpha_l=wasmExports.__iswalpha_l)(t,e),_iswalpha_l=Module._iswalpha_l=(t,e)=>(_iswalpha_l=Module._iswalpha_l=wasmExports.iswalpha_l)(t,e),_iswblank=Module._iswblank=t=>(_iswblank=Module._iswblank=wasmExports.iswblank)(t),___iswblank_l=Module.___iswblank_l=(t,e)=>(___iswblank_l=Module.___iswblank_l=wasmExports.__iswblank_l)(t,e),_iswblank_l=Module._iswblank_l=(t,e)=>(_iswblank_l=Module._iswblank_l=wasmExports.iswblank_l)(t,e),_iswcntrl=Module._iswcntrl=t=>(_iswcntrl=Module._iswcntrl=wasmExports.iswcntrl)(t),___iswcntrl_l=Module.___iswcntrl_l=(t,e)=>(___iswcntrl_l=Module.___iswcntrl_l=wasmExports.__iswcntrl_l)(t,e),_iswcntrl_l=Module._iswcntrl_l=(t,e)=>(_iswcntrl_l=Module._iswcntrl_l=wasmExports.iswcntrl_l)(t,e),_iswgraph=Module._iswgraph=t=>(_iswgraph=Module._iswgraph=wasmExports.iswgraph)(t),_iswlower=Module._iswlower=t=>(_iswlower=Module._iswlower=wasmExports.iswlower)(t),_iswprint=Module._iswprint=t=>(_iswprint=Module._iswprint=wasmExports.iswprint)(t),_iswpunct=Module._iswpunct=t=>(_iswpunct=Module._iswpunct=wasmExports.iswpunct)(t),_iswspace=Module._iswspace=t=>(_iswspace=Module._iswspace=wasmExports.iswspace)(t),_iswupper=Module._iswupper=t=>(_iswupper=Module._iswupper=wasmExports.iswupper)(t),_iswxdigit=Module._iswxdigit=t=>(_iswxdigit=Module._iswxdigit=wasmExports.iswxdigit)(t),___iswctype_l=Module.___iswctype_l=(t,e,n)=>(___iswctype_l=Module.___iswctype_l=wasmExports.__iswctype_l)(t,e,n),___wctype_l=Module.___wctype_l=(t,e)=>(___wctype_l=Module.___wctype_l=wasmExports.__wctype_l)(t,e),_iswctype_l=Module._iswctype_l=(t,e,n)=>(_iswctype_l=Module._iswctype_l=wasmExports.iswctype_l)(t,e,n),_wctype_l=Module._wctype_l=(t,e)=>(_wctype_l=Module._wctype_l=wasmExports.wctype_l)(t,e),___iswdigit_l=Module.___iswdigit_l=(t,e)=>(___iswdigit_l=Module.___iswdigit_l=wasmExports.__iswdigit_l)(t,e),_iswdigit_l=Module._iswdigit_l=(t,e)=>(_iswdigit_l=Module._iswdigit_l=wasmExports.iswdigit_l)(t,e),___iswgraph_l=Module.___iswgraph_l=(t,e)=>(___iswgraph_l=Module.___iswgraph_l=wasmExports.__iswgraph_l)(t,e),_iswgraph_l=Module._iswgraph_l=(t,e)=>(_iswgraph_l=Module._iswgraph_l=wasmExports.iswgraph_l)(t,e),___iswlower_l=Module.___iswlower_l=(t,e)=>(___iswlower_l=Module.___iswlower_l=wasmExports.__iswlower_l)(t,e),_iswlower_l=Module._iswlower_l=(t,e)=>(_iswlower_l=Module._iswlower_l=wasmExports.iswlower_l)(t,e),___iswprint_l=Module.___iswprint_l=(t,e)=>(___iswprint_l=Module.___iswprint_l=wasmExports.__iswprint_l)(t,e),_iswprint_l=Module._iswprint_l=(t,e)=>(_iswprint_l=Module._iswprint_l=wasmExports.iswprint_l)(t,e),___iswpunct_l=Module.___iswpunct_l=(t,e)=>(___iswpunct_l=Module.___iswpunct_l=wasmExports.__iswpunct_l)(t,e),_iswpunct_l=Module._iswpunct_l=(t,e)=>(_iswpunct_l=Module._iswpunct_l=wasmExports.iswpunct_l)(t,e),___iswspace_l=Module.___iswspace_l=(t,e)=>(___iswspace_l=Module.___iswspace_l=wasmExports.__iswspace_l)(t,e),_iswspace_l=Module._iswspace_l=(t,e)=>(_iswspace_l=Module._iswspace_l=wasmExports.iswspace_l)(t,e),___iswupper_l=Module.___iswupper_l=(t,e)=>(___iswupper_l=Module.___iswupper_l=wasmExports.__iswupper_l)(t,e),_iswupper_l=Module._iswupper_l=(t,e)=>(_iswupper_l=Module._iswupper_l=wasmExports.iswupper_l)(t,e),___iswxdigit_l=Module.___iswxdigit_l=(t,e)=>(___iswxdigit_l=Module.___iswxdigit_l=wasmExports.__iswxdigit_l)(t,e),_iswxdigit_l=Module._iswxdigit_l=(t,e)=>(_iswxdigit_l=Module._iswxdigit_l=wasmExports.iswxdigit_l)(t,e),___isxdigit_l=Module.___isxdigit_l=(t,e)=>(___isxdigit_l=Module.___isxdigit_l=wasmExports.__isxdigit_l)(t,e),_isxdigit_l=Module._isxdigit_l=(t,e)=>(_isxdigit_l=Module._isxdigit_l=wasmExports.isxdigit_l)(t,e),_j0=Module._j0=t=>(_j0=Module._j0=wasmExports.j0)(t),_y0=Module._y0=t=>(_y0=Module._y0=wasmExports.y0)(t),_j0f=Module._j0f=t=>(_j0f=Module._j0f=wasmExports.j0f)(t),_y0f=Module._y0f=t=>(_y0f=Module._y0f=wasmExports.y0f)(t),_j1=Module._j1=t=>(_j1=Module._j1=wasmExports.j1)(t),_y1=Module._y1=t=>(_y1=Module._y1=wasmExports.y1)(t),_j1f=Module._j1f=t=>(_j1f=Module._j1f=wasmExports.j1f)(t),_y1f=Module._y1f=t=>(_y1f=Module._y1f=wasmExports.y1f)(t),_jn=Module._jn=(t,e)=>(_jn=Module._jn=wasmExports.jn)(t,e),_yn=Module._yn=(t,e)=>(_yn=Module._yn=wasmExports.yn)(t,e),_jnf=Module._jnf=(t,e)=>(_jnf=Module._jnf=wasmExports.jnf)(t,e),_ynf=Module._ynf=(t,e)=>(_ynf=Module._ynf=wasmExports.ynf)(t,e),_labs=Module._labs=t=>(_labs=Module._labs=wasmExports.labs)(t),___nl_langinfo=Module.___nl_langinfo=t=>(___nl_langinfo=Module.___nl_langinfo=wasmExports.__nl_langinfo)(t),_nl_langinfo_l=Module._nl_langinfo_l=(t,e)=>(_nl_langinfo_l=Module._nl_langinfo_l=wasmExports.nl_langinfo_l)(t,e),_lchmod=Module._lchmod=(t,e)=>(_lchmod=Module._lchmod=wasmExports.lchmod)(t,e),_lchown=Module._lchown=(t,e,n)=>(_lchown=Module._lchown=wasmExports.lchown)(t,e,n),_lcong48=Module._lcong48=t=>(_lcong48=Module._lcong48=wasmExports.lcong48)(t),_ldexpf=Module._ldexpf=(t,e)=>(_ldexpf=Module._ldexpf=wasmExports.ldexpf)(t,e),_scalbnf=Module._scalbnf=(t,e)=>(_scalbnf=Module._scalbnf=wasmExports.scalbnf)(t,e),_ldexpl=Module._ldexpl=(t,e,n,_)=>(_ldexpl=Module._ldexpl=wasmExports.ldexpl)(t,e,n,_),_ldiv=Module._ldiv=(t,e,n)=>(_ldiv=Module._ldiv=wasmExports.ldiv)(t,e,n),_get_nprocs_conf=Module._get_nprocs_conf=()=>(_get_nprocs_conf=Module._get_nprocs_conf=wasmExports.get_nprocs_conf)(),_get_nprocs=Module._get_nprocs=()=>(_get_nprocs=Module._get_nprocs=wasmExports.get_nprocs)(),_get_phys_pages=Module._get_phys_pages=()=>(_get_phys_pages=Module._get_phys_pages=wasmExports.get_phys_pages)(),_get_avphys_pages=Module._get_avphys_pages=()=>(_get_avphys_pages=Module._get_avphys_pages=wasmExports.get_avphys_pages)(),_lgamma=Module._lgamma=t=>(_lgamma=Module._lgamma=wasmExports.lgamma)(t),_lgamma_r=Module._lgamma_r=(t,e)=>(_lgamma_r=Module._lgamma_r=wasmExports.lgamma_r)(t,e),_lgammaf=Module._lgammaf=t=>(_lgammaf=Module._lgammaf=wasmExports.lgammaf)(t),_lgammaf_r=Module._lgammaf_r=(t,e)=>(_lgammaf_r=Module._lgammaf_r=wasmExports.lgammaf_r)(t,e),___lgammal_r=Module.___lgammal_r=(t,e,n,_)=>(___lgammal_r=Module.___lgammal_r=wasmExports.__lgammal_r)(t,e,n,_),_lgammal=Module._lgammal=(t,e,n)=>(_lgammal=Module._lgammal=wasmExports.lgammal)(t,e,n),_lgammal_r=Module._lgammal_r=(t,e,n,_)=>(_lgammal_r=Module._lgammal_r=wasmExports.lgammal_r)(t,e,n,_),_emscripten_has_threading_support=Module._emscripten_has_threading_support=()=>(_emscripten_has_threading_support=Module._emscripten_has_threading_support=wasmExports.emscripten_has_threading_support)(),_emscripten_num_logical_cores=Module._emscripten_num_logical_cores=()=>(_emscripten_num_logical_cores=Module._emscripten_num_logical_cores=wasmExports.emscripten_num_logical_cores)(),_emscripten_force_num_logical_cores=Module._emscripten_force_num_logical_cores=t=>(_emscripten_force_num_logical_cores=Module._emscripten_force_num_logical_cores=wasmExports.emscripten_force_num_logical_cores)(t),_emscripten_futex_wait=Module._emscripten_futex_wait=(t,e,n)=>(_emscripten_futex_wait=Module._emscripten_futex_wait=wasmExports.emscripten_futex_wait)(t,e,n),_emscripten_is_main_runtime_thread=Module._emscripten_is_main_runtime_thread=()=>(_emscripten_is_main_runtime_thread=Module._emscripten_is_main_runtime_thread=wasmExports.emscripten_is_main_runtime_thread)(),_emscripten_main_thread_process_queued_calls=Module._emscripten_main_thread_process_queued_calls=()=>(_emscripten_main_thread_process_queued_calls=Module._emscripten_main_thread_process_queued_calls=wasmExports.emscripten_main_thread_process_queued_calls)(),_emscripten_current_thread_process_queued_calls=Module._emscripten_current_thread_process_queued_calls=()=>(_emscripten_current_thread_process_queued_calls=Module._emscripten_current_thread_process_queued_calls=wasmExports.emscripten_current_thread_process_queued_calls)(),__emscripten_yield=Module.__emscripten_yield=t=>(__emscripten_yield=Module.__emscripten_yield=wasmExports._emscripten_yield)(t),__emscripten_check_timers=Module.__emscripten_check_timers=t=>(__emscripten_check_timers=Module.__emscripten_check_timers=wasmExports._emscripten_check_timers)(t),_pthread_mutex_consistent=Module._pthread_mutex_consistent=t=>(_pthread_mutex_consistent=Module._pthread_mutex_consistent=wasmExports.pthread_mutex_consistent)(t),_pthread_barrier_init=Module._pthread_barrier_init=(t,e,n)=>(_pthread_barrier_init=Module._pthread_barrier_init=wasmExports.pthread_barrier_init)(t,e,n),_pthread_barrier_destroy=Module._pthread_barrier_destroy=t=>(_pthread_barrier_destroy=Module._pthread_barrier_destroy=wasmExports.pthread_barrier_destroy)(t),_pthread_barrier_wait=Module._pthread_barrier_wait=t=>(_pthread_barrier_wait=Module._pthread_barrier_wait=wasmExports.pthread_barrier_wait)(t),_pthread_cond_broadcast=Module._pthread_cond_broadcast=t=>(_pthread_cond_broadcast=Module._pthread_cond_broadcast=wasmExports.pthread_cond_broadcast)(t),_pthread_atfork=Module._pthread_atfork=(t,e,n)=>(_pthread_atfork=Module._pthread_atfork=wasmExports.pthread_atfork)(t,e,n),_pthread_cancel=Module._pthread_cancel=t=>(_pthread_cancel=Module._pthread_cancel=wasmExports.pthread_cancel)(t),_pthread_testcancel=Module._pthread_testcancel=()=>(_pthread_testcancel=Module._pthread_testcancel=wasmExports.pthread_testcancel)(),___pthread_detach=Module.___pthread_detach=t=>(___pthread_detach=Module.___pthread_detach=wasmExports.__pthread_detach)(t),_pthread_equal=Module._pthread_equal=(t,e)=>(_pthread_equal=Module._pthread_equal=wasmExports.pthread_equal)(t,e),_pthread_mutexattr_init=Module._pthread_mutexattr_init=t=>(_pthread_mutexattr_init=Module._pthread_mutexattr_init=wasmExports.pthread_mutexattr_init)(t),_pthread_mutexattr_setprotocol=Module._pthread_mutexattr_setprotocol=(t,e)=>(_pthread_mutexattr_setprotocol=Module._pthread_mutexattr_setprotocol=wasmExports.pthread_mutexattr_setprotocol)(t,e),_pthread_mutexattr_settype=Module._pthread_mutexattr_settype=(t,e)=>(_pthread_mutexattr_settype=Module._pthread_mutexattr_settype=wasmExports.pthread_mutexattr_settype)(t,e),_pthread_mutexattr_destroy=Module._pthread_mutexattr_destroy=t=>(_pthread_mutexattr_destroy=Module._pthread_mutexattr_destroy=wasmExports.pthread_mutexattr_destroy)(t),_pthread_mutexattr_setpshared=Module._pthread_mutexattr_setpshared=(t,e)=>(_pthread_mutexattr_setpshared=Module._pthread_mutexattr_setpshared=wasmExports.pthread_mutexattr_setpshared)(t,e),_pthread_condattr_destroy=Module._pthread_condattr_destroy=t=>(_pthread_condattr_destroy=Module._pthread_condattr_destroy=wasmExports.pthread_condattr_destroy)(t),_pthread_condattr_setpshared=Module._pthread_condattr_setpshared=(t,e)=>(_pthread_condattr_setpshared=Module._pthread_condattr_setpshared=wasmExports.pthread_condattr_setpshared)(t,e),_pthread_getattr_np=Module._pthread_getattr_np=(t,e)=>(_pthread_getattr_np=Module._pthread_getattr_np=wasmExports.pthread_getattr_np)(t,e),_pthread_setcanceltype=Module._pthread_setcanceltype=(t,e)=>(_pthread_setcanceltype=Module._pthread_setcanceltype=wasmExports.pthread_setcanceltype)(t,e),_pthread_rwlock_init=Module._pthread_rwlock_init=(t,e)=>(_pthread_rwlock_init=Module._pthread_rwlock_init=wasmExports.pthread_rwlock_init)(t,e),_pthread_rwlock_destroy=Module._pthread_rwlock_destroy=t=>(_pthread_rwlock_destroy=Module._pthread_rwlock_destroy=wasmExports.pthread_rwlock_destroy)(t),_pthread_rwlock_rdlock=Module._pthread_rwlock_rdlock=t=>(_pthread_rwlock_rdlock=Module._pthread_rwlock_rdlock=wasmExports.pthread_rwlock_rdlock)(t),_pthread_rwlock_tryrdlock=Module._pthread_rwlock_tryrdlock=t=>(_pthread_rwlock_tryrdlock=Module._pthread_rwlock_tryrdlock=wasmExports.pthread_rwlock_tryrdlock)(t),_pthread_rwlock_timedrdlock=Module._pthread_rwlock_timedrdlock=(t,e)=>(_pthread_rwlock_timedrdlock=Module._pthread_rwlock_timedrdlock=wasmExports.pthread_rwlock_timedrdlock)(t,e),_pthread_rwlock_wrlock=Module._pthread_rwlock_wrlock=t=>(_pthread_rwlock_wrlock=Module._pthread_rwlock_wrlock=wasmExports.pthread_rwlock_wrlock)(t),_pthread_rwlock_trywrlock=Module._pthread_rwlock_trywrlock=t=>(_pthread_rwlock_trywrlock=Module._pthread_rwlock_trywrlock=wasmExports.pthread_rwlock_trywrlock)(t),_pthread_rwlock_timedwrlock=Module._pthread_rwlock_timedwrlock=(t,e)=>(_pthread_rwlock_timedwrlock=Module._pthread_rwlock_timedwrlock=wasmExports.pthread_rwlock_timedwrlock)(t,e),_pthread_rwlock_unlock=Module._pthread_rwlock_unlock=t=>(_pthread_rwlock_unlock=Module._pthread_rwlock_unlock=wasmExports.pthread_rwlock_unlock)(t),_pthread_rwlockattr_init=Module._pthread_rwlockattr_init=t=>(_pthread_rwlockattr_init=Module._pthread_rwlockattr_init=wasmExports.pthread_rwlockattr_init)(t),_pthread_rwlockattr_destroy=Module._pthread_rwlockattr_destroy=t=>(_pthread_rwlockattr_destroy=Module._pthread_rwlockattr_destroy=wasmExports.pthread_rwlockattr_destroy)(t),_pthread_rwlockattr_setpshared=Module._pthread_rwlockattr_setpshared=(t,e)=>(_pthread_rwlockattr_setpshared=Module._pthread_rwlockattr_setpshared=wasmExports.pthread_rwlockattr_setpshared)(t,e),_pthread_spin_init=Module._pthread_spin_init=(t,e)=>(_pthread_spin_init=Module._pthread_spin_init=wasmExports.pthread_spin_init)(t,e),_pthread_spin_destroy=Module._pthread_spin_destroy=t=>(_pthread_spin_destroy=Module._pthread_spin_destroy=wasmExports.pthread_spin_destroy)(t),_pthread_spin_lock=Module._pthread_spin_lock=t=>(_pthread_spin_lock=Module._pthread_spin_lock=wasmExports.pthread_spin_lock)(t),_pthread_spin_trylock=Module._pthread_spin_trylock=t=>(_pthread_spin_trylock=Module._pthread_spin_trylock=wasmExports.pthread_spin_trylock)(t),_pthread_spin_unlock=Module._pthread_spin_unlock=t=>(_pthread_spin_unlock=Module._pthread_spin_unlock=wasmExports.pthread_spin_unlock)(t),_sem_init=Module._sem_init=(t,e,n)=>(_sem_init=Module._sem_init=wasmExports.sem_init)(t,e,n),_sem_post=Module._sem_post=t=>(_sem_post=Module._sem_post=wasmExports.sem_post)(t),_sem_wait=Module._sem_wait=t=>(_sem_wait=Module._sem_wait=wasmExports.sem_wait)(t),_sem_trywait=Module._sem_trywait=t=>(_sem_trywait=Module._sem_trywait=wasmExports.sem_trywait)(t),_sem_destroy=Module._sem_destroy=t=>(_sem_destroy=Module._sem_destroy=wasmExports.sem_destroy)(t),_pthread_mutex_timedlock=Module._pthread_mutex_timedlock=(t,e)=>(_pthread_mutex_timedlock=Module._pthread_mutex_timedlock=wasmExports.pthread_mutex_timedlock)(t,e),_emscripten_builtin_pthread_create=Module._emscripten_builtin_pthread_create=(t,e,n,_)=>(_emscripten_builtin_pthread_create=Module._emscripten_builtin_pthread_create=wasmExports.emscripten_builtin_pthread_create)(t,e,n,_),_emscripten_builtin_pthread_join=Module._emscripten_builtin_pthread_join=(t,e)=>(_emscripten_builtin_pthread_join=Module._emscripten_builtin_pthread_join=wasmExports.emscripten_builtin_pthread_join)(t,e),_pthread_join=Module._pthread_join=(t,e)=>(_pthread_join=Module._pthread_join=wasmExports.pthread_join)(t,e),_pthread_once=Module._pthread_once=(t,e)=>(_pthread_once=Module._pthread_once=wasmExports.pthread_once)(t,e),_emscripten_builtin_pthread_detach=Module._emscripten_builtin_pthread_detach=t=>(_emscripten_builtin_pthread_detach=Module._emscripten_builtin_pthread_detach=wasmExports.emscripten_builtin_pthread_detach)(t),_thrd_detach=Module._thrd_detach=t=>(_thrd_detach=Module._thrd_detach=wasmExports.thrd_detach)(t),_link=Module._link=(t,e)=>(_link=Module._link=wasmExports.link)(t,e),_linkat=Module._linkat=(t,e,n,_,r)=>(_linkat=Module._linkat=wasmExports.linkat)(t,e,n,_,r),_llabs=Module._llabs=t=>(_llabs=Module._llabs=wasmExports.llabs)(t),_lldiv=Module._lldiv=(t,e,n)=>(_lldiv=Module._lldiv=wasmExports.lldiv)(t,e,n),_llrint=Module._llrint=t=>(_llrint=Module._llrint=wasmExports.llrint)(t),_rint=Module._rint=t=>(_rint=Module._rint=wasmExports.rint)(t),_llrintf=Module._llrintf=t=>(_llrintf=Module._llrintf=wasmExports.llrintf)(t),_rintf=Module._rintf=t=>(_rintf=Module._rintf=wasmExports.rintf)(t),_llrintl=Module._llrintl=(t,e)=>(_llrintl=Module._llrintl=wasmExports.llrintl)(t,e),_rintl=Module._rintl=(t,e,n)=>(_rintl=Module._rintl=wasmExports.rintl)(t,e,n),_llround=Module._llround=t=>(_llround=Module._llround=wasmExports.llround)(t),_llroundf=Module._llroundf=t=>(_llroundf=Module._llroundf=wasmExports.llroundf)(t),_roundf=Module._roundf=t=>(_roundf=Module._roundf=wasmExports.roundf)(t),_llroundl=Module._llroundl=(t,e)=>(_llroundl=Module._llroundl=wasmExports.llroundl)(t,e),_roundl=Module._roundl=(t,e,n)=>(_roundl=Module._roundl=wasmExports.roundl)(t,e,n),_log10f=Module._log10f=t=>(_log10f=Module._log10f=wasmExports.log10f)(t),_log10l=Module._log10l=(t,e,n)=>(_log10l=Module._log10l=wasmExports.log10l)(t,e,n),_log2f=Module._log2f=t=>(_log2f=Module._log2f=wasmExports.log2f)(t),_log2l=Module._log2l=(t,e,n)=>(_log2l=Module._log2l=wasmExports.log2l)(t,e,n),_logb=Module._logb=t=>(_logb=Module._logb=wasmExports.logb)(t),_logbf=Module._logbf=t=>(_logbf=Module._logbf=wasmExports.logbf)(t),_logbl=Module._logbl=(t,e,n)=>(_logbl=Module._logbl=wasmExports.logbl)(t,e,n),_strtoull=Module._strtoull=(t,e,n)=>(_strtoull=Module._strtoull=wasmExports.strtoull)(t,e,n),_nrand48=Module._nrand48=t=>(_nrand48=Module._nrand48=wasmExports.nrand48)(t),_lrand48=Module._lrand48=()=>(_lrand48=Module._lrand48=wasmExports.lrand48)(),_lrint=Module._lrint=t=>(_lrint=Module._lrint=wasmExports.lrint)(t),_lrintf=Module._lrintf=t=>(_lrintf=Module._lrintf=wasmExports.lrintf)(t),_lrintl=Module._lrintl=(t,e)=>(_lrintl=Module._lrintl=wasmExports.lrintl)(t,e),_lround=Module._lround=t=>(_lround=Module._lround=wasmExports.lround)(t),_lroundf=Module._lroundf=t=>(_lroundf=Module._lroundf=wasmExports.lroundf)(t),_lroundl=Module._lroundl=(t,e)=>(_lroundl=Module._lroundl=wasmExports.lroundl)(t,e),_lsearch=Module._lsearch=(t,e,n,_,r)=>(_lsearch=Module._lsearch=wasmExports.lsearch)(t,e,n,_,r),_lfind=Module._lfind=(t,e,n,_,r)=>(_lfind=Module._lfind=wasmExports.lfind)(t,e,n,_,r),_mbrlen=Module._mbrlen=(t,e,n)=>(_mbrlen=Module._mbrlen=wasmExports.mbrlen)(t,e,n),_mbrtoc16=Module._mbrtoc16=(t,e,n,_)=>(_mbrtoc16=Module._mbrtoc16=wasmExports.mbrtoc16)(t,e,n,_),_mbrtoc32=Module._mbrtoc32=(t,e,n,_)=>(_mbrtoc32=Module._mbrtoc32=wasmExports.mbrtoc32)(t,e,n,_),_mbsinit=Module._mbsinit=t=>(_mbsinit=Module._mbsinit=wasmExports.mbsinit)(t),_mbsnrtowcs=Module._mbsnrtowcs=(t,e,n,_,r)=>(_mbsnrtowcs=Module._mbsnrtowcs=wasmExports.mbsnrtowcs)(t,e,n,_,r),_mbsrtowcs=Module._mbsrtowcs=(t,e,n,_)=>(_mbsrtowcs=Module._mbsrtowcs=wasmExports.mbsrtowcs)(t,e,n,_),_memccpy=Module._memccpy=(t,e,n,_)=>(_memccpy=Module._memccpy=wasmExports.memccpy)(t,e,n,_),_memmem=Module._memmem=(t,e,n,_)=>(_memmem=Module._memmem=wasmExports.memmem)(t,e,n,_),_mempcpy=Module._mempcpy=(t,e,n)=>(_mempcpy=Module._mempcpy=wasmExports.mempcpy)(t,e,n),_mincore=Module._mincore=(t,e,n)=>(_mincore=Module._mincore=wasmExports.mincore)(t,e,n),_mkdtemp=Module._mkdtemp=t=>(_mkdtemp=Module._mkdtemp=wasmExports.mkdtemp)(t),_mkfifo=Module._mkfifo=(t,e)=>(_mkfifo=Module._mkfifo=wasmExports.mkfifo)(t,e),_mkfifoat=Module._mkfifoat=(t,e,n)=>(_mkfifoat=Module._mkfifoat=wasmExports.mkfifoat)(t,e,n),_mkostemp=Module._mkostemp=(t,e)=>(_mkostemp=Module._mkostemp=wasmExports.mkostemp)(t,e),_mkostemps=Module._mkostemps=(t,e,n)=>(_mkostemps=Module._mkostemps=wasmExports.mkostemps)(t,e,n),_mkstemp=Module._mkstemp=t=>(_mkstemp=Module._mkstemp=wasmExports.mkstemp)(t),_mkstemps=Module._mkstemps=(t,e)=>(_mkstemps=Module._mkstemps=wasmExports.mkstemps)(t,e),_mktemp=Module._mktemp=t=>(_mktemp=Module._mktemp=wasmExports.mktemp)(t),_timegm=Module._timegm=t=>(_timegm=Module._timegm=wasmExports.timegm)(t),_tzset=Module._tzset=()=>(_tzset=Module._tzset=wasmExports.tzset)(),_mlock=Module._mlock=(t,e)=>(_mlock=Module._mlock=wasmExports.mlock)(t,e),_mlockall=Module._mlockall=t=>(_mlockall=Module._mlockall=wasmExports.mlockall)(t),_emscripten_builtin_mmap=Module._emscripten_builtin_mmap=(t,e,n,_,r,a)=>(_emscripten_builtin_mmap=Module._emscripten_builtin_mmap=wasmExports.emscripten_builtin_mmap)(t,e,n,_,r,a),_setmntent=Module._setmntent=(t,e)=>(_setmntent=Module._setmntent=wasmExports.setmntent)(t,e),_endmntent=Module._endmntent=t=>(_endmntent=Module._endmntent=wasmExports.endmntent)(t),_getmntent_r=Module._getmntent_r=(t,e,n,_)=>(_getmntent_r=Module._getmntent_r=wasmExports.getmntent_r)(t,e,n,_),_sscanf=Module._sscanf=(t,e,n)=>(_sscanf=Module._sscanf=wasmExports.sscanf)(t,e,n),_getmntent=Module._getmntent=t=>(_getmntent=Module._getmntent=wasmExports.getmntent)(t),_addmntent=Module._addmntent=(t,e)=>(_addmntent=Module._addmntent=wasmExports.addmntent)(t,e),_hasmntopt=Module._hasmntopt=(t,e)=>(_hasmntopt=Module._hasmntopt=wasmExports.hasmntopt)(t,e),_mprotect=Module._mprotect=(t,e,n)=>(_mprotect=Module._mprotect=wasmExports.mprotect)(t,e,n),_jrand48=Module._jrand48=t=>(_jrand48=Module._jrand48=wasmExports.jrand48)(t),_mrand48=Module._mrand48=()=>(_mrand48=Module._mrand48=wasmExports.mrand48)(),_mtx_destroy=Module._mtx_destroy=t=>(_mtx_destroy=Module._mtx_destroy=wasmExports.mtx_destroy)(t),_mtx_init=Module._mtx_init=(t,e)=>(_mtx_init=Module._mtx_init=wasmExports.mtx_init)(t,e),_mtx_lock=Module._mtx_lock=t=>(_mtx_lock=Module._mtx_lock=wasmExports.mtx_lock)(t),_mtx_timedlock=Module._mtx_timedlock=(t,e)=>(_mtx_timedlock=Module._mtx_timedlock=wasmExports.mtx_timedlock)(t,e),_mtx_trylock=Module._mtx_trylock=t=>(_mtx_trylock=Module._mtx_trylock=wasmExports.mtx_trylock)(t),_mtx_unlock=Module._mtx_unlock=t=>(_mtx_unlock=Module._mtx_unlock=wasmExports.mtx_unlock)(t),_munlock=Module._munlock=(t,e)=>(_munlock=Module._munlock=wasmExports.munlock)(t,e),_munlockall=Module._munlockall=()=>(_munlockall=Module._munlockall=wasmExports.munlockall)(),_emscripten_builtin_munmap=Module._emscripten_builtin_munmap=(t,e)=>(_emscripten_builtin_munmap=Module._emscripten_builtin_munmap=wasmExports.emscripten_builtin_munmap)(t,e),_nan=Module._nan=t=>(_nan=Module._nan=wasmExports.nan)(t),_nanf=Module._nanf=t=>(_nanf=Module._nanf=wasmExports.nanf)(t),_nanl=Module._nanl=(t,e)=>(_nanl=Module._nanl=wasmExports.nanl)(t,e),_nanosleep=Module._nanosleep=(t,e)=>(_nanosleep=Module._nanosleep=wasmExports.nanosleep)(t,e),_nearbyint=Module._nearbyint=t=>(_nearbyint=Module._nearbyint=wasmExports.nearbyint)(t),_nearbyintf=Module._nearbyintf=t=>(_nearbyintf=Module._nearbyintf=wasmExports.nearbyintf)(t),_nearbyintl=Module._nearbyintl=(t,e,n)=>(_nearbyintl=Module._nearbyintl=wasmExports.nearbyintl)(t,e,n),_getnetbyaddr=Module._getnetbyaddr=(t,e)=>(_getnetbyaddr=Module._getnetbyaddr=wasmExports.getnetbyaddr)(t,e),_getnetbyname=Module._getnetbyname=t=>(_getnetbyname=Module._getnetbyname=wasmExports.getnetbyname)(t),___newlocale=Module.___newlocale=(t,e,n)=>(___newlocale=Module.___newlocale=wasmExports.__newlocale)(t,e,n),_newlocale=Module._newlocale=(t,e,n)=>(_newlocale=Module._newlocale=wasmExports.newlocale)(t,e,n),_nextafterf=Module._nextafterf=(t,e)=>(_nextafterf=Module._nextafterf=wasmExports.nextafterf)(t,e),_nexttoward=Module._nexttoward=(t,e,n)=>(_nexttoward=Module._nexttoward=wasmExports.nexttoward)(t,e,n),_nexttowardf=Module._nexttowardf=(t,e,n)=>(_nexttowardf=Module._nexttowardf=wasmExports.nexttowardf)(t,e,n),_nexttowardl=Module._nexttowardl=(t,e,n,_,r)=>(_nexttowardl=Module._nexttowardl=wasmExports.nexttowardl)(t,e,n,_,r),_nftw=Module._nftw=(t,e,n,_)=>(_nftw=Module._nftw=wasmExports.nftw)(t,e,n,_),_nice=Module._nice=t=>(_nice=Module._nice=wasmExports.nice)(t),_setpriority=Module._setpriority=(t,e,n)=>(_setpriority=Module._setpriority=wasmExports.setpriority)(t,e,n),_ns_get16=Module._ns_get16=t=>(_ns_get16=Module._ns_get16=wasmExports.ns_get16)(t),_ns_get32=Module._ns_get32=t=>(_ns_get32=Module._ns_get32=wasmExports.ns_get32)(t),_ns_put16=Module._ns_put16=(t,e)=>(_ns_put16=Module._ns_put16=wasmExports.ns_put16)(t,e),_ns_put32=Module._ns_put32=(t,e)=>(_ns_put32=Module._ns_put32=wasmExports.ns_put32)(t,e),_ns_skiprr=Module._ns_skiprr=(t,e,n,_)=>(_ns_skiprr=Module._ns_skiprr=wasmExports.ns_skiprr)(t,e,n,_),_ns_initparse=Module._ns_initparse=(t,e,n)=>(_ns_initparse=Module._ns_initparse=wasmExports.ns_initparse)(t,e,n),_ns_name_uncompress=Module._ns_name_uncompress=(t,e,n,_,r)=>(_ns_name_uncompress=Module._ns_name_uncompress=wasmExports.ns_name_uncompress)(t,e,n,_,r),_ns_parserr=Module._ns_parserr=(t,e,n,_)=>(_ns_parserr=Module._ns_parserr=wasmExports.ns_parserr)(t,e,n,_),_open_memstream=Module._open_memstream=(t,e)=>(_open_memstream=Module._open_memstream=wasmExports.open_memstream)(t,e),_open_wmemstream=Module._open_wmemstream=(t,e)=>(_open_wmemstream=Module._open_wmemstream=wasmExports.open_wmemstream)(t,e),_tcsetattr=Module._tcsetattr=(t,e,n)=>(_tcsetattr=Module._tcsetattr=wasmExports.tcsetattr)(t,e,n),_posix_close=Module._posix_close=(t,e)=>(_posix_close=Module._posix_close=wasmExports.posix_close)(t,e),_posix_fallocate=Module._posix_fallocate=(t,e,n)=>(_posix_fallocate=Module._posix_fallocate=wasmExports.posix_fallocate)(t,e,n),_posix_madvise=Module._posix_madvise=(t,e,n)=>(_posix_madvise=Module._posix_madvise=wasmExports.posix_madvise)(t,e,n),_posix_spawn_file_actions_addchdir_np=Module._posix_spawn_file_actions_addchdir_np=(t,e)=>(_posix_spawn_file_actions_addchdir_np=Module._posix_spawn_file_actions_addchdir_np=wasmExports.posix_spawn_file_actions_addchdir_np)(t,e),_posix_spawn_file_actions_addclose=Module._posix_spawn_file_actions_addclose=(t,e)=>(_posix_spawn_file_actions_addclose=Module._posix_spawn_file_actions_addclose=wasmExports.posix_spawn_file_actions_addclose)(t,e),_posix_spawn_file_actions_adddup2=Module._posix_spawn_file_actions_adddup2=(t,e,n)=>(_posix_spawn_file_actions_adddup2=Module._posix_spawn_file_actions_adddup2=wasmExports.posix_spawn_file_actions_adddup2)(t,e,n),_posix_spawn_file_actions_addfchdir_np=Module._posix_spawn_file_actions_addfchdir_np=(t,e)=>(_posix_spawn_file_actions_addfchdir_np=Module._posix_spawn_file_actions_addfchdir_np=wasmExports.posix_spawn_file_actions_addfchdir_np)(t,e),_posix_spawn_file_actions_addopen=Module._posix_spawn_file_actions_addopen=(t,e,n,_,r)=>(_posix_spawn_file_actions_addopen=Module._posix_spawn_file_actions_addopen=wasmExports.posix_spawn_file_actions_addopen)(t,e,n,_,r),_posix_spawn_file_actions_destroy=Module._posix_spawn_file_actions_destroy=t=>(_posix_spawn_file_actions_destroy=Module._posix_spawn_file_actions_destroy=wasmExports.posix_spawn_file_actions_destroy)(t),_posix_spawn_file_actions_init=Module._posix_spawn_file_actions_init=t=>(_posix_spawn_file_actions_init=Module._posix_spawn_file_actions_init=wasmExports.posix_spawn_file_actions_init)(t),_posix_spawnattr_destroy=Module._posix_spawnattr_destroy=t=>(_posix_spawnattr_destroy=Module._posix_spawnattr_destroy=wasmExports.posix_spawnattr_destroy)(t),_posix_spawnattr_getflags=Module._posix_spawnattr_getflags=(t,e)=>(_posix_spawnattr_getflags=Module._posix_spawnattr_getflags=wasmExports.posix_spawnattr_getflags)(t,e),_posix_spawnattr_getpgroup=Module._posix_spawnattr_getpgroup=(t,e)=>(_posix_spawnattr_getpgroup=Module._posix_spawnattr_getpgroup=wasmExports.posix_spawnattr_getpgroup)(t,e),_posix_spawnattr_getsigdefault=Module._posix_spawnattr_getsigdefault=(t,e)=>(_posix_spawnattr_getsigdefault=Module._posix_spawnattr_getsigdefault=wasmExports.posix_spawnattr_getsigdefault)(t,e),_posix_spawnattr_getsigmask=Module._posix_spawnattr_getsigmask=(t,e)=>(_posix_spawnattr_getsigmask=Module._posix_spawnattr_getsigmask=wasmExports.posix_spawnattr_getsigmask)(t,e),_posix_spawnattr_init=Module._posix_spawnattr_init=t=>(_posix_spawnattr_init=Module._posix_spawnattr_init=wasmExports.posix_spawnattr_init)(t),_posix_spawnattr_getschedparam=Module._posix_spawnattr_getschedparam=(t,e)=>(_posix_spawnattr_getschedparam=Module._posix_spawnattr_getschedparam=wasmExports.posix_spawnattr_getschedparam)(t,e),_posix_spawnattr_setschedparam=Module._posix_spawnattr_setschedparam=(t,e)=>(_posix_spawnattr_setschedparam=Module._posix_spawnattr_setschedparam=wasmExports.posix_spawnattr_setschedparam)(t,e),_posix_spawnattr_getschedpolicy=Module._posix_spawnattr_getschedpolicy=(t,e)=>(_posix_spawnattr_getschedpolicy=Module._posix_spawnattr_getschedpolicy=wasmExports.posix_spawnattr_getschedpolicy)(t,e),_posix_spawnattr_setschedpolicy=Module._posix_spawnattr_setschedpolicy=(t,e)=>(_posix_spawnattr_setschedpolicy=Module._posix_spawnattr_setschedpolicy=wasmExports.posix_spawnattr_setschedpolicy)(t,e),_posix_spawnattr_setflags=Module._posix_spawnattr_setflags=(t,e)=>(_posix_spawnattr_setflags=Module._posix_spawnattr_setflags=wasmExports.posix_spawnattr_setflags)(t,e),_posix_spawnattr_setpgroup=Module._posix_spawnattr_setpgroup=(t,e)=>(_posix_spawnattr_setpgroup=Module._posix_spawnattr_setpgroup=wasmExports.posix_spawnattr_setpgroup)(t,e),_posix_spawnattr_setsigdefault=Module._posix_spawnattr_setsigdefault=(t,e)=>(_posix_spawnattr_setsigdefault=Module._posix_spawnattr_setsigdefault=wasmExports.posix_spawnattr_setsigdefault)(t,e),_posix_spawnattr_setsigmask=Module._posix_spawnattr_setsigmask=(t,e)=>(_posix_spawnattr_setsigmask=Module._posix_spawnattr_setsigmask=wasmExports.posix_spawnattr_setsigmask)(t,e),_powf=Module._powf=(t,e)=>(_powf=Module._powf=wasmExports.powf)(t,e),_preadv=Module._preadv=(t,e,n,_)=>(_preadv=Module._preadv=wasmExports.preadv)(t,e,n,_),_printf=Module._printf=(t,e)=>(_printf=Module._printf=wasmExports.printf)(t,e),___small_printf=Module.___small_printf=(t,e)=>(___small_printf=Module.___small_printf=wasmExports.__small_printf)(t,e),_em_proxying_queue_create=Module._em_proxying_queue_create=()=>(_em_proxying_queue_create=Module._em_proxying_queue_create=wasmExports.em_proxying_queue_create)(),_em_proxying_queue_destroy=Module._em_proxying_queue_destroy=t=>(_em_proxying_queue_destroy=Module._em_proxying_queue_destroy=wasmExports.em_proxying_queue_destroy)(t),_emscripten_proxy_get_system_queue=Module._emscripten_proxy_get_system_queue=()=>(_emscripten_proxy_get_system_queue=Module._emscripten_proxy_get_system_queue=wasmExports.emscripten_proxy_get_system_queue)(),_emscripten_proxy_execute_queue=Module._emscripten_proxy_execute_queue=t=>(_emscripten_proxy_execute_queue=Module._emscripten_proxy_execute_queue=wasmExports.emscripten_proxy_execute_queue)(t),_emscripten_proxy_finish=Module._emscripten_proxy_finish=t=>(_emscripten_proxy_finish=Module._emscripten_proxy_finish=wasmExports.emscripten_proxy_finish)(t),_emscripten_proxy_async=Module._emscripten_proxy_async=(t,e,n,_)=>(_emscripten_proxy_async=Module._emscripten_proxy_async=wasmExports.emscripten_proxy_async)(t,e,n,_),_emscripten_proxy_sync=Module._emscripten_proxy_sync=(t,e,n,_)=>(_emscripten_proxy_sync=Module._emscripten_proxy_sync=wasmExports.emscripten_proxy_sync)(t,e,n,_),_emscripten_proxy_sync_with_ctx=Module._emscripten_proxy_sync_with_ctx=(t,e,n,_)=>(_emscripten_proxy_sync_with_ctx=Module._emscripten_proxy_sync_with_ctx=wasmExports.emscripten_proxy_sync_with_ctx)(t,e,n,_),_pselect=Module._pselect=(t,e,n,_,r,a)=>(_pselect=Module._pselect=wasmExports.pselect)(t,e,n,_,r,a),_pthread_attr_getdetachstate=Module._pthread_attr_getdetachstate=(t,e)=>(_pthread_attr_getdetachstate=Module._pthread_attr_getdetachstate=wasmExports.pthread_attr_getdetachstate)(t,e),_pthread_attr_getguardsize=Module._pthread_attr_getguardsize=(t,e)=>(_pthread_attr_getguardsize=Module._pthread_attr_getguardsize=wasmExports.pthread_attr_getguardsize)(t,e),_pthread_attr_getinheritsched=Module._pthread_attr_getinheritsched=(t,e)=>(_pthread_attr_getinheritsched=Module._pthread_attr_getinheritsched=wasmExports.pthread_attr_getinheritsched)(t,e),_pthread_attr_getschedparam=Module._pthread_attr_getschedparam=(t,e)=>(_pthread_attr_getschedparam=Module._pthread_attr_getschedparam=wasmExports.pthread_attr_getschedparam)(t,e),_pthread_attr_getschedpolicy=Module._pthread_attr_getschedpolicy=(t,e)=>(_pthread_attr_getschedpolicy=Module._pthread_attr_getschedpolicy=wasmExports.pthread_attr_getschedpolicy)(t,e),_pthread_attr_getscope=Module._pthread_attr_getscope=(t,e)=>(_pthread_attr_getscope=Module._pthread_attr_getscope=wasmExports.pthread_attr_getscope)(t,e),_pthread_attr_getstack=Module._pthread_attr_getstack=(t,e,n)=>(_pthread_attr_getstack=Module._pthread_attr_getstack=wasmExports.pthread_attr_getstack)(t,e,n),_pthread_attr_getstacksize=Module._pthread_attr_getstacksize=(t,e)=>(_pthread_attr_getstacksize=Module._pthread_attr_getstacksize=wasmExports.pthread_attr_getstacksize)(t,e),_pthread_barrierattr_getpshared=Module._pthread_barrierattr_getpshared=(t,e)=>(_pthread_barrierattr_getpshared=Module._pthread_barrierattr_getpshared=wasmExports.pthread_barrierattr_getpshared)(t,e),_pthread_condattr_getclock=Module._pthread_condattr_getclock=(t,e)=>(_pthread_condattr_getclock=Module._pthread_condattr_getclock=wasmExports.pthread_condattr_getclock)(t,e),_pthread_condattr_getpshared=Module._pthread_condattr_getpshared=(t,e)=>(_pthread_condattr_getpshared=Module._pthread_condattr_getpshared=wasmExports.pthread_condattr_getpshared)(t,e),_pthread_mutexattr_getprotocol=Module._pthread_mutexattr_getprotocol=(t,e)=>(_pthread_mutexattr_getprotocol=Module._pthread_mutexattr_getprotocol=wasmExports.pthread_mutexattr_getprotocol)(t,e),_pthread_mutexattr_getpshared=Module._pthread_mutexattr_getpshared=(t,e)=>(_pthread_mutexattr_getpshared=Module._pthread_mutexattr_getpshared=wasmExports.pthread_mutexattr_getpshared)(t,e),_pthread_mutexattr_getrobust=Module._pthread_mutexattr_getrobust=(t,e)=>(_pthread_mutexattr_getrobust=Module._pthread_mutexattr_getrobust=wasmExports.pthread_mutexattr_getrobust)(t,e),_pthread_mutexattr_gettype=Module._pthread_mutexattr_gettype=(t,e)=>(_pthread_mutexattr_gettype=Module._pthread_mutexattr_gettype=wasmExports.pthread_mutexattr_gettype)(t,e),_pthread_rwlockattr_getpshared=Module._pthread_rwlockattr_getpshared=(t,e)=>(_pthread_rwlockattr_getpshared=Module._pthread_rwlockattr_getpshared=wasmExports.pthread_rwlockattr_getpshared)(t,e),_pthread_attr_setdetachstate=Module._pthread_attr_setdetachstate=(t,e)=>(_pthread_attr_setdetachstate=Module._pthread_attr_setdetachstate=wasmExports.pthread_attr_setdetachstate)(t,e),_pthread_attr_setguardsize=Module._pthread_attr_setguardsize=(t,e)=>(_pthread_attr_setguardsize=Module._pthread_attr_setguardsize=wasmExports.pthread_attr_setguardsize)(t,e),_pthread_attr_setinheritsched=Module._pthread_attr_setinheritsched=(t,e)=>(_pthread_attr_setinheritsched=Module._pthread_attr_setinheritsched=wasmExports.pthread_attr_setinheritsched)(t,e),_pthread_attr_setschedparam=Module._pthread_attr_setschedparam=(t,e)=>(_pthread_attr_setschedparam=Module._pthread_attr_setschedparam=wasmExports.pthread_attr_setschedparam)(t,e),_pthread_attr_setschedpolicy=Module._pthread_attr_setschedpolicy=(t,e)=>(_pthread_attr_setschedpolicy=Module._pthread_attr_setschedpolicy=wasmExports.pthread_attr_setschedpolicy)(t,e),_pthread_attr_setscope=Module._pthread_attr_setscope=(t,e)=>(_pthread_attr_setscope=Module._pthread_attr_setscope=wasmExports.pthread_attr_setscope)(t,e),_pthread_attr_setstack=Module._pthread_attr_setstack=(t,e,n)=>(_pthread_attr_setstack=Module._pthread_attr_setstack=wasmExports.pthread_attr_setstack)(t,e,n),__pthread_cleanup_push=Module.__pthread_cleanup_push=(t,e,n)=>(__pthread_cleanup_push=Module.__pthread_cleanup_push=wasmExports._pthread_cleanup_push)(t,e,n),__pthread_cleanup_pop=Module.__pthread_cleanup_pop=(t,e)=>(__pthread_cleanup_pop=Module.__pthread_cleanup_pop=wasmExports._pthread_cleanup_pop)(t,e),_pthread_getconcurrency=Module._pthread_getconcurrency=()=>(_pthread_getconcurrency=Module._pthread_getconcurrency=wasmExports.pthread_getconcurrency)(),_pthread_getschedparam=Module._pthread_getschedparam=(t,e,n)=>(_pthread_getschedparam=Module._pthread_getschedparam=wasmExports.pthread_getschedparam)(t,e,n),_thrd_current=Module._thrd_current=()=>(_thrd_current=Module._thrd_current=wasmExports.thrd_current)(),_emscripten_main_runtime_thread_id=Module._emscripten_main_runtime_thread_id=()=>(_emscripten_main_runtime_thread_id=Module._emscripten_main_runtime_thread_id=wasmExports.emscripten_main_runtime_thread_id)(),_pthread_setconcurrency=Module._pthread_setconcurrency=t=>(_pthread_setconcurrency=Module._pthread_setconcurrency=wasmExports.pthread_setconcurrency)(t),_pthread_setschedprio=Module._pthread_setschedprio=(t,e)=>(_pthread_setschedprio=Module._pthread_setschedprio=wasmExports.pthread_setschedprio)(t,e),___sig_is_blocked=Module.___sig_is_blocked=t=>(___sig_is_blocked=Module.___sig_is_blocked=wasmExports.__sig_is_blocked)(t),_sigorset=Module._sigorset=(t,e,n)=>(_sigorset=Module._sigorset=wasmExports.sigorset)(t,e,n),_sigandset=Module._sigandset=(t,e,n)=>(_sigandset=Module._sigandset=wasmExports.sigandset)(t,e,n),_sigdelset=Module._sigdelset=(t,e)=>(_sigdelset=Module._sigdelset=wasmExports.sigdelset)(t,e),_ptsname=Module._ptsname=t=>(_ptsname=Module._ptsname=wasmExports.ptsname)(t),_posix_openpt=Module._posix_openpt=t=>(_posix_openpt=Module._posix_openpt=wasmExports.posix_openpt)(t),_grantpt=Module._grantpt=t=>(_grantpt=Module._grantpt=wasmExports.grantpt)(t),_unlockpt=Module._unlockpt=t=>(_unlockpt=Module._unlockpt=wasmExports.unlockpt)(t),_ptsname_r=Module._ptsname_r=(t,e,n)=>(_ptsname_r=Module._ptsname_r=wasmExports.ptsname_r)(t,e,n),__IO_putc=Module.__IO_putc=(t,e)=>(__IO_putc=Module.__IO_putc=wasmExports._IO_putc)(t,e),_putc_unlocked=Module._putc_unlocked=(t,e)=>(_putc_unlocked=Module._putc_unlocked=wasmExports.putc_unlocked)(t,e),_fputc_unlocked=Module._fputc_unlocked=(t,e)=>(_fputc_unlocked=Module._fputc_unlocked=wasmExports.fputc_unlocked)(t,e),__IO_putc_unlocked=Module.__IO_putc_unlocked=(t,e)=>(__IO_putc_unlocked=Module.__IO_putc_unlocked=wasmExports._IO_putc_unlocked)(t,e),_putchar=Module._putchar=t=>(_putchar=Module._putchar=wasmExports.putchar)(t),_putchar_unlocked=Module._putchar_unlocked=t=>(_putchar_unlocked=Module._putchar_unlocked=wasmExports.putchar_unlocked)(t),_putenv=Module._putenv=t=>(_putenv=Module._putenv=wasmExports.putenv)(t),_putw=Module._putw=(t,e)=>(_putw=Module._putw=wasmExports.putw)(t,e),_putwc=Module._putwc=(t,e)=>(_putwc=Module._putwc=wasmExports.putwc)(t,e),_putwchar=Module._putwchar=t=>(_putwchar=Module._putwchar=wasmExports.putwchar)(t),_putwchar_unlocked=Module._putwchar_unlocked=t=>(_putwchar_unlocked=Module._putwchar_unlocked=wasmExports.putwchar_unlocked)(t),_pwritev=Module._pwritev=(t,e,n,_)=>(_pwritev=Module._pwritev=wasmExports.pwritev)(t,e,n,_),_qsort_r=Module._qsort_r=(t,e,n,_,r)=>(_qsort_r=Module._qsort_r=wasmExports.qsort_r)(t,e,n,_,r),_quick_exit=Module._quick_exit=t=>(_quick_exit=Module._quick_exit=wasmExports.quick_exit)(t),_srand=Module._srand=t=>(_srand=Module._srand=wasmExports.srand)(t),_rand=Module._rand=()=>(_rand=Module._rand=wasmExports.rand)(),_rand_r=Module._rand_r=t=>(_rand_r=Module._rand_r=wasmExports.rand_r)(t),_srandom=Module._srandom=t=>(_srandom=Module._srandom=wasmExports.srandom)(t),_initstate=Module._initstate=(t,e,n)=>(_initstate=Module._initstate=wasmExports.initstate)(t,e,n),_setstate=Module._setstate=t=>(_setstate=Module._setstate=wasmExports.setstate)(t),_random=Module._random=()=>(_random=Module._random=wasmExports.random)(),_readdir_r=Module._readdir_r=(t,e,n)=>(_readdir_r=Module._readdir_r=wasmExports.readdir_r)(t,e,n),_recvmmsg=Module._recvmmsg=(t,e,n,_,r)=>(_recvmmsg=Module._recvmmsg=wasmExports.recvmmsg)(t,e,n,_,r),_regcomp=Module._regcomp=(t,e,n)=>(_regcomp=Module._regcomp=wasmExports.regcomp)(t,e,n),_regfree=Module._regfree=t=>(_regfree=Module._regfree=wasmExports.regfree)(t),_regerror=Module._regerror=(t,e,n,_)=>(_regerror=Module._regerror=wasmExports.regerror)(t,e,n,_),_regexec=Module._regexec=(t,e,n,_,r)=>(_regexec=Module._regexec=wasmExports.regexec)(t,e,n,_,r),_remainder=Module._remainder=(t,e)=>(_remainder=Module._remainder=wasmExports.remainder)(t,e),_remquo=Module._remquo=(t,e,n)=>(_remquo=Module._remquo=wasmExports.remquo)(t,e,n),_drem=Module._drem=(t,e)=>(_drem=Module._drem=wasmExports.drem)(t,e),_remainderf=Module._remainderf=(t,e)=>(_remainderf=Module._remainderf=wasmExports.remainderf)(t,e),_remquof=Module._remquof=(t,e,n)=>(_remquof=Module._remquof=wasmExports.remquof)(t,e,n),_dremf=Module._dremf=(t,e)=>(_dremf=Module._dremf=wasmExports.dremf)(t,e),_remainderl=Module._remainderl=(t,e,n,_,r)=>(_remainderl=Module._remainderl=wasmExports.remainderl)(t,e,n,_,r),_remquol=Module._remquol=(t,e,n,_,r,a)=>(_remquol=Module._remquol=wasmExports.remquol)(t,e,n,_,r,a),_remove=Module._remove=t=>(_remove=Module._remove=wasmExports.remove)(t),_res_init=Module._res_init=()=>(_res_init=Module._res_init=wasmExports.res_init)(),_res_mkquery=Module._res_mkquery=(t,e,n,_,r,a,o,l,p)=>(_res_mkquery=Module._res_mkquery=wasmExports.res_mkquery)(t,e,n,_,r,a,o,l,p),___res_msend=Module.___res_msend=(t,e,n,_,r,a)=>(___res_msend=Module.___res_msend=wasmExports.__res_msend)(t,e,n,_,r,a),_res_send=Module._res_send=(t,e,n,_)=>(_res_send=Module._res_send=wasmExports.res_send)(t,e,n,_),___res_state=Module.___res_state=()=>(___res_state=Module.___res_state=wasmExports.__res_state)(),_rindex=Module._rindex=(t,e)=>(_rindex=Module._rindex=wasmExports.rindex)(t,e),_emscripten_get_sbrk_ptr=Module._emscripten_get_sbrk_ptr=()=>(_emscripten_get_sbrk_ptr=Module._emscripten_get_sbrk_ptr=wasmExports.emscripten_get_sbrk_ptr)(),_sbrk=Module._sbrk=t=>(_sbrk=Module._sbrk=wasmExports.sbrk)(t),_brk=Module._brk=t=>(_brk=Module._brk=wasmExports.brk)(t),_scalb=Module._scalb=(t,e)=>(_scalb=Module._scalb=wasmExports.scalb)(t,e),_scalbf=Module._scalbf=(t,e)=>(_scalbf=Module._scalbf=wasmExports.scalbf)(t,e),_scalbln=Module._scalbln=(t,e)=>(_scalbln=Module._scalbln=wasmExports.scalbln)(t,e),_scalblnf=Module._scalblnf=(t,e)=>(_scalblnf=Module._scalblnf=wasmExports.scalblnf)(t,e),_scalblnl=Module._scalblnl=(t,e,n,_)=>(_scalblnl=Module._scalblnl=wasmExports.scalblnl)(t,e,n,_),_scandir=Module._scandir=(t,e,n,_)=>(_scandir=Module._scandir=wasmExports.scandir)(t,e,n,_),_scanf=Module._scanf=(t,e)=>(_scanf=Module._scanf=wasmExports.scanf)(t,e),_vscanf=Module._vscanf=(t,e)=>(_vscanf=Module._vscanf=wasmExports.vscanf)(t,e),___isoc99_scanf=Module.___isoc99_scanf=(t,e)=>(___isoc99_scanf=Module.___isoc99_scanf=wasmExports.__isoc99_scanf)(t,e),_secure_getenv=Module._secure_getenv=t=>(_secure_getenv=Module._secure_getenv=wasmExports.secure_getenv)(t),_seed48=Module._seed48=t=>(_seed48=Module._seed48=wasmExports.seed48)(t),_seekdir=Module._seekdir=(t,e)=>(_seekdir=Module._seekdir=wasmExports.seekdir)(t,e),_sendmmsg=Module._sendmmsg=(t,e,n,_)=>(_sendmmsg=Module._sendmmsg=wasmExports.sendmmsg)(t,e,n,_),_endservent=Module._endservent=()=>(_endservent=Module._endservent=wasmExports.endservent)(),_setservent=Module._setservent=t=>(_setservent=Module._setservent=wasmExports.setservent)(t),_getservent=Module._getservent=()=>(_getservent=Module._getservent=wasmExports.getservent)(),_setbuf=Module._setbuf=(t,e)=>(_setbuf=Module._setbuf=wasmExports.setbuf)(t,e),_setbuffer=Module._setbuffer=(t,e,n)=>(_setbuffer=Module._setbuffer=wasmExports.setbuffer)(t,e,n),_setdomainname=Module._setdomainname=(t,e)=>(_setdomainname=Module._setdomainname=wasmExports.setdomainname)(t,e),_setegid=Module._setegid=t=>(_setegid=Module._setegid=wasmExports.setegid)(t),_seteuid=Module._seteuid=t=>(_seteuid=Module._seteuid=wasmExports.seteuid)(t),__emscripten_timeout=(t,e)=>(__emscripten_timeout=wasmExports._emscripten_timeout)(t,e),_setlinebuf=Module._setlinebuf=t=>(_setlinebuf=Module._setlinebuf=wasmExports.setlinebuf)(t),_setresgid=Module._setresgid=(t,e,n)=>(_setresgid=Module._setresgid=wasmExports.setresgid)(t,e,n),_setresuid=Module._setresuid=(t,e,n)=>(_setresuid=Module._setresuid=wasmExports.setresuid)(t,e,n),_shm_open=Module._shm_open=(t,e,n)=>(_shm_open=Module._shm_open=wasmExports.shm_open)(t,e,n),_shm_unlink=Module._shm_unlink=t=>(_shm_unlink=Module._shm_unlink=wasmExports.shm_unlink)(t),_sigaction=Module._sigaction=(t,e,n)=>(_sigaction=Module._sigaction=wasmExports.sigaction)(t,e,n),_bsd_signal=Module._bsd_signal=(t,e)=>(_bsd_signal=Module._bsd_signal=wasmExports.bsd_signal)(t,e),___sysv_signal=Module.___sysv_signal=(t,e)=>(___sysv_signal=Module.___sysv_signal=wasmExports.__sysv_signal)(t,e),_significand=Module._significand=t=>(_significand=Module._significand=wasmExports.significand)(t),_significandf=Module._significandf=t=>(_significandf=Module._significandf=wasmExports.significandf)(t),_sigprocmask=Module._sigprocmask=(t,e,n)=>(_sigprocmask=Module._sigprocmask=wasmExports.sigprocmask)(t,e,n),_sincos=Module._sincos=(t,e,n)=>(_sincos=Module._sincos=wasmExports.sincos)(t,e,n),_sincosf=Module._sincosf=(t,e,n)=>(_sincosf=Module._sincosf=wasmExports.sincosf)(t,e,n),_sincosl=Module._sincosl=(t,e,n,_)=>(_sincosl=Module._sincosl=wasmExports.sincosl)(t,e,n,_),_sinhl=Module._sinhl=(t,e,n)=>(_sinhl=Module._sinhl=wasmExports.sinhl)(t,e,n),_sinl=Module._sinl=(t,e,n)=>(_sinl=Module._sinl=wasmExports.sinl)(t,e,n),_sleep=Module._sleep=t=>(_sleep=Module._sleep=wasmExports.sleep)(t),_sockatmark=Module._sockatmark=t=>(_sockatmark=Module._sockatmark=wasmExports.sockatmark)(t),_vsprintf=Module._vsprintf=(t,e,n)=>(_vsprintf=Module._vsprintf=wasmExports.vsprintf)(t,e,n),_vsiprintf=Module._vsiprintf=(t,e,n)=>(_vsiprintf=Module._vsiprintf=wasmExports.vsiprintf)(t,e,n),___small_sprintf=Module.___small_sprintf=(t,e,n)=>(___small_sprintf=Module.___small_sprintf=wasmExports.__small_sprintf)(t,e,n),___small_vsprintf=Module.___small_vsprintf=(t,e,n)=>(___small_vsprintf=Module.___small_vsprintf=wasmExports.__small_vsprintf)(t,e,n),_srand48=Module._srand48=t=>(_srand48=Module._srand48=wasmExports.srand48)(t),_vsscanf=Module._vsscanf=(t,e,n)=>(_vsscanf=Module._vsscanf=wasmExports.vsscanf)(t,e,n),___isoc99_sscanf=Module.___isoc99_sscanf=(t,e,n)=>(___isoc99_sscanf=Module.___isoc99_sscanf=wasmExports.__isoc99_sscanf)(t,e,n),_statfs=Module._statfs=(t,e)=>(_statfs=Module._statfs=wasmExports.statfs)(t,e),_fstatfs=Module._fstatfs=(t,e)=>(_fstatfs=Module._fstatfs=wasmExports.fstatfs)(t,e),_stpcpy=Module._stpcpy=(t,e)=>(_stpcpy=Module._stpcpy=wasmExports.stpcpy)(t,e),_stpncpy=Module._stpncpy=(t,e,n)=>(_stpncpy=Module._stpncpy=wasmExports.stpncpy)(t,e,n),___strcasecmp_l=Module.___strcasecmp_l=(t,e,n)=>(___strcasecmp_l=Module.___strcasecmp_l=wasmExports.__strcasecmp_l)(t,e,n),_strcasecmp_l=Module._strcasecmp_l=(t,e,n)=>(_strcasecmp_l=Module._strcasecmp_l=wasmExports.strcasecmp_l)(t,e,n),_strcasestr=Module._strcasestr=(t,e)=>(_strcasestr=Module._strcasestr=wasmExports.strcasestr)(t,e),_strncasecmp=Module._strncasecmp=(t,e,n)=>(_strncasecmp=Module._strncasecmp=wasmExports.strncasecmp)(t,e,n),_strchrnul=Module._strchrnul=(t,e)=>(_strchrnul=Module._strchrnul=wasmExports.strchrnul)(t,e),___strcoll_l=Module.___strcoll_l=(t,e,n)=>(___strcoll_l=Module.___strcoll_l=wasmExports.__strcoll_l)(t,e,n),_strcoll_l=Module._strcoll_l=(t,e,n)=>(_strcoll_l=Module._strcoll_l=wasmExports.strcoll_l)(t,e,n),___strerror_l=Module.___strerror_l=(t,e)=>(___strerror_l=Module.___strerror_l=wasmExports.__strerror_l)(t,e),_strerror_l=Module._strerror_l=(t,e)=>(_strerror_l=Module._strerror_l=wasmExports.strerror_l)(t,e),_strerror_r=Module._strerror_r=(t,e,n)=>(_strerror_r=Module._strerror_r=wasmExports.strerror_r)(t,e,n),___xpg_strerror_r=Module.___xpg_strerror_r=(t,e,n)=>(___xpg_strerror_r=Module.___xpg_strerror_r=wasmExports.__xpg_strerror_r)(t,e,n),_strfmon_l=Module._strfmon_l=(t,e,n,_,r)=>(_strfmon_l=Module._strfmon_l=wasmExports.strfmon_l)(t,e,n,_,r),_strfmon=Module._strfmon=(t,e,n,_)=>(_strfmon=Module._strfmon=wasmExports.strfmon)(t,e,n,_),_strlcat=Module._strlcat=(t,e,n)=>(_strlcat=Module._strlcat=wasmExports.strlcat)(t,e,n),_strlcpy=Module._strlcpy=(t,e,n)=>(_strlcpy=Module._strlcpy=wasmExports.strlcpy)(t,e,n),_strlwr=Module._strlwr=t=>(_strlwr=Module._strlwr=wasmExports.strlwr)(t),___strncasecmp_l=Module.___strncasecmp_l=(t,e,n,_)=>(___strncasecmp_l=Module.___strncasecmp_l=wasmExports.__strncasecmp_l)(t,e,n,_),_strncasecmp_l=Module._strncasecmp_l=(t,e,n,_)=>(_strncasecmp_l=Module._strncasecmp_l=wasmExports.strncasecmp_l)(t,e,n,_),_strndup=Module._strndup=(t,e)=>(_strndup=Module._strndup=wasmExports.strndup)(t,e),_strpbrk=Module._strpbrk=(t,e)=>(_strpbrk=Module._strpbrk=wasmExports.strpbrk)(t,e),_strsep=Module._strsep=(t,e)=>(_strsep=Module._strsep=wasmExports.strsep)(t,e),_strtof=Module._strtof=(t,e)=>(_strtof=Module._strtof=wasmExports.strtof)(t,e),_strtold=Module._strtold=(t,e,n)=>(_strtold=Module._strtold=wasmExports.strtold)(t,e,n),_strtof_l=Module._strtof_l=(t,e,n)=>(_strtof_l=Module._strtof_l=wasmExports.strtof_l)(t,e,n),_strtod_l=Module._strtod_l=(t,e,n)=>(_strtod_l=Module._strtod_l=wasmExports.strtod_l)(t,e,n),_strtold_l=Module._strtold_l=(t,e,n,_)=>(_strtold_l=Module._strtold_l=wasmExports.strtold_l)(t,e,n,_),___strtof_l=Module.___strtof_l=(t,e,n)=>(___strtof_l=Module.___strtof_l=wasmExports.__strtof_l)(t,e,n),___strtod_l=Module.___strtod_l=(t,e,n)=>(___strtod_l=Module.___strtod_l=wasmExports.__strtod_l)(t,e,n),___strtold_l=Module.___strtold_l=(t,e,n,_)=>(___strtold_l=Module.___strtold_l=wasmExports.__strtold_l)(t,e,n,_),_strtok=Module._strtok=(t,e)=>(_strtok=Module._strtok=wasmExports.strtok)(t,e),_strtok_r=Module._strtok_r=(t,e,n)=>(_strtok_r=Module._strtok_r=wasmExports.strtok_r)(t,e,n),_strtoll=Module._strtoll=(t,e,n)=>(_strtoll=Module._strtoll=wasmExports.strtoll)(t,e,n),_strtoimax=Module._strtoimax=(t,e,n)=>(_strtoimax=Module._strtoimax=wasmExports.strtoimax)(t,e,n),_strtoumax=Module._strtoumax=(t,e,n)=>(_strtoumax=Module._strtoumax=wasmExports.strtoumax)(t,e,n),___strtol_internal=Module.___strtol_internal=(t,e,n)=>(___strtol_internal=Module.___strtol_internal=wasmExports.__strtol_internal)(t,e,n),___strtoul_internal=Module.___strtoul_internal=(t,e,n)=>(___strtoul_internal=Module.___strtoul_internal=wasmExports.__strtoul_internal)(t,e,n),___strtoll_internal=Module.___strtoll_internal=(t,e,n)=>(___strtoll_internal=Module.___strtoll_internal=wasmExports.__strtoll_internal)(t,e,n),___strtoull_internal=Module.___strtoull_internal=(t,e,n)=>(___strtoull_internal=Module.___strtoull_internal=wasmExports.__strtoull_internal)(t,e,n),___strtoimax_internal=Module.___strtoimax_internal=(t,e,n)=>(___strtoimax_internal=Module.___strtoimax_internal=wasmExports.__strtoimax_internal)(t,e,n),___strtoumax_internal=Module.___strtoumax_internal=(t,e,n)=>(___strtoumax_internal=Module.___strtoumax_internal=wasmExports.__strtoumax_internal)(t,e,n),_strtoull_l=Module._strtoull_l=(t,e,n,_)=>(_strtoull_l=Module._strtoull_l=wasmExports.strtoull_l)(t,e,n,_),_strtoll_l=Module._strtoll_l=(t,e,n,_)=>(_strtoll_l=Module._strtoll_l=wasmExports.strtoll_l)(t,e,n,_),_strtoul_l=Module._strtoul_l=(t,e,n,_)=>(_strtoul_l=Module._strtoul_l=wasmExports.strtoul_l)(t,e,n,_),_strtol_l=Module._strtol_l=(t,e,n,_)=>(_strtol_l=Module._strtol_l=wasmExports.strtol_l)(t,e,n,_),_strupr=Module._strupr=t=>(_strupr=Module._strupr=wasmExports.strupr)(t),_strverscmp=Module._strverscmp=(t,e)=>(_strverscmp=Module._strverscmp=wasmExports.strverscmp)(t,e),___strxfrm_l=Module.___strxfrm_l=(t,e,n,_)=>(___strxfrm_l=Module.___strxfrm_l=wasmExports.__strxfrm_l)(t,e,n,_),_strxfrm=Module._strxfrm=(t,e,n)=>(_strxfrm=Module._strxfrm=wasmExports.strxfrm)(t,e,n),_strxfrm_l=Module._strxfrm_l=(t,e,n,_)=>(_strxfrm_l=Module._strxfrm_l=wasmExports.strxfrm_l)(t,e,n,_),_swab=Module._swab=(t,e,n)=>(_swab=Module._swab=wasmExports.swab)(t,e,n),_swprintf=Module._swprintf=(t,e,n,_)=>(_swprintf=Module._swprintf=wasmExports.swprintf)(t,e,n,_),_vswprintf=Module._vswprintf=(t,e,n,_)=>(_vswprintf=Module._vswprintf=wasmExports.vswprintf)(t,e,n,_),_swscanf=Module._swscanf=(t,e,n)=>(_swscanf=Module._swscanf=wasmExports.swscanf)(t,e,n),_vswscanf=Module._vswscanf=(t,e,n)=>(_vswscanf=Module._vswscanf=wasmExports.vswscanf)(t,e,n),___isoc99_swscanf=Module.___isoc99_swscanf=(t,e,n)=>(___isoc99_swscanf=Module.___isoc99_swscanf=wasmExports.__isoc99_swscanf)(t,e,n),_symlinkat=Module._symlinkat=(t,e,n)=>(_symlinkat=Module._symlinkat=wasmExports.symlinkat)(t,e,n),_setlogmask=Module._setlogmask=t=>(_setlogmask=Module._setlogmask=wasmExports.setlogmask)(t),_closelog=Module._closelog=()=>(_closelog=Module._closelog=wasmExports.closelog)(),_openlog=Module._openlog=(t,e,n)=>(_openlog=Module._openlog=wasmExports.openlog)(t,e,n),_syslog=Module._syslog=(t,e,n)=>(_syslog=Module._syslog=wasmExports.syslog)(t,e,n),_vsyslog=Module._vsyslog=(t,e,n)=>(_vsyslog=Module._vsyslog=wasmExports.vsyslog)(t,e,n),_tanhf=Module._tanhf=t=>(_tanhf=Module._tanhf=wasmExports.tanhf)(t),_tanhl=Module._tanhl=(t,e,n)=>(_tanhl=Module._tanhl=wasmExports.tanhl)(t,e,n),_tanl=Module._tanl=(t,e,n)=>(_tanl=Module._tanl=wasmExports.tanl)(t,e,n),_tcdrain=Module._tcdrain=t=>(_tcdrain=Module._tcdrain=wasmExports.tcdrain)(t),_tcflow=Module._tcflow=(t,e)=>(_tcflow=Module._tcflow=wasmExports.tcflow)(t,e),_tcflush=Module._tcflush=(t,e)=>(_tcflush=Module._tcflush=wasmExports.tcflush)(t,e),_tcgetattr=Module._tcgetattr=(t,e)=>(_tcgetattr=Module._tcgetattr=wasmExports.tcgetattr)(t,e),_tcgetsid=Module._tcgetsid=t=>(_tcgetsid=Module._tcgetsid=wasmExports.tcgetsid)(t),_tcgetwinsize=Module._tcgetwinsize=(t,e)=>(_tcgetwinsize=Module._tcgetwinsize=wasmExports.tcgetwinsize)(t,e),_tcsendbreak=Module._tcsendbreak=(t,e)=>(_tcsendbreak=Module._tcsendbreak=wasmExports.tcsendbreak)(t,e),_tcsetwinsize=Module._tcsetwinsize=(t,e)=>(_tcsetwinsize=Module._tcsetwinsize=wasmExports.tcsetwinsize)(t,e),_tdelete=Module._tdelete=(t,e,n)=>(_tdelete=Module._tdelete=wasmExports.tdelete)(t,e,n),_tdestroy=Module._tdestroy=(t,e)=>(_tdestroy=Module._tdestroy=wasmExports.tdestroy)(t,e),_telldir=Module._telldir=t=>(_telldir=Module._telldir=wasmExports.telldir)(t),_tempnam=Module._tempnam=(t,e)=>(_tempnam=Module._tempnam=wasmExports.tempnam)(t,e),_ngettext=Module._ngettext=(t,e,n)=>(_ngettext=Module._ngettext=wasmExports.ngettext)(t,e,n),_tfind=Module._tfind=(t,e,n)=>(_tfind=Module._tfind=wasmExports.tfind)(t,e,n),_tgamma=Module._tgamma=t=>(_tgamma=Module._tgamma=wasmExports.tgamma)(t),_tgammaf=Module._tgammaf=t=>(_tgammaf=Module._tgammaf=wasmExports.tgammaf)(t),_tgammal=Module._tgammal=(t,e,n)=>(_tgammal=Module._tgammal=wasmExports.tgammal)(t,e,n),_thrd_create=Module._thrd_create=(t,e,n)=>(_thrd_create=Module._thrd_create=wasmExports.thrd_create)(t,e,n),_thrd_exit=Module._thrd_exit=t=>(_thrd_exit=Module._thrd_exit=wasmExports.thrd_exit)(t),_thrd_join=Module._thrd_join=(t,e)=>(_thrd_join=Module._thrd_join=wasmExports.thrd_join)(t,e),_thrd_sleep=Module._thrd_sleep=(t,e)=>(_thrd_sleep=Module._thrd_sleep=wasmExports.thrd_sleep)(t,e),_thrd_yield=Module._thrd_yield=()=>(_thrd_yield=Module._thrd_yield=wasmExports.thrd_yield)(),_emscripten_set_thread_name=Module._emscripten_set_thread_name=(t,e)=>(_emscripten_set_thread_name=Module._emscripten_set_thread_name=wasmExports.emscripten_set_thread_name)(t,e),_timespec_get=Module._timespec_get=(t,e)=>(_timespec_get=Module._timespec_get=wasmExports.timespec_get)(t,e),_tmpfile=Module._tmpfile=()=>(_tmpfile=Module._tmpfile=wasmExports.tmpfile)(),_tmpnam=Module._tmpnam=t=>(_tmpnam=Module._tmpnam=wasmExports.tmpnam)(t),_toascii=Module._toascii=t=>(_toascii=Module._toascii=wasmExports.toascii)(t),___tolower_l=Module.___tolower_l=(t,e)=>(___tolower_l=Module.___tolower_l=wasmExports.__tolower_l)(t,e),_tolower_l=Module._tolower_l=(t,e)=>(_tolower_l=Module._tolower_l=wasmExports.tolower_l)(t,e),___toupper_l=Module.___toupper_l=(t,e)=>(___toupper_l=Module.___toupper_l=wasmExports.__toupper_l)(t,e),_toupper_l=Module._toupper_l=(t,e)=>(_toupper_l=Module._toupper_l=wasmExports.toupper_l)(t,e),___towupper_l=Module.___towupper_l=(t,e)=>(___towupper_l=Module.___towupper_l=wasmExports.__towupper_l)(t,e),___towlower_l=Module.___towlower_l=(t,e)=>(___towlower_l=Module.___towlower_l=wasmExports.__towlower_l)(t,e),_towupper_l=Module._towupper_l=(t,e)=>(_towupper_l=Module._towupper_l=wasmExports.towupper_l)(t,e),_towlower_l=Module._towlower_l=(t,e)=>(_towlower_l=Module._towlower_l=wasmExports.towlower_l)(t,e),_trunc=Module._trunc=t=>(_trunc=Module._trunc=wasmExports.trunc)(t),_truncf=Module._truncf=t=>(_truncf=Module._truncf=wasmExports.truncf)(t),_truncl=Module._truncl=(t,e,n)=>(_truncl=Module._truncl=wasmExports.truncl)(t,e,n),_tsearch=Module._tsearch=(t,e,n)=>(_tsearch=Module._tsearch=wasmExports.tsearch)(t,e,n),_tss_create=Module._tss_create=(t,e)=>(_tss_create=Module._tss_create=wasmExports.tss_create)(t,e),_tss_delete=Module._tss_delete=t=>(_tss_delete=Module._tss_delete=wasmExports.tss_delete)(t),_tss_set=Module._tss_set=(t,e)=>(_tss_set=Module._tss_set=wasmExports.tss_set)(t,e),_ttyname=Module._ttyname=t=>(_ttyname=Module._ttyname=wasmExports.ttyname)(t),_twalk=Module._twalk=(t,e)=>(_twalk=Module._twalk=wasmExports.twalk)(t,e),_ualarm=Module._ualarm=(t,e)=>(_ualarm=Module._ualarm=wasmExports.ualarm)(t,e),_ungetwc=Module._ungetwc=(t,e)=>(_ungetwc=Module._ungetwc=wasmExports.ungetwc)(t,e),___uselocale=Module.___uselocale=t=>(___uselocale=Module.___uselocale=wasmExports.__uselocale)(t),_uselocale=Module._uselocale=t=>(_uselocale=Module._uselocale=wasmExports.uselocale)(t),_usleep=Module._usleep=t=>(_usleep=Module._usleep=wasmExports.usleep)(t),_utime=Module._utime=(t,e)=>(_utime=Module._utime=wasmExports.utime)(t,e),_versionsort=Module._versionsort=(t,e)=>(_versionsort=Module._versionsort=wasmExports.versionsort)(t,e),___vfprintf_internal=Module.___vfprintf_internal=(t,e,n,_,r)=>(___vfprintf_internal=Module.___vfprintf_internal=wasmExports.__vfprintf_internal)(t,e,n,_,r),___isoc99_vfscanf=Module.___isoc99_vfscanf=(t,e,n)=>(___isoc99_vfscanf=Module.___isoc99_vfscanf=wasmExports.__isoc99_vfscanf)(t,e,n),_wcsnlen=Module._wcsnlen=(t,e)=>(_wcsnlen=Module._wcsnlen=wasmExports.wcsnlen)(t,e),___isoc99_vfwscanf=Module.___isoc99_vfwscanf=(t,e,n)=>(___isoc99_vfwscanf=Module.___isoc99_vfwscanf=wasmExports.__isoc99_vfwscanf)(t,e,n),_vprintf=Module._vprintf=(t,e)=>(_vprintf=Module._vprintf=wasmExports.vprintf)(t,e),___isoc99_vscanf=Module.___isoc99_vscanf=(t,e)=>(___isoc99_vscanf=Module.___isoc99_vscanf=wasmExports.__isoc99_vscanf)(t,e),_vsniprintf=Module._vsniprintf=(t,e,n,_)=>(_vsniprintf=Module._vsniprintf=wasmExports.vsniprintf)(t,e,n,_),___small_vsnprintf=Module.___small_vsnprintf=(t,e,n,_)=>(___small_vsnprintf=Module.___small_vsnprintf=wasmExports.__small_vsnprintf)(t,e,n,_),___isoc99_vsscanf=Module.___isoc99_vsscanf=(t,e,n)=>(___isoc99_vsscanf=Module.___isoc99_vsscanf=wasmExports.__isoc99_vsscanf)(t,e,n),___isoc99_vswscanf=Module.___isoc99_vswscanf=(t,e,n)=>(___isoc99_vswscanf=Module.___isoc99_vswscanf=wasmExports.__isoc99_vswscanf)(t,e,n),_vwprintf=Module._vwprintf=(t,e)=>(_vwprintf=Module._vwprintf=wasmExports.vwprintf)(t,e),_vwscanf=Module._vwscanf=(t,e)=>(_vwscanf=Module._vwscanf=wasmExports.vwscanf)(t,e),___isoc99_vwscanf=Module.___isoc99_vwscanf=(t,e)=>(___isoc99_vwscanf=Module.___isoc99_vwscanf=wasmExports.__isoc99_vwscanf)(t,e),_wcpcpy=Module._wcpcpy=(t,e)=>(_wcpcpy=Module._wcpcpy=wasmExports.wcpcpy)(t,e),_wcpncpy=Module._wcpncpy=(t,e,n)=>(_wcpncpy=Module._wcpncpy=wasmExports.wcpncpy)(t,e,n),_wcscasecmp=Module._wcscasecmp=(t,e)=>(_wcscasecmp=Module._wcscasecmp=wasmExports.wcscasecmp)(t,e),_wcsncasecmp=Module._wcsncasecmp=(t,e,n)=>(_wcsncasecmp=Module._wcsncasecmp=wasmExports.wcsncasecmp)(t,e,n),_wcscasecmp_l=Module._wcscasecmp_l=(t,e,n)=>(_wcscasecmp_l=Module._wcscasecmp_l=wasmExports.wcscasecmp_l)(t,e,n),_wcscat=Module._wcscat=(t,e)=>(_wcscat=Module._wcscat=wasmExports.wcscat)(t,e),___wcscoll_l=Module.___wcscoll_l=(t,e,n)=>(___wcscoll_l=Module.___wcscoll_l=wasmExports.__wcscoll_l)(t,e,n),_wcscoll_l=Module._wcscoll_l=(t,e,n)=>(_wcscoll_l=Module._wcscoll_l=wasmExports.wcscoll_l)(t,e,n),_wcscspn=Module._wcscspn=(t,e)=>(_wcscspn=Module._wcscspn=wasmExports.wcscspn)(t,e),_wcsdup=Module._wcsdup=t=>(_wcsdup=Module._wcsdup=wasmExports.wcsdup)(t),_wmemcpy=Module._wmemcpy=(t,e,n)=>(_wmemcpy=Module._wmemcpy=wasmExports.wmemcpy)(t,e,n),_wcsncasecmp_l=Module._wcsncasecmp_l=(t,e,n,_)=>(_wcsncasecmp_l=Module._wcsncasecmp_l=wasmExports.wcsncasecmp_l)(t,e,n,_),_wcsncat=Module._wcsncat=(t,e,n)=>(_wcsncat=Module._wcsncat=wasmExports.wcsncat)(t,e,n),_wmemset=Module._wmemset=(t,e,n)=>(_wmemset=Module._wmemset=wasmExports.wmemset)(t,e,n),_wmemchr=Module._wmemchr=(t,e,n)=>(_wmemchr=Module._wmemchr=wasmExports.wmemchr)(t,e,n),_wcsnrtombs=Module._wcsnrtombs=(t,e,n,_,r)=>(_wcsnrtombs=Module._wcsnrtombs=wasmExports.wcsnrtombs)(t,e,n,_,r),_wcspbrk=Module._wcspbrk=(t,e)=>(_wcspbrk=Module._wcspbrk=wasmExports.wcspbrk)(t,e),_wcsspn=Module._wcsspn=(t,e)=>(_wcsspn=Module._wcsspn=wasmExports.wcsspn)(t,e),_wcsstr=Module._wcsstr=(t,e)=>(_wcsstr=Module._wcsstr=wasmExports.wcsstr)(t,e),_wcstof=Module._wcstof=(t,e)=>(_wcstof=Module._wcstof=wasmExports.wcstof)(t,e),_wcstod=Module._wcstod=(t,e)=>(_wcstod=Module._wcstod=wasmExports.wcstod)(t,e),_wcstold=Module._wcstold=(t,e,n)=>(_wcstold=Module._wcstold=wasmExports.wcstold)(t,e,n),_wcstoull=Module._wcstoull=(t,e,n)=>(_wcstoull=Module._wcstoull=wasmExports.wcstoull)(t,e,n),_wcstoll=Module._wcstoll=(t,e,n)=>(_wcstoll=Module._wcstoll=wasmExports.wcstoll)(t,e,n),_wcstoul=Module._wcstoul=(t,e,n)=>(_wcstoul=Module._wcstoul=wasmExports.wcstoul)(t,e,n),_wcstoimax=Module._wcstoimax=(t,e,n)=>(_wcstoimax=Module._wcstoimax=wasmExports.wcstoimax)(t,e,n),_wcstoumax=Module._wcstoumax=(t,e,n)=>(_wcstoumax=Module._wcstoumax=wasmExports.wcstoumax)(t,e,n),_wcswcs=Module._wcswcs=(t,e)=>(_wcswcs=Module._wcswcs=wasmExports.wcswcs)(t,e),_wcswidth=Module._wcswidth=(t,e)=>(_wcswidth=Module._wcswidth=wasmExports.wcswidth)(t,e),_wcwidth=Module._wcwidth=t=>(_wcwidth=Module._wcwidth=wasmExports.wcwidth)(t),___wcsxfrm_l=Module.___wcsxfrm_l=(t,e,n,_)=>(___wcsxfrm_l=Module.___wcsxfrm_l=wasmExports.__wcsxfrm_l)(t,e,n,_),_wcsxfrm_l=Module._wcsxfrm_l=(t,e,n,_)=>(_wcsxfrm_l=Module._wcsxfrm_l=wasmExports.wcsxfrm_l)(t,e,n,_),_wctob=Module._wctob=t=>(_wctob=Module._wctob=wasmExports.wctob)(t),_wctrans=Module._wctrans=t=>(_wctrans=Module._wctrans=wasmExports.wctrans)(t),_towctrans=Module._towctrans=(t,e)=>(_towctrans=Module._towctrans=wasmExports.towctrans)(t,e),___wctrans_l=Module.___wctrans_l=(t,e)=>(___wctrans_l=Module.___wctrans_l=wasmExports.__wctrans_l)(t,e),___towctrans_l=Module.___towctrans_l=(t,e,n)=>(___towctrans_l=Module.___towctrans_l=wasmExports.__towctrans_l)(t,e,n),_wctrans_l=Module._wctrans_l=(t,e)=>(_wctrans_l=Module._wctrans_l=wasmExports.wctrans_l)(t,e),_towctrans_l=Module._towctrans_l=(t,e,n)=>(_towctrans_l=Module._towctrans_l=wasmExports.towctrans_l)(t,e,n),_wmemmove=Module._wmemmove=(t,e,n)=>(_wmemmove=Module._wmemmove=wasmExports.wmemmove)(t,e,n),_wprintf=Module._wprintf=(t,e)=>(_wprintf=Module._wprintf=wasmExports.wprintf)(t,e),_wscanf=Module._wscanf=(t,e)=>(_wscanf=Module._wscanf=wasmExports.wscanf)(t,e),___isoc99_wscanf=Module.___isoc99_wscanf=(t,e)=>(___isoc99_wscanf=Module.___isoc99_wscanf=wasmExports.__isoc99_wscanf)(t,e),___libc_realloc=Module.___libc_realloc=(t,e)=>(___libc_realloc=Module.___libc_realloc=wasmExports.__libc_realloc)(t,e),_realloc_in_place=Module._realloc_in_place=(t,e)=>(_realloc_in_place=Module._realloc_in_place=wasmExports.realloc_in_place)(t,e),_memalign=Module._memalign=(t,e)=>(_memalign=Module._memalign=wasmExports.memalign)(t,e),_valloc=Module._valloc=t=>(_valloc=Module._valloc=wasmExports.valloc)(t),_pvalloc=Module._pvalloc=t=>(_pvalloc=Module._pvalloc=wasmExports.pvalloc)(t),_mallinfo=Module._mallinfo=t=>(_mallinfo=Module._mallinfo=wasmExports.mallinfo)(t),_mallopt=Module._mallopt=(t,e)=>(_mallopt=Module._mallopt=wasmExports.mallopt)(t,e),_malloc_trim=Module._malloc_trim=t=>(_malloc_trim=Module._malloc_trim=wasmExports.malloc_trim)(t),_malloc_usable_size=Module._malloc_usable_size=t=>(_malloc_usable_size=Module._malloc_usable_size=wasmExports.malloc_usable_size)(t),_malloc_footprint=Module._malloc_footprint=()=>(_malloc_footprint=Module._malloc_footprint=wasmExports.malloc_footprint)(),_malloc_max_footprint=Module._malloc_max_footprint=()=>(_malloc_max_footprint=Module._malloc_max_footprint=wasmExports.malloc_max_footprint)(),_malloc_footprint_limit=Module._malloc_footprint_limit=()=>(_malloc_footprint_limit=Module._malloc_footprint_limit=wasmExports.malloc_footprint_limit)(),_malloc_set_footprint_limit=Module._malloc_set_footprint_limit=t=>(_malloc_set_footprint_limit=Module._malloc_set_footprint_limit=wasmExports.malloc_set_footprint_limit)(t),_independent_calloc=Module._independent_calloc=(t,e,n)=>(_independent_calloc=Module._independent_calloc=wasmExports.independent_calloc)(t,e,n),_independent_comalloc=Module._independent_comalloc=(t,e,n)=>(_independent_comalloc=Module._independent_comalloc=wasmExports.independent_comalloc)(t,e,n),_bulk_free=Module._bulk_free=(t,e)=>(_bulk_free=Module._bulk_free=wasmExports.bulk_free)(t,e),___trap=Module.___trap=()=>(___trap=Module.___trap=wasmExports.__trap)(),___absvdi2=Module.___absvdi2=t=>(___absvdi2=Module.___absvdi2=wasmExports.__absvdi2)(t),___absvsi2=Module.___absvsi2=t=>(___absvsi2=Module.___absvsi2=wasmExports.__absvsi2)(t),___absvti2=Module.___absvti2=(t,e,n)=>(___absvti2=Module.___absvti2=wasmExports.__absvti2)(t,e,n),___adddf3=Module.___adddf3=(t,e)=>(___adddf3=Module.___adddf3=wasmExports.__adddf3)(t,e),___fe_getround=Module.___fe_getround=()=>(___fe_getround=Module.___fe_getround=wasmExports.__fe_getround)(),___fe_raise_inexact=Module.___fe_raise_inexact=()=>(___fe_raise_inexact=Module.___fe_raise_inexact=wasmExports.__fe_raise_inexact)(),___addsf3=Module.___addsf3=(t,e)=>(___addsf3=Module.___addsf3=wasmExports.__addsf3)(t,e),___ashlti3=Module.___ashlti3=(t,e,n,_)=>(___ashlti3=Module.___ashlti3=wasmExports.__ashlti3)(t,e,n,_),___lshrti3=Module.___lshrti3=(t,e,n,_)=>(___lshrti3=Module.___lshrti3=wasmExports.__lshrti3)(t,e,n,_),___addvdi3=Module.___addvdi3=(t,e)=>(___addvdi3=Module.___addvdi3=wasmExports.__addvdi3)(t,e),___addvsi3=Module.___addvsi3=(t,e)=>(___addvsi3=Module.___addvsi3=wasmExports.__addvsi3)(t,e),___addvti3=Module.___addvti3=(t,e,n,_,r)=>(___addvti3=Module.___addvti3=wasmExports.__addvti3)(t,e,n,_,r),___ashldi3=Module.___ashldi3=(t,e)=>(___ashldi3=Module.___ashldi3=wasmExports.__ashldi3)(t,e),___ashrdi3=Module.___ashrdi3=(t,e)=>(___ashrdi3=Module.___ashrdi3=wasmExports.__ashrdi3)(t,e),___ashrti3=Module.___ashrti3=(t,e,n,_)=>(___ashrti3=Module.___ashrti3=wasmExports.__ashrti3)(t,e,n,_),___atomic_is_lock_free=Module.___atomic_is_lock_free=(t,e)=>(___atomic_is_lock_free=Module.___atomic_is_lock_free=wasmExports.__atomic_is_lock_free)(t,e),___atomic_load=Module.___atomic_load=(t,e,n,_)=>(___atomic_load=Module.___atomic_load=wasmExports.__atomic_load)(t,e,n,_),___atomic_store=Module.___atomic_store=(t,e,n,_)=>(___atomic_store=Module.___atomic_store=wasmExports.__atomic_store)(t,e,n,_),___atomic_compare_exchange=Module.___atomic_compare_exchange=(t,e,n,_,r,a)=>(___atomic_compare_exchange=Module.___atomic_compare_exchange=wasmExports.__atomic_compare_exchange)(t,e,n,_,r,a),___atomic_exchange=Module.___atomic_exchange=(t,e,n,_,r)=>(___atomic_exchange=Module.___atomic_exchange=wasmExports.__atomic_exchange)(t,e,n,_,r),___atomic_load_1=Module.___atomic_load_1=(t,e)=>(___atomic_load_1=Module.___atomic_load_1=wasmExports.__atomic_load_1)(t,e),___atomic_load_2=Module.___atomic_load_2=(t,e)=>(___atomic_load_2=Module.___atomic_load_2=wasmExports.__atomic_load_2)(t,e),___atomic_load_4=Module.___atomic_load_4=(t,e)=>(___atomic_load_4=Module.___atomic_load_4=wasmExports.__atomic_load_4)(t,e),___atomic_load_8=Module.___atomic_load_8=(t,e)=>(___atomic_load_8=Module.___atomic_load_8=wasmExports.__atomic_load_8)(t,e),___atomic_load_16=Module.___atomic_load_16=(t,e,n)=>(___atomic_load_16=Module.___atomic_load_16=wasmExports.__atomic_load_16)(t,e,n),___atomic_store_1=Module.___atomic_store_1=(t,e,n)=>(___atomic_store_1=Module.___atomic_store_1=wasmExports.__atomic_store_1)(t,e,n),___atomic_store_2=Module.___atomic_store_2=(t,e,n)=>(___atomic_store_2=Module.___atomic_store_2=wasmExports.__atomic_store_2)(t,e,n),___atomic_store_4=Module.___atomic_store_4=(t,e,n)=>(___atomic_store_4=Module.___atomic_store_4=wasmExports.__atomic_store_4)(t,e,n),___atomic_store_8=Module.___atomic_store_8=(t,e,n)=>(___atomic_store_8=Module.___atomic_store_8=wasmExports.__atomic_store_8)(t,e,n),___atomic_store_16=Module.___atomic_store_16=(t,e,n,_)=>(___atomic_store_16=Module.___atomic_store_16=wasmExports.__atomic_store_16)(t,e,n,_),___atomic_exchange_1=Module.___atomic_exchange_1=(t,e,n)=>(___atomic_exchange_1=Module.___atomic_exchange_1=wasmExports.__atomic_exchange_1)(t,e,n),___atomic_exchange_2=Module.___atomic_exchange_2=(t,e,n)=>(___atomic_exchange_2=Module.___atomic_exchange_2=wasmExports.__atomic_exchange_2)(t,e,n),___atomic_exchange_4=Module.___atomic_exchange_4=(t,e,n)=>(___atomic_exchange_4=Module.___atomic_exchange_4=wasmExports.__atomic_exchange_4)(t,e,n),___atomic_exchange_8=Module.___atomic_exchange_8=(t,e,n)=>(___atomic_exchange_8=Module.___atomic_exchange_8=wasmExports.__atomic_exchange_8)(t,e,n),___atomic_exchange_16=Module.___atomic_exchange_16=(t,e,n,_,r)=>(___atomic_exchange_16=Module.___atomic_exchange_16=wasmExports.__atomic_exchange_16)(t,e,n,_,r),___atomic_compare_exchange_1=Module.___atomic_compare_exchange_1=(t,e,n,_,r)=>(___atomic_compare_exchange_1=Module.___atomic_compare_exchange_1=wasmExports.__atomic_compare_exchange_1)(t,e,n,_,r),___atomic_compare_exchange_2=Module.___atomic_compare_exchange_2=(t,e,n,_,r)=>(___atomic_compare_exchange_2=Module.___atomic_compare_exchange_2=wasmExports.__atomic_compare_exchange_2)(t,e,n,_,r),___atomic_compare_exchange_4=Module.___atomic_compare_exchange_4=(t,e,n,_,r)=>(___atomic_compare_exchange_4=Module.___atomic_compare_exchange_4=wasmExports.__atomic_compare_exchange_4)(t,e,n,_,r),___atomic_compare_exchange_8=Module.___atomic_compare_exchange_8=(t,e,n,_,r)=>(___atomic_compare_exchange_8=Module.___atomic_compare_exchange_8=wasmExports.__atomic_compare_exchange_8)(t,e,n,_,r),___atomic_compare_exchange_16=Module.___atomic_compare_exchange_16=(t,e,n,_,r,a)=>(___atomic_compare_exchange_16=Module.___atomic_compare_exchange_16=wasmExports.__atomic_compare_exchange_16)(t,e,n,_,r,a),___atomic_fetch_add_1=Module.___atomic_fetch_add_1=(t,e,n)=>(___atomic_fetch_add_1=Module.___atomic_fetch_add_1=wasmExports.__atomic_fetch_add_1)(t,e,n),___atomic_fetch_add_2=Module.___atomic_fetch_add_2=(t,e,n)=>(___atomic_fetch_add_2=Module.___atomic_fetch_add_2=wasmExports.__atomic_fetch_add_2)(t,e,n),___atomic_fetch_add_4=Module.___atomic_fetch_add_4=(t,e,n)=>(___atomic_fetch_add_4=Module.___atomic_fetch_add_4=wasmExports.__atomic_fetch_add_4)(t,e,n),___atomic_fetch_add_8=Module.___atomic_fetch_add_8=(t,e,n)=>(___atomic_fetch_add_8=Module.___atomic_fetch_add_8=wasmExports.__atomic_fetch_add_8)(t,e,n),___atomic_fetch_add_16=Module.___atomic_fetch_add_16=(t,e,n,_,r)=>(___atomic_fetch_add_16=Module.___atomic_fetch_add_16=wasmExports.__atomic_fetch_add_16)(t,e,n,_,r),___atomic_fetch_sub_1=Module.___atomic_fetch_sub_1=(t,e,n)=>(___atomic_fetch_sub_1=Module.___atomic_fetch_sub_1=wasmExports.__atomic_fetch_sub_1)(t,e,n),___atomic_fetch_sub_2=Module.___atomic_fetch_sub_2=(t,e,n)=>(___atomic_fetch_sub_2=Module.___atomic_fetch_sub_2=wasmExports.__atomic_fetch_sub_2)(t,e,n),___atomic_fetch_sub_4=Module.___atomic_fetch_sub_4=(t,e,n)=>(___atomic_fetch_sub_4=Module.___atomic_fetch_sub_4=wasmExports.__atomic_fetch_sub_4)(t,e,n),___atomic_fetch_sub_8=Module.___atomic_fetch_sub_8=(t,e,n)=>(___atomic_fetch_sub_8=Module.___atomic_fetch_sub_8=wasmExports.__atomic_fetch_sub_8)(t,e,n),___atomic_fetch_sub_16=Module.___atomic_fetch_sub_16=(t,e,n,_,r)=>(___atomic_fetch_sub_16=Module.___atomic_fetch_sub_16=wasmExports.__atomic_fetch_sub_16)(t,e,n,_,r),___atomic_fetch_and_1=Module.___atomic_fetch_and_1=(t,e,n)=>(___atomic_fetch_and_1=Module.___atomic_fetch_and_1=wasmExports.__atomic_fetch_and_1)(t,e,n),___atomic_fetch_and_2=Module.___atomic_fetch_and_2=(t,e,n)=>(___atomic_fetch_and_2=Module.___atomic_fetch_and_2=wasmExports.__atomic_fetch_and_2)(t,e,n),___atomic_fetch_and_4=Module.___atomic_fetch_and_4=(t,e,n)=>(___atomic_fetch_and_4=Module.___atomic_fetch_and_4=wasmExports.__atomic_fetch_and_4)(t,e,n),___atomic_fetch_and_8=Module.___atomic_fetch_and_8=(t,e,n)=>(___atomic_fetch_and_8=Module.___atomic_fetch_and_8=wasmExports.__atomic_fetch_and_8)(t,e,n),___atomic_fetch_and_16=Module.___atomic_fetch_and_16=(t,e,n,_,r)=>(___atomic_fetch_and_16=Module.___atomic_fetch_and_16=wasmExports.__atomic_fetch_and_16)(t,e,n,_,r),___atomic_fetch_or_1=Module.___atomic_fetch_or_1=(t,e,n)=>(___atomic_fetch_or_1=Module.___atomic_fetch_or_1=wasmExports.__atomic_fetch_or_1)(t,e,n),___atomic_fetch_or_2=Module.___atomic_fetch_or_2=(t,e,n)=>(___atomic_fetch_or_2=Module.___atomic_fetch_or_2=wasmExports.__atomic_fetch_or_2)(t,e,n),___atomic_fetch_or_4=Module.___atomic_fetch_or_4=(t,e,n)=>(___atomic_fetch_or_4=Module.___atomic_fetch_or_4=wasmExports.__atomic_fetch_or_4)(t,e,n),___atomic_fetch_or_8=Module.___atomic_fetch_or_8=(t,e,n)=>(___atomic_fetch_or_8=Module.___atomic_fetch_or_8=wasmExports.__atomic_fetch_or_8)(t,e,n),___atomic_fetch_or_16=Module.___atomic_fetch_or_16=(t,e,n,_,r)=>(___atomic_fetch_or_16=Module.___atomic_fetch_or_16=wasmExports.__atomic_fetch_or_16)(t,e,n,_,r),___atomic_fetch_xor_1=Module.___atomic_fetch_xor_1=(t,e,n)=>(___atomic_fetch_xor_1=Module.___atomic_fetch_xor_1=wasmExports.__atomic_fetch_xor_1)(t,e,n),___atomic_fetch_xor_2=Module.___atomic_fetch_xor_2=(t,e,n)=>(___atomic_fetch_xor_2=Module.___atomic_fetch_xor_2=wasmExports.__atomic_fetch_xor_2)(t,e,n),___atomic_fetch_xor_4=Module.___atomic_fetch_xor_4=(t,e,n)=>(___atomic_fetch_xor_4=Module.___atomic_fetch_xor_4=wasmExports.__atomic_fetch_xor_4)(t,e,n),___atomic_fetch_xor_8=Module.___atomic_fetch_xor_8=(t,e,n)=>(___atomic_fetch_xor_8=Module.___atomic_fetch_xor_8=wasmExports.__atomic_fetch_xor_8)(t,e,n),___atomic_fetch_xor_16=Module.___atomic_fetch_xor_16=(t,e,n,_,r)=>(___atomic_fetch_xor_16=Module.___atomic_fetch_xor_16=wasmExports.__atomic_fetch_xor_16)(t,e,n,_,r),___atomic_fetch_nand_1=Module.___atomic_fetch_nand_1=(t,e,n)=>(___atomic_fetch_nand_1=Module.___atomic_fetch_nand_1=wasmExports.__atomic_fetch_nand_1)(t,e,n),___atomic_fetch_nand_2=Module.___atomic_fetch_nand_2=(t,e,n)=>(___atomic_fetch_nand_2=Module.___atomic_fetch_nand_2=wasmExports.__atomic_fetch_nand_2)(t,e,n),___atomic_fetch_nand_4=Module.___atomic_fetch_nand_4=(t,e,n)=>(___atomic_fetch_nand_4=Module.___atomic_fetch_nand_4=wasmExports.__atomic_fetch_nand_4)(t,e,n),___atomic_fetch_nand_8=Module.___atomic_fetch_nand_8=(t,e,n)=>(___atomic_fetch_nand_8=Module.___atomic_fetch_nand_8=wasmExports.__atomic_fetch_nand_8)(t,e,n),___atomic_fetch_nand_16=Module.___atomic_fetch_nand_16=(t,e,n,_,r)=>(___atomic_fetch_nand_16=Module.___atomic_fetch_nand_16=wasmExports.__atomic_fetch_nand_16)(t,e,n,_,r),_atomic_flag_clear=Module._atomic_flag_clear=t=>(_atomic_flag_clear=Module._atomic_flag_clear=wasmExports.atomic_flag_clear)(t),_atomic_flag_clear_explicit=Module._atomic_flag_clear_explicit=(t,e)=>(_atomic_flag_clear_explicit=Module._atomic_flag_clear_explicit=wasmExports.atomic_flag_clear_explicit)(t,e),_atomic_flag_test_and_set=Module._atomic_flag_test_and_set=t=>(_atomic_flag_test_and_set=Module._atomic_flag_test_and_set=wasmExports.atomic_flag_test_and_set)(t),_atomic_flag_test_and_set_explicit=Module._atomic_flag_test_and_set_explicit=(t,e)=>(_atomic_flag_test_and_set_explicit=Module._atomic_flag_test_and_set_explicit=wasmExports.atomic_flag_test_and_set_explicit)(t,e),_atomic_signal_fence=Module._atomic_signal_fence=t=>(_atomic_signal_fence=Module._atomic_signal_fence=wasmExports.atomic_signal_fence)(t),_atomic_thread_fence=Module._atomic_thread_fence=t=>(_atomic_thread_fence=Module._atomic_thread_fence=wasmExports.atomic_thread_fence)(t),___bswapdi2=Module.___bswapdi2=t=>(___bswapdi2=Module.___bswapdi2=wasmExports.__bswapdi2)(t),___bswapsi2=Module.___bswapsi2=t=>(___bswapsi2=Module.___bswapsi2=wasmExports.__bswapsi2)(t),___clear_cache=Module.___clear_cache=(t,e)=>(___clear_cache=Module.___clear_cache=wasmExports.__clear_cache)(t,e),___clzdi2=Module.___clzdi2=t=>(___clzdi2=Module.___clzdi2=wasmExports.__clzdi2)(t),___clzsi2=Module.___clzsi2=t=>(___clzsi2=Module.___clzsi2=wasmExports.__clzsi2)(t),___clzti2=Module.___clzti2=(t,e)=>(___clzti2=Module.___clzti2=wasmExports.__clzti2)(t,e),___cmpdi2=Module.___cmpdi2=(t,e)=>(___cmpdi2=Module.___cmpdi2=wasmExports.__cmpdi2)(t,e),___cmpti2=Module.___cmpti2=(t,e,n,_)=>(___cmpti2=Module.___cmpti2=wasmExports.__cmpti2)(t,e,n,_),___ledf2=Module.___ledf2=(t,e)=>(___ledf2=Module.___ledf2=wasmExports.__ledf2)(t,e),___gedf2=Module.___gedf2=(t,e)=>(___gedf2=Module.___gedf2=wasmExports.__gedf2)(t,e),___unorddf2=Module.___unorddf2=(t,e)=>(___unorddf2=Module.___unorddf2=wasmExports.__unorddf2)(t,e),___eqdf2=Module.___eqdf2=(t,e)=>(___eqdf2=Module.___eqdf2=wasmExports.__eqdf2)(t,e),___ltdf2=Module.___ltdf2=(t,e)=>(___ltdf2=Module.___ltdf2=wasmExports.__ltdf2)(t,e),___nedf2=Module.___nedf2=(t,e)=>(___nedf2=Module.___nedf2=wasmExports.__nedf2)(t,e),___gtdf2=Module.___gtdf2=(t,e)=>(___gtdf2=Module.___gtdf2=wasmExports.__gtdf2)(t,e),___lesf2=Module.___lesf2=(t,e)=>(___lesf2=Module.___lesf2=wasmExports.__lesf2)(t,e),___gesf2=Module.___gesf2=(t,e)=>(___gesf2=Module.___gesf2=wasmExports.__gesf2)(t,e),___unordsf2=Module.___unordsf2=(t,e)=>(___unordsf2=Module.___unordsf2=wasmExports.__unordsf2)(t,e),___eqsf2=Module.___eqsf2=(t,e)=>(___eqsf2=Module.___eqsf2=wasmExports.__eqsf2)(t,e),___ltsf2=Module.___ltsf2=(t,e)=>(___ltsf2=Module.___ltsf2=wasmExports.__ltsf2)(t,e),___nesf2=Module.___nesf2=(t,e)=>(___nesf2=Module.___nesf2=wasmExports.__nesf2)(t,e),___gtsf2=Module.___gtsf2=(t,e)=>(___gtsf2=Module.___gtsf2=wasmExports.__gtsf2)(t,e),___ctzdi2=Module.___ctzdi2=t=>(___ctzdi2=Module.___ctzdi2=wasmExports.__ctzdi2)(t),___ctzsi2=Module.___ctzsi2=t=>(___ctzsi2=Module.___ctzsi2=wasmExports.__ctzsi2)(t),___ctzti2=Module.___ctzti2=(t,e)=>(___ctzti2=Module.___ctzti2=wasmExports.__ctzti2)(t,e),___divdc3=Module.___divdc3=(t,e,n,_,r)=>(___divdc3=Module.___divdc3=wasmExports.__divdc3)(t,e,n,_,r),___divdf3=Module.___divdf3=(t,e)=>(___divdf3=Module.___divdf3=wasmExports.__divdf3)(t,e),___divdi3=Module.___divdi3=(t,e)=>(___divdi3=Module.___divdi3=wasmExports.__divdi3)(t,e),___udivmoddi4=Module.___udivmoddi4=(t,e,n)=>(___udivmoddi4=Module.___udivmoddi4=wasmExports.__udivmoddi4)(t,e,n),___divmoddi4=Module.___divmoddi4=(t,e,n)=>(___divmoddi4=Module.___divmoddi4=wasmExports.__divmoddi4)(t,e,n),___divmodsi4=Module.___divmodsi4=(t,e,n)=>(___divmodsi4=Module.___divmodsi4=wasmExports.__divmodsi4)(t,e,n),___udivmodsi4=Module.___udivmodsi4=(t,e,n)=>(___udivmodsi4=Module.___udivmodsi4=wasmExports.__udivmodsi4)(t,e,n),___divmodti4=Module.___divmodti4=(t,e,n,_,r,a)=>(___divmodti4=Module.___divmodti4=wasmExports.__divmodti4)(t,e,n,_,r,a),___udivmodti4=Module.___udivmodti4=(t,e,n,_,r,a)=>(___udivmodti4=Module.___udivmodti4=wasmExports.__udivmodti4)(t,e,n,_,r,a),___divsc3=Module.___divsc3=(t,e,n,_,r)=>(___divsc3=Module.___divsc3=wasmExports.__divsc3)(t,e,n,_,r),___divsf3=Module.___divsf3=(t,e)=>(___divsf3=Module.___divsf3=wasmExports.__divsf3)(t,e),___divsi3=Module.___divsi3=(t,e)=>(___divsi3=Module.___divsi3=wasmExports.__divsi3)(t,e),___divtc3=Module.___divtc3=(t,e,n,_,r,a,o,l,p)=>(___divtc3=Module.___divtc3=wasmExports.__divtc3)(t,e,n,_,r,a,o,l,p),___divti3=Module.___divti3=(t,e,n,_,r)=>(___divti3=Module.___divti3=wasmExports.__divti3)(t,e,n,_,r),___divxc3=Module.___divxc3=(t,e,n,_,r,a,o,l,p)=>(___divxc3=Module.___divxc3=wasmExports.__divxc3)(t,e,n,_,r,a,o,l,p),_setThrew=(t,e)=>(_setThrew=wasmExports.setThrew)(t,e),_saveSetjmp=Module._saveSetjmp=(t,e,n,_)=>(_saveSetjmp=Module._saveSetjmp=wasmExports.saveSetjmp)(t,e,n,_),setTempRet0=t=>(setTempRet0=wasmExports.setTempRet0)(t),_testSetjmp=Module._testSetjmp=(t,e,n)=>(_testSetjmp=Module._testSetjmp=wasmExports.testSetjmp)(t,e,n),_emscripten_longjmp=Module._emscripten_longjmp=(t,e)=>(_emscripten_longjmp=Module._emscripten_longjmp=wasmExports.emscripten_longjmp)(t,e),getTempRet0=()=>(getTempRet0=wasmExports.getTempRet0)(),___get_temp_ret=Module.___get_temp_ret=()=>(___get_temp_ret=Module.___get_temp_ret=wasmExports.__get_temp_ret)(),___set_temp_ret=Module.___set_temp_ret=t=>(___set_temp_ret=Module.___set_temp_ret=wasmExports.__set_temp_ret)(t),___emutls_get_address=Module.___emutls_get_address=t=>(___emutls_get_address=Module.___emutls_get_address=wasmExports.__emutls_get_address)(t),___enable_execute_stack=Module.___enable_execute_stack=t=>(___enable_execute_stack=Module.___enable_execute_stack=wasmExports.__enable_execute_stack)(t),___extendhfsf2=Module.___extendhfsf2=t=>(___extendhfsf2=Module.___extendhfsf2=wasmExports.__extendhfsf2)(t),___gnu_h2f_ieee=Module.___gnu_h2f_ieee=t=>(___gnu_h2f_ieee=Module.___gnu_h2f_ieee=wasmExports.__gnu_h2f_ieee)(t),___extendsfdf2=Module.___extendsfdf2=t=>(___extendsfdf2=Module.___extendsfdf2=wasmExports.__extendsfdf2)(t),___ffsdi2=Module.___ffsdi2=t=>(___ffsdi2=Module.___ffsdi2=wasmExports.__ffsdi2)(t),___ffssi2=Module.___ffssi2=t=>(___ffssi2=Module.___ffssi2=wasmExports.__ffssi2)(t),___ffsti2=Module.___ffsti2=(t,e)=>(___ffsti2=Module.___ffsti2=wasmExports.__ffsti2)(t,e),___fixdfdi=Module.___fixdfdi=t=>(___fixdfdi=Module.___fixdfdi=wasmExports.__fixdfdi)(t),___fixunsdfdi=Module.___fixunsdfdi=t=>(___fixunsdfdi=Module.___fixunsdfdi=wasmExports.__fixunsdfdi)(t),___fixdfsi=Module.___fixdfsi=t=>(___fixdfsi=Module.___fixdfsi=wasmExports.__fixdfsi)(t),___fixdfti=Module.___fixdfti=(t,e)=>(___fixdfti=Module.___fixdfti=wasmExports.__fixdfti)(t,e),___fixsfdi=Module.___fixsfdi=t=>(___fixsfdi=Module.___fixsfdi=wasmExports.__fixsfdi)(t),___fixunssfdi=Module.___fixunssfdi=t=>(___fixunssfdi=Module.___fixunssfdi=wasmExports.__fixunssfdi)(t),___fixsfsi=Module.___fixsfsi=t=>(___fixsfsi=Module.___fixsfsi=wasmExports.__fixsfsi)(t),___fixsfti=Module.___fixsfti=(t,e)=>(___fixsfti=Module.___fixsfti=wasmExports.__fixsfti)(t,e),___fixtfti=Module.___fixtfti=(t,e,n)=>(___fixtfti=Module.___fixtfti=wasmExports.__fixtfti)(t,e,n),___fixunsdfsi=Module.___fixunsdfsi=t=>(___fixunsdfsi=Module.___fixunsdfsi=wasmExports.__fixunsdfsi)(t),___fixunsdfti=Module.___fixunsdfti=(t,e)=>(___fixunsdfti=Module.___fixunsdfti=wasmExports.__fixunsdfti)(t,e),___fixunssfsi=Module.___fixunssfsi=t=>(___fixunssfsi=Module.___fixunssfsi=wasmExports.__fixunssfsi)(t),___fixunssfti=Module.___fixunssfti=(t,e)=>(___fixunssfti=Module.___fixunssfti=wasmExports.__fixunssfti)(t,e),___fixunstfdi=Module.___fixunstfdi=(t,e)=>(___fixunstfdi=Module.___fixunstfdi=wasmExports.__fixunstfdi)(t,e),___fixunstfsi=Module.___fixunstfsi=(t,e)=>(___fixunstfsi=Module.___fixunstfsi=wasmExports.__fixunstfsi)(t,e),___fixunstfti=Module.___fixunstfti=(t,e,n)=>(___fixunstfti=Module.___fixunstfti=wasmExports.__fixunstfti)(t,e,n),___fixunsxfdi=Module.___fixunsxfdi=(t,e)=>(___fixunsxfdi=Module.___fixunsxfdi=wasmExports.__fixunsxfdi)(t,e),___fixunsxfsi=Module.___fixunsxfsi=(t,e)=>(___fixunsxfsi=Module.___fixunsxfsi=wasmExports.__fixunsxfsi)(t,e),___fixunsxfti=Module.___fixunsxfti=(t,e,n)=>(___fixunsxfti=Module.___fixunsxfti=wasmExports.__fixunsxfti)(t,e,n),___fixxfdi=Module.___fixxfdi=(t,e)=>(___fixxfdi=Module.___fixxfdi=wasmExports.__fixxfdi)(t,e),___fixxfti=Module.___fixxfti=(t,e,n)=>(___fixxfti=Module.___fixxfti=wasmExports.__fixxfti)(t,e,n),___floatdidf=Module.___floatdidf=t=>(___floatdidf=Module.___floatdidf=wasmExports.__floatdidf)(t),___floatdisf=Module.___floatdisf=t=>(___floatdisf=Module.___floatdisf=wasmExports.__floatdisf)(t),___floatditf=Module.___floatditf=(t,e)=>(___floatditf=Module.___floatditf=wasmExports.__floatditf)(t,e),___floatdixf=Module.___floatdixf=(t,e)=>(___floatdixf=Module.___floatdixf=wasmExports.__floatdixf)(t,e),___floatsidf=Module.___floatsidf=t=>(___floatsidf=Module.___floatsidf=wasmExports.__floatsidf)(t),___floatsisf=Module.___floatsisf=t=>(___floatsisf=Module.___floatsisf=wasmExports.__floatsisf)(t),___floattidf=Module.___floattidf=(t,e)=>(___floattidf=Module.___floattidf=wasmExports.__floattidf)(t,e),___floattisf=Module.___floattisf=(t,e)=>(___floattisf=Module.___floattisf=wasmExports.__floattisf)(t,e),___floattitf=Module.___floattitf=(t,e,n)=>(___floattitf=Module.___floattitf=wasmExports.__floattitf)(t,e,n),___floattixf=Module.___floattixf=(t,e,n)=>(___floattixf=Module.___floattixf=wasmExports.__floattixf)(t,e,n),___floatundidf=Module.___floatundidf=t=>(___floatundidf=Module.___floatundidf=wasmExports.__floatundidf)(t),___floatundisf=Module.___floatundisf=t=>(___floatundisf=Module.___floatundisf=wasmExports.__floatundisf)(t),___floatunditf=Module.___floatunditf=(t,e)=>(___floatunditf=Module.___floatunditf=wasmExports.__floatunditf)(t,e),___floatundixf=Module.___floatundixf=(t,e)=>(___floatundixf=Module.___floatundixf=wasmExports.__floatundixf)(t,e),___floatunsidf=Module.___floatunsidf=t=>(___floatunsidf=Module.___floatunsidf=wasmExports.__floatunsidf)(t),___floatunsisf=Module.___floatunsisf=t=>(___floatunsisf=Module.___floatunsisf=wasmExports.__floatunsisf)(t),___floatuntidf=Module.___floatuntidf=(t,e)=>(___floatuntidf=Module.___floatuntidf=wasmExports.__floatuntidf)(t,e),___floatuntisf=Module.___floatuntisf=(t,e)=>(___floatuntisf=Module.___floatuntisf=wasmExports.__floatuntisf)(t,e),___floatuntitf=Module.___floatuntitf=(t,e,n)=>(___floatuntitf=Module.___floatuntitf=wasmExports.__floatuntitf)(t,e,n),___floatuntixf=Module.___floatuntixf=(t,e,n)=>(___floatuntixf=Module.___floatuntixf=wasmExports.__floatuntixf)(t,e,n),___lshrdi3=Module.___lshrdi3=(t,e)=>(___lshrdi3=Module.___lshrdi3=wasmExports.__lshrdi3)(t,e),___moddi3=Module.___moddi3=(t,e)=>(___moddi3=Module.___moddi3=wasmExports.__moddi3)(t,e),___modsi3=Module.___modsi3=(t,e)=>(___modsi3=Module.___modsi3=wasmExports.__modsi3)(t,e),___modti3=Module.___modti3=(t,e,n,_,r)=>(___modti3=Module.___modti3=wasmExports.__modti3)(t,e,n,_,r),___muldf3=Module.___muldf3=(t,e)=>(___muldf3=Module.___muldf3=wasmExports.__muldf3)(t,e),___muldi3=Module.___muldi3=(t,e)=>(___muldi3=Module.___muldi3=wasmExports.__muldi3)(t,e),___mulodi4=Module.___mulodi4=(t,e,n)=>(___mulodi4=Module.___mulodi4=wasmExports.__mulodi4)(t,e,n),___mulosi4=Module.___mulosi4=(t,e,n)=>(___mulosi4=Module.___mulosi4=wasmExports.__mulosi4)(t,e,n),___muloti4=Module.___muloti4=(t,e,n,_,r,a)=>(___muloti4=Module.___muloti4=wasmExports.__muloti4)(t,e,n,_,r,a),___udivti3=Module.___udivti3=(t,e,n,_,r)=>(___udivti3=Module.___udivti3=wasmExports.__udivti3)(t,e,n,_,r),___mulsf3=Module.___mulsf3=(t,e)=>(___mulsf3=Module.___mulsf3=wasmExports.__mulsf3)(t,e),___mulvdi3=Module.___mulvdi3=(t,e)=>(___mulvdi3=Module.___mulvdi3=wasmExports.__mulvdi3)(t,e),___mulvsi3=Module.___mulvsi3=(t,e)=>(___mulvsi3=Module.___mulvsi3=wasmExports.__mulvsi3)(t,e),___mulvti3=Module.___mulvti3=(t,e,n,_,r)=>(___mulvti3=Module.___mulvti3=wasmExports.__mulvti3)(t,e,n,_,r),___mulxc3=Module.___mulxc3=(t,e,n,_,r,a,o,l,p)=>(___mulxc3=Module.___mulxc3=wasmExports.__mulxc3)(t,e,n,_,r,a,o,l,p),___negdf2=Module.___negdf2=t=>(___negdf2=Module.___negdf2=wasmExports.__negdf2)(t),___negdi2=Module.___negdi2=t=>(___negdi2=Module.___negdi2=wasmExports.__negdi2)(t),___negsf2=Module.___negsf2=t=>(___negsf2=Module.___negsf2=wasmExports.__negsf2)(t),___negti2=Module.___negti2=(t,e,n)=>(___negti2=Module.___negti2=wasmExports.__negti2)(t,e,n),___negvdi2=Module.___negvdi2=t=>(___negvdi2=Module.___negvdi2=wasmExports.__negvdi2)(t),___negvsi2=Module.___negvsi2=t=>(___negvsi2=Module.___negvsi2=wasmExports.__negvsi2)(t),___negvti2=Module.___negvti2=(t,e,n)=>(___negvti2=Module.___negvti2=wasmExports.__negvti2)(t,e,n),___paritydi2=Module.___paritydi2=t=>(___paritydi2=Module.___paritydi2=wasmExports.__paritydi2)(t),___paritysi2=Module.___paritysi2=t=>(___paritysi2=Module.___paritysi2=wasmExports.__paritysi2)(t),___parityti2=Module.___parityti2=(t,e)=>(___parityti2=Module.___parityti2=wasmExports.__parityti2)(t,e),___popcountdi2=Module.___popcountdi2=t=>(___popcountdi2=Module.___popcountdi2=wasmExports.__popcountdi2)(t),___popcountsi2=Module.___popcountsi2=t=>(___popcountsi2=Module.___popcountsi2=wasmExports.__popcountsi2)(t),___popcountti2=Module.___popcountti2=(t,e)=>(___popcountti2=Module.___popcountti2=wasmExports.__popcountti2)(t,e),___powidf2=Module.___powidf2=(t,e)=>(___powidf2=Module.___powidf2=wasmExports.__powidf2)(t,e),___powisf2=Module.___powisf2=(t,e)=>(___powisf2=Module.___powisf2=wasmExports.__powisf2)(t,e),___powitf2=Module.___powitf2=(t,e,n,_)=>(___powitf2=Module.___powitf2=wasmExports.__powitf2)(t,e,n,_),___powixf2=Module.___powixf2=(t,e,n,_)=>(___powixf2=Module.___powixf2=wasmExports.__powixf2)(t,e,n,_),_emscripten_stack_init=Module._emscripten_stack_init=()=>(_emscripten_stack_init=Module._emscripten_stack_init=wasmExports.emscripten_stack_init)(),_emscripten_stack_set_limits=Module._emscripten_stack_set_limits=(t,e)=>(_emscripten_stack_set_limits=Module._emscripten_stack_set_limits=wasmExports.emscripten_stack_set_limits)(t,e),_emscripten_stack_get_free=Module._emscripten_stack_get_free=()=>(_emscripten_stack_get_free=Module._emscripten_stack_get_free=wasmExports.emscripten_stack_get_free)(),stackSave=()=>(stackSave=wasmExports.stackSave)(),stackRestore=t=>(stackRestore=wasmExports.stackRestore)(t),stackAlloc=t=>(stackAlloc=wasmExports.stackAlloc)(t),___subdf3=Module.___subdf3=(t,e)=>(___subdf3=Module.___subdf3=wasmExports.__subdf3)(t,e),___subsf3=Module.___subsf3=(t,e)=>(___subsf3=Module.___subsf3=wasmExports.__subsf3)(t,e),___subvdi3=Module.___subvdi3=(t,e)=>(___subvdi3=Module.___subvdi3=wasmExports.__subvdi3)(t,e),___subvsi3=Module.___subvsi3=(t,e)=>(___subvsi3=Module.___subvsi3=wasmExports.__subvsi3)(t,e),___subvti3=Module.___subvti3=(t,e,n,_,r)=>(___subvti3=Module.___subvti3=wasmExports.__subvti3)(t,e,n,_,r),___truncdfhf2=Module.___truncdfhf2=t=>(___truncdfhf2=Module.___truncdfhf2=wasmExports.__truncdfhf2)(t),___truncdfsf2=Module.___truncdfsf2=t=>(___truncdfsf2=Module.___truncdfsf2=wasmExports.__truncdfsf2)(t),___truncsfhf2=Module.___truncsfhf2=t=>(___truncsfhf2=Module.___truncsfhf2=wasmExports.__truncsfhf2)(t),___gnu_f2h_ieee=Module.___gnu_f2h_ieee=t=>(___gnu_f2h_ieee=Module.___gnu_f2h_ieee=wasmExports.__gnu_f2h_ieee)(t),___ucmpdi2=Module.___ucmpdi2=(t,e)=>(___ucmpdi2=Module.___ucmpdi2=wasmExports.__ucmpdi2)(t,e),___ucmpti2=Module.___ucmpti2=(t,e,n,_)=>(___ucmpti2=Module.___ucmpti2=wasmExports.__ucmpti2)(t,e,n,_),___udivdi3=Module.___udivdi3=(t,e)=>(___udivdi3=Module.___udivdi3=wasmExports.__udivdi3)(t,e),___udivsi3=Module.___udivsi3=(t,e)=>(___udivsi3=Module.___udivsi3=wasmExports.__udivsi3)(t,e),___umoddi3=Module.___umoddi3=(t,e)=>(___umoddi3=Module.___umoddi3=wasmExports.__umoddi3)(t,e),___umodsi3=Module.___umodsi3=(t,e)=>(___umodsi3=Module.___umodsi3=wasmExports.__umodsi3)(t,e),___umodti3=Module.___umodti3=(t,e,n,_,r)=>(___umodti3=Module.___umodti3=wasmExports.__umodti3)(t,e,n,_,r),___cxa_pure_virtual=Module.___cxa_pure_virtual=()=>(___cxa_pure_virtual=Module.___cxa_pure_virtual=wasmExports.__cxa_pure_virtual)(),___cxa_allocate_exception=Module.___cxa_allocate_exception=t=>(___cxa_allocate_exception=Module.___cxa_allocate_exception=wasmExports.__cxa_allocate_exception)(t),___cxa_free_exception=t=>(___cxa_free_exception=wasmExports.__cxa_free_exception)(t),___cxa_decrement_exception_refcount=t=>(___cxa_decrement_exception_refcount=wasmExports.__cxa_decrement_exception_refcount)(t),___cxa_increment_exception_refcount=t=>(___cxa_increment_exception_refcount=wasmExports.__cxa_increment_exception_refcount)(t),___cxa_bad_cast=Module.___cxa_bad_cast=()=>(___cxa_bad_cast=Module.___cxa_bad_cast=wasmExports.__cxa_bad_cast)(),___cxa_bad_typeid=Module.___cxa_bad_typeid=()=>(___cxa_bad_typeid=Module.___cxa_bad_typeid=wasmExports.__cxa_bad_typeid)(),___cxa_throw_bad_array_new_length=Module.___cxa_throw_bad_array_new_length=()=>(___cxa_throw_bad_array_new_length=Module.___cxa_throw_bad_array_new_length=wasmExports.__cxa_throw_bad_array_new_length)(),___cxa_demangle=(t,e,n,_)=>(___cxa_demangle=wasmExports.__cxa_demangle)(t,e,n,_),___gxx_personality_v0=Module.___gxx_personality_v0=(t,e,n,_,r)=>(___gxx_personality_v0=Module.___gxx_personality_v0=wasmExports.__gxx_personality_v0)(t,e,n,_,r),___thrown_object_from_unwind_exception=Module.___thrown_object_from_unwind_exception=t=>(___thrown_object_from_unwind_exception=Module.___thrown_object_from_unwind_exception=wasmExports.__thrown_object_from_unwind_exception)(t),___get_exception_message=Module.___get_exception_message=(t,e,n)=>(___get_exception_message=Module.___get_exception_message=wasmExports.__get_exception_message)(t,e,n),___get_exception_terminate_message=Module.___get_exception_terminate_message=t=>(___get_exception_terminate_message=Module.___get_exception_terminate_message=wasmExports.__get_exception_terminate_message)(t),___cxa_guard_acquire=Module.___cxa_guard_acquire=t=>(___cxa_guard_acquire=Module.___cxa_guard_acquire=wasmExports.__cxa_guard_acquire)(t),___cxa_guard_release=Module.___cxa_guard_release=t=>(___cxa_guard_release=Module.___cxa_guard_release=wasmExports.__cxa_guard_release)(t),___cxa_guard_abort=Module.___cxa_guard_abort=t=>(___cxa_guard_abort=Module.___cxa_guard_abort=wasmExports.__cxa_guard_abort)(t),___cxa_thread_atexit=Module.___cxa_thread_atexit=(t,e,n)=>(___cxa_thread_atexit=Module.___cxa_thread_atexit=wasmExports.__cxa_thread_atexit)(t,e,n),___cxa_deleted_virtual=Module.___cxa_deleted_virtual=()=>(___cxa_deleted_virtual=Module.___cxa_deleted_virtual=wasmExports.__cxa_deleted_virtual)(),___dynamic_cast=Module.___dynamic_cast=(t,e,n,_)=>(___dynamic_cast=Module.___dynamic_cast=wasmExports.__dynamic_cast)(t,e,n,_),___cxa_can_catch=(t,e,n)=>(___cxa_can_catch=wasmExports.__cxa_can_catch)(t,e,n),___cxa_is_pointer_type=t=>(___cxa_is_pointer_type=wasmExports.__cxa_is_pointer_type)(t),_shutdown=Module._shutdown=(t,e)=>(_shutdown=Module._shutdown=wasmExports.shutdown)(t,e),_socketpair=Module._socketpair=(t,e,n,_)=>(_socketpair=Module._socketpair=wasmExports.socketpair)(t,e,n,_),_py_docstring_mod=Module._py_docstring_mod=3885760,_PyExc_AttributeError=Module._PyExc_AttributeError=2762280,_stdout=Module._stdout=3739648,__Py_NoneStruct=Module.__Py_NoneStruct=2788148,_PyExc_TypeError=Module._PyExc_TypeError=2755832,_internal_error=Module._internal_error=3885764,_conversion_error=Module._conversion_error=3885768,_PyExc_ImportError=Module._PyExc_ImportError=2757288,_pyodide_export_=Module._pyodide_export_=2741400,_py_version_major_=Module._py_version_major_=2741404,_set_new_cframe_=Module._set_new_cframe_=2741408,__Py_TrueStruct=Module.__Py_TrueStruct=2744608,__Py_FalseStruct=Module.__Py_FalseStruct=2744624,_Jsr_undefined=Module._Jsr_undefined=243188,_PyExc_StopIteration=Module._PyExc_StopIteration=2756248,_PyTraceBack_Type=Module._PyTraceBack_Type=2984248,_PyExc_GeneratorExit=Module._PyExc_GeneratorExit=2756456,_PyExc_StopAsyncIteration=Module._PyExc_StopAsyncIteration=2756040,_PyExc_RuntimeError=Module._PyExc_RuntimeError=2761240,_PyExc_Exception=Module._PyExc_Exception=2755624,_PyExc_BaseException=Module._PyExc_BaseException=2755416,_PyExc_KeyError=Module._PyExc_KeyError=2763528,_PyExc_IndexError=Module._PyExc_IndexError=2763320,_PySlice_Type=Module._PySlice_Type=2793124,_PyExc_ValueError=Module._PyExc_ValueError=2763736,_PyExc_NotImplementedError=Module._PyExc_NotImplementedError=2761656,_PyBaseObject_Type=Module._PyBaseObject_Type=2794380,_PyExc_OverflowError=Module._PyExc_OverflowError=2765400,_PyList_Type=Module._PyList_Type=2778220,_PyTuple_Type=Module._PyTuple_Type=2793568,__Py_NotImplementedStruct=Module.__Py_NotImplementedStruct=2788924,_PyDict_Type=Module._PyDict_Type=2780504,_PyGen_Type=Module._PyGen_Type=2772124,_PyCoro_Type=Module._PyCoro_Type=2772328,_compat_to_string_repr=Module._compat_to_string_repr=3885824,_PyMethod_Type=Module._PyMethod_Type=2749192,_PyFunction_Type=Module._PyFunction_Type=2775828,_py_buffer_len_offset=Module._py_buffer_len_offset=2743468,_py_buffer_shape_offset=Module._py_buffer_shape_offset=2743472,_syncifyHandler=Module._syncifyHandler=3885852,_Jsr_true=Module._Jsr_true=243192,_Jsr_false=Module._Jsr_false=243196,_Jsr_novalue=Module._Jsr_novalue=243200,_PySet_Type=Module._PySet_Type=2791888,_PyFloat_Type=Module._PyFloat_Type=2774576,_PyBool_Type=Module._PyBool_Type=2744784,_size_of_cframe=Module._size_of_cframe=2743920,__PyParser_TokenNames=Module.__PyParser_TokenNames=2743936,_PyExc_SyntaxError=Module._PyExc_SyntaxError=2762488,__PyRuntime=Module.__PyRuntime=2810368,_PyExc_LookupError=Module._PyExc_LookupError=2763112,_PyExc_UnicodeDecodeError=Module._PyExc_UnicodeDecodeError=2764360,_PyExc_IndentationError=Module._PyExc_IndentationError=2762696,_PyExc_KeyboardInterrupt=Module._PyExc_KeyboardInterrupt=2757080,_PyExc_TabError=Module._PyExc_TabError=2762904,_PyExc_UnicodeError=Module._PyExc_UnicodeError=2763944,_stdin=Module._stdin=3739496,_PyComplex_Type=Module._PyComplex_Type=2751180,__Py_EllipsisObject=Module.__Py_EllipsisObject=2793116,_PyExc_SystemError=Module._PyExc_SystemError=2765816,__Py_ctype_table=Module.__Py_ctype_table=434496,_PyExc_DeprecationWarning=Module._PyExc_DeprecationWarning=2767064,__PyOS_ReadlineTState=Module.__PyOS_ReadlineTState=3885912,_stderr=Module._stderr=3739344,_PyOS_InputHook=Module._PyOS_InputHook=3885916,_PyOS_ReadlineFunctionPointer=Module._PyOS_ReadlineFunctionPointer=3885920,_PyExc_MemoryError=Module._PyExc_MemoryError=2766232,_PyExc_SyntaxWarning=Module._PyExc_SyntaxWarning=2767480,_PyExc_OSError=Module._PyExc_OSError=2757704,_PyType_Type=Module._PyType_Type=2794176,_PyExc_BufferError=Module._PyExc_BufferError=2766440,_PyUnicode_Type=Module._PyUnicode_Type=2798536,_PyLong_Type=Module._PyLong_Type=2779324,_PyCFunction_Type=Module._PyCFunction_Type=2786872,_PyByteArray_Type=Module._PyByteArray_Type=2744988,__PyByteArray_empty_string=Module.__PyByteArray_empty_string=3885928,__Py_ctype_tolower=Module.__Py_ctype_tolower=435520,__Py_ctype_toupper=Module.__Py_ctype_toupper=435776,_Py_hexdigits=Module._Py_hexdigits=2806616,_PyExc_BytesWarning=Module._PyExc_BytesWarning=2768520,_PyByteArrayIter_Type=Module._PyByteArrayIter_Type=2746352,_PyBytes_Type=Module._PyBytes_Type=2746948,__PyLong_DigitValue=Module.__PyLong_DigitValue=2779536,_PyBytesIter_Type=Module._PyBytesIter_Type=2748080,_PyCapsule_Type=Module._PyCapsule_Type=2748740,_PyCell_Type=Module._PyCell_Type=2748944,_PyInstanceMethod_Type=Module._PyInstanceMethod_Type=2749544,_PyCode_Type=Module._PyCode_Type=2749848,_PyFrozenSet_Type=Module._PyFrozenSet_Type=2792448,_PyExc_ZeroDivisionError=Module._PyExc_ZeroDivisionError=2765608,__PyMethodWrapper_Type=Module.__PyMethodWrapper_Type=2753560,_PyMethodDescr_Type=Module._PyMethodDescr_Type=2751904,_PyClassMethodDescr_Type=Module._PyClassMethodDescr_Type=2752108,_PyMemberDescr_Type=Module._PyMemberDescr_Type=2752380,_PyGetSetDescr_Type=Module._PyGetSetDescr_Type=2752652,_PyWrapperDescr_Type=Module._PyWrapperDescr_Type=2752944,_PyDictProxy_Type=Module._PyDictProxy_Type=2753148,_PyProperty_Type=Module._PyProperty_Type=2754328,_PyReversed_Type=Module._PyReversed_Type=2754960,_PyEnum_Type=Module._PyEnum_Type=2754688,_PyExc_BaseExceptionGroup=Module._PyExc_BaseExceptionGroup=2756668,_PyExc_UnicodeTranslateError=Module._PyExc_UnicodeTranslateError=2764568,_PyExc_BlockingIOError=Module._PyExc_BlockingIOError=2757912,_PyExc_BrokenPipeError=Module._PyExc_BrokenPipeError=2758536,_PyExc_ChildProcessError=Module._PyExc_ChildProcessError=2758328,_PyExc_ConnectionAbortedError=Module._PyExc_ConnectionAbortedError=2758744,_PyExc_ConnectionRefusedError=Module._PyExc_ConnectionRefusedError=2758952,_PyExc_ConnectionResetError=Module._PyExc_ConnectionResetError=2759160,_PyExc_FileExistsError=Module._PyExc_FileExistsError=2759368,_PyExc_FileNotFoundError=Module._PyExc_FileNotFoundError=2759576,_PyExc_IsADirectoryError=Module._PyExc_IsADirectoryError=2759784,_PyExc_NotADirectoryError=Module._PyExc_NotADirectoryError=2759992,_PyExc_InterruptedError=Module._PyExc_InterruptedError=2760200,_PyExc_PermissionError=Module._PyExc_PermissionError=2760408,_PyExc_ProcessLookupError=Module._PyExc_ProcessLookupError=2760616,_PyExc_TimeoutError=Module._PyExc_TimeoutError=2760824,_PyExc_EnvironmentError=Module._PyExc_EnvironmentError=3885932,_PyExc_IOError=Module._PyExc_IOError=3885936,_PyExc_SystemExit=Module._PyExc_SystemExit=2756664,_PyExc_ModuleNotFoundError=Module._PyExc_ModuleNotFoundError=2757496,_PyExc_ConnectionError=Module._PyExc_ConnectionError=2758120,_PyExc_EOFError=Module._PyExc_EOFError=2761032,_PyExc_RecursionError=Module._PyExc_RecursionError=2761448,_PyExc_NameError=Module._PyExc_NameError=2761864,_PyExc_UnboundLocalError=Module._PyExc_UnboundLocalError=2762072,_PyExc_UnicodeEncodeError=Module._PyExc_UnicodeEncodeError=2764152,_PyExc_AssertionError=Module._PyExc_AssertionError=2764776,_PyExc_ArithmeticError=Module._PyExc_ArithmeticError=2764984,_PyExc_FloatingPointError=Module._PyExc_FloatingPointError=2765192,_PyExc_ReferenceError=Module._PyExc_ReferenceError=2766024,_PyExc_Warning=Module._PyExc_Warning=2766648,_PyExc_UserWarning=Module._PyExc_UserWarning=2766856,_PyExc_PendingDeprecationWarning=Module._PyExc_PendingDeprecationWarning=2767272,_PyExc_RuntimeWarning=Module._PyExc_RuntimeWarning=2767688,_PyExc_FutureWarning=Module._PyExc_FutureWarning=2767896,_PyExc_ImportWarning=Module._PyExc_ImportWarning=2768104,_PyExc_UnicodeWarning=Module._PyExc_UnicodeWarning=2768312,_PyExc_EncodingWarning=Module._PyExc_EncodingWarning=2768728,_PyExc_ResourceWarning=Module._PyExc_ResourceWarning=2768936,_Py_GenericAliasType=Module._Py_GenericAliasType=2771372,_PyAsyncGen_Type=Module._PyAsyncGen_Type=2771632,__PyAsyncGenWrappedValue_Type=Module.__PyAsyncGenWrappedValue_Type=2773692,__PyCoroWrapper_Type=Module.__PyCoroWrapper_Type=2772912,__PyAsyncGenASend_Type=Module.__PyAsyncGenASend_Type=2773488,__PyAsyncGenAThrow_Type=Module.__PyAsyncGenAThrow_Type=2773984,_PyStdPrinter_Type=Module._PyStdPrinter_Type=2774188,__Py_SwappedOp=Module.__Py_SwappedOp=2788160,_PyFrame_Type=Module._PyFrame_Type=2775604,_PyModule_Type=Module._PyModule_Type=2787492,_PyClassMethod_Type=Module._PyClassMethod_Type=2776460,_PyStaticMethod_Type=Module._PyStaticMethod_Type=2776796,__PyInterpreterID_Type=Module.__PyInterpreterID_Type=2777212,_PySeqIter_Type=Module._PySeqIter_Type=2777428,_PyCallIter_Type=Module._PyCallIter_Type=2777696,_PyListIter_Type=Module._PyListIter_Type=2778800,_PyListRevIter_Type=Module._PyListRevIter_Type=2779072,_PyDictIterKey_Type=Module._PyDictIterKey_Type=2781232,_PyDictRevIterKey_Type=Module._PyDictRevIterKey_Type=2781844,_PyDictRevIterValue_Type=Module._PyDictRevIterValue_Type=2782252,_PyDictKeys_Type=Module._PyDictKeys_Type=2782456,_PyDictItems_Type=Module._PyDictItems_Type=2782660,_PyDictIterItem_Type=Module._PyDictIterItem_Type=2781640,_PyDictIterValue_Type=Module._PyDictIterValue_Type=2781436,_PyDictRevIterItem_Type=Module._PyDictRevIterItem_Type=2782048,_PyDictValues_Type=Module._PyDictValues_Type=2783312,_PyODict_Type=Module._PyODict_Type=2783992,_PyODictIter_Type=Module._PyODictIter_Type=2784240,_PyODictKeys_Type=Module._PyODictKeys_Type=2784480,_PyODictValues_Type=Module._PyODictValues_Type=2784960,_PyODictItems_Type=Module._PyODictItems_Type=2784720,__PyManagedBuffer_Type=Module.__PyManagedBuffer_Type=2785400,_PyMemoryView_Type=Module._PyMemoryView_Type=2785604,_PyCMethod_Type=Module._PyCMethod_Type=2786668,_PyModuleDef_Type=Module._PyModuleDef_Type=2787288,__Py_PackageContext=Module.__Py_PackageContext=3887924,__PyNamespace_Type=Module.__PyNamespace_Type=2787944,__Py_tracemalloc_config=Module.__Py_tracemalloc_config=2789400,__PyNone_Type=Module.__PyNone_Type=2788328,__PyNotImplemented_Type=Module.__PyNotImplemented_Type=2788720,_PyContextToken_Type=Module._PyContextToken_Type=2807192,_PyContextVar_Type=Module._PyContextVar_Type=2806988,_PyContext_Type=Module._PyContext_Type=2806784,_PyEllipsis_Type=Module._PyEllipsis_Type=2792912,_PyFilter_Type=Module._PyFilter_Type=2804576,_PyLongRangeIter_Type=Module._PyLongRangeIter_Type=2790880,_PyMap_Type=Module._PyMap_Type=2804816,_PyPickleBuffer_Type=Module._PyPickleBuffer_Type=2789696,_PyRangeIter_Type=Module._PyRangeIter_Type=2790608,_PyRange_Type=Module._PyRange_Type=2790336,_PySetIter_Type=Module._PySetIter_Type=2791136,_PySuper_Type=Module._PySuper_Type=2798112,_PyTupleIter_Type=Module._PyTupleIter_Type=2793904,_PyUnicodeIter_Type=Module._PyUnicodeIter_Type=2800448,_PyZip_Type=Module._PyZip_Type=2805072,__PyWeakref_CallableProxyType=Module.__PyWeakref_CallableProxyType=2802508,__PyWeakref_ProxyType=Module.__PyWeakref_ProxyType=2802304,__PyWeakref_RefType=Module.__PyWeakref_RefType=2801848,__PySet_Dummy=Module.__PySet_Dummy=2792660,_PyStructSequence_UnnamedField=Module._PyStructSequence_UnnamedField=2793476,__Py_ascii_whitespace=Module.__Py_ascii_whitespace=289472,_Py_VerboseFlag=Module._Py_VerboseFlag=3887852,_Py_Version=Module._Py_Version=419860,_PyImport_Inittab=Module._PyImport_Inittab=2809696,__PyImport_FrozenBootstrap=Module.__PyImport_FrozenBootstrap=3734576,_PyImport_FrozenModules=Module._PyImport_FrozenModules=3901984,__PyImport_FrozenStdlib=Module.__PyImport_FrozenStdlib=3734912,__PyImport_FrozenTest=Module.__PyImport_FrozenTest=3735168,_Py_IgnoreEnvironmentFlag=Module._Py_IgnoreEnvironmentFlag=3887884,_Py_IsolatedFlag=Module._Py_IsolatedFlag=3887904,_Py_BytesWarningFlag=Module._Py_BytesWarningFlag=3887876,_Py_InspectFlag=Module._Py_InspectFlag=3887864,_Py_InteractiveFlag=Module._Py_InteractiveFlag=3887860,_Py_OptimizeFlag=Module._Py_OptimizeFlag=3887868,_Py_DebugFlag=Module._Py_DebugFlag=3887848,_Py_QuietFlag=Module._Py_QuietFlag=3887856,_Py_FrozenFlag=Module._Py_FrozenFlag=3887880,_Py_UnbufferedStdioFlag=Module._Py_UnbufferedStdioFlag=3887896,_Py_NoSiteFlag=Module._Py_NoSiteFlag=3887872,_Py_DontWriteBytecodeFlag=Module._Py_DontWriteBytecodeFlag=3887888,_Py_NoUserSiteDirectory=Module._Py_NoUserSiteDirectory=3887892,_Py_HashRandomizationFlag=Module._Py_HashRandomizationFlag=3887900,_Py_FileSystemDefaultEncoding=Module._Py_FileSystemDefaultEncoding=3887964,_Py_HasFileSystemDefaultEncoding=Module._Py_HasFileSystemDefaultEncoding=3887968,_Py_FileSystemDefaultEncodeErrors=Module._Py_FileSystemDefaultEncodeErrors=3887972,__Py_HasFileSystemDefaultEncodeErrors=Module.__Py_HasFileSystemDefaultEncodeErrors=3887976,_Py_UTF8Mode=Module._Py_UTF8Mode=3887844,__Py_HashSecret=Module.__Py_HashSecret=3887984,__Py_UnhandledKeyboardInterrupt=Module.__Py_UnhandledKeyboardInterrupt=3888008,_Py_EMSCRIPTEN_SIGNAL_HANDLING=Module._Py_EMSCRIPTEN_SIGNAL_HANDLING=3891616,_ffi_type_pointer=Module._ffi_type_pointer=2389412,_ffi_type_void=Module._ffi_type_void=2389304,_ffi_type_sint32=Module._ffi_type_sint32=2389376,_ffi_type_uint8=Module._ffi_type_uint8=2389316,_ffi_type_double=Module._ffi_type_double=2389436,_ffi_type_longdouble=Module._ffi_type_longdouble=2389448,_ffi_type_float=Module._ffi_type_float=2389424,_ffi_type_sint16=Module._ffi_type_sint16=2389352,_ffi_type_uint16=Module._ffi_type_uint16=2389340,_ffi_type_uint32=Module._ffi_type_uint32=2389364,_ffi_type_sint64=Module._ffi_type_sint64=2389400,_ffi_type_uint64=Module._ffi_type_uint64=2389388,_ffi_type_sint8=Module._ffi_type_sint8=2389328,_environ=Module._environ=3902008,__PyBytesIOBuffer_Type=Module.__PyBytesIOBuffer_Type=3106108,__deduplicate_map=Module.__deduplicate_map=3901988,_z_errmsg=Module._z_errmsg=3735472,__length_code=Module.__length_code=2400064,__dist_code=Module.__dist_code=2399552,_deflate_copyright=Module._deflate_copyright=2394720,_inflate_copyright=Module._inflate_copyright=2399248,_BZ2_crc32Table=Module._BZ2_crc32Table=3735584,_BZ2_rNums=Module._BZ2_rNums=3736608,___environ=Module.___environ=3902008,____environ=Module.____environ=3902008,__environ=Module.__environ=3902008,_timezone=Module._timezone=3902664,_daylight=Module._daylight=3902668,_tzname=Module._tzname=3902672,___progname=Module.___progname=3903888,___optreset=Module.___optreset=3902852,_optind=Module._optind=3738872,___optpos=Module.___optpos=3902856,_optarg=Module._optarg=3902860,_optopt=Module._optopt=3902864,_opterr=Module._opterr=3738876,_optreset=Module._optreset=3902852,_h_errno=Module._h_errno=3902988,___signgam=Module.___signgam=3918284,__ns_flagdata=Module.__ns_flagdata=2587040,___progname_full=Module.___progname_full=3903892,_program_invocation_short_name=Module._program_invocation_short_name=3903888,_program_invocation_name=Module._program_invocation_name=3903892,___sig_pending=Module.___sig_pending=3908264,___sig_actions=Module.___sig_actions=3909184,_signgam=Module._signgam=3918284,___THREW__=Module.___THREW__=3925120,___threwValue=Module.___threwValue=3925124,___cxa_unexpected_handler=Module.___cxa_unexpected_handler=3750032,___cxa_terminate_handler=Module.___cxa_terminate_handler=3750028,___cxa_new_handler=Module.___cxa_new_handler=3948040,_in6addr_any=Module._in6addr_any=2741292,_in6addr_loopback=Module._in6addr_loopback=2741308,___start_em_js=Module.___start_em_js=3757008,___stop_em_js=Module.___stop_em_js=3885483;function invoke_iiii(t,e,n,_){var r=stackSave();try{return getWasmTableEntry(t)(e,n,_)}catch(a){if(stackRestore(r),a!==a+0)throw a;_setThrew(1,0)}}function invoke_iii(t,e,n){var _=stackSave();try{return getWasmTableEntry(t)(e,n)}catch(r){if(stackRestore(_),r!==r+0)throw r;_setThrew(1,0)}}function invoke_i(t){var e=stackSave();try{return getWasmTableEntry(t)()}catch(n){if(stackRestore(e),n!==n+0)throw n;_setThrew(1,0)}}function invoke_viiifi(t,e,n,_,r,a){var o=stackSave();try{getWasmTableEntry(t)(e,n,_,r,a)}catch(l){if(stackRestore(o),l!==l+0)throw l;_setThrew(1,0)}}function invoke_viiidi(t,e,n,_,r,a){var o=stackSave();try{getWasmTableEntry(t)(e,n,_,r,a)}catch(l){if(stackRestore(o),l!==l+0)throw l;_setThrew(1,0)}}function invoke_viiii(t,e,n,_,r){var a=stackSave();try{getWasmTableEntry(t)(e,n,_,r)}catch(o){if(stackRestore(a),o!==o+0)throw o;_setThrew(1,0)}}function invoke_ii(t,e){var n=stackSave();try{return getWasmTableEntry(t)(e)}catch(_){if(stackRestore(n),_!==_+0)throw _;_setThrew(1,0)}}function invoke_j(t){var e=stackSave();try{return getWasmTableEntry(t)()}catch(n){if(stackRestore(e),n!==n+0)throw n;return _setThrew(1,0),0n}}function invoke_ji(t,e){var n=stackSave();try{return getWasmTableEntry(t)(e)}catch(_){if(stackRestore(n),_!==_+0)throw _;return _setThrew(1,0),0n}}function invoke_vii(t,e,n){var _=stackSave();try{getWasmTableEntry(t)(e,n)}catch(r){if(stackRestore(_),r!==r+0)throw r;_setThrew(1,0)}}function invoke_jii(t,e,n){var _=stackSave();try{return getWasmTableEntry(t)(e,n)}catch(r){if(stackRestore(_),r!==r+0)throw r;return _setThrew(1,0),0n}}function invoke_v(t){var e=stackSave();try{getWasmTableEntry(t)()}catch(n){if(stackRestore(e),n!==n+0)throw n;_setThrew(1,0)}}function invoke_viii(t,e,n,_){var r=stackSave();try{getWasmTableEntry(t)(e,n,_)}catch(a){if(stackRestore(r),a!==a+0)throw a;_setThrew(1,0)}}function invoke_iiiii(t,e,n,_,r){var a=stackSave();try{return getWasmTableEntry(t)(e,n,_,r)}catch(o){if(stackRestore(a),o!==o+0)throw o;_setThrew(1,0)}}function invoke_vi(t,e){var n=stackSave();try{getWasmTableEntry(t)(e)}catch(_){if(stackRestore(n),_!==_+0)throw _;_setThrew(1,0)}}function invoke_viiiii(t,e,n,_,r,a){var o=stackSave();try{getWasmTableEntry(t)(e,n,_,r,a)}catch(l){if(stackRestore(o),l!==l+0)throw l;_setThrew(1,0)}}function invoke_iiiiii(t,e,n,_,r,a){var o=stackSave();try{return getWasmTableEntry(t)(e,n,_,r,a)}catch(l){if(stackRestore(o),l!==l+0)throw l;_setThrew(1,0)}}function invoke_iiiiiii(t,e,n,_,r,a,o){var l=stackSave();try{return getWasmTableEntry(t)(e,n,_,r,a,o)}catch(p){if(stackRestore(l),p!==p+0)throw p;_setThrew(1,0)}}function invoke_viijii(t,e,n,_,r,a){var o=stackSave();try{getWasmTableEntry(t)(e,n,_,r,a)}catch(l){if(stackRestore(o),l!==l+0)throw l;_setThrew(1,0)}}function invoke_iiiiij(t,e,n,_,r,a){var o=stackSave();try{return getWasmTableEntry(t)(e,n,_,r,a)}catch(l){if(stackRestore(o),l!==l+0)throw l;_setThrew(1,0)}}function invoke_iiiiid(t,e,n,_,r,a){var o=stackSave();try{return getWasmTableEntry(t)(e,n,_,r,a)}catch(l){if(stackRestore(o),l!==l+0)throw l;_setThrew(1,0)}}function invoke_iiiiijj(t,e,n,_,r,a,o){var l=stackSave();try{return getWasmTableEntry(t)(e,n,_,r,a,o)}catch(p){if(stackRestore(l),p!==p+0)throw p;_setThrew(1,0)}}function invoke_iiiiiiii(t,e,n,_,r,a,o,l){var p=stackSave();try{return getWasmTableEntry(t)(e,n,_,r,a,o,l)}catch(c){if(stackRestore(p),c!==c+0)throw c;_setThrew(1,0)}}function invoke_iiiiiiiiiii(t,e,n,_,r,a,o,l,p,c,I){var A=stackSave();try{return getWasmTableEntry(t)(e,n,_,r,a,o,l,p,c,I)}catch(m){if(stackRestore(A),m!==m+0)throw m;_setThrew(1,0)}}function invoke_jiiii(t,e,n,_,r){var a=stackSave();try{return getWasmTableEntry(t)(e,n,_,r)}catch(o){if(stackRestore(a),o!==o+0)throw o;return _setThrew(1,0),0n}}function invoke_iiiiiiiiiiiii(t,e,n,_,r,a,o,l,p,c,I,A,m){var E=stackSave();try{return getWasmTableEntry(t)(e,n,_,r,a,o,l,p,c,I,A,m)}catch(f){if(stackRestore(E),f!==f+0)throw f;_setThrew(1,0)}}function invoke_fiii(t,e,n,_){var r=stackSave();try{return getWasmTableEntry(t)(e,n,_)}catch(a){if(stackRestore(r),a!==a+0)throw a;_setThrew(1,0)}}function invoke_diii(t,e,n,_){var r=stackSave();try{return getWasmTableEntry(t)(e,n,_)}catch(a){if(stackRestore(r),a!==a+0)throw a;_setThrew(1,0)}}function invoke_viiiiiii(t,e,n,_,r,a,o,l){var p=stackSave();try{getWasmTableEntry(t)(e,n,_,r,a,o,l)}catch(c){if(stackRestore(p),c!==c+0)throw c;_setThrew(1,0)}}function invoke_iiiiiiiiiiii(t,e,n,_,r,a,o,l,p,c,I,A){var m=stackSave();try{return getWasmTableEntry(t)(e,n,_,r,a,o,l,p,c,I,A)}catch(E){if(stackRestore(m),E!==E+0)throw E;_setThrew(1,0)}}function invoke_viiiiiiiiii(t,e,n,_,r,a,o,l,p,c,I){var A=stackSave();try{getWasmTableEntry(t)(e,n,_,r,a,o,l,p,c,I)}catch(m){if(stackRestore(A),m!==m+0)throw m;_setThrew(1,0)}}function invoke_viiiiiiiiiiiiiii(t,e,n,_,r,a,o,l,p,c,I,A,m,E,f,R){var h=stackSave();try{getWasmTableEntry(t)(e,n,_,r,a,o,l,p,c,I,A,m,E,f,R)}catch(w){if(stackRestore(h),w!==w+0)throw w;_setThrew(1,0)}}function invoke_viiiiii(t,e,n,_,r,a,o){var l=stackSave();try{getWasmTableEntry(t)(e,n,_,r,a,o)}catch(p){if(stackRestore(l),p!==p+0)throw p;_setThrew(1,0)}}function invoke_jiii(t,e,n,_){var r=stackSave();try{return getWasmTableEntry(t)(e,n,_)}catch(a){if(stackRestore(r),a!==a+0)throw a;return _setThrew(1,0),0n}}function invoke_viif(t,e,n,_){var r=stackSave();try{getWasmTableEntry(t)(e,n,_)}catch(a){if(stackRestore(r),a!==a+0)throw a;_setThrew(1,0)}}function invoke_viid(t,e,n,_){var r=stackSave();try{getWasmTableEntry(t)(e,n,_)}catch(a){if(stackRestore(r),a!==a+0)throw a;_setThrew(1,0)}}function invoke_viijj(t,e,n,_,r){var a=stackSave();try{getWasmTableEntry(t)(e,n,_,r)}catch(o){if(stackRestore(a),o!==o+0)throw o;_setThrew(1,0)}}function intArrayFromBase64(t){if(typeof ENVIRONMENT_IS_NODE<"u"&&ENVIRONMENT_IS_NODE){var e=Buffer.from(t,"base64");return new Uint8Array(e.buffer,e.byteOffset,e.length)}try{for(var n=atob(t),_=new Uint8Array(n.length),r=0;r<n.length;++r)_[r]=n.charCodeAt(r);return _}catch{throw new Error("Converting base64 string to bytes failed.")}}function tryParseAsDataURI(t){if(isDataURI(t))return intArrayFromBase64(t.slice(dataURIPrefix.length))}Module.addRunDependency=addRunDependency,Module.removeRunDependency=removeRunDependency,Module.FS_createPath=FS.createPath,Module.FS_createLazyFile=FS.createLazyFile,Module.FS_createDevice=FS.createDevice,Module.ERRNO_CODES=ERRNO_CODES,Module.wasmTable=wasmTable,Module.FS_createPreloadedFile=FS.createPreloadedFile,Module.FS_createDataFile=FS.createDataFile,Module.FS_unlink=FS.unlink,Module.LZ4=LZ4;var calledRun;dependenciesFulfilled=function t(){calledRun||run(),calledRun||(dependenciesFulfilled=t)};function callMain(t=[]){var e=resolveGlobalSymbol("main").sym;if(e){t.unshift(thisProgram);var n=t.length,_=stackAlloc((n+1)*4),r=_;t.forEach(o=>{HEAPU32[r>>2]=stringToUTF8OnStack(o),r+=4}),HEAPU32[r>>2]=0;try{var a=e(n,_);return exitJS(a,!0),a}catch(o){return handleException(o)}}}function run(t=arguments_){if(runDependencies>0||(preRun(),runDependencies>0))return;function e(){calledRun||(calledRun=!0,Module.calledRun=!0,!ABORT&&(initRuntime(),preMain(),readyPromiseResolve(Module),Module.onRuntimeInitialized&&Module.onRuntimeInitialized(),shouldRunNow&&callMain(t),postRun()))}Module.setStatus?(Module.setStatus("Running..."),setTimeout(function(){setTimeout(function(){Module.setStatus("")},1),e()},1)):e()}if(Module.preInit)for(typeof Module.preInit=="function"&&(Module.preInit=[Module.preInit]);Module.preInit.length>0;)Module.preInit.pop()();var shouldRunNow=!0;return Module.noInitialRun&&(shouldRunNow=!1),run(),moduleArg.ready}})();globalThis._createPyodideModule=_createPyodideModule});var u_={};z_(u_,{filesystem:()=>dr,modules:()=>lr});var lr,dr,c_=G_(()=>{lr={"yosys.core.wasm":new URL("./yosys.core-69e2380c.wasm?hash=69e2380c",import.meta.url),"yosys.core2.wasm":new URL("./yosys.core2-adde1f05.wasm?hash=adde1f05",import.meta.url),"yosys.core3.wasm":new URL("./yosys.core3-2e432872.wasm?hash=2e432872",import.meta.url),"yosys.core4.wasm":new URL("./yosys.core4-7eacd1f7.wasm?hash=7eacd1f7",import.meta.url)},dr={share:{"abc9_map.v":`\`ifdef DFF
(* techmap_celltype = "$_DFF_[PN]_" *)
module $_DFF_x_(input C, D, output Q);
  parameter [0:0] _TECHMAP_WIREINIT_Q_ = 1'bx;
  parameter _TECHMAP_CELLTYPE_ = "";
  wire D_;
  generate if (_TECHMAP_CELLTYPE_ == "$_DFF_N_") begin
    if (_TECHMAP_WIREINIT_Q_ === 1'b0) begin
      $__DFF_N__$abc9_flop _TECHMAP_REPLACE_ (.C(C), .D(D), .Q(Q), .n1(D_));
      $_DFF_N_ ff (.C(C), .D(D_), .Q(Q));
    end
    else
      (* abc9_keep *) $_DFF_N_ _TECHMAP_REPLACE_ (.C(C), .D(D), .Q(Q));
  end
  else if (_TECHMAP_CELLTYPE_ == "$_DFF_P_") begin
    if (_TECHMAP_WIREINIT_Q_ === 1'b0) begin
      $__DFF_P__$abc9_flop _TECHMAP_REPLACE_ (.C(C), .D(D), .Q(Q), .n1(D_));
      $_DFF_P_ ff (.C(C), .D(D_), .Q(Q));
    end
    else
      (* abc9_keep *) $_DFF_P_ _TECHMAP_REPLACE_ (.C(C), .D(D), .Q(Q));
  end
  else if (_TECHMAP_CELLTYPE_ != "")
    $error("Unrecognised _TECHMAP_CELLTYPE_");
  endgenerate
endmodule
\`endif
`,"abc9_model.v":`(* abc9_box *)
module $__ABC9_DELAY (input I, output O);
  parameter DELAY = 0;
  specify
    (I => O) = DELAY;
  endspecify
endmodule

module $__ABC9_SCC_BREAKER (input [WIDTH-1:0] I, output [WIDTH-1:0] O);
parameter WIDTH = 0;
endmodule

(* abc9_flop, abc9_box, lib_whitebox *)
module $__DFF_N__$abc9_flop (input C, D, Q, output n1);
  assign n1 = D;
  specify
    $setup(D, posedge C, 0);
    (posedge C => (n1:D)) = 0;
  endspecify
endmodule

(* abc9_flop, abc9_box, lib_whitebox *)
module $__DFF_P__$abc9_flop (input C, D, Q, output n1);
  assign n1 = D;
  specify
    $setup(D, posedge C, 0);
    (posedge C => (n1:D)) = 0;
  endspecify
endmodule
`,"abc9_unmap.v":`(* techmap_celltype = "$__DFF_N__$abc9_flop $__DFF_P__$abc9_flop" *)
module $__DFF_x__$abc9_flop (input C, D, (* init = 1'b0 *) input Q, output n1);
  parameter _TECHMAP_CELLTYPE_ = "";
  generate if (_TECHMAP_CELLTYPE_ == "$__DFF_N__$abc9_flop")
    $_DFF_N_ _TECHMAP_REPLACE_ (.C(C), .D(D), .Q(Q));
  else if (_TECHMAP_CELLTYPE_ == "$__DFF_P__$abc9_flop")
    $_DFF_P_ _TECHMAP_REPLACE_ (.C(C), .D(D), .Q(Q));
  else if (_TECHMAP_CELLTYPE_ != "")
    $error("Unrecognised _TECHMAP_CELLTYPE_");
  endgenerate
endmodule

module $__ABC9_SCC_BREAKER (input [WIDTH-1:0] I, output [WIDTH-1:0] O);
parameter WIDTH = 0;
assign O = I;
endmodule
`,achronix:{speedster22i:{"cells_map.v":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */
// > c60k28 (Viacheslav, VT) [at] yandex [dot] com
// > Achronix eFPGA technology mapping. User must first simulate the generated \\
// > netlist before going to test it on board/custom chip.

// > Input/Output buffers <
// Input buffer map
module \\$__inpad (input I, output O);
    PADIN _TECHMAP_REPLACE_ (.padout(O), .padin(I));
endmodule
// Output buffer map
module \\$__outpad (input I, output O);
    PADOUT _TECHMAP_REPLACE_ (.padout(O), .padin(I), .oe(1'b1));
endmodule
// > end buffers <

// > Look-Up table <
// > VT: I still think Achronix folks would have chosen a better \\
// >     logic architecture.
// LUT Map
module \\$lut (A, Y);
   parameter WIDTH  = 0;
   parameter LUT    = 0;
   (* force_downto *)
   input [WIDTH-1:0] A;
   output 	     Y;
   generate
      if (WIDTH == 1) begin
	   // VT: This is not consistent and ACE will complain: assign Y = ~A[0];
         LUT4 #(.lut_function({4{LUT}})) _TECHMAP_REPLACE_
           (.dout(Y), .din0(A[0]), .din1(1'b0), .din2(1'b0), .din3(1'b0));
      end else
      if (WIDTH == 2) begin
              LUT4 #(.lut_function({4{LUT}})) _TECHMAP_REPLACE_
                (.dout(Y), .din0(A[0]), .din1(A[1]), .din2(1'b0), .din3(1'b0));
      end else
      if(WIDTH == 3) begin
	      LUT4 #(.lut_function({2{LUT}})) _TECHMAP_REPLACE_
                (.dout(Y), .din0(A[0]), .din1(A[1]), .din2(A[2]), .din3(1'b0));
      end else
      if(WIDTH == 4) begin
             LUT4 #(.lut_function(LUT)) _TECHMAP_REPLACE_
               (.dout(Y), .din0(A[0]), .din1(A[1]), .din2(A[2]), .din3(A[3]));
      end else
	   wire _TECHMAP_FAIL_ = 1;
   endgenerate
endmodule
// > end LUT <

// > Flops <
// DFF flop
module  \\$_DFF_P_ (input D, C, output Q);
   DFF _TECHMAP_REPLACE_
     (.q(Q), .d(D), .ck(C));
endmodule

`,"cells_sim.v":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */
// > c60k28 (Viacheslav, VT) [at] yandex [dot] com
// > Achronix eFPGA technology sim models. User must first simulate the generated \\
// > netlist before going to test it on board/custom chip.
// > Changelog: 1) Removed unused VCC/GND modules
// >            2) Altera comments here (?). Removed.
// >            3) Reusing LUT sim model, removed wrong wires and parameters.

module PADIN (output padout, input padin);
   assign padout = padin;
endmodule

module PADOUT (output padout, input padin, input oe);
   assign padout  = padin;
   assign oe = oe;
endmodule

module LUT4 (output dout,
             input  din0, din1, din2, din3);

parameter [15:0] lut_function = 16'hFFFF;
reg combout_rt;
wire dataa_w;
wire datab_w;
wire datac_w;
wire datad_w;

assign dataa_w = din0;
assign datab_w = din1;
assign datac_w = din2;
assign datad_w = din3;

function lut_data;
input [15:0] mask;
input        dataa, datab, datac, datad;
reg [7:0]   s3;
reg [3:0]   s2;
reg [1:0]   s1;
  begin
       s3 = datad ? mask[15:8] : mask[7:0];
       s2 = datac ?   s3[7:4]  :   s3[3:0];
       s1 = datab ?   s2[3:2]  :   s2[1:0];
       lut_data = dataa ? s1[1] : s1[0];
  end
endfunction

always @(dataa_w or datab_w or datac_w or datad_w) begin
   combout_rt = lut_data(lut_function, dataa_w, datab_w,
                         datac_w, datad_w);
end
assign dout = combout_rt & 1'b1;
endmodule

module DFF (output reg q,
            input  d, ck);
   always @(posedge ck)
     q <= d;

endmodule



`}},"adff2dff.v":`(* techmap_celltype = "$adff" *)
module adff2dff (CLK, ARST, D, Q);
	parameter WIDTH = 1;
	parameter CLK_POLARITY = 1;
	parameter ARST_POLARITY = 1;
	parameter ARST_VALUE = 0;

	input CLK, ARST;
	(* force_downto *)
	input [WIDTH-1:0] D;
	(* force_downto *)
	output reg [WIDTH-1:0] Q;
	(* force_downto *)
	reg [WIDTH-1:0] NEXT_Q;

	wire [1023:0] _TECHMAP_DO_ = "proc;;";

	always @*
		if (ARST == ARST_POLARITY)
			NEXT_Q <= ARST_VALUE;
		else
			NEXT_Q <= D;

	if (CLK_POLARITY)
		always @(posedge CLK)
			Q <= NEXT_Q;
	else
		always @(negedge CLK)
			Q <= NEXT_Q;
endmodule
`,anlogic:{"arith_map.v":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2018  Miodrag Milanovic <micko@yosyshq.com>
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

(* techmap_celltype = "$alu" *)
module _80_anlogic_alu (A, B, CI, BI, X, Y, CO);
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;
	parameter A_WIDTH  = 1;
	parameter B_WIDTH  = 1;
	parameter Y_WIDTH  = 1;

	(* force_downto *)
	input [A_WIDTH-1:0] A;
	(* force_downto *)
	input [B_WIDTH-1:0] B;
	(* force_downto *)
	output [Y_WIDTH-1:0] X, Y;

	input CI, BI;
	(* force_downto *)
	output [Y_WIDTH-1:0] CO;
   
	wire CIx;
	(* force_downto *)
	wire [Y_WIDTH-1:0] COx;

	wire _TECHMAP_FAIL_ = Y_WIDTH <= 2;

	(* force_downto *)
	wire [Y_WIDTH-1:0] A_buf, B_buf;
	\\$pos #(.A_SIGNED(A_SIGNED), .A_WIDTH(A_WIDTH), .Y_WIDTH(Y_WIDTH)) A_conv (.A(A), .Y(A_buf));
	\\$pos #(.A_SIGNED(B_SIGNED), .A_WIDTH(B_WIDTH), .Y_WIDTH(Y_WIDTH)) B_conv (.A(B), .Y(B_buf));

	(* force_downto *)
	wire [Y_WIDTH-1:0] AA = A_buf;
	(* force_downto *)
	wire [Y_WIDTH-1:0] BB = BI ? ~B_buf : B_buf;
	(* force_downto *)
	wire [Y_WIDTH-1:0] C = { COx, CIx };

    wire dummy;
    AL_MAP_ADDER #(
    	.ALUTYPE("ADD_CARRY"))
    adder_cin  (
        .a(CI),
		.b(1'b0),
		.c(1'b0),
        .o({CIx, dummy})
	);

	genvar i;
	generate for (i = 0; i < Y_WIDTH; i = i + 1) begin: slice
	    AL_MAP_ADDER #(
            .ALUTYPE("ADD")
        ) adder_i (
            .a(AA[i]),
            .b(BB[i]),
            .c(C[i]),
            .o({COx[i],Y[i]})
        );

		wire cout;
		AL_MAP_ADDER #(
			.ALUTYPE("ADD"))
		adder_cout  (
			.a(1'b0),
			.b(1'b0),
			.c(COx[i]),
			.o({cout, CO[i]})
		);
	  end: slice	  
	endgenerate

   /* End implementation */
   assign X = AA ^ BB;
endmodule
`,"brams.txt":`ram block $__ANLOGIC_BRAM_TDP_ {
	abits 13;
	widths 1 2 4 9 per_port;
	cost 64;
	init no_undef;
	port srsw "A" "B" {
		clock anyedge;
		clken;
		portoption "WRITEMODE" "NORMAL" {
			rdwr no_change;
		}
		portoption "WRITEMODE" "WRITETHROUGH" {
			rdwr new;
		}
		portoption "WRITEMODE" "READBEFOREWRITE" {
			rdwr old;
		}
		option "RESETMODE" "SYNC" {
			rdsrst zero ungated block_wr;
		}
		option "RESETMODE" "ASYNC" {
			rdarst zero;
		}
		rdinit zero;
	}
}

ram block $__ANLOGIC_BRAM_SDP_ {
	abits 13;
	widths 1 2 4 9 18 per_port;
	byte 9;
	cost 64;
	init no_undef;
	port sr "R" {
		clock anyedge;
		clken;
		option "RESETMODE" "SYNC" {
			rdsrst zero ungated;
		}
		option "RESETMODE" "ASYNC" {
			rdarst zero;
		}
		rdinit zero;
	}
	port sw "W" {
		clock anyedge;
		clken;
	}
}

ram block $__ANLOGIC_BRAM32K_ {
	abits 12;
	widths 8 16 per_port;
	byte 8;
	cost 192;
	init no_undef;
	port srsw "A" "B" {
		clock anyedge;
		clken;
		portoption "WRITEMODE" "NORMAL" {
			rdwr no_change;
		}
		portoption "WRITEMODE" "WRITETHROUGH" {
			rdwr new;
		}
		# no reset - it doesn't really work without the pipeline
		# output registers
	}
}
`,"brams_map.v":`module $__ANLOGIC_BRAM_TDP_ (...);

parameter INIT = 0;
parameter OPTION_RESETMODE = "SYNC";

parameter PORT_A_WIDTH = 9;
parameter PORT_A_CLK_POL = 1;
parameter PORT_A_OPTION_WRITEMODE = "NORMAL";

input PORT_A_CLK;
input PORT_A_CLK_EN;
input PORT_A_WR_EN;
input PORT_A_RD_SRST;
input PORT_A_RD_ARST;
input [12:0] PORT_A_ADDR;
input [PORT_A_WIDTH-1:0] PORT_A_WR_DATA;
output [PORT_A_WIDTH-1:0] PORT_A_RD_DATA;

parameter PORT_B_WIDTH = 9;
parameter PORT_B_CLK_POL = 1;
parameter PORT_B_OPTION_WRITEMODE = "NORMAL";

input PORT_B_CLK;
input PORT_B_CLK_EN;
input PORT_B_WR_EN;
input PORT_B_RD_SRST;
input PORT_B_RD_ARST;
input [12:0] PORT_B_ADDR;
input [PORT_B_WIDTH-1:0] PORT_B_WR_DATA;
output [PORT_B_WIDTH-1:0] PORT_B_RD_DATA;

function [255:0] init_slice;
	input integer idx;
	integer i;
	for (i = 0; i < 32; i = i + 1) begin
		init_slice[i*8+:8] = INIT[(idx * 32 + i) * 9 +: 8];
	end
endfunction

function [255:0] initp_slice;
	input integer idx;
	integer i;
	for (i = 0; i < 256; i = i + 1) begin
		initp_slice[i] = INIT[(idx * 256 + i) * 9 + 8];
	end
endfunction

wire [8:0] DOA;
wire [8:0] DOB;
// the replication is important \u2014 the BRAM behaves in... unexpected ways for
// width 1 and 2
wire [8:0] DIA = {9{PORT_A_WR_DATA}};
wire [8:0] DIB = {9{PORT_B_WR_DATA}};

assign PORT_A_RD_DATA = DOA;
assign PORT_B_RD_DATA = DOB;

EG_PHY_BRAM #(
	.INIT_00(init_slice('h00)),
	.INIT_01(init_slice('h01)),
	.INIT_02(init_slice('h02)),
	.INIT_03(init_slice('h03)),
	.INIT_04(init_slice('h04)),
	.INIT_05(init_slice('h05)),
	.INIT_06(init_slice('h06)),
	.INIT_07(init_slice('h07)),
	.INIT_08(init_slice('h08)),
	.INIT_09(init_slice('h09)),
	.INIT_0A(init_slice('h0a)),
	.INIT_0B(init_slice('h0b)),
	.INIT_0C(init_slice('h0c)),
	.INIT_0D(init_slice('h0d)),
	.INIT_0E(init_slice('h0e)),
	.INIT_0F(init_slice('h0f)),
	.INIT_10(init_slice('h10)),
	.INIT_11(init_slice('h11)),
	.INIT_12(init_slice('h12)),
	.INIT_13(init_slice('h13)),
	.INIT_14(init_slice('h14)),
	.INIT_15(init_slice('h15)),
	.INIT_16(init_slice('h16)),
	.INIT_17(init_slice('h17)),
	.INIT_18(init_slice('h18)),
	.INIT_19(init_slice('h19)),
	.INIT_1A(init_slice('h1a)),
	.INIT_1B(init_slice('h1b)),
	.INIT_1C(init_slice('h1c)),
	.INIT_1D(init_slice('h1d)),
	.INIT_1E(init_slice('h1e)),
	.INIT_1F(init_slice('h1f)),
	.INITP_00(initp_slice('h00)),
	.INITP_01(initp_slice('h01)),
	.INITP_02(initp_slice('h02)),
	.INITP_03(initp_slice('h03)),
	.MODE("DP8K"),
	.DATA_WIDTH_A($sformatf("%d", PORT_A_WIDTH)),
	.DATA_WIDTH_B($sformatf("%d", PORT_B_WIDTH)),
	.REGMODE_A("NOREG"),
	.REGMODE_B("NOREG"),
	.RESETMODE(OPTION_RESETMODE),
	.ASYNC_RESET_RELEASE(OPTION_RESETMODE),
	.CLKAMUX(PORT_A_CLK_POL ? "SIG" : "INV"),
	.CLKBMUX(PORT_B_CLK_POL ? "SIG" : "INV"),
	.WRITEMODE_A(PORT_A_OPTION_WRITEMODE),
	.WRITEMODE_B(PORT_B_OPTION_WRITEMODE),
) _TECHMAP_REPLACE_ (
	.clka(PORT_A_CLK),
	.wea(PORT_A_WR_EN),
	.cea(PORT_A_CLK_EN),
	.ocea(1'b1),
	.rsta(OPTION_RESETMODE == "SYNC" ? PORT_A_RD_SRST : PORT_A_RD_ARST),
	.csa(3'b111),
	.addra(PORT_A_WIDTH == 9 ? {PORT_A_ADDR[12:1], 1'b1} : PORT_A_ADDR),
	.dia(DIA),
	.doa(DOA),

	.clkb(PORT_B_CLK),
	.web(PORT_B_WR_EN),
	.ceb(PORT_B_CLK_EN),
	.oceb(1'b1),
	.rstb(OPTION_RESETMODE == "SYNC" ? PORT_B_RD_SRST : PORT_B_RD_ARST),
	.csb(3'b111),
	.addrb(PORT_B_WIDTH == 9 ? {PORT_B_ADDR[12:1], 1'b1} : PORT_B_ADDR),
	.dib(DIB),
	.dob(DOB),
);

endmodule


module $__ANLOGIC_BRAM_SDP_ (...);

parameter INIT = 0;
parameter OPTION_RESETMODE = "SYNC";

parameter PORT_R_WIDTH = 18;
parameter PORT_R_CLK_POL = 1;

input PORT_R_CLK;
input PORT_R_CLK_EN;
input PORT_R_RD_SRST;
input PORT_R_RD_ARST;
input [12:0] PORT_R_ADDR;
output [PORT_R_WIDTH-1:0] PORT_R_RD_DATA;

parameter PORT_W_WIDTH = 18;
parameter PORT_W_WR_EN_WIDTH = 2;
parameter PORT_W_CLK_POL = 1;

input PORT_W_CLK;
input PORT_W_CLK_EN;
input [12:0] PORT_W_ADDR;
input [PORT_W_WR_EN_WIDTH-1:0] PORT_W_WR_EN;
input [PORT_W_WIDTH-1:0] PORT_W_WR_DATA;

function [255:0] init_slice;
	input integer idx;
	integer i;
	for (i = 0; i < 32; i = i + 1) begin
		init_slice[i*8+:8] = INIT[(idx * 32 + i) * 9 +: 8];
	end
endfunction

function [255:0] initp_slice;
	input integer idx;
	integer i;
	for (i = 0; i < 256; i = i + 1) begin
		initp_slice[i] = INIT[(idx * 256 + i) * 9 + 8];
	end
endfunction

wire [17:0] DI = {18{PORT_W_WR_DATA}};
wire [17:0] DO;

assign PORT_R_RD_DATA = PORT_R_WIDTH == 18 ? DO : DO[17:9];

EG_PHY_BRAM #(
	.INIT_00(init_slice('h00)),
	.INIT_01(init_slice('h01)),
	.INIT_02(init_slice('h02)),
	.INIT_03(init_slice('h03)),
	.INIT_04(init_slice('h04)),
	.INIT_05(init_slice('h05)),
	.INIT_06(init_slice('h06)),
	.INIT_07(init_slice('h07)),
	.INIT_08(init_slice('h08)),
	.INIT_09(init_slice('h09)),
	.INIT_0A(init_slice('h0a)),
	.INIT_0B(init_slice('h0b)),
	.INIT_0C(init_slice('h0c)),
	.INIT_0D(init_slice('h0d)),
	.INIT_0E(init_slice('h0e)),
	.INIT_0F(init_slice('h0f)),
	.INIT_10(init_slice('h10)),
	.INIT_11(init_slice('h11)),
	.INIT_12(init_slice('h12)),
	.INIT_13(init_slice('h13)),
	.INIT_14(init_slice('h14)),
	.INIT_15(init_slice('h15)),
	.INIT_16(init_slice('h16)),
	.INIT_17(init_slice('h17)),
	.INIT_18(init_slice('h18)),
	.INIT_19(init_slice('h19)),
	.INIT_1A(init_slice('h1a)),
	.INIT_1B(init_slice('h1b)),
	.INIT_1C(init_slice('h1c)),
	.INIT_1D(init_slice('h1d)),
	.INIT_1E(init_slice('h1e)),
	.INIT_1F(init_slice('h1f)),
	.INITP_00(initp_slice('h00)),
	.INITP_01(initp_slice('h01)),
	.INITP_02(initp_slice('h02)),
	.INITP_03(initp_slice('h03)),
	.MODE("PDPW8K"),
	.DATA_WIDTH_A($sformatf("%d", PORT_W_WIDTH)),
	.DATA_WIDTH_B($sformatf("%d", PORT_R_WIDTH)),
	.REGMODE_A("NOREG"),
	.REGMODE_B("NOREG"),
	.RESETMODE(OPTION_RESETMODE),
	.ASYNC_RESET_RELEASE(OPTION_RESETMODE),
	.CLKAMUX(PORT_W_CLK_POL ? "SIG" : "INV"),
	.CLKBMUX(PORT_R_CLK_POL ? "SIG" : "INV"),
) _TECHMAP_REPLACE_ (
	.clka(PORT_W_CLK),
	.wea(PORT_W_WIDTH >= 9 ? 1'b1 : PORT_W_WR_EN[0]),
	.cea(PORT_W_CLK_EN),
	.ocea(1'b1),
	.rsta(1'b0),
	.csa(3'b111),
	.addra(PORT_W_WIDTH == 18 ? {PORT_W_ADDR[12:2], PORT_W_WR_EN[1:0]} : (PORT_W_WIDTH == 9 ? {PORT_W_ADDR[12:1], PORT_W_WR_EN[0]} : PORT_W_ADDR)),
	.dia(DI[8:0]),
	.doa(DO[8:0]),

	.clkb(PORT_R_CLK),
	.web(1'b0),
	.ceb(PORT_R_CLK_EN),
	.oceb(1'b1),
	.rstb(OPTION_RESETMODE == "SYNC" ? PORT_R_RD_SRST : PORT_R_RD_ARST),
	.csb(3'b111),
	.addrb(PORT_R_ADDR),
	.dib(DI[17:9]),
	.dob(DO[17:9]),
);

endmodule


module $__ANLOGIC_BRAM32K_ (...);

parameter INIT = 0;

parameter PORT_A_WIDTH = 16;
parameter PORT_A_WR_EN_WIDTH = 2;
parameter PORT_A_CLK_POL = 1;
parameter PORT_A_OPTION_WRITEMODE = "NORMAL";

input PORT_A_CLK;
input PORT_A_CLK_EN;
input [PORT_A_WR_EN_WIDTH-1:0] PORT_A_WR_EN;
input [11:0] PORT_A_ADDR;
input [PORT_A_WIDTH-1:0] PORT_A_WR_DATA;
output [PORT_A_WIDTH-1:0] PORT_A_RD_DATA;

parameter PORT_B_WIDTH = 16;
parameter PORT_B_WR_EN_WIDTH = 2;
parameter PORT_B_CLK_POL = 1;
parameter PORT_B_OPTION_WRITEMODE = "NORMAL";

input PORT_B_CLK;
input PORT_B_CLK_EN;
input [PORT_B_WR_EN_WIDTH-1:0] PORT_B_WR_EN;
input [11:0] PORT_B_ADDR;
input [PORT_B_WIDTH-1:0] PORT_B_WR_DATA;
output [PORT_B_WIDTH-1:0] PORT_B_RD_DATA;

function [255:0] init_slice;
	input integer idx;
	init_slice = INIT[256 * idx +: 256];
endfunction

wire [15:0] DOA;
wire [15:0] DOB;
wire [15:0] DIA = PORT_A_WR_DATA;
wire [15:0] DIB = PORT_B_WR_DATA;

assign PORT_A_RD_DATA = DOA;
assign PORT_B_RD_DATA = DOB;

wire BYTE_A, BYTEWE_A;
wire BYTE_B, BYTEWE_B;

generate

if (PORT_A_WIDTH == 8) begin
	assign BYTE_A = PORT_A_ADDR[0];
	assign BYTEWE_A = 1;
end else begin
	assign BYTE_A = PORT_A_WR_EN == 2;
	assign BYTEWE_A = ^PORT_A_WR_EN;
end

if (PORT_B_WIDTH == 8) begin
	assign BYTE_B = PORT_B_ADDR[0];
	assign BYTEWE_B = 1;
end else begin
	assign BYTE_B = PORT_B_WR_EN == 2;
	assign BYTEWE_B = ^PORT_B_WR_EN;
end

endgenerate

EG_PHY_BRAM32K #(
	.INIT_00(init_slice('h00)),
	.INIT_01(init_slice('h01)),
	.INIT_02(init_slice('h02)),
	.INIT_03(init_slice('h03)),
	.INIT_04(init_slice('h04)),
	.INIT_05(init_slice('h05)),
	.INIT_06(init_slice('h06)),
	.INIT_07(init_slice('h07)),
	.INIT_08(init_slice('h08)),
	.INIT_09(init_slice('h09)),
	.INIT_0A(init_slice('h0a)),
	.INIT_0B(init_slice('h0b)),
	.INIT_0C(init_slice('h0c)),
	.INIT_0D(init_slice('h0d)),
	.INIT_0E(init_slice('h0e)),
	.INIT_0F(init_slice('h0f)),
	.INIT_10(init_slice('h10)),
	.INIT_11(init_slice('h11)),
	.INIT_12(init_slice('h12)),
	.INIT_13(init_slice('h13)),
	.INIT_14(init_slice('h14)),
	.INIT_15(init_slice('h15)),
	.INIT_16(init_slice('h16)),
	.INIT_17(init_slice('h17)),
	.INIT_18(init_slice('h18)),
	.INIT_19(init_slice('h19)),
	.INIT_1A(init_slice('h1a)),
	.INIT_1B(init_slice('h1b)),
	.INIT_1C(init_slice('h1c)),
	.INIT_1D(init_slice('h1d)),
	.INIT_1E(init_slice('h1e)),
	.INIT_1F(init_slice('h1f)),
	.INIT_20(init_slice('h20)),
	.INIT_21(init_slice('h21)),
	.INIT_22(init_slice('h22)),
	.INIT_23(init_slice('h23)),
	.INIT_24(init_slice('h24)),
	.INIT_25(init_slice('h25)),
	.INIT_26(init_slice('h26)),
	.INIT_27(init_slice('h27)),
	.INIT_28(init_slice('h28)),
	.INIT_29(init_slice('h29)),
	.INIT_2A(init_slice('h2a)),
	.INIT_2B(init_slice('h2b)),
	.INIT_2C(init_slice('h2c)),
	.INIT_2D(init_slice('h2d)),
	.INIT_2E(init_slice('h2e)),
	.INIT_2F(init_slice('h2f)),
	.INIT_30(init_slice('h30)),
	.INIT_31(init_slice('h31)),
	.INIT_32(init_slice('h32)),
	.INIT_33(init_slice('h33)),
	.INIT_34(init_slice('h34)),
	.INIT_35(init_slice('h35)),
	.INIT_36(init_slice('h36)),
	.INIT_37(init_slice('h37)),
	.INIT_38(init_slice('h38)),
	.INIT_39(init_slice('h39)),
	.INIT_3A(init_slice('h3a)),
	.INIT_3B(init_slice('h3b)),
	.INIT_3C(init_slice('h3c)),
	.INIT_3D(init_slice('h3d)),
	.INIT_3E(init_slice('h3e)),
	.INIT_3F(init_slice('h3f)),
	.INIT_40(init_slice('h40)),
	.INIT_41(init_slice('h41)),
	.INIT_42(init_slice('h42)),
	.INIT_43(init_slice('h43)),
	.INIT_44(init_slice('h44)),
	.INIT_45(init_slice('h45)),
	.INIT_46(init_slice('h46)),
	.INIT_47(init_slice('h47)),
	.INIT_48(init_slice('h48)),
	.INIT_49(init_slice('h49)),
	.INIT_4A(init_slice('h4a)),
	.INIT_4B(init_slice('h4b)),
	.INIT_4C(init_slice('h4c)),
	.INIT_4D(init_slice('h4d)),
	.INIT_4E(init_slice('h4e)),
	.INIT_4F(init_slice('h4f)),
	.INIT_50(init_slice('h50)),
	.INIT_51(init_slice('h51)),
	.INIT_52(init_slice('h52)),
	.INIT_53(init_slice('h53)),
	.INIT_54(init_slice('h54)),
	.INIT_55(init_slice('h55)),
	.INIT_56(init_slice('h56)),
	.INIT_57(init_slice('h57)),
	.INIT_58(init_slice('h58)),
	.INIT_59(init_slice('h59)),
	.INIT_5A(init_slice('h5a)),
	.INIT_5B(init_slice('h5b)),
	.INIT_5C(init_slice('h5c)),
	.INIT_5D(init_slice('h5d)),
	.INIT_5E(init_slice('h5e)),
	.INIT_5F(init_slice('h5f)),
	.INIT_60(init_slice('h60)),
	.INIT_61(init_slice('h61)),
	.INIT_62(init_slice('h62)),
	.INIT_63(init_slice('h63)),
	.INIT_64(init_slice('h64)),
	.INIT_65(init_slice('h65)),
	.INIT_66(init_slice('h66)),
	.INIT_67(init_slice('h67)),
	.INIT_68(init_slice('h68)),
	.INIT_69(init_slice('h69)),
	.INIT_6A(init_slice('h6a)),
	.INIT_6B(init_slice('h6b)),
	.INIT_6C(init_slice('h6c)),
	.INIT_6D(init_slice('h6d)),
	.INIT_6E(init_slice('h6e)),
	.INIT_6F(init_slice('h6f)),
	.INIT_70(init_slice('h70)),
	.INIT_71(init_slice('h71)),
	.INIT_72(init_slice('h72)),
	.INIT_73(init_slice('h73)),
	.INIT_74(init_slice('h74)),
	.INIT_75(init_slice('h75)),
	.INIT_76(init_slice('h76)),
	.INIT_77(init_slice('h77)),
	.INIT_78(init_slice('h78)),
	.INIT_79(init_slice('h79)),
	.INIT_7A(init_slice('h7a)),
	.INIT_7B(init_slice('h7b)),
	.INIT_7C(init_slice('h7c)),
	.INIT_7D(init_slice('h7d)),
	.INIT_7E(init_slice('h7e)),
	.INIT_7F(init_slice('h7f)),
	.MODE("DP16K"),
	.DATA_WIDTH_A($sformatf("%d", PORT_A_WIDTH)),
	.DATA_WIDTH_B($sformatf("%d", PORT_B_WIDTH)),
	.REGMODE_A("NOREG"),
	.REGMODE_B("NOREG"),
	.WRITEMODE_A(PORT_A_OPTION_WRITEMODE),
	.WRITEMODE_B(PORT_B_OPTION_WRITEMODE),
	.CLKAMUX(PORT_A_CLK_POL ? "SIG" : "INV"),
	.CLKBMUX(PORT_B_CLK_POL ? "SIG" : "INV"),
) _TECHMAP_REPLACE_ (
	.clka(PORT_A_CLK),
	.csa(PORT_A_CLK_EN),
	.wea(|PORT_A_WR_EN),
	.ocea(1'b1),
	.rsta(1'b0),
	.addra(PORT_A_ADDR[11:1]),
	.bytea(BYTE_A),
	.bytewea(BYTEWE_A),
	.dia(DIA),
	.doa(DOA),

	.clkb(PORT_B_CLK),
	.csb(PORT_B_CLK_EN),
	.web(|PORT_B_WR_EN),
	.ocea(1'b1),
	.rsta(1'b0),
	.addrb(PORT_B_ADDR[11:1]),
	.byteb(BYTE_B),
	.byteweb(BYTEWE_B),
	.dib(DIB),
	.dob(DOB),
);

endmodule
`,"cells_map.v":`module  \\$_DFFE_PN0P_ (input D, C, R, E, output Q); AL_MAP_SEQ #(.DFFMODE("FF"), .REGSET("RESET"), .SRMUX("INV"), .SRMODE("ASYNC")) _TECHMAP_REPLACE_ (.d(D), .q(Q), .clk(C) ,.ce(E), .sr(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_DFFE_PN1P_ (input D, C, R, E, output Q); AL_MAP_SEQ #(.DFFMODE("FF"), .REGSET("SET"), .SRMUX("INV"), .SRMODE("ASYNC")) _TECHMAP_REPLACE_ (.d(D), .q(Q), .clk(C), .ce(E), .sr(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_DFFE_PP0P_ (input D, C, R, E, output Q); AL_MAP_SEQ #(.DFFMODE("FF"), .REGSET("RESET"), .SRMUX("SR"),  .SRMODE("ASYNC")) _TECHMAP_REPLACE_ (.d(D), .q(Q), .clk(C), .ce(E), .sr(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_DFFE_PP1P_ (input D, C, R, E, output Q); AL_MAP_SEQ #(.DFFMODE("FF"), .REGSET("SET"), .SRMUX("SR"), . SRMODE("ASYNC")) _TECHMAP_REPLACE_ (.d(D), .q(Q), .clk(C), .ce(E), .sr(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule

module  \\$_SDFFE_PN0P_ (input D, C, R, E, output Q); AL_MAP_SEQ #(.DFFMODE("FF"), .REGSET("RESET"), .SRMUX("INV"), .SRMODE("SYNC")) _TECHMAP_REPLACE_ (.d(D), .q(Q), .clk(C) ,.ce(E), .sr(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_SDFFE_PN1P_ (input D, C, R, E, output Q); AL_MAP_SEQ #(.DFFMODE("FF"), .REGSET("SET"), .SRMUX("INV"), .SRMODE("SYNC")) _TECHMAP_REPLACE_ (.d(D), .q(Q), .clk(C), .ce(E), .sr(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_SDFFE_PP0P_ (input D, C, R, E, output Q); AL_MAP_SEQ #(.DFFMODE("FF"), .REGSET("RESET"), .SRMUX("SR"),  .SRMODE("SYNC")) _TECHMAP_REPLACE_ (.d(D), .q(Q), .clk(C), .ce(E), .sr(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_SDFFE_PP1P_ (input D, C, R, E, output Q); AL_MAP_SEQ #(.DFFMODE("FF"), .REGSET("SET"), .SRMUX("SR"), . SRMODE("SYNC")) _TECHMAP_REPLACE_ (.d(D), .q(Q), .clk(C), .ce(E), .sr(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule

module  \\$_DLATCH_NN0_ (input D, R, E, output Q); AL_MAP_SEQ #(.DFFMODE("LATCH"), .REGSET("RESET"), .SRMUX("INV"), .SRMODE("ASYNC")) _TECHMAP_REPLACE_ (.d(D), .q(Q), .clk(E) ,.ce(1'b1), .sr(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_DLATCH_NN1_ (input D, R, E, output Q); AL_MAP_SEQ #(.DFFMODE("LATCH"), .REGSET("SET"), .SRMUX("INV"), .SRMODE("ASYNC")) _TECHMAP_REPLACE_ (.d(D), .q(Q), .clk(E), .ce(1'b1), .sr(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_DLATCH_NP0_ (input D, R, E, output Q); AL_MAP_SEQ #(.DFFMODE("LATCH"), .REGSET("RESET"), .SRMUX("SR"),  .SRMODE("ASYNC")) _TECHMAP_REPLACE_ (.d(D), .q(Q), .clk(E), .ce(1'b1), .sr(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_DLATCH_NP1_ (input D, R, E, output Q); AL_MAP_SEQ #(.DFFMODE("LATCH"), .REGSET("SET"), .SRMUX("SR"), . SRMODE("ASYNC")) _TECHMAP_REPLACE_ (.d(D), .q(Q), .clk(E), .ce(1'b1), .sr(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule

\`ifndef NO_LUT
module \\$lut (A, Y);
  parameter WIDTH = 0;
  parameter LUT = 0;

  (* force_downto *)
  input [WIDTH-1:0] A;
  output Y;

  generate
    if (WIDTH == 1) begin
      AL_MAP_LUT1 #(.EQN(""),.INIT(LUT)) _TECHMAP_REPLACE_ (.o(Y), .a(A[0]));
    end else
    if (WIDTH == 2) begin
      AL_MAP_LUT2 #(.EQN(""),.INIT(LUT)) _TECHMAP_REPLACE_ (.o(Y), .a(A[0]), .b(A[1]));
    end else
    if (WIDTH == 3) begin
      AL_MAP_LUT3 #(.EQN(""),.INIT(LUT)) _TECHMAP_REPLACE_ (.o(Y), .a(A[0]), .b(A[1]), .c(A[2]));
    end else
    if (WIDTH == 4) begin
      AL_MAP_LUT4 #(.EQN(""),.INIT(LUT)) _TECHMAP_REPLACE_ (.o(Y), .a(A[0]), .b(A[1]), .c(A[2]), .d(A[3]));
    end else
    if (WIDTH == 5) begin
      AL_MAP_LUT5 #(.EQN(""),.INIT(LUT)) _TECHMAP_REPLACE_ (.o(Y), .a(A[0]), .b(A[1]), .c(A[2]), .d(A[3]), .e(A[4]));
    end else
    if (WIDTH == 6) begin
      AL_MAP_LUT6 #(.EQN(""),.INIT(LUT)) _TECHMAP_REPLACE_ (.o(Y), .a(A[0]), .b(A[1]), .c(A[2]), .d(A[3]), .e(A[4]), .f(A[5]));
    end else begin
      wire _TECHMAP_FAIL_ = 1;
    end
  endgenerate
endmodule
\`endif
`,"cells_sim.v":`module AL_MAP_SEQ (
	output reg q,
	input ce,
	input clk,
	input sr,
	input d
);
	parameter DFFMODE = "FF"; //FF,LATCH
	parameter REGSET = "RESET"; //RESET/SET
	parameter SRMUX = "SR"; //SR/INV
	parameter SRMODE = "SYNC"; //SYNC/ASYNC

	wire srmux;
	generate
		case (SRMUX)
			"SR": assign srmux = sr;
			"INV": assign srmux = ~sr;
			default: assign srmux = sr;
		endcase
	endgenerate

	wire regset;
	generate
		case (REGSET)
			"RESET": assign regset = 1'b0;
			"SET": assign regset = 1'b1;
			default: assign regset = 1'b0;
		endcase
	endgenerate

	initial q = regset;

	generate
		if (DFFMODE == "FF")
		begin
			if (SRMODE == "ASYNC")
			begin
				always @(posedge clk, posedge srmux)
					if (srmux)
						q <= regset;
					else if (ce)
						q <= d;
			end
			else
			begin
				always @(posedge clk)
					if (srmux)
						q <= regset;
					else if (ce)
						q <= d;
			end
		end
		else
		begin
			// DFFMODE == "LATCH"
			if (SRMODE == "ASYNC")
			begin
				always @*
					if (srmux)
						q <= regset;
					else if (~clk & ce)
						q <= d;
			end
			else
			begin
				always @*
					if (~clk) begin
						if (srmux)
							q <= regset;
						else if (ce)
							q <= d;
					end
			end
		end
    endgenerate
endmodule

module AL_MAP_LUT1 (
	output o,
	input a
);
	parameter [1:0] INIT = 2'h0;
	parameter EQN = "(A)";

	assign o = a ? INIT[1] : INIT[0];	
endmodule

module AL_MAP_LUT2 (
	output o,
	input a,
	input b
);
	parameter [3:0] INIT = 4'h0;
	parameter EQN = "(A)";

	wire [1:0] s1 = b ? INIT[ 3:2] : INIT[1:0];
	assign o = a ? s1[1] : s1[0];	
endmodule

module AL_MAP_LUT3 (
	output o,
	input a,
	input b,
	input c
);
	parameter [7:0] INIT = 8'h0;
	parameter EQN = "(A)";

	wire [3:0] s2 = c ? INIT[ 7:4] : INIT[3:0];
	wire [1:0] s1 = b ?   s2[ 3:2] :   s2[1:0];
	assign o = a ? s1[1] : s1[0];	
endmodule

module AL_MAP_LUT4 (
	output o,
	input a,
	input b,
	input c,
	input d
);
	parameter [15:0] INIT = 16'h0;
	parameter EQN = "(A)";

	wire [7:0] s3 = d ? INIT[15:8] : INIT[7:0];
	wire [3:0] s2 = c ?   s3[ 7:4] :   s3[3:0];
	wire [1:0] s1 = b ?   s2[ 3:2] :   s2[1:0];
	assign o = a ? s1[1] : s1[0];	
endmodule

module AL_MAP_LUT5 (
	output o,
	input a,
	input b,
	input c,
	input d,
	input e
);
	parameter [31:0] INIT = 32'h0;
	parameter EQN = "(A)";
	assign o = INIT >> {e, d, c, b, a};
endmodule


module AL_MAP_LUT6 (
	output o,
	input a,
	input b,
	input c,
	input d,
	input e,
	input f
);
	parameter [63:0] INIT = 64'h0;
	parameter EQN = "(A)";
	assign o = INIT >> {f, e, d, c, b, a};
endmodule

module AL_MAP_ALU2B (
   input cin,
   input a0, b0, c0, d0,
   input a1, b1, c1, d1,
   output s0, s1, cout
);
	parameter [15:0] INIT0 = 16'h0000;
	parameter [15:0] INIT1 = 16'h0000;
	parameter FUNC0 = "NO";
	parameter FUNC1 = "NO";
endmodule

module AL_MAP_ADDER (
  input a,
  input b,
  input c,
  output [1:0] o
);
	parameter ALUTYPE = "ADD";

	generate
		case (ALUTYPE)
			"ADD": 		 assign o = a + b + c;
			"SUB": 		 assign o = a - b - c;
			"A_LE_B":    assign o = a - b - c;

			"ADD_CARRY":    assign o = {  a, 1'b0 };
			"SUB_CARRY":    assign o = { ~a, 1'b0 };
			"A_LE_B_CARRY": assign o = {  a, 1'b0 };
			default: assign o = a + b + c;
		endcase
	endgenerate	

endmodule
`,"eagle_bb.v":`// Anlogic Eagle - Blackbox cells
// FIXME: Create sim models

(* blackbox *)
module EG_LOGIC_BUF(
  output o,
  input i
);
endmodule

(* blackbox *)
module EG_LOGIC_BUFG(
  output o,
  input i
);
endmodule

(* blackbox *)
module EG_LOGIC_BUFIO(
  input clki,
  input rst,
  input coe,
  output clko,
  output clkdiv1,
  output clkdivx
);
  parameter GSR = "DISABLE";
  parameter DIV = 2;
  parameter STOPCLK = "DISABLE";
endmodule

(* blackbox *)
module EG_LOGIC_BUFGMUX(
  output o,
  input i0,
  input i1,
  input s
);
  parameter INIT_OUT = "0";
  parameter PRESELECT_I0 = "TRUE";
  parameter PRESELECT_I1 = "FALSE";
endmodule

(* blackbox *)
module EG_LOGIC_MBOOT(
  input rebootn,
  input [7:0] dynamic_addr  
);
  parameter ADDR_SOURCE_SEL = "STATIC";
  parameter STATIC_ADDR = 8'b00000000;
endmodule

(* blackbox *)
module EG_LOGIC_DNA(
  output dout,
  input  clk,
  input  din,
  input  shift_en
);
endmodule

(* blackbox *)
module EG_LOGIC_GCTRL(
  output done,
  output highz
);
endmodule

(* blackbox *)
module EG_LOGIC_GSRN(
  input gsrn,
  input sync_clk
);
  parameter GSRN_SYNC_SEL = "DISABLE";
  parameter USR_GSRN_EN = "DISABLE";
endmodule

(* blackbox *)
module EG_LOGIC_CCLK(
  output cclk,
  input  en
);
  parameter FREQ = "4.5";
endmodule

(* blackbox *)
module EG_LOGIC_IDELAY(
  output o,
  input i
);
  parameter INDEL = 0;
endmodule

(* blackbox *)
module EG_LOGIC_IDDR(
  output q1,
  output q0,
  input clk,
  input d,
  input rst
);
  parameter ASYNCRST = "ENABLE";
  parameter PIPEMODE = "PIPED";
endmodule

(* blackbox *)
module EG_LOGIC_ODDR(
  output q,
  input clk,
  input d1,
  input d0,
  input rst
);
  parameter ASYNCRST = "ENABLE";
endmodule

(* blackbox *)
module EG_LOGIC_IDDRx2(
  output q3,
  output q2,
  output q1,
  output q0,
  input pclk,
  input sclk,
  input d,
  input rst
);
  parameter ASYNCRST = "ENABLE";
endmodule

(* blackbox *)
module EG_LOGIC_ODELAY(
  output o,
  input i
);
  parameter OUTDEL = 0;
endmodule

(* blackbox *)
module EG_LOGIC_ODDRx2(
  output q,
  input pclk,
  input sclk,
  input d3,
  input d2,
  input d1,
  input d0,
  input rst
);
  parameter ASYNCRST = "ENABLE";
endmodule

(* blackbox *)
module EG_LOGIC_ODDRx2l(
  output q,
  input sclk,
  input d3,
  input d2,
  input d1,
  input d0,
  input rst
);
  parameter ASYNCRST = "ENABLE";
endmodule

(* blackbox *)
module EG_LOGIC_FIFO(
  input rst,
  input [DATA_WIDTH_W-1:0] di,
  output [DATA_WIDTH_R-1:0] do,
  input clkw,
  input we,
  input clkr,
  input re,
  input ore,
  input [2:0] csw,
  input [2:0] csr,
  output empty_flag,
  output aempty_flag,
  output full_flag,
  output afull_flag
);
  parameter DATA_WIDTH_W = 9;
  parameter DATA_WIDTH_R = DATA_WIDTH_W;
  parameter DATA_DEPTH_W = 1024;
  parameter DATA_DEPTH_R = DATA_WIDTH_W * DATA_DEPTH_W / DATA_WIDTH_R;
  parameter MODE = "FIFO8K";
  parameter REGMODE_W = "NOREG";
  parameter REGMODE_R = "NOREG";
  parameter E = 0;
  parameter AE = 6;
  parameter AF = DATA_DEPTH_W - 6;
  parameter F = DATA_DEPTH_W;
  parameter GSR = "DISABLE";
  parameter RESETMODE = "ASYNC";
  parameter ASYNC_RESET_RELEASE = "SYNC";
  parameter ENDIAN = "LITTLE";
endmodule

(* blackbox *)
module EG_LOGIC_DRAM(
  input [DATA_WIDTH_W-1:0] di,
  input [ADDR_WIDTH_W-1:0] waddr,
  input wclk,
  input we,
  output [DATA_WIDTH_R-1:0] do,
  input [ADDR_WIDTH_R-1:0] raddr
);
  parameter DATA_WIDTH_W = 9;
  parameter ADDR_WIDTH_W = 10;
  parameter DATA_DEPTH_W = 2 ** ADDR_WIDTH_W;
  parameter DATA_WIDTH_R = 9;
  parameter ADDR_WIDTH_R = 10;
  parameter DATA_DEPTH_R = 2 ** ADDR_WIDTH_R;
  parameter INIT_FILE = "NONE";
endmodule

(* blackbox *)
module EG_LOGIC_DRAM16X4(
  input [3:0] di,
  input [3:0] waddr,
  input wclk,
  input we,
  input [3:0]raddr,
  output [3:0]do
);
  parameter INIT_D0=16'h0000;
  parameter INIT_D1=16'h0000;
  parameter INIT_D2=16'h0000;
  parameter INIT_D3=16'h0000;
endmodule

(* blackbox *)
module EG_LOGIC_MULT(
  output [OUTPUT_WIDTH-1:0] p,
  input [INPUT_WIDTH_A-1:0] a,
  input [INPUT_WIDTH_B-1:0] b,
  input cea,
  input ceb,
  input cepd,
  input clk,
  input rstan,
  input rstbn,
  input rstpdn
); 
  parameter INPUT_WIDTH_A = 18;
  parameter INPUT_WIDTH_B = 18;
  parameter OUTPUT_WIDTH = 36;
  parameter INPUTFORMAT = "SIGNED";
  parameter INPUTREGA = "ENABLE";
  parameter INPUTREGB = "ENABLE";
  parameter OUTPUTREG = "ENABLE";
  parameter SRMODE = "ASYNC";
  parameter IMPLEMENT = "AUTO";
endmodule

(* blackbox *)
module EG_LOGIC_SEQ_DIV(
  input clk,
  input rst,
  input start,
  input [NUMER_WIDTH-1:0] numer,
  input [DENOM_WIDTH-1:0] denom,
  output [NUMER_WIDTH-1:0] quotient,
  output [DENOM_WIDTH-1:0] remain,
  output done
);
	parameter NUMER_WIDTH = 16;
  parameter DENOM_WIDTH = 16;
endmodule

(* blackbox *)
module EG_PHY_BRAM(
  output [8:0] doa,
  output [8:0] dob,
  input [8:0] dia,
  input [8:0] dib,
  input [2:0] csa,
  input [2:0] csb,
  input cea,
  input ocea,
  input clka,
  input wea,
  input rsta,
  input ceb,
  input oceb,
  input clkb,
  input web,
  input rstb,
  input [12:0] addra,
  input [12:0] addrb
);
  parameter MODE = "DP8K";
  parameter DATA_WIDTH_A = "9";
  parameter DATA_WIDTH_B = "9";
  parameter READBACK = "OFF";
  parameter REGMODE_A = "NOREG";
  parameter REGMODE_B = "NOREG";
  parameter WRITEMODE_A = "NORMAL";
  parameter WRITEMODE_B = "NORMAL";
  parameter GSR = "ENABLE";
  parameter RESETMODE = "SYNC";
  parameter ASYNC_RESET_RELEASE = "SYNC";
  parameter CEAMUX = "SIG";
  parameter CEBMUX = "SIG";
  parameter OCEAMUX = "SIG";
  parameter OCEBMUX = "SIG";
  parameter RSTAMUX = "SIG";
  parameter RSTBMUX = "SIG";
  parameter CLKAMUX = "SIG";
  parameter CLKBMUX = "SIG";
  parameter WEAMUX = "SIG";
  parameter WEBMUX = "SIG";
  parameter CSA0 = "SIG" ;
  parameter CSA1 = "SIG" ;
  parameter CSA2 = "SIG" ;
  parameter CSB0 = "SIG" ;
  parameter CSB1 = "SIG" ;
  parameter CSB2 = "SIG" ;
  parameter INIT_FILE = "NONE";
  parameter INITP_00 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INITP_01 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INITP_02 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INITP_03 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_00 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_01 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_02 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_03 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_04 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_05 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_06 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_07 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_08 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_09 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_0A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_0B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_0C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_0D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_0E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_0F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_10 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_11 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_12 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_13 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_14 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_15 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_16 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_17 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_18 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_19 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_1A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_1B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_1C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_1D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_1E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_1F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
endmodule

(* blackbox *)
module EG_PHY_BRAM32K(
  output [15:0] doa,
  output [15:0] dob,
  input [15:0] dia,
  input [15:0] dib,
  input [10:0] addra,
  input [10:0] addrb,
  input bytea,
  input bytewea,
  input byteb,
  input byteweb,
  input csa,
  input wea,
  input csb,
  input web,
  input clka,
  input rsta,
  input clkb,
  input rstb,
  input ocea,
  input oceb
);
  parameter MODE = "DP16K";
  parameter DATA_WIDTH_A = "16";
  parameter DATA_WIDTH_B = "16";
  parameter REGMODE_A = "NOREG";
  parameter REGMODE_B = "NOREG";
  parameter WRITEMODE_A = "NORMAL";
  parameter WRITEMODE_B = "NORMAL";
  parameter SRMODE = "SYNC";
  parameter CSAMUX = "SIG";
  parameter CSBMUX = "SIG";
  parameter OCEAMUX = "SIG";
  parameter OCEBMUX = "SIG";
  parameter RSTAMUX = "SIG";
  parameter RSTBMUX = "SIG";
  parameter CLKAMUX = "SIG";
  parameter CLKBMUX = "SIG";
  parameter WEAMUX = "SIG";
  parameter WEBMUX = "SIG";
  parameter READBACK = "OFF";
  parameter INIT_FILE = "";
  parameter INIT_00 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_01 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_02 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_03 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_04 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_05 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_06 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_07 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_08 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_09 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_0A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_0B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_0C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_0D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_0E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_0F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_10 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_11 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_12 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_13 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_14 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_15 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_16 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_17 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_18 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_19 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_1A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_1B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_1C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_1D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_1E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_1F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_20 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_21 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_22 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_23 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_24 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_25 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_26 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_27 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_28 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_29 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_2A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_2B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_2C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_2D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_2E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_2F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_30 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_31 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_32 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_33 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_34 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_35 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_36 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_37 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_38 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_39 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_3A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_3B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_3C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_3D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_3E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_3F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_40 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_41 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_42 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_43 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_44 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_45 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_46 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_47 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_48 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_49 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_4A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_4B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_4C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_4D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_4E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_4F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_50 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_51 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_52 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_53 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_54 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_55 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_56 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_57 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_58 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_59 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_5A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_5B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_5C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_5D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_5E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_5F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_60 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_61 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_62 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_63 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_64 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_65 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_66 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_67 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_68 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_69 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_6A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_6B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_6C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_6D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_6E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_6F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_70 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_71 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_72 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_73 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_74 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_75 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_76 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_77 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_78 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_79 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_7A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_7B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_7C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_7D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_7E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
  parameter INIT_7F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
endmodule

(* blackbox *)
module EG_PHY_FIFO(
  input [8:0] dia,
  input [8:0] dib,
  input [2:0] csr,
  input [2:0] csw,
  input we,
  input re,
  input clkw,
  input clkr,
  input rst,
  input rprst,
  input orea,
  input oreb,
  output [8:0] dob,
  output [8:0] doa,
  output empty_flag,
  output aempty_flag,
  output afull_flag,
  output full_flag
);
  parameter MODE = "FIFO8K";
  parameter DATA_WIDTH_A = "18";
  parameter DATA_WIDTH_B = "18";
  parameter READBACK = "OFF";
  parameter REGMODE_A = "NOREG";
  parameter REGMODE_B = "NOREG";
  parameter [13:0] AE = 14'b00000001100000;
  parameter [13:0] AF = 14'b01111110010000;
  parameter [13:0] F = 14'b01111111110000;
  parameter [13:0] AEP1 = 14'b00000001110000;
  parameter [13:0] AFM1 = 14'b01111110000000;
  parameter [13:0] FM1  = 14'b01111111100000;   
  parameter [4:0] E = 5'b00000;
  parameter [5:0] EP1 = 6'b010000;
  parameter GSR = "ENABLE";
  parameter RESETMODE = "ASYNC";
  parameter ASYNC_RESET_RELEASE = "SYNC";
  parameter CEA = "SIG";
  parameter CEB = "SIG";
  parameter OCEA = "SIG";
  parameter OCEB = "SIG";
  parameter RSTA = "SIG";
  parameter RSTB = "SIG";
  parameter CLKA = "SIG";
  parameter CLKB = "SIG";
  parameter WEA = "SIG";
  parameter WEB = "SIG";
  parameter CSA0 = "SIG";
  parameter CSA1 = "SIG";
  parameter CSA2 = "SIG";
  parameter CSB0 = "SIG";
  parameter CSB1 = "SIG";
  parameter CSB2 = "SIG";
endmodule

(* blackbox *)
module EG_PHY_MULT18(
  output [17:0] acout,
  output [17:0] bcout,
  output [35:0] p,
  input signeda,
  input signedb,
  input [17:0] a,
  input [17:0] b,
  input [17:0] acin,
  input [17:0] bcin,
  input cea,
  input ceb,
  input cepd,
  input clk,
  input rstan,
  input rstbn,
  input rstpdn,
  input sourcea,
  input sourceb  
); 
  parameter INPUTREGA = "ENABLE";
  parameter INPUTREGB = "ENABLE";
  parameter OUTPUTREG = "ENABLE";
  parameter SRMODE = "ASYNC";
  parameter MODE = "MULT18X18C";
  parameter CEAMUX = "SIG";
  parameter CEBMUX = "SIG";
  parameter CEPDMUX = "SIG";
  parameter RSTANMUX = "SIG";
  parameter RSTBNMUX = "SIG";
  parameter RSTPDNMUX = "SIG";
  parameter CLKMUX = "SIG";
  parameter SIGNEDAMUX = "SIG";
  parameter SIGNEDBMUX = "SIG";
  parameter SOURCEAMUX = "SIG";
  parameter SOURCEBMUX = "SIG";
endmodule

(* blackbox *)
module EG_PHY_GCLK(
  input clki,
  output clko
);    
endmodule

(* blackbox *)
module EG_PHY_IOCLK(
  input clki,
  input stop,
  output clko
);
  parameter STOPCLK = "DISABLE";
endmodule

(* blackbox *)
module EG_PHY_CLKDIV(
  output clkdiv1,
  output clkdivx,
  input clki,
  input rst,
  input rls
);    
  parameter GSR = "DISABLE";
  parameter DIV = 2;
endmodule

(* blackbox *)
module EG_PHY_CONFIG(
  output jrstn,
  output [1:0] jrti,
  output jshift,
  output jtck,
  output jtdi,
  output jupdate,
  output [1:0] jscanen,
  output jtms,
  input [1:0] jtdo,
  input [7:0] jtag8_ipa,
  input [7:0] jtag8_ipb,
  output done,
  output highz,
  output cclk,
  input	cclk_en,
  input gsrn_sync_clk,
  input usr_gsrn,
  output dna_dout,
  input	dna_clk,
  input	dna_din,
  input	dna_shift_en,
  input	mboot_rebootn,
  input [7:0]	mboot_dynamic_addr
);  
  parameter MBOOT_AUTO_SEL = "DISABLE";
  parameter ADDR_SOURCE_SEL = "STATIC";
  parameter STATIC_ADDR = 8'b0;
  parameter DONE_PERSISTN = "ENABLE";
  parameter INIT_PERSISTN = "ENABLE";
  parameter PROGRAMN_PERSISTN = "DISABLE";
  parameter JTAG_PERSISTN = "DISABLE";
  parameter GSRN_SYNC_SEL = "DISABLE";
  parameter FREQ = "2.5";
  parameter USR_GSRN_EN = "DISABLE";
endmodule

(* blackbox *)
module EG_PHY_OSC(
  input osc_dis,
  output osc_clk
);    
  parameter STDBY = "DISABLE";
endmodule

(* blackbox *)
module EG_PHY_PWRMNT(
    output pwr_dwn_n,
    input sel_pwr,
    input pwr_mnt_pd
);
  parameter MNT_LVL = 0;
endmodule

(* blackbox *)
module EG_PHY_DDR_8M_16(
  input clk,
  input clk_n,
  input ras_n,
  input cas_n,
  input we_n,
  input cs_n,
  input [11:0] addr,
  input [1:0] ba,
  inout [15:0] dq,
  input ldqs,
  input udqs,
  input ldm,
  input udm,
  input cke
);
endmodule

(* blackbox *)
module EG_PHY_SDRAM_2M_32(
  input clk,
  input ras_n,
  input cas_n,
  input we_n,
  input [10:0] addr,
  input [1:0] ba,
  inout [31:0] dq,
  input cs_n,
  input dm0,
  input dm1,
  input dm2,
  input dm3,
  input cke
);
endmodule

(* blackbox *)
module EG_PHY_PAD(
  input ipad,
  output opad,
  inout bpad,
  input rst,
  input ce,
  input isclk,
  input ipclk,
  input osclk,
  input opclk,
  input ts,
  input [3:0] do,
  output di,
  output [3:0] diq
);
  parameter DEDCLK = "DISABLE";
  parameter GSR = "ENABLE";
  parameter SRMODE = "SYNC";
  parameter TSMUX = "1";
  parameter INSCLKMUX = "0";
  parameter INPCLKMUX = "CLK";
  parameter INCEMUX = "CE";
  parameter INRSTMUX = "0";
  parameter IN_REGSET = "RESET";
  parameter IN_DFFMODE = "NONE";
  parameter IDDRMODE = "OFF";
  parameter IDDRPIPEMODE = "NONE";
  parameter INDELMUX = "NODEL";
  parameter INDEL = 0;
  parameter OUTSCLKMUX = "0";
  parameter OUTPCLKMUX = "CLK";
  parameter OUTCEMUX = "CE";
  parameter OUTRSTMUX = "0";
  parameter DO_REGSET = "RESET";
  parameter DO_DFFMODE = "NONE";
  parameter ODDRMODE = "OFF";
  parameter OUTDELMUX = "NODEL";
  parameter OUTDEL = 0;
  parameter TO_REGSET = "RESET";
  parameter TO_DFFMODE = "NONE";
  parameter MODE = "IN";
  parameter DRIVE = "NONE";
  parameter IOTYPE = "LVCMOS25";
endmodule

(* blackbox *)
module EG_PHY_MSLICE(
  input [1:0] a,
  input [1:0] b,
  input [1:0] c,
  input [1:0] d,
  input [1:0] mi,
  input clk,
  input ce,
  input sr,
  input fci,
  output [1:0] f,
  output [1:0] fx,
  output [1:0] q,
  output fco,
  input dpram_mode,
  input [1:0] dpram_di,
  input dpram_we,
  input dpram_wclk,
  input [3:0] dpram_waddr
);
  parameter INIT_LUT0 = 16'h0000;
  parameter INIT_LUT1 = 16'h0000;
  parameter MODE = "LOGIC";
  parameter ALUTYPE = "ADD";
  parameter MSFXMUX = "OFF";
  parameter GSR = "ENABLE";
  parameter TESTMODE = "OFF";
  parameter CEMUX = "CE";
  parameter SRMUX = "SR";
  parameter CLKMUX = "CLK";
  parameter SRMODE = "ASYNC";
  parameter DFFMODE = "FF";
  parameter REG0_SD = "MI";
  parameter REG1_SD = "MI";
  parameter REG0_REGSET = "SET";
  parameter REG1_REGSET = "SET";
endmodule

(* blackbox *)
module EG_PHY_LSLICE(
  input [1:0] a,
  input [1:0] b,
  input [1:0] c,
  input [1:0] d,
  input [1:0] e,
  input [1:0] mi,
  input clk,
  input ce,
  input sr,
  input fci,
  output [1:0] f,
  output [1:0] fx,
  output [1:0] q,
  output fco,
  output [3:0] dpram_di,
  output [3:0] dpram_waddr,
  output dpram_wclk,
  output dpram_we,
  output dpram_mode
);
  parameter INIT_LUTF0 = 16'h0000;
  parameter INIT_LUTG0 = 16'h0000;
  parameter INIT_LUTF1 = 16'h0000;
  parameter INIT_LUTG1 = 16'h0000;
  parameter MODE = "LOGIC";
  parameter GSR = "ENABLE";
  parameter TESTMODE = "OFF";
  parameter CEMUX = "1";
  parameter SRMUX = "SR";
  parameter CLKMUX = "CLK";
  parameter SRMODE = "ASYNC";
  parameter DFFMODE = "FF";
  parameter REG0_SD = "MI";
  parameter REG1_SD = "MI";
  parameter REG0_REGSET = "SET";
  parameter REG1_REGSET = "SET";
  parameter DEMUX0 = "D";
  parameter DEMUX1 = "D";
  parameter CMIMUX0 = "C";
  parameter CMIMUX1 = "C";
  parameter LSFMUX0 = "LUTF";
  parameter LSFXMUX0 = "LUTG";
  parameter LSFMUX1 = "LUTF";
  parameter LSFXMUX1 = "LUTG";
endmodule

(* blackbox *)
module EG_PHY_PLL(
  output [4:0] clkc,
  output extlock,
  input stdby,
  input refclk,
  input fbclk,
  input reset,
  output psdone,
  input psclk,
  input psdown,
  input psstep,
  input [2:0] psclksel,
  output [7:0] do,
  input dclk,
  input dcs,
  input dwe,
  input [7:0] di,
  input [5:0] daddr
);
  parameter DYNCFG = "DISABLE";
  parameter IF_ESCLKSTSW = "DISABLE";
  parameter REFCLK_SEL = "INTERNAL";
  parameter FIN = "100.0000";
  parameter REFCLK_DIV = 1;
  parameter FBCLK_DIV = 1;
  parameter CLKC0_DIV = 1;
  parameter CLKC1_DIV = 1;
  parameter CLKC2_DIV = 1;
  parameter CLKC3_DIV = 1;
  parameter CLKC4_DIV = 1;
  parameter CLKC0_ENABLE = "DISABLE";
  parameter CLKC1_ENABLE = "DISABLE";
  parameter CLKC2_ENABLE = "DISABLE";
  parameter CLKC3_ENABLE = "DISABLE";
  parameter CLKC4_ENABLE = "DISABLE";
  parameter CLKC0_DIV2_ENABLE = "DISABLE";
  parameter CLKC1_DIV2_ENABLE = "DISABLE";
  parameter CLKC2_DIV2_ENABLE = "DISABLE";
  parameter CLKC3_DIV2_ENABLE = "DISABLE";
  parameter CLKC4_DIV2_ENABLE = "DISABLE";
  parameter FEEDBK_MODE = "NORMAL";
  parameter FEEDBK_PATH = "VCO_PHASE_0";  
  parameter STDBY_ENABLE = "ENABLE";
  parameter CLKC0_FPHASE = 0;
  parameter CLKC1_FPHASE = 0;
  parameter CLKC2_FPHASE = 0;
  parameter CLKC3_FPHASE = 0;
  parameter CLKC4_FPHASE = 0;
  parameter CLKC0_CPHASE = 1;
  parameter CLKC1_CPHASE = 1;
  parameter CLKC2_CPHASE = 1;
  parameter CLKC3_CPHASE = 1;
  parameter CLKC4_CPHASE = 1;
  parameter GMC_GAIN = 7;
  parameter GMC_TEST = 14;
  parameter ICP_CURRENT = 14;
  parameter KVCO = 7;
  parameter LPF_CAPACITOR = 3;
  parameter LPF_RESISTOR = 1;
  parameter PLLRST_ENA = "ENABLE";
  parameter PLLMRST_ENA = "DISABLE";
  parameter PLLC2RST_ENA = "DISABLE";
  parameter PLLC34RST_ENA = "DISABLE";
  parameter PREDIV_MUXC0 = "VCO";
  parameter PREDIV_MUXC1 = "VCO";
  parameter PREDIV_MUXC2 = "VCO";
  parameter PREDIV_MUXC3 = "VCO";
  parameter PREDIV_MUXC4 = "VCO";
  parameter ODIV_MUXC0 = "DIV";
  parameter ODIV_MUXC1 = "DIV";
  parameter ODIV_MUXC2 = "DIV";
  parameter ODIV_MUXC3 = "DIV";
  parameter ODIV_MUXC4 = "DIV";
  parameter FREQ_LOCK_ACCURACY = 2;
  parameter PLL_LOCK_MODE = 0;
  parameter INTFB_WAKE = "DISABLE";
  parameter DPHASE_SOURCE = "DISABLE";
  parameter VCO_NORESET = "DISABLE";
  parameter STDBY_VCO_ENA = "DISABLE";
  parameter NORESET = "DISABLE";
  parameter SYNC_ENABLE = "ENABLE";
  parameter DERIVE_PLL_CLOCKS = "DISABLE";
  parameter GEN_BASIC_CLOCK = "DISABLE";
endmodule

(* blackbox *)
module EG_LOGIC_BRAM(
  output [DATA_WIDTH_A-1:0] doa,
  output [DATA_WIDTH_B-1:0] dob,
  input [DATA_WIDTH_A-1:0] dia,
  input [DATA_WIDTH_B-1:0] dib,
  input cea,
  input ocea,
  input clka,
  input wea,
  input rsta,
  input ceb,
  input oceb,
  input clkb,
  input web,
  input rstb,
  input [BYTE_A - 1 : 0] bea,
  input [BYTE_B - 1 : 0] beb,
  input [ADDR_WIDTH_A-1:0] addra,
  input [ADDR_WIDTH_B-1:0] addrb
);
  parameter DATA_WIDTH_A = 9;
  parameter DATA_WIDTH_B = DATA_WIDTH_A;
  parameter ADDR_WIDTH_A = 10;
  parameter ADDR_WIDTH_B = ADDR_WIDTH_A;
  parameter DATA_DEPTH_A = 2 ** ADDR_WIDTH_A;
  parameter DATA_DEPTH_B = 2 ** ADDR_WIDTH_B;
  parameter BYTE_ENABLE = 0;
  parameter BYTE_A = BYTE_ENABLE == 0 ? 1 : DATA_WIDTH_A / BYTE_ENABLE;
  parameter BYTE_B = BYTE_ENABLE == 0 ? 1 : DATA_WIDTH_B / BYTE_ENABLE;  
  parameter MODE = "DP";
  parameter REGMODE_A = "NOREG";
  parameter REGMODE_B = "NOREG";
  parameter WRITEMODE_A = "NORMAL";
  parameter WRITEMODE_B = "NORMAL";
  parameter RESETMODE = "SYNC";
  parameter DEBUGGABLE = "NO";
  parameter PACKABLE = "NO";
  parameter FORCE_KEEP = "OFF";
  parameter INIT_FILE = "NONE";
  parameter FILL_ALL = "NONE";
  parameter IMPLEMENT = "9K";
endmodule     

(* blackbox *)
module EG_PHY_ADC(
  input clk,
  input pd,
  input [2:0] s,
  input soc,
  output eoc,
  output [11:0] dout
);
  parameter CH0 = "DISABLE";
  parameter CH1 = "DISABLE";
  parameter CH2 = "DISABLE";
  parameter CH3 = "DISABLE";
  parameter CH4 = "DISABLE";
  parameter CH5 = "DISABLE";
  parameter CH6 = "DISABLE";
  parameter CH7 = "DISABLE";
  parameter VREF = "DISABLE";
endmodule
`,"lutrams.txt":`ram distributed $__ANLOGIC_DRAM16X4_ {
	abits 4;
	width 4;
	cost 4;
	init no_undef;
	prune_rom;
	port sw "W" {
		clock posedge;
	}
	port ar "R" {
	}
}
`,"lutrams_map.v":`module $__ANLOGIC_DRAM16X4_ (...);
	parameter INIT = 64'b0;

	input PORT_W_CLK;
	input [3:0] PORT_W_ADDR;
	input [3:0] PORT_W_WR_DATA;
	input PORT_W_WR_EN;

	input [3:0] PORT_R_ADDR;
	output [3:0] PORT_R_RD_DATA;

	function [15:0] init_slice;
		input integer idx;
		integer i;
		for (i = 0; i < 16; i = i + 1)
			init_slice[i] = INIT[i * 4 + idx];
	endfunction

	EG_LOGIC_DRAM16X4 #(
		.INIT_D0(init_slice(0)),
		.INIT_D1(init_slice(1)),
		.INIT_D2(init_slice(2)),
		.INIT_D3(init_slice(3))
	) _TECHMAP_REPLACE_ (
		.di(PORT_W_WR_DATA),
		.waddr(PORT_W_ADDR),
		.wclk(PORT_W_CLK),
		.we(PORT_W_WR_EN),
		.raddr(PORT_R_ADDR),
		.do(PORT_R_RD_DATA)
	);
endmodule
`},"cells.lib":`library(yosys_cells) {
	cell(DFF_N) {
		ff(IQ, IQN) {
			clocked_on: "!C";
			next_state: "D";
		}
		pin(D) { direction: input; }
		pin(C) { direction: input; clock: true; }
		pin(Q) { direction: output; function: "IQ"; }
	}
	cell(DFF_P) {
		ff(IQ, IQN) {
			clocked_on: "C";
			next_state: "D";
		}
		pin(D) { direction: input; }
		pin(C) { direction: input; clock: true; }
		pin(Q) { direction: output; function: "IQ"; }
	}
	cell(DFF_NN0) {
		ff(IQ, IQN) {
			clocked_on: "!C";
			next_state: "D";
			clear: "!R";
		}
		pin(D) { direction: input; }
		pin(R) { direction: input; }
		pin(C) { direction: input; clock: true; }
		pin(Q) { direction: output; function: "IQ"; }
	}
	cell(DFF_NN1) {
		ff(IQ, IQN) {
			clocked_on: "!C";
			next_state: "D";
			preset: "!R";
		}
		pin(D) { direction: input; }
		pin(R) { direction: input; }
		pin(C) { direction: input; clock: true; }
		pin(Q) { direction: output; function: "IQ"; }
	}
	cell(DFF_NP0) {
		ff(IQ, IQN) {
			clocked_on: "!C";
			next_state: "D";
			clear: "R";
		}
		pin(D) { direction: input; }
		pin(R) { direction: input; }
		pin(C) { direction: input; clock: true; }
		pin(Q) { direction: output; function: "IQ"; }
	}
	cell(DFF_NP1) {
		ff(IQ, IQN) {
			clocked_on: "!C";
			next_state: "D";
			preset: "R";
		}
		pin(D) { direction: input; }
		pin(R) { direction: input; }
		pin(C) { direction: input; clock: true; }
		pin(Q) { direction: output; function: "IQ"; }
	}
	cell(DFF_PN0) {
		ff(IQ, IQN) {
			clocked_on: "C";
			next_state: "D";
			clear: "!R";
		}
		pin(D) { direction: input; }
		pin(R) { direction: input; }
		pin(C) { direction: input; clock: true; }
		pin(Q) { direction: output; function: "IQ"; }
	}
	cell(DFF_PN1) {
		ff(IQ, IQN) {
			clocked_on: "C";
			next_state: "D";
			preset: "!R";
		}
		pin(D) { direction: input; }
		pin(R) { direction: input; }
		pin(C) { direction: input; clock: true; }
		pin(Q) { direction: output; function: "IQ"; }
	}
	cell(DFF_PP0) {
		ff(IQ, IQN) {
			clocked_on: "C";
			next_state: "D";
			clear: "R";
		}
		pin(D) { direction: input; }
		pin(R) { direction: input; }
		pin(C) { direction: input; clock: true; }
		pin(Q) { direction: output; function: "IQ"; }
	}
	cell(DFF_PP1) {
		ff(IQ, IQN) {
			clocked_on: "C";
			next_state: "D";
			preset: "R";
		}
		pin(D) { direction: input; }
		pin(R) { direction: input; }
		pin(C) { direction: input; clock: true; }
		pin(Q) { direction: output; function: "IQ"; }
	}
}
`,choices:{"kogge-stone.v":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2024  Martin Povi\u0161er <povik@cutebit.org>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

(* techmap_celltype = "$lcu" *)
module _80_lcu_kogge_stone (P, G, CI, CO);
	parameter WIDTH = 2;

	(* force_downto *)
	input [WIDTH-1:0] P, G;
	input CI;

	(* force_downto *)
	output [WIDTH-1:0] CO;

	integer i, j;
	(* force_downto *)
	reg [WIDTH-1:0] p, g;

	wire [1023:0] _TECHMAP_DO_ = "proc; opt -fast";

	always @* begin
		p = P;
		g = G;

		// in almost all cases CI will be constant zero
		g[0] = g[0] | (p[0] & CI);

		for (i = 0; i < $clog2(WIDTH); i = i + 1) begin
			// iterate in reverse so we don't confuse a result from this stage and the previous
			for (j = WIDTH - 1; j >= 2**i; j = j - 1) begin
				g[j] = g[j] | p[j] & g[j - 2**i];
				p[j] = p[j] & p[j - 2**i];
			end
		end
	end

	assign CO = g;
endmodule
`},"cmp2lcu.v":`// This pass performs an optimisation that decomposes wide arithmetic
//   comparisons into LUT-size chunks (as guided by the \`LUT_WIDTH
//   macro) connected to a single lookahead-carry-unit $lcu cell,
//   which is typically mapped to dedicated (and fast) FPGA
//   carry-chains.
(* techmap_celltype = "$lt $le $gt $ge" *)
module _80_lcu_cmp_ (A, B, Y);

parameter A_SIGNED = 0;
parameter B_SIGNED = 0;
parameter A_WIDTH = 0;
parameter B_WIDTH = 0;
parameter Y_WIDTH = 0;

(* force_downto *)
input [A_WIDTH-1:0] A;
(* force_downto *)
input [B_WIDTH-1:0] B;
(* force_downto *)
output [Y_WIDTH-1:0] Y;

parameter _TECHMAP_CELLTYPE_ = "";

generate
    if (_TECHMAP_CELLTYPE_ == "" || \`LUT_WIDTH < 2)
        wire _TECHMAP_FAIL_ = 1;
    else if (_TECHMAP_CELLTYPE_ == "$lt") begin
        // Transform $lt into $gt by swapping A and B
        $gt #(.A_SIGNED(B_SIGNED), .B_SIGNED(A_SIGNED), .A_WIDTH(B_WIDTH), .B_WIDTH(A_WIDTH), .Y_WIDTH(Y_WIDTH)) _TECHMAP_REPLACE_ (.A(B), .B(A), .Y(Y));
    end
    else if (_TECHMAP_CELLTYPE_ == "$le") begin
        // Transform $le into $ge by swapping A and B
        $ge #(.A_SIGNED(B_SIGNED), .B_SIGNED(A_SIGNED), .A_WIDTH(B_WIDTH), .B_WIDTH(A_WIDTH), .Y_WIDTH(Y_WIDTH)) _TECHMAP_REPLACE_ (.A(B), .B(A), .Y(Y));
    end
    else begin
        // Perform sign extension on A and B
        localparam WIDTH = A_WIDTH > B_WIDTH ? A_WIDTH : B_WIDTH;
        (* force_downto *)
        wire [WIDTH-1:0] AA = {{(WIDTH-A_WIDTH){A_SIGNED ? A[A_WIDTH-1] : 1'b0}}, A};
        (* force_downto *)
        wire [WIDTH-1:0] BB = {{(WIDTH-B_WIDTH){B_SIGNED ? B[B_WIDTH-1] : 1'b0}}, B};
        // For $ge operation, start with the assumption that A and B are
        //   equal (propagating this equality if A and B turn out to be so)
        localparam CI = _TECHMAP_CELLTYPE_ == "$ge";
        $__CMP2LCU #(.AB_WIDTH(WIDTH), .AB_SIGNED(A_SIGNED && B_SIGNED), .LCU_WIDTH(1), .BUDGET(\`LUT_WIDTH), .CI(CI))
            _TECHMAP_REPLACE_ (.A(AA), .B(BB), .P(1'b1), .G(1'b0), .Y(Y));
    end
endgenerate
endmodule

module $__CMP2LCU (A, B, P, G, Y);

parameter AB_WIDTH = 0;
parameter AB_SIGNED = 0;
parameter LCU_WIDTH = 1;
parameter BUDGET = 0;
parameter CI = 0;

(* force_downto *)
input [AB_WIDTH-1:0] A; // A from original $gt/$ge
(* force_downto *)
input [AB_WIDTH-1:0] B; // B from original $gt/$ge
(* force_downto *)
input [LCU_WIDTH-1:0] P; // P of $lcu
(* force_downto *)
input [LCU_WIDTH-1:0] G; // G of $lcu
output Y;

parameter [AB_WIDTH-1:0] _TECHMAP_CONSTMSK_A_ = 0;
parameter [AB_WIDTH-1:0] _TECHMAP_CONSTMSK_B_ = 0;
parameter [LCU_WIDTH-1:0] _TECHMAP_CONSTMSK_P_ = 0;

generate
    if (AB_WIDTH == 0) begin
        (* force_downto *)
        wire [LCU_WIDTH-1:0] CO;
        $lcu #(.WIDTH(LCU_WIDTH)) _TECHMAP_REPLACE_ (.P(P), .G(G), .CI(CI), .CO(CO));
        assign Y = CO[LCU_WIDTH-1];
    end
    else begin
        localparam COST =
            _TECHMAP_CONSTMSK_A_[AB_WIDTH-1:0] && _TECHMAP_CONSTMSK_B_[AB_WIDTH-1:0]
            ? 0
            : (_TECHMAP_CONSTMSK_A_[AB_WIDTH-1:0] || _TECHMAP_CONSTMSK_B_[AB_WIDTH-1:0]
                ? 1
                : 2);

        if (BUDGET < COST)
             $__CMP2LCU #(.AB_WIDTH(AB_WIDTH), .AB_SIGNED(AB_SIGNED), .LCU_WIDTH(LCU_WIDTH+1), .BUDGET(\`LUT_WIDTH), .CI(CI))
                _TECHMAP_REPLACE_ (.A(A), .B(B), .P({P, 1'b1}), .G({G, 1'b0}), .Y(Y));
        else begin
            wire PP, GG;
            // Bit-wise equality (xnor) of A and B
            assign PP = A[AB_WIDTH-1] ^~ B[AB_WIDTH-1];
            if (AB_SIGNED)
                assign GG = ~A[AB_WIDTH-1] & B[AB_WIDTH-1];
            else if (_TECHMAP_CONSTMSK_P_[LCU_WIDTH-1]) // First compare for LUT if P (and G) is constant
                assign GG = A[AB_WIDTH-1] & ~B[AB_WIDTH-1];
            else
                // Priority "encoder" that checks A[i] == 1'b1 && B[i] == 1'b0
                //   from MSB down, deferring to less significant bits if the
                //   MSBs are equal
                assign GG = P[0] & (A[AB_WIDTH-1] & ~B[AB_WIDTH-1]);
            (* force_downto *)
            wire [LCU_WIDTH-1:0] P_, G_;
            if (LCU_WIDTH == 1) begin
                // Propagate only if all pairs are equal
                //   (inconclusive evidence to say A >= B)
                assign P_ = P[0] & PP;
                // Generate if any comparisons call for it
                assign G_ = G[0] | GG;
            end
            else begin
                // Propagate only if all pairs are equal
                //   (inconclusive evidence to say A >= B)
                assign P_ = {P[LCU_WIDTH-1:1], P[0] & PP};
                // Generate if any comparisons call for it
                assign G_ = {G[LCU_WIDTH-1:1], G[0] | GG};
            end
            if (AB_WIDTH == 1)
               $__CMP2LCU #(.AB_WIDTH(AB_WIDTH-1), .AB_SIGNED(1'b0), .LCU_WIDTH(LCU_WIDTH), .BUDGET(BUDGET-COST), .CI(CI))
                    _TECHMAP_REPLACE_ (.A(), .B(), .P(P_), .G(G_), .Y(Y));
            else
               $__CMP2LCU #(.AB_WIDTH(AB_WIDTH-1), .AB_SIGNED(1'b0), .LCU_WIDTH(LCU_WIDTH), .BUDGET(BUDGET-COST), .CI(CI))
                    _TECHMAP_REPLACE_ (.A(A[AB_WIDTH-2:0]), .B(B[AB_WIDTH-2:0]), .P(P_), .G(G_), .Y(Y));
        end
    end
endgenerate
endmodule
`,"cmp2lut.v":`// Certain arithmetic operations between a signal of width n and a constant can be directly mapped
// to a single k-LUT (where n <= k). This is preferable to normal alumacc techmapping process
// because for many targets, arithmetic techmapping creates hard logic (such as carry cells) which often
// cannot be optimized further.
//
// TODO: Currently, only comparisons with 1-bit output are mapped. Potentially, all arithmetic cells
// with n <= k inputs should be techmapped in this way, because this shortens the critical path
// from n to 1 by avoiding carry chains.

(* techmap_celltype = "$lt $le $gt $ge" *)
module _90_lut_cmp_ (A, B, Y);

parameter A_SIGNED = 0;
parameter B_SIGNED = 0;
parameter A_WIDTH = 0;
parameter B_WIDTH = 0;
parameter Y_WIDTH = 0;

(* force_downto *)
input [A_WIDTH-1:0] A;
(* force_downto *)
input [B_WIDTH-1:0] B;
(* force_downto *)
output [Y_WIDTH-1:0] Y;

parameter _TECHMAP_CELLTYPE_ = "";

parameter _TECHMAP_CONSTMSK_A_ = 0;
parameter _TECHMAP_CONSTVAL_A_ = 0;
parameter _TECHMAP_CONSTMSK_B_ = 0;
parameter _TECHMAP_CONSTVAL_B_ = 0;

function automatic [(1 << \`LUT_WIDTH)-1:0] gen_lut;
	input integer width;
	input integer operation;
	input integer swap;
	input integer sign;
	input integer operand;
	integer n, i_var, i_cst, lhs, rhs, o_bit;
	begin
		gen_lut = width'b0;
		for (n = 0; n < (1 << width); n++) begin
			if (sign)
				i_var = n[width-1:0];
			else
				i_var = n;
			i_cst = operand;
			if (swap) begin
				lhs = i_cst;
				rhs = i_var;
			end else begin
				lhs = i_var;
				rhs = i_cst;
			end
			if (operation == 0)
				o_bit = (lhs <  rhs);
			if (operation == 1)
				o_bit = (lhs <= rhs);
			if (operation == 2)
				o_bit = (lhs >  rhs);
			if (operation == 3)
				o_bit = (lhs >= rhs);
			gen_lut = gen_lut | (o_bit << n);
		end
	end
endfunction

generate
	localparam operation =
		_TECHMAP_CELLTYPE_ == "$lt" ? 0 :
		_TECHMAP_CELLTYPE_ == "$le" ? 1 :
		_TECHMAP_CELLTYPE_ == "$gt" ? 2 :
		_TECHMAP_CELLTYPE_ == "$ge" ? 3 :
		-1;

	if (A_WIDTH > \`LUT_WIDTH || B_WIDTH > \`LUT_WIDTH || Y_WIDTH != 1)
		wire _TECHMAP_FAIL_ = 1;
	else if (&_TECHMAP_CONSTMSK_B_)
		\\$lut #(
			.WIDTH(A_WIDTH),
			.LUT({ gen_lut(A_WIDTH, operation, 0, A_SIGNED && B_SIGNED, _TECHMAP_CONSTVAL_B_) })
		) _TECHMAP_REPLACE_ (
			.A(A),
			.Y(Y)
		);
	else if (&_TECHMAP_CONSTMSK_A_)
		\\$lut #(
			.WIDTH(B_WIDTH),
			.LUT({ gen_lut(B_WIDTH, operation, 1, A_SIGNED && B_SIGNED, _TECHMAP_CONSTVAL_A_) })
		) _TECHMAP_REPLACE_ (
			.A(B),
			.Y(Y)
		);
	else
		wire _TECHMAP_FAIL_ = 1;
endgenerate

endmodule
`,"cmp2softlogic.v":`module constgtge(C, A, B, Y);
parameter A_WIDTH = 0;
parameter B_WIDTH = 0;

(* force_downto *)
input [A_WIDTH-1:0] A;
(* force_downto *)
input [B_WIDTH-1:0] B;
output Y;
input C;

wire [A_WIDTH:0] ch;
genvar n;
generate
	if (B_WIDTH > A_WIDTH) begin
		// Fail
	end else begin
		assign ch[0] = C;
		for (n = 0; n < A_WIDTH; n = n + 1) begin
			if (n < B_WIDTH) begin
				assign ch[n + 1] = B[n] ? (ch[n] && A[n]) : (ch[n] || A[n]);
			end else begin
				assign ch[n + 1] = ch[n] || A[n];
			end
		end
		assign Y = ch[A_WIDTH];
	end
endgenerate
endmodule

module constltle(C, A, B, Y);
parameter A_WIDTH = 0;
parameter B_WIDTH = 0;

(* force_downto *)
input [A_WIDTH-1:0] A;
(* force_downto *)
input [B_WIDTH-1:0] B;
output Y;
input C;

wire [A_WIDTH:0] ch;
genvar n;
generate
	if (B_WIDTH > A_WIDTH) begin
		// Fail
	end else begin
		assign ch[0] = C;
		for (n = 0; n < A_WIDTH; n = n + 1) begin
			if (n < B_WIDTH) begin
				assign ch[n + 1] = !B[n] ? (ch[n] && !A[n]) : (ch[n] || !A[n]);
			end else begin
				assign ch[n + 1] = ch[n] && !A[n];
			end
		end
		assign Y = ch[A_WIDTH];
	end
endgenerate
endmodule

(* techmap_celltype = "$ge $gt $le $lt" *)
module _map_const_cmp_(A, B, Y);
parameter A_WIDTH = 0;
parameter B_WIDTH = 0;
parameter Y_WIDTH = 0;
parameter A_SIGNED = 0;
parameter B_SIGNED = 0;

(* force_downto *)
input [A_WIDTH-1:0] A;
(* force_downto *)
input [B_WIDTH-1:0] B;
(* force_downto *)
output [Y_WIDTH-1:0] Y;

parameter _TECHMAP_CELLTYPE_ = "";

parameter _TECHMAP_CONSTMSK_A_ = 0;
parameter _TECHMAP_CONSTVAL_A_ = 0;
parameter _TECHMAP_CONSTMSK_B_ = 0;
parameter _TECHMAP_CONSTVAL_B_ = 0;

wire [1023:0] _TECHMAP_DO_ = "opt -fast;";

wire [A_WIDTH:0] ch;

genvar n;
generate
	if (Y_WIDTH != 1 || A_SIGNED || B_SIGNED)
		wire _TECHMAP_FAIL_ = 1;
	else if (&_TECHMAP_CONSTMSK_A_) begin
		if (A_WIDTH > B_WIDTH)
			wire _TECHMAP_FAIL_ = 1;
		else if (_TECHMAP_CELLTYPE_ == "$lt" || _TECHMAP_CELLTYPE_ == "$le")
			constgtge #(.A_WIDTH(B_WIDTH), .B_WIDTH(A_WIDTH))
				_TECHMAP_REPLACE_(.A(B), .B(A), .Y(Y),
					.C(_TECHMAP_CELLTYPE_ == "$lt"));
		else
			constltle #(.A_WIDTH(B_WIDTH), .B_WIDTH(A_WIDTH))
				_TECHMAP_REPLACE_(.A(B), .B(A), .Y(Y),
					.C(_TECHMAP_CELLTYPE_ == "$gt"));
	end else if (&_TECHMAP_CONSTMSK_B_) begin
		if (B_WIDTH > A_WIDTH)
			wire _TECHMAP_FAIL_ = 1;
		else if (_TECHMAP_CELLTYPE_ == "$lt" || _TECHMAP_CELLTYPE_ == "$le")
			constltle #(.A_WIDTH(A_WIDTH), .B_WIDTH(B_WIDTH))
				_TECHMAP_REPLACE_(.A(A), .B(B), .Y(Y),
					.C(_TECHMAP_CELLTYPE_ == "$le"));
		else
			constgtge #(.A_WIDTH(A_WIDTH), .B_WIDTH(B_WIDTH))
				_TECHMAP_REPLACE_(.A(A), .B(B), .Y(Y),
					.C(_TECHMAP_CELLTYPE_ == "$ge"));
	end else
		wire _TECHMAP_FAIL_ = 1;
endgenerate

endmodule
`,coolrunner2:{"cells_counter_map.v":`module \\$__COUNT_ (CE, CLK, OUT, POUT, RST, UP);

    input wire CE;
    input wire CLK;
    output wire OUT;
    (* force_downto *)
    output wire[WIDTH-1:0] POUT;
    input wire RST;
    input wire UP;

    parameter COUNT_TO = 1;
    parameter RESET_MODE = "RISING";
    parameter RESET_TO_MAX = 0;
    parameter HAS_POUT = 0;
    parameter HAS_CE = 0;
    parameter WIDTH = 8;
    parameter DIRECTION = "DOWN";

    if (DIRECTION == "UP") begin
        if (WIDTH < 2) begin
            initial begin
                $display("ERROR: \\$__COUNT_ must be at least 2 bits wide (bug in extract_counter pass?).");
                $finish;
            end
        end

        // FIXME: Max width?

        assign OUT = POUT == COUNT_TO;

        if (HAS_CE) begin
            genvar i;
            for (i = 0; i < WIDTH; i++) begin: countbits
                // each bit = (cur & !reset) ^ (all prev & !reset)
                wire xor_to_mc_bitn;
                FDCP #(
                    .INIT(0)
                ) bitn_ff (
                    .C(CLK),
                    .CLR(0),
                    .D(xor_to_mc_bitn),
                    .PRE(0),
                    .Q(POUT[i])
                );
                wire orterm_to_xor_bitn;
                wire pterm0_to_or_bitn;
                wire pterm1_to_or_bitn;
                MACROCELL_XOR #(
                    .INVERT_OUT(0)
                ) bitn_xor (
                    .IN_ORTERM(orterm_to_xor_bitn),
                    .IN_PTC(pterm1_to_or_bitn),
                    .OUT(xor_to_mc_bitn)
                );
                ORTERM #(
                    .WIDTH(1)
                ) bitn_or (
                    .IN(pterm0_to_or_bitn),
                    .OUT(orterm_to_xor_bitn)
                );
                ANDTERM #(
                    .COMP_INP(1),
                    .TRUE_INP(1)
                ) bitn_pterm0 (
                    .IN(POUT[i]),
                    .IN_B(OUT),
                    .OUT(pterm0_to_or_bitn)
                );
                ANDTERM #(
                    .COMP_INP(1),
                    .TRUE_INP(i + 1)
                ) bitn_pterm1 (
                    .IN({POUT[i-1:0], CE}),
                    .IN_B(OUT),
                    .OUT(pterm1_to_or_bitn)
                );
            end
        end else begin
            // Bit0 is special; toggle unless reset
            // cur  reset           out
            // 0    0               1
            // 0    1               0
            // 1    0               0
            // 1    1               0
            wire xor_to_mc_bit0;
            FDCP #(
                .INIT(0)
            ) bit0_ff (
                .C(CLK),
                .CLR(0),
                .D(xor_to_mc_bit0),
                .PRE(0),
                .Q(POUT[0])
            );
            wire pterm_to_xor_bit0;
            MACROCELL_XOR #(
                .INVERT_OUT(0)
            ) bit0_xor (
                .IN_PTC(pterm_to_xor_bit0),
                .OUT(xor_to_mc_bit0)
            );
            ANDTERM #(
                .COMP_INP(2),
                .TRUE_INP(0)
            ) bit0_pterm (
                .IN(),
                .IN_B({POUT[0], OUT}),
                .OUT(pterm_to_xor_bit0)
            );

            genvar i;
            for (i = 1; i < WIDTH; i++) begin: countbits
                // each bit = (cur & !reset) ^ (all prev & !reset)
                wire xor_to_mc_bitn;
                FDCP #(
                    .INIT(0)
                ) bitn_ff (
                    .C(CLK),
                    .CLR(0),
                    .D(xor_to_mc_bitn),
                    .PRE(0),
                    .Q(POUT[i])
                );
                wire orterm_to_xor_bitn;
                wire pterm0_to_or_bitn;
                wire pterm1_to_or_bitn;
                MACROCELL_XOR #(
                    .INVERT_OUT(0)
                ) bitn_xor (
                    .IN_ORTERM(orterm_to_xor_bitn),
                    .IN_PTC(pterm1_to_or_bitn),
                    .OUT(xor_to_mc_bitn)
                );
                ORTERM #(
                    .WIDTH(1)
                ) bitn_or (
                    .IN(pterm0_to_or_bitn),
                    .OUT(orterm_to_xor_bitn)
                );
                ANDTERM #(
                    .COMP_INP(1),
                    .TRUE_INP(1)
                ) bitn_pterm0 (
                    .IN(POUT[i]),
                    .IN_B(OUT),
                    .OUT(pterm0_to_or_bitn)
                );
                ANDTERM #(
                    .COMP_INP(1),
                    .TRUE_INP(i)
                ) bitn_pterm1 (
                    .IN(POUT[i-1:0]),
                    .IN_B(OUT),
                    .OUT(pterm1_to_or_bitn)
                );
            end
        end
    end

    // FIXME: down counters

endmodule
`,"cells_latch.v":`module $_DLATCH_P_(input E, input D, output Q);
    LDCP _TECHMAP_REPLACE_ (
        .D(D),
        .G(E),
        .Q(Q),
        .PRE(1'b0),
        .CLR(1'b0)
        );
endmodule

module $_DLATCH_N_(input E, input D, output Q);
    LDCP_N _TECHMAP_REPLACE_ (
        .D(D),
        .G(E),
        .Q(Q),
        .PRE(1'b0),
        .CLR(1'b0)
        );
endmodule
`,"cells_sim.v":`module IBUF(input I, output O);
    assign O = I;
endmodule

module IOBUFE(input I, input E, output O, inout IO);
    assign O = IO;
    assign IO = E ? I : 1'bz;
endmodule

module ANDTERM(IN, IN_B, OUT);
    parameter TRUE_INP = 0;
    parameter COMP_INP = 0;

    input [TRUE_INP-1:0] IN;
    input [COMP_INP-1:0] IN_B;
    output reg OUT;

    integer i;

    always @(*) begin
        OUT = 1;
        for (i = 0; i < TRUE_INP; i=i+1)
            OUT = OUT & IN[i];
        for (i = 0; i < COMP_INP; i=i+1)
            OUT = OUT & ~IN_B[i];
    end
endmodule

module ORTERM(IN, OUT);
    parameter WIDTH = 0;

    input [WIDTH-1:0] IN;
    output reg OUT;

    integer i;

    always @(*) begin
        OUT = 0;
        for (i = 0; i < WIDTH; i=i+1) begin
            OUT = OUT | IN[i];
        end
    end
endmodule

module MACROCELL_XOR(IN_PTC, IN_ORTERM, OUT);
    parameter INVERT_OUT = 0;

    input IN_PTC;
    input IN_ORTERM;
    output wire OUT;

    wire xor_intermed;

    assign OUT = INVERT_OUT ? ~xor_intermed : xor_intermed;
    assign xor_intermed = IN_ORTERM ^ IN_PTC;
endmodule

module FDCP (C, PRE, CLR, D, Q);
    parameter INIT = 0;

    input C, PRE, CLR, D;
    output reg Q;

    initial begin
        Q <= INIT;
    end

    always @(posedge C, posedge PRE, posedge CLR) begin
        if (CLR == 1)
            Q <= 0;
        else if (PRE == 1)
            Q <= 1;
        else
            Q <= D;
    end
endmodule

module FDCP_N (C, PRE, CLR, D, Q);
    parameter INIT = 0;

    input C, PRE, CLR, D;
    output reg Q;

    initial begin
        Q <= INIT;
    end

    always @(negedge C, posedge PRE, posedge CLR) begin
        if (CLR == 1)
            Q <= 0;
        else if (PRE == 1)
            Q <= 1;
        else
            Q <= D;
    end
endmodule

module LDCP (G, PRE, CLR, D, Q);
    parameter INIT = 0;

    input G, PRE, CLR, D;
    output reg Q;

    initial begin
        Q <= INIT;
    end

    always @* begin
        if (CLR == 1)
            Q <= 0;
        else if (G == 1)
            Q <= D;
        else if (PRE == 1)
            Q <= 1;
    end
endmodule

module LDCP_N (G, PRE, CLR, D, Q);
    parameter INIT = 0;

    input G, PRE, CLR, D;
    output reg Q;

    initial begin
        Q <= INIT;
    end

    always @* begin
        if (CLR == 1)
            Q <= 0;
        else if (G == 0)
            Q <= D;
        else if (PRE == 1)
            Q <= 1;
    end
endmodule

module BUFG(I, O);
    input I;
    output O;

    assign O = I;
endmodule

module BUFGSR(I, O);
    parameter INVERT = 0;

    input I;
    output O;

    assign O = INVERT ? ~I : I;
endmodule

module BUFGTS(I, O);
    parameter INVERT = 0;

    input I;
    output O;

    assign O = INVERT ? ~I : I;
endmodule

module FDDCP (C, PRE, CLR, D, Q);
    parameter INIT = 0;

    input C, PRE, CLR, D;
    output reg Q;

    initial begin
        Q <= INIT;
    end

    always @(posedge C, negedge C, posedge PRE, posedge CLR) begin
        if (CLR == 1)
            Q <= 0;
        else if (PRE == 1)
            Q <= 1;
        else
            Q <= D;
    end
endmodule

module FTCP (C, PRE, CLR, T, Q);
    parameter INIT = 0;

    input C, PRE, CLR, T;
    output wire Q;
    reg Q_;

    initial begin
        Q_ <= INIT;
    end

    always @(posedge C, posedge PRE, posedge CLR) begin
        if (CLR == 1)
            Q_ <= 0;
        else if (PRE == 1)
            Q_ <= 1;
        else if (T == 1)
            Q_ <= ~Q_;
    end

    assign Q = Q_;
endmodule

module FTCP_N (C, PRE, CLR, T, Q);
    parameter INIT = 0;

    input C, PRE, CLR, T;
    output wire Q;
    reg Q_;

    initial begin
        Q_ <= INIT;
    end

    always @(negedge C, posedge PRE, posedge CLR) begin
        if (CLR == 1)
            Q_ <= 0;
        else if (PRE == 1)
            Q_ <= 1;
        else if (T == 1)
            Q_ <= ~Q_;
    end

    assign Q = Q_;
endmodule

module FTDCP (C, PRE, CLR, T, Q);
    parameter INIT = 0;

    input C, PRE, CLR, T;
    output wire Q;
    reg Q_;

    initial begin
        Q_ <= INIT;
    end

    always @(posedge C, negedge C, posedge PRE, posedge CLR) begin
        if (CLR == 1)
            Q_ <= 0;
        else if (PRE == 1)
            Q_ <= 1;
        else if (T == 1)
            Q_ <= ~Q_;
    end

    assign Q = Q_;
endmodule

module FDCPE (C, PRE, CLR, D, Q, CE);
    parameter INIT = 0;

    input C, PRE, CLR, D, CE;
    output reg Q;

    initial begin
        Q <= INIT;
    end

    always @(posedge C, posedge PRE, posedge CLR) begin
        if (CLR == 1)
            Q <= 0;
        else if (PRE == 1)
            Q <= 1;
        else if (CE == 1)
            Q <= D;
    end
endmodule

module FDCPE_N (C, PRE, CLR, D, Q, CE);
    parameter INIT = 0;

    input C, PRE, CLR, D, CE;
    output reg Q;

    initial begin
        Q <= INIT;
    end

    always @(negedge C, posedge PRE, posedge CLR) begin
        if (CLR == 1)
            Q <= 0;
        else if (PRE == 1)
            Q <= 1;
        else if (CE == 1)
            Q <= D;
    end
endmodule

module FDDCPE (C, PRE, CLR, D, Q, CE);
    parameter INIT = 0;

    input C, PRE, CLR, D, CE;
    output reg Q;

    initial begin
        Q <= INIT;
    end

    always @(posedge C, negedge C, posedge PRE, posedge CLR) begin
        if (CLR == 1)
            Q <= 0;
        else if (PRE == 1)
            Q <= 1;
        else if (CE == 1)
            Q <= D;
    end
endmodule
`,"tff_extract.v":`module FTCP (C, PRE, CLR, T, Q);
	input C, PRE, CLR, T;
	output wire Q;

	wire xorout;

	$_XOR_ xorgate (
		.A(T),
		.B(Q),
		.Y(xorout),
	);

	$_DFFSR_PPP_ dff (
		.C(C),
		.D(xorout),
		.Q(Q),
		.S(PRE),
		.R(CLR),
	);
endmodule

module FTCP_N (C, PRE, CLR, T, Q);
	input C, PRE, CLR, T;
	output wire Q;

	wire xorout;

	$_XOR_ xorgate (
		.A(T),
		.B(Q),
		.Y(xorout),
	);

	$_DFFSR_NPP_ dff (
		.C(C),
		.D(xorout),
		.Q(Q),
		.S(PRE),
		.R(CLR),
	);
endmodule
`,"xc2_dff.lib":`library(xc2_dff) {
  cell(FDCP) {
    area: 1;
    ff("IQ", "IQN") { clocked_on: C;
                      next_state: D;
                      clear: "CLR";
                      preset: "PRE"; }
    pin(C) { direction: input;
             clock: true; }
    pin(D) { direction: input; }
    pin(Q) { direction: output;
             function: "IQ"; }
    pin(CLR) { direction: input; }
    pin(PRE) { direction: input; }
  }

  cell(FDCP_N) {
    area: 1;
    ff("IQ", "IQN") { clocked_on: "!C";
                      next_state: D;
                      clear: "CLR";
                      preset: "PRE"; }
    pin(C) { direction: input;
             clock: true; }
    pin(D) { direction: input; }
    pin(Q) { direction: output;
             function: "IQ"; }
    pin(CLR) { direction: input; }
    pin(PRE) { direction: input; }
  }
}
`},"dff2ff.v":`(* techmap_celltype = "$dff" *)
module dff2ff (CLK, D, Q);
	parameter WIDTH = 1;
	parameter CLK_POLARITY = 1;

	input CLK;
	(* force_downto *)
	input [WIDTH-1:0] D;
	(* force_downto *)
	output reg [WIDTH-1:0] Q;

	wire [1023:0] _TECHMAP_DO_ = "proc;;";

	always @($global_clock)
		Q <= D;
endmodule
`,ecp5:{"arith_map.v":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *  Copyright (C) 2018  gatecat <gatecat@ds0.me>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

(* techmap_celltype = "$alu" *)
module _80_ecp5_alu (A, B, CI, BI, X, Y, CO);
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;
	parameter A_WIDTH = 1;
	parameter B_WIDTH = 1;
	parameter Y_WIDTH = 1;

	(* force_downto *)
	input [A_WIDTH-1:0] A;
	(* force_downto *)
	input [B_WIDTH-1:0] B;
	(* force_downto *)
	output [Y_WIDTH-1:0] X, Y;

	input CI, BI;
	(* force_downto *)
	output [Y_WIDTH-1:0] CO;

	wire _TECHMAP_FAIL_ = Y_WIDTH <= 4;

	(* force_downto *)
	wire [Y_WIDTH-1:0] A_buf, B_buf;
	\\$pos #(.A_SIGNED(A_SIGNED), .A_WIDTH(A_WIDTH), .Y_WIDTH(Y_WIDTH)) A_conv (.A(A), .Y(A_buf));
	\\$pos #(.A_SIGNED(B_SIGNED), .A_WIDTH(B_WIDTH), .Y_WIDTH(Y_WIDTH)) B_conv (.A(B), .Y(B_buf));

	function integer round_up2;
		input integer N;
		begin
			round_up2 = ((N + 1) / 2) * 2;
		end
	endfunction

	localparam Y_WIDTH2 = round_up2(Y_WIDTH);

	(* force_downto *)
	wire [Y_WIDTH2-1:0] AA = A_buf;
	(* force_downto *)
	wire [Y_WIDTH2-1:0] BB = BI ? ~B_buf : B_buf;
	(* force_downto *)
	wire [Y_WIDTH2-1:0] BX = B_buf;
	(* force_downto *)
	wire [Y_WIDTH2-1:0] C = {CO, CI};
	(* force_downto *)
	wire [Y_WIDTH2-1:0] FCO, Y1;

	genvar i;
	generate for (i = 0; i < Y_WIDTH2; i = i + 2) begin:slice
		CCU2C #(
			.INIT0(16'b1001011010101010),
			.INIT1(16'b1001011010101010),
			.INJECT1_0("NO"),
			.INJECT1_1("NO")
	   ) ccu2c_i (
			.CIN(C[i]),
			.A0(AA[i]), .B0(BX[i]), .C0(BI), .D0(1'b1),
			.A1(AA[i+1]), .B1(BX[i+1]), .C1(BI), .D1(1'b1),
			.S0(Y[i]), .S1(Y1[i]),
			.COUT(FCO[i])
		);

		assign CO[i] = (AA[i] && BB[i]) || (C[i] && (AA[i] || BB[i]));
		if (i+1 < Y_WIDTH) begin
			assign CO[i+1] = FCO[i];
			assign Y[i+1] = Y1[i];
		end
	end endgenerate

	assign X = AA ^ BB;
endmodule
`,"brams.txt":`ram block $__ECP5_DP16KD_ {
	abits 14;
	widths 1 2 4 9 18 per_port;
	byte 9;
	cost 128;
	init no_undef;
	port srsw "A" "B" {
		clock anyedge;
		clken;
		wrbe_separate;
		portoption "WRITEMODE" "NORMAL" {
			rdwr no_change;
		}
		portoption "WRITEMODE" "WRITETHROUGH" {
			rdwr new;
		}
		portoption "WRITEMODE" "READBEFOREWRITE" {
			rdwr old;
		}
		option "RESETMODE" "SYNC" {
			rdsrst zero ungated block_wr;
		}
		option "RESETMODE" "ASYNC" {
			rdarst zero;
		}
		rdinit zero;
	}
}

ram block $__ECP5_PDPW16KD_ {
	abits 14;
	widths 1 2 4 9 18 36 per_port;
	byte 9;
	cost 128;
	init no_undef;
	port sr "R" {
		clock anyedge;
		clken;
		option "RESETMODE" "SYNC" {
			rdsrst zero ungated;
		}
		option "RESETMODE" "ASYNC" {
			rdarst zero;
		}
		rdinit zero;
	}
	port sw "W" {
		width 36;
		clock anyedge;
		clken;
	}
}
`,"brams_map.v":`module $__ECP5_DP16KD_ (...);

parameter INIT = 0;
parameter OPTION_RESETMODE = "SYNC";

parameter PORT_A_WIDTH = 18;
parameter PORT_A_WR_BE_WIDTH = 2;
parameter PORT_A_CLK_POL = 1;
parameter PORT_A_OPTION_WRITEMODE = "NORMAL";

input PORT_A_CLK;
input PORT_A_CLK_EN;
input PORT_A_WR_EN;
input PORT_A_RD_SRST;
input PORT_A_RD_ARST;
input [13:0] PORT_A_ADDR;
input [PORT_A_WR_BE_WIDTH-1:0] PORT_A_WR_BE;
input [PORT_A_WIDTH-1:0] PORT_A_WR_DATA;
output [PORT_A_WIDTH-1:0] PORT_A_RD_DATA;

parameter PORT_B_WIDTH = 18;
parameter PORT_B_WR_BE_WIDTH = 2;
parameter PORT_B_CLK_POL = 1;
parameter PORT_B_OPTION_WRITEMODE = "NORMAL";

input PORT_B_CLK;
input PORT_B_CLK_EN;
input PORT_B_WR_EN;
input PORT_B_RD_SRST;
input PORT_B_RD_ARST;
input [13:0] PORT_B_ADDR;
input [PORT_B_WR_BE_WIDTH-1:0] PORT_B_WR_BE;
input [PORT_B_WIDTH-1:0] PORT_B_WR_DATA;
output [PORT_B_WIDTH-1:0] PORT_B_RD_DATA;

function [319:0] init_slice;
	input integer idx;
	integer i, j;
	init_slice = 0;
	for (i = 0; i < 16; i = i + 1) begin
		init_slice[i*20+:18] = INIT[(idx * 16 + i) * 18+:18];
	end
endfunction

wire [17:0] DOA;
wire [17:0] DOB;
wire [17:0] DIA = PORT_A_WR_DATA;
wire [17:0] DIB = PORT_B_WR_DATA;

assign PORT_A_RD_DATA = DOA;
assign PORT_B_RD_DATA = DOB;

DP16KD #(
	.INITVAL_00(init_slice('h00)),
	.INITVAL_01(init_slice('h01)),
	.INITVAL_02(init_slice('h02)),
	.INITVAL_03(init_slice('h03)),
	.INITVAL_04(init_slice('h04)),
	.INITVAL_05(init_slice('h05)),
	.INITVAL_06(init_slice('h06)),
	.INITVAL_07(init_slice('h07)),
	.INITVAL_08(init_slice('h08)),
	.INITVAL_09(init_slice('h09)),
	.INITVAL_0A(init_slice('h0a)),
	.INITVAL_0B(init_slice('h0b)),
	.INITVAL_0C(init_slice('h0c)),
	.INITVAL_0D(init_slice('h0d)),
	.INITVAL_0E(init_slice('h0e)),
	.INITVAL_0F(init_slice('h0f)),
	.INITVAL_10(init_slice('h10)),
	.INITVAL_11(init_slice('h11)),
	.INITVAL_12(init_slice('h12)),
	.INITVAL_13(init_slice('h13)),
	.INITVAL_14(init_slice('h14)),
	.INITVAL_15(init_slice('h15)),
	.INITVAL_16(init_slice('h16)),
	.INITVAL_17(init_slice('h17)),
	.INITVAL_18(init_slice('h18)),
	.INITVAL_19(init_slice('h19)),
	.INITVAL_1A(init_slice('h1a)),
	.INITVAL_1B(init_slice('h1b)),
	.INITVAL_1C(init_slice('h1c)),
	.INITVAL_1D(init_slice('h1d)),
	.INITVAL_1E(init_slice('h1e)),
	.INITVAL_1F(init_slice('h1f)),
	.INITVAL_20(init_slice('h20)),
	.INITVAL_21(init_slice('h21)),
	.INITVAL_22(init_slice('h22)),
	.INITVAL_23(init_slice('h23)),
	.INITVAL_24(init_slice('h24)),
	.INITVAL_25(init_slice('h25)),
	.INITVAL_26(init_slice('h26)),
	.INITVAL_27(init_slice('h27)),
	.INITVAL_28(init_slice('h28)),
	.INITVAL_29(init_slice('h29)),
	.INITVAL_2A(init_slice('h2a)),
	.INITVAL_2B(init_slice('h2b)),
	.INITVAL_2C(init_slice('h2c)),
	.INITVAL_2D(init_slice('h2d)),
	.INITVAL_2E(init_slice('h2e)),
	.INITVAL_2F(init_slice('h2f)),
	.INITVAL_30(init_slice('h30)),
	.INITVAL_31(init_slice('h31)),
	.INITVAL_32(init_slice('h32)),
	.INITVAL_33(init_slice('h33)),
	.INITVAL_34(init_slice('h34)),
	.INITVAL_35(init_slice('h35)),
	.INITVAL_36(init_slice('h36)),
	.INITVAL_37(init_slice('h37)),
	.INITVAL_38(init_slice('h38)),
	.INITVAL_39(init_slice('h39)),
	.INITVAL_3A(init_slice('h3a)),
	.INITVAL_3B(init_slice('h3b)),
	.INITVAL_3C(init_slice('h3c)),
	.INITVAL_3D(init_slice('h3d)),
	.INITVAL_3E(init_slice('h3e)),
	.INITVAL_3F(init_slice('h3f)),
	.DATA_WIDTH_A(PORT_A_WIDTH),
	.DATA_WIDTH_B(PORT_B_WIDTH),
	.REGMODE_A("NOREG"),
	.REGMODE_B("NOREG"),
	.RESETMODE(OPTION_RESETMODE),
	.ASYNC_RESET_RELEASE(OPTION_RESETMODE),
	.CSDECODE_A("0b000"),
	.CSDECODE_B("0b000"),
	.CLKAMUX(PORT_A_CLK_POL ? "CLKA" : "INV"),
	.CLKBMUX(PORT_B_CLK_POL ? "CLKB" : "INV"),
	.WRITEMODE_A(PORT_A_OPTION_WRITEMODE),
	.WRITEMODE_B(PORT_B_OPTION_WRITEMODE),
	.GSR("AUTO")
) _TECHMAP_REPLACE_ (
	.CLKA(PORT_A_CLK),
	.WEA(PORT_A_WIDTH == 18 ? PORT_A_WR_EN : (PORT_A_WR_EN | PORT_A_WR_BE[0])),
	.CEA(PORT_A_CLK_EN),
	.OCEA(1'b1),
	.RSTA(OPTION_RESETMODE == "SYNC" ? PORT_A_RD_SRST : PORT_A_RD_ARST),
	.CSA0(1'b0),
	.CSA1(1'b0),
	.CSA2(1'b0),
	.ADA0(PORT_A_WIDTH == 18 ? PORT_A_WR_BE[0] : PORT_A_ADDR[0]),
	.ADA1(PORT_A_WIDTH == 18 ? PORT_A_WR_BE[1] : PORT_A_ADDR[1]),
	.ADA2(PORT_A_ADDR[2]),
	.ADA3(PORT_A_ADDR[3]),
	.ADA4(PORT_A_ADDR[4]),
	.ADA5(PORT_A_ADDR[5]),
	.ADA6(PORT_A_ADDR[6]),
	.ADA7(PORT_A_ADDR[7]),
	.ADA8(PORT_A_ADDR[8]),
	.ADA9(PORT_A_ADDR[9]),
	.ADA10(PORT_A_ADDR[10]),
	.ADA11(PORT_A_ADDR[11]),
	.ADA12(PORT_A_ADDR[12]),
	.ADA13(PORT_A_ADDR[13]),
	.DIA0(DIA[0]),
	.DIA1(DIA[1]),
	.DIA2(DIA[2]),
	.DIA3(DIA[3]),
	.DIA4(DIA[4]),
	.DIA5(DIA[5]),
	.DIA6(DIA[6]),
	.DIA7(DIA[7]),
	.DIA8(DIA[8]),
	.DIA9(DIA[9]),
	.DIA10(DIA[10]),
	.DIA11(DIA[11]),
	.DIA12(DIA[12]),
	.DIA13(DIA[13]),
	.DIA14(DIA[14]),
	.DIA15(DIA[15]),
	.DIA16(DIA[16]),
	.DIA17(DIA[17]),
	.DOA0(DOA[0]),
	.DOA1(DOA[1]),
	.DOA2(DOA[2]),
	.DOA3(DOA[3]),
	.DOA4(DOA[4]),
	.DOA5(DOA[5]),
	.DOA6(DOA[6]),
	.DOA7(DOA[7]),
	.DOA8(DOA[8]),
	.DOA9(DOA[9]),
	.DOA10(DOA[10]),
	.DOA11(DOA[11]),
	.DOA12(DOA[12]),
	.DOA13(DOA[13]),
	.DOA14(DOA[14]),
	.DOA15(DOA[15]),
	.DOA16(DOA[16]),
	.DOA17(DOA[17]),

	.CLKB(PORT_B_CLK),
	.WEB(PORT_B_WIDTH == 18 ? PORT_B_WR_EN : (PORT_B_WR_EN | PORT_B_WR_BE[0])),
	.CEB(PORT_B_CLK_EN),
	.OCEB(1'b1),
	.RSTB(OPTION_RESETMODE == "SYNC" ? PORT_B_RD_SRST : PORT_B_RD_ARST),
	.CSB0(1'b0),
	.CSB1(1'b0),
	.CSB2(1'b0),
	.ADB0(PORT_B_WIDTH == 18 ? PORT_B_WR_BE[0] : PORT_B_ADDR[0]),
	.ADB1(PORT_B_WIDTH == 18 ? PORT_B_WR_BE[1] : PORT_B_ADDR[1]),
	.ADB2(PORT_B_ADDR[2]),
	.ADB3(PORT_B_ADDR[3]),
	.ADB4(PORT_B_ADDR[4]),
	.ADB5(PORT_B_ADDR[5]),
	.ADB6(PORT_B_ADDR[6]),
	.ADB7(PORT_B_ADDR[7]),
	.ADB8(PORT_B_ADDR[8]),
	.ADB9(PORT_B_ADDR[9]),
	.ADB10(PORT_B_ADDR[10]),
	.ADB11(PORT_B_ADDR[11]),
	.ADB12(PORT_B_ADDR[12]),
	.ADB13(PORT_B_ADDR[13]),
	.DIB0(DIB[0]),
	.DIB1(DIB[1]),
	.DIB2(DIB[2]),
	.DIB3(DIB[3]),
	.DIB4(DIB[4]),
	.DIB5(DIB[5]),
	.DIB6(DIB[6]),
	.DIB7(DIB[7]),
	.DIB8(DIB[8]),
	.DIB9(DIB[9]),
	.DIB10(DIB[10]),
	.DIB11(DIB[11]),
	.DIB12(DIB[12]),
	.DIB13(DIB[13]),
	.DIB14(DIB[14]),
	.DIB15(DIB[15]),
	.DIB16(DIB[16]),
	.DIB17(DIB[17]),
	.DOB0(DOB[0]),
	.DOB1(DOB[1]),
	.DOB2(DOB[2]),
	.DOB3(DOB[3]),
	.DOB4(DOB[4]),
	.DOB5(DOB[5]),
	.DOB6(DOB[6]),
	.DOB7(DOB[7]),
	.DOB8(DOB[8]),
	.DOB9(DOB[9]),
	.DOB10(DOB[10]),
	.DOB11(DOB[11]),
	.DOB12(DOB[12]),
	.DOB13(DOB[13]),
	.DOB14(DOB[14]),
	.DOB15(DOB[15]),
	.DOB16(DOB[16]),
	.DOB17(DOB[17]),
);

endmodule


module $__ECP5_PDPW16KD_ (...);

parameter INIT = 0;
parameter OPTION_RESETMODE = "SYNC";

parameter PORT_R_WIDTH = 36;
parameter PORT_R_CLK_POL = 1;

input PORT_R_CLK;
input PORT_R_CLK_EN;
input PORT_R_RD_SRST;
input PORT_R_RD_ARST;
input [13:0] PORT_R_ADDR;
output [PORT_R_WIDTH-1:0] PORT_R_RD_DATA;

parameter PORT_W_WIDTH = 36;
parameter PORT_W_WR_EN_WIDTH = 4;
parameter PORT_W_CLK_POL = 1;

input PORT_W_CLK;
input PORT_W_CLK_EN;
input [13:0] PORT_W_ADDR;
input [PORT_W_WR_EN_WIDTH-1:0] PORT_W_WR_EN;
input [PORT_W_WIDTH-1:0] PORT_W_WR_DATA;

function [319:0] init_slice;
	input integer idx;
	integer i, j;
	init_slice = 0;
	for (i = 0; i < 16; i = i + 1) begin
		init_slice[i*20+:18] = INIT[(idx * 16 + i) * 18+:18];
	end
endfunction

wire [35:0] DI = PORT_W_WR_DATA;
wire [35:0] DO;

assign PORT_R_RD_DATA = PORT_R_WIDTH == 36 ? DO : DO[35:18];

DP16KD #(
	.INITVAL_00(init_slice('h00)),
	.INITVAL_01(init_slice('h01)),
	.INITVAL_02(init_slice('h02)),
	.INITVAL_03(init_slice('h03)),
	.INITVAL_04(init_slice('h04)),
	.INITVAL_05(init_slice('h05)),
	.INITVAL_06(init_slice('h06)),
	.INITVAL_07(init_slice('h07)),
	.INITVAL_08(init_slice('h08)),
	.INITVAL_09(init_slice('h09)),
	.INITVAL_0A(init_slice('h0a)),
	.INITVAL_0B(init_slice('h0b)),
	.INITVAL_0C(init_slice('h0c)),
	.INITVAL_0D(init_slice('h0d)),
	.INITVAL_0E(init_slice('h0e)),
	.INITVAL_0F(init_slice('h0f)),
	.INITVAL_10(init_slice('h10)),
	.INITVAL_11(init_slice('h11)),
	.INITVAL_12(init_slice('h12)),
	.INITVAL_13(init_slice('h13)),
	.INITVAL_14(init_slice('h14)),
	.INITVAL_15(init_slice('h15)),
	.INITVAL_16(init_slice('h16)),
	.INITVAL_17(init_slice('h17)),
	.INITVAL_18(init_slice('h18)),
	.INITVAL_19(init_slice('h19)),
	.INITVAL_1A(init_slice('h1a)),
	.INITVAL_1B(init_slice('h1b)),
	.INITVAL_1C(init_slice('h1c)),
	.INITVAL_1D(init_slice('h1d)),
	.INITVAL_1E(init_slice('h1e)),
	.INITVAL_1F(init_slice('h1f)),
	.INITVAL_20(init_slice('h20)),
	.INITVAL_21(init_slice('h21)),
	.INITVAL_22(init_slice('h22)),
	.INITVAL_23(init_slice('h23)),
	.INITVAL_24(init_slice('h24)),
	.INITVAL_25(init_slice('h25)),
	.INITVAL_26(init_slice('h26)),
	.INITVAL_27(init_slice('h27)),
	.INITVAL_28(init_slice('h28)),
	.INITVAL_29(init_slice('h29)),
	.INITVAL_2A(init_slice('h2a)),
	.INITVAL_2B(init_slice('h2b)),
	.INITVAL_2C(init_slice('h2c)),
	.INITVAL_2D(init_slice('h2d)),
	.INITVAL_2E(init_slice('h2e)),
	.INITVAL_2F(init_slice('h2f)),
	.INITVAL_30(init_slice('h30)),
	.INITVAL_31(init_slice('h31)),
	.INITVAL_32(init_slice('h32)),
	.INITVAL_33(init_slice('h33)),
	.INITVAL_34(init_slice('h34)),
	.INITVAL_35(init_slice('h35)),
	.INITVAL_36(init_slice('h36)),
	.INITVAL_37(init_slice('h37)),
	.INITVAL_38(init_slice('h38)),
	.INITVAL_39(init_slice('h39)),
	.INITVAL_3A(init_slice('h3a)),
	.INITVAL_3B(init_slice('h3b)),
	.INITVAL_3C(init_slice('h3c)),
	.INITVAL_3D(init_slice('h3d)),
	.INITVAL_3E(init_slice('h3e)),
	.INITVAL_3F(init_slice('h3f)),
	.DATA_WIDTH_A(PORT_W_WIDTH),
	.DATA_WIDTH_B(PORT_R_WIDTH),
	.REGMODE_A("NOREG"),
	.REGMODE_B("NOREG"),
	.RESETMODE(OPTION_RESETMODE),
	.ASYNC_RESET_RELEASE(OPTION_RESETMODE),
	.CSDECODE_A("0b000"),
	.CSDECODE_B("0b000"),
	.CLKAMUX(PORT_W_CLK_POL ? "CLKA" : "INV"),
	.CLKBMUX(PORT_R_CLK_POL ? "CLKB" : "INV"),
	.GSR("AUTO")
) _TECHMAP_REPLACE_ (
	.CLKA(PORT_W_CLK),
	.WEA(PORT_W_WIDTH >= 18 ? 1'b1 : PORT_W_WR_EN[0]),
	.CEA(PORT_W_CLK_EN),
	.OCEA(1'b0),
	.RSTA(1'b0),
	.CSA0(1'b0),
	.CSA1(1'b0),
	.CSA2(1'b0),
	.ADA0(PORT_W_WIDTH >= 18 ? PORT_W_WR_EN[0] : PORT_W_ADDR[0]),
	.ADA1(PORT_W_WIDTH >= 18 ? PORT_W_WR_EN[1] : PORT_W_ADDR[1]),
	.ADA2(PORT_W_WIDTH >= 36 ? PORT_W_WR_EN[2] : PORT_W_ADDR[2]),
	.ADA3(PORT_W_WIDTH >= 36 ? PORT_W_WR_EN[3] : PORT_W_ADDR[3]),
	.ADA4(PORT_W_ADDR[4]),
	.ADA5(PORT_W_ADDR[5]),
	.ADA6(PORT_W_ADDR[6]),
	.ADA7(PORT_W_ADDR[7]),
	.ADA8(PORT_W_ADDR[8]),
	.ADA9(PORT_W_ADDR[9]),
	.ADA10(PORT_W_ADDR[10]),
	.ADA11(PORT_W_ADDR[11]),
	.ADA12(PORT_W_ADDR[12]),
	.ADA13(PORT_W_ADDR[13]),
	.DIA0(DI[0]),
	.DIA1(DI[1]),
	.DIA2(DI[2]),
	.DIA3(DI[3]),
	.DIA4(DI[4]),
	.DIA5(DI[5]),
	.DIA6(DI[6]),
	.DIA7(DI[7]),
	.DIA8(DI[8]),
	.DIA9(DI[9]),
	.DIA10(DI[10]),
	.DIA11(DI[11]),
	.DIA12(DI[12]),
	.DIA13(DI[13]),
	.DIA14(DI[14]),
	.DIA15(DI[15]),
	.DIA16(DI[16]),
	.DIA17(DI[17]),
	.DIB0(DI[18]),
	.DIB1(DI[19]),
	.DIB2(DI[20]),
	.DIB3(DI[21]),
	.DIB4(DI[22]),
	.DIB5(DI[23]),
	.DIB6(DI[24]),
	.DIB7(DI[25]),
	.DIB8(DI[26]),
	.DIB9(DI[27]),
	.DIB10(DI[28]),
	.DIB11(DI[29]),
	.DIB12(DI[30]),
	.DIB13(DI[31]),
	.DIB14(DI[32]),
	.DIB15(DI[33]),
	.DIB16(DI[34]),
	.DIB17(DI[35]),

	.CLKB(PORT_R_CLK),
	.WEB(1'b0),
	.CEB(PORT_R_CLK_EN),
	.OCEB(1'b1),
	.RSTB(OPTION_RESETMODE == "SYNC" ? PORT_R_RD_SRST : PORT_R_RD_ARST),
	.CSB0(1'b0),
	.CSB1(1'b0),
	.CSB2(1'b0),
	.ADB0(PORT_R_ADDR[0]),
	.ADB1(PORT_R_ADDR[1]),
	.ADB2(PORT_R_ADDR[2]),
	.ADB3(PORT_R_ADDR[3]),
	.ADB4(PORT_R_ADDR[4]),
	.ADB5(PORT_R_ADDR[5]),
	.ADB6(PORT_R_ADDR[6]),
	.ADB7(PORT_R_ADDR[7]),
	.ADB8(PORT_R_ADDR[8]),
	.ADB9(PORT_R_ADDR[9]),
	.ADB10(PORT_R_ADDR[10]),
	.ADB11(PORT_R_ADDR[11]),
	.ADB12(PORT_R_ADDR[12]),
	.ADB13(PORT_R_ADDR[13]),
	.DOA0(DO[0]),
	.DOA1(DO[1]),
	.DOA2(DO[2]),
	.DOA3(DO[3]),
	.DOA4(DO[4]),
	.DOA5(DO[5]),
	.DOA6(DO[6]),
	.DOA7(DO[7]),
	.DOA8(DO[8]),
	.DOA9(DO[9]),
	.DOA10(DO[10]),
	.DOA11(DO[11]),
	.DOA12(DO[12]),
	.DOA13(DO[13]),
	.DOA14(DO[14]),
	.DOA15(DO[15]),
	.DOA16(DO[16]),
	.DOA17(DO[17]),
	.DOB0(DO[18]),
	.DOB1(DO[19]),
	.DOB2(DO[20]),
	.DOB3(DO[21]),
	.DOB4(DO[22]),
	.DOB5(DO[23]),
	.DOB6(DO[24]),
	.DOB7(DO[25]),
	.DOB8(DO[26]),
	.DOB9(DO[27]),
	.DOB10(DO[28]),
	.DOB11(DO[29]),
	.DOB12(DO[30]),
	.DOB13(DO[31]),
	.DOB14(DO[32]),
	.DOB15(DO[33]),
	.DOB16(DO[34]),
	.DOB17(DO[35]),
);

endmodule
`,"cells_bb.v":`// ECP5 Blackbox cells
// FIXME: Create sim models

(* blackbox *)
module MULT18X18D(
	input A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17,
	input B0, B1, B2, B3, B4, B5, B6, B7, B8, B9, B10, B11, B12, B13, B14, B15, B16, B17,
	input C0, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, C11, C12, C13, C14, C15, C16, C17,
	input SIGNEDA, SIGNEDB, SOURCEA, SOURCEB,
	input CLK0, CLK1, CLK2, CLK3,
	input CE0, CE1, CE2, CE3,
	input RST0, RST1, RST2, RST3,
	input SRIA0, SRIA1, SRIA2, SRIA3, SRIA4, SRIA5, SRIA6, SRIA7, SRIA8, SRIA9, SRIA10, SRIA11, SRIA12, SRIA13, SRIA14, SRIA15, SRIA16, SRIA17,
	input SRIB0, SRIB1, SRIB2, SRIB3, SRIB4, SRIB5, SRIB6, SRIB7, SRIB8, SRIB9, SRIB10, SRIB11, SRIB12, SRIB13, SRIB14, SRIB15, SRIB16, SRIB17,
	output SROA0, SROA1, SROA2, SROA3, SROA4, SROA5, SROA6, SROA7, SROA8, SROA9, SROA10, SROA11, SROA12, SROA13, SROA14, SROA15, SROA16, SROA17,
	output SROB0, SROB1, SROB2, SROB3, SROB4, SROB5, SROB6, SROB7, SROB8, SROB9, SROB10, SROB11, SROB12, SROB13, SROB14, SROB15, SROB16, SROB17,
	output ROA0, ROA1, ROA2, ROA3, ROA4, ROA5, ROA6, ROA7, ROA8, ROA9, ROA10, ROA11, ROA12, ROA13, ROA14, ROA15, ROA16, ROA17,
	output ROB0, ROB1, ROB2, ROB3, ROB4, ROB5, ROB6, ROB7, ROB8, ROB9, ROB10, ROB11, ROB12, ROB13, ROB14, ROB15, ROB16, ROB17,
	output ROC0, ROC1, ROC2, ROC3, ROC4, ROC5, ROC6, ROC7, ROC8, ROC9, ROC10, ROC11, ROC12, ROC13, ROC14, ROC15, ROC16, ROC17,
	output P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20, P21, P22, P23, P24, P25, P26, P27, P28, P29, P30, P31, P32, P33, P34, P35,
	output SIGNEDP
);
	parameter REG_INPUTA_CLK = "NONE";
	parameter REG_INPUTA_CE = "CE0";
	parameter REG_INPUTA_RST = "RST0";
	parameter REG_INPUTB_CLK = "NONE";
	parameter REG_INPUTB_CE = "CE0";
	parameter REG_INPUTB_RST = "RST0";
	parameter REG_INPUTC_CLK = "NONE";
	parameter REG_INPUTC_CE = "CE0";
	parameter REG_INPUTC_RST = "RST0";
	parameter REG_PIPELINE_CLK = "NONE";
	parameter REG_PIPELINE_CE = "CE0";
	parameter REG_PIPELINE_RST = "RST0";
	parameter REG_OUTPUT_CLK = "NONE";
	parameter REG_OUTPUT_CE = "CE0";
	parameter REG_OUTPUT_RST = "RST0";
	parameter [127:0] CLK0_DIV = "ENABLED";
	parameter [127:0] CLK1_DIV = "ENABLED";
	parameter [127:0] CLK2_DIV = "ENABLED";
	parameter [127:0] CLK3_DIV = "ENABLED";
	parameter HIGHSPEED_CLK = "NONE";
	parameter [127:0] GSR = "ENABLED";
	parameter CAS_MATCH_REG = "FALSE";
	parameter [127:0] SOURCEB_MODE = "B_SHIFT";
	parameter [127:0] MULT_BYPASS = "DISABLED";
	parameter [127:0] RESETMODE = "SYNC";
endmodule

(* blackbox *)
module ALU54B(
	input CLK0, CLK1, CLK2, CLK3,
	input CE0, CE1, CE2, CE3,
	input RST0, RST1, RST2, RST3,
	input SIGNEDIA, SIGNEDIB, SIGNEDCIN,
	input A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31, A32, A33, A34, A35,
	input B0, B1, B2, B3, B4, B5, B6, B7, B8, B9, B10, B11, B12, B13, B14, B15, B16, B17, B18, B19, B20, B21, B22, B23, B24, B25, B26, B27, B28, B29, B30, B31, B32, B33, B34, B35,
	input C0, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, C11, C12, C13, C14, C15, C16, C17, C18, C19, C20, C21, C22, C23, C24, C25, C26, C27, C28, C29, C30, C31, C32, C33, C34, C35, C36, C37, C38, C39, C40, C41, C42, C43, C44, C45, C46, C47, C48, C49, C50, C51, C52, C53,
	input CFB0, CFB1, CFB2, CFB3, CFB4, CFB5, CFB6, CFB7, CFB8, CFB9, CFB10, CFB11, CFB12, CFB13, CFB14, CFB15, CFB16, CFB17, CFB18, CFB19, CFB20, CFB21, CFB22, CFB23, CFB24, CFB25, CFB26, CFB27, CFB28, CFB29, CFB30, CFB31, CFB32, CFB33, CFB34, CFB35, CFB36, CFB37, CFB38, CFB39, CFB40, CFB41, CFB42, CFB43, CFB44, CFB45, CFB46, CFB47, CFB48, CFB49, CFB50, CFB51, CFB52, CFB53,
	input MA0, MA1, MA2, MA3, MA4, MA5, MA6, MA7, MA8, MA9, MA10, MA11, MA12, MA13, MA14, MA15, MA16, MA17, MA18, MA19, MA20, MA21, MA22, MA23, MA24, MA25, MA26, MA27, MA28, MA29, MA30, MA31, MA32, MA33, MA34, MA35,
	input MB0, MB1, MB2, MB3, MB4, MB5, MB6, MB7, MB8, MB9, MB10, MB11, MB12, MB13, MB14, MB15, MB16, MB17, MB18, MB19, MB20, MB21, MB22, MB23, MB24, MB25, MB26, MB27, MB28, MB29, MB30, MB31, MB32, MB33, MB34, MB35,
	input CIN0, CIN1, CIN2, CIN3, CIN4, CIN5, CIN6, CIN7, CIN8, CIN9, CIN10, CIN11, CIN12, CIN13, CIN14, CIN15, CIN16, CIN17, CIN18, CIN19, CIN20, CIN21, CIN22, CIN23, CIN24, CIN25, CIN26, CIN27, CIN28, CIN29, CIN30, CIN31, CIN32, CIN33, CIN34, CIN35, CIN36, CIN37, CIN38, CIN39, CIN40, CIN41, CIN42, CIN43, CIN44, CIN45, CIN46, CIN47, CIN48, CIN49, CIN50, CIN51, CIN52, CIN53,
	input OP0, OP1, OP2, OP3, OP4, OP5, OP6, OP7, OP8, OP9, OP10,
	output R0, R1, R2, R3, R4, R5, R6, R7, R8, R9, R10, R11, R12, R13, R14, R15, R16, R17, R18, R19, R20, R21, R22, R23, R24, R25, R26, R27, R28, R29, R30, R31, R32, R33, R34, R35, R36, R37, R38, R39, R40, R41, R42, R43, R44, R45, R46, R47, R48, R49, R50, R51, R52, R53,
	output CO0, CO1, CO2, CO3, CO4, CO5, CO6, CO7, CO8, CO9, CO10, CO11, CO12, CO13, CO14, CO15, CO16, CO17, CO18, CO19, CO20, CO21, CO22, CO23, CO24, CO25, CO26, CO27, CO28, CO29, CO30, CO31, CO32, CO33, CO34, CO35, CO36, CO37, CO38, CO39, CO40, CO41, CO42, CO43, CO44, CO45, CO46, CO47, CO48, CO49, CO50, CO51, CO52, CO53,
	output EQZ, EQZM, EQOM, EQPAT, EQPATB,
	output OVER, UNDER, OVERUNDER,
	output SIGNEDR
);
	parameter REG_INPUTC0_CLK = "NONE";
	parameter REG_INPUTC0_CE = "CE0";
	parameter REG_INPUTC0_RST = "RST0";
	parameter REG_INPUTC1_CLK = "NONE";
	parameter REG_INPUTC1_CE = "CE0";
	parameter REG_INPUTC1_RST = "RST0";
	parameter REG_OPCODEOP0_0_CLK = "NONE";
	parameter REG_OPCODEOP0_0_CE = "CE0";
	parameter REG_OPCODEOP0_0_RST = "RST0";
	parameter REG_OPCODEOP1_0_CLK = "NONE";
	parameter REG_OPCODEOP0_1_CLK = "NONE";
	parameter REG_OPCODEOP0_1_CE = "CE0";
	parameter REG_OPCODEOP0_1_RST = "RST0";
	parameter REG_OPCODEOP1_1_CLK = "NONE";
	parameter REG_OPCODEIN_0_CLK = "NONE";
	parameter REG_OPCODEIN_0_CE = "CE0";
	parameter REG_OPCODEIN_0_RST = "RST0";
	parameter REG_OPCODEIN_1_CLK = "NONE";
	parameter REG_OPCODEIN_1_CE = "CE0";
	parameter REG_OPCODEIN_1_RST = "RST0";
	parameter REG_OUTPUT0_CLK = "NONE";
	parameter REG_OUTPUT0_CE = "CE0";
	parameter REG_OUTPUT0_RST = "RST0";
	parameter REG_OUTPUT1_CLK = "NONE";
	parameter REG_OUTPUT1_CE = "CE0";
	parameter REG_OUTPUT1_RST = "RST0";
	parameter REG_FLAG_CLK = "NONE";
	parameter REG_FLAG_CE = "CE0";
	parameter REG_FLAG_RST = "RST0";
	parameter REG_INPUTCFB_CLK = "NONE";
	parameter REG_INPUTCFB_CE = "CE0";
	parameter REG_INPUTCFB_RST = "RST0";
	parameter [127:0] MCPAT_SOURCE = "STATIC";
	parameter [127:0] MASKPAT_SOURCE = "STATIC";
	parameter MASK01 = "0x00000000000000";
	parameter [127:0] CLK0_DIV = "ENABLED";
	parameter [127:0] CLK1_DIV = "ENABLED";
	parameter [127:0] CLK2_DIV = "ENABLED";
	parameter [127:0] CLK3_DIV = "ENABLED";
	parameter MCPAT = "0x00000000000000";
	parameter MASKPAT = "0x00000000000000";
	parameter RNDPAT = "0x00000000000000";
	parameter [127:0] GSR = "ENABLED";
	parameter [127:0] RESETMODE = "SYNC";
	parameter MULT9_MODE = "DISABLED";
	parameter FORCE_ZERO_BARREL_SHIFT = "DISABLED";
	parameter LEGACY = "DISABLED";
endmodule

(* blackbox *)
module EHXPLLL (
	input CLKI, CLKFB,
	input PHASESEL1, PHASESEL0, PHASEDIR, PHASESTEP, PHASELOADREG,
	input STDBY, PLLWAKESYNC,
	input RST, ENCLKOP, ENCLKOS, ENCLKOS2, ENCLKOS3,
	output CLKOP, CLKOS, CLKOS2, CLKOS3,
	output LOCK, INTLOCK,
	output REFCLK, CLKINTFB
);
	parameter CLKI_DIV = 1;
	parameter CLKFB_DIV = 1;
	parameter CLKOP_DIV = 8;
	parameter CLKOS_DIV = 8;
	parameter CLKOS2_DIV = 8;
	parameter CLKOS3_DIV = 8;
	parameter CLKOP_ENABLE = "ENABLED";
	parameter CLKOS_ENABLE = "DISABLED";
	parameter CLKOS2_ENABLE = "DISABLED";
	parameter CLKOS3_ENABLE = "DISABLED";
	parameter CLKOP_CPHASE = 0;
	parameter CLKOS_CPHASE = 0;
	parameter CLKOS2_CPHASE = 0;
	parameter CLKOS3_CPHASE = 0;
	parameter CLKOP_FPHASE = 0;
	parameter CLKOS_FPHASE = 0;
	parameter CLKOS2_FPHASE = 0;
	parameter CLKOS3_FPHASE = 0;
	parameter FEEDBK_PATH = "CLKOP";
	parameter CLKOP_TRIM_POL = "RISING";
	parameter CLKOP_TRIM_DELAY = 0;
	parameter CLKOS_TRIM_POL = "RISING";
	parameter CLKOS_TRIM_DELAY = 0;
	parameter OUTDIVIDER_MUXA = "DIVA";
	parameter OUTDIVIDER_MUXB = "DIVB";
	parameter OUTDIVIDER_MUXC = "DIVC";
	parameter OUTDIVIDER_MUXD = "DIVD";
	parameter PLL_LOCK_MODE = 0;
	parameter PLL_LOCK_DELAY = 200;
	parameter STDBY_ENABLE = "DISABLED";
	parameter REFIN_RESET = "DISABLED";
	parameter SYNC_ENABLE = "DISABLED";
	parameter INT_LOCK_STICKY = "ENABLED";
	parameter DPHASE_SOURCE = "DISABLED";
	parameter PLLRST_ENA = "DISABLED";
	parameter INTFB_WAKE = "DISABLED";
endmodule

(* blackbox *)
module DTR(
	input STARTPULSE,
	output DTROUT7, DTROUT6, DTROUT5, DTROUT4, DTROUT3, DTROUT2, DTROUT1, DTROUT0
);
endmodule

(* blackbox *)
module OSCG(
	output OSC
);
parameter DIV = 128;
endmodule

(* blackbox *) (* keep *)
module USRMCLK(
	input USRMCLKI, USRMCLKTS,
	output USRMCLKO
);
endmodule

(* blackbox *) (* keep *)
module JTAGG(
	(* iopad_external_pin *)
	input TCK, 
	(* iopad_external_pin *)
	input TMS, 
	(* iopad_external_pin *)
	input TDI,
	input JTDO2, JTDO1,
	(* iopad_external_pin *)
	output TDO,
	output JTDI, JTCK, JRTI2, JRTI1,
	output JSHIFT, JUPDATE, JRSTN, JCE2, JCE1
);
parameter ER1 = "ENABLED";
parameter ER2 = "ENABLED";
endmodule

(* blackbox *)
module DELAYF(
	input A, LOADN, MOVE, DIRECTION,
	output Z, CFLAG
);
	parameter DEL_MODE = "USER_DEFINED";
	parameter DEL_VALUE = 0;
endmodule

(* blackbox *)
module DELAYG(
	input A,
	output Z
);
	parameter DEL_MODE = "USER_DEFINED";
	parameter DEL_VALUE = 0;
endmodule

(* blackbox *)
module IDDRX1F(
	input D, SCLK, RST,
	output Q0, Q1
);
	parameter GSR = "ENABLED";
endmodule

(* blackbox *)
module IDDRX2F(
	input D, SCLK, ECLK, RST, ALIGNWD,
	output Q0, Q1, Q2, Q3
);
	parameter GSR = "ENABLED";
endmodule

(* blackbox *)
module IDDR71B(
	input D, SCLK, ECLK, RST, ALIGNWD,
	output Q0, Q1, Q2, Q3, Q4, Q5, Q6
);
	parameter GSR = "ENABLED";
endmodule

(* blackbox *)
module IDDRX2DQA(
	input D, DQSR90, ECLK, SCLK, RST,
	input RDPNTR2, RDPNTR1, RDPNTR0, WRPNTR2, WRPNTR1, WRPNTR0,
	output Q0, Q1, Q2, Q3, QWL
);
	parameter GSR = "ENABLED";
endmodule

(* blackbox *)
module ODDRX1F(
	input SCLK, RST, D0, D1,
	output Q
);
	parameter GSR = "ENABLED";
endmodule

(* blackbox *)
module ODDRX2F(
	input SCLK, ECLK, RST, D0, D1, D2, D3,
	output Q
);
	parameter GSR = "ENABLED";
endmodule

(* blackbox *)
module ODDR71B(
	input SCLK, ECLK, RST, D0, D1, D2, D3, D4, D5, D6,
	output Q
);
	parameter GSR = "ENABLED";
endmodule

(* blackbox *)
module OSHX2A(
	input D0, D1, RST, ECLK, SCLK,
	output Q
);
	parameter GSR = "ENABLED";
endmodule

(* blackbox *)
module ODDRX2DQA(
	input D0, D1, D2, D3, RST, ECLK, SCLK, DQSW270,
	output Q
);
	parameter GSR = "ENABLED";
endmodule

(* blackbox *)
module ODDRX2DQSB(
	input D0, D1, D2, D3, RST, ECLK, SCLK, DQSW,
	output Q
);
	parameter GSR = "ENABLED";
endmodule

(* blackbox *)
module TSHX2DQA(
	input T0, T1, SCLK, ECLK, DQSW270, RST,
	output Q
);
	parameter GSR = "ENABLED";
	parameter REGSET = "SET";
endmodule

(* blackbox *)
module TSHX2DQSA(
	input T0, T1, SCLK, ECLK, DQSW, RST,
	output Q
);
	parameter GSR = "ENABLED";
	parameter REGSET = "SET";
endmodule

(* blackbox *)
module DQSBUFM(
	input DQSI, READ1, READ0, READCLKSEL2, READCLKSEL1, READCLKSEL0, DDRDEL,
	input ECLK, SCLK,
	input DYNDELAY7, DYNDELAY6, DYNDELAY5, DYNDELAY4,
	input DYNDELAY3, DYNDELAY2, DYNDELAY1, DYNDELAY0, 
	input RST, RDLOADN, RDMOVE, RDDIRECTION, WRLOADN, WRMOVE, WRDIRECTION, PAUSE,
	output DQSR90, DQSW, DQSW270,
	output RDPNTR2, RDPNTR1, RDPNTR0, WRPNTR2, WRPNTR1, WRPNTR0,
	output DATAVALID, BURSTDET, RDCFLAG, WRCFLAG
);
	parameter DQS_LI_DEL_ADJ = "FACTORYONLY";
	parameter DQS_LI_DEL_VAL = 0;
	parameter DQS_LO_DEL_ADJ = "FACTORYONLY";
	parameter DQS_LO_DEL_VAL = 0;
	parameter GSR = "ENABLED";
endmodule

(* blackbox *)
module DDRDLLA(
	input CLK, RST, UDDCNTLN, FREEZE,
	output LOCK, DDRDEL, DCNTL7, DCNTL6, DCNTL5, DCNTL4, DCNTL3, DCNTL2, DCNTL1, DCNTL0
);
	parameter FORCE_MAX_DELAY = "NO";
	parameter GSR = "ENABLED";
endmodule

(* blackbox *)
module DLLDELD(
	input A, DDRDEL, LOADN, MOVE, DIRECTION,
	output Z, CFLAG
);
	parameter DEL_ADJ = "PLUS";
	parameter DEL_VAL = 0;
endmodule

(* blackbox *)
module CLKDIVF(
	input CLKI, RST, ALIGNWD,
	output CDIVX
);
	parameter GSR = "DISABLED";
	parameter DIV = "2.0";
endmodule

(* blackbox *)
module ECLKSYNCB(
	input ECLKI, STOP,
	output ECLKO
);
endmodule

(* blackbox *)
module ECLKBRIDGECS(
	input CLK0, CLK1, SEL,
	output ECSOUT
);
endmodule

(* blackbox *)
module DCCA(
	input CLKI, CE,
	output CLKO
);
endmodule

(* blackbox *)
module DCSC(
	input CLK1, CLK0,
	input SEL1, SEL0,
	input MODESEL,
	output DCSOUT
);
	parameter DCSMODE = "POS";
endmodule

(* blackbox *) (* keep *)
module DCUA(
	(* iopad_external_pin *)
	input CH0_HDINP,
	(* iopad_external_pin *)
	input CH1_HDINP,
	(* iopad_external_pin *)
	input CH0_HDINN,
	(* iopad_external_pin *)
	input CH1_HDINN,
	input D_TXBIT_CLKP_FROM_ND, D_TXBIT_CLKN_FROM_ND, D_SYNC_ND, D_TXPLL_LOL_FROM_ND,
	input CH0_RX_REFCLK, CH1_RX_REFCLK, CH0_FF_RXI_CLK, CH1_FF_RXI_CLK, CH0_FF_TXI_CLK, CH1_FF_TXI_CLK, CH0_FF_EBRD_CLK, CH1_FF_EBRD_CLK,
	input CH0_FF_TX_D_0, CH1_FF_TX_D_0, CH0_FF_TX_D_1, CH1_FF_TX_D_1, CH0_FF_TX_D_2, CH1_FF_TX_D_2, CH0_FF_TX_D_3, CH1_FF_TX_D_3,
	input CH0_FF_TX_D_4, CH1_FF_TX_D_4, CH0_FF_TX_D_5, CH1_FF_TX_D_5, CH0_FF_TX_D_6, CH1_FF_TX_D_6, CH0_FF_TX_D_7, CH1_FF_TX_D_7,
	input CH0_FF_TX_D_8, CH1_FF_TX_D_8, CH0_FF_TX_D_9, CH1_FF_TX_D_9, CH0_FF_TX_D_10, CH1_FF_TX_D_10, CH0_FF_TX_D_11, CH1_FF_TX_D_11,
	input CH0_FF_TX_D_12, CH1_FF_TX_D_12, CH0_FF_TX_D_13, CH1_FF_TX_D_13, CH0_FF_TX_D_14, CH1_FF_TX_D_14, CH0_FF_TX_D_15, CH1_FF_TX_D_15,
	input CH0_FF_TX_D_16, CH1_FF_TX_D_16, CH0_FF_TX_D_17, CH1_FF_TX_D_17, CH0_FF_TX_D_18, CH1_FF_TX_D_18, CH0_FF_TX_D_19, CH1_FF_TX_D_19,
	input CH0_FF_TX_D_20, CH1_FF_TX_D_20, CH0_FF_TX_D_21, CH1_FF_TX_D_21, CH0_FF_TX_D_22, CH1_FF_TX_D_22, CH0_FF_TX_D_23, CH1_FF_TX_D_23,
	input CH0_FFC_EI_EN, CH1_FFC_EI_EN, CH0_FFC_PCIE_DET_EN, CH1_FFC_PCIE_DET_EN, CH0_FFC_PCIE_CT, CH1_FFC_PCIE_CT, CH0_FFC_SB_INV_RX, CH1_FFC_SB_INV_RX,
	input CH0_FFC_ENABLE_CGALIGN, CH1_FFC_ENABLE_CGALIGN, CH0_FFC_SIGNAL_DETECT, CH1_FFC_SIGNAL_DETECT, CH0_FFC_FB_LOOPBACK, CH1_FFC_FB_LOOPBACK, CH0_FFC_SB_PFIFO_LP, CH1_FFC_SB_PFIFO_LP,
	input CH0_FFC_PFIFO_CLR, CH1_FFC_PFIFO_CLR, CH0_FFC_RATE_MODE_RX, CH1_FFC_RATE_MODE_RX, CH0_FFC_RATE_MODE_TX, CH1_FFC_RATE_MODE_TX, CH0_FFC_DIV11_MODE_RX, CH1_FFC_DIV11_MODE_RX, CH0_FFC_RX_GEAR_MODE, CH1_FFC_RX_GEAR_MODE, CH0_FFC_TX_GEAR_MODE, CH1_FFC_TX_GEAR_MODE,
	input CH0_FFC_DIV11_MODE_TX, CH1_FFC_DIV11_MODE_TX, CH0_FFC_LDR_CORE2TX_EN, CH1_FFC_LDR_CORE2TX_EN, CH0_FFC_LANE_TX_RST, CH1_FFC_LANE_TX_RST, CH0_FFC_LANE_RX_RST, CH1_FFC_LANE_RX_RST,
	input CH0_FFC_RRST, CH1_FFC_RRST, CH0_FFC_TXPWDNB, CH1_FFC_TXPWDNB, CH0_FFC_RXPWDNB, CH1_FFC_RXPWDNB, CH0_LDR_CORE2TX, CH1_LDR_CORE2TX,
	input D_SCIWDATA0, D_SCIWDATA1, D_SCIWDATA2, D_SCIWDATA3, D_SCIWDATA4, D_SCIWDATA5, D_SCIWDATA6, D_SCIWDATA7,
	input D_SCIADDR0, D_SCIADDR1, D_SCIADDR2, D_SCIADDR3, D_SCIADDR4, D_SCIADDR5, D_SCIENAUX, D_SCISELAUX,
	input CH0_SCIEN, CH1_SCIEN, CH0_SCISEL, CH1_SCISEL, D_SCIRD, D_SCIWSTN, D_CYAWSTN, D_FFC_SYNC_TOGGLE,
	input D_FFC_DUAL_RST, D_FFC_MACRO_RST, D_FFC_MACROPDB, D_FFC_TRST, CH0_FFC_CDR_EN_BITSLIP, CH1_FFC_CDR_EN_BITSLIP, D_SCAN_ENABLE, D_SCAN_IN_0,
	input D_SCAN_IN_1, D_SCAN_IN_2, D_SCAN_IN_3, D_SCAN_IN_4, D_SCAN_IN_5, D_SCAN_IN_6, D_SCAN_IN_7, D_SCAN_MODE,
	input D_SCAN_RESET, D_CIN0, D_CIN1, D_CIN2, D_CIN3, D_CIN4, D_CIN5, D_CIN6,D_CIN7, D_CIN8, D_CIN9, D_CIN10, D_CIN11,
	output CH0_HDOUTP, CH1_HDOUTP, CH0_HDOUTN, CH1_HDOUTN, D_TXBIT_CLKP_TO_ND, D_TXBIT_CLKN_TO_ND, D_SYNC_PULSE2ND, D_TXPLL_LOL_TO_ND,
	output CH0_FF_RX_F_CLK, CH1_FF_RX_F_CLK, CH0_FF_RX_H_CLK, CH1_FF_RX_H_CLK, CH0_FF_TX_F_CLK, CH1_FF_TX_F_CLK, CH0_FF_TX_H_CLK, CH1_FF_TX_H_CLK,
	output CH0_FF_RX_PCLK, CH1_FF_RX_PCLK, CH0_FF_TX_PCLK, CH1_FF_TX_PCLK, CH0_FF_RX_D_0, CH1_FF_RX_D_0, CH0_FF_RX_D_1, CH1_FF_RX_D_1,
	output CH0_FF_RX_D_2, CH1_FF_RX_D_2, CH0_FF_RX_D_3, CH1_FF_RX_D_3, CH0_FF_RX_D_4, CH1_FF_RX_D_4, CH0_FF_RX_D_5, CH1_FF_RX_D_5,
	output CH0_FF_RX_D_6, CH1_FF_RX_D_6, CH0_FF_RX_D_7, CH1_FF_RX_D_7, CH0_FF_RX_D_8, CH1_FF_RX_D_8, CH0_FF_RX_D_9, CH1_FF_RX_D_9,
	output CH0_FF_RX_D_10, CH1_FF_RX_D_10, CH0_FF_RX_D_11, CH1_FF_RX_D_11, CH0_FF_RX_D_12, CH1_FF_RX_D_12, CH0_FF_RX_D_13, CH1_FF_RX_D_13,
	output CH0_FF_RX_D_14, CH1_FF_RX_D_14, CH0_FF_RX_D_15, CH1_FF_RX_D_15, CH0_FF_RX_D_16, CH1_FF_RX_D_16, CH0_FF_RX_D_17, CH1_FF_RX_D_17,
	output CH0_FF_RX_D_18, CH1_FF_RX_D_18, CH0_FF_RX_D_19, CH1_FF_RX_D_19, CH0_FF_RX_D_20, CH1_FF_RX_D_20, CH0_FF_RX_D_21, CH1_FF_RX_D_21,
	output CH0_FF_RX_D_22, CH1_FF_RX_D_22, CH0_FF_RX_D_23, CH1_FF_RX_D_23, CH0_FFS_PCIE_DONE, CH1_FFS_PCIE_DONE, CH0_FFS_PCIE_CON, CH1_FFS_PCIE_CON,
	output CH0_FFS_RLOS, CH1_FFS_RLOS, CH0_FFS_LS_SYNC_STATUS, CH1_FFS_LS_SYNC_STATUS, CH0_FFS_CC_UNDERRUN, CH1_FFS_CC_UNDERRUN, CH0_FFS_CC_OVERRUN, CH1_FFS_CC_OVERRUN,
	output CH0_FFS_RXFBFIFO_ERROR, CH1_FFS_RXFBFIFO_ERROR, CH0_FFS_TXFBFIFO_ERROR, CH1_FFS_TXFBFIFO_ERROR, CH0_FFS_RLOL, CH1_FFS_RLOL, CH0_FFS_SKP_ADDED, CH1_FFS_SKP_ADDED,
	output CH0_FFS_SKP_DELETED, CH1_FFS_SKP_DELETED, CH0_LDR_RX2CORE, CH1_LDR_RX2CORE, D_SCIRDATA0, D_SCIRDATA1, D_SCIRDATA2, D_SCIRDATA3,
	output D_SCIRDATA4, D_SCIRDATA5, D_SCIRDATA6, D_SCIRDATA7, D_SCIINT, D_SCAN_OUT_0, D_SCAN_OUT_1, D_SCAN_OUT_2, D_SCAN_OUT_3, D_SCAN_OUT_4, D_SCAN_OUT_5, D_SCAN_OUT_6, D_SCAN_OUT_7,
	output D_COUT0, D_COUT1, D_COUT2, D_COUT3, D_COUT4, D_COUT5, D_COUT6, D_COUT7, D_COUT8, D_COUT9, D_COUT10, D_COUT11, D_COUT12, D_COUT13, D_COUT14, D_COUT15, D_COUT16, D_COUT17, D_COUT18, D_COUT19,

	input  D_REFCLKI,
	output D_FFS_PLOL
);
	parameter CH0_AUTO_CALIB_EN = "0b0";
	parameter CH0_AUTO_FACQ_EN = "0b0";
	parameter CH0_BAND_THRESHOLD = "0b000000";
	parameter CH0_CALIB_CK_MODE = "0b0";
	parameter CH0_CC_MATCH_1 = "0b0000000000";
	parameter CH0_CC_MATCH_2 = "0b0000000000";
	parameter CH0_CC_MATCH_3 = "0b0000000000";
	parameter CH0_CC_MATCH_4 = "0b0000000000";
	parameter CH0_CDR_CNT4SEL = "0b00";
	parameter CH0_CDR_CNT8SEL = "0b00";
	parameter CH0_CTC_BYPASS = "0b0";
	parameter CH0_DCOATDCFG = "0b00";
	parameter CH0_DCOATDDLY = "0b00";
	parameter CH0_DCOBYPSATD = "0b0";
	parameter CH0_DCOCALDIV = "0b000";
	parameter CH0_DCOCTLGI = "0b000";
	parameter CH0_DCODISBDAVOID = "0b0";
	parameter CH0_DCOFLTDAC = "0b00";
	parameter CH0_DCOFTNRG = "0b000";
	parameter CH0_DCOIOSTUNE = "0b000";
	parameter CH0_DCOITUNE = "0b00";
	parameter CH0_DCOITUNE4LSB = "0b000";
	parameter CH0_DCOIUPDNX2 = "0b0";
	parameter CH0_DCONUOFLSB = "0b000";
	parameter CH0_DCOSCALEI = "0b00";
	parameter CH0_DCOSTARTVAL = "0b000";
	parameter CH0_DCOSTEP = "0b00";
	parameter CH0_DEC_BYPASS = "0b0";
	parameter CH0_ENABLE_CG_ALIGN = "0b0";
	parameter CH0_ENC_BYPASS = "0b0";
	parameter CH0_FF_RX_F_CLK_DIS = "0b0";
	parameter CH0_FF_RX_H_CLK_EN = "0b0";
	parameter CH0_FF_TX_F_CLK_DIS = "0b0";
	parameter CH0_FF_TX_H_CLK_EN = "0b0";
	parameter CH0_GE_AN_ENABLE = "0b0";
	parameter CH0_INVERT_RX = "0b0";
	parameter CH0_INVERT_TX = "0b0";
	parameter CH0_LDR_CORE2TX_SEL = "0b0";
	parameter CH0_LDR_RX2CORE_SEL = "0b0";
	parameter CH0_LEQ_OFFSET_SEL = "0b0";
	parameter CH0_LEQ_OFFSET_TRIM = "0b000";
	parameter CH0_LSM_DISABLE = "0b0";
	parameter CH0_MATCH_2_ENABLE = "0b0";
	parameter CH0_MATCH_4_ENABLE = "0b0";
	parameter CH0_MIN_IPG_CNT = "0b00";
	parameter CH0_PCIE_EI_EN = "0b0";
	parameter CH0_PCIE_MODE = "0b0";
	parameter CH0_PCS_DET_TIME_SEL = "0b00";
	parameter CH0_PDEN_SEL = "0b0";
	parameter CH0_PRBS_ENABLE = "0b0";
	parameter CH0_PRBS_LOCK = "0b0";
	parameter CH0_PRBS_SELECTION = "0b0";
	parameter CH0_RATE_MODE_RX = "0b0";
	parameter CH0_RATE_MODE_TX = "0b0";
	parameter CH0_RCV_DCC_EN = "0b0";
	parameter CH0_REG_BAND_OFFSET = "0b0000";
	parameter CH0_REG_BAND_SEL = "0b000000";
	parameter CH0_REG_IDAC_EN = "0b0";
	parameter CH0_REG_IDAC_SEL = "0b0000000000";
	parameter CH0_REQ_EN = "0b0";
	parameter CH0_REQ_LVL_SET = "0b00";
	parameter CH0_RIO_MODE = "0b0";
	parameter CH0_RLOS_SEL = "0b0";
	parameter CH0_RPWDNB = "0b0";
	parameter CH0_RTERM_RX = "0b00000";
	parameter CH0_RTERM_TX = "0b00000";
	parameter CH0_RXIN_CM = "0b00";
	parameter CH0_RXTERM_CM = "0b00";
	parameter CH0_RX_DCO_CK_DIV = "0b000";
	parameter CH0_RX_DIV11_SEL = "0b0";
	parameter CH0_RX_GEAR_BYPASS = "0b0";
	parameter CH0_RX_GEAR_MODE = "0b0";
	parameter CH0_RX_LOS_CEQ = "0b00";
	parameter CH0_RX_LOS_EN = "0b0";
	parameter CH0_RX_LOS_HYST_EN = "0b0";
	parameter CH0_RX_LOS_LVL = "0b000";
	parameter CH0_RX_RATE_SEL = "0b0000";
	parameter CH0_RX_SB_BYPASS = "0b0";
	parameter CH0_SB_BYPASS = "0b0";
	parameter CH0_SEL_SD_RX_CLK = "0b0";
	parameter CH0_TDRV_DAT_SEL = "0b00";
	parameter CH0_TDRV_POST_EN = "0b0";
	parameter CH0_TDRV_PRE_EN = "0b0";
	parameter CH0_TDRV_SLICE0_CUR = "0b000";
	parameter CH0_TDRV_SLICE0_SEL = "0b00";
	parameter CH0_TDRV_SLICE1_CUR = "0b000";
	parameter CH0_TDRV_SLICE1_SEL = "0b00";
	parameter CH0_TDRV_SLICE2_CUR = "0b00";
	parameter CH0_TDRV_SLICE2_SEL = "0b00";
	parameter CH0_TDRV_SLICE3_CUR = "0b00";
	parameter CH0_TDRV_SLICE3_SEL = "0b00";
	parameter CH0_TDRV_SLICE4_CUR = "0b00";
	parameter CH0_TDRV_SLICE4_SEL = "0b00";
	parameter CH0_TDRV_SLICE5_CUR = "0b00";
	parameter CH0_TDRV_SLICE5_SEL = "0b00";
	parameter CH0_TPWDNB = "0b0";
	parameter CH0_TX_CM_SEL = "0b00";
	parameter CH0_TX_DIV11_SEL = "0b0";
	parameter CH0_TX_GEAR_BYPASS = "0b0";
	parameter CH0_TX_GEAR_MODE = "0b0";
	parameter CH0_TX_POST_SIGN = "0b0";
	parameter CH0_TX_PRE_SIGN = "0b0";
	parameter CH0_UC_MODE = "0b0";
	parameter CH0_UDF_COMMA_A = "0b0000000000";
	parameter CH0_UDF_COMMA_B = "0b0000000000";
	parameter CH0_UDF_COMMA_MASK = "0b0000000000";
	parameter CH0_WA_BYPASS = "0b0";
	parameter CH0_WA_MODE = "0b0";
	parameter CH1_AUTO_CALIB_EN = "0b0";
	parameter CH1_AUTO_FACQ_EN = "0b0";
	parameter CH1_BAND_THRESHOLD = "0b000000";
	parameter CH1_CALIB_CK_MODE = "0b0";
	parameter CH1_CC_MATCH_1 = "0b0000000000";
	parameter CH1_CC_MATCH_2 = "0b0000000000";
	parameter CH1_CC_MATCH_3 = "0b0000000000";
	parameter CH1_CC_MATCH_4 = "0b0000000000";
	parameter CH1_CDR_CNT4SEL = "0b00";
	parameter CH1_CDR_CNT8SEL = "0b00";
	parameter CH1_CTC_BYPASS = "0b0";
	parameter CH1_DCOATDCFG = "0b00";
	parameter CH1_DCOATDDLY = "0b00";
	parameter CH1_DCOBYPSATD = "0b0";
	parameter CH1_DCOCALDIV = "0b000";
	parameter CH1_DCOCTLGI = "0b000";
	parameter CH1_DCODISBDAVOID = "0b0";
	parameter CH1_DCOFLTDAC = "0b00";
	parameter CH1_DCOFTNRG = "0b000";
	parameter CH1_DCOIOSTUNE = "0b000";
	parameter CH1_DCOITUNE = "0b00";
	parameter CH1_DCOITUNE4LSB = "0b000";
	parameter CH1_DCOIUPDNX2 = "0b0";
	parameter CH1_DCONUOFLSB = "0b000";
	parameter CH1_DCOSCALEI = "0b00";
	parameter CH1_DCOSTARTVAL = "0b000";
	parameter CH1_DCOSTEP = "0b00";
	parameter CH1_DEC_BYPASS = "0b0";
	parameter CH1_ENABLE_CG_ALIGN = "0b0";
	parameter CH1_ENC_BYPASS = "0b0";
	parameter CH1_FF_RX_F_CLK_DIS = "0b0";
	parameter CH1_FF_RX_H_CLK_EN = "0b0";
	parameter CH1_FF_TX_F_CLK_DIS = "0b0";
	parameter CH1_FF_TX_H_CLK_EN = "0b0";
	parameter CH1_GE_AN_ENABLE = "0b0";
	parameter CH1_INVERT_RX = "0b0";
	parameter CH1_INVERT_TX = "0b0";
	parameter CH1_LDR_CORE2TX_SEL = "0b0";
	parameter CH1_LDR_RX2CORE_SEL = "0b0";
	parameter CH1_LEQ_OFFSET_SEL = "0b0";
	parameter CH1_LEQ_OFFSET_TRIM = "0b000";
	parameter CH1_LSM_DISABLE = "0b0";
	parameter CH1_MATCH_2_ENABLE = "0b0";
	parameter CH1_MATCH_4_ENABLE = "0b0";
	parameter CH1_MIN_IPG_CNT = "0b00";
	parameter CH1_PCIE_EI_EN = "0b0";
	parameter CH1_PCIE_MODE = "0b0";
	parameter CH1_PCS_DET_TIME_SEL = "0b00";
	parameter CH1_PDEN_SEL = "0b0";
	parameter CH1_PRBS_ENABLE = "0b0";
	parameter CH1_PRBS_LOCK = "0b0";
	parameter CH1_PRBS_SELECTION = "0b0";
	parameter CH1_RATE_MODE_RX = "0b0";
	parameter CH1_RATE_MODE_TX = "0b0";
	parameter CH1_RCV_DCC_EN = "0b0";
	parameter CH1_REG_BAND_OFFSET = "0b0000";
	parameter CH1_REG_BAND_SEL = "0b000000";
	parameter CH1_REG_IDAC_EN = "0b0";
	parameter CH1_REG_IDAC_SEL = "0b0000000000";
	parameter CH1_REQ_EN = "0b0";
	parameter CH1_REQ_LVL_SET = "0b00";
	parameter CH1_RIO_MODE = "0b0";
	parameter CH1_RLOS_SEL = "0b0";
	parameter CH1_RPWDNB = "0b0";
	parameter CH1_RTERM_RX = "0b00000";
	parameter CH1_RTERM_TX = "0b00000";
	parameter CH1_RXIN_CM = "0b00";
	parameter CH1_RXTERM_CM = "0b00";
	parameter CH1_RX_DCO_CK_DIV = "0b000";
	parameter CH1_RX_DIV11_SEL = "0b0";
	parameter CH1_RX_GEAR_BYPASS = "0b0";
	parameter CH1_RX_GEAR_MODE = "0b0";
	parameter CH1_RX_LOS_CEQ = "0b00";
	parameter CH1_RX_LOS_EN = "0b0";
	parameter CH1_RX_LOS_HYST_EN = "0b0";
	parameter CH1_RX_LOS_LVL = "0b000";
	parameter CH1_RX_RATE_SEL = "0b0000";
	parameter CH1_RX_SB_BYPASS = "0b0";
	parameter CH1_SB_BYPASS = "0b0";
	parameter CH1_SEL_SD_RX_CLK = "0b0";
	parameter CH1_TDRV_DAT_SEL = "0b00";
	parameter CH1_TDRV_POST_EN = "0b0";
	parameter CH1_TDRV_PRE_EN = "0b0";
	parameter CH1_TDRV_SLICE0_CUR = "0b000";
	parameter CH1_TDRV_SLICE0_SEL = "0b00";
	parameter CH1_TDRV_SLICE1_CUR = "0b000";
	parameter CH1_TDRV_SLICE1_SEL = "0b00";
	parameter CH1_TDRV_SLICE2_CUR = "0b00";
	parameter CH1_TDRV_SLICE2_SEL = "0b00";
	parameter CH1_TDRV_SLICE3_CUR = "0b00";
	parameter CH1_TDRV_SLICE3_SEL = "0b00";
	parameter CH1_TDRV_SLICE4_CUR = "0b00";
	parameter CH1_TDRV_SLICE4_SEL = "0b00";
	parameter CH1_TDRV_SLICE5_CUR = "0b00";
	parameter CH1_TDRV_SLICE5_SEL = "0b00";
	parameter CH1_TPWDNB = "0b0";
	parameter CH1_TX_CM_SEL = "0b00";
	parameter CH1_TX_DIV11_SEL = "0b0";
	parameter CH1_TX_GEAR_BYPASS = "0b0";
	parameter CH1_TX_GEAR_MODE = "0b0";
	parameter CH1_TX_POST_SIGN = "0b0";
	parameter CH1_TX_PRE_SIGN = "0b0";
	parameter CH1_UC_MODE = "0b0";
	parameter CH1_UDF_COMMA_A = "0b0000000000";
	parameter CH1_UDF_COMMA_B = "0b0000000000";
	parameter CH1_UDF_COMMA_MASK = "0b0000000000";
	parameter CH1_WA_BYPASS = "0b0";
	parameter CH1_WA_MODE = "0b0";
	parameter D_BITCLK_FROM_ND_EN = "0b0";
	parameter D_BITCLK_LOCAL_EN = "0b0";
	parameter D_BITCLK_ND_EN = "0b0";
	parameter D_BUS8BIT_SEL = "0b0";
	parameter D_CDR_LOL_SET = "0b00";
	parameter D_CMUSETBIASI = "0b00";
	parameter D_CMUSETI4CPP = "0b0000";
	parameter D_CMUSETI4CPZ = "0b0000";
	parameter D_CMUSETI4VCO = "0b00";
	parameter D_CMUSETICP4P = "0b00";
	parameter D_CMUSETICP4Z = "0b000";
	parameter D_CMUSETINITVCT = "0b00";
	parameter D_CMUSETISCL4VCO = "0b000";
	parameter D_CMUSETP1GM = "0b000";
	parameter D_CMUSETP2AGM = "0b000";
	parameter D_CMUSETZGM = "0b000";
	parameter D_DCO_CALIB_TIME_SEL = "0b00";
	parameter D_HIGH_MARK = "0b0000";
	parameter D_IB_PWDNB = "0b0";
	parameter D_ISETLOS = "0b00000000";
	parameter D_LOW_MARK = "0b0000";
	parameter D_MACROPDB = "0b0";
	parameter D_PD_ISET = "0b00";
	parameter D_PLL_LOL_SET = "0b00";
	parameter D_REFCK_MODE = "0b000";
	parameter D_REQ_ISET = "0b000";
	parameter D_RG_EN = "0b0";
	parameter D_RG_SET = "0b00";
	parameter D_SETICONST_AUX = "0b00";
	parameter D_SETICONST_CH = "0b00";
	parameter D_SETIRPOLY_AUX = "0b00";
	parameter D_SETIRPOLY_CH = "0b00";
	parameter D_SETPLLRC = "0b000000";
	parameter D_SYNC_LOCAL_EN = "0b0";
	parameter D_SYNC_ND_EN = "0b0";
	parameter D_TXPLL_PWDNB = "0b0";
	parameter D_TX_VCO_CK_DIV = "0b000";
	parameter D_XGE_MODE = "0b0";

// These parameters don't do anything but are
// needed for compatibility with Diamond
	parameter D_TX_MAX_RATE = "2.5";
	parameter D_RX_MAX_RATE = "2.5";
	parameter CH0_TXAMPLITUDE = "0d1300";
	parameter CH1_TXAMPLITUDE = "0d1300";
	parameter CH0_PROTOCOL = "8B10B";
	parameter CH1_PROTOCOL = "8B10B";
	parameter CH0_CDR_MAX_RATE = "2.5";
	parameter CH1_CDR_MAX_RATE = "2.5";
	parameter CH0_TXDEPRE = "DISABLED";
	parameter CH1_TXDEPRE = "DISABLED";
	parameter CH0_TXDEPOST = "DISABLED";
	parameter CH1_TXDEPOST = "DISABLED";
endmodule

(* blackbox *)
module EXTREFB (
	(* iopad_external_pin *)
	input REFCLKP,
	(* iopad_external_pin *)
	input REFCLKN,
	output REFCLKO
);
	parameter REFCK_PWDNB = "0b0";
	parameter REFCK_RTERM = "0b0";
	parameter REFCK_DCBIAS_EN = "0b0";
endmodule

(* blackbox *)
module PCSCLKDIV (
	input CLKI, RST, SEL2, SEL1, SEL0,
	output CDIV1, CDIVX
);
	parameter GSR = "DISABLED";
endmodule

// Note: this module is not marked keep as we want it swept away in synth (sim use only)
(* blackbox *)
module PUR (
	input PUR
);
	parameter RST_PULSE = 1;
endmodule

(* blackbox, keep *)
module GSR (
	input GSR
);
endmodule

(* blackbox, keep *)
module SGSR (
	input GSR, CLK
);
endmodule


(* blackbox *)
module PDPW16KD (
	input DI35, DI34, DI33, DI32, DI31, DI30, DI29, DI28, DI27, DI26, DI25, DI24, DI23, DI22, DI21, DI20, DI19, DI18,
	input DI17, DI16, DI15, DI14, DI13, DI12, DI11, DI10, DI9, DI8, DI7, DI6, DI5, DI4, DI3, DI2, DI1, DI0,
	input ADW8, ADW7, ADW6, ADW5, ADW4, ADW3, ADW2, ADW1, ADW0,
	input BE3,  BE2,  BE1, BE0, CEW, CLKW, CSW2, CSW1, CSW0,
	input ADR13, ADR12, ADR11, ADR10, ADR9, ADR8, ADR7, ADR6, ADR5, ADR4, ADR3, ADR2, ADR1, ADR0,
	input CER, OCER, CLKR, CSR2, CSR1, CSR0, RST,
	output DO35, DO34, DO33, DO32, DO31, DO30, DO29, DO28, DO27, DO26, DO25, DO24, DO23, DO22, DO21, DO20, DO19, DO18,
	output DO17, DO16, DO15, DO14, DO13, DO12, DO11, DO10, DO9, DO8, DO7, DO6, DO5, DO4, DO3, DO2, DO1, DO0
);
	parameter DATA_WIDTH_W = 36;
	parameter DATA_WIDTH_R = 36;
	parameter GSR = "ENABLED";

	parameter REGMODE = "NOREG";

	parameter RESETMODE = "SYNC";
	parameter ASYNC_RESET_RELEASE = "SYNC";

	parameter CSDECODE_W = "0b000";
	parameter CSDECODE_R = "0b000";

	parameter INITVAL_00 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_01 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_02 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_03 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_04 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_05 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_06 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_07 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_08 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_09 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_0A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_0B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_0C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_0D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_0E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_0F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_10 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_11 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_12 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_13 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_14 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_15 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_16 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_17 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_18 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_19 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_1A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_1B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_1C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_1D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_1E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_1F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_20 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_21 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_22 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_23 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_24 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_25 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_26 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_27 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_28 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_29 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_2A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_2B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_2C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_2D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_2E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_2F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_30 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_31 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_32 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_33 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_34 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_35 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_36 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_37 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_38 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_39 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_3A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_3B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_3C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_3D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_3E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_3F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INIT_DATA = "STATIC";
	parameter CLKWMUX = "CLKW";
	parameter CLKRMUX = "CLKR";

endmodule
`,"cells_ff.vh":`// Diamond flip-flops
module FD1P3AX(input     D, SP, CK, output Q); parameter GSR = "ENABLED"; TRELLIS_FF #(.GSR(GSR), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("ASYNC"))        _TECHMAP_REPLACE_ (.CLK(CK), .LSR(|0), .CE(SP), .DI(D), .Q(Q)); endmodule
module FD1P3AY(input     D, SP, CK, output Q); parameter GSR = "ENABLED"; TRELLIS_FF #(.GSR(GSR), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"),   .SRMODE("ASYNC"))        _TECHMAP_REPLACE_ (.CLK(CK), .LSR(|0), .CE(SP), .DI(D), .Q(Q)); endmodule
module FD1P3BX(input PD, D, SP, CK, output Q); parameter GSR = "ENABLED"; TRELLIS_FF #(.GSR(GSR), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"),   .SRMODE("ASYNC"))        _TECHMAP_REPLACE_ (.CLK(CK), .LSR(PD), .CE(SP), .DI(D), .Q(Q)); endmodule
module FD1P3DX(input CD, D, SP, CK, output Q); parameter GSR = "ENABLED"; TRELLIS_FF #(.GSR(GSR), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("ASYNC"))        _TECHMAP_REPLACE_ (.CLK(CK), .LSR(CD), .CE(SP), .DI(D), .Q(Q)); endmodule
module FD1P3IX(input CD, D, SP, CK, output Q); parameter GSR = "ENABLED"; TRELLIS_FF #(.GSR(GSR), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("LSR_OVER_CE"))  _TECHMAP_REPLACE_ (.CLK(CK), .LSR(CD), .CE(SP), .DI(D), .Q(Q)); endmodule
module FD1P3JX(input PD, D, SP, CK, output Q); parameter GSR = "ENABLED"; TRELLIS_FF #(.GSR(GSR), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"),   .SRMODE("LSR_OVER_CE"))  _TECHMAP_REPLACE_ (.CLK(CK), .LSR(PD), .CE(SP), .DI(D), .Q(Q)); endmodule
module FD1S3AX(input     D,     CK, output Q); parameter GSR = "ENABLED"; TRELLIS_FF #(.GSR(GSR), .CEMUX("1"),  .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("ASYNC"))        _TECHMAP_REPLACE_ (.CLK(CK), .LSR(|0),          .DI(D), .Q(Q)); endmodule
module FD1S3AY(input     D,     CK, output Q); parameter GSR = "ENABLED"; TRELLIS_FF #(.GSR(GSR), .CEMUX("1"),  .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"),   .SRMODE("ASYNC"))        _TECHMAP_REPLACE_ (.CLK(CK), .LSR(|0),          .DI(D), .Q(Q)); endmodule
module FD1S3BX(input PD, D,     CK, output Q); parameter GSR = "ENABLED"; TRELLIS_FF #(.GSR(GSR), .CEMUX("1"),  .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"),   .SRMODE("ASYNC"))        _TECHMAP_REPLACE_ (.CLK(CK), .LSR(PD),          .DI(D), .Q(Q)); endmodule
module FD1S3DX(input CD, D,     CK, output Q); parameter GSR = "ENABLED"; TRELLIS_FF #(.GSR(GSR), .CEMUX("1"),  .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("ASYNC"))        _TECHMAP_REPLACE_ (.CLK(CK), .LSR(CD),          .DI(D), .Q(Q)); endmodule
module FD1S3IX(input CD, D,     CK, output Q); parameter GSR = "ENABLED"; TRELLIS_FF #(.GSR(GSR), .CEMUX("1"),  .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("LSR_OVER_CE"))  _TECHMAP_REPLACE_ (.CLK(CK), .LSR(CD),          .DI(D), .Q(Q)); endmodule
module FD1S3JX(input PD, D,     CK, output Q); parameter GSR = "ENABLED"; TRELLIS_FF #(.GSR(GSR), .CEMUX("1"),  .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"),   .SRMODE("LSR_OVER_CE"))  _TECHMAP_REPLACE_ (.CLK(CK), .LSR(PD),          .DI(D), .Q(Q)); endmodule

// TODO: Diamond latches
// module FL1P3AY(); endmodule
// module FL1P3AZ(); endmodule
// module FL1P3BX(); endmodule
// module FL1P3DX(); endmodule
// module FL1P3IY(); endmodule
// module FL1P3JY(); endmodule
// module FL1S3AX(); endmodule
// module FL1S3AY(); endmodule

// Diamond I/O registers
module IFS1P3BX(input PD, D, SP, SCLK, output Q); parameter GSR = "ENABLED"; (* syn_useioff, ioff_dir="input" *) TRELLIS_FF #(.GSR(GSR), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"),   .SRMODE("ASYNC"))       _TECHMAP_REPLACE_ (.CLK(SCLK), .LSR(PD), .CE(SP), .DI(D), .Q(Q)); endmodule
module IFS1P3DX(input CD, D, SP, SCLK, output Q); parameter GSR = "ENABLED"; (* syn_useioff, ioff_dir="input" *) TRELLIS_FF #(.GSR(GSR), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("ASYNC"))       _TECHMAP_REPLACE_ (.CLK(SCLK), .LSR(CD), .CE(SP), .DI(D), .Q(Q)); endmodule
module IFS1P3IX(input CD, D, SP, SCLK, output Q); parameter GSR = "ENABLED"; (* syn_useioff, ioff_dir="input" *) TRELLIS_FF #(.GSR(GSR), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("LSR_OVER_CE")) _TECHMAP_REPLACE_ (.CLK(SCLK), .LSR(CD), .CE(SP), .DI(D), .Q(Q)); endmodule
module IFS1P3JX(input PD, D, SP, SCLK, output Q); parameter GSR = "ENABLED"; (* syn_useioff, ioff_dir="input" *) TRELLIS_FF #(.GSR(GSR), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"),   .SRMODE("LSR_OVER_CE")) _TECHMAP_REPLACE_ (.CLK(SCLK), .LSR(PD), .CE(SP), .DI(D), .Q(Q)); endmodule

module OFS1P3BX(input PD, D, SP, SCLK, output Q); parameter GSR = "ENABLED"; (* syn_useioff, ioff_dir="output" *) TRELLIS_FF #(.GSR(GSR), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"),   .SRMODE("ASYNC"))       _TECHMAP_REPLACE_ (.CLK(SCLK), .LSR(PD), .CE(SP), .DI(D), .Q(Q)); endmodule
module OFS1P3DX(input CD, D, SP, SCLK, output Q); parameter GSR = "ENABLED"; (* syn_useioff, ioff_dir="output" *) TRELLIS_FF #(.GSR(GSR), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("ASYNC"))       _TECHMAP_REPLACE_ (.CLK(SCLK), .LSR(CD), .CE(SP), .DI(D), .Q(Q)); endmodule
module OFS1P3IX(input CD, D, SP, SCLK, output Q); parameter GSR = "ENABLED"; (* syn_useioff, ioff_dir="output" *) TRELLIS_FF #(.GSR(GSR), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("LSR_OVER_CE")) _TECHMAP_REPLACE_ (.CLK(SCLK), .LSR(CD), .CE(SP), .DI(D), .Q(Q)); endmodule
module OFS1P3JX(input PD, D, SP, SCLK, output Q); parameter GSR = "ENABLED"; (* syn_useioff, ioff_dir="output" *) TRELLIS_FF #(.GSR(GSR), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"),   .SRMODE("LSR_OVER_CE")) _TECHMAP_REPLACE_ (.CLK(SCLK), .LSR(PD), .CE(SP), .DI(D), .Q(Q)); endmodule

// TODO: Diamond I/O latches
// module IFS1S1B(input PD, D, SCLK, output Q); endmodule
// module IFS1S1D(input CD, D, SCLK, output Q); endmodule
// module IFS1S1I(input PD, D, SCLK, output Q); endmodule
// module IFS1S1J(input CD, D, SCLK, output Q); endmodule
`,"cells_io.vh":`// Diamond I/O buffers
module IB   ((* iopad_external_pin *) input I,     output O); (* PULLMODE="NONE" *) TRELLIS_IO #(.DIR("INPUT"))  _TECHMAP_REPLACE_ (.B(I), .O(O)); endmodule
module IBPU ((* iopad_external_pin *) input I,     output O); (* PULLMODE="UP"   *) TRELLIS_IO #(.DIR("INPUT"))  _TECHMAP_REPLACE_ (.B(I), .O(O)); endmodule
module IBPD ((* iopad_external_pin *) input I,     output O); (* PULLMODE="DOWN" *) TRELLIS_IO #(.DIR("INPUT"))  _TECHMAP_REPLACE_ (.B(I), .O(O)); endmodule
module OB   (input I,     (* iopad_external_pin *) output O); (* PULLMODE="NONE" *) TRELLIS_IO #(.DIR("OUTPUT")) _TECHMAP_REPLACE_ (.B(O), .I(I)); endmodule
module OBZ  (input I, T,  (* iopad_external_pin *) output O); (* PULLMODE="NONE" *) TRELLIS_IO #(.DIR("OUTPUT")) _TECHMAP_REPLACE_ (.B(O), .I(I), .T(T)); endmodule
module OBZPU(input I, T,  (* iopad_external_pin *) output O); (* PULLMODE="UP"   *) TRELLIS_IO #(.DIR("OUTPUT")) _TECHMAP_REPLACE_ (.B(O), .I(I), .T(T)); endmodule
module OBZPD(input I, T,  (* iopad_external_pin *) output O); (* PULLMODE="DOWN" *) TRELLIS_IO #(.DIR("OUTPUT")) _TECHMAP_REPLACE_ (.B(O), .I(I), .T(T)); endmodule
module OBCO (input I,     output OT, OC); OLVDS olvds (.A(I), .Z(OT), .ZN(OC)); endmodule
module BB   (input I, T,  output O, (* iopad_external_pin *) inout B); (* PULLMODE="NONE" *) TRELLIS_IO #(.DIR("BIDIR")) _TECHMAP_REPLACE_ (.B(B), .I(I), .O(O), .T(T)); endmodule
module BBPU (input I, T,  output O, (* iopad_external_pin *) inout B); (* PULLMODE="UP"   *) TRELLIS_IO #(.DIR("BIDIR")) _TECHMAP_REPLACE_ (.B(B), .I(I), .O(O), .T(T)); endmodule
module BBPD (input I, T,  output O, (* iopad_external_pin *) inout B); (* PULLMODE="DOWN" *) TRELLIS_IO #(.DIR("BIDIR")) _TECHMAP_REPLACE_ (.B(B), .I(I), .O(O), .T(T)); endmodule
module ILVDS(input A, AN, (* iopad_external_pin *) output Z    ); TRELLIS_IO #(.DIR("INPUT"))  _TECHMAP_REPLACE_ (.B(A), .O(Z)); endmodule
module OLVDS(input A,     (* iopad_external_pin *) output Z, output ZN); TRELLIS_IO #(.DIR("OUTPUT")) _TECHMAP_REPLACE_ (.B(Z), .I(A)); endmodule
`,"cells_map.v":`module  \\$_DFF_N_ (input D, C, output Q);
    parameter _TECHMAP_WIREINIT_Q_ = 1'bx;
    generate if (_TECHMAP_WIREINIT_Q_ === 1'b1)
        TRELLIS_FF #(.GSR("AUTO"), .CEMUX("1"), .CLKMUX("INV"), .LSRMUX("LSR"), .REGSET("SET"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(1'b0), .DI(D), .Q(Q));
    else
        TRELLIS_FF #(.GSR("AUTO"), .CEMUX("1"), .CLKMUX("INV"), .LSRMUX("LSR"), .REGSET("RESET"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(1'b0), .DI(D), .Q(Q));
    endgenerate
    wire _TECHMAP_REMOVEINIT_Q_ = 1'b1;
endmodule

module  \\$_DFF_P_ (input D, C, output Q);
    parameter _TECHMAP_WIREINIT_Q_ = 1'bx;
    generate if (_TECHMAP_WIREINIT_Q_ === 1'b1)
        TRELLIS_FF #(.GSR("AUTO"), .CEMUX("1"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(1'b0), .DI(D), .Q(Q));
    else
        TRELLIS_FF #(.GSR("AUTO"), .CEMUX("1"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(1'b0), .DI(D), .Q(Q));
    endgenerate
    wire _TECHMAP_REMOVEINIT_Q_ = 1'b1;
endmodule

module  \\$_DFFE_NN_ (input D, C, E, output Q);
    parameter _TECHMAP_WIREINIT_Q_ = 1'bx;
    generate if (_TECHMAP_WIREINIT_Q_ === 1'b1)
        TRELLIS_FF #(.GSR("AUTO"), .CEMUX("INV"), .CLKMUX("INV"), .LSRMUX("LSR"), .REGSET("SET"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(1'b0), .DI(D), .Q(Q));
    else
        TRELLIS_FF #(.GSR("AUTO"), .CEMUX("INV"), .CLKMUX("INV"), .LSRMUX("LSR"), .REGSET("RESET"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(1'b0), .DI(D), .Q(Q));
    endgenerate
    wire _TECHMAP_REMOVEINIT_Q_ = 1'b1;
endmodule

module  \\$_DFFE_PN_ (input D, C, E, output Q);
    parameter _TECHMAP_WIREINIT_Q_ = 1'bx;
    generate if (_TECHMAP_WIREINIT_Q_ === 1'b1)
        TRELLIS_FF #(.GSR("AUTO"), .CEMUX("INV"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(1'b0), .DI(D), .Q(Q));
    else
        TRELLIS_FF #(.GSR("AUTO"), .CEMUX("INV"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(1'b0), .DI(D), .Q(Q));
    endgenerate
    wire _TECHMAP_REMOVEINIT_Q_ = 1'b1;
endmodule

module  \\$_DFFE_NP_ (input D, C, E, output Q);
    parameter _TECHMAP_WIREINIT_Q_ = 1'bx;
    generate if (_TECHMAP_WIREINIT_Q_ === 1'b1)
        TRELLIS_FF #(.GSR("AUTO"), .CEMUX("CE"), .CLKMUX("INV"), .LSRMUX("LSR"), .REGSET("SET"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(1'b0), .DI(D), .Q(Q));
    else
        TRELLIS_FF #(.GSR("AUTO"), .CEMUX("CE"), .CLKMUX("INV"), .LSRMUX("LSR"), .REGSET("RESET"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(1'b0), .DI(D), .Q(Q));
    endgenerate
    wire _TECHMAP_REMOVEINIT_Q_ = 1'b1;
endmodule

module  \\$_DFFE_PP_ (input D, C, E, output Q);
    parameter _TECHMAP_WIREINIT_Q_ = 1'bx;
    generate if (_TECHMAP_WIREINIT_Q_ === 1'b1)
        TRELLIS_FF #(.GSR("AUTO"), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(1'b0), .DI(D), .Q(Q));
    else
        TRELLIS_FF #(.GSR("AUTO"), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(1'b0), .DI(D), .Q(Q));
    endgenerate
    wire _TECHMAP_REMOVEINIT_Q_ = 1'b1;
endmodule

module  \\$_DFF_NP0_ (input D, C, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("1"), .CLKMUX("INV"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("ASYNC"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_DFF_NP1_ (input D, C, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("1"), .CLKMUX("INV"), .LSRMUX("LSR"), .REGSET("SET"), .SRMODE("ASYNC"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_DFF_PP0_ (input D, C, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("1"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("ASYNC"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_DFF_PP1_ (input D, C, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("1"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"), .SRMODE("ASYNC"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule

module  \\$_SDFF_NP0_ (input D, C, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("1"), .CLKMUX("INV"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("LSR_OVER_CE"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_SDFF_NP1_ (input D, C, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("1"), .CLKMUX("INV"), .LSRMUX("LSR"), .REGSET("SET"), .SRMODE("LSR_OVER_CE"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_SDFF_PP0_ (input D, C, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("1"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("LSR_OVER_CE"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_SDFF_PP1_ (input D, C, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("1"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"), .SRMODE("LSR_OVER_CE"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule

module  \\$_DFFE_NP0P_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("CE"), .CLKMUX("INV"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("ASYNC"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_DFFE_NP1P_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("CE"), .CLKMUX("INV"), .LSRMUX("LSR"), .REGSET("SET"), .SRMODE("ASYNC"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_DFFE_PP0P_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("ASYNC"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_DFFE_PP1P_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"), .SRMODE("ASYNC"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule

module  \\$_DFFE_NP0N_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("INV"), .CLKMUX("INV"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("ASYNC"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_DFFE_NP1N_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("INV"), .CLKMUX("INV"), .LSRMUX("LSR"), .REGSET("SET"), .SRMODE("ASYNC"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_DFFE_PP0N_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("INV"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("ASYNC"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_DFFE_PP1N_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("INV"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"), .SRMODE("ASYNC"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule

module  \\$_SDFFE_NP0P_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("CE"), .CLKMUX("INV"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("LSR_OVER_CE"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_SDFFE_NP1P_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("CE"), .CLKMUX("INV"), .LSRMUX("LSR"), .REGSET("SET"), .SRMODE("LSR_OVER_CE"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_SDFFE_PP0P_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("LSR_OVER_CE"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_SDFFE_PP1P_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"), .SRMODE("LSR_OVER_CE"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule

module  \\$_SDFFE_NP0N_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("INV"), .CLKMUX("INV"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("LSR_OVER_CE"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_SDFFE_NP1N_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("INV"), .CLKMUX("INV"), .LSRMUX("LSR"), .REGSET("SET"), .SRMODE("LSR_OVER_CE"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_SDFFE_PP0N_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("INV"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("LSR_OVER_CE"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_SDFFE_PP1N_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("INV"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"), .SRMODE("LSR_OVER_CE"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule

module \\$_ALDFF_NP_ (input C, L, AD, D, output Q); TRELLIS_FF #(.GSR("DISABLED"), .CEMUX("1"), .CLKMUX("INV"), .LSRMODE("PRLD"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("ASYNC"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(L), .DI(D), .M(AD), .Q(Q)); endmodule
module \\$_ALDFF_PP_ (input C, L, AD, D, output Q); TRELLIS_FF #(.GSR("DISABLED"), .CEMUX("1"), .CLKMUX("CLK"), .LSRMODE("PRLD"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("ASYNC"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(L), .DI(D), .M(AD), .Q(Q)); endmodule

module \\$_ALDFFE_NPN_ (input C, E, L, AD, D, output Q); TRELLIS_FF #(.GSR("DISABLED"), .CEMUX("INV"), .CLKMUX("INV"), .LSRMODE("PRLD"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("ASYNC"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(L), .DI(D), .M(AD), .Q(Q)); endmodule
module \\$_ALDFFE_NPP_ (input C, E, L, AD, D, output Q); TRELLIS_FF #(.GSR("DISABLED"), .CEMUX("CE"), .CLKMUX("INV"), .LSRMODE("PRLD"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("ASYNC"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(L), .DI(D), .M(AD), .Q(Q)); endmodule
module \\$_ALDFFE_PPN_ (input C, E, L, AD, D, output Q); TRELLIS_FF #(.GSR("DISABLED"), .CEMUX("INV"), .CLKMUX("CLK"), .LSRMODE("PRLD"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("ASYNC"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(L), .DI(D), .M(AD), .Q(Q)); endmodule
module \\$_ALDFFE_PPP_ (input C, E, L, AD, D, output Q); TRELLIS_FF #(.GSR("DISABLED"), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMODE("PRLD"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("ASYNC"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(L), .DI(D), .M(AD), .Q(Q)); endmodule

\`include "cells_ff.vh"
\`include "cells_io.vh"

\`ifndef NO_LUT
module \\$lut (A, Y);
    parameter WIDTH = 0;
    parameter LUT = 0;

    (* force_downto *)
    input [WIDTH-1:0] A;
    output Y;

    generate
        if (WIDTH == 1) begin
            localparam [15:0] INIT = {{8{LUT[1]}}, {8{LUT[0]}}};
            LUT4 #(.INIT(INIT)) _TECHMAP_REPLACE_ (.Z(Y),
                .A(1'b0), .B(1'b0), .C(1'b0), .D(A[0]));
        end else
        if (WIDTH == 2) begin
            localparam [15:0] INIT = {{4{LUT[3]}}, {4{LUT[2]}}, {4{LUT[1]}}, {4{LUT[0]}}};
            LUT4 #(.INIT(INIT)) _TECHMAP_REPLACE_ (.Z(Y),
                .A(1'b0), .B(1'b0), .C(A[0]), .D(A[1]));
        end else
        if (WIDTH == 3) begin
            localparam [15:0] INIT = {{2{LUT[7]}}, {2{LUT[6]}}, {2{LUT[5]}}, {2{LUT[4]}}, {2{LUT[3]}}, {2{LUT[2]}}, {2{LUT[1]}}, {2{LUT[0]}}};
            LUT4 #(.INIT(INIT)) _TECHMAP_REPLACE_ (.Z(Y),
                .A(1'b0), .B(A[0]), .C(A[1]), .D(A[2]));
        end else
        if (WIDTH == 4) begin
            LUT4 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.Z(Y),
                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));
        \`ifndef NO_PFUMUX
        end else
        if (WIDTH == 5) begin
            wire f0, f1;
            LUT4 #(.INIT(LUT[15: 0])) lut0 (.Z(f0),
                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));
            LUT4 #(.INIT(LUT[31:16])) lut1 (.Z(f1),
                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));
            PFUMX mux5(.ALUT(f1), .BLUT(f0), .C0(A[4]), .Z(Y));
        end else
        if (WIDTH == 6) begin
            wire f0, f1, f2, f3, g0, g1;
            LUT4 #(.INIT(LUT[15: 0])) lut0 (.Z(f0),
                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));
            LUT4 #(.INIT(LUT[31:16])) lut1 (.Z(f1),
                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));

            LUT4 #(.INIT(LUT[47:32])) lut2 (.Z(f2),
                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));
            LUT4 #(.INIT(LUT[63:48])) lut3 (.Z(f3),
                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));

            PFUMX mux50(.ALUT(f1), .BLUT(f0), .C0(A[4]), .Z(g0));
            PFUMX mux51(.ALUT(f3), .BLUT(f2), .C0(A[4]), .Z(g1));
            L6MUX21 mux6 (.D0(g0), .D1(g1), .SD(A[5]), .Z(Y));
        end else
        if (WIDTH == 7) begin
            wire f0, f1, f2, f3, f4, f5, f6, f7, g0, g1, g2, g3, h0, h1;
            LUT4 #(.INIT(LUT[15: 0])) lut0 (.Z(f0),
                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));
            LUT4 #(.INIT(LUT[31:16])) lut1 (.Z(f1),
                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));

            LUT4 #(.INIT(LUT[47:32])) lut2 (.Z(f2),
                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));
            LUT4 #(.INIT(LUT[63:48])) lut3 (.Z(f3),
                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));

            LUT4 #(.INIT(LUT[79:64])) lut4 (.Z(f4),
                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));
            LUT4 #(.INIT(LUT[95:80])) lut5 (.Z(f5),
                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));

            LUT4 #(.INIT(LUT[111: 96])) lut6 (.Z(f6),
                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));
            LUT4 #(.INIT(LUT[127:112])) lut7 (.Z(f7),
                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));

            PFUMX mux50(.ALUT(f1), .BLUT(f0), .C0(A[4]), .Z(g0));
            PFUMX mux51(.ALUT(f3), .BLUT(f2), .C0(A[4]), .Z(g1));
            PFUMX mux52(.ALUT(f5), .BLUT(f4), .C0(A[4]), .Z(g2));
            PFUMX mux53(.ALUT(f7), .BLUT(f6), .C0(A[4]), .Z(g3));
            L6MUX21 mux60 (.D0(g0), .D1(g1), .SD(A[5]), .Z(h0));
            L6MUX21 mux61 (.D0(g2), .D1(g3), .SD(A[5]), .Z(h1));
            L6MUX21 mux7  (.D0(h0), .D1(h1), .SD(A[6]), .Z(Y));
        \`endif
        end else begin
            wire _TECHMAP_FAIL_ = 1;
        end
    endgenerate
endmodule
\`endif
`,"cells_sim.v":`// ---------------------------------------

(* abc9_lut=1, lib_whitebox *)
module LUT4(input A, B, C, D, output Z);
    parameter [15:0] INIT = 16'h0000;
    wire [7:0] s3 = D ?     INIT[15:8] :     INIT[7:0];
    wire [3:0] s2 = C ?       s3[ 7:4] :       s3[3:0];
    wire [1:0] s1 = B ?       s2[ 3:2] :       s2[1:0];
    assign Z =      A ?          s1[1] :         s1[0];
    specify
        (A => Z) = 141;
        (B => Z) = 275;
        (C => Z) = 379;
        (D => Z) = 379;
    endspecify
endmodule

// This is a placeholder for ABC9 to extract the area/delay
//   cost of 5-input LUTs and is not intended to be instantiated
// LUT5 = 2x LUT4 + PFUMX
(* abc9_lut=2 *)
module \\$__ABC9_LUT5 (input M0, D, C, B, A, output Z);
    specify
        (M0 => Z) = 151;
        (D => Z) = 239;
        (C => Z) = 373;
        (B => Z) = 477;
        (A => Z) = 477;
    endspecify
endmodule

// This is a placeholder for ABC9 to extract the area/delay
//   of 6-input LUTs and is not intended to be instantiated
// LUT6 = 2x LUT5 + MUX2
(* abc9_lut=4 *)
module \\$__ABC9_LUT6 (input M1, M0, D, C, B, A, output Z);
    specify
        (M1 => Z) = 148;
        (M0 => Z) = 292;
        (D => Z) = 380;
        (C => Z) = 514;
        (B => Z) = 618;
        (A => Z) = 618;
    endspecify
endmodule

// This is a placeholder for ABC9 to extract the area/delay
//   of 7-input LUTs and is not intended to be instantiated
// LUT7 = 2x LUT6 + MUX2
(* abc9_lut=8 *)
module \\$__ABC9_LUT7 (input M2, M1, M0, D, C, B, A, output Z);
    specify
        (M2 => Z) = 148;
        (M1 => Z) = 289;
        (M0 => Z) = 433;
        (D => Z) = 521;
        (C => Z) = 655;
        (B => Z) = 759;
        (A => Z) = 759;
    endspecify
endmodule

// ---------------------------------------
(* abc9_box, lib_whitebox *)
module L6MUX21 (input D0, D1, SD, output Z);
	assign Z = SD ? D1 : D0;
	specify
		(D0 => Z) = 140;
		(D1 => Z) = 141;
		(SD => Z) = 148;
	endspecify
endmodule

// ---------------------------------------
(* abc9_box, lib_whitebox *)
module CCU2C(
	(* abc9_carry *)
	input  CIN,
	input  A0, B0, C0, D0, A1, B1, C1, D1,
	output S0, S1,
	(* abc9_carry *)
	output COUT
);
	parameter [15:0] INIT0 = 16'h0000;
	parameter [15:0] INIT1 = 16'h0000;
	parameter INJECT1_0 = "YES";
	parameter INJECT1_1 = "YES";

	// First half
	wire LUT4_0, LUT2_0;
	LUT4 #(.INIT(INIT0)) lut4_0(.A(A0), .B(B0), .C(C0), .D(D0), .Z(LUT4_0));
	LUT2 #(.INIT(INIT0[3:0])) lut2_0(.A(A0), .B(B0), .Z(LUT2_0));
	wire gated_cin_0 = (INJECT1_0 == "YES") ? 1'b0 : CIN;
	assign S0 = LUT4_0 ^ gated_cin_0;

	wire gated_lut2_0 = (INJECT1_0 == "YES") ? 1'b0 : LUT2_0;
	wire cout_0 = (~LUT4_0 & gated_lut2_0) | (LUT4_0 & CIN);

	// Second half
	wire LUT4_1, LUT2_1;
	LUT4 #(.INIT(INIT1)) lut4_1(.A(A1), .B(B1), .C(C1), .D(D1), .Z(LUT4_1));
	LUT2 #(.INIT(INIT1[3:0])) lut2_1(.A(A1), .B(B1), .Z(LUT2_1));
	wire gated_cin_1 = (INJECT1_1 == "YES") ? 1'b0 : cout_0;
	assign S1 = LUT4_1 ^ gated_cin_1;

	wire gated_lut2_1 = (INJECT1_1 == "YES") ? 1'b0 : LUT2_1;
	assign COUT = (~LUT4_1 & gated_lut2_1) | (LUT4_1 & cout_0);

	specify
		(A0 => S0) = 379;
		(B0 => S0) = 379;
		(C0 => S0) = 275;
		(D0 => S0) = 141;
		(CIN => S0) = 257;
		(A0 => S1) = 630;
		(B0 => S1) = 630;
		(C0 => S1) = 526;
		(D0 => S1) = 392;
		(A1 => S1) = 379;
		(B1 => S1) = 379;
		(C1 => S1) = 275;
		(D1 => S1) = 141;
		(CIN => S1) = 273;
		(A0 => COUT) = 516;
		(B0 => COUT) = 516;
		(C0 => COUT) = 412;
		(D0 => COUT) = 278;
		(A1 => COUT) = 516;
		(B1 => COUT) = 516;
		(C1 => COUT) = 412;
		(D1 => COUT) = 278;
		(CIN => COUT) = 43;
	endspecify
endmodule

// ---------------------------------------

module TRELLIS_RAM16X2 (
	input DI0, DI1,
	input WAD0, WAD1, WAD2, WAD3,
	input WRE, WCK,
	input RAD0, RAD1, RAD2, RAD3,
	output DO0, DO1
);
	parameter WCKMUX = "WCK";
	parameter WREMUX = "WRE";
	parameter INITVAL_0 = 16'h0000;
	parameter INITVAL_1 = 16'h0000;

	reg [1:0] mem[15:0];

	integer i;
	initial begin
		for (i = 0; i < 16; i = i + 1)
			mem[i] <= {INITVAL_1[i], INITVAL_0[i]};
	end

	wire muxwck = (WCKMUX == "INV") ? ~WCK : WCK;

	reg muxwre;
	always @(*)
		case (WREMUX)
			"1": muxwre = 1'b1;
			"0": muxwre = 1'b0;
			"INV": muxwre = ~WRE;
			default: muxwre = WRE;
		endcase


	always @(posedge muxwck)
		if (muxwre)
			mem[{WAD3, WAD2, WAD1, WAD0}] <= {DI1, DI0};

	assign {DO1, DO0} = mem[{RAD3, RAD2, RAD1, RAD0}];
endmodule

// ---------------------------------------
(* abc9_box, lib_whitebox *)
module PFUMX (input ALUT, BLUT, C0, output Z);
	assign Z = C0 ? ALUT : BLUT;
	specify
		(ALUT => Z) = 98;
		(BLUT => Z) = 98;
		(C0 => Z) = 151;
	endspecify
endmodule

// ---------------------------------------
(* abc9_box, lib_whitebox *)
module TRELLIS_DPR16X4 (
	input  [3:0] DI,
	input  [3:0] WAD,
	input        WRE,
	input        WCK,
	input  [3:0] RAD,
	output [3:0] DO
);
	parameter WCKMUX = "WCK";
	parameter WREMUX = "WRE";
	parameter [63:0] INITVAL = 64'h0000000000000000;

	reg [3:0] mem[15:0];

	integer i;
	initial begin
		for (i = 0; i < 16; i = i + 1)
			mem[i] <= INITVAL[4*i +: 4];
	end

	wire muxwck = (WCKMUX == "INV") ? ~WCK : WCK;

	reg muxwre;
	always @(*)
		case (WREMUX)
			"1": muxwre = 1'b1;
			"0": muxwre = 1'b0;
			"INV": muxwre = ~WRE;
			default: muxwre = WRE;
		endcase

	always @(posedge muxwck)
		if (muxwre)
			mem[WAD] <= DI;

	assign DO = mem[RAD];

	specify
		// TODO
		(RAD *> DO) = 0;
	endspecify
endmodule

// ---------------------------------------

(* abc9_box, lib_whitebox *)
module DPR16X4C (
		input [3:0] DI,
		input WCK, WRE,
		input [3:0] RAD,
		input [3:0] WAD,
		output [3:0] DO
);
	// For legacy Lattice compatibility, INITIVAL is a hex
	// string rather than a numeric parameter
	parameter INITVAL = "0x0000000000000000";

	function [63:0] convert_initval;
		input [143:0] hex_initval;
		reg done;
		reg [63:0] temp;
		reg [7:0] char;
		integer i;
		begin
			done = 1'b0;
			temp = 0;
			for (i = 0; i < 16; i = i + 1) begin
				if (!done) begin
					char = hex_initval[8*i +: 8];
					if (char == "x") begin
						done = 1'b1;
					end else begin
						if (char >= "0" && char <= "9")
							temp[4*i +: 4] = char - "0";
						else if (char >= "A" && char <= "F")
							temp[4*i +: 4] = 10 + char - "A";
						else if (char >= "a" && char <= "f")
							temp[4*i +: 4] = 10 + char - "a";
					end
				end
			end
			convert_initval = temp;
		end
	endfunction

	localparam conv_initval = convert_initval(INITVAL);

	reg [3:0] ram[0:15];
	integer i;
	initial begin
		for (i = 0; i < 15; i = i + 1) begin
			ram[i] <= conv_initval[4*i +: 4];
		end
	end

	always @(posedge WCK)
		if (WRE)
			ram[WAD] <= DI;

	assign DO = ram[RAD];

	specify
		// TODO
		(RAD *> DO) = 0;
	endspecify
endmodule

// ---------------------------------------

(* lib_whitebox *)
module LUT2(input A, B, output Z);
    parameter [3:0] INIT = 4'h0;
    wire [1:0] s1 = B ?     INIT[ 3:2] :     INIT[1:0];
    assign Z =      A ?          s1[1] :         s1[0];
endmodule

// ---------------------------------------

\`ifdef YOSYS
(* abc9_flop=(SRMODE != "ASYNC"), abc9_box=(SRMODE == "ASYNC"), lib_whitebox *)
\`endif
module TRELLIS_FF(input CLK, LSR, CE, DI, M, output reg Q);
	parameter GSR = "ENABLED";
	parameter [127:0] CEMUX = "1";
	parameter CLKMUX = "CLK";
	parameter LSRMUX = "LSR";
	parameter SRMODE = "LSR_OVER_CE";
	parameter REGSET = "RESET";
	parameter [127:0] LSRMODE = "LSR";

	wire muxce;
	generate
		case (CEMUX)
			"1": assign muxce = 1'b1;
			"0": assign muxce = 1'b0;
			"INV": assign muxce = ~CE;
			default: assign muxce = CE;
		endcase
	endgenerate

	wire muxlsr = (LSRMUX == "INV") ? ~LSR : LSR;
	wire muxclk = (CLKMUX == "INV") ? ~CLK : CLK;
	wire srval;
	generate
		if (LSRMODE == "PRLD")
			assign srval = M;
		else
			assign srval = (REGSET == "SET") ? 1'b1 : 1'b0;
	endgenerate

	initial Q = srval;

	generate
		if (SRMODE == "ASYNC") begin
			always @(posedge muxclk, posedge muxlsr)
				if (muxlsr)
					Q <= srval;
				else if (muxce)
					Q <= DI;
		end else begin
			always @(posedge muxclk)
				if (muxlsr)
					Q <= srval;
				else if (muxce)
					Q <= DI;
		end
	endgenerate

	specify
		$setup(DI, negedge CLK &&& CLKMUX == "INV", 0);
		$setup(CE, negedge CLK &&& CLKMUX == "INV", 0);
		$setup(LSR, negedge CLK &&& CLKMUX == "INV", 0);
		$setup(DI, posedge CLK &&& CLKMUX != "INV", 0);
		$setup(CE, posedge CLK &&& CLKMUX != "INV", 0);
		$setup(LSR, posedge CLK &&& CLKMUX != "INV", 0);
\`ifndef YOSYS
		if (SRMODE == "ASYNC" && muxlsr && CLKMUX == "INV") (negedge CLK => (Q : srval)) = 0;
		if (SRMODE == "ASYNC" && muxlsr && CLKMUX != "INV") (posedge CLK => (Q : srval)) = 0;
\`else
		if (SRMODE == "ASYNC" && muxlsr) (LSR => Q) = 0; 	// Technically, this should be an edge sensitive path
									// but for facilitating a bypass box, let's pretend it's
									// a simple path
\`endif
		if (!muxlsr && muxce && CLKMUX == "INV") (negedge CLK => (Q : DI)) = 0;
		if (!muxlsr && muxce && CLKMUX != "INV") (posedge CLK => (Q : DI)) = 0;
	endspecify
endmodule

// ---------------------------------------
(* keep *)
module TRELLIS_IO(
	(* iopad_external_pin *)
	inout B,
	input I,
	input T,
	output O
);
	parameter DIR = "INPUT";
	reg T_pd;
	always @(*) if (T === 1'bz) T_pd <= 1'b0; else T_pd <= T;

	generate
		if (DIR == "INPUT") begin
			assign B = 1'bz;
			assign O = B;
		end else if (DIR == "OUTPUT") begin
			assign B = T_pd ? 1'bz : I;
			assign O = 1'bx;
		end else if (DIR == "BIDIR") begin
			assign B = T_pd ? 1'bz : I;
			assign O = B;
		end else begin
			ERROR_UNKNOWN_IO_MODE error();
		end
	endgenerate

endmodule

// ---------------------------------------

module INV(input A, output Z);
	assign Z = !A;
endmodule

// ---------------------------------------

module TRELLIS_COMB(
	input A, B, C, D, M,
	input FCI, F1, FXA, FXB,
	input WD,
	input WAD0, WAD1, WAD2, WAD3,
	input WRE, WCK,
	output F, FCO, OFX
);
	parameter MODE = "LOGIC";
	parameter INITVAL = 16'h0;
	parameter CCU2_INJECT1 = "NO";
	parameter WREMUX = "WRE";
	parameter IS_Z1 = 1'b0;

	generate
		if (MODE == "LOGIC") begin: mode_logic
			LUT4 #(.INIT(INITVAL)) lut4 (.A(A), .B(B), .C(C), .D(D), .Z(F));
		end else if (MODE == "CCU2") begin: mode_ccu2
			wire l4o, l2o;
			LUT4 #(.INIT(INITVAL)) lut4_0(.A(A), .B(B), .C(C), .D(D), .Z(l4o));
			LUT2 #(.INIT(INITVAL[3:0])) lut2_0(.A(A), .B(B), .Z(l2o));
			wire gated_cin_0 = (CCU2_INJECT1 == "YES") ? 1'b0 : FCI;
			assign F = l4o ^ gated_cin_0;
			wire gated_lut2_0 = (CCU2_INJECT1 == "YES") ? 1'b0 : l2o;
			wire FCO = (~l4o & gated_lut2_0) | (l4o & FCI);
		end else if (MODE == "DPRAM") begin: mode_dpram
			reg [15:0] ram = INITVAL;
			always @(posedge WCK)
				if (WRE)
					ram[{WAD3, WAD2, WAD1, WAD0}] <= WD;
			assign F = ram[{A, C, B, D}];
		end else begin
			$error("unsupported COMB mode %s", MODE);
		end

 		if (IS_Z1)
			L6MUX21 lutx_mux (.D0(FXA), .D1(FXB), .SD(M), .Z(OFX));
		else
			PFUMX lut5_mux (.ALUT(F1), .BLUT(F), .C0(M), .Z(OFX));
	endgenerate

endmodule

(* blackbox *)
module DP16KD(
  input DIA17, DIA16, DIA15, DIA14, DIA13, DIA12, DIA11, DIA10, DIA9, DIA8, DIA7, DIA6, DIA5, DIA4, DIA3, DIA2, DIA1, DIA0,
  input ADA13, ADA12, ADA11, ADA10, ADA9, ADA8, ADA7, ADA6, ADA5, ADA4, ADA3, ADA2, ADA1, ADA0,
  input CEA, OCEA, CLKA, WEA, RSTA,
  input CSA2, CSA1, CSA0,
  output DOA17, DOA16, DOA15, DOA14, DOA13, DOA12, DOA11, DOA10, DOA9, DOA8, DOA7, DOA6, DOA5, DOA4, DOA3, DOA2, DOA1, DOA0,

  input DIB17, DIB16, DIB15, DIB14, DIB13, DIB12, DIB11, DIB10, DIB9, DIB8, DIB7, DIB6, DIB5, DIB4, DIB3, DIB2, DIB1, DIB0,
  input ADB13, ADB12, ADB11, ADB10, ADB9, ADB8, ADB7, ADB6, ADB5, ADB4, ADB3, ADB2, ADB1, ADB0,
  input CEB, OCEB, CLKB, WEB, RSTB,
  input CSB2, CSB1, CSB0,
  output DOB17, DOB16, DOB15, DOB14, DOB13, DOB12, DOB11, DOB10, DOB9, DOB8, DOB7, DOB6, DOB5, DOB4, DOB3, DOB2, DOB1, DOB0
);
	parameter DATA_WIDTH_A = 18;
	parameter DATA_WIDTH_B = 18;

	parameter REGMODE_A = "NOREG";
	parameter REGMODE_B = "NOREG";

	parameter RESETMODE = "SYNC";
	parameter ASYNC_RESET_RELEASE = "SYNC";

	parameter CSDECODE_A = "0b000";
	parameter CSDECODE_B = "0b000";

	parameter WRITEMODE_A = "NORMAL";
	parameter WRITEMODE_B = "NORMAL";

	parameter DIA17MUX = "DIA17";
	parameter DIA16MUX = "DIA16";
	parameter DIA15MUX = "DIA15";
	parameter DIA14MUX = "DIA14";
	parameter DIA13MUX = "DIA13";
	parameter DIA12MUX = "DIA12";
	parameter DIA11MUX = "DIA11";
	parameter DIA10MUX = "DIA10";
	parameter DIA9MUX = "DIA9";
	parameter DIA8MUX = "DIA8";
	parameter DIA7MUX = "DIA7";
	parameter DIA6MUX = "DIA6";
	parameter DIA5MUX = "DIA5";
	parameter DIA4MUX = "DIA4";
	parameter DIA3MUX = "DIA3";
	parameter DIA2MUX = "DIA2";
	parameter DIA1MUX = "DIA1";
	parameter DIA0MUX = "DIA0";
	parameter ADA13MUX = "ADA13";
	parameter ADA12MUX = "ADA12";
	parameter ADA11MUX = "ADA11";
	parameter ADA10MUX = "ADA10";
	parameter ADA9MUX = "ADA9";
	parameter ADA8MUX = "ADA8";
	parameter ADA7MUX = "ADA7";
	parameter ADA6MUX = "ADA6";
	parameter ADA5MUX = "ADA5";
	parameter ADA4MUX = "ADA4";
	parameter ADA3MUX = "ADA3";
	parameter ADA2MUX = "ADA2";
	parameter ADA1MUX = "ADA1";
	parameter ADA0MUX = "ADA0";
	parameter CEAMUX = "CEA";
	parameter OCEAMUX = "OCEA";
	parameter CLKAMUX = "CLKA";
	parameter WEAMUX = "WEA";
	parameter RSTAMUX = "RSTA";
	parameter CSA2MUX = "CSA2";
	parameter CSA1MUX = "CSA1";
	parameter CSA0MUX = "CSA0";
	parameter DOA17MUX = "DOA17";
	parameter DOA16MUX = "DOA16";
	parameter DOA15MUX = "DOA15";
	parameter DOA14MUX = "DOA14";
	parameter DOA13MUX = "DOA13";
	parameter DOA12MUX = "DOA12";
	parameter DOA11MUX = "DOA11";
	parameter DOA10MUX = "DOA10";
	parameter DOA9MUX = "DOA9";
	parameter DOA8MUX = "DOA8";
	parameter DOA7MUX = "DOA7";
	parameter DOA6MUX = "DOA6";
	parameter DOA5MUX = "DOA5";
	parameter DOA4MUX = "DOA4";
	parameter DOA3MUX = "DOA3";
	parameter DOA2MUX = "DOA2";
	parameter DOA1MUX = "DOA1";
	parameter DOA0MUX = "DOA0";
	parameter DIB17MUX = "DIB17";
	parameter DIB16MUX = "DIB16";
	parameter DIB15MUX = "DIB15";
	parameter DIB14MUX = "DIB14";
	parameter DIB13MUX = "DIB13";
	parameter DIB12MUX = "DIB12";
	parameter DIB11MUX = "DIB11";
	parameter DIB10MUX = "DIB10";
	parameter DIB9MUX = "DIB9";
	parameter DIB8MUX = "DIB8";
	parameter DIB7MUX = "DIB7";
	parameter DIB6MUX = "DIB6";
	parameter DIB5MUX = "DIB5";
	parameter DIB4MUX = "DIB4";
	parameter DIB3MUX = "DIB3";
	parameter DIB2MUX = "DIB2";
	parameter DIB1MUX = "DIB1";
	parameter DIB0MUX = "DIB0";
	parameter ADB13MUX = "ADB13";
	parameter ADB12MUX = "ADB12";
	parameter ADB11MUX = "ADB11";
	parameter ADB10MUX = "ADB10";
	parameter ADB9MUX = "ADB9";
	parameter ADB8MUX = "ADB8";
	parameter ADB7MUX = "ADB7";
	parameter ADB6MUX = "ADB6";
	parameter ADB5MUX = "ADB5";
	parameter ADB4MUX = "ADB4";
	parameter ADB3MUX = "ADB3";
	parameter ADB2MUX = "ADB2";
	parameter ADB1MUX = "ADB1";
	parameter ADB0MUX = "ADB0";
	parameter CEBMUX = "CEB";
	parameter OCEBMUX = "OCEB";
	parameter CLKBMUX = "CLKB";
	parameter WEBMUX = "WEB";
	parameter RSTBMUX = "RSTB";
	parameter CSB2MUX = "CSB2";
	parameter CSB1MUX = "CSB1";
	parameter CSB0MUX = "CSB0";
	parameter DOB17MUX = "DOB17";
	parameter DOB16MUX = "DOB16";
	parameter DOB15MUX = "DOB15";
	parameter DOB14MUX = "DOB14";
	parameter DOB13MUX = "DOB13";
	parameter DOB12MUX = "DOB12";
	parameter DOB11MUX = "DOB11";
	parameter DOB10MUX = "DOB10";
	parameter DOB9MUX = "DOB9";
	parameter DOB8MUX = "DOB8";
	parameter DOB7MUX = "DOB7";
	parameter DOB6MUX = "DOB6";
	parameter DOB5MUX = "DOB5";
	parameter DOB4MUX = "DOB4";
	parameter DOB3MUX = "DOB3";
	parameter DOB2MUX = "DOB2";
	parameter DOB1MUX = "DOB1";
	parameter DOB0MUX = "DOB0";

	parameter WID = 0;

	parameter GSR = "ENABLED";

	parameter INITVAL_00 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_01 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_02 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_03 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_04 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_05 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_06 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_07 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_08 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_09 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_0A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_0B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_0C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_0D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_0E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_0F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_10 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_11 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_12 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_13 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_14 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_15 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_16 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_17 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_18 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_19 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_1A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_1B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_1C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_1D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_1E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_1F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_20 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_21 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_22 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_23 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_24 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_25 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_26 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_27 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_28 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_29 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_2A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_2B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_2C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_2D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_2E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_2F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_30 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_31 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_32 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_33 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_34 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_35 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_36 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_37 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_38 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_39 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_3A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_3B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_3C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_3D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_3E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INITVAL_3F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
	parameter INIT_DATA = "STATIC";
endmodule

\`ifndef NO_INCLUDES

\`include "cells_ff.vh"
\`include "cells_io.vh"

\`endif
`,"dsp_map.v":`module \\$__MUL18X18 (input [17:0] A, input [17:0] B, output [35:0] Y);

	parameter A_WIDTH = 18;
	parameter B_WIDTH = 18;
	parameter Y_WIDTH = 36;
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;

	MULT18X18D _TECHMAP_REPLACE_ (
		.A0(A[0]), .A1(A[1]), .A2(A[2]), .A3(A[3]), .A4(A[4]), .A5(A[5]), .A6(A[6]), .A7(A[7]), .A8(A[8]), .A9(A[9]), .A10(A[10]), .A11(A[11]), .A12(A[12]), .A13(A[13]), .A14(A[14]), .A15(A[15]), .A16(A[16]), .A17(A[17]),
		.B0(B[0]), .B1(B[1]), .B2(B[2]), .B3(B[3]), .B4(B[4]), .B5(B[5]), .B6(B[6]), .B7(B[7]), .B8(B[8]), .B9(B[9]), .B10(B[10]), .B11(B[11]), .B12(B[12]), .B13(B[13]), .B14(B[14]), .B15(B[15]), .B16(B[16]), .B17(B[17]),
		.C17(1'b0), .C16(1'b0), .C15(1'b0), .C14(1'b0), .C13(1'b0), .C12(1'b0), .C11(1'b0), .C10(1'b0), .C9(1'b0), .C8(1'b0), .C7(1'b0), .C6(1'b0), .C5(1'b0), .C4(1'b0), .C3(1'b0), .C2(1'b0), .C1(1'b0), .C0(1'b0),
		.SIGNEDA(A_SIGNED ? 1'b1 : 1'b0), .SIGNEDB(B_SIGNED ? 1'b1 : 1'b0), .SOURCEA(1'b0), .SOURCEB(1'b0),

		.P0(Y[0]), .P1(Y[1]), .P2(Y[2]), .P3(Y[3]), .P4(Y[4]), .P5(Y[5]), .P6(Y[6]), .P7(Y[7]), .P8(Y[8]), .P9(Y[9]), .P10(Y[10]), .P11(Y[11]), .P12(Y[12]), .P13(Y[13]), .P14(Y[14]), .P15(Y[15]), .P16(Y[16]), .P17(Y[17]), .P18(Y[18]), .P19(Y[19]), .P20(Y[20]), .P21(Y[21]), .P22(Y[22]), .P23(Y[23]), .P24(Y[24]), .P25(Y[25]), .P26(Y[26]), .P27(Y[27]), .P28(Y[28]), .P29(Y[29]), .P30(Y[30]), .P31(Y[31]), .P32(Y[32]), .P33(Y[33]), .P34(Y[34]), .P35(Y[35])
	);
endmodule
`,"latches_map.v":`module \\$_DLATCH_N_ (E, D, Q);
  wire [1023:0] _TECHMAP_DO_ = "simplemap; opt";
  input E, D;
  output Q = !E ? D : Q;
endmodule

module \\$_DLATCH_P_ (E, D, Q);
  wire [1023:0] _TECHMAP_DO_ = "simplemap; opt";
  input E, D;
  output Q = E ? D : Q;
endmodule
`,"lutrams.txt":`ram distributed $__TRELLIS_DPR16X4_ {
	abits 4;
	width 4;
	cost 4;
	init any;
	prune_rom;
	port sw "W" {
		clock anyedge;
	}
	port ar "R" {
	}
}
`,"lutrams_map.v":`module $__TRELLIS_DPR16X4_(...);

parameter INIT = 64'bx;
parameter PORT_W_CLK_POL = 1;

input PORT_W_CLK;
input [3:0] PORT_W_ADDR;
input [3:0] PORT_W_WR_DATA;
input PORT_W_WR_EN;

input [3:0] PORT_R_ADDR;
output [3:0] PORT_R_RD_DATA;

localparam WCKMUX = PORT_W_CLK_POL ? "WCK" : "INV";

TRELLIS_DPR16X4 #(
	.INITVAL(INIT),
	.WCKMUX(WCKMUX),
	.WREMUX("WRE")
) _TECHMAP_REPLACE_ (
	.RAD(PORT_R_ADDR),
	.DO(PORT_R_RD_DATA),

	.WAD(PORT_W_ADDR),
	.DI(PORT_W_WR_DATA),
	.WCK(PORT_W_CLK),
	.WRE(PORT_W_WR_EN)
);

endmodule
`},efinix:{"arith_map.v":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2018  Miodrag Milanovic <micko@yosyshq.com>
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

(* techmap_celltype = "$alu" *)
module _80_efinix_alu (A, B, CI, BI, X, Y, CO);
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;
	parameter A_WIDTH  = 1;
	parameter B_WIDTH  = 1;
	parameter Y_WIDTH  = 1;

	(* force_downto *)
	input [A_WIDTH-1:0] A;
	(* force_downto *)
	input [B_WIDTH-1:0] B;
	(* force_downto *)
	output [Y_WIDTH-1:0] X, Y;

	input CI, BI;
	(* force_downto *)
	output [Y_WIDTH-1:0] CO;
   
    wire CIx;
    (* force_downto *)
    wire [Y_WIDTH-1:0] COx;

	wire _TECHMAP_FAIL_ = Y_WIDTH <= 2;

	(* force_downto *)
	wire [Y_WIDTH-1:0] A_buf, B_buf;
	\\$pos #(.A_SIGNED(A_SIGNED), .A_WIDTH(A_WIDTH), .Y_WIDTH(Y_WIDTH)) A_conv (.A(A), .Y(A_buf));
	\\$pos #(.A_SIGNED(B_SIGNED), .A_WIDTH(B_WIDTH), .Y_WIDTH(Y_WIDTH)) B_conv (.A(B), .Y(B_buf));

	(* force_downto *)
	wire [Y_WIDTH-1:0] AA = A_buf;
	(* force_downto *)
	wire [Y_WIDTH-1:0] BB = BI ? ~B_buf : B_buf;
	(* force_downto *)
	wire [Y_WIDTH-1:0] C = { COx, CIx };

    EFX_ADD #(.I0_POLARITY(1'b1),.I1_POLARITY(1'b1))
    adder_cin  (
        .I0(CI),
        .I1(1'b1),
        .CI(1'b0),
        .CO(CIx)
	);

	genvar i;
	generate for (i = 0; i < Y_WIDTH; i = i + 1) begin: slice
		EFX_ADD #(.I0_POLARITY(1'b1),.I1_POLARITY(1'b1))
		adder_i (
			.I0(AA[i]),
			.I1(BB[i]),
			.CI(C[i]),
			.O(Y[i]),
			.CO(COx[i])
		);
		EFX_ADD #(.I0_POLARITY(1'b1),.I1_POLARITY(1'b1))				
		adder_cout  (
			.I0(1'b0),
			.I1(1'b0),
			.CI(COx[i]),
			.O(CO[i])
		);
	  end: slice	  
	endgenerate

   /* End implementation */
   assign X = AA ^ BB;
endmodule
`,"brams.txt":`ram block $__EFINIX_5K_ {
	abits 12;
	widths 1 2 5 10 20 per_port;
	cost 32;
	init no_undef;
	port sr "R" {
		clock anyedge;
		rden;
	}
	port sw "W" {
		clock anyedge;
		option "WRITE_MODE" "READ_FIRST" {
			wrtrans "R" old;
		}
		option "WRITE_MODE" "WRITE_FIRST" {
			wrtrans "R" new;
		}
	}
}
`,"brams_map.v":`module $__EFINIX_5K_ (...);
	parameter INIT = 0;
	parameter OPTION_WRITE_MODE = "READ_FIRST";

	parameter PORT_R_WIDTH = 20;
	parameter PORT_R_CLK_POL = 1;
	parameter PORT_W_WIDTH = 20;
	parameter PORT_W_CLK_POL = 1;

	input PORT_R_CLK;
	input PORT_R_RD_EN;
	input [11:0] PORT_R_ADDR;
	output [PORT_R_WIDTH-1:0] PORT_R_RD_DATA;

	input PORT_W_CLK;
	input PORT_W_WR_EN;
	input [11:0] PORT_W_ADDR;
	input [PORT_W_WIDTH-1:0] PORT_W_WR_DATA;

	localparam IS_5BIT = PORT_R_WIDTH >= 5 && PORT_W_WIDTH >= 5;

	localparam RADDR_WIDTH =
		PORT_R_WIDTH == 1 ? 12 :
		PORT_R_WIDTH == 2 ? 11 :
		PORT_R_WIDTH == 5 ? 10 :
		PORT_R_WIDTH == 10 ? 9 :
		8;

	localparam WADDR_WIDTH =
		PORT_W_WIDTH == 1 ? 12 :
		PORT_W_WIDTH == 2 ? 11 :
		PORT_W_WIDTH == 5 ? 10 :
		PORT_W_WIDTH == 10 ? 9 :
		8;

	localparam READ_WIDTH = 
		PORT_R_WIDTH == 1 ? 1 :
		PORT_R_WIDTH == 2 ? 2 :
		PORT_R_WIDTH == 5 ? (IS_5BIT ? 5 : 4) :
		PORT_R_WIDTH == 10 ? (IS_5BIT ? 10 : 8) :
		(IS_5BIT ? 20 : 16);

	localparam WRITE_WIDTH = 
		PORT_W_WIDTH == 1 ? 1 :
		PORT_W_WIDTH == 2 ? 2 :
		PORT_W_WIDTH == 5 ? (IS_5BIT ? 5 : 4) :
		PORT_W_WIDTH == 10 ? (IS_5BIT ? 10 : 8) :
		(IS_5BIT ? 20 : 16);

	wire [RADDR_WIDTH-1:0] RADDR = PORT_R_ADDR[11:12-RADDR_WIDTH];
	wire [WADDR_WIDTH-1:0] WADDR = PORT_W_ADDR[11:12-WADDR_WIDTH];

	wire [WRITE_WIDTH-1:0] WDATA;
	wire [READ_WIDTH-1:0] RDATA;

	generate
		case (WRITE_WIDTH)
		1:	assign WDATA = PORT_W_WR_DATA;
		2:	assign WDATA = PORT_W_WR_DATA;
		4:	assign WDATA = PORT_W_WR_DATA[3:0];
		5:	assign WDATA = PORT_W_WR_DATA;
		8:	assign WDATA = {
			PORT_W_WR_DATA[8:5],
			PORT_W_WR_DATA[3:0]
		};
		10:	assign WDATA = PORT_W_WR_DATA;
		16:	assign WDATA = {
			PORT_W_WR_DATA[18:15],
			PORT_W_WR_DATA[13:10],
			PORT_W_WR_DATA[8:5],
			PORT_W_WR_DATA[3:0]
		};
		20:	assign WDATA = PORT_W_WR_DATA;
		endcase
		case (READ_WIDTH)
		1:	assign PORT_R_RD_DATA = RDATA;
		2:	assign PORT_R_RD_DATA = RDATA;
		4:	assign PORT_R_RD_DATA[3:0] = RDATA;
		5:	assign PORT_R_RD_DATA = RDATA;
		8:	assign {
			PORT_R_RD_DATA[8:5],
			PORT_R_RD_DATA[3:0]
		} = RDATA;
		10:	assign PORT_R_RD_DATA = RDATA;
		16:	assign {
			PORT_R_RD_DATA[18:15],
			PORT_R_RD_DATA[13:10],
			PORT_R_RD_DATA[8:5],
			PORT_R_RD_DATA[3:0]
		} = RDATA;
		20:	assign PORT_R_RD_DATA = RDATA;
		endcase
	endgenerate

	function [255:0] init_slice;
		input integer idx;
		integer i;
		if (IS_5BIT)
			init_slice = INIT[idx * 256 +: 256];
		else if (idx > 16)
			init_slice = 0;
		else
			for (i = 0; i < 64; i = i + 1)
				init_slice[i*4+:4] = INIT[(idx * 64 + i) * 5+:4];
	endfunction

	EFX_RAM_5K #(
		.READ_WIDTH(READ_WIDTH),
		.WRITE_WIDTH(WRITE_WIDTH),
		.OUTPUT_REG(1'b0),
		.RCLK_POLARITY(PORT_R_CLK_POL),
		.RE_POLARITY(1'b1),
		.WCLK_POLARITY(PORT_W_CLK_POL),
		.WE_POLARITY(1'b1),
		.WCLKE_POLARITY(1'b1),
		.WRITE_MODE(OPTION_WRITE_MODE),
		.INIT_0(init_slice('h00)),
		.INIT_1(init_slice('h01)),
		.INIT_2(init_slice('h02)),
		.INIT_3(init_slice('h03)),
		.INIT_4(init_slice('h04)),
		.INIT_5(init_slice('h05)),
		.INIT_6(init_slice('h06)),
		.INIT_7(init_slice('h07)),
		.INIT_8(init_slice('h08)),
		.INIT_9(init_slice('h09)),
		.INIT_A(init_slice('h0a)),
		.INIT_B(init_slice('h0b)),
		.INIT_C(init_slice('h0c)),
		.INIT_D(init_slice('h0d)),
		.INIT_E(init_slice('h0e)),
		.INIT_F(init_slice('h0f)),
		.INIT_10(init_slice('h10)),
		.INIT_11(init_slice('h11)),
		.INIT_12(init_slice('h12)),
		.INIT_13(init_slice('h13)),
	) _TECHMAP_REPLACE_ (
		.WDATA(WDATA),
		.WADDR(WADDR),
		.WE(PORT_W_WR_EN),
		.WCLK(PORT_W_CLK),
		.WCLKE(1'b1),
		.RDATA(RDATA),
		.RADDR(RADDR),
		.RE(PORT_R_RD_EN),
		.RCLK(PORT_R_CLK)
	);

endmodule
`,"cells_map.v":`(* techmap_celltype = "$_DFFE_[PN][PN][01][PN]_" *)
module  \\$_DFFE_xxxx_ (input D, C, R, E, output Q);

  parameter _TECHMAP_CELLTYPE_ = "";

  EFX_FF #(
    .CLK_POLARITY(_TECHMAP_CELLTYPE_[39:32] == "P"),
    .CE_POLARITY(_TECHMAP_CELLTYPE_[15:8] == "P"),
    .SR_POLARITY(_TECHMAP_CELLTYPE_[31:24] == "P"),
    .D_POLARITY(1'b1),
    .SR_SYNC(1'b0),
    .SR_VALUE(_TECHMAP_CELLTYPE_[23:16] == "1"),
    .SR_SYNC_PRIORITY(1'b1)
  ) _TECHMAP_REPLACE_ (.D(D), .CE(E), .CLK(C), .SR(R), .Q(Q));

  wire _TECHMAP_REMOVEINIT_Q_ = 1'b1;

endmodule

(* techmap_celltype = "$_SDFFE_[PN][PN][01][PN]_" *)
module  \\$_SDFFE_xxxx_ (input D, C, R, E, output Q);

  parameter _TECHMAP_CELLTYPE_ = "";

  EFX_FF #(
    .CLK_POLARITY(_TECHMAP_CELLTYPE_[39:32] == "P"),
    .CE_POLARITY(_TECHMAP_CELLTYPE_[15:8] == "P"),
    .SR_POLARITY(_TECHMAP_CELLTYPE_[31:24] == "P"),
    .D_POLARITY(1'b1),
    .SR_SYNC(1'b1),
    .SR_VALUE(_TECHMAP_CELLTYPE_[23:16] == "1"),
    .SR_SYNC_PRIORITY(1'b1)
  ) _TECHMAP_REPLACE_ (.D(D), .CE(E), .CLK(C), .SR(R), .Q(Q));

  wire _TECHMAP_REMOVEINIT_Q_ = 1'b1;

endmodule

(* techmap_celltype = "$_SDFFCE_[PN][PN][01][PN]_" *)
module  \\$_SDFFCE_xxxx_ (input D, C, R, E, output Q);

  parameter _TECHMAP_CELLTYPE_ = "";

  EFX_FF #(
    .CLK_POLARITY(_TECHMAP_CELLTYPE_[39:32] == "P"),
    .CE_POLARITY(_TECHMAP_CELLTYPE_[15:8] == "P"),
    .SR_POLARITY(_TECHMAP_CELLTYPE_[31:24] == "P"),
    .D_POLARITY(1'b1),
    .SR_SYNC(1'b1),
    .SR_VALUE(_TECHMAP_CELLTYPE_[23:16] == "1"),
    .SR_SYNC_PRIORITY(1'b0)
  ) _TECHMAP_REPLACE_ (.D(D), .CE(E), .CLK(C), .SR(R), .Q(Q));

  wire _TECHMAP_REMOVEINIT_Q_ = 1'b1;

endmodule

module \\$_DLATCH_N_ (E, D, Q);
  wire [1023:0] _TECHMAP_DO_ = "simplemap; opt";
  input E, D;
  output Q = !E ? D : Q;
endmodule

module \\$_DLATCH_P_ (E, D, Q);
  wire [1023:0] _TECHMAP_DO_ = "simplemap; opt";
  input E, D;
  output Q = E ? D : Q;
endmodule

\`ifndef NO_LUT
module \\$lut (A, Y);
  parameter WIDTH = 0;
  parameter LUT = 0;

  (* force_downto *)
  input [WIDTH-1:0] A;
  output Y;

  generate
    if (WIDTH == 1) begin
      EFX_LUT4 #(.LUTMASK(LUT)) _TECHMAP_REPLACE_ (.O(Y), .I0(A[0]), .I1(1'b0), .I2(1'b0), .I3(1'b0));
    end else
    if (WIDTH == 2) begin
      EFX_LUT4 #(.LUTMASK(LUT)) _TECHMAP_REPLACE_ (.O(Y), .I0(A[0]), .I1(A[1]), .I2(1'b0), .I3(1'b0));
    end else
    if (WIDTH == 3) begin
      EFX_LUT4 #(.LUTMASK(LUT)) _TECHMAP_REPLACE_ (.O(Y), .I0(A[0]), .I1(A[1]), .I2(A[2]), .I3(1'b0));
    end else
    if (WIDTH == 4) begin
      EFX_LUT4 #(.LUTMASK(LUT)) _TECHMAP_REPLACE_ (.O(Y), .I0(A[0]), .I1(A[1]), .I2(A[2]), .I3(A[3]));
    end else begin
      wire _TECHMAP_FAIL_ = 1;
    end
  endgenerate
endmodule
\`endif
`,"cells_sim.v":`module EFX_LUT4(
   output O, 
   input I0,
   input I1,
   input I2,
   input I3
);
	parameter LUTMASK = 16'h0000;

	wire [7:0] s3 = I3 ? LUTMASK[15:8] : LUTMASK[7:0];
	wire [3:0] s2 = I2 ?      s3[ 7:4] :      s3[3:0];
	wire [1:0] s1 = I1 ?      s2[ 3:2] :      s2[1:0];
	assign O = I0 ? s1[1] : s1[0];	   
endmodule

module EFX_ADD(
   output O,
   output CO,
   input I0,
   input I1,
   input CI
);
   parameter I0_POLARITY   = 1;
   parameter I1_POLARITY   = 1;

   wire i0;
   wire i1;

   assign i0 = I0_POLARITY ? I0 : ~I0;
   assign i1 = I1_POLARITY ? I1 : ~I1;

   assign {CO, O} = i0 + i1 + CI;
endmodule

module EFX_FF(
   output reg Q,
   input D,
   input CE,
   (* clkbuf_sink *)
   input CLK,
   input SR
);
   parameter CLK_POLARITY = 1;
   parameter CE_POLARITY = 1;
   parameter SR_POLARITY = 1;
   parameter SR_SYNC = 0;
   parameter SR_VALUE = 0;
   parameter SR_SYNC_PRIORITY = 0;
   parameter D_POLARITY = 1;

   wire clk;
   wire ce;
   wire sr;
   wire d;
   wire prio;
   wire sync;
   wire async;

   assign clk = CLK_POLARITY ? CLK : ~CLK;
   assign ce = CE_POLARITY ? CE : ~CE;
   assign sr = SR_POLARITY ? SR : ~SR;
   assign d = D_POLARITY ? D : ~D;

	initial Q = 1'b0;

   generate
   	if (SR_SYNC == 1) 
      begin
         if (SR_SYNC_PRIORITY == 1) 
         begin
            always @(posedge clk)
               if (sr)
                  Q <= SR_VALUE;
               else if (ce)
                  Q <= d;
         end
         else
         begin
            always @(posedge clk)
               if (ce)
               begin
                  if (sr)
                     Q <= SR_VALUE;
                  else
                     Q <= d;
               end
         end
      end
      else
      begin
         always @(posedge clk or posedge sr)
            if (sr)
               Q <= SR_VALUE;
            else if (ce)
               Q <= d;
         
      end
   endgenerate
endmodule

module EFX_GBUFCE(
   input CE,
   input I,
   (* clkbuf_driver *)
   output O
);
   parameter CE_POLARITY = 1'b1;

   wire ce;
   assign ce = CE_POLARITY ? CE : ~CE;
   
   assign O = I & ce;
   
endmodule

module EFX_RAM_5K
# (
   parameter READ_WIDTH = 20,
   parameter WRITE_WIDTH = 20,
   localparam READ_ADDR_WIDTH = 
			    (READ_WIDTH == 16) ? 8 :  // 256x16
			    (READ_WIDTH == 8)  ? 9 :  // 512x8
			    (READ_WIDTH == 4)  ? 10 : // 1024x4
			    (READ_WIDTH == 2)  ? 11 : // 2048x2
			    (READ_WIDTH == 1)  ? 12 : // 4096x1
			    (READ_WIDTH == 20) ? 8 :  // 256x20
			    (READ_WIDTH == 10) ? 9 :  // 512x10
			    (READ_WIDTH == 5)  ? 10 : -1, // 1024x5
   
   localparam WRITE_ADDR_WIDTH = 
			    (WRITE_WIDTH == 16) ? 8 :  // 256x16
			    (WRITE_WIDTH == 8)  ? 9 :  // 512x8
			    (WRITE_WIDTH == 4)  ? 10 : // 1024x4
			    (WRITE_WIDTH == 2)  ? 11 : // 2048x2
			    (WRITE_WIDTH == 1)  ? 12 : // 4096x1
			    (WRITE_WIDTH == 20) ? 8 :  // 256x20
			    (WRITE_WIDTH == 10) ? 9 :  // 512x10
			    (WRITE_WIDTH == 5)  ? 10 : -1 // 1024x5
)
(
   input [WRITE_WIDTH-1:0] WDATA,
   input [WRITE_ADDR_WIDTH-1:0] WADDR,
   input WE, 
   (* clkbuf_sink *)
   input WCLK,
   input WCLKE, 
   output [READ_WIDTH-1:0] RDATA, 
   input [READ_ADDR_WIDTH-1:0] RADDR,
   input RE, 
   (* clkbuf_sink *)
   input RCLK
);
   parameter OUTPUT_REG = 1'b0;
   parameter RCLK_POLARITY  = 1'b1;
   parameter RE_POLARITY    = 1'b1;
   parameter WCLK_POLARITY  = 1'b1;
   parameter WE_POLARITY    = 1'b1;
   parameter WCLKE_POLARITY = 1'b1;
   parameter WRITE_MODE = "READ_FIRST";
   parameter INIT_0 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
   parameter INIT_1 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
   parameter INIT_2 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
   parameter INIT_3 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
   parameter INIT_4 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
   parameter INIT_5 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
   parameter INIT_6 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
   parameter INIT_7 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
   parameter INIT_8 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
   parameter INIT_9 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
   parameter INIT_A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
   parameter INIT_B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
   parameter INIT_C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
   parameter INIT_D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
   parameter INIT_E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
   parameter INIT_F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
   parameter INIT_10 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
   parameter INIT_11 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
   parameter INIT_12 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
   parameter INIT_13 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
endmodule
`,"gbuf_map.v":`module \\$__EFX_GBUF (input I, output O);
  EFX_GBUFCE #(.CE_POLARITY(1'b1)) _TECHMAP_REPLACE_ (.I(I), .O(O), .CE(1'b1));
endmodule
`},fabulous:{"arith_map.v":`\`default_nettype none

\`ifdef ARITH_ha
(* techmap_celltype = "$alu" *)
module _80_fabulous_ha_alu (A, B, CI, BI, X, Y, CO);

parameter A_SIGNED = 0;
parameter B_SIGNED = 0;
parameter A_WIDTH = 1;
parameter B_WIDTH = 1;
parameter Y_WIDTH = 1;

parameter _TECHMAP_CONSTMSK_CI_ = 0;
parameter _TECHMAP_CONSTVAL_CI_ = 0;

(* force_downto *)
input [A_WIDTH-1:0] A;
(* force_downto *)
input [B_WIDTH-1:0] B;
input CI, BI;
(* force_downto *)
output [Y_WIDTH-1:0] X, Y, CO;

(* force_downto *)
wire [Y_WIDTH-1:0] A_buf, B_buf;
\\$pos #(.A_SIGNED(A_SIGNED), .A_WIDTH(A_WIDTH), .Y_WIDTH(Y_WIDTH)) A_conv (.A(A), .Y(A_buf));
\\$pos #(.A_SIGNED(B_SIGNED), .A_WIDTH(B_WIDTH), .Y_WIDTH(Y_WIDTH)) B_conv (.A(B), .Y(B_buf));

(* force_downto *)
wire [Y_WIDTH-1:0] AA = A_buf;
(* force_downto *)
wire [Y_WIDTH-1:0] BB = BI ? ~B_buf : B_buf;
wire [Y_WIDTH:0] CARRY;


LUT4_HA #(
	.INIT(16'b0),
	.I0MUX(1'b1)
) carry_statrt (
	.I0(), .I1(CI), .I2(CI), .I3(),
	.Ci(),
	.Co(CARRY[0])
);

// Carry chain
genvar i;
generate for (i = 0; i < Y_WIDTH; i = i + 1) begin:slice
	LUT4_HA #(
		.INIT(16'b1001_0110_1001_0110), // full adder sum over (I2, I1, I0)
		.I0MUX(1'b1)
	) lut_i (
		.I0(), .I1(AA[i]), .I2(BB[i]), .I3(),
		.Ci(CARRY[i]),
		.O(Y[i]),
		.Co(CARRY[i+1])
	);

	assign CO[i] = (AA[i] && BB[i]) || ((Y[i] ^ AA[i] ^ BB[i]) && (AA[i] || BB[i]));
end endgenerate

assign X = AA ^ BB;

endmodule
\`endif

`,"cells_map.v":`module \\$lut (A, Y);
  parameter WIDTH = 0;
  parameter LUT = 0;

  input [WIDTH-1:0] A;
  output Y;

  generate
    if (WIDTH == 1) begin
      LUT1 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.O(Y), .I0(A[0]));

    end else
    if (WIDTH == 2) begin
      LUT2 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.O(Y), .I0(A[0]), .I1(A[1]));

    end else
    if (WIDTH == 3) begin
      LUT3 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.O(Y), .I0(A[0]), .I1(A[1]), .I2(A[2]));
    end else
    if (WIDTH == 4) begin
      LUT4 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.O(Y), .I0(A[0]), .I1(A[1]), .I2(A[2]), .I3(A[3]));
    end else
    if (WIDTH == 5) begin
      LUT5 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.O(Y), .I0(A[0]), .I1(A[1]), .I2(A[2]), .I3(A[3]), .I4(A[4]));
    end else
    if (WIDTH == 6) begin
      LUT6 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.O(Y), .I0(A[0]), .I1(A[1]), .I2(A[2]), .I3(A[3]), .I4(A[4]), .I5(A[5]));
    end else begin
      wire _TECHMAP_FAIL_ = 1;
    end
  endgenerate
endmodule

module  \\$_DFF_P_ (input D, C, output Q); LUTFF _TECHMAP_REPLACE_ (.D(D), .O(Q), .CLK(C)); endmodule
`,"ff_map.v":`module  \\$_DFF_P_ (input D, C, output Q); LUTFF _TECHMAP_REPLACE_ (.D(D), .O(Q), .CLK(C)); endmodule

module  \\$_DFFE_PP_ (input D, C, E, output Q); LUTFF_E  _TECHMAP_REPLACE_ (.D(D), .O(Q), .CLK(C), .E(E)); endmodule

module  \\$_SDFF_PP0_ (input D, C, R, output Q); LUTFF_SR  _TECHMAP_REPLACE_ (.D(D), .O(Q), .CLK(C), .R(R)); endmodule
module  \\$_SDFF_PP1_ (input D, C, R, output Q); LUTFF_SS  _TECHMAP_REPLACE_ (.D(D), .O(Q), .CLK(C), .S(R)); endmodule

module  \\$_SDFFCE_PP0P_ (input D, C, E, R, output Q); LUTFF_ESR  _TECHMAP_REPLACE_ (.D(D), .O(Q), .CLK(C), .E(E), .R(R)); endmodule
module  \\$_SDFFCE_PP1P_ (input D, C, E, R, output Q); LUTFF_ESS  _TECHMAP_REPLACE_ (.D(D), .O(Q), .CLK(C), .E(E), .S(R)); endmodule
`,"io_map.v":`module \\$__FABULOUS_IBUF (input PAD, output O);
	IO_1_bidirectional_frame_config_pass _TECHMAP_REPLACE_ (.PAD(PAD), .O(O), .T(1'b1));
endmodule

module \\$__FABULOUS_OBUF (output PAD, input I);
	IO_1_bidirectional_frame_config_pass _TECHMAP_REPLACE_ (.PAD(PAD), .I(I), .T(1'b0));
endmodule

`,"latches_map.v":`module \\$_DLATCH_N_ (E, D, Q);
  wire [1023:0] _TECHMAP_DO_ = "simplemap; opt";
  input E, D;
  output Q = !E ? D : Q;
endmodule

module \\$_DLATCH_P_ (E, D, Q);
  wire [1023:0] _TECHMAP_DO_ = "simplemap; opt";
  input E, D;
  output Q = E ? D : Q;
endmodule
`,"prims.v":`module LUT1(output O, input I0);
  parameter [1:0] INIT = 0;
  assign O = I0 ? INIT[1] : INIT[0];
endmodule

module LUT2(output O, input I0, I1);
  parameter [3:0] INIT = 0;
  wire [ 1: 0] s1 = I1 ? INIT[ 3: 2] : INIT[ 1: 0];
  assign O = I0 ? s1[1] : s1[0];
endmodule

module LUT3(output O, input I0, I1, I2);
  parameter [7:0] INIT = 0;
  wire [ 3: 0] s2 = I2 ? INIT[ 7: 4] : INIT[ 3: 0];
  wire [ 1: 0] s1 = I1 ?   s2[ 3: 2] :   s2[ 1: 0];
  assign O = I0 ? s1[1] : s1[0];
endmodule

module LUT4(output O, input I0, I1, I2, I3);
  parameter [15:0] INIT = 0;
  wire [ 7: 0] s3 = I3 ? INIT[15: 8] : INIT[ 7: 0];
  wire [ 3: 0] s2 = I2 ?   s3[ 7: 4] :   s3[ 3: 0];
  wire [ 1: 0] s1 = I1 ?   s2[ 3: 2] :   s2[ 1: 0];
  assign O = I0 ? s1[1] : s1[0];
endmodule

module LUT4_HA(output O, Co, input I0, I1, I2, I3, Ci);
  parameter [15:0] INIT = 0;
  parameter I0MUX = 1'b1;

  wire [ 7: 0] s3 = I3 ? INIT[15: 8] : INIT[ 7: 0];
  wire [ 3: 0] s2 = I2 ?   s3[ 7: 4] :   s3[ 3: 0];
  wire [ 1: 0] s1 = I1 ?   s2[ 3: 2] :   s2[ 1: 0];

  wire I0_sel = I0MUX ? Ci : I0;
  assign O = I0_sel ? s1[1] : s1[0];

  assign Co = (Ci & I1) | (Ci & I2) | (I1 & I2);
endmodule

module LUT5(output O, input I0, I1, I2, I3, I4);
  parameter [31:0] INIT = 0;
  wire [15: 0] s4 = I4 ? INIT[31:16] : INIT[15: 0];
  wire [ 7: 0] s3 = I3 ?   s4[15: 8] :   s4[ 7: 0];
  wire [ 3: 0] s2 = I2 ?   s3[ 7: 4] :   s3[ 3: 0];
  wire [ 1: 0] s1 = I1 ?   s2[ 3: 2] :   s2[ 1: 0];
  assign O = I0 ? s1[1] : s1[0];
endmodule

module LUT6(output O, input I0, I1, I2, I3, I4, I5);
  parameter [63:0] INIT = 0;
  wire [31: 0] s5 = I5 ? INIT[63:32] : INIT[31: 0];
  wire [15: 0] s4 = I4 ?   s5[31:16] :   s5[15: 0];
  wire [ 7: 0] s3 = I3 ?   s4[15: 8] :   s4[ 7: 0];
  wire [ 3: 0] s2 = I2 ?   s3[ 7: 4] :   s3[ 3: 0];
  wire [ 1: 0] s1 = I1 ?   s2[ 3: 2] :   s2[ 1: 0];
  assign O = I0 ? s1[1] : s1[0];
endmodule

module LUT55_FCY (output O, Co, input I0, I1, I2, I3, I4, Ci);
  parameter [63:0] INIT = 0;

  wire comb1, comb2;

  LUT5 #(.INIT(INIT[31: 0])) l5_1 (.I0(I0), .I1(I1), .I2(I2), .I3(I3), .I4(I4), .O(comb1));
  LUT5 #(.INIT(INIT[63:32])) l5_2 (.I0(I0), .I1(I1), .I2(I2), .I3(I3), .I4(I4), .O(comb2));

  assign O = comb1 ^ Ci;
  assign Co = comb1 ? Ci : comb2;
endmodule


module LUTFF(input CLK, D, output reg O);
  initial O = 1'b0;
  always @ (posedge CLK) begin
    O <= D;
  end
endmodule

module FABULOUS_MUX2(input I0, I1, S0, output O);
  assign O = S0 ? I1 : I0;
endmodule

module FABULOUS_MUX4(input I0, I1, I2, I3, S0, S1, output O);
  wire A0 = S0 ? I1 : I0;
  wire A1 = S0 ? I3 : I2;
  assign O = S1 ? A1 : A0;
endmodule

module FABULOUS_MUX8(input I0, I1, I2, I3, I4, I5, I6, I7, S0, S1, S2, output O);
  wire A0 = S0 ? I1 : I0;
  wire A1 = S0 ? I3 : I2;
  wire A2 = S0 ? I5 : I4;
  wire A3 = S0 ? I7 : I6;
  wire B0 = S1 ? A1 : A0;
  wire B1 = S1 ? A3 : A2;
  assign O = S2 ? B1 : B0;
endmodule

module FABULOUS_LC #(
  parameter K = 4,
  parameter [2**K-1:0] INIT = 0,
  parameter DFF_ENABLE = 1'b0
) (
  input CLK,
  input [K-1:0] I,
  output O,
  output Q
);
  wire f_wire;
  
  //LUT #(.K(K), .INIT(INIT)) lut_i(.I(I), .Q(f_wire));
  generate
    if (K == 1) begin
      LUT1 #(.INIT(INIT)) lut1 (.O(f_wire), .I0(I[0]));
    end else
    if (K == 2) begin
      LUT2 #(.INIT(INIT)) lut2 (.O(f_wire), .I0(I[0]), .I1(I[1]));
    end else
    if (K == 3) begin
      LUT3 #(.INIT(INIT)) lut3 (.O(f_wire), .I0(I[0]), .I1(I[1]), .I2(I[2]));
    end else
    if (K == 4) begin
      LUT4 #(.INIT(INIT)) lut4 (.O(f_wire), .I0(I[0]), .I1(I[1]), .I2(I[2]), .I3(I[3]));
    end
  endgenerate
        
  LUTFF dff_i(.CLK(CLK), .D(f_wire), .Q(Q));

  assign O = f_wire;
endmodule

(* blackbox *)
module Global_Clock (output CLK);
\`ifndef SYNTHESIS
  initial CLK = 0;
  always #10 CLK = ~CLK;
\`endif
endmodule

(* blackbox, keep *)
module InPass4_frame_config (input CLK, output O0, O1, O2, O3);

endmodule


(* blackbox, keep *)
module OutPass4_frame_config (input CLK, I0, I1, I2, I3);

endmodule

(* keep *)
module IO_1_bidirectional_frame_config_pass (input CLK, T, I, output Q, O, (* iopad_external_pin *) inout PAD);
  assign PAD = T ? 1'bz : I;
  assign O = PAD;
  reg Q_q;
  always @(posedge CLK) Q_q <= O;
  assign Q = Q_q;
endmodule


module MULADD (A7, A6, A5, A4, A3, A2, A1, A0, B7, B6, B5, B4, B3, B2, B1, B0, C19, C18, C17, C16, C15, C14, C13, C12, C11, C10, C9, C8, C7, C6, C5, C4, C3, C2, C1, C0, Q19, Q18, Q17, Q16, Q15, Q14, Q13, Q12, Q11, Q10, Q9, Q8, Q7, Q6, Q5, Q4, Q3, Q2, Q1, Q0, clr, CLK);
  parameter A_reg = 1'b0;
  parameter B_reg = 1'b0;
  parameter C_reg = 1'b0;
  parameter ACC = 1'b0;
  parameter signExtension = 1'b0;
  parameter ACCout = 1'b0;

  //parameter NoConfigBits = 6;// has to be adjusted manually (we don't use an arithmetic parser for the value)
  // IMPORTANT: this has to be in a dedicated line
  input A7;// operand A
  input A6;
  input A5;
  input A4;
  input A3;
  input A2;
  input A1;
  input A0;
  input B7;// operand B
  input B6;
  input B5;
  input B4;
  input B3;
  input B2;
  input B1;
  input B0;
  input C19;// operand C
  input C18;
  input C17;
  input C16;
  input C15;
  input C14;
  input C13;
  input C12;
  input C11;
  input C10;
  input C9;
  input C8;
  input C7;
  input C6;
  input C5;
  input C4;
  input C3;
  input C2;
  input C1;
  input C0;
  output Q19;// result
  output Q18;
  output Q17;
  output Q16;
  output Q15;
  output Q14;
  output Q13;
  output Q12;
  output Q11;
  output Q10;
  output Q9;
  output Q8;
  output Q7;
  output Q6;
  output Q5;
  output Q4;
  output Q3;
  output Q2;
  output Q1;
  output Q0;

  input clr;
  input CLK; // EXTERNAL // SHARED_PORT // ## the EXTERNAL keyword will send this sisgnal all the way to top and the //SHARED Allows multiple BELs using the same port (e.g. for exporting a clock to the top)
  // GLOBAL all primitive pins that are connected to the switch matrix have to go before the GLOBAL label


  wire [7:0] A;   // port A read data 
  wire [7:0] B;   // port B read data 
  wire [19:0] C;    // port B read data 
  reg [7:0] A_q;    // port A read data register
  reg [7:0] B_q;    // port B read data register
  reg [19:0] C_q;   // port B read data register
  wire [7:0] OPA;   // port A 
  wire [7:0] OPB;   // port B 
  wire [19:0] OPC;    // port B  
  reg [19:0] ACC_data ;    // accumulator register
  wire [19:0] sum;// port B read data register
  wire [19:0] sum_in;// port B read data register
  wire [15:0] product;
  wire [19:0] product_extended;

  assign A = {A7,A6,A5,A4,A3,A2,A1,A0};
  assign B = {B7,B6,B5,B4,B3,B2,B1,B0};
  assign C = {C19,C18,C17,C16,C15,C14,C13,C12,C11,C10,C9,C8,C7,C6,C5,C4,C3,C2,C1,C0};

  assign OPA = A_reg ? A_q : A;
  assign OPB = B_reg ? B_q : B;
  assign OPC = C_reg ? C_q : C;

  assign sum_in = ACC ? ACC_data : OPC;// we can

  assign product = OPA * OPB;

// The sign extension was not tested
  assign product_extended = signExtension ? {product[15],product[15],product[15],product[15],product} : {4'b0000,product};

  assign sum = product_extended + sum_in;

  assign Q19  = ACCout ? ACC_data[19] : sum[19];
  assign Q18  = ACCout ? ACC_data[18] : sum[18];
  assign Q17  = ACCout ? ACC_data[17] : sum[17];
  assign Q16  = ACCout ? ACC_data[16] : sum[16];
  assign Q15  = ACCout ? ACC_data[15] : sum[15];
  assign Q14  = ACCout ? ACC_data[14] : sum[14];
  assign Q13  = ACCout ? ACC_data[13] : sum[13];
  assign Q12  = ACCout ? ACC_data[12] : sum[12];
  assign Q11  = ACCout ? ACC_data[11] : sum[11];
  assign Q10  = ACCout ? ACC_data[10] : sum[10];
  assign Q9 = ACCout ? ACC_data[9] : sum[9];
  assign Q8 = ACCout ? ACC_data[8] : sum[8];
  assign Q7 = ACCout ? ACC_data[7] : sum[7];
  assign Q6 = ACCout ? ACC_data[6] : sum[6];
  assign Q5 = ACCout ? ACC_data[5] : sum[5];
  assign Q4 = ACCout ? ACC_data[4] : sum[4];
  assign Q3 = ACCout ? ACC_data[3] : sum[3];
  assign Q2 = ACCout ? ACC_data[2] : sum[2];
  assign Q1 = ACCout ? ACC_data[1] : sum[1];
  assign Q0 = ACCout ? ACC_data[0] : sum[0];

  always @ (posedge CLK)
  begin
    A_q <= A;
    B_q <= B;
    C_q <= C;
    if (clr == 1'b1) begin
      ACC_data <= 20'b00000000000000000000;
    end else begin
      ACC_data <= sum;
    end
  end

endmodule

module RegFile_32x4 (D0, D1, D2, D3, W_ADR0, W_ADR1, W_ADR2, W_ADR3, W_ADR4, W_en, AD0, AD1, AD2, AD3, A_ADR0, A_ADR1, A_ADR2, A_ADR3, A_ADR4, BD0, BD1, BD2, BD3, B_ADR0, B_ADR1, B_ADR2, B_ADR3, B_ADR4, CLK);
  //parameter NoConfigBits = 2;// has to be adjusted manually (we don't use an arithmetic parser for the value)
  parameter AD_reg = 1'b0;
  parameter BD_reg = 1'b0;
  // IMPORTANT: this has to be in a dedicated line
  input D0; // Register File write port
  input D1;
  input D2;
  input D3;
  input W_ADR0;
  input W_ADR1;
  input W_ADR2;
  input W_ADR3;
  input W_ADR4;
  input W_en;
  
  output AD0;// Register File read port A
  output AD1;
  output AD2;
  output AD3;
  input A_ADR0;
  input A_ADR1;
  input A_ADR2;
  input A_ADR3;
  input A_ADR4;

  output BD0;//Register File read port B
  output BD1;
  output BD2;
  output BD3;
  input B_ADR0;
  input B_ADR1;
  input B_ADR2;
  input B_ADR3;
  input B_ADR4;

  input CLK;// EXTERNAL // SHARED_PORT // ## the EXTERNAL keyword will send this sisgnal all the way to top and the //SHARED Allows multiple BELs using the same port (e.g. for exporting a clock to the top)
  
  // GLOBAL all primitive pins that are connected to the switch matrix have to go before the GLOBAL label
  

  //type memtype is array (31 downto 0) of std_logic_vector(3 downto 0); // 32 entries of 4 bit
  //signal mem : memtype := (others => (others => '0'));
  reg [3:0] mem [31:0];

  wire [4:0] W_ADR;// write address
  wire [4:0] A_ADR;// port A read address
  wire [4:0] B_ADR;// port B read address

  wire [3:0] D;   // write data
  wire [3:0] AD;    // port A read data
  wire [3:0] BD;    // port B read data

  reg [3:0] AD_q;   // port A read data register
  reg [3:0] BD_q;   // port B read data register
  
  integer i;

  assign W_ADR = {W_ADR4,W_ADR3,W_ADR2,W_ADR1,W_ADR0};
  assign A_ADR = {A_ADR4,A_ADR3,A_ADR2,A_ADR1,A_ADR0};
  assign B_ADR = {B_ADR4,B_ADR3,B_ADR2,B_ADR1,B_ADR0};

  assign D = {D3,D2,D1,D0};
  
  initial begin
    for (i=0; i<32; i=i+1) begin
      mem[i] = 4'b0000;
    end
  end

  always @ (posedge CLK) begin : P_write
    if (W_en == 1'b1) begin
      mem[W_ADR] <= D ;
    end
  end

  assign AD = mem[A_ADR];
  assign BD = mem[B_ADR];

  always @ (posedge CLK) begin
    AD_q <= AD;
    BD_q <= BD;
  end

  assign AD0 = AD_reg ? AD_q[0] : AD[0];
  assign AD1 = AD_reg ? AD_q[1] : AD[1];
  assign AD2 = AD_reg ? AD_q[2] : AD[2];
  assign AD3 = AD_reg ? AD_q[3] : AD[3];

  assign BD0 = BD_reg ? BD_q[0] : BD[0];
  assign BD1 = BD_reg ? BD_q[1] : BD[1];
  assign BD2 = BD_reg ? BD_q[2] : BD[2];
  assign BD3 = BD_reg ? BD_q[3] : BD[3];

endmodule

\`ifdef EQUIV
\`define COMPLEX_DFF
\`endif

\`ifdef COMPLEX_DFF
module LUTFF_E (
  output reg O,
  input CLK, E, D
);
  initial O = 1'b0;
  always @(posedge CLK)
    if (E)
      O <= D;
endmodule

module LUTFF_SR (
  output reg O,
  input CLK, R, D
);
  initial O = 1'b0;
  always @(posedge CLK)
    if (R)
      O <= 0;
    else
      O <= D;
endmodule

module LUTFF_SS (
  output reg O,
  input CLK, S, D
);
  initial O = 1'b0;
  always @(posedge CLK)
    if (S)
      O <= 1;
    else
      O <= D;
endmodule

module LUTFF_ESR (
  output reg O,
  input CLK, E, R, D
);
  initial O = 1'b0;
  always @(posedge CLK)
    if (E) begin
      if (R)
        O <= 0;
      else
        O <= D;
    end
endmodule

module LUTFF_ESS (
  output reg O,
  input CLK, E, S, D
);
  initial O = 1'b0;
  always @(posedge CLK)
    if (E) begin
      if (S)
        O <= 1;
      else
        O <= D;
    end
endmodule
\`endif // COMPLEX_DFF
`,"ram_regfile.txt":`# Yosys doesn't support configurable sync/async ports.
# So we define three RAMs for 2xasync, 1xsync 1xasync and 2xsync

ram distributed $__REGFILE_AA_ {
    abits 5;
    width 4;
    cost 6;
    port sw "W" {
        clock posedge "CLK";
    }
    port ar "A" {
    }
    port ar "B" {
    }
}

ram distributed $__REGFILE_SA_ {
    abits 5;
    width 4;
    cost 5;
    port sw "W" {
        clock posedge "CLK";
        wrtrans all old;
    }
    port sr "A" {
        clock posedge "CLK";
    }
    port ar "B" {
    }
}

ram distributed $__REGFILE_SS_ {
    abits 5;
    width 4;
    cost 4;
    port sw "W" {
        clock posedge "CLK";
        wrtrans all old;
    }
    port sr "A" {
        clock posedge "CLK";
    }
    port sr "B" {
        clock posedge "CLK";
    }
}
`,"regfile_map.v":`(* techmap_celltype = "$__REGFILE_[AS][AS]_" *)
module \\$__REGFILE_XX_ (...);

parameter _TECHMAP_CELLTYPE_ = "";
localparam [0:0] B_SYNC = _TECHMAP_CELLTYPE_[15:8] == "S";
localparam [0:0] A_SYNC = _TECHMAP_CELLTYPE_[23:16] == "S";

localparam WIDTH = 4;
localparam ABITS = 5;

input [WIDTH-1:0] PORT_W_WR_DATA;
input [ABITS-1:0] PORT_W_ADDR;
input PORT_W_WR_EN;

output [WIDTH-1:0] PORT_A_RD_DATA;
input [ABITS-1:0] PORT_A_ADDR;

output [WIDTH-1:0] PORT_B_RD_DATA;
input [ABITS-1:0] PORT_B_ADDR;

// Unused - we have a shared clock - but keep techmap happy
input PORT_W_CLK;
input PORT_A_CLK;
input PORT_B_CLK;

input CLK_CLK;

RegFile_32x4 #(
	.AD_reg(A_SYNC),
	.BD_reg(B_SYNC)
) _TECHMAP_REPLACE_ (
	.D0(PORT_W_WR_DATA[0]), .D1(PORT_W_WR_DATA[1]), .D2(PORT_W_WR_DATA[2]), .D3(PORT_W_WR_DATA[3]),
	.W_ADR0(PORT_W_ADDR[0]), .W_ADR1(PORT_W_ADDR[1]), .W_ADR2(PORT_W_ADDR[2]), .W_ADR3(PORT_W_ADDR[3]), .W_ADR4(PORT_W_ADDR[4]),
	.W_en(PORT_W_WR_EN),
	.AD0(PORT_A_RD_DATA[0]), .AD1(PORT_A_RD_DATA[1]), .AD2(PORT_A_RD_DATA[2]), .AD3(PORT_A_RD_DATA[3]),
	.A_ADR0(PORT_A_ADDR[0]), .A_ADR1(PORT_A_ADDR[1]), .A_ADR2(PORT_A_ADDR[2]), .A_ADR3(PORT_A_ADDR[3]), .A_ADR4(PORT_A_ADDR[4]),
	.BD0(PORT_B_RD_DATA[0]), .BD1(PORT_B_RD_DATA[1]), .BD2(PORT_B_RD_DATA[2]), .BD3(PORT_B_RD_DATA[3]),
	.B_ADR0(PORT_B_ADDR[0]), .B_ADR1(PORT_B_ADDR[1]), .B_ADR2(PORT_B_ADDR[2]), .B_ADR3(PORT_B_ADDR[3]), .B_ADR4(PORT_B_ADDR[4]),
	.CLK(CLK_CLK)
);

endmodule
`},"gate2lut.v":`(* techmap_celltype = "$_NOT_" *)
module _90_lut_not (A, Y);
    input A;
    output Y;

    wire [\`LUT_WIDTH-1:0] AA;
    assign AA = {A};

    \\$lut #(
        .WIDTH(\`LUT_WIDTH),
        .LUT(4'b01)
    ) lut (
        .A(AA),
        .Y(Y)
    );
endmodule

(* techmap_celltype = "$_OR_" *)
module _90_lut_or (A, B, Y);
    input A, B;
    output Y;

    wire [\`LUT_WIDTH-1:0] AA;
    assign AA = {B, A};

    \\$lut #(
        .WIDTH(\`LUT_WIDTH),
        .LUT(4'b1110)
    ) lut (
        .A(AA),
        .Y(Y)
    );
endmodule

(* techmap_celltype = "$_AND_" *)
module _90_lut_and (A, B, Y);
    input A, B;
    output Y;

    wire [\`LUT_WIDTH-1:0] AA;
    assign AA = {B, A};

    \\$lut #(
        .WIDTH(\`LUT_WIDTH),
        .LUT(4'b1000)
    ) lut (
        .A(AA),
        .Y(Y)
    );
endmodule

(* techmap_celltype = "$_XOR_" *)
module _90_lut_xor (A, B, Y);
    input A, B;
    output Y;

    wire [\`LUT_WIDTH-1:0] AA;
    assign AA = {B, A};

    \\$lut #(
        .WIDTH(\`LUT_WIDTH),
        .LUT(4'b0110)
    ) lut (
        .A(AA),
        .Y(Y)
    );
endmodule

(* techmap_celltype = "$_MUX_" *)
module _90_lut_mux (A, B, S, Y);
    input A, B, S;
    output Y;

    wire [\`LUT_WIDTH-1:0] AA;
    assign AA = {S, B, A};

    \\$lut #(
        .WIDTH(\`LUT_WIDTH),
        //     A 1010 1010
        //     B 1100 1100
        //     S 1111 0000
        .LUT(8'b 1100_1010)
    ) lut (
        .A(AA),
        .Y(Y)
    );
endmodule
`,gatemate:{"arith_map.v":`/*\r
 *  yosys -- Yosys Open SYnthesis Suite\r
 *\r
 *  Copyright (C) 2021  Cologne Chip AG <support@colognechip.com>\r
 *\r
 *  Permission to use, copy, modify, and/or distribute this software for any\r
 *  purpose with or without fee is hereby granted, provided that the above\r
 *  copyright notice and this permission notice appear in all copies.\r
 *\r
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\r
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\r
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\r
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\r
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\r
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\r
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\r
 *\r
 */\r
\r
(* techmap_celltype = "$alu" *)\r
module _80_gatemate_alu(A, B, CI, BI, X, Y, CO);\r
	parameter A_SIGNED = 0;\r
	parameter B_SIGNED = 0;\r
	parameter A_WIDTH = 1;\r
	parameter B_WIDTH = 1;\r
	parameter Y_WIDTH = 1;\r
\r
	(* force_downto *)\r
	input [A_WIDTH-1:0] A;\r
	(* force_downto *)\r
	input [B_WIDTH-1:0] B;\r
	(* force_downto *)\r
	output [Y_WIDTH-1:0] X, Y;\r
\r
	input CI, BI;\r
	(* force_downto *)\r
	output [Y_WIDTH-1:0] CO;\r
\r
	wire _TECHMAP_FAIL_ = Y_WIDTH <= 2;\r
\r
	(* force_downto *)\r
	wire [Y_WIDTH-1:0] A_buf, B_buf;\r
	\\$pos #(.A_SIGNED(A_SIGNED), .A_WIDTH(A_WIDTH), .Y_WIDTH(Y_WIDTH)) A_conv (.A(A), .Y(A_buf));\r
	\\$pos #(.A_SIGNED(B_SIGNED), .A_WIDTH(B_WIDTH), .Y_WIDTH(Y_WIDTH)) B_conv (.A(B), .Y(B_buf));\r
\r
	(* force_downto *)\r
	wire [Y_WIDTH-1:0] AA = A_buf;\r
	(* force_downto *)\r
	wire [Y_WIDTH-1:0] BB = BI ? ~B_buf : B_buf;\r
	(* force_downto *)\r
	wire [Y_WIDTH-1:0] C = {CO, CI};\r
\r
	genvar i;\r
	generate\r
		for (i = 0; i < Y_WIDTH; i = i + 1)\r
		begin: slice\r
			CC_ADDF addf_i (\r
				.A(AA[i]),\r
				.B(BB[i]),\r
				.CI(C[i]),\r
				.CO(CO[i]),\r
				.S(Y[i])\r
			);\r
		end\r
	endgenerate\r
\r
	assign X = AA ^ BB;\r
\r
endmodule\r
`,"brams.txt":`ram block $__CC_BRAM_TDP_ {
	option "MODE" "20K" {
		abits 14;
		widths 1 2 5 10 20 per_port;
		cost 129;
	}
	option "MODE" "40K" {
		abits 15;
		widths 1 2 5 10 20 40 per_port;
		cost 257;
	}
	option "MODE" "CASCADE" {
		abits 16;
		# hack to enforce same INIT layout as in the other modes
		widths 1 2 5 per_port;
		cost 513;
	}
	byte 1;
	init no_undef;
	port srsw "A" "B" {
		clock anyedge;
		clken;
		option "MODE" "20K" {
			width mix;
		}
		option "MODE" "40K" {
			width mix;
		}
		option "MODE" "CASCADE" {
			width mix 1;
		}
		portoption "WR_MODE" "NO_CHANGE" {
			rdwr no_change;
		}
		portoption "WR_MODE" "WRITE_THROUGH" {
			rdwr new;
			wrtrans all new;
		}
		wrbe_separate;
		optional_rw;
	}
}

ram block $__CC_BRAM_SDP_ {
	option "MODE" "20K" {
		abits 14;
		widths 1 2 5 10 20 40 per_port;
		cost 129;
	}
	option "MODE" "40K" {
		abits 15;
		widths 1 2 5 10 20 40 80 per_port;
		cost 257;
	}
	byte 1;
	init no_undef;
	port sr "R" {
		option "MODE" "20K" {
			width 40;
		}
		option "MODE" "40K" {
			width 80;
		}
		clock anyedge;
		clken;
		optional;
	}
	port sw "W" {
		option "MODE" "20K" {
			width 40;
		}
		option "MODE" "40K" {
			width 80;
		}
		clock anyedge;
		clken;
		wrbe_separate;
		optional;
	}
}
`,"brams_init_20.vh":`.INIT_00(permute_init(INIT[  0*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_01(permute_init(INIT[  1*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_02(permute_init(INIT[  2*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_03(permute_init(INIT[  3*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_04(permute_init(INIT[  4*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_05(permute_init(INIT[  5*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_06(permute_init(INIT[  6*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_07(permute_init(INIT[  7*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_08(permute_init(INIT[  8*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_09(permute_init(INIT[  9*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_0A(permute_init(INIT[ 10*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_0B(permute_init(INIT[ 11*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_0C(permute_init(INIT[ 12*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_0D(permute_init(INIT[ 13*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_0E(permute_init(INIT[ 14*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_0F(permute_init(INIT[ 15*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_10(permute_init(INIT[ 16*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_11(permute_init(INIT[ 17*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_12(permute_init(INIT[ 18*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_13(permute_init(INIT[ 19*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_14(permute_init(INIT[ 20*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_15(permute_init(INIT[ 21*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_16(permute_init(INIT[ 22*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_17(permute_init(INIT[ 23*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_18(permute_init(INIT[ 24*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_19(permute_init(INIT[ 25*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_1A(permute_init(INIT[ 26*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_1B(permute_init(INIT[ 27*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_1C(permute_init(INIT[ 28*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_1D(permute_init(INIT[ 29*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_1E(permute_init(INIT[ 30*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_1F(permute_init(INIT[ 31*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_20(permute_init(INIT[ 32*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_21(permute_init(INIT[ 33*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_22(permute_init(INIT[ 34*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_23(permute_init(INIT[ 35*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_24(permute_init(INIT[ 36*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_25(permute_init(INIT[ 37*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_26(permute_init(INIT[ 38*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_27(permute_init(INIT[ 39*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_28(permute_init(INIT[ 40*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_29(permute_init(INIT[ 41*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_2A(permute_init(INIT[ 42*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_2B(permute_init(INIT[ 43*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_2C(permute_init(INIT[ 44*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_2D(permute_init(INIT[ 45*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_2E(permute_init(INIT[ 46*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_2F(permute_init(INIT[ 47*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_30(permute_init(INIT[ 48*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_31(permute_init(INIT[ 49*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_32(permute_init(INIT[ 50*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_33(permute_init(INIT[ 51*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_34(permute_init(INIT[ 52*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_35(permute_init(INIT[ 53*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_36(permute_init(INIT[ 54*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_37(permute_init(INIT[ 55*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_38(permute_init(INIT[ 56*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_39(permute_init(INIT[ 57*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_3A(permute_init(INIT[ 58*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_3B(permute_init(INIT[ 59*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_3C(permute_init(INIT[ 60*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_3D(permute_init(INIT[ 61*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_3E(permute_init(INIT[ 62*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_3F(permute_init(INIT[ 63*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
`,"brams_init_40.vh":`\`ifdef INIT_LOWER
.INIT_00(permute_init(INIT[  0*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_01(permute_init(INIT[  1*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_02(permute_init(INIT[  2*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_03(permute_init(INIT[  3*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_04(permute_init(INIT[  4*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_05(permute_init(INIT[  5*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_06(permute_init(INIT[  6*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_07(permute_init(INIT[  7*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_08(permute_init(INIT[  8*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_09(permute_init(INIT[  9*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_0A(permute_init(INIT[ 10*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_0B(permute_init(INIT[ 11*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_0C(permute_init(INIT[ 12*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_0D(permute_init(INIT[ 13*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_0E(permute_init(INIT[ 14*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_0F(permute_init(INIT[ 15*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_10(permute_init(INIT[ 16*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_11(permute_init(INIT[ 17*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_12(permute_init(INIT[ 18*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_13(permute_init(INIT[ 19*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_14(permute_init(INIT[ 20*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_15(permute_init(INIT[ 21*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_16(permute_init(INIT[ 22*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_17(permute_init(INIT[ 23*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_18(permute_init(INIT[ 24*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_19(permute_init(INIT[ 25*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_1A(permute_init(INIT[ 26*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_1B(permute_init(INIT[ 27*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_1C(permute_init(INIT[ 28*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_1D(permute_init(INIT[ 29*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_1E(permute_init(INIT[ 30*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_1F(permute_init(INIT[ 31*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_20(permute_init(INIT[ 32*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_21(permute_init(INIT[ 33*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_22(permute_init(INIT[ 34*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_23(permute_init(INIT[ 35*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_24(permute_init(INIT[ 36*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_25(permute_init(INIT[ 37*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_26(permute_init(INIT[ 38*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_27(permute_init(INIT[ 39*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_28(permute_init(INIT[ 40*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_29(permute_init(INIT[ 41*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_2A(permute_init(INIT[ 42*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_2B(permute_init(INIT[ 43*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_2C(permute_init(INIT[ 44*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_2D(permute_init(INIT[ 45*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_2E(permute_init(INIT[ 46*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_2F(permute_init(INIT[ 47*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_30(permute_init(INIT[ 48*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_31(permute_init(INIT[ 49*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_32(permute_init(INIT[ 50*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_33(permute_init(INIT[ 51*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_34(permute_init(INIT[ 52*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_35(permute_init(INIT[ 53*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_36(permute_init(INIT[ 54*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_37(permute_init(INIT[ 55*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_38(permute_init(INIT[ 56*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_39(permute_init(INIT[ 57*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_3A(permute_init(INIT[ 58*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_3B(permute_init(INIT[ 59*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_3C(permute_init(INIT[ 60*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_3D(permute_init(INIT[ 61*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_3E(permute_init(INIT[ 62*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_3F(permute_init(INIT[ 63*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_40(permute_init(INIT[ 64*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_41(permute_init(INIT[ 65*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_42(permute_init(INIT[ 66*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_43(permute_init(INIT[ 67*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_44(permute_init(INIT[ 68*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_45(permute_init(INIT[ 69*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_46(permute_init(INIT[ 70*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_47(permute_init(INIT[ 71*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_48(permute_init(INIT[ 72*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_49(permute_init(INIT[ 73*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_4A(permute_init(INIT[ 74*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_4B(permute_init(INIT[ 75*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_4C(permute_init(INIT[ 76*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_4D(permute_init(INIT[ 77*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_4E(permute_init(INIT[ 78*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_4F(permute_init(INIT[ 79*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_50(permute_init(INIT[ 80*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_51(permute_init(INIT[ 81*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_52(permute_init(INIT[ 82*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_53(permute_init(INIT[ 83*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_54(permute_init(INIT[ 84*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_55(permute_init(INIT[ 85*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_56(permute_init(INIT[ 86*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_57(permute_init(INIT[ 87*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_58(permute_init(INIT[ 88*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_59(permute_init(INIT[ 89*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_5A(permute_init(INIT[ 90*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_5B(permute_init(INIT[ 91*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_5C(permute_init(INIT[ 92*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_5D(permute_init(INIT[ 93*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_5E(permute_init(INIT[ 94*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_5F(permute_init(INIT[ 95*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_60(permute_init(INIT[ 96*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_61(permute_init(INIT[ 97*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_62(permute_init(INIT[ 98*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_63(permute_init(INIT[ 99*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_64(permute_init(INIT[100*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_65(permute_init(INIT[101*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_66(permute_init(INIT[102*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_67(permute_init(INIT[103*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_68(permute_init(INIT[104*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_69(permute_init(INIT[105*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_6A(permute_init(INIT[106*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_6B(permute_init(INIT[107*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_6C(permute_init(INIT[108*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_6D(permute_init(INIT[109*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_6E(permute_init(INIT[110*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_6F(permute_init(INIT[111*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_70(permute_init(INIT[112*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_71(permute_init(INIT[113*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_72(permute_init(INIT[114*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_73(permute_init(INIT[115*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_74(permute_init(INIT[116*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_75(permute_init(INIT[117*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_76(permute_init(INIT[118*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_77(permute_init(INIT[119*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_78(permute_init(INIT[120*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_79(permute_init(INIT[121*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_7A(permute_init(INIT[122*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_7B(permute_init(INIT[123*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_7C(permute_init(INIT[124*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_7D(permute_init(INIT[125*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_7E(permute_init(INIT[126*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_7F(permute_init(INIT[127*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
\`endif
\`ifdef INIT_UPPER
.INIT_00(permute_init(INIT[128*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_01(permute_init(INIT[129*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_02(permute_init(INIT[130*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_03(permute_init(INIT[131*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_04(permute_init(INIT[132*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_05(permute_init(INIT[133*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_06(permute_init(INIT[134*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_07(permute_init(INIT[135*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_08(permute_init(INIT[136*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_09(permute_init(INIT[137*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_0A(permute_init(INIT[138*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_0B(permute_init(INIT[139*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_0C(permute_init(INIT[140*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_0D(permute_init(INIT[141*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_0E(permute_init(INIT[142*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_0F(permute_init(INIT[143*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_10(permute_init(INIT[144*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_11(permute_init(INIT[145*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_12(permute_init(INIT[146*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_13(permute_init(INIT[147*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_14(permute_init(INIT[148*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_15(permute_init(INIT[149*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_16(permute_init(INIT[150*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_17(permute_init(INIT[151*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_18(permute_init(INIT[152*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_19(permute_init(INIT[153*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_1A(permute_init(INIT[154*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_1B(permute_init(INIT[155*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_1C(permute_init(INIT[156*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_1D(permute_init(INIT[157*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_1E(permute_init(INIT[158*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_1F(permute_init(INIT[159*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_20(permute_init(INIT[160*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_21(permute_init(INIT[161*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_22(permute_init(INIT[162*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_23(permute_init(INIT[163*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_24(permute_init(INIT[164*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_25(permute_init(INIT[165*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_26(permute_init(INIT[166*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_27(permute_init(INIT[167*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_28(permute_init(INIT[168*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_29(permute_init(INIT[169*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_2A(permute_init(INIT[170*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_2B(permute_init(INIT[171*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_2C(permute_init(INIT[172*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_2D(permute_init(INIT[173*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_2E(permute_init(INIT[174*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_2F(permute_init(INIT[175*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_30(permute_init(INIT[176*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_31(permute_init(INIT[177*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_32(permute_init(INIT[178*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_33(permute_init(INIT[179*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_34(permute_init(INIT[180*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_35(permute_init(INIT[181*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_36(permute_init(INIT[182*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_37(permute_init(INIT[183*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_38(permute_init(INIT[184*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_39(permute_init(INIT[185*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_3A(permute_init(INIT[186*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_3B(permute_init(INIT[187*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_3C(permute_init(INIT[188*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_3D(permute_init(INIT[189*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_3E(permute_init(INIT[190*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_3F(permute_init(INIT[191*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_40(permute_init(INIT[192*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_41(permute_init(INIT[193*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_42(permute_init(INIT[194*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_43(permute_init(INIT[195*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_44(permute_init(INIT[196*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_45(permute_init(INIT[197*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_46(permute_init(INIT[198*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_47(permute_init(INIT[199*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_48(permute_init(INIT[200*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_49(permute_init(INIT[201*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_4A(permute_init(INIT[202*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_4B(permute_init(INIT[203*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_4C(permute_init(INIT[204*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_4D(permute_init(INIT[205*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_4E(permute_init(INIT[206*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_4F(permute_init(INIT[207*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_50(permute_init(INIT[208*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_51(permute_init(INIT[209*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_52(permute_init(INIT[210*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_53(permute_init(INIT[211*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_54(permute_init(INIT[212*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_55(permute_init(INIT[213*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_56(permute_init(INIT[214*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_57(permute_init(INIT[215*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_58(permute_init(INIT[216*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_59(permute_init(INIT[217*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_5A(permute_init(INIT[218*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_5B(permute_init(INIT[219*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_5C(permute_init(INIT[220*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_5D(permute_init(INIT[221*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_5E(permute_init(INIT[222*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_5F(permute_init(INIT[223*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_60(permute_init(INIT[224*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_61(permute_init(INIT[225*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_62(permute_init(INIT[226*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_63(permute_init(INIT[227*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_64(permute_init(INIT[228*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_65(permute_init(INIT[229*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_66(permute_init(INIT[230*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_67(permute_init(INIT[231*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_68(permute_init(INIT[232*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_69(permute_init(INIT[233*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_6A(permute_init(INIT[234*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_6B(permute_init(INIT[235*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_6C(permute_init(INIT[236*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_6D(permute_init(INIT[237*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_6E(permute_init(INIT[238*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_6F(permute_init(INIT[239*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_70(permute_init(INIT[240*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_71(permute_init(INIT[241*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_72(permute_init(INIT[242*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_73(permute_init(INIT[243*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_74(permute_init(INIT[244*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_75(permute_init(INIT[245*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_76(permute_init(INIT[246*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_77(permute_init(INIT[247*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_78(permute_init(INIT[248*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_79(permute_init(INIT[249*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_7A(permute_init(INIT[250*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_7B(permute_init(INIT[251*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_7C(permute_init(INIT[252*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_7D(permute_init(INIT[253*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_7E(permute_init(INIT[254*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
.INIT_7F(permute_init(INIT[255*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),
\`endif
`,"brams_map.v":`module $__CC_BRAM_TDP_(...);\r
\r
parameter INIT = 0;\r
parameter OPTION_MODE = "20K";\r
\r
parameter PORT_A_CLK_POL = 1;\r
parameter PORT_A_RD_USED = 1;\r
parameter PORT_A_WR_USED = 1;\r
parameter PORT_A_RD_WIDTH = 1;\r
parameter PORT_A_WR_WIDTH = 1;\r
parameter PORT_A_WR_BE_WIDTH = 1;\r
parameter PORT_A_OPTION_WR_MODE = "NO_CHANGE";\r
\r
parameter PORT_B_CLK_POL = 1;\r
parameter PORT_B_RD_USED = 1;\r
parameter PORT_B_WR_USED = 1;\r
parameter PORT_B_RD_WIDTH = 1;\r
parameter PORT_B_WR_WIDTH = 1;\r
parameter PORT_B_WR_BE_WIDTH = 1;\r
parameter PORT_B_OPTION_WR_MODE = "NO_CHANGE";\r
\r
input PORT_A_CLK;\r
input PORT_A_CLK_EN;\r
input PORT_A_WR_EN;\r
input [15:0] PORT_A_ADDR;\r
input [PORT_A_WR_BE_WIDTH-1:0] PORT_A_WR_BE;\r
input [PORT_A_WR_WIDTH-1:0] PORT_A_WR_DATA;\r
output [PORT_A_RD_WIDTH-1:0] PORT_A_RD_DATA;\r
\r
input PORT_B_CLK;\r
input PORT_B_CLK_EN;\r
input PORT_B_WR_EN;\r
input [15:0] PORT_B_ADDR;\r
input [PORT_B_WR_BE_WIDTH-1:0] PORT_B_WR_BE;\r
input [PORT_B_WR_WIDTH-1:0] PORT_B_WR_DATA;\r
output [PORT_B_RD_WIDTH-1:0] PORT_B_RD_DATA;\r
\r
generate\r
	if (OPTION_MODE == "20K") begin\r
		CC_BRAM_20K #(\r
			.INIT_00(INIT['h00*320+:320]),\r
			.INIT_01(INIT['h01*320+:320]),\r
			.INIT_02(INIT['h02*320+:320]),\r
			.INIT_03(INIT['h03*320+:320]),\r
			.INIT_04(INIT['h04*320+:320]),\r
			.INIT_05(INIT['h05*320+:320]),\r
			.INIT_06(INIT['h06*320+:320]),\r
			.INIT_07(INIT['h07*320+:320]),\r
			.INIT_08(INIT['h08*320+:320]),\r
			.INIT_09(INIT['h09*320+:320]),\r
			.INIT_0A(INIT['h0a*320+:320]),\r
			.INIT_0B(INIT['h0b*320+:320]),\r
			.INIT_0C(INIT['h0c*320+:320]),\r
			.INIT_0D(INIT['h0d*320+:320]),\r
			.INIT_0E(INIT['h0e*320+:320]),\r
			.INIT_0F(INIT['h0f*320+:320]),\r
			.INIT_10(INIT['h10*320+:320]),\r
			.INIT_11(INIT['h11*320+:320]),\r
			.INIT_12(INIT['h12*320+:320]),\r
			.INIT_13(INIT['h13*320+:320]),\r
			.INIT_14(INIT['h14*320+:320]),\r
			.INIT_15(INIT['h15*320+:320]),\r
			.INIT_16(INIT['h16*320+:320]),\r
			.INIT_17(INIT['h17*320+:320]),\r
			.INIT_18(INIT['h18*320+:320]),\r
			.INIT_19(INIT['h19*320+:320]),\r
			.INIT_1A(INIT['h1a*320+:320]),\r
			.INIT_1B(INIT['h1b*320+:320]),\r
			.INIT_1C(INIT['h1c*320+:320]),\r
			.INIT_1D(INIT['h1d*320+:320]),\r
			.INIT_1E(INIT['h1e*320+:320]),\r
			.INIT_1F(INIT['h1f*320+:320]),\r
			.INIT_20(INIT['h20*320+:320]),\r
			.INIT_21(INIT['h21*320+:320]),\r
			.INIT_22(INIT['h22*320+:320]),\r
			.INIT_23(INIT['h23*320+:320]),\r
			.INIT_24(INIT['h24*320+:320]),\r
			.INIT_25(INIT['h25*320+:320]),\r
			.INIT_26(INIT['h26*320+:320]),\r
			.INIT_27(INIT['h27*320+:320]),\r
			.INIT_28(INIT['h28*320+:320]),\r
			.INIT_29(INIT['h29*320+:320]),\r
			.INIT_2A(INIT['h2a*320+:320]),\r
			.INIT_2B(INIT['h2b*320+:320]),\r
			.INIT_2C(INIT['h2c*320+:320]),\r
			.INIT_2D(INIT['h2d*320+:320]),\r
			.INIT_2E(INIT['h2e*320+:320]),\r
			.INIT_2F(INIT['h2f*320+:320]),\r
			.INIT_30(INIT['h30*320+:320]),\r
			.INIT_31(INIT['h31*320+:320]),\r
			.INIT_32(INIT['h32*320+:320]),\r
			.INIT_33(INIT['h33*320+:320]),\r
			.INIT_34(INIT['h34*320+:320]),\r
			.INIT_35(INIT['h35*320+:320]),\r
			.INIT_36(INIT['h36*320+:320]),\r
			.INIT_37(INIT['h37*320+:320]),\r
			.INIT_38(INIT['h38*320+:320]),\r
			.INIT_39(INIT['h39*320+:320]),\r
			.INIT_3A(INIT['h3a*320+:320]),\r
			.INIT_3B(INIT['h3b*320+:320]),\r
			.INIT_3C(INIT['h3c*320+:320]),\r
			.INIT_3D(INIT['h3d*320+:320]),\r
			.INIT_3E(INIT['h3e*320+:320]),\r
			.INIT_3F(INIT['h3f*320+:320]),\r
			.A_RD_WIDTH(PORT_A_RD_USED ? PORT_A_RD_WIDTH : 0),\r
			.A_WR_WIDTH(PORT_A_WR_USED ? PORT_A_WR_WIDTH : 0),\r
			.B_RD_WIDTH(PORT_B_RD_USED ? PORT_B_RD_WIDTH : 0),\r
			.B_WR_WIDTH(PORT_B_WR_USED ? PORT_B_WR_WIDTH : 0),\r
			.RAM_MODE("TDP"),\r
			.A_WR_MODE(PORT_A_OPTION_WR_MODE),\r
			.B_WR_MODE(PORT_B_OPTION_WR_MODE),\r
			.A_CLK_INV(!PORT_A_CLK_POL),\r
			.B_CLK_INV(!PORT_B_CLK_POL),\r
		) _TECHMAP_REPLACE_ (\r
			.A_CLK(PORT_A_CLK),\r
			.A_EN(PORT_A_CLK_EN),\r
			.A_WE(PORT_A_WR_EN),\r
			.A_BM(PORT_A_WR_BE),\r
			.A_DI(PORT_A_WR_DATA),\r
			.A_ADDR({PORT_A_ADDR[13:5], 1'b0, PORT_A_ADDR[4:0], 1'b0}),\r
			.A_DO(PORT_A_RD_DATA),\r
			.B_CLK(PORT_B_CLK),\r
			.B_EN(PORT_B_CLK_EN),\r
			.B_WE(PORT_B_WR_EN),\r
			.B_BM(PORT_B_WR_BE),\r
			.B_DI(PORT_B_WR_DATA),\r
			.B_ADDR({PORT_B_ADDR[13:5], 1'b0, PORT_B_ADDR[4:0], 1'b0}),\r
			.B_DO(PORT_B_RD_DATA),\r
		);\r
	end else if (OPTION_MODE == "40K") begin\r
		CC_BRAM_40K #(\r
			.INIT_00(INIT['h00*320+:320]),\r
			.INIT_01(INIT['h01*320+:320]),\r
			.INIT_02(INIT['h02*320+:320]),\r
			.INIT_03(INIT['h03*320+:320]),\r
			.INIT_04(INIT['h04*320+:320]),\r
			.INIT_05(INIT['h05*320+:320]),\r
			.INIT_06(INIT['h06*320+:320]),\r
			.INIT_07(INIT['h07*320+:320]),\r
			.INIT_08(INIT['h08*320+:320]),\r
			.INIT_09(INIT['h09*320+:320]),\r
			.INIT_0A(INIT['h0a*320+:320]),\r
			.INIT_0B(INIT['h0b*320+:320]),\r
			.INIT_0C(INIT['h0c*320+:320]),\r
			.INIT_0D(INIT['h0d*320+:320]),\r
			.INIT_0E(INIT['h0e*320+:320]),\r
			.INIT_0F(INIT['h0f*320+:320]),\r
			.INIT_10(INIT['h10*320+:320]),\r
			.INIT_11(INIT['h11*320+:320]),\r
			.INIT_12(INIT['h12*320+:320]),\r
			.INIT_13(INIT['h13*320+:320]),\r
			.INIT_14(INIT['h14*320+:320]),\r
			.INIT_15(INIT['h15*320+:320]),\r
			.INIT_16(INIT['h16*320+:320]),\r
			.INIT_17(INIT['h17*320+:320]),\r
			.INIT_18(INIT['h18*320+:320]),\r
			.INIT_19(INIT['h19*320+:320]),\r
			.INIT_1A(INIT['h1a*320+:320]),\r
			.INIT_1B(INIT['h1b*320+:320]),\r
			.INIT_1C(INIT['h1c*320+:320]),\r
			.INIT_1D(INIT['h1d*320+:320]),\r
			.INIT_1E(INIT['h1e*320+:320]),\r
			.INIT_1F(INIT['h1f*320+:320]),\r
			.INIT_20(INIT['h20*320+:320]),\r
			.INIT_21(INIT['h21*320+:320]),\r
			.INIT_22(INIT['h22*320+:320]),\r
			.INIT_23(INIT['h23*320+:320]),\r
			.INIT_24(INIT['h24*320+:320]),\r
			.INIT_25(INIT['h25*320+:320]),\r
			.INIT_26(INIT['h26*320+:320]),\r
			.INIT_27(INIT['h27*320+:320]),\r
			.INIT_28(INIT['h28*320+:320]),\r
			.INIT_29(INIT['h29*320+:320]),\r
			.INIT_2A(INIT['h2a*320+:320]),\r
			.INIT_2B(INIT['h2b*320+:320]),\r
			.INIT_2C(INIT['h2c*320+:320]),\r
			.INIT_2D(INIT['h2d*320+:320]),\r
			.INIT_2E(INIT['h2e*320+:320]),\r
			.INIT_2F(INIT['h2f*320+:320]),\r
			.INIT_30(INIT['h30*320+:320]),\r
			.INIT_31(INIT['h31*320+:320]),\r
			.INIT_32(INIT['h32*320+:320]),\r
			.INIT_33(INIT['h33*320+:320]),\r
			.INIT_34(INIT['h34*320+:320]),\r
			.INIT_35(INIT['h35*320+:320]),\r
			.INIT_36(INIT['h36*320+:320]),\r
			.INIT_37(INIT['h37*320+:320]),\r
			.INIT_38(INIT['h38*320+:320]),\r
			.INIT_39(INIT['h39*320+:320]),\r
			.INIT_3A(INIT['h3a*320+:320]),\r
			.INIT_3B(INIT['h3b*320+:320]),\r
			.INIT_3C(INIT['h3c*320+:320]),\r
			.INIT_3D(INIT['h3d*320+:320]),\r
			.INIT_3E(INIT['h3e*320+:320]),\r
			.INIT_3F(INIT['h3f*320+:320]),\r
			.INIT_40(INIT['h40*320+:320]),\r
			.INIT_41(INIT['h41*320+:320]),\r
			.INIT_42(INIT['h42*320+:320]),\r
			.INIT_43(INIT['h43*320+:320]),\r
			.INIT_44(INIT['h44*320+:320]),\r
			.INIT_45(INIT['h45*320+:320]),\r
			.INIT_46(INIT['h46*320+:320]),\r
			.INIT_47(INIT['h47*320+:320]),\r
			.INIT_48(INIT['h48*320+:320]),\r
			.INIT_49(INIT['h49*320+:320]),\r
			.INIT_4A(INIT['h4a*320+:320]),\r
			.INIT_4B(INIT['h4b*320+:320]),\r
			.INIT_4C(INIT['h4c*320+:320]),\r
			.INIT_4D(INIT['h4d*320+:320]),\r
			.INIT_4E(INIT['h4e*320+:320]),\r
			.INIT_4F(INIT['h4f*320+:320]),\r
			.INIT_50(INIT['h50*320+:320]),\r
			.INIT_51(INIT['h51*320+:320]),\r
			.INIT_52(INIT['h52*320+:320]),\r
			.INIT_53(INIT['h53*320+:320]),\r
			.INIT_54(INIT['h54*320+:320]),\r
			.INIT_55(INIT['h55*320+:320]),\r
			.INIT_56(INIT['h56*320+:320]),\r
			.INIT_57(INIT['h57*320+:320]),\r
			.INIT_58(INIT['h58*320+:320]),\r
			.INIT_59(INIT['h59*320+:320]),\r
			.INIT_5A(INIT['h5a*320+:320]),\r
			.INIT_5B(INIT['h5b*320+:320]),\r
			.INIT_5C(INIT['h5c*320+:320]),\r
			.INIT_5D(INIT['h5d*320+:320]),\r
			.INIT_5E(INIT['h5e*320+:320]),\r
			.INIT_5F(INIT['h5f*320+:320]),\r
			.INIT_60(INIT['h60*320+:320]),\r
			.INIT_61(INIT['h61*320+:320]),\r
			.INIT_62(INIT['h62*320+:320]),\r
			.INIT_63(INIT['h63*320+:320]),\r
			.INIT_64(INIT['h64*320+:320]),\r
			.INIT_65(INIT['h65*320+:320]),\r
			.INIT_66(INIT['h66*320+:320]),\r
			.INIT_67(INIT['h67*320+:320]),\r
			.INIT_68(INIT['h68*320+:320]),\r
			.INIT_69(INIT['h69*320+:320]),\r
			.INIT_6A(INIT['h6a*320+:320]),\r
			.INIT_6B(INIT['h6b*320+:320]),\r
			.INIT_6C(INIT['h6c*320+:320]),\r
			.INIT_6D(INIT['h6d*320+:320]),\r
			.INIT_6E(INIT['h6e*320+:320]),\r
			.INIT_6F(INIT['h6f*320+:320]),\r
			.INIT_70(INIT['h70*320+:320]),\r
			.INIT_71(INIT['h71*320+:320]),\r
			.INIT_72(INIT['h72*320+:320]),\r
			.INIT_73(INIT['h73*320+:320]),\r
			.INIT_74(INIT['h74*320+:320]),\r
			.INIT_75(INIT['h75*320+:320]),\r
			.INIT_76(INIT['h76*320+:320]),\r
			.INIT_77(INIT['h77*320+:320]),\r
			.INIT_78(INIT['h78*320+:320]),\r
			.INIT_79(INIT['h79*320+:320]),\r
			.INIT_7A(INIT['h7a*320+:320]),\r
			.INIT_7B(INIT['h7b*320+:320]),\r
			.INIT_7C(INIT['h7c*320+:320]),\r
			.INIT_7D(INIT['h7d*320+:320]),\r
			.INIT_7E(INIT['h7e*320+:320]),\r
			.INIT_7F(INIT['h7f*320+:320]),\r
			.A_RD_WIDTH(PORT_A_RD_USED ? PORT_A_RD_WIDTH : 0),\r
			.A_WR_WIDTH(PORT_A_WR_USED ? PORT_A_WR_WIDTH : 0),\r
			.B_RD_WIDTH(PORT_B_RD_USED ? PORT_B_RD_WIDTH : 0),\r
			.B_WR_WIDTH(PORT_B_WR_USED ? PORT_B_WR_WIDTH : 0),\r
			.RAM_MODE("TDP"),\r
			.A_WR_MODE(PORT_A_OPTION_WR_MODE),\r
			.B_WR_MODE(PORT_B_OPTION_WR_MODE),\r
			.A_CLK_INV(!PORT_A_CLK_POL),\r
			.B_CLK_INV(!PORT_B_CLK_POL),\r
		) _TECHMAP_REPLACE_ (\r
			.A_CLK(PORT_A_CLK),\r
			.A_EN(PORT_A_CLK_EN),\r
			.A_WE(PORT_A_WR_EN),\r
			.A_BM(PORT_A_WR_BE),\r
			.A_DI(PORT_A_WR_DATA),\r
			.A_ADDR({PORT_A_ADDR[14:0], 1'b0}),\r
			.A_DO(PORT_A_RD_DATA),\r
			.B_CLK(PORT_B_CLK),\r
			.B_EN(PORT_B_CLK_EN),\r
			.B_WE(PORT_B_WR_EN),\r
			.B_BM(PORT_B_WR_BE),\r
			.B_DI(PORT_B_WR_DATA),\r
			.B_ADDR({PORT_B_ADDR[14:0], 1'b0}),\r
			.B_DO(PORT_B_RD_DATA),\r
		);\r
	end else begin\r
		wire CAS_A, CAS_B;\r
		CC_BRAM_40K #(\r
			.INIT_00(INIT['h00*320+:320]),\r
			.INIT_01(INIT['h01*320+:320]),\r
			.INIT_02(INIT['h02*320+:320]),\r
			.INIT_03(INIT['h03*320+:320]),\r
			.INIT_04(INIT['h04*320+:320]),\r
			.INIT_05(INIT['h05*320+:320]),\r
			.INIT_06(INIT['h06*320+:320]),\r
			.INIT_07(INIT['h07*320+:320]),\r
			.INIT_08(INIT['h08*320+:320]),\r
			.INIT_09(INIT['h09*320+:320]),\r
			.INIT_0A(INIT['h0a*320+:320]),\r
			.INIT_0B(INIT['h0b*320+:320]),\r
			.INIT_0C(INIT['h0c*320+:320]),\r
			.INIT_0D(INIT['h0d*320+:320]),\r
			.INIT_0E(INIT['h0e*320+:320]),\r
			.INIT_0F(INIT['h0f*320+:320]),\r
			.INIT_10(INIT['h10*320+:320]),\r
			.INIT_11(INIT['h11*320+:320]),\r
			.INIT_12(INIT['h12*320+:320]),\r
			.INIT_13(INIT['h13*320+:320]),\r
			.INIT_14(INIT['h14*320+:320]),\r
			.INIT_15(INIT['h15*320+:320]),\r
			.INIT_16(INIT['h16*320+:320]),\r
			.INIT_17(INIT['h17*320+:320]),\r
			.INIT_18(INIT['h18*320+:320]),\r
			.INIT_19(INIT['h19*320+:320]),\r
			.INIT_1A(INIT['h1a*320+:320]),\r
			.INIT_1B(INIT['h1b*320+:320]),\r
			.INIT_1C(INIT['h1c*320+:320]),\r
			.INIT_1D(INIT['h1d*320+:320]),\r
			.INIT_1E(INIT['h1e*320+:320]),\r
			.INIT_1F(INIT['h1f*320+:320]),\r
			.INIT_20(INIT['h20*320+:320]),\r
			.INIT_21(INIT['h21*320+:320]),\r
			.INIT_22(INIT['h22*320+:320]),\r
			.INIT_23(INIT['h23*320+:320]),\r
			.INIT_24(INIT['h24*320+:320]),\r
			.INIT_25(INIT['h25*320+:320]),\r
			.INIT_26(INIT['h26*320+:320]),\r
			.INIT_27(INIT['h27*320+:320]),\r
			.INIT_28(INIT['h28*320+:320]),\r
			.INIT_29(INIT['h29*320+:320]),\r
			.INIT_2A(INIT['h2a*320+:320]),\r
			.INIT_2B(INIT['h2b*320+:320]),\r
			.INIT_2C(INIT['h2c*320+:320]),\r
			.INIT_2D(INIT['h2d*320+:320]),\r
			.INIT_2E(INIT['h2e*320+:320]),\r
			.INIT_2F(INIT['h2f*320+:320]),\r
			.INIT_30(INIT['h30*320+:320]),\r
			.INIT_31(INIT['h31*320+:320]),\r
			.INIT_32(INIT['h32*320+:320]),\r
			.INIT_33(INIT['h33*320+:320]),\r
			.INIT_34(INIT['h34*320+:320]),\r
			.INIT_35(INIT['h35*320+:320]),\r
			.INIT_36(INIT['h36*320+:320]),\r
			.INIT_37(INIT['h37*320+:320]),\r
			.INIT_38(INIT['h38*320+:320]),\r
			.INIT_39(INIT['h39*320+:320]),\r
			.INIT_3A(INIT['h3a*320+:320]),\r
			.INIT_3B(INIT['h3b*320+:320]),\r
			.INIT_3C(INIT['h3c*320+:320]),\r
			.INIT_3D(INIT['h3d*320+:320]),\r
			.INIT_3E(INIT['h3e*320+:320]),\r
			.INIT_3F(INIT['h3f*320+:320]),\r
			.INIT_40(INIT['h40*320+:320]),\r
			.INIT_41(INIT['h41*320+:320]),\r
			.INIT_42(INIT['h42*320+:320]),\r
			.INIT_43(INIT['h43*320+:320]),\r
			.INIT_44(INIT['h44*320+:320]),\r
			.INIT_45(INIT['h45*320+:320]),\r
			.INIT_46(INIT['h46*320+:320]),\r
			.INIT_47(INIT['h47*320+:320]),\r
			.INIT_48(INIT['h48*320+:320]),\r
			.INIT_49(INIT['h49*320+:320]),\r
			.INIT_4A(INIT['h4a*320+:320]),\r
			.INIT_4B(INIT['h4b*320+:320]),\r
			.INIT_4C(INIT['h4c*320+:320]),\r
			.INIT_4D(INIT['h4d*320+:320]),\r
			.INIT_4E(INIT['h4e*320+:320]),\r
			.INIT_4F(INIT['h4f*320+:320]),\r
			.INIT_50(INIT['h50*320+:320]),\r
			.INIT_51(INIT['h51*320+:320]),\r
			.INIT_52(INIT['h52*320+:320]),\r
			.INIT_53(INIT['h53*320+:320]),\r
			.INIT_54(INIT['h54*320+:320]),\r
			.INIT_55(INIT['h55*320+:320]),\r
			.INIT_56(INIT['h56*320+:320]),\r
			.INIT_57(INIT['h57*320+:320]),\r
			.INIT_58(INIT['h58*320+:320]),\r
			.INIT_59(INIT['h59*320+:320]),\r
			.INIT_5A(INIT['h5a*320+:320]),\r
			.INIT_5B(INIT['h5b*320+:320]),\r
			.INIT_5C(INIT['h5c*320+:320]),\r
			.INIT_5D(INIT['h5d*320+:320]),\r
			.INIT_5E(INIT['h5e*320+:320]),\r
			.INIT_5F(INIT['h5f*320+:320]),\r
			.INIT_60(INIT['h60*320+:320]),\r
			.INIT_61(INIT['h61*320+:320]),\r
			.INIT_62(INIT['h62*320+:320]),\r
			.INIT_63(INIT['h63*320+:320]),\r
			.INIT_64(INIT['h64*320+:320]),\r
			.INIT_65(INIT['h65*320+:320]),\r
			.INIT_66(INIT['h66*320+:320]),\r
			.INIT_67(INIT['h67*320+:320]),\r
			.INIT_68(INIT['h68*320+:320]),\r
			.INIT_69(INIT['h69*320+:320]),\r
			.INIT_6A(INIT['h6a*320+:320]),\r
			.INIT_6B(INIT['h6b*320+:320]),\r
			.INIT_6C(INIT['h6c*320+:320]),\r
			.INIT_6D(INIT['h6d*320+:320]),\r
			.INIT_6E(INIT['h6e*320+:320]),\r
			.INIT_6F(INIT['h6f*320+:320]),\r
			.INIT_70(INIT['h70*320+:320]),\r
			.INIT_71(INIT['h71*320+:320]),\r
			.INIT_72(INIT['h72*320+:320]),\r
			.INIT_73(INIT['h73*320+:320]),\r
			.INIT_74(INIT['h74*320+:320]),\r
			.INIT_75(INIT['h75*320+:320]),\r
			.INIT_76(INIT['h76*320+:320]),\r
			.INIT_77(INIT['h77*320+:320]),\r
			.INIT_78(INIT['h78*320+:320]),\r
			.INIT_79(INIT['h79*320+:320]),\r
			.INIT_7A(INIT['h7a*320+:320]),\r
			.INIT_7B(INIT['h7b*320+:320]),\r
			.INIT_7C(INIT['h7c*320+:320]),\r
			.INIT_7D(INIT['h7d*320+:320]),\r
			.INIT_7E(INIT['h7e*320+:320]),\r
			.INIT_7F(INIT['h7f*320+:320]),\r
			.A_RD_WIDTH(PORT_A_RD_USED ? PORT_A_RD_WIDTH : 0),\r
			.A_WR_WIDTH(PORT_A_WR_USED ? PORT_A_WR_WIDTH : 0),\r
			.B_RD_WIDTH(PORT_B_RD_USED ? PORT_B_RD_WIDTH : 0),\r
			.B_WR_WIDTH(PORT_B_WR_USED ? PORT_B_WR_WIDTH : 0),\r
			.RAM_MODE("TDP"),\r
			.A_WR_MODE(PORT_A_OPTION_WR_MODE),\r
			.B_WR_MODE(PORT_B_OPTION_WR_MODE),\r
			.A_CLK_INV(!PORT_A_CLK_POL),\r
			.B_CLK_INV(!PORT_B_CLK_POL),\r
			.CAS("LOWER"),\r
		) lower (\r
			.A_CO(CAS_A),\r
			.B_CO(CAS_B),\r
			.A_CLK(PORT_A_CLK),\r
			.A_EN(PORT_A_CLK_EN),\r
			.A_WE(PORT_A_WR_EN),\r
			.A_BM(PORT_A_WR_BE),\r
			.A_DI(PORT_A_WR_DATA),\r
			.A_ADDR({PORT_A_ADDR[14:0], PORT_A_ADDR[15]}),\r
			.B_CLK(PORT_B_CLK),\r
			.B_EN(PORT_B_CLK_EN),\r
			.B_WE(PORT_B_WR_EN),\r
			.B_BM(PORT_B_WR_BE),\r
			.B_DI(PORT_B_WR_DATA),\r
			.B_ADDR({PORT_B_ADDR[14:0], PORT_B_ADDR[15]}),\r
		);\r
		CC_BRAM_40K #(\r
			.INIT_00(INIT['h80*320+:320]),\r
			.INIT_01(INIT['h81*320+:320]),\r
			.INIT_02(INIT['h82*320+:320]),\r
			.INIT_03(INIT['h83*320+:320]),\r
			.INIT_04(INIT['h84*320+:320]),\r
			.INIT_05(INIT['h85*320+:320]),\r
			.INIT_06(INIT['h86*320+:320]),\r
			.INIT_07(INIT['h87*320+:320]),\r
			.INIT_08(INIT['h88*320+:320]),\r
			.INIT_09(INIT['h89*320+:320]),\r
			.INIT_0A(INIT['h8a*320+:320]),\r
			.INIT_0B(INIT['h8b*320+:320]),\r
			.INIT_0C(INIT['h8c*320+:320]),\r
			.INIT_0D(INIT['h8d*320+:320]),\r
			.INIT_0E(INIT['h8e*320+:320]),\r
			.INIT_0F(INIT['h8f*320+:320]),\r
			.INIT_10(INIT['h90*320+:320]),\r
			.INIT_11(INIT['h91*320+:320]),\r
			.INIT_12(INIT['h92*320+:320]),\r
			.INIT_13(INIT['h93*320+:320]),\r
			.INIT_14(INIT['h94*320+:320]),\r
			.INIT_15(INIT['h95*320+:320]),\r
			.INIT_16(INIT['h96*320+:320]),\r
			.INIT_17(INIT['h97*320+:320]),\r
			.INIT_18(INIT['h98*320+:320]),\r
			.INIT_19(INIT['h99*320+:320]),\r
			.INIT_1A(INIT['h9a*320+:320]),\r
			.INIT_1B(INIT['h9b*320+:320]),\r
			.INIT_1C(INIT['h9c*320+:320]),\r
			.INIT_1D(INIT['h9d*320+:320]),\r
			.INIT_1E(INIT['h9e*320+:320]),\r
			.INIT_1F(INIT['h9f*320+:320]),\r
			.INIT_20(INIT['ha0*320+:320]),\r
			.INIT_21(INIT['ha1*320+:320]),\r
			.INIT_22(INIT['ha2*320+:320]),\r
			.INIT_23(INIT['ha3*320+:320]),\r
			.INIT_24(INIT['ha4*320+:320]),\r
			.INIT_25(INIT['ha5*320+:320]),\r
			.INIT_26(INIT['ha6*320+:320]),\r
			.INIT_27(INIT['ha7*320+:320]),\r
			.INIT_28(INIT['ha8*320+:320]),\r
			.INIT_29(INIT['ha9*320+:320]),\r
			.INIT_2A(INIT['haa*320+:320]),\r
			.INIT_2B(INIT['hab*320+:320]),\r
			.INIT_2C(INIT['hac*320+:320]),\r
			.INIT_2D(INIT['had*320+:320]),\r
			.INIT_2E(INIT['hae*320+:320]),\r
			.INIT_2F(INIT['haf*320+:320]),\r
			.INIT_30(INIT['hb0*320+:320]),\r
			.INIT_31(INIT['hb1*320+:320]),\r
			.INIT_32(INIT['hb2*320+:320]),\r
			.INIT_33(INIT['hb3*320+:320]),\r
			.INIT_34(INIT['hb4*320+:320]),\r
			.INIT_35(INIT['hb5*320+:320]),\r
			.INIT_36(INIT['hb6*320+:320]),\r
			.INIT_37(INIT['hb7*320+:320]),\r
			.INIT_38(INIT['hb8*320+:320]),\r
			.INIT_39(INIT['hb9*320+:320]),\r
			.INIT_3A(INIT['hba*320+:320]),\r
			.INIT_3B(INIT['hbb*320+:320]),\r
			.INIT_3C(INIT['hbc*320+:320]),\r
			.INIT_3D(INIT['hbd*320+:320]),\r
			.INIT_3E(INIT['hbe*320+:320]),\r
			.INIT_3F(INIT['hbf*320+:320]),\r
			.INIT_40(INIT['hc0*320+:320]),\r
			.INIT_41(INIT['hc1*320+:320]),\r
			.INIT_42(INIT['hc2*320+:320]),\r
			.INIT_43(INIT['hc3*320+:320]),\r
			.INIT_44(INIT['hc4*320+:320]),\r
			.INIT_45(INIT['hc5*320+:320]),\r
			.INIT_46(INIT['hc6*320+:320]),\r
			.INIT_47(INIT['hc7*320+:320]),\r
			.INIT_48(INIT['hc8*320+:320]),\r
			.INIT_49(INIT['hc9*320+:320]),\r
			.INIT_4A(INIT['hca*320+:320]),\r
			.INIT_4B(INIT['hcb*320+:320]),\r
			.INIT_4C(INIT['hcc*320+:320]),\r
			.INIT_4D(INIT['hcd*320+:320]),\r
			.INIT_4E(INIT['hce*320+:320]),\r
			.INIT_4F(INIT['hcf*320+:320]),\r
			.INIT_50(INIT['hd0*320+:320]),\r
			.INIT_51(INIT['hd1*320+:320]),\r
			.INIT_52(INIT['hd2*320+:320]),\r
			.INIT_53(INIT['hd3*320+:320]),\r
			.INIT_54(INIT['hd4*320+:320]),\r
			.INIT_55(INIT['hd5*320+:320]),\r
			.INIT_56(INIT['hd6*320+:320]),\r
			.INIT_57(INIT['hd7*320+:320]),\r
			.INIT_58(INIT['hd8*320+:320]),\r
			.INIT_59(INIT['hd9*320+:320]),\r
			.INIT_5A(INIT['hda*320+:320]),\r
			.INIT_5B(INIT['hdb*320+:320]),\r
			.INIT_5C(INIT['hdc*320+:320]),\r
			.INIT_5D(INIT['hdd*320+:320]),\r
			.INIT_5E(INIT['hde*320+:320]),\r
			.INIT_5F(INIT['hdf*320+:320]),\r
			.INIT_60(INIT['he0*320+:320]),\r
			.INIT_61(INIT['he1*320+:320]),\r
			.INIT_62(INIT['he2*320+:320]),\r
			.INIT_63(INIT['he3*320+:320]),\r
			.INIT_64(INIT['he4*320+:320]),\r
			.INIT_65(INIT['he5*320+:320]),\r
			.INIT_66(INIT['he6*320+:320]),\r
			.INIT_67(INIT['he7*320+:320]),\r
			.INIT_68(INIT['he8*320+:320]),\r
			.INIT_69(INIT['he9*320+:320]),\r
			.INIT_6A(INIT['hea*320+:320]),\r
			.INIT_6B(INIT['heb*320+:320]),\r
			.INIT_6C(INIT['hec*320+:320]),\r
			.INIT_6D(INIT['hed*320+:320]),\r
			.INIT_6E(INIT['hee*320+:320]),\r
			.INIT_6F(INIT['hef*320+:320]),\r
			.INIT_70(INIT['hf0*320+:320]),\r
			.INIT_71(INIT['hf1*320+:320]),\r
			.INIT_72(INIT['hf2*320+:320]),\r
			.INIT_73(INIT['hf3*320+:320]),\r
			.INIT_74(INIT['hf4*320+:320]),\r
			.INIT_75(INIT['hf5*320+:320]),\r
			.INIT_76(INIT['hf6*320+:320]),\r
			.INIT_77(INIT['hf7*320+:320]),\r
			.INIT_78(INIT['hf8*320+:320]),\r
			.INIT_79(INIT['hf9*320+:320]),\r
			.INIT_7A(INIT['hfa*320+:320]),\r
			.INIT_7B(INIT['hfb*320+:320]),\r
			.INIT_7C(INIT['hfc*320+:320]),\r
			.INIT_7D(INIT['hfd*320+:320]),\r
			.INIT_7E(INIT['hfe*320+:320]),\r
			.INIT_7F(INIT['hff*320+:320]),\r
			.A_RD_WIDTH(PORT_A_RD_USED ? PORT_A_RD_WIDTH : 0),\r
			.A_WR_WIDTH(PORT_A_WR_USED ? PORT_A_WR_WIDTH : 0),\r
			.B_RD_WIDTH(PORT_B_RD_USED ? PORT_B_RD_WIDTH : 0),\r
			.B_WR_WIDTH(PORT_B_WR_USED ? PORT_B_WR_WIDTH : 0),\r
			.RAM_MODE("TDP"),\r
			.A_WR_MODE(PORT_A_OPTION_WR_MODE),\r
			.B_WR_MODE(PORT_B_OPTION_WR_MODE),\r
			.A_CLK_INV(!PORT_A_CLK_POL),\r
			.B_CLK_INV(!PORT_B_CLK_POL),\r
			.CAS("UPPER"),\r
		) upper (\r
			.A_CI(CAS_A),\r
			.B_CI(CAS_B),\r
			.A_CLK(PORT_A_CLK),\r
			.A_EN(PORT_A_CLK_EN),\r
			.A_WE(PORT_A_WR_EN),\r
			.A_BM(PORT_A_WR_BE),\r
			.A_DI(PORT_A_WR_DATA),\r
			.A_DO(PORT_A_RD_DATA),\r
			.A_ADDR({PORT_A_ADDR[14:0], PORT_A_ADDR[15]}),\r
			.B_CLK(PORT_B_CLK),\r
			.B_EN(PORT_B_CLK_EN),\r
			.B_WE(PORT_B_WR_EN),\r
			.B_BM(PORT_B_WR_BE),\r
			.B_DI(PORT_B_WR_DATA),\r
			.B_DO(PORT_B_RD_DATA),\r
			.B_ADDR({PORT_B_ADDR[14:0], PORT_B_ADDR[15]}),\r
		);\r
	end\r
endgenerate\r
\r
endmodule\r
\r
\r
module $__CC_BRAM_SDP_(...);\r
\r
parameter INIT = 0;\r
parameter OPTION_MODE = "20K";\r
parameter OPTION_WR_MODE = "NO_CHANGE";\r
\r
parameter PORT_W_CLK_POL = 1;\r
parameter PORT_W_USED = 1;\r
parameter PORT_W_WIDTH = 40;\r
parameter PORT_W_WR_BE_WIDTH = 40;\r
\r
parameter PORT_R_CLK_POL = 1;\r
parameter PORT_R_USED = 1;\r
parameter PORT_R_WIDTH = 40;\r
\r
input PORT_W_CLK;\r
input PORT_W_CLK_EN;\r
input PORT_W_WR_EN;\r
input [15:0] PORT_W_ADDR;\r
input [PORT_W_WR_BE_WIDTH-1:0] PORT_W_WR_BE;\r
input [PORT_W_WIDTH-1:0] PORT_W_WR_DATA;\r
\r
input PORT_R_CLK;\r
input PORT_R_CLK_EN;\r
input [15:0] PORT_R_ADDR;\r
output [PORT_R_WIDTH-1:0] PORT_R_RD_DATA;\r
\r
generate\r
	if (OPTION_MODE == "20K") begin\r
		CC_BRAM_20K #(\r
			.INIT_00(INIT['h00*320+:320]),\r
			.INIT_01(INIT['h01*320+:320]),\r
			.INIT_02(INIT['h02*320+:320]),\r
			.INIT_03(INIT['h03*320+:320]),\r
			.INIT_04(INIT['h04*320+:320]),\r
			.INIT_05(INIT['h05*320+:320]),\r
			.INIT_06(INIT['h06*320+:320]),\r
			.INIT_07(INIT['h07*320+:320]),\r
			.INIT_08(INIT['h08*320+:320]),\r
			.INIT_09(INIT['h09*320+:320]),\r
			.INIT_0A(INIT['h0a*320+:320]),\r
			.INIT_0B(INIT['h0b*320+:320]),\r
			.INIT_0C(INIT['h0c*320+:320]),\r
			.INIT_0D(INIT['h0d*320+:320]),\r
			.INIT_0E(INIT['h0e*320+:320]),\r
			.INIT_0F(INIT['h0f*320+:320]),\r
			.INIT_10(INIT['h10*320+:320]),\r
			.INIT_11(INIT['h11*320+:320]),\r
			.INIT_12(INIT['h12*320+:320]),\r
			.INIT_13(INIT['h13*320+:320]),\r
			.INIT_14(INIT['h14*320+:320]),\r
			.INIT_15(INIT['h15*320+:320]),\r
			.INIT_16(INIT['h16*320+:320]),\r
			.INIT_17(INIT['h17*320+:320]),\r
			.INIT_18(INIT['h18*320+:320]),\r
			.INIT_19(INIT['h19*320+:320]),\r
			.INIT_1A(INIT['h1a*320+:320]),\r
			.INIT_1B(INIT['h1b*320+:320]),\r
			.INIT_1C(INIT['h1c*320+:320]),\r
			.INIT_1D(INIT['h1d*320+:320]),\r
			.INIT_1E(INIT['h1e*320+:320]),\r
			.INIT_1F(INIT['h1f*320+:320]),\r
			.INIT_20(INIT['h20*320+:320]),\r
			.INIT_21(INIT['h21*320+:320]),\r
			.INIT_22(INIT['h22*320+:320]),\r
			.INIT_23(INIT['h23*320+:320]),\r
			.INIT_24(INIT['h24*320+:320]),\r
			.INIT_25(INIT['h25*320+:320]),\r
			.INIT_26(INIT['h26*320+:320]),\r
			.INIT_27(INIT['h27*320+:320]),\r
			.INIT_28(INIT['h28*320+:320]),\r
			.INIT_29(INIT['h29*320+:320]),\r
			.INIT_2A(INIT['h2a*320+:320]),\r
			.INIT_2B(INIT['h2b*320+:320]),\r
			.INIT_2C(INIT['h2c*320+:320]),\r
			.INIT_2D(INIT['h2d*320+:320]),\r
			.INIT_2E(INIT['h2e*320+:320]),\r
			.INIT_2F(INIT['h2f*320+:320]),\r
			.INIT_30(INIT['h30*320+:320]),\r
			.INIT_31(INIT['h31*320+:320]),\r
			.INIT_32(INIT['h32*320+:320]),\r
			.INIT_33(INIT['h33*320+:320]),\r
			.INIT_34(INIT['h34*320+:320]),\r
			.INIT_35(INIT['h35*320+:320]),\r
			.INIT_36(INIT['h36*320+:320]),\r
			.INIT_37(INIT['h37*320+:320]),\r
			.INIT_38(INIT['h38*320+:320]),\r
			.INIT_39(INIT['h39*320+:320]),\r
			.INIT_3A(INIT['h3a*320+:320]),\r
			.INIT_3B(INIT['h3b*320+:320]),\r
			.INIT_3C(INIT['h3c*320+:320]),\r
			.INIT_3D(INIT['h3d*320+:320]),\r
			.INIT_3E(INIT['h3e*320+:320]),\r
			.INIT_3F(INIT['h3f*320+:320]),\r
			.A_RD_WIDTH(0),\r
			.A_WR_WIDTH(PORT_W_USED ? PORT_W_WIDTH : 0),\r
			.B_RD_WIDTH(PORT_R_USED ? PORT_R_WIDTH : 0),\r
			.B_WR_WIDTH(0),\r
			.RAM_MODE("SDP"),\r
			.A_WR_MODE(OPTION_WR_MODE),\r
			.B_WR_MODE(OPTION_WR_MODE),\r
			.A_CLK_INV(!PORT_W_CLK_POL),\r
			.B_CLK_INV(!PORT_R_CLK_POL),\r
		) _TECHMAP_REPLACE_ (\r
			.A_CLK(PORT_W_CLK),\r
			.A_EN(PORT_W_CLK_EN),\r
			.A_WE(PORT_W_WR_EN),\r
			.A_BM(PORT_W_WR_BE[19:0]),\r
			.B_BM(PORT_W_WR_BE[39:20]),\r
			.A_DI(PORT_W_WR_DATA[19:0]),\r
			.B_DI(PORT_W_WR_DATA[39:20]),\r
			.A_ADDR({PORT_W_ADDR[13:5], 1'b0, PORT_W_ADDR[4:0], 1'b0}),\r
			.B_CLK(PORT_R_CLK),\r
			.B_EN(PORT_R_CLK_EN),\r
			.B_WE(1'b0),\r
			.B_ADDR({PORT_R_ADDR[13:5], 1'b0, PORT_R_ADDR[4:0], 1'b0}),\r
			.A_DO(PORT_R_RD_DATA[19:0]),\r
			.B_DO(PORT_R_RD_DATA[39:20]),\r
		);\r
	end else if (OPTION_MODE == "40K") begin\r
		CC_BRAM_40K #(\r
			.INIT_00(INIT['h00*320+:320]),\r
			.INIT_01(INIT['h01*320+:320]),\r
			.INIT_02(INIT['h02*320+:320]),\r
			.INIT_03(INIT['h03*320+:320]),\r
			.INIT_04(INIT['h04*320+:320]),\r
			.INIT_05(INIT['h05*320+:320]),\r
			.INIT_06(INIT['h06*320+:320]),\r
			.INIT_07(INIT['h07*320+:320]),\r
			.INIT_08(INIT['h08*320+:320]),\r
			.INIT_09(INIT['h09*320+:320]),\r
			.INIT_0A(INIT['h0a*320+:320]),\r
			.INIT_0B(INIT['h0b*320+:320]),\r
			.INIT_0C(INIT['h0c*320+:320]),\r
			.INIT_0D(INIT['h0d*320+:320]),\r
			.INIT_0E(INIT['h0e*320+:320]),\r
			.INIT_0F(INIT['h0f*320+:320]),\r
			.INIT_10(INIT['h10*320+:320]),\r
			.INIT_11(INIT['h11*320+:320]),\r
			.INIT_12(INIT['h12*320+:320]),\r
			.INIT_13(INIT['h13*320+:320]),\r
			.INIT_14(INIT['h14*320+:320]),\r
			.INIT_15(INIT['h15*320+:320]),\r
			.INIT_16(INIT['h16*320+:320]),\r
			.INIT_17(INIT['h17*320+:320]),\r
			.INIT_18(INIT['h18*320+:320]),\r
			.INIT_19(INIT['h19*320+:320]),\r
			.INIT_1A(INIT['h1a*320+:320]),\r
			.INIT_1B(INIT['h1b*320+:320]),\r
			.INIT_1C(INIT['h1c*320+:320]),\r
			.INIT_1D(INIT['h1d*320+:320]),\r
			.INIT_1E(INIT['h1e*320+:320]),\r
			.INIT_1F(INIT['h1f*320+:320]),\r
			.INIT_20(INIT['h20*320+:320]),\r
			.INIT_21(INIT['h21*320+:320]),\r
			.INIT_22(INIT['h22*320+:320]),\r
			.INIT_23(INIT['h23*320+:320]),\r
			.INIT_24(INIT['h24*320+:320]),\r
			.INIT_25(INIT['h25*320+:320]),\r
			.INIT_26(INIT['h26*320+:320]),\r
			.INIT_27(INIT['h27*320+:320]),\r
			.INIT_28(INIT['h28*320+:320]),\r
			.INIT_29(INIT['h29*320+:320]),\r
			.INIT_2A(INIT['h2a*320+:320]),\r
			.INIT_2B(INIT['h2b*320+:320]),\r
			.INIT_2C(INIT['h2c*320+:320]),\r
			.INIT_2D(INIT['h2d*320+:320]),\r
			.INIT_2E(INIT['h2e*320+:320]),\r
			.INIT_2F(INIT['h2f*320+:320]),\r
			.INIT_30(INIT['h30*320+:320]),\r
			.INIT_31(INIT['h31*320+:320]),\r
			.INIT_32(INIT['h32*320+:320]),\r
			.INIT_33(INIT['h33*320+:320]),\r
			.INIT_34(INIT['h34*320+:320]),\r
			.INIT_35(INIT['h35*320+:320]),\r
			.INIT_36(INIT['h36*320+:320]),\r
			.INIT_37(INIT['h37*320+:320]),\r
			.INIT_38(INIT['h38*320+:320]),\r
			.INIT_39(INIT['h39*320+:320]),\r
			.INIT_3A(INIT['h3a*320+:320]),\r
			.INIT_3B(INIT['h3b*320+:320]),\r
			.INIT_3C(INIT['h3c*320+:320]),\r
			.INIT_3D(INIT['h3d*320+:320]),\r
			.INIT_3E(INIT['h3e*320+:320]),\r
			.INIT_3F(INIT['h3f*320+:320]),\r
			.INIT_40(INIT['h40*320+:320]),\r
			.INIT_41(INIT['h41*320+:320]),\r
			.INIT_42(INIT['h42*320+:320]),\r
			.INIT_43(INIT['h43*320+:320]),\r
			.INIT_44(INIT['h44*320+:320]),\r
			.INIT_45(INIT['h45*320+:320]),\r
			.INIT_46(INIT['h46*320+:320]),\r
			.INIT_47(INIT['h47*320+:320]),\r
			.INIT_48(INIT['h48*320+:320]),\r
			.INIT_49(INIT['h49*320+:320]),\r
			.INIT_4A(INIT['h4a*320+:320]),\r
			.INIT_4B(INIT['h4b*320+:320]),\r
			.INIT_4C(INIT['h4c*320+:320]),\r
			.INIT_4D(INIT['h4d*320+:320]),\r
			.INIT_4E(INIT['h4e*320+:320]),\r
			.INIT_4F(INIT['h4f*320+:320]),\r
			.INIT_50(INIT['h50*320+:320]),\r
			.INIT_51(INIT['h51*320+:320]),\r
			.INIT_52(INIT['h52*320+:320]),\r
			.INIT_53(INIT['h53*320+:320]),\r
			.INIT_54(INIT['h54*320+:320]),\r
			.INIT_55(INIT['h55*320+:320]),\r
			.INIT_56(INIT['h56*320+:320]),\r
			.INIT_57(INIT['h57*320+:320]),\r
			.INIT_58(INIT['h58*320+:320]),\r
			.INIT_59(INIT['h59*320+:320]),\r
			.INIT_5A(INIT['h5a*320+:320]),\r
			.INIT_5B(INIT['h5b*320+:320]),\r
			.INIT_5C(INIT['h5c*320+:320]),\r
			.INIT_5D(INIT['h5d*320+:320]),\r
			.INIT_5E(INIT['h5e*320+:320]),\r
			.INIT_5F(INIT['h5f*320+:320]),\r
			.INIT_60(INIT['h60*320+:320]),\r
			.INIT_61(INIT['h61*320+:320]),\r
			.INIT_62(INIT['h62*320+:320]),\r
			.INIT_63(INIT['h63*320+:320]),\r
			.INIT_64(INIT['h64*320+:320]),\r
			.INIT_65(INIT['h65*320+:320]),\r
			.INIT_66(INIT['h66*320+:320]),\r
			.INIT_67(INIT['h67*320+:320]),\r
			.INIT_68(INIT['h68*320+:320]),\r
			.INIT_69(INIT['h69*320+:320]),\r
			.INIT_6A(INIT['h6a*320+:320]),\r
			.INIT_6B(INIT['h6b*320+:320]),\r
			.INIT_6C(INIT['h6c*320+:320]),\r
			.INIT_6D(INIT['h6d*320+:320]),\r
			.INIT_6E(INIT['h6e*320+:320]),\r
			.INIT_6F(INIT['h6f*320+:320]),\r
			.INIT_70(INIT['h70*320+:320]),\r
			.INIT_71(INIT['h71*320+:320]),\r
			.INIT_72(INIT['h72*320+:320]),\r
			.INIT_73(INIT['h73*320+:320]),\r
			.INIT_74(INIT['h74*320+:320]),\r
			.INIT_75(INIT['h75*320+:320]),\r
			.INIT_76(INIT['h76*320+:320]),\r
			.INIT_77(INIT['h77*320+:320]),\r
			.INIT_78(INIT['h78*320+:320]),\r
			.INIT_79(INIT['h79*320+:320]),\r
			.INIT_7A(INIT['h7a*320+:320]),\r
			.INIT_7B(INIT['h7b*320+:320]),\r
			.INIT_7C(INIT['h7c*320+:320]),\r
			.INIT_7D(INIT['h7d*320+:320]),\r
			.INIT_7E(INIT['h7e*320+:320]),\r
			.INIT_7F(INIT['h7f*320+:320]),\r
			.A_RD_WIDTH(0),\r
			.A_WR_WIDTH(PORT_W_USED ? PORT_W_WIDTH : 0),\r
			.B_RD_WIDTH(PORT_R_USED ? PORT_R_WIDTH : 0),\r
			.B_WR_WIDTH(0),\r
			.RAM_MODE("SDP"),\r
			.A_WR_MODE(OPTION_WR_MODE),\r
			.B_WR_MODE(OPTION_WR_MODE),\r
			.A_CLK_INV(!PORT_W_CLK_POL),\r
			.B_CLK_INV(!PORT_R_CLK_POL),\r
		) _TECHMAP_REPLACE_ (\r
			.A_CLK(PORT_W_CLK),\r
			.A_EN(PORT_W_CLK_EN),\r
			.A_WE(PORT_W_WR_EN),\r
			.A_BM(PORT_W_WR_BE[39:0]),\r
			.B_BM(PORT_W_WR_BE[79:40]),\r
			.A_DI(PORT_W_WR_DATA[39:0]),\r
			.B_DI(PORT_W_WR_DATA[79:40]),\r
			.A_ADDR({PORT_W_ADDR[14:0], 1'b0}),\r
			.B_CLK(PORT_R_CLK),\r
			.B_EN(PORT_R_CLK_EN),\r
			.B_WE(1'b0),\r
			.B_ADDR({PORT_R_ADDR[14:0], 1'b0}),\r
			.A_DO(PORT_R_RD_DATA[39:0]),\r
			.B_DO(PORT_R_RD_DATA[79:40]),\r
		);\r
	end\r
endgenerate\r
\r
endmodule\r
`,"cells_bb.v":`/*\r
 *  yosys -- Yosys Open SYnthesis Suite\r
 *\r
 *  Copyright (C) 2021  Cologne Chip AG <support@colognechip.com>\r
 *\r
 *  Permission to use, copy, modify, and/or distribute this software for any\r
 *  purpose with or without fee is hereby granted, provided that the above\r
 *  copyright notice and this permission notice appear in all copies.\r
 *\r
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\r
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\r
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\r
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\r
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\r
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\r
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\r
 *\r
 */\r
\r
(* blackbox *)\r
module CC_PLL #(\r
	parameter REF_CLK = "", // e.g. "10.0"\r
	parameter OUT_CLK = "", // e.g. "50.0"\r
	parameter PERF_MD = "", // LOWPOWER, ECONOMY, SPEED\r
	parameter LOCK_REQ = 1,\r
	parameter CLK270_DOUB = 0,\r
	parameter CLK180_DOUB = 0,\r
	parameter LOW_JITTER = 1,\r
	parameter CI_FILTER_CONST = 2,\r
	parameter CP_FILTER_CONST = 4\r
)(\r
	input  CLK_REF, CLK_FEEDBACK, USR_CLK_REF,\r
	input  USR_LOCKED_STDY_RST,\r
	output USR_PLL_LOCKED_STDY, USR_PLL_LOCKED,\r
	output CLK270, CLK180, CLK90, CLK0, CLK_REF_OUT\r
);\r
endmodule\r
\r
(* blackbox *)\r
module CC_PLL_ADV #(\r
	parameter [95:0] PLL_CFG_A = 96'bx,\r
	parameter [95:0] PLL_CFG_B = 96'bx\r
)(\r
	input  CLK_REF, CLK_FEEDBACK, USR_CLK_REF,\r
	input  USR_LOCKED_STDY_RST, USR_SEL_A_B,\r
	output USR_PLL_LOCKED_STDY, USR_PLL_LOCKED,\r
	output CLK270, CLK180, CLK90, CLK0, CLK_REF_OUT\r
);\r
endmodule\r
\r
(* blackbox *) (* keep *)\r
module CC_SERDES #(\r
	parameter SERDES_CFG = ""\r
)(\r
	input [63:0] TX_DATA_I,\r
	input TX_RESET_I,\r
	input TX_PCS_RESET_I,\r
	input TX_PMA_RESET_I,\r
	input PLL_RESET_I,\r
	input TX_POWERDOWN_N_I,\r
	input TX_POLARITY_I,\r
	input [2:0] TX_PRBS_SEL_I,\r
	input TX_PRBS_FORCE_ERR_I,\r
	input TX_8B10B_EN_I,\r
	input [7:0] TX_8B10B_BYPASS_I,\r
	input [7:0] TX_CHAR_IS_K_I,\r
	input [7:0] TX_CHAR_DISPMODE_I,\r
	input [7:0] TX_CHAR_DISPVAL_I,\r
	input TX_ELEC_IDLE_I,\r
	input TX_DETECT_RX_I,\r
	input [2:0] LOOPBACK_I,\r
	input CLK_CORE_TX_I,\r
	input CLK_CORE_RX_I,\r
	input RX_RESET_I,\r
	input RX_PMA_RESET_I,\r
	input RX_EQA_RESET_I,\r
	input RX_CDR_RESET_I,\r
	input RX_PCS_RESET_I,\r
	input RX_BUF_RESET_I,\r
	input RX_POWERDOWN_N_I,\r
	input RX_POLARITY_I,\r
	input [2:0] RX_PRBS_SEL_I,\r
	input RX_PRBS_CNT_RESET_I,\r
	input RX_8B10B_EN_I,\r
	input [7:0] RX_8B10B_BYPASS_I,\r
	input RX_EN_EI_DETECTOR_I,\r
	input RX_COMMA_DETECT_EN_I,\r
	input RX_SLIDE_I,\r
	input RX_MCOMMA_ALIGN_I,\r
	input RX_PCOMMA_ALIGN_I,\r
	input CLK_REG_I,\r
	input REGFILE_WE_I,\r
	input REGFILE_EN_I,\r
	input [7:0] REGFILE_ADDR_I,\r
	input [15:0] REGFILE_DI_I,\r
	input [15:0] REGFILE_MASK_I,\r
	output [63:0] RX_DATA_O,\r
	output [7:0] RX_NOT_IN_TABLE_O,\r
	output [7:0] RX_CHAR_IS_COMMA_O,\r
	output [7:0] RX_CHAR_IS_K_O,\r
	output [7:0] RX_DISP_ERR_O,\r
	output RX_DETECT_DONE_O,\r
	output RX_PRESENT_O,\r
	output TX_BUF_ERR_O,\r
	output TX_RESETDONE_O,\r
	output RX_PRBS_ERR_O,\r
	output RX_BUF_ERR_O,\r
	output RX_BYTE_IS_ALIGNED_O,\r
	output RX_BYTE_REALIGN_O,\r
	output RX_RESETDONE_O,\r
	output RX_EI_EN_O,\r
	output CLK_CORE_RX_O,\r
	output CLK_CORE_PLL_O,\r
	output [15:0] REGFILE_DO_O,\r
	output REGFILE_RDY_O\r
);\r
endmodule\r
\r
(* blackbox *) (* keep *)\r
module CC_CFG_CTRL(\r
	input [7:0] DATA,\r
	input CLK,\r
	input EN,\r
	input RECFG,\r
	input VALID\r
);\r
endmodule\r
\r
(* blackbox *) (* keep *)\r
module CC_USR_RSTN (\r
	output USR_RSTN\r
);\r
endmodule\r
`,"cells_sim.v":`/*\r
 *  yosys -- Yosys Open SYnthesis Suite\r
 *\r
 *  Copyright (C) 2021  Cologne Chip AG <support@colognechip.com>\r
 *\r
 *  Permission to use, copy, modify, and/or distribute this software for any\r
 *  purpose with or without fee is hereby granted, provided that the above\r
 *  copyright notice and this permission notice appear in all copies.\r
 *\r
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\r
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\r
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\r
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\r
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\r
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\r
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\r
 *\r
 */\r
\r
\`timescale 1ps/1ps\r
\r
module CC_IBUF #(\r
	parameter PIN_NAME = "UNPLACED",\r
	parameter V_IO = "UNDEFINED",\r
	parameter [0:0] PULLUP = 1'bx,\r
	parameter [0:0] PULLDOWN = 1'bx,\r
	parameter [0:0] KEEPER = 1'bx,\r
	parameter [0:0] SCHMITT_TRIGGER = 1'bx,\r
	// IOSEL\r
	parameter [3:0] DELAY_IBF = 1'bx,\r
	parameter [0:0] FF_IBF = 1'bx\r
)(\r
	(* iopad_external_pin *)\r
	input  I,\r
	output Y\r
);\r
	assign Y = I;\r
\r
endmodule\r
\r
\r
module CC_OBUF #(\r
	parameter PIN_NAME = "UNPLACED",\r
	parameter V_IO = "UNDEFINED",\r
	parameter DRIVE = "UNDEFINED",\r
	parameter SLEW = "UNDEFINED",\r
	// IOSEL\r
	parameter [3:0] DELAY_OBF = 1'bx,\r
	parameter [0:0] FF_OBF = 1'bx\r
)(\r
	input  A,\r
	(* iopad_external_pin *)\r
	output O\r
);\r
	assign O = A;\r
\r
endmodule\r
\r
\r
module CC_TOBUF #(\r
	parameter PIN_NAME = "UNPLACED",\r
	parameter V_IO = "UNDEFINED",\r
	parameter DRIVE = "UNDEFINED",\r
	parameter SLEW = "UNDEFINED",\r
	parameter [0:0] PULLUP = 1'bx,\r
	parameter [0:0] PULLDOWN = 1'bx,\r
	parameter [0:0] KEEPER = 1'bx,\r
	// IOSEL\r
	parameter [3:0] DELAY_OBF = 1'bx,\r
	parameter [0:0] FF_OBF = 1'bx\r
)(\r
	input  A, T,\r
	(* iopad_external_pin *)\r
	output O\r
);\r
	assign O = T ? 1'bz : A;\r
\r
endmodule\r
\r
\r
module CC_IOBUF #(\r
	parameter PIN_NAME = "UNPLACED",\r
	parameter V_IO = "UNDEFINED",\r
	parameter DRIVE = "UNDEFINED",\r
	parameter SLEW = "UNDEFINED",\r
	parameter [0:0] PULLUP = 1'bx,\r
	parameter [0:0] PULLDOWN = 1'bx,\r
	parameter [0:0] KEEPER = 1'bx,\r
	parameter [0:0] SCHMITT_TRIGGER = 1'bx,\r
	// IOSEL\r
	parameter [3:0] DELAY_IBF = 1'bx,\r
	parameter [3:0] DELAY_OBF = 1'bx,\r
	parameter [0:0] FF_IBF = 1'bx,\r
	parameter [0:0] FF_OBF = 1'bx\r
)(\r
	input  A, T,\r
	output Y,\r
	(* iopad_external_pin *)\r
	inout  IO\r
);\r
	assign IO = T ? 1'bz : A;\r
	assign Y = IO;\r
\r
endmodule\r
\r
\r
module CC_LVDS_IBUF #(\r
	parameter PIN_NAME_P = "UNPLACED",\r
	parameter PIN_NAME_N = "UNPLACED",\r
	parameter V_IO = "UNDEFINED",\r
	parameter [0:0] LVDS_RTERM = 1'bx,\r
	// IOSEL\r
	parameter [3:0] DELAY_IBF = 1'bx,\r
	parameter [0:0] FF_IBF = 1'bx\r
)(\r
	(* iopad_external_pin *)\r
	input  I_P, I_N,\r
	output Y\r
);\r
	assign Y = I_P;\r
\r
endmodule\r
\r
\r
module CC_LVDS_OBUF #(\r
	parameter PIN_NAME_P = "UNPLACED",\r
	parameter PIN_NAME_N = "UNPLACED",\r
	parameter V_IO = "UNDEFINED",\r
	parameter [0:0] LVDS_BOOST = 1'bx,\r
	// IOSEL\r
	parameter [3:0] DELAY_OBF = 1'bx,\r
	parameter [0:0] FF_OBF = 1'bx\r
)(\r
	input  A,\r
	(* iopad_external_pin *)\r
	output O_P, O_N\r
);\r
	assign O_P = A;\r
	assign O_N = ~A;\r
\r
endmodule\r
\r
\r
module CC_LVDS_TOBUF #(\r
	parameter PIN_NAME_P = "UNPLACED",\r
	parameter PIN_NAME_N = "UNPLACED",\r
	parameter V_IO = "UNDEFINED",\r
	parameter [0:0] LVDS_BOOST = 1'bx,\r
	// IOSEL\r
	parameter [3:0] DELAY_OBF = 1'bx,\r
	parameter [0:0] FF_OBF = 1'bx\r
)(\r
	input  A, T,\r
	(* iopad_external_pin *)\r
	output O_P, O_N\r
);\r
	assign O_P = T ? 1'bz :  A;\r
	assign O_N = T ? 1'bz : ~A;\r
\r
endmodule\r
\r
\r
module CC_LVDS_IOBUF #(\r
	parameter PIN_NAME_P = "UNPLACED",\r
	parameter PIN_NAME_N = "UNPLACED",\r
	parameter V_IO = "UNDEFINED",\r
	parameter [0:0] LVDS_RTERM = 1'bx,\r
	parameter [0:0] LVDS_BOOST = 1'bx,\r
	// IOSEL\r
	parameter [3:0] DELAY_IBF = 1'bx,\r
	parameter [3:0] DELAY_OBF = 1'bx,\r
	parameter [0:0] FF_IBF = 1'bx,\r
	parameter [0:0] FF_OBF = 1'bx\r
)(\r
	input  A, T,\r
	(* iopad_external_pin *)\r
	inout  IO_P, IO_N,\r
	output Y\r
);\r
	assign IO_P = T ? 1'bz :  A;\r
	assign IO_N = T ? 1'bz : ~A;\r
	assign Y = IO_P;\r
\r
endmodule\r
\r
\r
module CC_IDDR #(\r
	parameter [0:0] CLK_INV = 1'b0\r
)(\r
	input D,\r
	(* clkbuf_sink *)\r
	input CLK,\r
	output reg Q0, Q1\r
);\r
	wire clk;\r
	assign clk = (CLK_INV) ? ~CLK : CLK;\r
\r
	always @(posedge clk)\r
	begin\r
		Q0 <= D;\r
	end\r
\r
	always @(negedge clk)\r
	begin\r
		Q1 <= D;\r
	end\r
\r
endmodule\r
\r
\r
module CC_ODDR #(\r
	parameter [0:0] CLK_INV = 1'b0\r
)(\r
	input D0,\r
	input D1,\r
	(* clkbuf_sink *)\r
	input CLK,\r
	(* clkbuf_sink *)\r
	input DDR,\r
	output Q\r
);\r
	wire clk;\r
	assign clk = (CLK_INV) ? ~CLK : CLK;\r
\r
	reg q0, q1;\r
	assign Q = (DDR) ? q0 : q1;\r
\r
	always @(posedge clk)\r
	begin\r
		q0 <= D0;\r
	end\r
\r
	always @(negedge clk)\r
	begin\r
		q1 <= D1;\r
	end\r
\r
endmodule\r
\r
\r
module CC_DFF #(\r
	parameter [0:0] CLK_INV = 1'b0,\r
	parameter [0:0] EN_INV  = 1'b0,\r
	parameter [0:0] SR_INV  = 1'b0,\r
	parameter [0:0] SR_VAL  = 1'b0,\r
	parameter [0:0] INIT    = 1'bx\r
)(\r
	input D,\r
	(* clkbuf_sink *)\r
	input CLK,\r
	input EN,\r
	input SR,\r
	output reg Q\r
);\r
	wire clk, en, sr;\r
	assign clk = (CLK_INV) ? ~CLK : CLK;\r
	assign en  = (EN_INV)  ?  ~EN :  EN;\r
	assign sr  = (SR_INV)  ?  ~SR :  SR;\r
\r
	initial Q = INIT;\r
\r
	always @(posedge clk or posedge sr)\r
	begin\r
		if (sr) begin\r
			Q <= SR_VAL;\r
		end\r
		else if (en) begin\r
			Q <= D;\r
		end\r
	end\r
\r
endmodule\r
\r
\r
module CC_DLT #(\r
	parameter [0:0] G_INV  = 1'b0,\r
	parameter [0:0] SR_INV = 1'b0,\r
	parameter [0:0] SR_VAL = 1'b0,\r
	parameter [0:0] INIT   = 1'bx\r
)(\r
	input D,\r
	input G,\r
	input SR,\r
	output reg Q\r
);\r
	wire en, sr;\r
	assign en  = (G_INV) ? ~G : G;\r
	assign sr  = (SR_INV) ? ~SR : SR;\r
\r
	initial Q = INIT;\r
\r
	always @(*)\r
	begin\r
		if (sr) begin\r
			Q <= SR_VAL;\r
		end\r
		else if (en) begin\r
			Q <= D;\r
		end\r
	end\r
\r
endmodule\r
\r
\r
module CC_LUT1 (\r
	output O,\r
	input  I0\r
);\r
	parameter [1:0] INIT = 0;\r
\r
	assign O = I0 ? INIT[1] : INIT[0];\r
\r
endmodule\r
\r
\r
module CC_LUT2 (\r
	output O,\r
	input  I0, I1\r
);\r
	parameter [3:0] INIT = 0;\r
\r
	wire [1:0] s1 = I1 ? INIT[3:2] : INIT[1:0];\r
	assign O = I0 ? s1[1] : s1[0];\r
\r
endmodule\r
\r
\r
module CC_LUT3 (\r
	output O,\r
	input  I0, I1, I2\r
);\r
	parameter [7:0] INIT = 0;\r
\r
	wire [3:0] s2 = I2 ? INIT[7:4] : INIT[3:0];\r
	wire [1:0] s1 = I1 ? s2[3:2] : s2[1:0];\r
	assign O = I0 ? s1[1] : s1[0];\r
\r
endmodule\r
\r
\r
module CC_LUT4 (\r
	output O,\r
	input  I0, I1, I2, I3\r
);\r
	parameter [15:0] INIT = 0;\r
\r
	wire [7:0] s3 = I3 ? INIT[15:8] : INIT[7:0];\r
	wire [3:0] s2 = I2 ? s3[7:4] : s3[3:0];\r
	wire [1:0] s1 = I1 ? s2[3:2] : s2[1:0];\r
	assign O = I0 ? s1[1] : s1[0];\r
\r
endmodule\r
\r
\r
module CC_MX2 (\r
	input  D0, D1,\r
	input  S0,\r
	output Y\r
);\r
	assign Y = S0 ? D1 : D0;\r
\r
endmodule\r
\r
\r
module CC_MX4 (\r
	input  D0, D1, D2, D3,\r
	input  S0, S1,\r
	output Y\r
);\r
	assign Y = S1 ? (S0 ? D3 : D2) :\r
					(S0 ? D1 : D0);\r
\r
endmodule\r
\r
\r
module CC_MX8 (\r
	input  D0, D1, D2, D3,\r
	input  D4, D5, D6, D7,\r
	input  S0, S1, S2,\r
	output Y\r
);\r
	assign Y = S2 ? (S1 ? (S0 ? D7 : D6) :\r
						  (S0 ? D5 : D4)) :\r
					(S1 ? (S0 ? D3 : D2) :\r
						  (S0 ? D1 : D0));\r
\r
endmodule\r
\r
\r
module CC_ADDF (\r
	input  A, B, CI,\r
	output CO, S\r
);\r
	assign {CO, S} = A + B + CI;\r
\r
endmodule\r
\r
\r
module CC_MULT #(\r
	parameter A_WIDTH = 0,\r
	parameter B_WIDTH = 0,\r
	parameter P_WIDTH = 0\r
)(\r
	input signed [A_WIDTH-1:0] A,\r
	input signed [B_WIDTH-1:0] B,\r
	output reg signed [P_WIDTH-1:0] P\r
);\r
	always @(*)\r
	begin\r
		P <= A * B;\r
	end\r
endmodule\r
\r
\r
module CC_BUFG (\r
	input  I,\r
	(* clkbuf_driver *)\r
	output O\r
);\r
	assign O = I;\r
\r
endmodule\r
\r
\r
module CC_BRAM_20K (\r
	output [19:0] A_DO,\r
	output [19:0] B_DO,\r
	output ECC_1B_ERR,\r
	output ECC_2B_ERR,\r
	(* clkbuf_sink *)\r
	input A_CLK,\r
	(* clkbuf_sink *)\r
	input B_CLK,\r
	input A_EN,\r
	input B_EN,\r
	input A_WE,\r
	input B_WE,\r
	input [15:0] A_ADDR,\r
	input [15:0] B_ADDR,\r
	input [19:0] A_DI,\r
	input [19:0] B_DI,\r
	input [19:0] A_BM,\r
	input [19:0] B_BM\r
);\r
	// Location format: D(0..N-1)(0..N-1)X(0..3)Y(0..7)Z(0..1) or UNPLACED\r
	parameter LOC = "UNPLACED";\r
\r
	// Port Widths\r
	parameter A_RD_WIDTH = 0;\r
	parameter B_RD_WIDTH = 0;\r
	parameter A_WR_WIDTH = 0;\r
	parameter B_WR_WIDTH = 0;\r
\r
	// RAM and Write Modes\r
	parameter RAM_MODE = "SDP";\r
	parameter A_WR_MODE = "NO_CHANGE";\r
	parameter B_WR_MODE = "NO_CHANGE";\r
\r
	// Inverting Control Pins\r
	parameter A_CLK_INV = 1'b0;\r
	parameter B_CLK_INV = 1'b0;\r
	parameter A_EN_INV = 1'b0;\r
	parameter B_EN_INV = 1'b0;\r
	parameter A_WE_INV = 1'b0;\r
	parameter B_WE_INV = 1'b0;\r
\r
	// Output Register\r
	parameter A_DO_REG = 1'b0;\r
	parameter B_DO_REG = 1'b0;\r
\r
	// Error Checking and Correction\r
	parameter ECC_EN = 1'b0;\r
\r
	// RAM Contents\r
	parameter INIT_00 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_01 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_02 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_03 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_04 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_05 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_06 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_07 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_08 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_09 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_0A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_0B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_0C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_0D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_0E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_0F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_10 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_11 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_12 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_13 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_14 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_15 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_16 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_17 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_18 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_19 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_1A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_1B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_1C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_1D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_1E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_1F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_20 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_21 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_22 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_23 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_24 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_25 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_26 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_27 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_28 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_29 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_2A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_2B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_2C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_2D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_2E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_2F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_30 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_31 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_32 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_33 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_34 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_35 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_36 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_37 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_38 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_39 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_3A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_3B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_3C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_3D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_3E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_3F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
\r
	localparam WIDTH_MODE_A = (A_RD_WIDTH > A_WR_WIDTH) ? A_RD_WIDTH : A_WR_WIDTH;\r
	localparam WIDTH_MODE_B = (B_RD_WIDTH > B_WR_WIDTH) ? B_RD_WIDTH : B_WR_WIDTH;\r
\r
	integer i, k;\r
\r
	// 512 x 40 bit\r
	reg [20479:0] memory = 20480'b0;\r
\r
	initial begin\r
		// Check parameters\r
		if ((RAM_MODE != "SDP") && (RAM_MODE != "TDP")) begin\r
			$display("ERROR: Illegal RAM MODE %d.", RAM_MODE);\r
			$finish();\r
		end\r
		if ((A_WR_MODE != "WRITE_THROUGH") && (A_WR_MODE != "NO_CHANGE")) begin\r
			$display("ERROR: Illegal RAM MODE %d.", RAM_MODE);\r
			$finish();\r
		end\r
		if ((RAM_MODE == "SDP") && (A_WR_MODE == "WRITE_THROUGH")) begin\r
			$display("ERROR: %s is not supported in %s mode.", A_WR_MODE, RAM_MODE);\r
			$finish();\r
		end\r
		if (ECC_EN != 1'b0) begin\r
			$display("WARNING: ECC feature not supported in simulation.");\r
		end\r
		if ((ECC_EN == 1'b1) && (RAM_MODE != "SDP") && (WIDTH_MODE_A != 40)) begin\r
			$display("ERROR: Illegal ECC Port configuration. Must be SDP 40 bit, but is %s %d.", RAM_MODE, WIDTH_MODE_A);\r
			$finish();\r
		end\r
		if ((WIDTH_MODE_A == 40) && (RAM_MODE == "TDP")) begin\r
			$display("ERROR: Port A width of 40 bits is only supported in SDP mode.");\r
			$finish();\r
		end\r
		if ((WIDTH_MODE_B == 40) && (RAM_MODE == "TDP")) begin\r
			$display("ERROR: Port B width of 40 bits is only supported in SDP mode.");\r
			$finish();\r
		end\r
		if ((WIDTH_MODE_A != 40) && (WIDTH_MODE_A != 20) && (WIDTH_MODE_A != 10) &&\r
			(WIDTH_MODE_A != 5)  && (WIDTH_MODE_A != 2)  && (WIDTH_MODE_A != 1) && (WIDTH_MODE_A != 0)) begin\r
			$display("ERROR: Illegal %s Port A width configuration %d.", RAM_MODE, WIDTH_MODE_A);\r
			$finish();\r
		end\r
		if ((WIDTH_MODE_B != 40) && (WIDTH_MODE_B != 20) && (WIDTH_MODE_B != 10) &&\r
			(WIDTH_MODE_B != 5)  && (WIDTH_MODE_B != 2)  && (WIDTH_MODE_B != 1) && (WIDTH_MODE_B != 0)) begin\r
			$display("ERROR: Illegal %s Port B width configuration %d.", RAM_MODE, WIDTH_MODE_B);\r
			$finish();\r
		end\r
		// RAM initialization\r
		memory[320*0+319:320*0]   = INIT_00;\r
		memory[320*1+319:320*1]   = INIT_01;\r
		memory[320*2+319:320*2]   = INIT_02;\r
		memory[320*3+319:320*3]   = INIT_03;\r
		memory[320*4+319:320*4]   = INIT_04;\r
		memory[320*5+319:320*5]   = INIT_05;\r
		memory[320*6+319:320*6]   = INIT_06;\r
		memory[320*7+319:320*7]   = INIT_07;\r
		memory[320*8+319:320*8]   = INIT_08;\r
		memory[320*9+319:320*9]   = INIT_09;\r
		memory[320*10+319:320*10] = INIT_0A;\r
		memory[320*11+319:320*11] = INIT_0B;\r
		memory[320*12+319:320*12] = INIT_0C;\r
		memory[320*13+319:320*13] = INIT_0D;\r
		memory[320*14+319:320*14] = INIT_0E;\r
		memory[320*15+319:320*15] = INIT_0F;\r
		memory[320*16+319:320*16] = INIT_10;\r
		memory[320*17+319:320*17] = INIT_11;\r
		memory[320*18+319:320*18] = INIT_12;\r
		memory[320*19+319:320*19] = INIT_13;\r
		memory[320*20+319:320*20] = INIT_14;\r
		memory[320*21+319:320*21] = INIT_15;\r
		memory[320*22+319:320*22] = INIT_16;\r
		memory[320*23+319:320*23] = INIT_17;\r
		memory[320*24+319:320*24] = INIT_18;\r
		memory[320*25+319:320*25] = INIT_19;\r
		memory[320*26+319:320*26] = INIT_1A;\r
		memory[320*27+319:320*27] = INIT_1B;\r
		memory[320*28+319:320*28] = INIT_1C;\r
		memory[320*29+319:320*29] = INIT_1D;\r
		memory[320*30+319:320*30] = INIT_1E;\r
		memory[320*31+319:320*31] = INIT_1F;\r
		memory[320*32+319:320*32] = INIT_20;\r
		memory[320*33+319:320*33] = INIT_21;\r
		memory[320*34+319:320*34] = INIT_22;\r
		memory[320*35+319:320*35] = INIT_23;\r
		memory[320*36+319:320*36] = INIT_24;\r
		memory[320*37+319:320*37] = INIT_25;\r
		memory[320*38+319:320*38] = INIT_26;\r
		memory[320*39+319:320*39] = INIT_27;\r
		memory[320*40+319:320*40] = INIT_28;\r
		memory[320*41+319:320*41] = INIT_29;\r
		memory[320*42+319:320*42] = INIT_2A;\r
		memory[320*43+319:320*43] = INIT_2B;\r
		memory[320*44+319:320*44] = INIT_2C;\r
		memory[320*45+319:320*45] = INIT_2D;\r
		memory[320*46+319:320*46] = INIT_2E;\r
		memory[320*47+319:320*47] = INIT_2F;\r
		memory[320*48+319:320*48] = INIT_30;\r
		memory[320*49+319:320*49] = INIT_31;\r
		memory[320*50+319:320*50] = INIT_32;\r
		memory[320*51+319:320*51] = INIT_33;\r
		memory[320*52+319:320*52] = INIT_34;\r
		memory[320*53+319:320*53] = INIT_35;\r
		memory[320*54+319:320*54] = INIT_36;\r
		memory[320*55+319:320*55] = INIT_37;\r
		memory[320*56+319:320*56] = INIT_38;\r
		memory[320*57+319:320*57] = INIT_39;\r
		memory[320*58+319:320*58] = INIT_3A;\r
		memory[320*59+319:320*59] = INIT_3B;\r
		memory[320*60+319:320*60] = INIT_3C;\r
		memory[320*61+319:320*61] = INIT_3D;\r
		memory[320*62+319:320*62] = INIT_3E;\r
		memory[320*63+319:320*63] = INIT_3F;\r
	end\r
\r
	// Signal inversion\r
	wire clka = A_CLK_INV ^ A_CLK;\r
	wire clkb = B_CLK_INV ^ B_CLK;\r
	wire ena  = A_EN_INV ^ A_EN;\r
	wire enb  = B_EN_INV ^ B_EN;\r
	wire wea  = A_WE_INV ^ A_WE;\r
	wire web  = B_WE_INV ^ B_WE;\r
\r
	// Internal signals\r
	wire [15:0] addra;\r
	wire [15:0] addrb;\r
	reg  [19:0] A_DO_out = 0, A_DO_reg = 0;\r
	reg  [19:0] B_DO_out = 0, B_DO_reg = 0;\r
\r
	generate\r
		if (RAM_MODE == "SDP") begin\r
			// Port A (write)\r
			if (A_WR_WIDTH == 40) begin\r
				assign addra = A_ADDR[15:7]*40;\r
			end\r
			// Port B (read)\r
			if (B_RD_WIDTH == 40) begin\r
				assign addrb = B_ADDR[15:7]*40;\r
			end\r
		end\r
		else if (RAM_MODE == "TDP") begin\r
			// Port A\r
			if (WIDTH_MODE_A <= 1) begin\r
				wire [15:0] tmpa = {2'b0, A_ADDR[15:7], A_ADDR[5:1]};\r
				assign addra = tmpa + (tmpa/4);\r
			end\r
			else if (WIDTH_MODE_A <= 2) begin\r
				wire [15:0] tmpa = {3'b0, A_ADDR[15:7], A_ADDR[5:2]};\r
				assign addra = tmpa*2 + (tmpa/2);\r
			end\r
			else if (WIDTH_MODE_A <= 5) begin\r
				assign addra = {4'b0, A_ADDR[15:7], A_ADDR[5:3]}*5;\r
			end\r
			else if (WIDTH_MODE_A <= 10) begin\r
				assign addra = {5'b0, A_ADDR[15:7], A_ADDR[5:4]}*10;\r
			end\r
			else if (WIDTH_MODE_A <= 20) begin\r
				assign addra = {6'b0, A_ADDR[15:7], A_ADDR[5]}*20;\r
			end\r
			// Port B\r
			if (WIDTH_MODE_B <= 1) begin\r
				wire [15:0] tmpb = {2'b0, B_ADDR[15:7], B_ADDR[5:1]};\r
				assign addrb = tmpb + (tmpb/4);\r
			end\r
			else if (WIDTH_MODE_B <= 2) begin\r
				wire [15:0] tmpb = {3'b0, B_ADDR[15:7], B_ADDR[5:2]};\r
				assign addrb = tmpb*2 + (tmpb/2);\r
			end\r
			else if (WIDTH_MODE_B <= 5) begin\r
				assign addrb = {4'b0, B_ADDR[15:7], B_ADDR[5:3]}*5;\r
			end\r
			else if (WIDTH_MODE_B <= 10) begin\r
				assign addrb = {5'b0, B_ADDR[15:7], B_ADDR[5:4]}*10;\r
			end\r
			else if (WIDTH_MODE_B <= 20) begin\r
				assign addrb = {6'b0, B_ADDR[15:7], B_ADDR[5]}*20;\r
			end\r
		end\r
	endgenerate\r
\r
	generate\r
		if (RAM_MODE == "SDP") begin\r
			// SDP write port\r
			always @(posedge clka)\r
			begin\r
				for (k=0; k < A_WR_WIDTH; k=k+1) begin\r
					if (k < 20) begin\r
						if (ena && wea && A_BM[k]) memory[addra+k] <= A_DI[k];\r
					end\r
					else begin // use both ports\r
						if (ena && wea && B_BM[k-20]) memory[addra+k] <= B_DI[k-20];\r
					end\r
				end\r
			end\r
			// SDP read port\r
			always @(posedge clkb)\r
			begin\r
				for (k=0; k < B_RD_WIDTH; k=k+1) begin\r
					if (k < 20) begin\r
						if (enb) A_DO_out[k] <= memory[addrb+k];\r
					end\r
					else begin // use both ports\r
						if (enb) B_DO_out[k-20] <= memory[addrb+k];\r
					end\r
				end\r
			end\r
		end\r
		else if (RAM_MODE == "TDP") begin\r
			// TDP port A\r
			always @(posedge clka)\r
			begin\r
				for (i=0; i < WIDTH_MODE_A; i=i+1) begin\r
					if (ena && wea && A_BM[i]) memory[addra+i] <= A_DI[i];\r
\r
					if (A_WR_MODE == "NO_CHANGE") begin\r
						if (ena && !wea) A_DO_out[i] <= memory[addra+i];\r
					end\r
					else if (A_WR_MODE == "WRITE_THROUGH") begin\r
						if (ena) begin\r
							if (wea && A_BM[i]) begin\r
								A_DO_out[i] <= A_DI[i];\r
							end\r
							else begin\r
								A_DO_out[i] <= memory[addra+i];\r
							end\r
						end\r
					end\r
				end\r
			end\r
			// TDP port B\r
			always @(posedge clkb)\r
			begin\r
				for (i=0; i < WIDTH_MODE_B; i=i+1) begin\r
					if (enb && web && B_BM[i]) memory[addrb+i] <= B_DI[i];\r
\r
					if (B_WR_MODE == "NO_CHANGE") begin\r
						if (enb && !web) B_DO_out[i] <= memory[addrb+i];\r
					end\r
					else if (B_WR_MODE == "WRITE_THROUGH") begin\r
						if (enb) begin\r
							if (web && B_BM[i]) begin\r
								B_DO_out[i] <= B_DI[i];\r
							end\r
							else begin\r
								B_DO_out[i] <= memory[addrb+i];\r
							end\r
						end\r
					end\r
				end\r
			end\r
		end\r
	endgenerate\r
\r
	// Optional output register\r
	generate\r
		if (A_DO_REG) begin\r
			always @(posedge clka) begin\r
				A_DO_reg <= A_DO_out;\r
			end\r
			assign A_DO = A_DO_reg;\r
		end\r
		else begin\r
			assign A_DO = A_DO_out;\r
		end\r
		if (B_DO_REG) begin\r
			always @(posedge clkb) begin\r
				B_DO_reg <= B_DO_out;\r
			end\r
			assign B_DO = B_DO_reg;\r
		end\r
		else begin\r
			assign B_DO = B_DO_out;\r
		end\r
	endgenerate\r
endmodule\r
\r
\r
module CC_BRAM_40K (\r
	output [39:0] A_DO,\r
	output [39:0] B_DO,\r
	output A_ECC_1B_ERR,\r
	output B_ECC_1B_ERR,\r
	output A_ECC_2B_ERR,\r
	output B_ECC_2B_ERR,\r
	output reg A_CO = 0,\r
	output reg B_CO = 0,\r
	(* clkbuf_sink *)\r
	input A_CLK,\r
	(* clkbuf_sink *)\r
	input B_CLK,\r
	input A_EN,\r
	input B_EN,\r
	input A_WE,\r
	input B_WE,\r
	input [15:0] A_ADDR,\r
	input [15:0] B_ADDR,\r
	input [39:0] A_DI,\r
	input [39:0] B_DI,\r
	input [39:0] A_BM,\r
	input [39:0] B_BM,\r
	input A_CI,\r
	input B_CI\r
);\r
	// Location format: D(0..N-1)X(0..3)Y(0..7) or UNPLACED\r
	parameter LOC = "UNPLACED";\r
	parameter CAS = "NONE"; // NONE, UPPER, LOWER\r
\r
	// Port Widths\r
	parameter A_RD_WIDTH = 0;\r
	parameter B_RD_WIDTH = 0;\r
	parameter A_WR_WIDTH = 0;\r
	parameter B_WR_WIDTH = 0;\r
\r
	// RAM and Write Modes\r
	parameter RAM_MODE = "SDP";\r
	parameter A_WR_MODE = "NO_CHANGE";\r
	parameter B_WR_MODE = "NO_CHANGE";\r
\r
	// Inverting Control Pins\r
	parameter A_CLK_INV = 1'b0;\r
	parameter B_CLK_INV = 1'b0;\r
	parameter A_EN_INV = 1'b0;\r
	parameter B_EN_INV = 1'b0;\r
	parameter A_WE_INV = 1'b0;\r
	parameter B_WE_INV = 1'b0;\r
\r
	// Output Register\r
	parameter A_DO_REG = 1'b0;\r
	parameter B_DO_REG = 1'b0;\r
\r
	// Error Checking and Correction\r
	parameter A_ECC_EN  = 1'b0;\r
	parameter B_ECC_EN  = 1'b0;\r
\r
	parameter INIT_00 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_01 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_02 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_03 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_04 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_05 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_06 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_07 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_08 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_09 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_0A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_0B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_0C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_0D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_0E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_0F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_10 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_11 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_12 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_13 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_14 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_15 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_16 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_17 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_18 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_19 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_1A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_1B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_1C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_1D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_1E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_1F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_20 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_21 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_22 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_23 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_24 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_25 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_26 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_27 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_28 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_29 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_2A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_2B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_2C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_2D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_2E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_2F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_30 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_31 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_32 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_33 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_34 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_35 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_36 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_37 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_38 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_39 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_3A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_3B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_3C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_3D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_3E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_3F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_40 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_41 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_42 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_43 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_44 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_45 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_46 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_47 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_48 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_49 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_4A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_4B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_4C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_4D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_4E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_4F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_50 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_51 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_52 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_53 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_54 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_55 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_56 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_57 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_58 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_59 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_5A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_5B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_5C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_5D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_5E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_5F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_60 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_61 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_62 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_63 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_64 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_65 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_66 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_67 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_68 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_69 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_6A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_6B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_6C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_6D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_6E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_6F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_70 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_71 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_72 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_73 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_74 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_75 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_76 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_77 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_78 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_79 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_7A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_7B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_7C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_7D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_7E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
	parameter INIT_7F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\r
\r
	localparam WIDTH_MODE_A = (A_RD_WIDTH > A_WR_WIDTH) ? A_RD_WIDTH : A_WR_WIDTH;\r
	localparam WIDTH_MODE_B = (B_RD_WIDTH > B_WR_WIDTH) ? B_RD_WIDTH : B_WR_WIDTH;\r
\r
	integer i, k;\r
\r
	// 512 x 80 bit\r
	reg [40959:0] memory = 40960'b0;\r
\r
	initial begin\r
		// Check parameters\r
		if ((RAM_MODE != "SDP") && (RAM_MODE != "TDP")) begin\r
			$display("ERROR: Illegal RAM MODE %d.", RAM_MODE);\r
			$finish();\r
		end\r
		if ((A_WR_MODE != "WRITE_THROUGH") && (A_WR_MODE != "NO_CHANGE")) begin\r
			$display("ERROR: Illegal RAM MODE %d.", RAM_MODE);\r
			$finish();\r
		end\r
		if ((RAM_MODE == "SDP") && (A_WR_MODE == "WRITE_THROUGH")) begin\r
			$display("ERROR: %s is not supported in %s mode.", A_WR_MODE, RAM_MODE);\r
			$finish();\r
		end\r
		if ((A_ECC_EN != 1'b0) || (B_ECC_EN != 1'b0)) begin\r
			$display("WARNING: ECC feature not supported in simulation.");\r
		end\r
		if ((A_ECC_EN == 1'b1) && (RAM_MODE != "SDP") && (WIDTH_MODE_A != 40)) begin\r
			$display("ERROR: Illegal ECC Port A configuration. Must be SDP 40 bit, but is %s %d.", RAM_MODE, WIDTH_MODE_A);\r
			$finish();\r
		end\r
		if ((WIDTH_MODE_A == 80) && (RAM_MODE == "TDP")) begin\r
			$display("ERROR: Port A width of 80 bits is only supported in SDP mode.");\r
			$finish();\r
		end\r
		if ((WIDTH_MODE_B == 80) && (RAM_MODE == "TDP")) begin\r
			$display("ERROR: Port B width of 80 bits is only supported in SDP mode.");\r
			$finish();\r
		end\r
		if ((WIDTH_MODE_A != 80) && (WIDTH_MODE_A != 40) && (WIDTH_MODE_A != 20) && (WIDTH_MODE_A != 10) &&\r
			(WIDTH_MODE_A != 5)  && (WIDTH_MODE_A != 2)  && (WIDTH_MODE_A != 1) && (WIDTH_MODE_A != 0)) begin\r
			$display("ERROR: Illegal %s Port A width configuration %d.", RAM_MODE, WIDTH_MODE_A);\r
			$finish();\r
		end\r
		if ((WIDTH_MODE_B != 80) && (WIDTH_MODE_B != 40) && (WIDTH_MODE_B != 20) && (WIDTH_MODE_B != 10) &&\r
			(WIDTH_MODE_B != 5)  && (WIDTH_MODE_B != 2)  && (WIDTH_MODE_B != 1) && (WIDTH_MODE_B != 0)) begin\r
			$display("ERROR: Illegal %s Port B width configuration %d.", RAM_MODE, WIDTH_MODE_B);\r
			$finish();\r
		end\r
		if ((CAS != "NONE") && ((WIDTH_MODE_A > 1) || (WIDTH_MODE_B > 1))) begin\r
			$display("ERROR: Cascade feature only supported in 1 bit data width mode.");\r
			$finish();\r
		end\r
		if ((CAS != "NONE") && (RAM_MODE != "TDP")) begin\r
			$display("ERROR: Cascade feature only supported in TDP mode.");\r
			$finish();\r
		end\r
		// RAM initialization\r
		memory[320*0+319:320*0]     = INIT_00;\r
		memory[320*1+319:320*1]     = INIT_01;\r
		memory[320*2+319:320*2]     = INIT_02;\r
		memory[320*3+319:320*3]     = INIT_03;\r
		memory[320*4+319:320*4]     = INIT_04;\r
		memory[320*5+319:320*5]     = INIT_05;\r
		memory[320*6+319:320*6]     = INIT_06;\r
		memory[320*7+319:320*7]     = INIT_07;\r
		memory[320*8+319:320*8]     = INIT_08;\r
		memory[320*9+319:320*9]     = INIT_09;\r
		memory[320*10+319:320*10]   = INIT_0A;\r
		memory[320*11+319:320*11]   = INIT_0B;\r
		memory[320*12+319:320*12]   = INIT_0C;\r
		memory[320*13+319:320*13]   = INIT_0D;\r
		memory[320*14+319:320*14]   = INIT_0E;\r
		memory[320*15+319:320*15]   = INIT_0F;\r
		memory[320*16+319:320*16]   = INIT_10;\r
		memory[320*17+319:320*17]   = INIT_11;\r
		memory[320*18+319:320*18]   = INIT_12;\r
		memory[320*19+319:320*19]   = INIT_13;\r
		memory[320*20+319:320*20]   = INIT_14;\r
		memory[320*21+319:320*21]   = INIT_15;\r
		memory[320*22+319:320*22]   = INIT_16;\r
		memory[320*23+319:320*23]   = INIT_17;\r
		memory[320*24+319:320*24]   = INIT_18;\r
		memory[320*25+319:320*25]   = INIT_19;\r
		memory[320*26+319:320*26]   = INIT_1A;\r
		memory[320*27+319:320*27]   = INIT_1B;\r
		memory[320*28+319:320*28]   = INIT_1C;\r
		memory[320*29+319:320*29]   = INIT_1D;\r
		memory[320*30+319:320*30]   = INIT_1E;\r
		memory[320*31+319:320*31]   = INIT_1F;\r
		memory[320*32+319:320*32]   = INIT_20;\r
		memory[320*33+319:320*33]   = INIT_21;\r
		memory[320*34+319:320*34]   = INIT_22;\r
		memory[320*35+319:320*35]   = INIT_23;\r
		memory[320*36+319:320*36]   = INIT_24;\r
		memory[320*37+319:320*37]   = INIT_25;\r
		memory[320*38+319:320*38]   = INIT_26;\r
		memory[320*39+319:320*39]   = INIT_27;\r
		memory[320*40+319:320*40]   = INIT_28;\r
		memory[320*41+319:320*41]   = INIT_29;\r
		memory[320*42+319:320*42]   = INIT_2A;\r
		memory[320*43+319:320*43]   = INIT_2B;\r
		memory[320*44+319:320*44]   = INIT_2C;\r
		memory[320*45+319:320*45]   = INIT_2D;\r
		memory[320*46+319:320*46]   = INIT_2E;\r
		memory[320*47+319:320*47]   = INIT_2F;\r
		memory[320*48+319:320*48]   = INIT_30;\r
		memory[320*49+319:320*49]   = INIT_31;\r
		memory[320*50+319:320*50]   = INIT_32;\r
		memory[320*51+319:320*51]   = INIT_33;\r
		memory[320*52+319:320*52]   = INIT_34;\r
		memory[320*53+319:320*53]   = INIT_35;\r
		memory[320*54+319:320*54]   = INIT_36;\r
		memory[320*55+319:320*55]   = INIT_37;\r
		memory[320*56+319:320*56]   = INIT_38;\r
		memory[320*57+319:320*57]   = INIT_39;\r
		memory[320*58+319:320*58]   = INIT_3A;\r
		memory[320*59+319:320*59]   = INIT_3B;\r
		memory[320*60+319:320*60]   = INIT_3C;\r
		memory[320*61+319:320*61]   = INIT_3D;\r
		memory[320*62+319:320*62]   = INIT_3E;\r
		memory[320*63+319:320*63]   = INIT_3F;\r
		memory[320*64+319:320*64]   = INIT_40;\r
		memory[320*65+319:320*65]   = INIT_41;\r
		memory[320*66+319:320*66]   = INIT_42;\r
		memory[320*67+319:320*67]   = INIT_43;\r
		memory[320*68+319:320*68]   = INIT_44;\r
		memory[320*69+319:320*69]   = INIT_45;\r
		memory[320*70+319:320*70]   = INIT_46;\r
		memory[320*71+319:320*71]   = INIT_47;\r
		memory[320*72+319:320*72]   = INIT_48;\r
		memory[320*73+319:320*73]   = INIT_49;\r
		memory[320*74+319:320*74]   = INIT_4A;\r
		memory[320*75+319:320*75]   = INIT_4B;\r
		memory[320*76+319:320*76]   = INIT_4C;\r
		memory[320*77+319:320*77]   = INIT_4D;\r
		memory[320*78+319:320*78]   = INIT_4E;\r
		memory[320*79+319:320*79]   = INIT_4F;\r
		memory[320*80+319:320*80]   = INIT_50;\r
		memory[320*81+319:320*81]   = INIT_51;\r
		memory[320*82+319:320*82]   = INIT_52;\r
		memory[320*83+319:320*83]   = INIT_53;\r
		memory[320*84+319:320*84]   = INIT_54;\r
		memory[320*85+319:320*85]   = INIT_55;\r
		memory[320*86+319:320*86]   = INIT_56;\r
		memory[320*87+319:320*87]   = INIT_57;\r
		memory[320*88+319:320*88]   = INIT_58;\r
		memory[320*89+319:320*89]   = INIT_59;\r
		memory[320*90+319:320*90]   = INIT_5A;\r
		memory[320*91+319:320*91]   = INIT_5B;\r
		memory[320*92+319:320*92]   = INIT_5C;\r
		memory[320*93+319:320*93]   = INIT_5D;\r
		memory[320*94+319:320*94]   = INIT_5E;\r
		memory[320*95+319:320*95]   = INIT_5F;\r
		memory[320*96+319:320*96]   = INIT_60;\r
		memory[320*97+319:320*97]   = INIT_61;\r
		memory[320*98+319:320*98]   = INIT_62;\r
		memory[320*99+319:320*99]   = INIT_63;\r
		memory[320*100+319:320*100] = INIT_64;\r
		memory[320*101+319:320*101] = INIT_65;\r
		memory[320*102+319:320*102] = INIT_66;\r
		memory[320*103+319:320*103] = INIT_67;\r
		memory[320*104+319:320*104] = INIT_68;\r
		memory[320*105+319:320*105] = INIT_69;\r
		memory[320*106+319:320*106] = INIT_6A;\r
		memory[320*107+319:320*107] = INIT_6B;\r
		memory[320*108+319:320*108] = INIT_6C;\r
		memory[320*109+319:320*109] = INIT_6D;\r
		memory[320*110+319:320*110] = INIT_6E;\r
		memory[320*111+319:320*111] = INIT_6F;\r
		memory[320*112+319:320*112] = INIT_70;\r
		memory[320*113+319:320*113] = INIT_71;\r
		memory[320*114+319:320*114] = INIT_72;\r
		memory[320*115+319:320*115] = INIT_73;\r
		memory[320*116+319:320*116] = INIT_74;\r
		memory[320*117+319:320*117] = INIT_75;\r
		memory[320*118+319:320*118] = INIT_76;\r
		memory[320*119+319:320*119] = INIT_77;\r
		memory[320*120+319:320*120] = INIT_78;\r
		memory[320*121+319:320*121] = INIT_79;\r
		memory[320*122+319:320*122] = INIT_7A;\r
		memory[320*123+319:320*123] = INIT_7B;\r
		memory[320*124+319:320*124] = INIT_7C;\r
		memory[320*125+319:320*125] = INIT_7D;\r
		memory[320*126+319:320*126] = INIT_7E;\r
		memory[320*127+319:320*127] = INIT_7F;\r
	end\r
\r
	// Signal inversion\r
	wire clka = A_CLK_INV ^ A_CLK;\r
	wire clkb = B_CLK_INV ^ B_CLK;\r
	wire ena  = A_EN_INV ^ A_EN;\r
	wire enb  = B_EN_INV ^ B_EN;\r
	wire wea  = A_WE_INV ^ A_WE;\r
	wire web  = B_WE_INV ^ B_WE;\r
\r
	// Internal signals\r
	wire [15:0] addra;\r
	wire [15:0] addrb;\r
	reg  [39:0] A_DO_out = 0, A_DO_reg = 0;\r
	reg  [39:0] B_DO_out = 0, B_DO_reg = 0;\r
\r
	generate\r
		if (RAM_MODE == "SDP") begin\r
			// Port A (write)\r
			 if (A_WR_WIDTH == 80) begin\r
				assign addra = A_ADDR[15:7]*80;\r
			end\r
			// Port B (read)\r
			if (B_RD_WIDTH == 80) begin\r
				assign addrb = B_ADDR[15:7]*80;\r
			end\r
		end\r
		else if (RAM_MODE == "TDP") begin\r
			// Port A\r
			if (WIDTH_MODE_A <= 1) begin\r
				wire [15:0] tmpa = {1'b0, A_ADDR[15:1]};\r
				assign addra = tmpa + (tmpa/4);\r
			end\r
			else if (WIDTH_MODE_A <= 2) begin\r
				wire [15:0] tmpa = {2'b0, A_ADDR[15:2]};\r
				assign addra = tmpa*2 + (tmpa/2);\r
			end\r
			else if (WIDTH_MODE_A <= 5) begin\r
				assign addra = {3'b0, A_ADDR[15:3]}*5;\r
			end\r
			else if (WIDTH_MODE_A <= 10) begin\r
				assign addra = {4'b0, A_ADDR[15:4]}*10;\r
			end\r
			else if (WIDTH_MODE_A <= 20) begin\r
				assign addra = {5'b0, A_ADDR[15:5]}*20;\r
			end\r
			else if (WIDTH_MODE_A <= 40) begin\r
				assign addra = {6'b0, A_ADDR[15:6]}*40;\r
			end\r
			// Port B\r
			if (WIDTH_MODE_B <= 1) begin\r
				wire [15:0] tmpb = {1'b0, B_ADDR[15:1]};\r
				assign addrb = tmpb + (tmpb/4);\r
			end\r
			else if (WIDTH_MODE_B <= 2) begin\r
				wire [15:0] tmpb = {2'b0, B_ADDR[15:2]};\r
				assign addrb = tmpb*2 + (tmpb/2);\r
			end\r
			else if (WIDTH_MODE_B <= 5) begin\r
				assign addrb = {3'b0, B_ADDR[15:3]}*5;\r
			end\r
			else if (WIDTH_MODE_B <= 10) begin\r
				assign addrb = {4'b0, B_ADDR[15:4]}*10;\r
			end\r
			else if (WIDTH_MODE_B <= 20) begin\r
				assign addrb = {5'b0, B_ADDR[15:5]}*20;\r
			end\r
			else if (WIDTH_MODE_B <= 40) begin\r
				assign addrb = {6'b0, B_ADDR[15:6]}*40;\r
			end\r
		end\r
	endgenerate\r
\r
	generate\r
		if (RAM_MODE == "SDP") begin\r
			// SDP write port\r
			always @(posedge clka)\r
			begin\r
				for (k=0; k < A_WR_WIDTH; k=k+1) begin\r
					if (k < 40) begin\r
						if (ena && wea && A_BM[k]) memory[addra+k] <= A_DI[k];\r
					end\r
					else begin // use both ports\r
						if (ena && wea && B_BM[k-40]) memory[addra+k] <= B_DI[k-40];\r
					end\r
				end\r
			end\r
			// SDP read port\r
			always @(posedge clkb)\r
			begin\r
				for (k=0; k < B_RD_WIDTH; k=k+1) begin\r
					if (k < 40) begin\r
						if (enb) A_DO_out[k] <= memory[addrb+k];\r
					end\r
					else begin // use both ports\r
						if (enb) B_DO_out[k-40] <= memory[addrb+k];\r
					end\r
				end\r
			end\r
		end\r
		else if (RAM_MODE == "TDP") begin\r
			// {A,B}_ADDR[0]=0 selects lower, {A,B}_ADDR[0]=1 selects upper cascade memory\r
			wire upper_sel_a = ((CAS == "UPPER") && (A_ADDR[0] == 1));\r
			wire lower_sel_a = ((CAS == "LOWER") && (A_ADDR[0] == 0));\r
			wire upper_sel_b = ((CAS == "UPPER") && (B_ADDR[0] == 1));\r
			wire lower_sel_b = ((CAS == "LOWER") && (B_ADDR[0] == 0));\r
\r
			reg dumm;\r
\r
			// Cascade output port A\r
			always @(*)\r
			begin\r
				if ((A_WR_MODE == "NO_CHANGE") && lower_sel_a) begin\r
					A_CO = memory[addra];\r
				end\r
				else if ((A_WR_MODE == "WRITE_THROUGH") && lower_sel_a) begin\r
					A_CO = ((wea && A_BM[0]) ? (A_DI[0]) : (memory[addra]));\r
				end\r
			end\r
\r
			// Cascade output port B\r
			always @(*)\r
			begin\r
				if ((B_WR_MODE == "NO_CHANGE") && lower_sel_b) begin\r
					B_CO = memory[addrb];\r
				end\r
				else if ((B_WR_MODE == "WRITE_THROUGH") && lower_sel_b) begin\r
					B_CO = ((web && B_BM[0]) ? (B_DI[0]) : (memory[addrb]));\r
				end\r
			end\r
\r
			// TDP port A\r
			always @(posedge clka)\r
			begin\r
				for (i=0; i < WIDTH_MODE_A; i=i+1) begin\r
					if (upper_sel_a || lower_sel_a || (CAS == "NONE")) begin\r
						if (ena && wea && A_BM[i])\r
							memory[addra+i] <= A_DI[i];\r
					end\r
\r
					if (A_WR_MODE == "NO_CHANGE") begin\r
						if (ena && !wea) begin\r
							if (CAS == "UPPER") begin\r
								A_DO_out[i] <= ((A_ADDR[0] == 1) ? (memory[addra+i]) : (A_CI));\r
							end\r
							else if (CAS == "NONE") begin\r
								A_DO_out[i] <= memory[addra+i];\r
							end\r
						end\r
					end\r
					else if (A_WR_MODE == "WRITE_THROUGH") begin\r
						if (ena) begin\r
							if (CAS == "UPPER") begin\r
								if (A_ADDR[0] == 1) begin\r
									A_DO_out[i] <= ((wea && A_BM[i]) ? (A_DI[i]) : (memory[addra+i]));\r
								end else begin\r
									A_DO_out[i] <= A_CI;\r
								end\r
							end\r
							else if (CAS == "NONE") begin\r
								A_DO_out[i] <= ((wea && A_BM[i]) ? (A_DI[i]) : (memory[addra+i]));\r
							end\r
						end\r
					end\r
				end\r
			end\r
			// TDP port B\r
			always @(posedge clkb)\r
			begin\r
				for (i=0; i < WIDTH_MODE_B; i=i+1) begin\r
					if (upper_sel_b || lower_sel_b || (CAS == "NONE")) begin\r
						if (enb && web && B_BM[i])\r
							memory[addrb+i] <= B_DI[i];\r
					end\r
\r
					if (B_WR_MODE == "NO_CHANGE") begin\r
						if (enb && !web) begin\r
							if (CAS == "UPPER") begin\r
								B_DO_out[i] <= ((B_ADDR[0] == 1) ? (memory[addrb+i]) : (B_CI));\r
							end\r
							else if (CAS == "NONE") begin\r
								B_DO_out[i] <= memory[addrb+i];\r
							end\r
						end\r
					end\r
					else if (B_WR_MODE == "WRITE_THROUGH") begin\r
						if (enb) begin\r
							if (CAS == "UPPER") begin\r
								if (B_ADDR[0] == 1) begin\r
									B_DO_out[i] <= ((web && B_BM[i]) ? (B_DI[i]) : (memory[addrb+i]));\r
								end else begin\r
									B_DO_out[i] <= B_CI;\r
								end\r
							end\r
							else if (CAS == "NONE") begin\r
								B_DO_out[i] <= ((web && B_BM[i]) ? (B_DI[i]) : (memory[addrb+i]));\r
							end\r
						end\r
					end\r
				end\r
			end\r
		end\r
	endgenerate\r
\r
	// Optional output register\r
	generate\r
		if (A_DO_REG) begin\r
			always @(posedge clka) begin\r
				A_DO_reg <= A_DO_out;\r
			end\r
			assign A_DO = A_DO_reg;\r
		end\r
		else begin\r
			assign A_DO = A_DO_out;\r
		end\r
		if (B_DO_REG) begin\r
			always @(posedge clkb) begin\r
				B_DO_reg <= B_DO_out;\r
			end\r
			assign B_DO = B_DO_reg;\r
		end\r
		else begin\r
			assign B_DO = B_DO_out;\r
		end\r
	endgenerate\r
endmodule\r
\r
module CC_FIFO_40K (\r
	output A_ECC_1B_ERR,\r
	output B_ECC_1B_ERR,\r
	output A_ECC_2B_ERR,\r
	output B_ECC_2B_ERR,\r
	// FIFO pop port\r
	output [39:0] A_DO,\r
	output [39:0] B_DO,\r
	(* clkbuf_sink *)\r
	input  A_CLK,\r
	input  A_EN,\r
	// FIFO push port\r
	input  [39:0] A_DI,\r
	input  [39:0] B_DI,\r
	input  [39:0] A_BM,\r
	input  [39:0] B_BM,\r
	(* clkbuf_sink *)\r
	input  B_CLK,\r
	input  B_EN,\r
	input  B_WE,\r
	// FIFO control\r
	input  F_RST_N,\r
	input  [14:0] F_ALMOST_FULL_OFFSET,\r
	input  [14:0] F_ALMOST_EMPTY_OFFSET,\r
	// FIFO status signals\r
	output F_FULL,\r
	output F_EMPTY,\r
	output F_ALMOST_FULL,\r
	output F_ALMOST_EMPTY,\r
	output F_RD_ERROR,\r
	output F_WR_ERROR,\r
	output [15:0] F_RD_PTR,\r
	output [15:0] F_WR_PTR\r
);\r
	// Location format: D(0..N-1)X(0..3)Y(0..7) or UNPLACED\r
	parameter LOC = "UNPLACED";\r
\r
	// Offset configuration\r
	parameter DYN_STAT_SELECT = 1'b0;\r
	parameter [14:0] ALMOST_FULL_OFFSET = 15'b0;\r
	parameter [14:0] ALMOST_EMPTY_OFFSET = 15'b0;\r
\r
	// Port Widths\r
	parameter A_WIDTH = 0;\r
	parameter B_WIDTH = 0;\r
\r
	// RAM and Write Modes\r
	parameter RAM_MODE = "TDP"; // "TDP" or "SDP"\r
	parameter FIFO_MODE = "SYNC"; // "ASYNC" or "SYNC"\r
\r
	// Inverting Control Pins\r
	parameter A_CLK_INV = 1'b0;\r
	parameter B_CLK_INV = 1'b0;\r
	parameter A_EN_INV = 1'b0;\r
	parameter B_EN_INV = 1'b0;\r
	parameter A_WE_INV = 1'b0;\r
	parameter B_WE_INV = 1'b0;\r
\r
	// Output Register\r
	parameter A_DO_REG = 1'b0;\r
	parameter B_DO_REG = 1'b0;\r
\r
	// Error Checking and Correction\r
	parameter A_ECC_EN  = 1'b0;\r
	parameter B_ECC_EN  = 1'b0;\r
\r
	integer i, k;\r
\r
	// 512 x 80 bit\r
	reg [40959:0] memory = 40960'b0;\r
\r
	reg [15:0] counter_max;\r
	reg [15:0] sram_depth;\r
	localparam tp = (A_WIDTH ==  1) ? 15 :\r
					(A_WIDTH ==  2) ? 14 :\r
					(A_WIDTH ==  5) ? 13 :\r
					(A_WIDTH == 10) ? 12 :\r
					(A_WIDTH == 20) ? 11 :\r
					(A_WIDTH == 40) ? 10 : 9;\r
\r
	initial begin\r
		// Check parameters\r
		if ((RAM_MODE != "SDP") && (RAM_MODE != "TDP")) begin\r
			$display("ERROR: Illegal RAM MODE %d.", RAM_MODE);\r
			$finish();\r
		end\r
		if ((FIFO_MODE != "ASYNC") && (FIFO_MODE != "SYNC")) begin\r
			$display("ERROR: Illegal FIFO MODE %d.", FIFO_MODE);\r
			$finish();\r
		end\r
		if ((RAM_MODE == "SDP") && (DYN_STAT_SELECT == 1)) begin\r
			$display("ERROR: Dynamic offset configuration is not supported in %s mode.", RAM_MODE);\r
			$finish();\r
		end\r
		if ((RAM_MODE == "SDP") && ((A_WIDTH != 80) || (B_WIDTH != 80))) begin\r
			$display("ERROR: SDP is ony supported in 80 bit mode.");\r
			$finish();\r
		end\r
		if ((A_WIDTH == 80) && (RAM_MODE == "TDP")) begin\r
			$display("ERROR: Port A width of 80 bits is only supported in SDP mode.");\r
			$finish();\r
		end\r
		if ((B_WIDTH == 80) && (RAM_MODE == "TDP")) begin\r
			$display("ERROR: Port B width of 80 bits is only supported in SDP mode.");\r
			$finish();\r
		end\r
		if ((A_WIDTH != 80) && (A_WIDTH != 40) && (A_WIDTH != 20) && (A_WIDTH != 10) &&\r
			(A_WIDTH != 5)  && (A_WIDTH != 2)  && (A_WIDTH != 1) && (A_WIDTH != 0)) begin\r
			$display("ERROR: Illegal %s Port A width configuration %d.", RAM_MODE, A_WIDTH);\r
			$finish();\r
		end\r
		if ((B_WIDTH != 80) && (B_WIDTH != 40) && (B_WIDTH != 20) && (B_WIDTH != 10) &&\r
			(B_WIDTH != 5)  && (B_WIDTH != 2)  && (B_WIDTH != 1) && (B_WIDTH != 0)) begin\r
			$display("ERROR: Illegal %s Port B width configuration %d.", RAM_MODE, B_WIDTH);\r
			$finish();\r
		end\r
		if (A_WIDTH != B_WIDTH) begin\r
			$display("ERROR: The values of A_WIDTH and B_WIDTH must be equal.");\r
		end\r
		if ((A_ECC_EN == 1'b1) && (RAM_MODE != "SDP") && (A_WIDTH != 40)) begin\r
			$display("ERROR: Illegal ECC Port A configuration. ECC mode requires TDP >=40 bit or SDP 80 bit, but is %s %d.", RAM_MODE, A_WIDTH);\r
			$finish();\r
		end\r
		// Set local parameters\r
		if (A_WIDTH == 1) begin // A_WIDTH=B_WIDTH\r
			counter_max = 2 * 32*1024 - 1;\r
			sram_depth  =     32*1024;\r
		end\r
		else if (A_WIDTH == 2) begin\r
			counter_max = 2 * 16*1024 - 1;\r
			sram_depth  =     16*1024;\r
		end\r
		else if (A_WIDTH == 5) begin\r
			counter_max = 2 * 8*1024 - 1;\r
			sram_depth  =     8*1024;\r
		end\r
		else if (A_WIDTH == 10) begin\r
			counter_max = 2 * 4*1024 - 1;\r
			sram_depth  =     4*1024;\r
		end\r
		else if (A_WIDTH == 20) begin\r
			counter_max = 2 * 2*1024 - 1;\r
			sram_depth  =     2*1024;\r
		end\r
		else if (A_WIDTH == 40) begin\r
			counter_max = 2 * 1*1024 - 1;\r
			sram_depth  =     1*1024;\r
		end\r
		else begin // 80 bit SDP\r
			counter_max = 2 * 512 - 1;\r
			sram_depth  =     512;\r
		end\r
	end\r
\r
	// Internal signals\r
	wire fifo_rdclk = A_CLK ^ A_CLK_INV;\r
	wire fifo_wrclk = (FIFO_MODE == "ASYNC") ? (B_CLK ^ B_CLK_INV) : (A_CLK ^ A_CLK_INV);\r
	wire [15:0] almost_full_offset  = DYN_STAT_SELECT ? F_ALMOST_FULL_OFFSET  : ALMOST_FULL_OFFSET;\r
	wire [15:0] almost_empty_offset = DYN_STAT_SELECT ? F_ALMOST_EMPTY_OFFSET : ALMOST_EMPTY_OFFSET;\r
	reg  [39:0] A_DO_out = 0, A_DO_reg = 0;\r
	reg  [39:0] B_DO_out = 0, B_DO_reg = 0;\r
\r
	// Status signals\r
	reg fifo_full;\r
	reg fifo_empty;\r
	reg fifo_almost_full;\r
	reg fifo_almost_empty;\r
	assign F_FULL         = fifo_full;\r
	assign F_EMPTY        = fifo_empty;\r
	assign F_ALMOST_FULL  = fifo_almost_full;\r
	assign F_ALMOST_EMPTY = fifo_almost_empty;\r
	assign F_WR_ERROR     = (F_FULL && (B_EN ^ B_EN_INV) && (B_WE ^ B_WE_INV));\r
	assign F_RD_ERROR     = (F_EMPTY && (A_EN ^ A_EN_INV));\r
	wire ram_we = (~F_FULL  && (B_EN ^ B_EN_INV) && (B_WE ^ B_WE_INV));\r
	wire ram_en = (~F_EMPTY && (A_EN ^ A_EN_INV));\r
\r
	// Reset synchronizers\r
	reg  [1:0] aclk_reset_q, bclk_reset_q;\r
	wire fifo_sync_rstn    = aclk_reset_q;\r
	wire fifo_async_wrrstn = bclk_reset_q;\r
	wire fifo_async_rdrstn = aclk_reset_q;\r
\r
	always @(posedge fifo_rdclk or negedge F_RST_N)\r
	begin\r
		if (F_RST_N == 1'b0) begin\r
			aclk_reset_q <= 2'b0;\r
		end\r
		else begin\r
			aclk_reset_q[1] <= aclk_reset_q[0];\r
			aclk_reset_q[0] <= 1'b1;\r
		end\r
	end\r
\r
	always @(posedge fifo_wrclk or negedge F_RST_N)\r
	begin\r
		if (F_RST_N == 1'b0) begin\r
			bclk_reset_q <= 2'b0;\r
		end\r
		else begin\r
			bclk_reset_q[1] <= bclk_reset_q[0];\r
			bclk_reset_q[0] <= 1'b1;\r
		end\r
	end\r
\r
	// Push/pop pointers\r
	reg  [15:0] rd_pointer, rd_pointer_int;\r
	reg  [15:0] wr_pointer, wr_pointer_int;\r
	reg  [15:0] rd_pointer_cmp, wr_pointer_cmp;\r
	wire [15:0] rd_pointer_nxt;\r
	wire [15:0] wr_pointer_nxt;\r
	reg  [15:0] fifo_rdaddr, rdaddr;\r
	reg  [15:0] fifo_wraddr, wraddr;\r
	assign F_RD_PTR = fifo_rdaddr;\r
	assign F_WR_PTR = fifo_wraddr;\r
\r
	always @(posedge fifo_rdclk or negedge F_RST_N)\r
	begin\r
		if (F_RST_N == 1'b0) begin\r
			rd_pointer <= 0;\r
			rd_pointer_int <= 0;\r
		end\r
		else if (ram_en) begin\r
			rd_pointer <= rd_pointer_nxt;\r
			rd_pointer_int <= rd_pointer_nxt[15:1] ^ rd_pointer_nxt[14:0];\r
		end\r
	end\r
\r
	assign rd_pointer_nxt = (rd_pointer == counter_max) ? (0) : (rd_pointer + 1'b1);\r
\r
	always @(posedge fifo_wrclk or negedge F_RST_N)\r
	begin\r
		if (F_RST_N == 1'b0) begin\r
			wr_pointer <= 0;\r
			wr_pointer_int <= 0;\r
		end\r
		else if (ram_we) begin\r
			wr_pointer <= wr_pointer_nxt;\r
			wr_pointer_int <= wr_pointer_nxt[15:1] ^ wr_pointer_nxt[14:0];\r
		end\r
	end\r
\r
	assign wr_pointer_nxt = (wr_pointer == counter_max) ? (0) : (wr_pointer + 1'b1);\r
\r
	// Address synchronizers\r
	reg [15:0] rd_pointer_sync, wr_pointer_sync;\r
	reg [15:0] rd_pointer_sync_0, rd_pointer_sync_1;\r
	reg [15:0] wr_pointer_sync_0, wr_pointer_sync_1;\r
\r
	always @(posedge fifo_rdclk or negedge F_RST_N)\r
	begin\r
		if (F_RST_N == 1'b0) begin\r
			wr_pointer_sync_0 <= 0;\r
			wr_pointer_sync_1 <= 0;\r
		end\r
		else begin\r
			wr_pointer_sync_0 <= wraddr;\r
			wr_pointer_sync_1 <= wr_pointer_sync_0;\r
		end\r
	 end\r
\r
	always @(posedge fifo_wrclk or negedge F_RST_N)\r
	 begin\r
		if (F_RST_N == 1'b0) begin\r
			rd_pointer_sync_0 <= 0;\r
			rd_pointer_sync_1 <= 0;\r
		end\r
		else begin\r
			rd_pointer_sync_0 <= rdaddr;\r
			rd_pointer_sync_1 <= rd_pointer_sync_0;\r
		end\r
	 end\r
\r
	always @(*) begin\r
		fifo_wraddr = {wr_pointer[tp-1:0], {(15-tp){1'b0}}};\r
		fifo_rdaddr = {rd_pointer[tp-1:0], {(15-tp){1'b0}}};\r
\r
		rdaddr = {rd_pointer[tp], rd_pointer_int[tp-1:0]};\r
		wraddr = {{(15-tp){1'b0}}, wr_pointer[tp], wr_pointer_int[tp:0]};\r
\r
		if (FIFO_MODE == "ASYNC")\r
			fifo_full = (wraddr[tp-2:0] == rd_pointer_sync_1[tp-2:0] ) && (wraddr[tp] != rd_pointer_sync_1[tp] ) && ( wraddr[tp-1] != rd_pointer_sync_1[tp-1] );\r
		else\r
			fifo_full = (wr_pointer[tp-1:0] == rd_pointer[tp-1:0]) && (wr_pointer[tp] ^ rd_pointer[tp]);\r
\r
		if (FIFO_MODE == "ASYNC")\r
			fifo_empty = (wr_pointer_sync_1[tp:0] == rdaddr[tp:0]);\r
		else\r
			fifo_empty = (wr_pointer[tp:0] == rd_pointer[tp:0]);\r
\r
		rd_pointer_cmp = (FIFO_MODE == "ASYNC") ? rd_pointer_sync : rd_pointer;\r
		if (wr_pointer[tp] == rd_pointer_cmp[tp])\r
			fifo_almost_full = ((wr_pointer[tp-1:0] - rd_pointer_cmp[tp-1:0]) >= (sram_depth - almost_full_offset));\r
		else\r
			fifo_almost_full = ((rd_pointer_cmp[tp-1:0] - wr_pointer[tp-1:0]) <= almost_full_offset);\r
\r
		wr_pointer_cmp = (FIFO_MODE == "ASYNC") ? wr_pointer_sync : wr_pointer;\r
		if (wr_pointer_cmp[tp] == rd_pointer[tp])\r
			fifo_almost_empty = ((wr_pointer_cmp[tp-1:0] - rd_pointer[tp-1:0]) <= almost_empty_offset);\r
		else\r
			fifo_almost_empty = ((rd_pointer[tp-1:0] - wr_pointer_cmp[tp-1:0]) >= (sram_depth - almost_empty_offset));\r
	end\r
\r
	generate\r
		always @(*) begin\r
			wr_pointer_sync = 0;\r
			rd_pointer_sync = 0;\r
			for (i=tp; i >= 0; i=i-1) begin\r
				if (i == tp) begin\r
					wr_pointer_sync[i] = wr_pointer_sync_1[i];\r
					rd_pointer_sync[i] = rd_pointer_sync_1[i];\r
				end\r
				else begin\r
					wr_pointer_sync[i] = wr_pointer_sync_1[i] ^ wr_pointer_sync[i+1];\r
					rd_pointer_sync[i] = rd_pointer_sync_1[i] ^ rd_pointer_sync[i+1];\r
				end\r
			end\r
		end\r
		if (RAM_MODE == "SDP") begin\r
			// SDP push ports A+B\r
			always @(posedge fifo_wrclk)\r
			begin\r
				for (k=0; k < A_WIDTH; k=k+1) begin\r
					if (k < 40) begin\r
						if (ram_we && A_BM[k]) memory[fifo_wraddr+k] <= A_DI[k];\r
					end\r
					else begin // use both ports\r
						if (ram_we && B_BM[k-40]) memory[fifo_wraddr+k] <= B_DI[k-40];\r
					end\r
				end\r
			end\r
			// SDP pop ports A+B\r
			always @(posedge fifo_rdclk)\r
			begin\r
				for (k=0; k < B_WIDTH; k=k+1) begin\r
					if (k < 40) begin\r
						if (ram_en) A_DO_out[k] <= memory[fifo_rdaddr+k];\r
					end\r
					else begin // use both ports\r
						if (ram_en) B_DO_out[k-40] <= memory[fifo_rdaddr+k];\r
					end\r
				end\r
			end\r
		end\r
		else if (RAM_MODE == "TDP") begin\r
			// TDP pop port A\r
			always @(posedge fifo_rdclk)\r
			begin\r
				for (i=0; i < A_WIDTH; i=i+1) begin\r
					if (ram_en) begin\r
						A_DO_out[i] <= memory[fifo_rdaddr+i];\r
					end\r
				end\r
			end\r
			// TDP push port B\r
			always @(posedge fifo_wrclk)\r
			begin\r
				for (i=0; i < B_WIDTH; i=i+1) begin\r
					if (ram_we && B_BM[i])\r
						memory[fifo_wraddr+i] <= B_DI[i];\r
				end\r
			end\r
		end\r
	endgenerate\r
\r
	// Optional output register\r
	generate\r
		if (A_DO_REG) begin\r
			always @(posedge fifo_rdclk) begin\r
				A_DO_reg <= A_DO_out;\r
			end\r
			assign A_DO = A_DO_reg;\r
		end\r
		else begin\r
			assign A_DO = A_DO_out;\r
		end\r
		if (B_DO_REG) begin\r
			always @(posedge fifo_rdclk) begin\r
				B_DO_reg <= B_DO_out;\r
			end\r
			assign B_DO = B_DO_reg;\r
		end\r
		else begin\r
			assign B_DO = B_DO_out;\r
		end\r
	endgenerate\r
endmodule\r
\r
// Models of the LUT2 tree primitives\r
module CC_L2T4(\r
	output O,\r
	input I0, I1, I2, I3\r
);\r
	parameter [3:0] INIT_L00 = 4'b0000;\r
	parameter [3:0] INIT_L01 = 4'b0000;\r
	parameter [3:0] INIT_L10 = 4'b0000;\r
\r
	wire [1:0] l00_s1 = I1 ? INIT_L00[3:2] : INIT_L00[1:0];\r
	wire l00 = I0 ? l00_s1[1] : l00_s1[0];\r
\r
	wire [1:0] l01_s1 = I3 ? INIT_L01[3:2] : INIT_L01[1:0];\r
	wire l01 = I2 ? l01_s1[1] : l01_s1[0];\r
\r
	wire [1:0] l10_s1 = l01 ? INIT_L10[3:2] : INIT_L10[1:0];\r
	assign O = l00 ? l10_s1[1] : l10_s1[0];\r
\r
endmodule\r
\r
\r
module CC_L2T5(\r
	output O,\r
	input I0, I1, I2, I3, I4\r
);\r
	parameter [3:0] INIT_L02 = 4'b0000;\r
	parameter [3:0] INIT_L03 = 4'b0000;\r
	parameter [3:0] INIT_L11 = 4'b0000;\r
	parameter [3:0] INIT_L20 = 4'b0000;\r
\r
	wire [1:0] l02_s1 = I1 ? INIT_L02[3:2] : INIT_L02[1:0];\r
	wire l02 = I0 ? l02_s1[1] : l02_s1[0];\r
\r
	wire [1:0] l03_s1 = I3 ? INIT_L03[3:2] : INIT_L03[1:0];\r
	wire l03 = I2 ? l03_s1[1] : l03_s1[0];\r
\r
	wire [1:0] l11_s1 = l03 ? INIT_L11[3:2] : INIT_L11[1:0];\r
	wire l11 = l02 ? l11_s1[1] : l11_s1[0];\r
\r
	wire [1:0] l20_s1 = l11 ? INIT_L20[3:2] : INIT_L20[1:0];\r
	assign O = I4 ? l20_s1[1] : l20_s1[0];\r
\r
endmodule\r
`,"inv_map.v":`// Any inverters not folded into LUTs are mapped to a LUT of their own
module \\$__CC_NOT (input A, output Y);
	CC_LUT1 #(.INIT(2'b01)) _TECHMAP_REPLACE_ (.I0(A), .O(Y));
endmodule
`,"lut_map.v":`/*\r
 *  yosys -- Yosys Open SYnthesis Suite\r
 *\r
 *  Copyright (C) 2021  Cologne Chip AG <support@colognechip.com>\r
 *\r
 *  Permission to use, copy, modify, and/or distribute this software for any\r
 *  purpose with or without fee is hereby granted, provided that the above\r
 *  copyright notice and this permission notice appear in all copies.\r
 *\r
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\r
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\r
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\r
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\r
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\r
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\r
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\r
 *\r
 */\r
\r
module \\$lut (A, Y);\r
	parameter WIDTH = 0;\r
	parameter LUT = 0;\r
\r
	(* force_downto *)\r
	input [WIDTH-1:0] A;\r
	output Y;\r
\r
	generate\r
		if (WIDTH == 1) begin\r
			CC_LUT1 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.O(Y), .I0(A[0]));\r
		end\r
		else if (WIDTH == 2) begin\r
			CC_LUT2 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.O(Y), .I0(A[0]), .I1(A[1]));\r
		end\r
		else if (WIDTH == 3) begin\r
			CC_LUT3 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.O(Y), .I0(A[0]), .I1(A[1]), .I2(A[2]));\r
		end\r
		else if (WIDTH == 4) begin\r
			CC_LUT4 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.O(Y), .I0(A[0]), .I1(A[1]), .I2(A[2]), .I3(A[3]));\r
		end\r
		else begin\r
			wire _TECHMAP_FAIL_ = 1;\r
		end\r
	endgenerate\r
endmodule\r
`,"lut_tree_cells.genlib":`GATE $__ZERO 0 Y=CONST0;
GATE $__ONE 0 Y=CONST1;

GATE $__CC_BUF 5 Y=A;
PIN * NONINV 1 9999 10 5 10 5

GATE $__CC_NOT 0 Y=!A;
PIN * INV 1 9999 10 5 10 5

GATE $__CC_MUX 5 Y=((A*!C)+(B*C));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC2_A 10 Y=(A*B);
PIN * NONINV 1 9999 10 5 10 5

GATE $__CC3_A_O 12 Y=(E+(A*B));
PIN * NONINV 1 9999 10 5 10 5

GATE $__CC3_A_X 12 Y=((E*(!A+!B))+(!E*(A*B)));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC2_O 10 Y=(A+B);
PIN * NONINV 1 9999 10 5 10 5

GATE $__CC3_O_A 12 Y=(E*(A+B));
PIN * NONINV 1 9999 10 5 10 5

GATE $__CC3_O_X 12 Y=((E*(!A*!B))+(!E*(A+B)));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC2_X 10 Y=((A*!B)+(!A*B));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC3_X_A 12 Y=(E*((A*!B)+(!A*B)));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC3_X_O 12 Y=(E+((A*!B)+(!A*B)));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC3_AA 10 Y=((A*B)*C);
PIN * NONINV 1 9999 10 5 10 5

GATE $__CC4_AA_O 12 Y=(E+((A*B)*C));
PIN * NONINV 1 9999 10 5 10 5

GATE $__CC4_AA_X 12 Y=((E*((!A+!B)+!C))+(!E*((A*B)*C)));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC3_OO 10 Y=((A+B)+C);
PIN * NONINV 1 9999 10 5 10 5

GATE $__CC4_OO_A 12 Y=(E*((A+B)+C));
PIN * NONINV 1 9999 10 5 10 5

GATE $__CC4_OO_X 12 Y=((E*((!A*!B)*!C))+(!E*((A+B)+C)));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC3_XX 10 Y=((((A*!B)+(!A*B))*!C)+(((!A+B)*(A+!B))*C));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC4_XX_A 12 Y=(E*((((A*!B)+(!A*B))*!C)+(((!A+B)*(A+!B))*C)));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC4_XX_O 12 Y=(E+((((A*!B)+(!A*B))*!C)+(((!A+B)*(A+!B))*C)));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC3_AO 10 Y=((A*B)+C);
PIN * NONINV 1 9999 10 5 10 5

GATE $__CC4_AO_A 12 Y=(E*((A*B)+C));
PIN * NONINV 1 9999 10 5 10 5

GATE $__CC4_AO_O 12 Y=(E+((A*B)+C));
PIN * NONINV 1 9999 10 5 10 5

GATE $__CC4_AO_X 12 Y=((E*((!A+!B)*!C))+(!E*((A*B)+C)));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC3_OA 10 Y=((A+B)*C);
PIN * NONINV 1 9999 10 5 10 5

GATE $__CC4_OA_A 12 Y=(E*((A+B)*C));
PIN * NONINV 1 9999 10 5 10 5

GATE $__CC4_OA_O 12 Y=(E+((A+B)*C));
PIN * NONINV 1 9999 10 5 10 5

GATE $__CC4_OA_X 12 Y=((E*((!A*!B)+!C))+(!E*((A+B)*C)));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC3_AX 10 Y=(((A*B)*!C)+((!A+!B)*C));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC4_AX_A 12 Y=(E*(((A*B)*!C)+((!A+!B)*C)));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC4_AX_O 12 Y=(E+(((A*B)*!C)+((!A+!B)*C)));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC4_AX_X 12 Y=((E*(((!A+!B)+C)*((A*B)+!C)))+(!E*(((A*B)*!C)+((!A+!B)*C))));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC3_XA 10 Y=(((A*!B)+(!A*B))*C);
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC4_XA_A 12 Y=(E*(((A*!B)+(!A*B))*C));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC4_XA_O 12 Y=(E+(((A*!B)+(!A*B))*C));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC4_XA_X 12 Y=((E*(((!A+B)*(A+!B))+!C))+(!E*(((A*!B)+(!A*B))*C)));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC4_AAA 10 Y=((A*B)*(C*D));
PIN * NONINV 1 9999 10 5 10 5

GATE $__CC5_AAA_A 12 Y=(E*((A*B)*(C*D)));
PIN * NONINV 1 9999 10 5 10 5

GATE $__CC5_AAA_O 12 Y=(E+((A*B)*(C*D)));
PIN * NONINV 1 9999 10 5 10 5

GATE $__CC5_AAA_X 12 Y=((E*((!A+!B)+(!C+!D)))+(!E*((A*B)*(C*D))));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC4_AXA 10 Y=(((A*B)*(!C+!D))+((!A+!B)*(C*D)));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC5_AXA_A 12 Y=(E*(((A*B)*(!C+!D))+((!A+!B)*(C*D))));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC5_AXA_O 12 Y=(E+(((A*B)*(!C+!D))+((!A+!B)*(C*D))));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC5_AXA_X 12 Y=((E*(((!A+!B)+(C*D))*((A*B)+(!C+!D))))+(!E*(((A*B)*(!C+!D))+((!A+!B)*(C*D)))));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC4_XAX 10 Y=(((A*!B)+(!A*B))*((C*!D)+(!C*D)));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC5_XAX_A 12 Y=(E*(((A*!B)+(!A*B))*((C*!D)+(!C*D))));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC5_XAX_O 12 Y=(E+(((A*!B)+(!A*B))*((C*!D)+(!C*D))));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC5_XAX_X 12 Y=((E*(((!A+B)*(A+!B))+((!C+D)*(C+!D))))+(!E*(((A*!B)+(!A*B))*((C*!D)+(!C*D)))));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC4_AAX 10 Y=((A*B)*((C*!D)+(!C*D)));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC5_AAX_A 12 Y=(E*((A*B)*((C*!D)+(!C*D))));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC5_AAX_O 12 Y=(E+((A*B)*((C*!D)+(!C*D))));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC5_AAX_X 12 Y=((E*((!A+!B)+((!C+D)*(C+!D))))+(!E*((A*B)*((C*!D)+(!C*D)))));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC4_AXX 10 Y=(((A*B)*((!C+D)*(C+!D)))+((!A+!B)*((C*!D)+(!C*D))));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC5_AXX_A 12 Y=(E*(((A*B)*((!C+D)*(C+!D)))+((!A+!B)*((C*!D)+(!C*D)))));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC5_AXX_O 12 Y=(E+(((A*B)*((!C+D)*(C+!D)))+((!A+!B)*((C*!D)+(!C*D)))));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC5_AXX_X 12 Y=((E*(((!A+!B)+((C*!D)+(!C*D)))*((A*B)+((!C+D)*(C+!D)))))+(!E*(((A*B)*((!C+D)*(C+!D)))+((!A+!B)*((C*!D)+(!C*D))))));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC4_XXX 10 Y=((((A*!B)+(!A*B))*((!C+D)*(C+!D)))+(((!A+B)*(A+!B))*((C*!D)+(!C*D))));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC5_XXX_A 12 Y=(E*((((A*!B)+(!A*B))*((!C+D)*(C+!D)))+(((!A+B)*(A+!B))*((C*!D)+(!C*D)))));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC5_XXX_O 12 Y=(E+((((A*!B)+(!A*B))*((!C+D)*(C+!D)))+(((!A+B)*(A+!B))*((C*!D)+(!C*D)))));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC5_XXX_X 12 Y=((E*((((!A+B)*(A+!B))+((C*!D)+(!C*D)))*(((A*!B)+(!A*B))+((!C+D)*(C+!D)))))+(!E*((((A*!B)+(!A*B))*((!C+D)*(C+!D)))+(((!A+B)*(A+!B))*((C*!D)+(!C*D))))));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC4_AAO 10 Y=((A*B)*(C+D));
PIN * NONINV 1 9999 10 5 10 5

GATE $__CC5_AAO_A 12 Y=(E*((A*B)*(C+D)));
PIN * NONINV 1 9999 10 5 10 5

GATE $__CC5_AAO_O 12 Y=(E+((A*B)*(C+D)));
PIN * NONINV 1 9999 10 5 10 5

GATE $__CC5_AAO_X 12 Y=((E*((!A+!B)+(!C*!D)))+(!E*((A*B)*(C+D))));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC4_AOA 10 Y=((A*B)+(C*D));
PIN * NONINV 1 9999 10 5 10 5

GATE $__CC5_AOA_A 12 Y=(E*((A*B)+(C*D)));
PIN * NONINV 1 9999 10 5 10 5

GATE $__CC5_AOA_O 12 Y=(E+((A*B)+(C*D)));
PIN * NONINV 1 9999 10 5 10 5

GATE $__CC5_AOA_X 12 Y=((E*((!A+!B)*(!C+!D)))+(!E*((A*B)+(C*D))));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC4_AOX 10 Y=((A*B)+((C*!D)+(!C*D)));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC5_AOX_A 12 Y=(E*((A*B)+((C*!D)+(!C*D))));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC5_AOX_O 12 Y=(E+((A*B)+((C*!D)+(!C*D))));
PIN * UNKNOWN 1 9999 10 5 10 5

GATE $__CC5_AOX_X 12 Y=((E*((!A+!B)*((!C+D)*(C+!D))))+(!E*((A*B)+((C*!D)+(!C*D)))));
PIN * UNKNOWN 1 9999 10 5 10 5
`,"lut_tree_map.v":`
module \\$__ZERO (output Y); assign Y = 1'b0; endmodule
module \\$__ONE (output Y); assign Y = 1'b1; endmodule

module \\$__CC_BUF (input A, output Y); assign Y = A; endmodule

module \\$__CC_MUX (input A, B, C, output Y);
    CC_MX2 _TECHMAP_REPLACE_ (
        .D0(A), .D1(B), .S0(C),
        .Y(Y)
    );
endmodule


module \\$__CC2_A (input A, B, output Y);
    CC_LUT2 #(
        .INIT(4'b1000),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B),
         .O(Y)
    );
endmodule

module \\$__CC3_A_O (input A, B, E, output Y);
    CC_L2T4 #(
        .INIT_L00(4'b1010),
        .INIT_L01(4'b1000),
        .INIT_L10(4'b1110),
    ) _TECHMAP_REPLACE_ (
         .I0(E), .I1(), .I2(A), .I3(B),
         .O(Y)
    );
endmodule

module \\$__CC3_A_X (input A, B, E, output Y);
    CC_L2T4 #(
        .INIT_L00(4'b1010),
        .INIT_L01(4'b1000),
        .INIT_L10(4'b0110),
    ) _TECHMAP_REPLACE_ (
         .I0(E), .I1(), .I2(A), .I3(B),
         .O(Y)
    );
endmodule

module \\$__CC2_O (input A, B, output Y);
    CC_LUT2 #(
        .INIT(4'b1110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B),
         .O(Y)
    );
endmodule

module \\$__CC3_O_A (input A, B, E, output Y);
    CC_L2T4 #(
        .INIT_L00(4'b1010),
        .INIT_L01(4'b1110),
        .INIT_L10(4'b1000),
    ) _TECHMAP_REPLACE_ (
         .I0(E), .I1(), .I2(A), .I3(B),
         .O(Y)
    );
endmodule

module \\$__CC3_O_X (input A, B, E, output Y);
    CC_L2T4 #(
        .INIT_L00(4'b1010),
        .INIT_L01(4'b1110),
        .INIT_L10(4'b0110),
    ) _TECHMAP_REPLACE_ (
         .I0(E), .I1(), .I2(A), .I3(B),
         .O(Y)
    );
endmodule

module \\$__CC2_X (input A, B, output Y);
    CC_LUT2 #(
        .INIT(4'b0110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B),
         .O(Y)
    );
endmodule

module \\$__CC3_X_A (input A, B, E, output Y);
    CC_L2T4 #(
        .INIT_L00(4'b1010),
        .INIT_L01(4'b0110),
        .INIT_L10(4'b1000),
    ) _TECHMAP_REPLACE_ (
         .I0(E), .I1(), .I2(A), .I3(B),
         .O(Y)
    );
endmodule

module \\$__CC3_X_O (input A, B, E, output Y);
    CC_L2T4 #(
        .INIT_L00(4'b1010),
        .INIT_L01(4'b0110),
        .INIT_L10(4'b1110),
    ) _TECHMAP_REPLACE_ (
         .I0(E), .I1(), .I2(A), .I3(B),
         .O(Y)
    );
endmodule

module \\$__CC3_AA (input A, B, C, output Y);
    CC_L2T4 #(
        .INIT_L00(4'b1000),
        .INIT_L01(4'b1010),
        .INIT_L10(4'b1000),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(),
         .O(Y)
    );
endmodule

module \\$__CC4_AA_O (input A, B, C, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b1000),
        .INIT_L03(4'b1010),
        .INIT_L11(4'b1000),
        .INIT_L20(4'b1110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC4_AA_X (input A, B, C, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b1000),
        .INIT_L03(4'b1010),
        .INIT_L11(4'b1000),
        .INIT_L20(4'b0110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC3_OO (input A, B, C, output Y);
    CC_L2T4 #(
        .INIT_L00(4'b1110),
        .INIT_L01(4'b1010),
        .INIT_L10(4'b1110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(),
         .O(Y)
    );
endmodule

module \\$__CC4_OO_A (input A, B, C, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b1110),
        .INIT_L03(4'b1010),
        .INIT_L11(4'b1110),
        .INIT_L20(4'b1000),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC4_OO_X (input A, B, C, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b1110),
        .INIT_L03(4'b1010),
        .INIT_L11(4'b1110),
        .INIT_L20(4'b0110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC3_XX (input A, B, C, output Y);
    CC_L2T4 #(
        .INIT_L00(4'b0110),
        .INIT_L01(4'b1010),
        .INIT_L10(4'b0110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(),
         .O(Y)
    );
endmodule

module \\$__CC4_XX_A (input A, B, C, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b0110),
        .INIT_L03(4'b1010),
        .INIT_L11(4'b0110),
        .INIT_L20(4'b1000),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC4_XX_O (input A, B, C, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b0110),
        .INIT_L03(4'b1010),
        .INIT_L11(4'b0110),
        .INIT_L20(4'b1110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC3_AO (input A, B, C, output Y);
    CC_L2T4 #(
        .INIT_L00(4'b1000),
        .INIT_L01(4'b1010),
        .INIT_L10(4'b1110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(),
         .O(Y)
    );
endmodule

module \\$__CC4_AO_A (input A, B, C, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b1000),
        .INIT_L03(4'b1010),
        .INIT_L11(4'b1110),
        .INIT_L20(4'b1000),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC4_AO_O (input A, B, C, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b1000),
        .INIT_L03(4'b1010),
        .INIT_L11(4'b1110),
        .INIT_L20(4'b1110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC4_AO_X (input A, B, C, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b1000),
        .INIT_L03(4'b1010),
        .INIT_L11(4'b1110),
        .INIT_L20(4'b0110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC3_OA (input A, B, C, output Y);
    CC_L2T4 #(
        .INIT_L00(4'b1110),
        .INIT_L01(4'b1010),
        .INIT_L10(4'b1000),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(),
         .O(Y)
    );
endmodule

module \\$__CC4_OA_A (input A, B, C, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b1110),
        .INIT_L03(4'b1010),
        .INIT_L11(4'b1000),
        .INIT_L20(4'b1000),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC4_OA_O (input A, B, C, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b1110),
        .INIT_L03(4'b1010),
        .INIT_L11(4'b1000),
        .INIT_L20(4'b1110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC4_OA_X (input A, B, C, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b1110),
        .INIT_L03(4'b1010),
        .INIT_L11(4'b1000),
        .INIT_L20(4'b0110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC3_AX (input A, B, C, output Y);
    CC_L2T4 #(
        .INIT_L00(4'b1000),
        .INIT_L01(4'b1010),
        .INIT_L10(4'b0110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(),
         .O(Y)
    );
endmodule

module \\$__CC4_AX_A (input A, B, C, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b1000),
        .INIT_L03(4'b1010),
        .INIT_L11(4'b0110),
        .INIT_L20(4'b1000),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC4_AX_O (input A, B, C, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b1000),
        .INIT_L03(4'b1010),
        .INIT_L11(4'b0110),
        .INIT_L20(4'b1110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC4_AX_X (input A, B, C, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b1000),
        .INIT_L03(4'b1010),
        .INIT_L11(4'b0110),
        .INIT_L20(4'b0110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC3_XA (input A, B, C, output Y);
    CC_L2T4 #(
        .INIT_L00(4'b0110),
        .INIT_L01(4'b1010),
        .INIT_L10(4'b1000),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(),
         .O(Y)
    );
endmodule

module \\$__CC4_XA_A (input A, B, C, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b0110),
        .INIT_L03(4'b1010),
        .INIT_L11(4'b1000),
        .INIT_L20(4'b1000),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC4_XA_O (input A, B, C, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b0110),
        .INIT_L03(4'b1010),
        .INIT_L11(4'b1000),
        .INIT_L20(4'b1110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC4_XA_X (input A, B, C, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b0110),
        .INIT_L03(4'b1010),
        .INIT_L11(4'b1000),
        .INIT_L20(4'b0110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC4_AAA (input A, B, C, D, output Y);
    CC_L2T4 #(
        .INIT_L00(4'b1000),
        .INIT_L01(4'b1000),
        .INIT_L10(4'b1000),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(D),
         .O(Y)
    );
endmodule

module \\$__CC5_AAA_A (input A, B, C, D, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b1000),
        .INIT_L03(4'b1000),
        .INIT_L11(4'b1000),
        .INIT_L20(4'b1000),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC5_AAA_O (input A, B, C, D, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b1000),
        .INIT_L03(4'b1000),
        .INIT_L11(4'b1000),
        .INIT_L20(4'b1110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC5_AAA_X (input A, B, C, D, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b1000),
        .INIT_L03(4'b1000),
        .INIT_L11(4'b1000),
        .INIT_L20(4'b0110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC4_AXA (input A, B, C, D, output Y);
    CC_L2T4 #(
        .INIT_L00(4'b1000),
        .INIT_L01(4'b1000),
        .INIT_L10(4'b0110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(D),
         .O(Y)
    );
endmodule

module \\$__CC5_AXA_A (input A, B, C, D, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b1000),
        .INIT_L03(4'b1000),
        .INIT_L11(4'b0110),
        .INIT_L20(4'b1000),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC5_AXA_O (input A, B, C, D, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b1000),
        .INIT_L03(4'b1000),
        .INIT_L11(4'b0110),
        .INIT_L20(4'b1110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC5_AXA_X (input A, B, C, D, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b1000),
        .INIT_L03(4'b1000),
        .INIT_L11(4'b0110),
        .INIT_L20(4'b0110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC4_XAX (input A, B, C, D, output Y);
    CC_L2T4 #(
        .INIT_L00(4'b0110),
        .INIT_L01(4'b0110),
        .INIT_L10(4'b1000),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(D),
         .O(Y)
    );
endmodule

module \\$__CC5_XAX_A (input A, B, C, D, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b0110),
        .INIT_L03(4'b0110),
        .INIT_L11(4'b1000),
        .INIT_L20(4'b1000),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC5_XAX_O (input A, B, C, D, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b0110),
        .INIT_L03(4'b0110),
        .INIT_L11(4'b1000),
        .INIT_L20(4'b1110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC5_XAX_X (input A, B, C, D, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b0110),
        .INIT_L03(4'b0110),
        .INIT_L11(4'b1000),
        .INIT_L20(4'b0110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC4_AAX (input A, B, C, D, output Y);
    CC_L2T4 #(
        .INIT_L00(4'b1000),
        .INIT_L01(4'b0110),
        .INIT_L10(4'b1000),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(D),
         .O(Y)
    );
endmodule

module \\$__CC5_AAX_A (input A, B, C, D, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b1000),
        .INIT_L03(4'b0110),
        .INIT_L11(4'b1000),
        .INIT_L20(4'b1000),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC5_AAX_O (input A, B, C, D, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b1000),
        .INIT_L03(4'b0110),
        .INIT_L11(4'b1000),
        .INIT_L20(4'b1110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC5_AAX_X (input A, B, C, D, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b1000),
        .INIT_L03(4'b0110),
        .INIT_L11(4'b1000),
        .INIT_L20(4'b0110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC4_AXX (input A, B, C, D, output Y);
    CC_L2T4 #(
        .INIT_L00(4'b1000),
        .INIT_L01(4'b0110),
        .INIT_L10(4'b0110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(D),
         .O(Y)
    );
endmodule

module \\$__CC5_AXX_A (input A, B, C, D, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b1000),
        .INIT_L03(4'b0110),
        .INIT_L11(4'b0110),
        .INIT_L20(4'b1000),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC5_AXX_O (input A, B, C, D, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b1000),
        .INIT_L03(4'b0110),
        .INIT_L11(4'b0110),
        .INIT_L20(4'b1110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC5_AXX_X (input A, B, C, D, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b1000),
        .INIT_L03(4'b0110),
        .INIT_L11(4'b0110),
        .INIT_L20(4'b0110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC4_XXX (input A, B, C, D, output Y);
    CC_L2T4 #(
        .INIT_L00(4'b0110),
        .INIT_L01(4'b0110),
        .INIT_L10(4'b0110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(D),
         .O(Y)
    );
endmodule

module \\$__CC5_XXX_A (input A, B, C, D, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b0110),
        .INIT_L03(4'b0110),
        .INIT_L11(4'b0110),
        .INIT_L20(4'b1000),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC5_XXX_O (input A, B, C, D, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b0110),
        .INIT_L03(4'b0110),
        .INIT_L11(4'b0110),
        .INIT_L20(4'b1110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC5_XXX_X (input A, B, C, D, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b0110),
        .INIT_L03(4'b0110),
        .INIT_L11(4'b0110),
        .INIT_L20(4'b0110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC4_AAO (input A, B, C, D, output Y);
    CC_L2T4 #(
        .INIT_L00(4'b1000),
        .INIT_L01(4'b1110),
        .INIT_L10(4'b1000),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(D),
         .O(Y)
    );
endmodule

module \\$__CC5_AAO_A (input A, B, C, D, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b1000),
        .INIT_L03(4'b1110),
        .INIT_L11(4'b1000),
        .INIT_L20(4'b1000),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC5_AAO_O (input A, B, C, D, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b1000),
        .INIT_L03(4'b1110),
        .INIT_L11(4'b1000),
        .INIT_L20(4'b1110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC5_AAO_X (input A, B, C, D, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b1000),
        .INIT_L03(4'b1110),
        .INIT_L11(4'b1000),
        .INIT_L20(4'b0110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC4_AOA (input A, B, C, D, output Y);
    CC_L2T4 #(
        .INIT_L00(4'b1000),
        .INIT_L01(4'b1000),
        .INIT_L10(4'b1110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(D),
         .O(Y)
    );
endmodule

module \\$__CC5_AOA_A (input A, B, C, D, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b1000),
        .INIT_L03(4'b1000),
        .INIT_L11(4'b1110),
        .INIT_L20(4'b1000),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC5_AOA_O (input A, B, C, D, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b1000),
        .INIT_L03(4'b1000),
        .INIT_L11(4'b1110),
        .INIT_L20(4'b1110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC5_AOA_X (input A, B, C, D, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b1000),
        .INIT_L03(4'b1000),
        .INIT_L11(4'b1110),
        .INIT_L20(4'b0110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC4_AOX (input A, B, C, D, output Y);
    CC_L2T4 #(
        .INIT_L00(4'b1000),
        .INIT_L01(4'b0110),
        .INIT_L10(4'b1110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(D),
         .O(Y)
    );
endmodule

module \\$__CC5_AOX_A (input A, B, C, D, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b1000),
        .INIT_L03(4'b0110),
        .INIT_L11(4'b1110),
        .INIT_L20(4'b1000),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC5_AOX_O (input A, B, C, D, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b1000),
        .INIT_L03(4'b0110),
        .INIT_L11(4'b1110),
        .INIT_L20(4'b1110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),
         .O(Y)
    );
endmodule

module \\$__CC5_AOX_X (input A, B, C, D, E, output Y);
    CC_L2T5 #(
        .INIT_L02(4'b1000),
        .INIT_L03(4'b0110),
        .INIT_L11(4'b1110),
        .INIT_L20(4'b0110),
    ) _TECHMAP_REPLACE_ (
         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),
         .O(Y)
    );
endmodule
`,"mul_map.v":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2021  Cologne Chip AG <support@colognechip.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

(* techmap_celltype = "$mul $__mul" *)
module \\$__MULMXN (A, B, Y);

	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;
	parameter A_WIDTH = 1;
	parameter B_WIDTH = 1;
	parameter Y_WIDTH = 1;

	(* force_downto *)
	input [A_WIDTH-1:0] A;
	(* force_downto *)
	input [B_WIDTH-1:0] B;
	(* force_downto *)
	output [Y_WIDTH-1:0] Y;

	localparam A_ADJWIDTH = A_WIDTH + (A_SIGNED ? 0 : 1);
	localparam B_ADJWIDTH = B_WIDTH + (B_SIGNED ? 0 : 1);

	generate
		if (A_SIGNED) begin: blkA
			wire signed [A_ADJWIDTH-1:0] Aext = $signed(A);
		end
		else begin: blkA
			wire [A_ADJWIDTH-1:0] Aext = A;
		end
		if (B_SIGNED) begin: blkB
			wire signed [B_ADJWIDTH-1:0] Bext = $signed(B);
		end
		else begin: blkB
			wire [B_ADJWIDTH-1:0] Bext = B;
		end

		if (A_WIDTH >= B_WIDTH) begin
			CC_MULT #(
				.A_WIDTH(A_ADJWIDTH),
				.B_WIDTH(B_ADJWIDTH),
				.P_WIDTH(Y_WIDTH),
			) _TECHMAP_REPLACE_ (
				.A(blkA.Aext),
				.B(blkB.Bext),
				.P(Y)
			);
		end
		else begin // swap A,B
			CC_MULT #(
				.A_WIDTH(B_ADJWIDTH),
				.B_WIDTH(A_ADJWIDTH),
				.P_WIDTH(Y_WIDTH),
			) _TECHMAP_REPLACE_ (
				.A(blkB.Bext),
				.B(blkA.Aext),
				.P(Y)
			);
		end
	endgenerate

endmodule
`,"mux_map.v":`/*\r
 *  yosys -- Yosys Open SYnthesis Suite\r
 *\r
 *  Copyright (C) 2021  Cologne Chip AG <support@colognechip.com>\r
 *\r
 *  Permission to use, copy, modify, and/or distribute this software for any\r
 *  purpose with or without fee is hereby granted, provided that the above\r
 *  copyright notice and this permission notice appear in all copies.\r
 *\r
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\r
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\r
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\r
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\r
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\r
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\r
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\r
 *\r
 */\r
\r
module \\$_MUX8_ (A, B, C, D, E, F, G, H, S, T, U, Y);\r
	input  A, B, C, D, E, F, G, H, S, T, U;\r
	output Y;\r
\r
	CC_MX8 _TECHMAP_REPLACE_ (\r
		.D0(A), .D1(B), .D2(C), .D3(D),\r
		.D4(E), .D5(F), .D6(G), .D7(H),\r
		.S0(S), .S1(T), .S2(U),\r
		.Y(Y)\r
	);\r
\r
endmodule\r
\r
module \\$_MUX4_ (A, B, C, D, S, T, Y);\r
	input  A, B, C, D, S, T;\r
	output Y;\r
\r
	CC_MX4 _TECHMAP_REPLACE_ (\r
		.D0(A), .D1(B), .D2(C), .D3(D),\r
		.S0(S), .S1(T),\r
		.Y(Y)\r
	);\r
\r
endmodule\r
\r
/*\r
module \\$_MUX_ (A, B, S, Y);\r
	input  A, B, S;\r
	output Y;\r
\r
	CC_MX2 _TECHMAP_REPLACE_ (\r
		.D0(A), .D1(B), .S0(S),\r
		.Y(Y)\r
	);\r
\r
endmodule\r
*/\r
`,"reg_map.v":`/*\r
 *  yosys -- Yosys Open SYnthesis Suite\r
 *\r
 *  Copyright (C) 2021  Cologne Chip AG <support@colognechip.com>\r
 *\r
 *  Permission to use, copy, modify, and/or distribute this software for any\r
 *  purpose with or without fee is hereby granted, provided that the above\r
 *  copyright notice and this permission notice appear in all copies.\r
 *\r
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\r
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\r
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\r
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\r
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\r
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\r
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\r
 *\r
 */\r
\r
(* techmap_celltype = "$_DFFE_[NP][NP][01][NP]_" *)\r
module \\$_DFFE_xxxx_ (input D, C, R, E, output Q);\r
\r
	parameter _TECHMAP_CELLTYPE_ = "";\r
	parameter _TECHMAP_WIREINIT_Q_ = 1'bx;\r
\r
	CC_DFF #(\r
		.CLK_INV(_TECHMAP_CELLTYPE_[39:32] == "N"),\r
		.EN_INV(_TECHMAP_CELLTYPE_[15:8] == "N"),\r
		.SR_INV(_TECHMAP_CELLTYPE_[31:24] == "N"),\r
		.SR_VAL(_TECHMAP_CELLTYPE_[23:16] == "1"),\r
		.INIT(_TECHMAP_WIREINIT_Q_)\r
	) _TECHMAP_REPLACE_ (.D(D), .EN(E), .CLK(C), .SR(R), .Q(Q));\r
\r
	wire _TECHMAP_REMOVEINIT_Q_ = 1;\r
endmodule\r
\r
(* techmap_celltype = "$_DLATCH_[NP][NP][01]_" *)\r
module \\$_DLATCH_xxx_ (input E, R, D, output Q);\r
\r
	parameter _TECHMAP_CELLTYPE_ = "";\r
	parameter _TECHMAP_WIREINIT_Q_ = 1'bx;\r
\r
	CC_DLT #(\r
		.G_INV(_TECHMAP_CELLTYPE_[31:24] == "N"),\r
		.SR_INV(_TECHMAP_CELLTYPE_[23:16] == "N"),\r
		.SR_VAL(_TECHMAP_CELLTYPE_[15:8] == "1"),\r
		.INIT(_TECHMAP_WIREINIT_Q_)\r
	) _TECHMAP_REPLACE_ (.D(D), .G(E), .SR(R), .Q(Q));\r
\r
	wire _TECHMAP_REMOVEINIT_Q_ = 1;\r
endmodule\r
`},gowin:{"arith_map.v":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *  Copyright (C) 2018  gatecat <gatecat@ds0.me>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

(* techmap_celltype = "$alu" *)
module _80_gw1n_alu(A, B, CI, BI, X, Y, CO);
   parameter A_SIGNED = 0;
   parameter B_SIGNED = 0;
   parameter A_WIDTH = 1;
   parameter B_WIDTH = 1;
   parameter Y_WIDTH = 1;

   (* force_downto *)
   input [A_WIDTH-1:0] A;
   (* force_downto *)
   input [B_WIDTH-1:0] B;
   (* force_downto *)
   output [Y_WIDTH-1:0] X, Y;

   input 		CI, BI;
   (* force_downto *)
   output [Y_WIDTH-1:0] CO;

   wire 		_TECHMAP_FAIL_ = Y_WIDTH <= 2;

   (* force_downto *)
   wire [Y_WIDTH-1:0] 	A_buf, B_buf;
   \\$pos #(.A_SIGNED(A_SIGNED), .A_WIDTH(A_WIDTH), .Y_WIDTH(Y_WIDTH)) A_conv (.A(A), .Y(A_buf));
   \\$pos #(.A_SIGNED(B_SIGNED), .A_WIDTH(B_WIDTH), .Y_WIDTH(Y_WIDTH)) B_conv (.A(B), .Y(B_buf));

   (* force_downto *)
   wire [Y_WIDTH-1:0] 	AA = A_buf;
   (* force_downto *)
   wire [Y_WIDTH-1:0] 	BB = B_buf;
   (* force_downto *)
   wire [Y_WIDTH-1:0] 	C = {CO, CI};

   genvar 		i;
   generate for (i = 0; i < Y_WIDTH; i = i + 1) begin:slice
      ALU #(.ALU_MODE(2)) // ADDSUB I3 ? add : sub
      alu(.I0(AA[i]),
	  .I1(BB[i]),
	  .I3(~BI),
	  .CIN(C[i]),
	  .COUT(CO[i]),
	  .SUM(Y[i])
	  );
   end endgenerate
   assign X = AA ^ BB ^ {Y_WIDTH{BI}};
endmodule

`,"brams.txt":`ram block $__GOWIN_SP_ {
	abits 14;
	widths 1 2 4 9 18 36 per_port;
	cost 128;
	init no_undef;
	port srsw "A" {
		clock posedge;
		clken;
		option "RESET_MODE" "SYNC" {
			rdsrst zero ungated;
		}
		option "RESET_MODE" "ASYNC" {
			rdarst zero;
		}
		rdinit zero;
		portoption "WRITE_MODE" 0 {
			rdwr no_change;
		}
		portoption "WRITE_MODE" 1 {
			rdwr new;
		}
		portoption "WRITE_MODE" 2 {
			rdwr old;
		}
	}
}

ram block $__GOWIN_DP_ {
	abits 14;
	widths 1 2 4 9 18 per_port;
	cost 128;
	init no_undef;
	port srsw "A" "B" {
		clock posedge;
		clken;
		option "RESET_MODE" "SYNC" {
			rdsrst zero ungated;
		}
		option "RESET_MODE" "ASYNC" {
			rdarst zero;
		}
		rdinit zero;
		portoption "WRITE_MODE" 0 {
			rdwr no_change;
		}
		portoption "WRITE_MODE" 1 {
			rdwr new;
		}
		portoption "WRITE_MODE" 2 {
			rdwr old;
		}
	}
}

ram block $__GOWIN_SDP_ {
	abits 14;
	widths 1 2 4 9 18 36 per_port;
	cost 128;
	init no_undef;
	port sr "R" {
		clock posedge;
		clken;
		option "RESET_MODE" "SYNC" {
			rdsrst zero ungated;
		}
		option "RESET_MODE" "ASYNC" {
			rdarst zero;
		}
		rdinit zero;
	}
	port sw "W" {
		clock posedge;
		clken;
	}
}
`,"brams_map.v":`\`define DEF_FUNCS \\
	function [255:0] init_slice_x8; \\
		input integer idx; \\
		integer i; \\
		for (i = 0; i < 32; i = i + 1) begin \\
			init_slice_x8[i*8+:8] = INIT[(idx * 32 + i) * 9+:8]; \\
		end \\
	endfunction \\
	function [287:0] init_slice_x9; \\
		input integer idx; \\
		init_slice_x9 = INIT[idx * 288+:288]; \\
	endfunction \\

\`define x8_width(width) (width / 9 * 8 + width % 9)
\`define x8_rd_data(data) {1'bx, data[31:24], 1'bx, data[23:16], 1'bx, data[15:8], 1'bx, data[7:0]}
\`define x8_wr_data(data) {data[34:27], data[25:18], data[16:9], data[7:0]}
\`define addrbe_always(width, addr) (width < 18 ? addr :  width == 18 ? {addr[13:4], 4'b0011} : {addr[13:5], 5'b01111})


\`define INIT(func) \\
	.INIT_RAM_00(func('h00)), \\
	.INIT_RAM_01(func('h01)), \\
	.INIT_RAM_02(func('h02)), \\
	.INIT_RAM_03(func('h03)), \\
	.INIT_RAM_04(func('h04)), \\
	.INIT_RAM_05(func('h05)), \\
	.INIT_RAM_06(func('h06)), \\
	.INIT_RAM_07(func('h07)), \\
	.INIT_RAM_08(func('h08)), \\
	.INIT_RAM_09(func('h09)), \\
	.INIT_RAM_0A(func('h0a)), \\
	.INIT_RAM_0B(func('h0b)), \\
	.INIT_RAM_0C(func('h0c)), \\
	.INIT_RAM_0D(func('h0d)), \\
	.INIT_RAM_0E(func('h0e)), \\
	.INIT_RAM_0F(func('h0f)), \\
	.INIT_RAM_10(func('h10)), \\
	.INIT_RAM_11(func('h11)), \\
	.INIT_RAM_12(func('h12)), \\
	.INIT_RAM_13(func('h13)), \\
	.INIT_RAM_14(func('h14)), \\
	.INIT_RAM_15(func('h15)), \\
	.INIT_RAM_16(func('h16)), \\
	.INIT_RAM_17(func('h17)), \\
	.INIT_RAM_18(func('h18)), \\
	.INIT_RAM_19(func('h19)), \\
	.INIT_RAM_1A(func('h1a)), \\
	.INIT_RAM_1B(func('h1b)), \\
	.INIT_RAM_1C(func('h1c)), \\
	.INIT_RAM_1D(func('h1d)), \\
	.INIT_RAM_1E(func('h1e)), \\
	.INIT_RAM_1F(func('h1f)), \\
	.INIT_RAM_20(func('h20)), \\
	.INIT_RAM_21(func('h21)), \\
	.INIT_RAM_22(func('h22)), \\
	.INIT_RAM_23(func('h23)), \\
	.INIT_RAM_24(func('h24)), \\
	.INIT_RAM_25(func('h25)), \\
	.INIT_RAM_26(func('h26)), \\
	.INIT_RAM_27(func('h27)), \\
	.INIT_RAM_28(func('h28)), \\
	.INIT_RAM_29(func('h29)), \\
	.INIT_RAM_2A(func('h2a)), \\
	.INIT_RAM_2B(func('h2b)), \\
	.INIT_RAM_2C(func('h2c)), \\
	.INIT_RAM_2D(func('h2d)), \\
	.INIT_RAM_2E(func('h2e)), \\
	.INIT_RAM_2F(func('h2f)), \\
	.INIT_RAM_30(func('h30)), \\
	.INIT_RAM_31(func('h31)), \\
	.INIT_RAM_32(func('h32)), \\
	.INIT_RAM_33(func('h33)), \\
	.INIT_RAM_34(func('h34)), \\
	.INIT_RAM_35(func('h35)), \\
	.INIT_RAM_36(func('h36)), \\
	.INIT_RAM_37(func('h37)), \\
	.INIT_RAM_38(func('h38)), \\
	.INIT_RAM_39(func('h39)), \\
	.INIT_RAM_3A(func('h3a)), \\
	.INIT_RAM_3B(func('h3b)), \\
	.INIT_RAM_3C(func('h3c)), \\
	.INIT_RAM_3D(func('h3d)), \\
	.INIT_RAM_3E(func('h3e)), \\
	.INIT_RAM_3F(func('h3f)),

module $__GOWIN_SP_ (...);

parameter INIT = 0;
parameter OPTION_RESET_MODE = "SYNC";

parameter PORT_A_WIDTH = 36;
parameter PORT_A_OPTION_WRITE_MODE = 0;

input PORT_A_CLK;
input PORT_A_CLK_EN;
input PORT_A_WR_EN;
input PORT_A_RD_SRST;
input PORT_A_RD_ARST;
input [13:0] PORT_A_ADDR;
input [PORT_A_WIDTH-1:0] PORT_A_WR_DATA;
output [PORT_A_WIDTH-1:0] PORT_A_RD_DATA;

\`DEF_FUNCS

wire RST = OPTION_RESET_MODE == "SYNC" ? PORT_A_RD_SRST : PORT_A_RD_ARST;
wire [13:0] AD = \`addrbe_always(PORT_A_WIDTH, PORT_A_ADDR);

generate

if (PORT_A_WIDTH < 9) begin

	wire [31:0] DI = \`x8_wr_data(PORT_A_WR_DATA);
	wire [31:0] DO;

	assign PORT_A_RD_DATA = \`x8_rd_data(DO);

	SP #(
		\`INIT(init_slice_x8)
		.READ_MODE(1'b0),
		.WRITE_MODE(PORT_A_OPTION_WRITE_MODE),
		.BIT_WIDTH(\`x8_width(PORT_A_WIDTH)),
		.BLK_SEL(3'b000),
		.RESET_MODE(OPTION_RESET_MODE),
	) _TECHMAP_REPLACE_ (
		.BLKSEL(3'b000),
		.CLK(PORT_A_CLK),
		.CE(PORT_A_CLK_EN),
		.WRE(PORT_A_WR_EN),
		.RESET(RST),
		.OCE(1'b1),
		.AD(AD),
		.DI(DI),
		.DO(DO),
	);

end else begin

	wire [35:0] DI = PORT_A_WR_DATA;
	wire [35:0] DO;

	assign PORT_A_RD_DATA = DO;

	SPX9 #(
		\`INIT(init_slice_x9)
		.READ_MODE(1'b0),
		.WRITE_MODE(PORT_A_OPTION_WRITE_MODE),
		.BIT_WIDTH(PORT_A_WIDTH),
		.BLK_SEL(3'b000),
		.RESET_MODE(OPTION_RESET_MODE),
	) _TECHMAP_REPLACE_ (
		.BLKSEL(3'b000),
		.CLK(PORT_A_CLK),
		.CE(PORT_A_CLK_EN),
		.WRE(PORT_A_WR_EN),
		.RESET(RST),
		.OCE(1'b1),
		.AD(AD),
		.DI(DI),
		.DO(DO),
	);

end

endgenerate

endmodule


module $__GOWIN_DP_ (...);

parameter INIT = 0;
parameter OPTION_RESET_MODE = "SYNC";

parameter PORT_A_WIDTH = 18;
parameter PORT_A_OPTION_WRITE_MODE = 0;

parameter PORT_B_WIDTH = 18;
parameter PORT_B_OPTION_WRITE_MODE = 0;

input PORT_A_CLK;
input PORT_A_CLK_EN;
input PORT_A_WR_EN;
input PORT_A_RD_SRST;
input PORT_A_RD_ARST;
input [13:0] PORT_A_ADDR;
input [PORT_A_WIDTH-1:0] PORT_A_WR_DATA;
output [PORT_A_WIDTH-1:0] PORT_A_RD_DATA;

input PORT_B_CLK;
input PORT_B_CLK_EN;
input PORT_B_WR_EN;
input PORT_B_RD_SRST;
input PORT_B_RD_ARST;
input [13:0] PORT_B_ADDR;
input [PORT_A_WIDTH-1:0] PORT_B_WR_DATA;
output [PORT_A_WIDTH-1:0] PORT_B_RD_DATA;

\`DEF_FUNCS

wire RSTA = OPTION_RESET_MODE == "SYNC" ? PORT_A_RD_SRST : PORT_A_RD_ARST;
wire RSTB = OPTION_RESET_MODE == "SYNC" ? PORT_B_RD_SRST : PORT_B_RD_ARST;
wire [13:0] ADA = \`addrbe_always(PORT_A_WIDTH, PORT_A_ADDR);
wire [13:0] ADB = \`addrbe_always(PORT_B_WIDTH, PORT_B_ADDR);

generate

if (PORT_A_WIDTH < 9 || PORT_B_WIDTH < 9) begin

	wire [15:0] DIA = \`x8_wr_data(PORT_A_WR_DATA);
	wire [15:0] DIB = \`x8_wr_data(PORT_B_WR_DATA);
	wire [15:0] DOA;
	wire [15:0] DOB;

	assign PORT_A_RD_DATA = \`x8_rd_data(DOA);
	assign PORT_B_RD_DATA = \`x8_rd_data(DOB);

	DPB #(
		\`INIT(init_slice_x8)
		.READ_MODE0(1'b0),
		.READ_MODE1(1'b0),
		.WRITE_MODE0(PORT_A_OPTION_WRITE_MODE),
		.WRITE_MODE1(PORT_B_OPTION_WRITE_MODE),
		.BIT_WIDTH_0(\`x8_width(PORT_A_WIDTH)),
		.BIT_WIDTH_1(\`x8_width(PORT_B_WIDTH)),
		.BLK_SEL_0(3'b000),
		.BLK_SEL_1(3'b000),
		.RESET_MODE(OPTION_RESET_MODE),
	) _TECHMAP_REPLACE_ (
		.BLKSELA(3'b000),
		.BLKSELB(3'b000),

		.CLKA(PORT_A_CLK),
		.CEA(PORT_A_CLK_EN),
		.WREA(PORT_A_WR_EN),
		.RESETA(RSTA),
		.OCEA(1'b1),
		.ADA(ADA),
		.DIA(DIA),
		.DOA(DOA),

		.CLKB(PORT_B_CLK),
		.CEB(PORT_B_CLK_EN),
		.WREB(PORT_B_WR_EN),
		.RESETB(RSTB),
		.OCEB(1'b1),
		.ADB(ADB),
		.DIB(DIB),
		.DOB(DOB),
	);

end else begin

	wire [17:0] DIA = PORT_A_WR_DATA;
	wire [17:0] DIB = PORT_B_WR_DATA;
	wire [17:0] DOA;
	wire [17:0] DOB;

	assign PORT_A_RD_DATA = DOA;
	assign PORT_B_RD_DATA = DOB;

	DPX9B #(
		\`INIT(init_slice_x9)
		.READ_MODE0(1'b0),
		.READ_MODE1(1'b0),
		.WRITE_MODE0(PORT_A_OPTION_WRITE_MODE),
		.WRITE_MODE1(PORT_B_OPTION_WRITE_MODE),
		.BIT_WIDTH_0(PORT_A_WIDTH),
		.BIT_WIDTH_1(PORT_B_WIDTH),
		.BLK_SEL_0(3'b000),
		.BLK_SEL_1(3'b000),
		.RESET_MODE(OPTION_RESET_MODE),
	) _TECHMAP_REPLACE_ (
		.BLKSELA(3'b000),
		.BLKSELB(3'b000),

		.CLKA(PORT_A_CLK),
		.CEA(PORT_A_CLK_EN),
		.WREA(PORT_A_WR_EN),
		.RESETA(RSTA),
		.OCEA(1'b1),
		.ADA(ADA),
		.DIA(DIA),
		.DOA(DOA),

		.CLKB(PORT_B_CLK),
		.CEB(PORT_B_CLK_EN),
		.WREB(PORT_B_WR_EN),
		.RESETB(RSTB),
		.OCEB(1'b1),
		.ADB(ADB),
		.DIB(DIB),
		.DOB(DOB),
	);

end

endgenerate

endmodule


module $__GOWIN_SDP_ (...);

parameter INIT = 0;
parameter OPTION_RESET_MODE = "SYNC";

parameter PORT_R_WIDTH = 18;
parameter PORT_W_WIDTH = 18;

input PORT_R_CLK;
input PORT_R_CLK_EN;
input PORT_R_RD_SRST;
input PORT_R_RD_ARST;
input [13:0] PORT_R_ADDR;
output [PORT_R_WIDTH-1:0] PORT_R_RD_DATA;

input PORT_W_CLK;
input PORT_W_CLK_EN;
input PORT_W_WR_EN;
input [13:0] PORT_W_ADDR;
input [PORT_W_WIDTH-1:0] PORT_W_WR_DATA;

\`DEF_FUNCS

wire RST = OPTION_RESET_MODE == "SYNC" ? PORT_R_RD_SRST : PORT_R_RD_ARST;
wire [13:0] ADW = \`addrbe_always(PORT_W_WIDTH, PORT_W_ADDR);
wire WRE = PORT_W_CLK_EN & PORT_W_WR_EN;

generate

if (PORT_W_WIDTH < 9 || PORT_R_WIDTH < 9) begin

	wire [31:0] DI = \`x8_wr_data(PORT_W_WR_DATA);
	wire [31:0] DO;

	assign PORT_R_RD_DATA = \`x8_rd_data(DO);

	SDPB #(
		\`INIT(init_slice_x8)
		.READ_MODE(1'b0),
		.BIT_WIDTH_0(\`x8_width(PORT_W_WIDTH)),
		.BIT_WIDTH_1(\`x8_width(PORT_R_WIDTH)),
		.BLK_SEL_0(3'b000),
		.BLK_SEL_1(3'b000),
		.RESET_MODE(OPTION_RESET_MODE),
	) _TECHMAP_REPLACE_ (
		.BLKSELA(3'b000),
		.BLKSELB(3'b000),

		.CLKA(PORT_W_CLK),
		.CEA(WRE),
		.RESETA(1'b0),
		.ADA(ADW),
		.DI(DI),

		.CLKB(PORT_R_CLK),
		.CEB(PORT_R_CLK_EN),
		.RESETB(RST),
		.OCE(1'b1),
		.ADB(PORT_R_ADDR),
		.DO(DO),
	);

end else begin

	wire [35:0] DI = PORT_W_WR_DATA;
	wire [35:0] DO;

	assign PORT_R_RD_DATA = DO;

	SDPX9B #(
		\`INIT(init_slice_x9)
		.READ_MODE(1'b0),
		.BIT_WIDTH_0(PORT_W_WIDTH),
		.BIT_WIDTH_1(PORT_R_WIDTH),
		.BLK_SEL_0(3'b000),
		.BLK_SEL_1(3'b000),
		.RESET_MODE(OPTION_RESET_MODE),
	) _TECHMAP_REPLACE_ (
		.BLKSELA(3'b000),
		.BLKSELB(3'b000),

		.CLKA(PORT_W_CLK),
		.CEA(WRE),
		.RESETA(1'b0),
		.ADA(ADW),
		.DI(DI),

		.CLKB(PORT_R_CLK),
		.CEB(PORT_R_CLK_EN),
		.RESETB(RST),
		.OCE(1'b1),
		.ADB(PORT_R_ADDR),
		.DO(DO),
	);

end

endgenerate

endmodule
`,"cells_map.v":`\`default_nettype none
//All DFF* have INIT, but the hardware is always initialised to the reset
//value regardless. The parameter is ignored.

// DFFN			 D Flip-Flop with Negative-Edge Clock
module	\\$_DFF_N_ (input D, C, output Q);
	DFFN _TECHMAP_REPLACE_ (.D(D), .Q(Q), .CLK(C));
	wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule

// DFF			 D Flip-Flop
module	\\$_DFF_P_ (input D, C, output Q);
	DFF _TECHMAP_REPLACE_ (.D(D), .Q(Q), .CLK(C));
	wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule

// DFFE			 D Flip-Flop with Clock Enable
module	\\$_DFFE_PP_ (input D, C, E, output Q);
	DFFE _TECHMAP_REPLACE_ (.D(D), .Q(Q), .CLK(C), .CE(E));
	wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule

// DFFNE		 D Flip-Flop with Negative-Edge Clock and Clock Enable
module	\\$_DFFE_NP_ (input D, C, E, output Q);
	DFFNE _TECHMAP_REPLACE_ (.D(D), .Q(Q), .CLK(C), .CE(E));
	wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule

// DFFR			 D Flip-Flop with Synchronous Reset
module	\\$_SDFF_PP0_ (input D, C, R, output Q);
	DFFR _TECHMAP_REPLACE_ (.D(D), .Q(Q), .CLK(C), .RESET(R));
	wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule

// DFFNR		 D Flip-Flop with Negative-Edge Clock and Synchronous Reset
module	\\$_SDFF_NP0_ (input D, C, R, output Q);
	DFFNR _TECHMAP_REPLACE_ (.D(D), .Q(Q), .CLK(C), .RESET(R));
	wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule

// DFFRE		 D Flip-Flop with Clock Enable and Synchronous Reset
module	\\$_SDFFE_PP0P_ (input D, C, R, E, output Q);
	DFFRE _TECHMAP_REPLACE_ (.D(D), .Q(Q), .CLK(C), .RESET(R), .CE(E));
	wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule

// DFFNRE		 D Flip-Flop with Negative-Edge Clock,Clock Enable, and Synchronous Reset
module	\\$_SDFFE_NP0P_ (input D, C, R, E, output Q);
	DFFNRE _TECHMAP_REPLACE_ (.D(D), .Q(Q), .CLK(C), .RESET(R), .CE(E));
	wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule

// DFFS			 D Flip-Flop with Synchronous Set
module	\\$_SDFF_PP1_ (input D, C, R, output Q);
	DFFS _TECHMAP_REPLACE_ (.D(D), .Q(Q), .CLK(C), .SET(R));
	wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule

// DFFNS		 D Flip-Flop with Negative-Edge Clock and Synchronous Set
module	\\$_SDFF_NP1_ (input D, C, R, output Q);
	DFFNS _TECHMAP_REPLACE_ (.D(D), .Q(Q), .CLK(C), .SET(R));
	wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule

// DFFSE		 D Flip-Flop with Clock Enable and Synchronous Set
module	\\$_SDFFE_PP1P_ (input D, C, R, E, output Q);
	DFFSE _TECHMAP_REPLACE_ (.D(D), .Q(Q), .CLK(C), .SET(R), .CE(E));
	wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule

// DFFNSE		 D Flip-Flop with Negative-Edge Clock,Clock Enable,and Synchronous Set
module	\\$_SDFFE_NP1P_ (input D, C, R, E, output Q);
	DFFNSE _TECHMAP_REPLACE_ (.D(D), .Q(Q), .CLK(C), .SET(R), .CE(E));
	wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule

// DFFP			 D Flip-Flop with Asynchronous Preset
module	\\$_DFF_PP1_ (input D, C, R, output Q);
	DFFP _TECHMAP_REPLACE_ (.D(D), .Q(Q), .CLK(C), .PRESET(R));
	wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule

// DFFNP		 D Flip-Flop with Negative-Edge Clock and Asynchronous Preset
module	\\$_DFF_NP1_ (input D, C, R, output Q);
	DFFNP _TECHMAP_REPLACE_ (.D(D), .Q(Q), .CLK(C), .PRESET(R));
	wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule

// DFFC			 D Flip-Flop with Asynchronous Clear
module	\\$_DFF_PP0_ (input D, C, R, output Q);
	DFFC _TECHMAP_REPLACE_ (.D(D), .Q(Q), .CLK(C), .CLEAR(R));
	wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule

// DFFNC		 D Flip-Flop with Negative-Edge Clock and Asynchronous Clear
module	\\$_DFF_NP0_ (input D, C, R, output Q);
	DFFNC _TECHMAP_REPLACE_ (.D(D), .Q(Q), .CLK(C), .CLEAR(R));
	wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule

// DFFPE		 D Flip-Flop with Clock Enable and Asynchronous Preset
module	\\$_DFFE_PP1P_ (input D, C, R, E, output Q);
	DFFPE _TECHMAP_REPLACE_ (.D(D), .Q(Q), .CLK(C), .PRESET(R), .CE(E));
	wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule

// DFFNPE		 D Flip-Flop with Negative-Edge Clock,Clock Enable, and Asynchronous Preset
module	\\$_DFFE_NP1P_ (input D, C, R, E, output Q);
	DFFNPE _TECHMAP_REPLACE_ (.D(D), .Q(Q), .CLK(C), .PRESET(R), .CE(E));
	wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule

// DFFCE		 D Flip-Flop with Clock Enable and Asynchronous Clear
module	\\$_DFFE_PP0P_ (input D, C, R, E, output Q);
	DFFCE _TECHMAP_REPLACE_ (.D(D), .Q(Q), .CLK(C), .CLEAR(R), .CE(E));
	wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule

// DFFNCE		 D Flip-Flop with Negative-Edge Clock,Clock Enable and Asynchronous Clear
module	\\$_DFFE_NP0P_ (input D, C, R, E, output Q);
	DFFNCE _TECHMAP_REPLACE_ (.D(D), .Q(Q), .CLK(C), .CLEAR(R), .CE(E));
	wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule

module \\$lut (A, Y);
	parameter WIDTH = 0;
	parameter LUT = 0;

	(* force_downto *)
	input [WIDTH-1:0] A;
	output Y;

	generate
		if (WIDTH == 1) begin
			LUT1 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.F(Y),
				.I0(A[0]));
		end else
		if (WIDTH == 2) begin
			LUT2 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.F(Y),
				.I0(A[0]), .I1(A[1]));
		end else
		if (WIDTH == 3) begin
			LUT3 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.F(Y),
				.I0(A[0]), .I1(A[1]), .I2(A[2]));
		end else
		if (WIDTH == 4) begin
			LUT4 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.F(Y),
				.I0(A[0]), .I1(A[1]), .I2(A[2]), .I3(A[3]));
		end else
		if (WIDTH == 5) begin
			wire f0, f1;
			\\$lut #(.LUT(LUT[15: 0]), .WIDTH(4)) lut0 (.A(A[3:0]), .Y(f0));
			\\$lut #(.LUT(LUT[31:16]), .WIDTH(4)) lut1 (.A(A[3:0]), .Y(f1));
			MUX2_LUT5 mux5(.I0(f0), .I1(f1), .S0(A[4]), .O(Y));
		end else
		if (WIDTH == 6) begin
			wire f0, f1;
			\\$lut #(.LUT(LUT[31: 0]), .WIDTH(5)) lut0 (.A(A[4:0]), .Y(f0));
			\\$lut #(.LUT(LUT[63:32]), .WIDTH(5)) lut1 (.A(A[4:0]), .Y(f1));
			MUX2_LUT6 mux6(.I0(f0), .I1(f1), .S0(A[5]), .O(Y));
		end else
		if (WIDTH == 7) begin
			wire f0, f1;
			\\$lut #(.LUT(LUT[63: 0]), .WIDTH(6)) lut0 (.A(A[5:0]), .Y(f0));
			\\$lut #(.LUT(LUT[127:64]), .WIDTH(6)) lut1 (.A(A[5:0]), .Y(f1));
			MUX2_LUT7 mux7(.I0(f0), .I1(f1), .S0(A[6]), .O(Y));
		end else
		if (WIDTH == 8) begin
			wire f0, f1;
			\\$lut #(.LUT(LUT[127: 0]), .WIDTH(7)) lut0 (.A(A[6:0]), .Y(f0));
			\\$lut #(.LUT(LUT[255:128]), .WIDTH(7)) lut1 (.A(A[6:0]), .Y(f1));
			MUX2_LUT8 mux8(.I0(f0), .I1(f1), .S0(A[7]), .O(Y));
		end else begin
			wire _TECHMAP_FAIL_ = 1;
		end
	endgenerate
endmodule
`,"cells_sim.v":`(* abc9_lut=1 *)
module LUT1(output F, input I0);
	parameter [1:0] INIT = 0;
	specify
		(I0 => F) = (555, 902);
	endspecify
	assign F = I0 ? INIT[1] : INIT[0];
endmodule

(* abc9_lut=1 *)
module LUT2(output F, input I0, I1);
	parameter [3:0] INIT = 0;
	specify
		(I0 => F) = (867, 1184);
		(I1 => F) = (555, 902);
	endspecify
	wire [ 1: 0] s1 = I1 ? INIT[ 3: 2] : INIT[ 1: 0];
	assign F = I0 ? s1[1] : s1[0];
endmodule

(* abc9_lut=1 *)
module LUT3(output F, input I0, I1, I2);
	parameter [7:0] INIT = 0;
	specify
		(I0 => F) = (1054, 1486);
		(I1 => F) = (867, 1184);
		(I2 => F) = (555, 902);
	endspecify	
	wire [ 3: 0] s2 = I2 ? INIT[ 7: 4] : INIT[ 3: 0];
	wire [ 1: 0] s1 = I1 ?   s2[ 3: 2] :   s2[ 1: 0];
	assign F = I0 ? s1[1] : s1[0];
endmodule

(* abc9_lut=1 *)
module LUT4(output F, input I0, I1, I2, I3);
	parameter [15:0] INIT = 0;
	specify
		(I0 => F) = (1054, 1486);
		(I1 => F) = (1053, 1583);
		(I2 => F) = (867, 1184);
		(I3 => F) = (555, 902);
	endspecify	
	wire [ 7: 0] s3 = I3 ? INIT[15: 8] : INIT[ 7: 0];
	wire [ 3: 0] s2 = I2 ?   s3[ 7: 4] :   s3[ 3: 0];
	wire [ 1: 0] s1 = I1 ?   s2[ 3: 2] :   s2[ 1: 0];
	assign F = I0 ? s1[1] : s1[0];
endmodule

(* abc9_lut=2 *)
module __APICULA_LUT5(output F, input I0, I1, I2, I3, M0);
	specify
		(I0 => F) = (1187, 1638);
		(I1 => F) = (1184, 1638);
		(I2 => F) = (995, 1371);
		(I3 => F) = (808, 1116);
		(M0 => F) = (486, 680);
	endspecify	
endmodule

(* abc9_lut=4 *)
module __APICULA_LUT6(output F, input I0, I1, I2, I3, M0, M1);
	specify
		(I0 => F) = (1187 + 136, 1638 + 255);
		(I1 => F) = (1184 + 136, 1638 + 255);
		(I2 => F) = (995 + 136, 1371 + 255);
		(I3 => F) = (808 + 136, 1116 + 255);
		(M0 => F) = (486 + 136, 680 + 255);
		(M1 => F) = (478, 723);
	endspecify	
endmodule

(* abc9_lut=8 *)
module __APICULA_LUT7(output F, input I0, I1, I2, I3, M0, M1, M2);
	specify
		(I0 => F) = (1187 + 136 + 136, 1638 + 255 + 255);
		(I1 => F) = (1184 + 136 + 136, 1638 + 255 + 255);
		(I2 => F) = (995 + 136 + 136, 1371 + 255 + 255);
		(I3 => F) = (808 + 136 + 136, 1116 + 255 + 255);
		(M0 => F) = (486 + 136 + 136, 680 + 255 + 255);
		(M1 => F) = (478 + 136, 723 + 255);
		(M2 => F) = (478, 723);
	endspecify	
endmodule

(* abc9_lut=16 *)
module __APICULA_LUT8(output F, input I0, I1, I2, I3, M0, M1, M2, M3);
		specify
		(I0 => F) = (1187 + 136 + 136 + 136, 1638 + 255 + 255 + 255);
		(I1 => F) = (1184 + 136 + 136 + 136, 1638 + 255 + 255 + 255);
		(I2 => F) = (995 + 136 + 136 + 136, 1371 + 255 + 255 + 255);
		(I3 => F) = (808 + 136 + 136 + 136, 1116 + 255 + 255 + 255);
		(M0 => F) = (486 + 136 + 136 + 136, 680 + 255 + 255 + 255);
		(M1 => F) = (478 + 136 + 136, 723 + 255 + 255);
		(M2 => F) = (478 + 136, 723 + 255);
		(M3 => F) = (478, 723);
		endspecify	
	endmodule

module MUX2 (O, I0, I1, S0);
  input I0,I1;
  input S0;
  output O;

	specify
		(I0 => O) = (141, 160);
		(I1 => O) = (141, 160);
		(S0 => O) = (486, 680);
	endspecify

  assign O = S0 ? I1 : I0;
endmodule

module MUX2_LUT5 (O, I0, I1, S0);
  input I0,I1;
  input S0;
  output O;

	specify
		(I0 => O) = (141, 160);
		(I1 => O) = (141, 160);
		(S0 => O) = (486, 680);
	endspecify

  MUX2 mux2_lut5 (O, I0, I1, S0);
endmodule

module MUX2_LUT6 (O, I0, I1, S0);
  input I0,I1;
  input S0;
  output O;

	specify
		(I0 => O) = (136, 255);
		(I1 => O) = (136, 255);
		(S0 => O) = (478, 723);
	endspecify

  MUX2 mux2_lut6 (O, I0, I1, S0);
endmodule

module MUX2_LUT7 (O, I0, I1, S0);
  input I0,I1;
  input S0;
  output O;

	specify
		(I0 => O) = (136, 255);
		(I1 => O) = (136, 255);
		(S0 => O) = (478, 723);
	endspecify

  MUX2 mux2_lut7 (O, I0, I1, S0);
endmodule

module MUX2_LUT8 (O, I0, I1, S0);
  input I0,I1;
  input S0;
  output O;

	specify
		(I0 => O) = (136, 255);
		(I1 => O) = (136, 255);
		(S0 => O) = (478, 723);
	endspecify

  MUX2 mux2_lut8 (O, I0, I1, S0);
endmodule

(* abc9_flop, lib_whitebox *)
module DFF (output reg Q, input CLK, D);
	parameter [0:0] INIT = 1'b0;
	initial Q = INIT;

	specify
		(posedge CLK => (Q : D)) = (480, 660);
		$setup(D, posedge CLK, 576);
	endspecify

	always @(posedge CLK)
		Q <= D;
endmodule

(* abc9_flop, lib_whitebox *)
module DFFE (output reg Q, input D, CLK, CE);
  parameter [0:0] INIT = 1'b0;
  initial Q = INIT;

	specify
		if (CE) (posedge CLK => (Q : D)) = (480, 660);
		$setup(D, posedge CLK &&& CE, 576);
		$setup(CE, posedge CLK, 63);
	endspecify

  always @(posedge CLK) begin
    if (CE)
      Q <= D;
  end
endmodule // DFFE (positive clock edge; clock enable)

(* abc9_flop, lib_whitebox *)
module DFFS (output reg Q, input D, CLK, SET);
  parameter [0:0] INIT = 1'b1;
  initial Q = INIT;

	specify
		(posedge CLK => (Q : D)) = (480, 660);
		$setup(D, posedge CLK, 576);
		$setup(SET, posedge CLK, 63);
	endspecify

  always @(posedge CLK) begin
    if (SET)
      Q <= 1'b1;
    else
      Q <= D;	
  end
endmodule // DFFS (positive clock edge; synchronous set)

(* abc9_flop, lib_whitebox *)
module DFFSE (output reg Q, input D, CLK, CE, SET);
  parameter [0:0] INIT = 1'b1;
  initial Q = INIT;

	specify
		if (CE) (posedge CLK => (Q : D)) = (480, 660);
		$setup(D, posedge CLK &&& CE, 576);
		$setup(CE, posedge CLK, 63);
		$setup(SET, posedge CLK, 63);
	endspecify

  always @(posedge CLK) begin
    if (SET)
      Q <= 1'b1;
    else if (CE)
      Q <= D;
end
endmodule // DFFSE (positive clock edge; synchronous set takes precedence over clock enable)

(* abc9_flop, lib_whitebox *)
module DFFR (output reg Q, input D, CLK, RESET);
  parameter [0:0] INIT = 1'b0;
  initial Q = INIT;

	specify
		(posedge CLK => (Q : D)) = (480, 660);
		$setup(D, posedge CLK, 576);
		$setup(RESET, posedge CLK, 63);
	endspecify

  always @(posedge CLK) begin
    if (RESET)
      Q <= 1'b0;
    else
      Q <= D;
  end
endmodule // DFFR (positive clock edge; synchronous reset)

(* abc9_flop, lib_whitebox *)
module DFFRE (output reg Q, input D, CLK, CE, RESET);
  parameter [0:0] INIT = 1'b0;
  initial Q = INIT;

	specify
		if (CE) (posedge CLK => (Q : D)) = (480, 660);
		$setup(D, posedge CLK &&& CE, 576);
		$setup(CE, posedge CLK, 63);
		$setup(RESET, posedge CLK, 63);
	endspecify

  always @(posedge CLK) begin
    if (RESET)
      Q <= 1'b0;
    else if (CE)
      Q <= D;
  end
endmodule // DFFRE (positive clock edge; synchronous reset takes precedence over clock enable)

(* abc9_box, lib_whitebox *)
module DFFP (output reg Q, input D, CLK, PRESET);
  parameter [0:0] INIT = 1'b1;
  initial Q = INIT;

	specify
		(posedge CLK => (Q : D)) = (480, 660);
		(PRESET => Q) = (1800, 2679);
		$setup(D, posedge CLK, 576);
	endspecify

  always @(posedge CLK or posedge PRESET) begin
    if(PRESET)
      Q <= 1'b1;
    else
      Q <= D;
  end
endmodule // DFFP (positive clock edge; asynchronous preset)

(* abc9_box, lib_whitebox *)
module DFFPE (output reg Q, input D, CLK, CE, PRESET);
  parameter [0:0] INIT = 1'b1;
  initial Q = INIT;

	specify
		if (CE) (posedge CLK => (Q : D)) = (480, 660);
		(PRESET => Q) = (1800, 2679);
		$setup(D, posedge CLK &&& CE, 576);
		$setup(CE, posedge CLK, 63);
	endspecify

  always @(posedge CLK or posedge PRESET) begin
    if(PRESET)
      Q <= 1'b1;
    else if (CE)
      Q <= D;
  end
endmodule // DFFPE (positive clock edge; asynchronous preset; clock enable)

(* abc9_box, lib_whitebox *)
module DFFC (output reg Q, input D, CLK, CLEAR);
  parameter [0:0] INIT = 1'b0;
  initial Q = INIT;

	specify
		(posedge CLK => (Q : D)) = (480, 660);
		(CLEAR => Q) = (1800, 2679);
		$setup(D, posedge CLK, 576);
	endspecify

  always @(posedge CLK or posedge CLEAR) begin
    if(CLEAR)
      Q <= 1'b0;
    else
      Q <= D;
  end
endmodule // DFFC (positive clock edge; asynchronous clear)

(* abc9_box, lib_whitebox *)
module DFFCE (output reg Q, input D, CLK, CE, CLEAR);
  parameter [0:0] INIT = 1'b0;
  initial Q = INIT;

	specify
		if (CE) (posedge CLK => (Q : D)) = (480, 660);
		(CLEAR => Q) = (1800, 2679);
		$setup(D, posedge CLK &&& CE, 576);
		$setup(CE, posedge CLK, 63);
	endspecify

  always @(posedge CLK or posedge CLEAR) begin
    if(CLEAR)
      Q <= 1'b0;
    else if (CE)
      Q <= D;
  end
endmodule // DFFCE (positive clock edge; asynchronous clear; clock enable)

(* abc9_flop, lib_whitebox *)
module DFFN (output reg Q, input CLK, D);
	parameter [0:0] INIT = 1'b0;
	initial Q = INIT;

  specify
    (negedge CLK => (Q : D)) = (480, 660);
    $setup(D, negedge CLK, 576);
  endspecify

	always @(negedge CLK)
		Q <= D;
endmodule

(* abc9_flop, lib_whitebox *)
module DFFNE (output reg Q, input D, CLK, CE);
  parameter [0:0] INIT = 1'b0;
  initial Q = INIT;

	specify
		if (CE) (negedge CLK => (Q : D)) = (480, 660);
		$setup(D, negedge CLK &&& CE, 576);
		$setup(CE, negedge CLK, 63);
	endspecify

  always @(negedge CLK) begin
    if (CE)
      Q <= D;
  end
endmodule // DFFNE (negative clock edge; clock enable)

(* abc9_flop, lib_whitebox *)
module DFFNS (output reg Q, input D, CLK, SET);
  parameter [0:0] INIT = 1'b1;
  initial Q = INIT;
  
	specify
		(negedge CLK => (Q : D)) = (480, 660);
		$setup(D, negedge CLK, 576);
		$setup(SET, negedge CLK, 63);
	endspecify

  always @(negedge CLK) begin
    if (SET)
      Q <= 1'b1;
    else
      Q <= D;	
  end
endmodule // DFFNS (negative clock edge; synchronous set)

(* abc9_flop, lib_whitebox *)
module DFFNSE (output reg Q, input D, CLK, CE, SET);
  parameter [0:0] INIT = 1'b1;
  initial Q = INIT;

	specify
		if (CE) (negedge CLK => (Q : D)) = (480, 660);
		$setup(D, negedge CLK &&& CE, 576);
		$setup(CE, negedge CLK, 63);
		$setup(SET, negedge CLK, 63);
	endspecify

  always @(negedge CLK) begin
    if (SET)
      Q <= 1'b1;
    else if (CE)
      Q <= D;
end
endmodule // DFFNSE (negative clock edge; synchronous set takes precedence over clock enable)

(* abc9_flop, lib_whitebox *)
module DFFNR (output reg Q, input D, CLK, RESET);
  parameter [0:0] INIT = 1'b0;
  initial Q = INIT;

	specify
		(negedge CLK => (Q : D)) = (480, 660);
		$setup(D, negedge CLK, 576);
		$setup(RESET, negedge CLK, 63);
	endspecify

  always @(negedge CLK) begin
    if (RESET)
      Q <= 1'b0;
    else
      Q <= D;
  end
endmodule // DFFNR (negative clock edge; synchronous reset)

(* abc9_flop, lib_whitebox *)
module DFFNRE (output reg Q, input D, CLK, CE, RESET);
  parameter [0:0] INIT = 1'b0;
  initial Q = INIT;

	specify
		if (CE) (negedge CLK => (Q : D)) = (480, 660);
		$setup(D, negedge CLK &&& CE, 576);
		$setup(CE, negedge CLK, 63);
		$setup(RESET, negedge CLK, 63);
	endspecify

  always @(negedge CLK) begin
    if (RESET)
      Q <= 1'b0;
    else if (CE)
      Q <= D;
  end
endmodule // DFFNRE (negative clock edge; synchronous reset takes precedence over clock enable)

(* abc9_box, lib_whitebox *)
module DFFNP (output reg Q, input D, CLK, PRESET);
  parameter [0:0] INIT = 1'b1;
  initial Q = INIT;

	specify
		(negedge CLK => (Q : D)) = (480, 660);
		(PRESET => Q) = (1800, 2679);
		$setup(D, negedge CLK, 576);
	endspecify

  always @(negedge CLK or posedge PRESET) begin
    if(PRESET)
      Q <= 1'b1;
    else
      Q <= D;
  end
endmodule // DFFNP (negative clock edge; asynchronous preset)

(* abc9_box, lib_whitebox *)
module DFFNPE (output reg Q, input D, CLK, CE, PRESET);
  parameter [0:0] INIT = 1'b1;
  initial Q = INIT;
  
	specify
		if (CE) (negedge CLK => (Q : D)) = (480, 660);
		(PRESET => Q) = (1800, 2679);
		$setup(D, negedge CLK &&& CE, 576);
		$setup(CE, negedge CLK, 63);
	endspecify

  always @(negedge CLK or posedge PRESET) begin
    if(PRESET)
      Q <= 1'b1;
    else if (CE)
      Q <= D;
  end
endmodule // DFFNPE (negative clock edge; asynchronous preset; clock enable)

(* abc9_box, lib_whitebox *)
module DFFNC (output reg Q, input D, CLK, CLEAR);
  parameter [0:0] INIT = 1'b0;
  initial Q = INIT;

	specify
		(negedge CLK => (Q : D)) = (480, 660);
		(CLEAR => Q) = (1800, 2679);
		$setup(D, negedge CLK, 576);
	endspecify

  always @(negedge CLK or posedge CLEAR) begin
    if(CLEAR)
      Q <= 1'b0;
    else
      Q <= D;
  end
endmodule // DFFNC (negative clock edge; asynchronous clear)

(* abc9_box, lib_whitebox *)
module DFFNCE (output reg Q, input D, CLK, CE, CLEAR);
  parameter [0:0] INIT = 1'b0;
  initial Q = INIT;

	specify
		if (CE) (negedge CLK => (Q : D)) = (480, 660);
		(CLEAR => Q) = (1800, 2679);
		$setup(D, negedge CLK &&& CE, 576);
		$setup(CE, negedge CLK, 63);
	endspecify

  always @(negedge CLK or posedge CLEAR) begin
    if(CLEAR)
      Q <= 1'b0;
    else if (CE)
      Q <= D;
  end
endmodule // DFFNCE (negative clock edge; asynchronous clear; clock enable)

// TODO add more DFF sim cells

module VCC(output V);
	assign V = 1;
endmodule

module GND(output G);
	assign G = 0;
endmodule

module IBUF(output O, input I);

	specify
		(I => O) = 0;
	endspecify

	assign O = I;
endmodule

module OBUF(output O, input I);

	specify
		(I => O) = 0;
	endspecify

	assign O = I;
endmodule

module TBUF (O, I, OEN);
  input I, OEN;
  output O;
  assign O = OEN ? 1'bz : I;
endmodule

module IOBUF (O, IO, I, OEN);
  input I,OEN;
  output O;
  inout IO;
  assign IO = OEN ? 1'bz : I;
  assign I = IO;
endmodule

module ELVDS_OBUF (I, O, OB);
  input I;
  output O;
  output OB;
  assign O = I;
  assign OB = ~I;
endmodule

module TLVDS_OBUF (I, O, OB);
  input I;
  output O;
  output OB;
  assign O = I;
  assign OB = ~I;
endmodule

module OSER4(D3, D2, D1, D0, TX1, TX0, FCLK, PCLK, RESET, Q1, Q0);
	output Q1;
	output Q0;

	input D3;
	input D2;
	input D1;
	input D0;
	input TX1;
	input TX0;
	input FCLK;
	input PCLK;
	input RESET;

	parameter GSREN = "false";
	parameter LSREN = "true";
	parameter TXCLK_POL = 0;
	parameter HWL = "false";
endmodule

module OSER8(D7, D6, D5, D4, D3, D2, D1, D0, TX3, TX2, TX1, TX0, FCLK, PCLK, RESET, Q1, Q0);
	output Q1;
	output Q0;

	input D7;
	input D6;
	input D5;
	input D4;
	input D3;
	input D2;
	input D1;
	input D0;
	input TX3;
	input TX2;
	input TX1;
	input TX0;
	input FCLK;
	input PCLK;
	input RESET;

	parameter GSREN = "false";
	parameter LSREN = "true";
	parameter TXCLK_POL = 0;
	parameter HWL = "false";
endmodule

module OSER10(D9, D8, D7, D6, D5, D4, D3, D2, D1, D0, FCLK, PCLK, RESET, Q);
	output Q;

	input D9;
	input D8;
	input D7;
	input D6;
	input D5;
	input D4;
	input D3;
	input D2;
	input D1;
	input D0;
	input FCLK;
	input PCLK;
	input RESET;

	parameter GSREN = "false";
	parameter LSREN = "true";
endmodule

module OVIDEO(D6, D5, D4, D3, D2, D1, D0, FCLK, PCLK, RESET, Q);
	output Q;

	input D6;
	input D5;
	input D4;
	input D3;
	input D2;
	input D1;
	input D0;
	input FCLK;
	input PCLK;
	input RESET;

	parameter GSREN = "false";
	parameter LSREN = "true";
endmodule

module OSER16(D15, D14, D13, D12, D11, D10, 
D9, D8, D7, D6, D5, D4, D3, D2, D1, D0, FCLK, PCLK,
RESET, Q);
	output Q;

	input D15;
	input D14;
	input D13;
	input D12;
	input D11;
	input D10;
	input D9;
	input D8;
	input D7;
	input D6;
	input D5;
	input D4;
	input D3;
	input D2;
	input D1;
	input D0;
	input FCLK;
	input PCLK;
	input RESET;

	parameter GSREN = "false";
	parameter LSREN = "true";
endmodule

module IDES4(Q3, Q2, Q1, Q0, FCLK, PCLK,
RESET, CALIB, D);
	input D;
	input FCLK;
	input PCLK;
	input RESET;
	input CALIB;

	output Q3;
	output Q2;
	output Q1;
	output Q0;

	parameter GSREN = "false";
	parameter LSREN = "true";
endmodule

module IDES8(Q7, Q6, Q5, Q4, Q3, Q2, Q1, Q0, FCLK, PCLK,
RESET, CALIB, D);
	input D;
	input FCLK;
	input PCLK;
	input RESET;
	input CALIB;

	output Q7;
	output Q6;
	output Q5;
	output Q4;
	output Q3;
	output Q2;
	output Q1;
	output Q0;

	parameter GSREN = "false";
	parameter LSREN = "true";
endmodule

module IDES10(Q9, Q8, Q7, Q6, Q5, Q4, Q3, Q2, Q1, Q0, FCLK, PCLK,
RESET, CALIB, D);
	input D;
	input FCLK;
	input PCLK;
	input RESET;
	input CALIB;

	output Q9;
	output Q8;
	output Q7;
	output Q6;
	output Q5;
	output Q4;
	output Q3;
	output Q2;
	output Q1;
	output Q0;

	parameter GSREN = "false";
	parameter LSREN = "true";
endmodule

module IVIDEO(Q6, Q5, Q4, Q3, Q2, Q1, Q0, FCLK, PCLK,
RESET, CALIB, D);
	input D;
	input FCLK;
	input PCLK;
	input RESET;
	input CALIB;

	output Q6;
	output Q5;
	output Q4;
	output Q3;
	output Q2;
	output Q1;
	output Q0;

	parameter GSREN = "false";
	parameter LSREN = "true";
endmodule

module IDES16(Q15, Q14, Q13, Q12, Q11, Q10, 
Q9, Q8, Q7, Q6, Q5, Q4, Q3, Q2, Q1, Q0, FCLK, PCLK,
RESET, CALIB, D);
	input D;
	input FCLK;
	input PCLK;
	input RESET;
	input CALIB;

	output Q15;
	output Q14;
	output Q13;
	output Q12;
	output Q11;
	output Q10;
	output Q9;
	output Q8;
	output Q7;
	output Q6;
	output Q5;
	output Q4;
	output Q3;
	output Q2;
	output Q1;
	output Q0;

	parameter GSREN = "false";
	parameter LSREN = "true";
endmodule

module IDDR(D, CLK, Q0, Q1);
	input D;
	input CLK;
	output Q0;
	output Q1;
	parameter Q0_INIT = 1'b0;
	parameter Q1_INIT = 1'b0;
endmodule

module IDDRC(D, CLK, CLEAR, Q0, Q1);
	input D;
	input CLK;
	input CLEAR;
	output Q0;
	output Q1;
	parameter Q0_INIT = 1'b0;
	parameter Q1_INIT = 1'b0;
endmodule

(* blackbox *)
module ODDR(D0, D1, TX, CLK, Q0, Q1);
	input D0;
	input D1;
	input TX;
	input CLK;
	output Q0;
	output Q1;
	parameter TXCLK_POL = 0;
	parameter INIT = 0;
endmodule

(* blackbox *)
module ODDRC(D0, D1, CLEAR, TX, CLK, Q0, Q1);
	input D0;
	input D1;
	input CLEAR;
	input TX;
	input CLK;
	output Q0;
	output Q1;
	parameter TXCLK_POL = 0;
	parameter INIT = 0;
endmodule

module GSR (input GSRI);
	wire GSRO = GSRI;
endmodule

(* abc9_box, lib_whitebox *)
module ALU (SUM, COUT, I0, I1, I3, CIN);

input I0;
input I1;
input I3;
(* abc9_carry *) input CIN;
output SUM;
(* abc9_carry *) output COUT;

localparam ADD = 0;
localparam SUB = 1;
localparam ADDSUB = 2;
localparam NE = 3;
localparam GE = 4;
localparam LE = 5;
localparam CUP = 6;
localparam CDN = 7;
localparam CUPCDN = 8;
localparam MULT = 9;

parameter ALU_MODE = 0;

reg S, C;

specify
	(I0 => SUM) = (1043, 1432);
	(I1 => SUM) = (775, 1049);
	(I3 => SUM) = (751, 1010);
	(CIN => SUM) = (694, 811);
	(I0  => COUT) = (1010, 1380);
	(I1  => COUT) = (1021, 1505);
	(I3  => COUT) = (483, 792);
	(CIN => COUT) = (49, 82);
endspecify

assign SUM = S ^ CIN;
assign COUT = S? CIN : C;

always @* begin
	case (ALU_MODE)
		ADD: begin
			S = I0 ^ I1;
			C = I0;
		end
		SUB: begin
			S = I0 ^ ~I1;
			C = I0;
		end
		ADDSUB: begin
			S = I3? I0 ^ I1 : I0 ^ ~I1;
			C = I0;
		end
		NE: begin
			S = I0 ^ ~I1;
			C = 1'b1;
		end
		GE: begin
			S = I0 ^ ~I1;
			C = I0;
		end
		LE: begin
			S = ~I0 ^ I1;
			C = I1;
		end
		CUP: begin
			S = I0;
			C = 1'b0;
		end
		CDN: begin
			S = ~I0;
			C = 1'b1;
		end
		CUPCDN: begin
			S = I3? I0 : ~I0;
			C = I0;
		end
		MULT: begin
			S = I0 & I1;
			C = I0 & I1;
		end
	endcase
end

endmodule

(* abc9_flop, lib_whitebox *)
module RAM16S1 (DO, DI, AD, WRE, CLK);

parameter INIT_0 = 16'h0000;

input [3:0] AD;
input DI;
output DO;
input CLK;
input WRE;

specify
	(AD *> DO) = (270, 405);
	$setup(DI, posedge CLK, 62);
	$setup(WRE, posedge CLK, 62);
	$setup(AD, posedge CLK, 62);
	(posedge CLK => (DO : 1'bx)) = (474, 565);
endspecify

reg [15:0] mem;

initial begin
	mem = INIT_0;
end

assign DO = mem[AD];

always @(posedge CLK) begin
	if (WRE) begin
		mem[AD] <= DI;
	end
end

endmodule

(* abc9_flop, lib_whitebox *)
module RAM16S2 (DO, DI, AD, WRE, CLK);

parameter INIT_0 = 16'h0000;
parameter INIT_1 = 16'h0000;

input [3:0] AD;
input [1:0] DI;
output [1:0] DO;
input CLK;
input WRE;

specify
	(AD *> DO) = (270, 405);
	$setup(DI, posedge CLK, 62);
	$setup(WRE, posedge CLK, 62);
	$setup(AD, posedge CLK, 62);
	(posedge CLK => (DO : 2'bx)) = (474, 565);
endspecify

reg [15:0] mem0, mem1;

initial begin
	mem0 = INIT_0;
	mem1 = INIT_1;
end

assign DO[0] = mem0[AD];
assign DO[1] = mem1[AD];

always @(posedge CLK) begin
	if (WRE) begin
		mem0[AD] <= DI[0];
		mem1[AD] <= DI[1];
	end
end

endmodule

(* abc9_flop, lib_whitebox *)
module RAM16S4 (DO, DI, AD, WRE, CLK);

parameter INIT_0 = 16'h0000;
parameter INIT_1 = 16'h0000;
parameter INIT_2 = 16'h0000;
parameter INIT_3 = 16'h0000;

input [3:0] AD;
input [3:0] DI;
output [3:0] DO;
input CLK;
input WRE;

specify
	(AD *> DO) = (270, 405);
	$setup(DI, posedge CLK, 62);
	$setup(WRE, posedge CLK, 62);
	$setup(AD, posedge CLK, 62);
	(posedge CLK => (DO : 4'bx)) = (474, 565);
endspecify

reg [15:0] mem0, mem1, mem2, mem3;

initial begin
	mem0 = INIT_0;
	mem1 = INIT_1;
	mem2 = INIT_2;
	mem3 = INIT_3;
end

assign DO[0] = mem0[AD];
assign DO[1] = mem1[AD];
assign DO[2] = mem2[AD];
assign DO[3] = mem3[AD];

always @(posedge CLK) begin
	if (WRE) begin
		mem0[AD] <= DI[0];
		mem1[AD] <= DI[1];
		mem2[AD] <= DI[2];
		mem3[AD] <= DI[3];
	end
end

endmodule


module RAM16SDP1 (DO, DI, WAD, RAD, WRE, CLK);

parameter INIT_0 = 16'h0000;

input [3:0] WAD;
input [3:0] RAD;
input DI;
output DO;
input CLK;
input WRE;

specify
	(RAD *> DO) = (270, 405);
	$setup(DI, posedge CLK, 62);
	$setup(WRE, posedge CLK, 62);
	$setup(WAD, posedge CLK, 62);
	(posedge CLK => (DO : 1'bx)) = (474, 565);
endspecify

reg [15:0] mem;

initial begin
	mem = INIT_0;
end

assign DO = mem[RAD];

always @(posedge CLK) begin
	if (WRE) begin
		mem[WAD] <= DI;
	end
end

endmodule


module RAM16SDP2 (DO, DI, WAD, RAD, WRE, CLK);

parameter INIT_0 = 16'h0000;
parameter INIT_1 = 16'h0000;

input [3:0] WAD;
input [3:0] RAD;
input [1:0] DI;
output [1:0] DO;
input CLK;
input WRE;

specify
	(RAD *> DO) = (270, 405);
	$setup(DI, posedge CLK, 62);
	$setup(WRE, posedge CLK, 62);
	$setup(WAD, posedge CLK, 62);
	(posedge CLK => (DO : 2'bx)) = (474, 565);
endspecify

reg [15:0] mem0, mem1;

initial begin
	mem0 = INIT_0;
	mem1 = INIT_1;
end

assign DO[0] = mem0[RAD];
assign DO[1] = mem1[RAD];

always @(posedge CLK) begin
	if (WRE) begin
		mem0[WAD] <= DI[0];
		mem1[WAD] <= DI[1];
	end
end

endmodule


module RAM16SDP4 (DO, DI, WAD, RAD, WRE, CLK);

parameter INIT_0 = 16'h0000;
parameter INIT_1 = 16'h0000;
parameter INIT_2 = 16'h0000;
parameter INIT_3 = 16'h0000;

input [3:0] WAD;
input [3:0] RAD;
input [3:0] DI;
output [3:0] DO;
input CLK;
input WRE;

specify
	(RAD *> DO) = (270, 405);
	$setup(DI, posedge CLK, 62);
	$setup(WRE, posedge CLK, 62);
	$setup(WAD, posedge CLK, 62);
	(posedge CLK => (DO : 4'bx)) = (474, 565);
endspecify

reg [15:0] mem0, mem1, mem2, mem3;

initial begin
	mem0 = INIT_0;
	mem1 = INIT_1;
	mem2 = INIT_2;
	mem3 = INIT_3;
end

assign DO[0] = mem0[RAD];
assign DO[1] = mem1[RAD];
assign DO[2] = mem2[RAD];
assign DO[3] = mem3[RAD];

always @(posedge CLK) begin
	if (WRE) begin
		mem0[WAD] <= DI[0];
		mem1[WAD] <= DI[1];
		mem2[WAD] <= DI[2];
		mem3[WAD] <= DI[3];
	end
end

endmodule


(* blackbox *)
module SP (DO, DI, BLKSEL, AD, WRE, CLK, CE, OCE, RESET);

// 1 Enables output pipeline registers.
parameter READ_MODE = 1'b0;
// 0: no read on write, 1: transparent, 2: read-before-write
parameter WRITE_MODE = 2'b00;
parameter BIT_WIDTH = 32; // 1, 2, 4, 8, 16, 32
parameter BLK_SEL = 3'b000;
parameter RESET_MODE = "SYNC";
parameter INIT_RAM_00 = 256'h0;
parameter INIT_RAM_01 = 256'h0;
parameter INIT_RAM_02 = 256'h0;
parameter INIT_RAM_03 = 256'h0;
parameter INIT_RAM_04 = 256'h0;
parameter INIT_RAM_05 = 256'h0;
parameter INIT_RAM_06 = 256'h0;
parameter INIT_RAM_07 = 256'h0;
parameter INIT_RAM_08 = 256'h0;
parameter INIT_RAM_09 = 256'h0;
parameter INIT_RAM_0A = 256'h0;
parameter INIT_RAM_0B = 256'h0;
parameter INIT_RAM_0C = 256'h0;
parameter INIT_RAM_0D = 256'h0;
parameter INIT_RAM_0E = 256'h0;
parameter INIT_RAM_0F = 256'h0;
parameter INIT_RAM_10 = 256'h0;
parameter INIT_RAM_11 = 256'h0;
parameter INIT_RAM_12 = 256'h0;
parameter INIT_RAM_13 = 256'h0;
parameter INIT_RAM_14 = 256'h0;
parameter INIT_RAM_15 = 256'h0;
parameter INIT_RAM_16 = 256'h0;
parameter INIT_RAM_17 = 256'h0;
parameter INIT_RAM_18 = 256'h0;
parameter INIT_RAM_19 = 256'h0;
parameter INIT_RAM_1A = 256'h0;
parameter INIT_RAM_1B = 256'h0;
parameter INIT_RAM_1C = 256'h0;
parameter INIT_RAM_1D = 256'h0;
parameter INIT_RAM_1E = 256'h0;
parameter INIT_RAM_1F = 256'h0;
parameter INIT_RAM_20 = 256'h0;
parameter INIT_RAM_21 = 256'h0;
parameter INIT_RAM_22 = 256'h0;
parameter INIT_RAM_23 = 256'h0;
parameter INIT_RAM_24 = 256'h0;
parameter INIT_RAM_25 = 256'h0;
parameter INIT_RAM_26 = 256'h0;
parameter INIT_RAM_27 = 256'h0;
parameter INIT_RAM_28 = 256'h0;
parameter INIT_RAM_29 = 256'h0;
parameter INIT_RAM_2A = 256'h0;
parameter INIT_RAM_2B = 256'h0;
parameter INIT_RAM_2C = 256'h0;
parameter INIT_RAM_2D = 256'h0;
parameter INIT_RAM_2E = 256'h0;
parameter INIT_RAM_2F = 256'h0;
parameter INIT_RAM_30 = 256'h0;
parameter INIT_RAM_31 = 256'h0;
parameter INIT_RAM_32 = 256'h0;
parameter INIT_RAM_33 = 256'h0;
parameter INIT_RAM_34 = 256'h0;
parameter INIT_RAM_35 = 256'h0;
parameter INIT_RAM_36 = 256'h0;
parameter INIT_RAM_37 = 256'h0;
parameter INIT_RAM_38 = 256'h0;
parameter INIT_RAM_39 = 256'h0;
parameter INIT_RAM_3A = 256'h0;
parameter INIT_RAM_3B = 256'h0;
parameter INIT_RAM_3C = 256'h0;
parameter INIT_RAM_3D = 256'h0;
parameter INIT_RAM_3E = 256'h0;
parameter INIT_RAM_3F = 256'h0;

output [31:0] DO;
input [31:0] DI;
input [2:0] BLKSEL;
input [13:0] AD;
input WRE;
input CLK;
input CE;
input OCE;
input RESET;

endmodule

(* blackbox *)
module SPX9 (DO, DI, BLKSEL, AD, WRE, CLK, CE, OCE, RESET);

// 1 Enables output pipeline registers.
parameter READ_MODE = 1'b0;
// 0: no read on write, 1: transparent, 2: read-before-write
parameter WRITE_MODE = 2'b00;
parameter BIT_WIDTH = 36; // 9, 18, 36
parameter BLK_SEL = 3'b000;
parameter RESET_MODE = "SYNC";
parameter INIT_RAM_00 = 288'h0;
parameter INIT_RAM_01 = 288'h0;
parameter INIT_RAM_02 = 288'h0;
parameter INIT_RAM_03 = 288'h0;
parameter INIT_RAM_04 = 288'h0;
parameter INIT_RAM_05 = 288'h0;
parameter INIT_RAM_06 = 288'h0;
parameter INIT_RAM_07 = 288'h0;
parameter INIT_RAM_08 = 288'h0;
parameter INIT_RAM_09 = 288'h0;
parameter INIT_RAM_0A = 288'h0;
parameter INIT_RAM_0B = 288'h0;
parameter INIT_RAM_0C = 288'h0;
parameter INIT_RAM_0D = 288'h0;
parameter INIT_RAM_0E = 288'h0;
parameter INIT_RAM_0F = 288'h0;
parameter INIT_RAM_10 = 288'h0;
parameter INIT_RAM_11 = 288'h0;
parameter INIT_RAM_12 = 288'h0;
parameter INIT_RAM_13 = 288'h0;
parameter INIT_RAM_14 = 288'h0;
parameter INIT_RAM_15 = 288'h0;
parameter INIT_RAM_16 = 288'h0;
parameter INIT_RAM_17 = 288'h0;
parameter INIT_RAM_18 = 288'h0;
parameter INIT_RAM_19 = 288'h0;
parameter INIT_RAM_1A = 288'h0;
parameter INIT_RAM_1B = 288'h0;
parameter INIT_RAM_1C = 288'h0;
parameter INIT_RAM_1D = 288'h0;
parameter INIT_RAM_1E = 288'h0;
parameter INIT_RAM_1F = 288'h0;
parameter INIT_RAM_20 = 288'h0;
parameter INIT_RAM_21 = 288'h0;
parameter INIT_RAM_22 = 288'h0;
parameter INIT_RAM_23 = 288'h0;
parameter INIT_RAM_24 = 288'h0;
parameter INIT_RAM_25 = 288'h0;
parameter INIT_RAM_26 = 288'h0;
parameter INIT_RAM_27 = 288'h0;
parameter INIT_RAM_28 = 288'h0;
parameter INIT_RAM_29 = 288'h0;
parameter INIT_RAM_2A = 288'h0;
parameter INIT_RAM_2B = 288'h0;
parameter INIT_RAM_2C = 288'h0;
parameter INIT_RAM_2D = 288'h0;
parameter INIT_RAM_2E = 288'h0;
parameter INIT_RAM_2F = 288'h0;
parameter INIT_RAM_30 = 288'h0;
parameter INIT_RAM_31 = 288'h0;
parameter INIT_RAM_32 = 288'h0;
parameter INIT_RAM_33 = 288'h0;
parameter INIT_RAM_34 = 288'h0;
parameter INIT_RAM_35 = 288'h0;
parameter INIT_RAM_36 = 288'h0;
parameter INIT_RAM_37 = 288'h0;
parameter INIT_RAM_38 = 288'h0;
parameter INIT_RAM_39 = 288'h0;
parameter INIT_RAM_3A = 288'h0;
parameter INIT_RAM_3B = 288'h0;
parameter INIT_RAM_3C = 288'h0;
parameter INIT_RAM_3D = 288'h0;
parameter INIT_RAM_3E = 288'h0;
parameter INIT_RAM_3F = 288'h0;

output [35:0] DO;
input [35:0] DI;
input [2:0] BLKSEL;
input [13:0] AD;
input WRE;
input CLK;
input CE;
input OCE;
input RESET;

endmodule


(* blackbox *)
module SDP (DO, DI, BLKSEL, ADA, ADB, WREA, WREB, CLKA, CLKB, CEA, CEB, OCE, RESETA, RESETB);

parameter READ_MODE = 1'b0;
parameter BIT_WIDTH_0 = 32; // 1, 2, 4, 8, 16, 32
parameter BIT_WIDTH_1 = 32; // 1, 2, 4, 8, 16, 32
parameter BLK_SEL = 3'b000;
parameter RESET_MODE = "SYNC";
parameter INIT_RAM_00 = 256'h0;
parameter INIT_RAM_01 = 256'h0;
parameter INIT_RAM_02 = 256'h0;
parameter INIT_RAM_03 = 256'h0;
parameter INIT_RAM_04 = 256'h0;
parameter INIT_RAM_05 = 256'h0;
parameter INIT_RAM_06 = 256'h0;
parameter INIT_RAM_07 = 256'h0;
parameter INIT_RAM_08 = 256'h0;
parameter INIT_RAM_09 = 256'h0;
parameter INIT_RAM_0A = 256'h0;
parameter INIT_RAM_0B = 256'h0;
parameter INIT_RAM_0C = 256'h0;
parameter INIT_RAM_0D = 256'h0;
parameter INIT_RAM_0E = 256'h0;
parameter INIT_RAM_0F = 256'h0;
parameter INIT_RAM_10 = 256'h0;
parameter INIT_RAM_11 = 256'h0;
parameter INIT_RAM_12 = 256'h0;
parameter INIT_RAM_13 = 256'h0;
parameter INIT_RAM_14 = 256'h0;
parameter INIT_RAM_15 = 256'h0;
parameter INIT_RAM_16 = 256'h0;
parameter INIT_RAM_17 = 256'h0;
parameter INIT_RAM_18 = 256'h0;
parameter INIT_RAM_19 = 256'h0;
parameter INIT_RAM_1A = 256'h0;
parameter INIT_RAM_1B = 256'h0;
parameter INIT_RAM_1C = 256'h0;
parameter INIT_RAM_1D = 256'h0;
parameter INIT_RAM_1E = 256'h0;
parameter INIT_RAM_1F = 256'h0;
parameter INIT_RAM_20 = 256'h0;
parameter INIT_RAM_21 = 256'h0;
parameter INIT_RAM_22 = 256'h0;
parameter INIT_RAM_23 = 256'h0;
parameter INIT_RAM_24 = 256'h0;
parameter INIT_RAM_25 = 256'h0;
parameter INIT_RAM_26 = 256'h0;
parameter INIT_RAM_27 = 256'h0;
parameter INIT_RAM_28 = 256'h0;
parameter INIT_RAM_29 = 256'h0;
parameter INIT_RAM_2A = 256'h0;
parameter INIT_RAM_2B = 256'h0;
parameter INIT_RAM_2C = 256'h0;
parameter INIT_RAM_2D = 256'h0;
parameter INIT_RAM_2E = 256'h0;
parameter INIT_RAM_2F = 256'h0;
parameter INIT_RAM_30 = 256'h0;
parameter INIT_RAM_31 = 256'h0;
parameter INIT_RAM_32 = 256'h0;
parameter INIT_RAM_33 = 256'h0;
parameter INIT_RAM_34 = 256'h0;
parameter INIT_RAM_35 = 256'h0;
parameter INIT_RAM_36 = 256'h0;
parameter INIT_RAM_37 = 256'h0;
parameter INIT_RAM_38 = 256'h0;
parameter INIT_RAM_39 = 256'h0;
parameter INIT_RAM_3A = 256'h0;
parameter INIT_RAM_3B = 256'h0;
parameter INIT_RAM_3C = 256'h0;
parameter INIT_RAM_3D = 256'h0;
parameter INIT_RAM_3E = 256'h0;
parameter INIT_RAM_3F = 256'h0;

output [31:0] DO;
input [31:0] DI;
input [2:0] BLKSEL;
input [13:0] ADA, ADB;
input WREA, WREB;
input CLKA, CLKB;
input CEA, CEB;
input OCE;
input RESETA, RESETB;

specify
	(posedge CLKB => (DO : DI)) = (419, 493);
	$setup(RESETA, posedge CLKA, 62);
	$setup(RESETB, posedge CLKB, 62);
	$setup(OCE, posedge CLKB, 62);
	$setup(CEA, posedge CLKA, 62);
	$setup(CEB, posedge CLKB, 62);
	$setup(OCE, posedge CLKB, 62);
	$setup(WREA, posedge CLKA, 62);
	$setup(WREB, posedge CLKB, 62);
	$setup(DI, posedge CLKA, 62);
	$setup(ADA, posedge CLKA, 62);
	$setup(ADB, posedge CLKB, 62);
	$setup(BLKSEL, posedge CLKA, 62);
endspecify

endmodule

(* blackbox *)
module SDPX9 (DO, DI, BLKSEL, ADA, ADB, WREA, WREB, CLKA, CLKB, CEA, CEB, OCE, RESETA, RESETB);

parameter READ_MODE = 1'b0;
parameter BIT_WIDTH_0 = 36; // 9, 18, 36
parameter BIT_WIDTH_1 = 36; // 9, 18, 36
parameter BLK_SEL = 3'b000;
parameter RESET_MODE = "SYNC";
parameter INIT_RAM_00 = 288'h0;
parameter INIT_RAM_01 = 288'h0;
parameter INIT_RAM_02 = 288'h0;
parameter INIT_RAM_03 = 288'h0;
parameter INIT_RAM_04 = 288'h0;
parameter INIT_RAM_05 = 288'h0;
parameter INIT_RAM_06 = 288'h0;
parameter INIT_RAM_07 = 288'h0;
parameter INIT_RAM_08 = 288'h0;
parameter INIT_RAM_09 = 288'h0;
parameter INIT_RAM_0A = 288'h0;
parameter INIT_RAM_0B = 288'h0;
parameter INIT_RAM_0C = 288'h0;
parameter INIT_RAM_0D = 288'h0;
parameter INIT_RAM_0E = 288'h0;
parameter INIT_RAM_0F = 288'h0;
parameter INIT_RAM_10 = 288'h0;
parameter INIT_RAM_11 = 288'h0;
parameter INIT_RAM_12 = 288'h0;
parameter INIT_RAM_13 = 288'h0;
parameter INIT_RAM_14 = 288'h0;
parameter INIT_RAM_15 = 288'h0;
parameter INIT_RAM_16 = 288'h0;
parameter INIT_RAM_17 = 288'h0;
parameter INIT_RAM_18 = 288'h0;
parameter INIT_RAM_19 = 288'h0;
parameter INIT_RAM_1A = 288'h0;
parameter INIT_RAM_1B = 288'h0;
parameter INIT_RAM_1C = 288'h0;
parameter INIT_RAM_1D = 288'h0;
parameter INIT_RAM_1E = 288'h0;
parameter INIT_RAM_1F = 288'h0;
parameter INIT_RAM_20 = 288'h0;
parameter INIT_RAM_21 = 288'h0;
parameter INIT_RAM_22 = 288'h0;
parameter INIT_RAM_23 = 288'h0;
parameter INIT_RAM_24 = 288'h0;
parameter INIT_RAM_25 = 288'h0;
parameter INIT_RAM_26 = 288'h0;
parameter INIT_RAM_27 = 288'h0;
parameter INIT_RAM_28 = 288'h0;
parameter INIT_RAM_29 = 288'h0;
parameter INIT_RAM_2A = 288'h0;
parameter INIT_RAM_2B = 288'h0;
parameter INIT_RAM_2C = 288'h0;
parameter INIT_RAM_2D = 288'h0;
parameter INIT_RAM_2E = 288'h0;
parameter INIT_RAM_2F = 288'h0;
parameter INIT_RAM_30 = 288'h0;
parameter INIT_RAM_31 = 288'h0;
parameter INIT_RAM_32 = 288'h0;
parameter INIT_RAM_33 = 288'h0;
parameter INIT_RAM_34 = 288'h0;
parameter INIT_RAM_35 = 288'h0;
parameter INIT_RAM_36 = 288'h0;
parameter INIT_RAM_37 = 288'h0;
parameter INIT_RAM_38 = 288'h0;
parameter INIT_RAM_39 = 288'h0;
parameter INIT_RAM_3A = 288'h0;
parameter INIT_RAM_3B = 288'h0;
parameter INIT_RAM_3C = 288'h0;
parameter INIT_RAM_3D = 288'h0;
parameter INIT_RAM_3E = 288'h0;
parameter INIT_RAM_3F = 288'h0;

output [35:0] DO;
input [35:0] DI;
input [2:0] BLKSEL;
input [13:0] ADA, ADB;
input WREA, WREB;
input CLKA, CLKB;
input CEA, CEB;
input OCE;
input RESETA, RESETB;

specify
	(posedge CLKB => (DO : DI)) = (419, 493);
	$setup(RESETA, posedge CLKA, 62);
	$setup(RESETB, posedge CLKB, 62);
	$setup(OCE, posedge CLKB, 62);
	$setup(CEA, posedge CLKA, 62);
	$setup(CEB, posedge CLKB, 62);
	$setup(OCE, posedge CLKB, 62);
	$setup(WREA, posedge CLKA, 62);
	$setup(WREB, posedge CLKB, 62);
	$setup(DI, posedge CLKA, 62);
	$setup(ADA, posedge CLKA, 62);
	$setup(ADB, posedge CLKB, 62);
	$setup(BLKSEL, posedge CLKA, 62);
endspecify

endmodule


(* blackbox *)
module DP (DOA, DOB, DIA, DIB, BLKSEL, ADA, ADB, WREA, WREB, CLKA, CLKB, CEA, CEB, OCEA, OCEB, RESETA, RESETB);

parameter READ_MODE0 = 1'b0;
parameter READ_MODE1 = 1'b0;
parameter WRITE_MODE0 = 2'b00;
parameter WRITE_MODE1 = 2'b00;
parameter BIT_WIDTH_0 = 16; // 1, 2, 4, 8, 16
parameter BIT_WIDTH_1 = 16; // 1, 2, 4, 8, 16
parameter BLK_SEL = 3'b000;
parameter RESET_MODE = "SYNC";
parameter INIT_RAM_00 = 256'h0;
parameter INIT_RAM_01 = 256'h0;
parameter INIT_RAM_02 = 256'h0;
parameter INIT_RAM_03 = 256'h0;
parameter INIT_RAM_04 = 256'h0;
parameter INIT_RAM_05 = 256'h0;
parameter INIT_RAM_06 = 256'h0;
parameter INIT_RAM_07 = 256'h0;
parameter INIT_RAM_08 = 256'h0;
parameter INIT_RAM_09 = 256'h0;
parameter INIT_RAM_0A = 256'h0;
parameter INIT_RAM_0B = 256'h0;
parameter INIT_RAM_0C = 256'h0;
parameter INIT_RAM_0D = 256'h0;
parameter INIT_RAM_0E = 256'h0;
parameter INIT_RAM_0F = 256'h0;
parameter INIT_RAM_10 = 256'h0;
parameter INIT_RAM_11 = 256'h0;
parameter INIT_RAM_12 = 256'h0;
parameter INIT_RAM_13 = 256'h0;
parameter INIT_RAM_14 = 256'h0;
parameter INIT_RAM_15 = 256'h0;
parameter INIT_RAM_16 = 256'h0;
parameter INIT_RAM_17 = 256'h0;
parameter INIT_RAM_18 = 256'h0;
parameter INIT_RAM_19 = 256'h0;
parameter INIT_RAM_1A = 256'h0;
parameter INIT_RAM_1B = 256'h0;
parameter INIT_RAM_1C = 256'h0;
parameter INIT_RAM_1D = 256'h0;
parameter INIT_RAM_1E = 256'h0;
parameter INIT_RAM_1F = 256'h0;
parameter INIT_RAM_20 = 256'h0;
parameter INIT_RAM_21 = 256'h0;
parameter INIT_RAM_22 = 256'h0;
parameter INIT_RAM_23 = 256'h0;
parameter INIT_RAM_24 = 256'h0;
parameter INIT_RAM_25 = 256'h0;
parameter INIT_RAM_26 = 256'h0;
parameter INIT_RAM_27 = 256'h0;
parameter INIT_RAM_28 = 256'h0;
parameter INIT_RAM_29 = 256'h0;
parameter INIT_RAM_2A = 256'h0;
parameter INIT_RAM_2B = 256'h0;
parameter INIT_RAM_2C = 256'h0;
parameter INIT_RAM_2D = 256'h0;
parameter INIT_RAM_2E = 256'h0;
parameter INIT_RAM_2F = 256'h0;
parameter INIT_RAM_30 = 256'h0;
parameter INIT_RAM_31 = 256'h0;
parameter INIT_RAM_32 = 256'h0;
parameter INIT_RAM_33 = 256'h0;
parameter INIT_RAM_34 = 256'h0;
parameter INIT_RAM_35 = 256'h0;
parameter INIT_RAM_36 = 256'h0;
parameter INIT_RAM_37 = 256'h0;
parameter INIT_RAM_38 = 256'h0;
parameter INIT_RAM_39 = 256'h0;
parameter INIT_RAM_3A = 256'h0;
parameter INIT_RAM_3B = 256'h0;
parameter INIT_RAM_3C = 256'h0;
parameter INIT_RAM_3D = 256'h0;
parameter INIT_RAM_3E = 256'h0;
parameter INIT_RAM_3F = 256'h0;

output [15:0] DOA, DOB;
input [15:0] DIA, DIB;
input [2:0] BLKSEL;
input [13:0] ADA, ADB;
input WREA, WREB;
input CLKA, CLKB;
input CEA, CEB;
input OCEA, OCEB;
input RESETA, RESETB;

endmodule

(* blackbox *)
module DPX9 (DOA, DOB, DIA, DIB, BLKSEL, ADA, ADB, WREA, WREB, CLKA, CLKB, CEA, CEB, OCEA, OCEB, RESETA, RESETB);

parameter READ_MODE0 = 1'b0;
parameter READ_MODE1 = 1'b0;
parameter WRITE_MODE0 = 2'b00;
parameter WRITE_MODE1 = 2'b00;
parameter BIT_WIDTH_0 = 18; // 9, 18
parameter BIT_WIDTH_1 = 18; // 9, 18
parameter BLK_SEL = 3'b000;
parameter RESET_MODE = "SYNC";
parameter INIT_RAM_00 = 288'h0;
parameter INIT_RAM_01 = 288'h0;
parameter INIT_RAM_02 = 288'h0;
parameter INIT_RAM_03 = 288'h0;
parameter INIT_RAM_04 = 288'h0;
parameter INIT_RAM_05 = 288'h0;
parameter INIT_RAM_06 = 288'h0;
parameter INIT_RAM_07 = 288'h0;
parameter INIT_RAM_08 = 288'h0;
parameter INIT_RAM_09 = 288'h0;
parameter INIT_RAM_0A = 288'h0;
parameter INIT_RAM_0B = 288'h0;
parameter INIT_RAM_0C = 288'h0;
parameter INIT_RAM_0D = 288'h0;
parameter INIT_RAM_0E = 288'h0;
parameter INIT_RAM_0F = 288'h0;
parameter INIT_RAM_10 = 288'h0;
parameter INIT_RAM_11 = 288'h0;
parameter INIT_RAM_12 = 288'h0;
parameter INIT_RAM_13 = 288'h0;
parameter INIT_RAM_14 = 288'h0;
parameter INIT_RAM_15 = 288'h0;
parameter INIT_RAM_16 = 288'h0;
parameter INIT_RAM_17 = 288'h0;
parameter INIT_RAM_18 = 288'h0;
parameter INIT_RAM_19 = 288'h0;
parameter INIT_RAM_1A = 288'h0;
parameter INIT_RAM_1B = 288'h0;
parameter INIT_RAM_1C = 288'h0;
parameter INIT_RAM_1D = 288'h0;
parameter INIT_RAM_1E = 288'h0;
parameter INIT_RAM_1F = 288'h0;
parameter INIT_RAM_20 = 288'h0;
parameter INIT_RAM_21 = 288'h0;
parameter INIT_RAM_22 = 288'h0;
parameter INIT_RAM_23 = 288'h0;
parameter INIT_RAM_24 = 288'h0;
parameter INIT_RAM_25 = 288'h0;
parameter INIT_RAM_26 = 288'h0;
parameter INIT_RAM_27 = 288'h0;
parameter INIT_RAM_28 = 288'h0;
parameter INIT_RAM_29 = 288'h0;
parameter INIT_RAM_2A = 288'h0;
parameter INIT_RAM_2B = 288'h0;
parameter INIT_RAM_2C = 288'h0;
parameter INIT_RAM_2D = 288'h0;
parameter INIT_RAM_2E = 288'h0;
parameter INIT_RAM_2F = 288'h0;
parameter INIT_RAM_30 = 288'h0;
parameter INIT_RAM_31 = 288'h0;
parameter INIT_RAM_32 = 288'h0;
parameter INIT_RAM_33 = 288'h0;
parameter INIT_RAM_34 = 288'h0;
parameter INIT_RAM_35 = 288'h0;
parameter INIT_RAM_36 = 288'h0;
parameter INIT_RAM_37 = 288'h0;
parameter INIT_RAM_38 = 288'h0;
parameter INIT_RAM_39 = 288'h0;
parameter INIT_RAM_3A = 288'h0;
parameter INIT_RAM_3B = 288'h0;
parameter INIT_RAM_3C = 288'h0;
parameter INIT_RAM_3D = 288'h0;
parameter INIT_RAM_3E = 288'h0;
parameter INIT_RAM_3F = 288'h0;

output [17:0] DOA, DOB;
input [17:0] DIA, DIB;
input [2:0] BLKSEL;
input [13:0] ADA, ADB;
input WREA, WREB;
input CLKA, CLKB;
input CEA, CEB;
input OCEA, OCEB;
input RESETA, RESETB;

endmodule


(* blackbox *)
module rPLL (CLKOUT, CLKOUTP, CLKOUTD, CLKOUTD3, LOCK, CLKIN, CLKFB, FBDSEL, IDSEL, ODSEL, DUTYDA, PSDA, FDLY, RESET, RESET_P);
input CLKIN;
input CLKFB;
input RESET;
input RESET_P;
input [5:0] FBDSEL;
input [5:0] IDSEL;
input [5:0] ODSEL;
input [3:0] PSDA,FDLY;
input [3:0] DUTYDA;

output CLKOUT;
output LOCK;
output CLKOUTP;
output CLKOUTD;
output CLKOUTD3;

parameter FCLKIN = "100.0";         // frequency of CLKIN
parameter DYN_IDIV_SEL= "false";    // true:IDSEL, false:IDIV_SEL
parameter IDIV_SEL = 0;             // 0:1, 1:2 ... 63:64
parameter DYN_FBDIV_SEL= "false";   // true:FBDSEL, false:FBDIV_SEL
parameter FBDIV_SEL = 0;            // 0:1, 1:2 ... 63:64
parameter DYN_ODIV_SEL= "false";    // true:ODSEL, false:ODIV_SEL
parameter ODIV_SEL = 8;             // 2/4/8/16/32/48/64/80/96/112/128

parameter PSDA_SEL= "0000";
parameter DYN_DA_EN = "false";      // true:PSDA or DUTYDA or FDA, false: DA_SEL
parameter DUTYDA_SEL= "1000";

parameter CLKOUT_FT_DIR = 1'b1;     // CLKOUT fine tuning direction. 1'b1 only
parameter CLKOUTP_FT_DIR = 1'b1;    // 1'b1 only
parameter CLKOUT_DLY_STEP = 0;      // 0, 1, 2, 4
parameter CLKOUTP_DLY_STEP = 0;     // 0, 1, 2

parameter CLKFB_SEL = "internal";   // "internal", "external"
parameter CLKOUT_BYPASS = "false";  // "true", "false"
parameter CLKOUTP_BYPASS = "false"; // "true", "false"
parameter CLKOUTD_BYPASS = "false"; // "true", "false"
parameter DYN_SDIV_SEL = 2;         // 2~128, only even numbers
parameter CLKOUTD_SRC =  "CLKOUT";  // CLKOUT, CLKOUTP
parameter CLKOUTD3_SRC = "CLKOUT";  // CLKOUT, CLKOUTP
parameter DEVICE = "GW1N-1";        // "GW1N-1", "GW1N-4", "GW1N-9", "GW1NR-4", "GW1NR-9", "GW1N-4B", "GW1NR-4B", "GW1NS-2", "GW1NS-2C", "GW1NZ-1", "GW1NSR-2", "GW1NSR-2C", "GW1N-1S", "GW1NSE-2C", "GW1NRF-4B", "GW1N-9C", "GW1NR-9C", "GW1N-4C", "GW1NR-4C"

endmodule

(* blackbox *)
module PLLVR (CLKOUT, CLKOUTP, CLKOUTD, CLKOUTD3, LOCK, CLKIN, CLKFB, FBDSEL, IDSEL, ODSEL, DUTYDA, PSDA, FDLY, RESET, RESET_P, VREN);
input CLKIN;
input CLKFB;
input RESET;
input RESET_P;
input [5:0] FBDSEL;
input [5:0] IDSEL;
input [5:0] ODSEL;
input [3:0] PSDA,FDLY;
input [3:0] DUTYDA;
input VREN;

output CLKOUT;
output LOCK;
output CLKOUTP;
output CLKOUTD;
output CLKOUTD3;

parameter FCLKIN = "100.0";         // frequency of CLKIN
parameter DYN_IDIV_SEL= "false";    // true:IDSEL, false:IDIV_SEL
parameter IDIV_SEL = 0;             // 0:1, 1:2 ... 63:64
parameter DYN_FBDIV_SEL= "false";   // true:FBDSEL, false:FBDIV_SEL
parameter FBDIV_SEL = 0;            // 0:1, 1:2 ... 63:64
parameter DYN_ODIV_SEL= "false";    // true:ODSEL, false:ODIV_SEL
parameter ODIV_SEL = 8;             // 2/4/8/16/32/48/64/80/96/112/128

parameter PSDA_SEL= "0000";
parameter DYN_DA_EN = "false";      // true:PSDA or DUTYDA or FDA, false: DA_SEL
parameter DUTYDA_SEL= "1000";

parameter CLKOUT_FT_DIR = 1'b1;     // CLKOUT fine tuning direction. 1'b1 only
parameter CLKOUTP_FT_DIR = 1'b1;    // 1'b1 only
parameter CLKOUT_DLY_STEP = 0;      // 0, 1, 2, 4
parameter CLKOUTP_DLY_STEP = 0;     // 0, 1, 2

parameter CLKFB_SEL = "internal";   // "internal", "external"
parameter CLKOUT_BYPASS = "false";  // "true", "false"
parameter CLKOUTP_BYPASS = "false"; // "true", "false"
parameter CLKOUTD_BYPASS = "false"; // "true", "false"
parameter DYN_SDIV_SEL = 2;         // 2~128, only even numbers
parameter CLKOUTD_SRC =  "CLKOUT";  // CLKOUT, CLKOUTP
parameter CLKOUTD3_SRC = "CLKOUT";  // CLKOUT, CLKOUTP
parameter DEVICE = "GW1NS-4";       // "GW1NS-4", "GW1NS-4C", "GW1NSR-4", "GW1NSR-4C", "GW1NSER-4C"

endmodule

(* blackbox *)
module OSC(OSCOUT);
output OSCOUT;

parameter FREQ_DIV = 100;
parameter DEVICE = "GW1N-4";
endmodule

(* blackbox *)
module OSCZ(OSCOUT, OSCEN);
input OSCEN;

output OSCOUT;

parameter FREQ_DIV = 100;
endmodule

(* blackbox *)
module OSCF(OSCOUT, OSCOUT30M, OSCEN);
input OSCEN;

output OSCOUT;
output OSCOUT30M;

parameter FREQ_DIV = 100;
endmodule

(* blackbox *)
module OSCH(OSCOUT);
output OSCOUT;

parameter FREQ_DIV = 96;
endmodule

(* blackbox *)
module OSCW(OSCOUT);
output OSCOUT;

parameter FREQ_DIV = 80;
endmodule

(* blackbox *)
module OSCO(OSCOUT, OSCEN);
input OSCEN;

output OSCOUT;

parameter FREQ_DIV = 100;
parameter REGULATOR_EN = 1'b0;
endmodule
`,"cells_xtra.v":`// Created by cells_xtra.py


module MUX2_MUX8 (...);
input I0,I1;
input S0;
output O;
endmodule


module MUX2_MUX16 (...);
input I0,I1;
input S0;
output O;
endmodule


module MUX2_MUX32 (...);
input I0,I1;
input S0;
output O;
endmodule


module MUX4 (...);
input I0, I1, I2, I3;
input S0, S1;
output O;
endmodule


module MUX8 (...);
input I0, I1, I2, I3, I4, I5, I6, I7;
input S0, S1, S2;
output O;
endmodule


module MUX16 (...);
input I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, I11, I12, I13, I14, I15;
input S0, S1, S2, S3;
output O;
endmodule

module MUX32 (...);
input I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, I11, I12, I13, I14, I15, I16, I17, I18, I19, I20, I21, I22, I23, I24, I25, I26, I27, I28, I29, I30, I31;
input S0, S1, S2, S3, S4;
output O;
endmodule

module LUT5 (...);
parameter INIT = 32'h00000000;
input I0, I1, I2, I3, I4;
output F;
endmodule


module LUT6 (...);
parameter INIT = 64'h0000_0000_0000_0000;
input I0, I1, I2, I3, I4, I5;
output F;
endmodule


module LUT7 (...);
parameter INIT = 128'h0000_0000_0000_0000_0000_0000_0000_0000;
input I0, I1, I2, I3, I4, I5, I6;
output F;
endmodule


module LUT8 (...);
parameter INIT = 256'h0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000;
input I0, I1, I2, I3, I4, I5, I6, I7;
output F;
endmodule


module DL (...);
input D, G;
output Q;
parameter INIT = 1'b0;
endmodule


module DLE (...);
input D, G, CE;
output Q;
parameter INIT = 1'b0;
endmodule


module DLC (...);
input D, G, CLEAR;
output Q;
parameter INIT = 1'b0;
endmodule


module DLCE (...);
input D, G, CLEAR, CE;
output Q;
parameter INIT = 1'b0;
endmodule


module DLP (...);
input D, G, PRESET;
output Q;
parameter INIT = 1'b1;
endmodule


module DLPE (...);
input D, G, PRESET, CE;
output Q;
parameter INIT = 1'b1;
endmodule


module DLN (...);
input D, G;
output Q;
parameter INIT = 1'b0;
endmodule


module DLNE (...);
input D, G, CE;
output Q;
parameter INIT = 1'b0;
endmodule


module DLNC (...);
input D, G, CLEAR;
output Q;
parameter INIT = 1'b0;
endmodule


module DLNCE (...);
input D, G, CLEAR, CE;
output Q;
parameter INIT = 1'b0;
endmodule


module DLNP (...);
input D, G, PRESET;
output Q;
parameter INIT = 1'b1;
endmodule


module DLNPE (...);
input D, G, PRESET, CE;
output Q;
parameter INIT = 1'b1;
endmodule


module INV (...);
input  I;
output O;
endmodule


module IODELAY (...);
parameter C_STATIC_DLY = 0; 
input DI;
input  SDTAP;
input  SETN;
input  VALUE;
output DF;
output DO;
endmodule


module IEM (...);
parameter WINSIZE = "SMALL"; 
parameter GSREN = "false"; 
parameter LSREN = "true";    
input D, CLK, RESET, MCLK;
output LAG, LEAD;
endmodule


module ROM16 (...);
parameter INIT_0 = 16'h0000;
input [3:0] AD;
output DO;
endmodule


module ROM (...);
parameter READ_MODE = 1'b0; 
parameter BIT_WIDTH = 32; 
parameter BLK_SEL = 3'b000;
parameter RESET_MODE = "SYNC"; 
parameter INIT_RAM_00 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_01 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_02 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_03 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_04 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_05 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_06 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_07 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_08 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_09 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_10 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_11 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_12 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_13 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_14 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_15 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_16 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_17 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_18 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_19 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_20 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_21 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_22 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_23 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_24 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_25 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_26 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_27 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_28 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_29 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_30 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_31 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_32 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_33 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_34 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_35 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_36 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_37 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_38 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_39 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
input CLK, CE;
input OCE; 
input RESET; 
input WRE; 
input [13:0] AD;
input [2:0] BLKSEL;
output [31:0] DO;
endmodule


module ROMX9 (...);
parameter READ_MODE = 1'b0; 
parameter BIT_WIDTH = 36; 
parameter BLK_SEL = 3'b000;
parameter RESET_MODE = "SYNC"; 
parameter INIT_RAM_00 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000; 
parameter INIT_RAM_01 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_02 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_03 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_04 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_05 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_06 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_07 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_08 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_09 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_10 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_11 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_12 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_13 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_14 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_15 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_16 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_17 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_18 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_19 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_20 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_21 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_22 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_23 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_24 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_25 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_26 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_27 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_28 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_29 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_30 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_31 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_32 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_33 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_34 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_35 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_36 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_37 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_38 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_39 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
input CLK, CE;
input OCE; 
input RESET; 
input WRE; 
input [13:0] AD;
input [2:0] BLKSEL;
output [35:0] DO;
endmodule


module rSDP (...);
parameter READ_MODE = 1'b0; 
parameter BIT_WIDTH_0 = 32; 
parameter BIT_WIDTH_1 = 32; 
parameter BLK_SEL = 3'b000;
parameter RESET_MODE = "SYNC"; 
parameter INIT_RAM_00 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_01 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_02 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_03 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_04 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_05 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_06 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_07 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_08 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_09 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_10 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_11 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_12 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_13 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_14 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_15 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_16 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_17 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_18 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_19 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_20 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_21 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_22 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_23 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_24 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_25 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_26 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_27 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_28 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_29 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_30 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_31 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_32 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_33 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_34 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_35 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_36 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_37 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_38 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_39 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
input CLKA, CEA, CLKB, CEB;
input OCE; 
input RESETA, RESETB; 
input [13:0] ADA, ADB;
input [31:0] DI;
input [2:0] BLKSEL;
output [31:0] DO;
endmodule


module rSDPX9 (...);
parameter READ_MODE = 1'b0; 
parameter BIT_WIDTH_0 = 36; 
parameter BIT_WIDTH_1 = 36; 
parameter BLK_SEL = 3'b000;
parameter RESET_MODE = "SYNC"; 
parameter INIT_RAM_00 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000; 
parameter INIT_RAM_01 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_02 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_03 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_04 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_05 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_06 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_07 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_08 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_09 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_10 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_11 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_12 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_13 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_14 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_15 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_16 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_17 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_18 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_19 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_20 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_21 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_22 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_23 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_24 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_25 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_26 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_27 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_28 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_29 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_30 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_31 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_32 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_33 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_34 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_35 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_36 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_37 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_38 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_39 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
input CLKA, CEA, CLKB, CEB;
input OCE; 
input RESETA, RESETB; 
input [13:0] ADA, ADB;
input [2:0] BLKSEL;
input [35:0] DI;
output [35:0] DO;
endmodule


module rROM (...);
parameter READ_MODE = 1'b0; 
parameter BIT_WIDTH = 32; 
parameter BLK_SEL = 3'b000;
parameter RESET_MODE = "SYNC"; 
parameter INIT_RAM_00 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_01 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_02 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_03 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_04 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_05 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_06 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_07 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_08 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_09 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_10 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_11 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_12 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_13 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_14 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_15 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_16 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_17 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_18 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_19 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_20 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_21 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_22 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_23 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_24 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_25 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_26 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_27 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_28 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_29 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_30 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_31 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_32 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_33 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_34 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_35 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_36 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_37 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_38 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_39 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
input CLK, CE;
input OCE; 
input RESET; 
input [13:0] AD;
input [2:0] BLKSEL;
output [31:0] DO;
endmodule


module rROMX9 (...);
parameter READ_MODE = 1'b0; 
parameter BIT_WIDTH = 36; 
parameter BLK_SEL = 3'b000;
parameter RESET_MODE = "SYNC"; 
parameter INIT_RAM_00 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000; 
parameter INIT_RAM_01 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_02 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_03 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_04 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_05 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_06 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_07 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_08 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_09 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_10 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_11 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_12 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_13 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_14 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_15 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_16 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_17 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_18 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_19 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_20 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_21 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_22 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_23 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_24 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_25 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_26 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_27 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_28 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_29 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_30 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_31 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_32 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_33 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_34 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_35 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_36 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_37 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_38 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_39 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
input CLK, CE;
input OCE; 
input RESET; 
input [13:0] AD;
input [2:0] BLKSEL;
output [35:0] DO;
endmodule


module pROM (...);
parameter READ_MODE = 1'b0; 
parameter BIT_WIDTH = 32; 
parameter RESET_MODE = "SYNC"; 
parameter INIT_RAM_00 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_01 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_02 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_03 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_04 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_05 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_06 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_07 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_08 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_09 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_10 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_11 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_12 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_13 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_14 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_15 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_16 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_17 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_18 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_19 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_20 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_21 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_22 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_23 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_24 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_25 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_26 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_27 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_28 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_29 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_30 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_31 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_32 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_33 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_34 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_35 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_36 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_37 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_38 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_39 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
input CLK, CE;
input OCE; 
input RESET; 
input [13:0] AD;
output [31:0] DO;
endmodule


module pROMX9 (...);
parameter READ_MODE = 1'b0; 
parameter BIT_WIDTH = 36; 
parameter RESET_MODE = "SYNC"; 
parameter INIT_RAM_00 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000; 
parameter INIT_RAM_01 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_02 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_03 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_04 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_05 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_06 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_07 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_08 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_09 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_10 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_11 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_12 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_13 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_14 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_15 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_16 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_17 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_18 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_19 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_20 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_21 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_22 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_23 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_24 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_25 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_26 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_27 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_28 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_29 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_30 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_31 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_32 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_33 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_34 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_35 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_36 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_37 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_38 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_39 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
input CLK, CE;
input OCE; 
input RESET; 
input [13:0] AD;
output [35:0] DO;
endmodule


module SDPB (...);
parameter READ_MODE = 1'b0; 
parameter BIT_WIDTH_0 = 32; 
parameter BIT_WIDTH_1 = 32; 
parameter BLK_SEL_0 = 3'b000;
parameter BLK_SEL_1 = 3'b000;
parameter RESET_MODE = "SYNC"; 
parameter INIT_RAM_00 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_01 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_02 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_03 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_04 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_05 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_06 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_07 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_08 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_09 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_10 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_11 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_12 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_13 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_14 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_15 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_16 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_17 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_18 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_19 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_20 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_21 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_22 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_23 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_24 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_25 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_26 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_27 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_28 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_29 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_30 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_31 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_32 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_33 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_34 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_35 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_36 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_37 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_38 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_39 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
input CLKA, CEA, CLKB, CEB;
input OCE; 
input RESETA, RESETB; 
input [13:0] ADA, ADB;
input [31:0] DI;
input [2:0] BLKSELA, BLKSELB;
output [31:0] DO;
endmodule


module SDPX9B (...);
parameter READ_MODE = 1'b0; 
parameter BIT_WIDTH_0 = 36; 
parameter BIT_WIDTH_1 = 36; 
parameter BLK_SEL_0 = 3'b000;
parameter BLK_SEL_1 = 3'b000;
parameter RESET_MODE = "SYNC"; 
parameter INIT_RAM_00 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000; 
parameter INIT_RAM_01 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_02 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_03 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_04 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_05 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_06 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_07 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_08 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_09 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_10 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_11 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_12 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_13 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_14 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_15 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_16 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_17 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_18 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_19 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_20 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_21 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_22 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_23 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_24 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_25 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_26 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_27 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_28 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_29 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_30 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_31 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_32 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_33 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_34 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_35 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_36 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_37 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_38 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_39 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
input CLKA, CEA, CLKB, CEB;
input OCE; 
input RESETA, RESETB; 
input [13:0] ADA, ADB;
input [2:0] BLKSELA, BLKSELB;
input [35:0] DI;
output [35:0] DO;
endmodule


module DPB (...);
parameter READ_MODE0 = 1'b0; 
parameter READ_MODE1 = 1'b0; 
parameter WRITE_MODE0 = 2'b00; 
parameter WRITE_MODE1 = 2'b00; 
parameter BIT_WIDTH_0 = 16; 
parameter BIT_WIDTH_1 = 16; 
parameter BLK_SEL_0 = 3'b000;
parameter BLK_SEL_1 = 3'b000;
parameter RESET_MODE = "SYNC"; 
parameter INIT_RAM_00 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_01 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_02 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_03 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_04 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_05 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_06 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_07 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_08 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_09 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_10 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_11 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_12 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_13 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_14 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_15 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_16 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_17 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_18 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_19 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_20 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_21 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_22 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_23 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_24 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_25 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_26 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_27 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_28 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_29 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_30 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_31 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_32 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_33 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_34 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_35 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_36 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_37 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_38 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_39 = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3A = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3B = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3C = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3D = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3E = 256'h0000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3F = 256'h0000000000000000000000000000000000000000000000000000000000000000;
input CLKA, CEA, CLKB, CEB;
input OCEA, OCEB; 
input RESETA, RESETB; 
input WREA, WREB; 
input [13:0] ADA, ADB;
input [2:0] BLKSELA, BLKSELB;
input [15:0] DIA, DIB;
output [15:0] DOA, DOB;
endmodule


module DPX9B (...);
parameter READ_MODE0 = 1'b0; 
parameter READ_MODE1 = 1'b0; 
parameter WRITE_MODE0 = 2'b00; 
parameter WRITE_MODE1 = 2'b00; 
parameter BIT_WIDTH_0 = 18; 
parameter BIT_WIDTH_1 = 18; 
parameter BLK_SEL_0 = 3'b000;
parameter BLK_SEL_1 = 3'b000;
parameter RESET_MODE = "SYNC"; 
parameter INIT_RAM_00 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000; 
parameter INIT_RAM_01 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_02 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_03 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_04 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_05 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_06 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_07 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_08 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_09 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_0F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_10 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_11 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_12 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_13 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_14 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_15 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_16 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_17 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_18 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_19 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_1F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_20 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_21 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_22 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_23 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_24 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_25 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_26 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_27 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_28 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_29 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_2F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_30 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_31 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_32 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_33 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_34 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_35 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_36 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_37 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_38 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_39 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
parameter INIT_RAM_3F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;
input CLKA, CEA, CLKB, CEB;
input OCEA, OCEB; 
input RESETA, RESETB; 
input WREA, WREB; 
input [13:0] ADA, ADB;
input [17:0] DIA, DIB;
input [2:0] BLKSELA, BLKSELB;
output [17:0] DOA, DOB;
endmodule


module PADD18 (...);
input  [17:0] A;
input  [17:0] B;
input  ASEL;
input  CE,CLK,RESET;
input  [17:0] SI,SBI;
output [17:0] SO,SBO;
output [17:0] DOUT;
parameter AREG = 1'b0; 
parameter BREG = 1'b0;
parameter ADD_SUB = 1'b0; 
parameter PADD_RESET_MODE = "SYNC"; 
parameter BSEL_MODE = 1'b1; 
parameter SOREG = 1'b0;
endmodule

module PADD9 (...);
input  [8:0] A;
input  [8:0] B;
input  ASEL;
input  CE,CLK,RESET;
input  [8:0] SI,SBI;
output [8:0] SO,SBO;
output [8:0] DOUT;
parameter AREG = 1'b0; 
parameter BREG = 1'b0; 
parameter ADD_SUB = 1'b0; 
parameter PADD_RESET_MODE = "SYNC"; 
parameter BSEL_MODE = 1'b1; 
parameter SOREG = 1'b0;
endmodule

module MULT9X9 (...);
input  [8:0] A,SIA;
input  [8:0] B,SIB;
input  ASIGN,BSIGN;
input  ASEL,BSEL;
input  CE;
input  CLK;
input  RESET;
output [17:0] DOUT;
output [8:0] SOA,SOB;
parameter AREG = 1'b0;
parameter BREG = 1'b0;
parameter OUT_REG = 1'b0;
parameter PIPE_REG = 1'b0;
parameter ASIGN_REG = 1'b0;
parameter BSIGN_REG = 1'b0;
parameter SOA_REG = 1'b0; 
parameter MULT_RESET_MODE = "SYNC"; 
endmodule

module MULT18X18 (...);
input  [17:0] A,SIA;
input  [17:0] B,SIB;
input  ASIGN,BSIGN;
input  ASEL,BSEL;
input  CE;
input  CLK;
input  RESET;
output [35:0] DOUT;
output [17:0] SOA,SOB;
parameter AREG = 1'b0;
parameter BREG = 1'b0;
parameter OUT_REG = 1'b0;
parameter PIPE_REG = 1'b0;
parameter ASIGN_REG = 1'b0;
parameter BSIGN_REG = 1'b0;
parameter SOA_REG = 1'b0;
parameter MULT_RESET_MODE = "SYNC"; 
endmodule

module MULT36X36 (...);
input  [35:0] A;
input  [35:0] B;
input  ASIGN,BSIGN;
input  CE;
input  CLK;
input  RESET;
output [71:0] DOUT;
parameter AREG = 1'b0;
parameter BREG = 1'b0;
parameter OUT0_REG = 1'b0;
parameter OUT1_REG = 1'b0;
parameter PIPE_REG = 1'b0;
parameter ASIGN_REG = 1'b0;
parameter BSIGN_REG = 1'b0;
parameter MULT_RESET_MODE = "SYNC"; 
endmodule

module MULTALU36X18 (...);
input  [17:0] A;
input  [35:0] B;
input  [53:0] C;
input  ASIGN,BSIGN,ACCLOAD;
input  CE;
input  CLK;
input  RESET;
input  [54:0] CASI;
output [53:0] DOUT;
output [54:0] CASO;
parameter AREG = 1'b0;
parameter BREG = 1'b0;
parameter CREG = 1'b0;
parameter OUT_REG = 1'b0;
parameter PIPE_REG = 1'b0;
parameter ASIGN_REG = 1'b0;
parameter BSIGN_REG = 1'b0;
parameter ACCLOAD_REG0 = 1'b0;
parameter ACCLOAD_REG1 = 1'b0;
parameter MULT_RESET_MODE = "SYNC"; 
parameter MULTALU36X18_MODE = 0; 
parameter C_ADD_SUB = 1'b0; 
endmodule

module MULTADDALU18X18 (...);
input [17:0] A0;
input [17:0] B0;
input [17:0] A1;
input [17:0] B1;
input [53:0] C;
input [17:0] SIA, SIB;
input [1:0] ASIGN, BSIGN;
input [1:0] ASEL, BSEL;
input [54:0] CASI;
input CE;
input CLK;
input RESET;
input ACCLOAD;
output [53:0] DOUT;
output [54:0] CASO;
output [17:0] SOA, SOB;
parameter A0REG = 1'b0; 
parameter A1REG = 1'b0;
parameter B0REG = 1'b0;
parameter B1REG = 1'b0;
parameter CREG = 1'b0;
parameter PIPE0_REG = 1'b0;
parameter PIPE1_REG = 1'b0;
parameter OUT_REG = 1'b0;
parameter ASIGN0_REG = 1'b0;
parameter ASIGN1_REG = 1'b0;
parameter ACCLOAD_REG0 = 1'b0;
parameter ACCLOAD_REG1 = 1'b0;
parameter BSIGN0_REG = 1'b0;
parameter BSIGN1_REG = 1'b0;
parameter SOA_REG = 1'b0;
parameter B_ADD_SUB = 1'b0; 
parameter C_ADD_SUB = 1'b0;
parameter MULTADDALU18X18_MODE = 0;
parameter MULT_RESET_MODE = "SYNC";
endmodule

module MULTALU18X18 (...);
input [17:0] A, B;
input CLK,CE,RESET;
input ASIGN, BSIGN;
input ACCLOAD,DSIGN;
input [53:0] C,D;
input [54:0] CASI;
output [53:0] DOUT;
output [54:0] CASO;
parameter AREG = 1'b0;
parameter BREG = 1'b0;
parameter CREG = 1'b0;
parameter DREG = 1'b0;
parameter DSIGN_REG = 1'b0;
parameter ASIGN_REG = 1'b0;
parameter BSIGN_REG = 1'b0;
parameter ACCLOAD_REG0 = 1'b0;
parameter ACCLOAD_REG1 = 1'b0;
parameter MULT_RESET_MODE = "SYNC"; 
parameter PIPE_REG = 1'b0;
parameter OUT_REG = 1'b0;
parameter B_ADD_SUB = 1'b0; 
parameter C_ADD_SUB = 1'b0;
parameter MULTALU18X18_MODE = 0; 
endmodule

module ALU54D (...);
input [53:0] A, B;
input ASIGN,BSIGN;
input ACCLOAD;
input [54:0] CASI;
input CLK, CE, RESET;
output [53:0] DOUT;
output [54:0] CASO;
parameter AREG = 1'b0; 
parameter BREG = 1'b0;
parameter ASIGN_REG = 1'b0;
parameter BSIGN_REG = 1'b0;
parameter ACCLOAD_REG = 1'b0;
parameter OUT_REG = 1'b0;
parameter B_ADD_SUB = 1'b0; 
parameter C_ADD_SUB = 1'b0;
parameter ALUD_MODE = 0;
parameter ALU_RESET_MODE = "SYNC";
endmodule

module BUFG (...);
output O;
input I;
endmodule


module BUFS (...);
output O;
input I;
endmodule


module PLL (...);
input CLKIN;
input CLKFB;
input RESET; 
input RESET_P; 
input RESET_I;
input RESET_S;
input [5:0] FBDSEL; 
input [5:0] IDSEL;
input [5:0] ODSEL;
input [3:0] PSDA,FDLY; 
input [3:0] DUTYDA;
output CLKOUT;
output LOCK;
output CLKOUTP;
output CLKOUTD;
output CLKOUTD3;
parameter FCLKIN = "100.0"; 
parameter DYN_IDIV_SEL= "false";
parameter IDIV_SEL = 0; 
parameter DYN_FBDIV_SEL= "false";
parameter FBDIV_SEL = 0; 
parameter DYN_ODIV_SEL= "false";
parameter ODIV_SEL = 8; 
parameter PSDA_SEL= "0000";
parameter DYN_DA_EN = "false";
parameter DUTYDA_SEL= "1000";
parameter CLKOUT_FT_DIR = 1'b1; 
parameter CLKOUTP_FT_DIR = 1'b1; 
parameter CLKOUT_DLY_STEP = 0; 
parameter CLKOUTP_DLY_STEP = 0; 
parameter CLKFB_SEL = "internal"; 
parameter CLKOUT_BYPASS = "false";  
parameter CLKOUTP_BYPASS = "false";   
parameter CLKOUTD_BYPASS = "false";  
parameter DYN_SDIV_SEL = 2; 
parameter CLKOUTD_SRC =  "CLKOUT";  
parameter CLKOUTD3_SRC = "CLKOUT"; 
parameter DEVICE = "GW1N-4";
endmodule

module TLVDS_IBUF (...);
output O;
input  I, IB;
endmodule

module TLVDS_TBUF (...);
output O, OB;
input  I, OEN;
endmodule

module TLVDS_IOBUF (...);
output   O;
inout IO, IOB;
input I, OEN;
endmodule

module ELVDS_IBUF (...);
output O;
input  I, IB;
endmodule

module ELVDS_TBUF (...);
output O, OB;
input  I, OEN;
endmodule

module ELVDS_IOBUF (...);
output   O;
inout IO, IOB;
input I, OEN;
endmodule

module MIPI_IBUF (...);
output OH, OL, OB;
inout IO, IOB;
input  I, IB;
input OEN, OENB;
input HSREN;
endmodule

module MIPI_IBUF_HS (...);
output OH;
input  I, IB;
endmodule

module MIPI_IBUF_LP (...);
output OL;
output OB;
input  I;
input IB;
endmodule

module MIPI_OBUF (...);
output O, OB;
input  I, IB, MODESEL;
endmodule

module MIPI_OBUF_A (...);
output O, OB;
input  I, IB, IL, MODESEL;
endmodule

module I3C_IOBUF (...);
output O;
inout IO;
input  I, MODESEL;
endmodule

module CLKDIV (...);
input HCLKIN;
input RESETN;
input CALIB;
output CLKOUT;
parameter DIV_MODE = "2"; 
parameter GSREN = "false"; 
endmodule

module DHCEN (...);
input CLKIN,CE;
output CLKOUT;
endmodule

module DLL (...);
input CLKIN;
input STOP;
input UPDNCNTL;
input RESET;
output [7:0]STEP;
output LOCK;
parameter DLL_FORCE = 0;
parameter CODESCAL="000";
parameter SCAL_EN="true";
parameter DIV_SEL = 1'b0; 
endmodule

module DLLDLY (...);
input CLKIN;
input [7:0] DLLSTEP;
input DIR,LOADN,MOVE;
output CLKOUT;
output FLAG;
parameter DLL_INSEL = 1'b1; 
parameter DLY_SIGN = 1'b0; 
parameter DLY_ADJ = 0; 
endmodule

module FLASH96K (...);
input [5:0] RA,CA,PA;
input [3:0] MODE;
input [1:0] SEQ;
input ACLK,PW,RESET,PE,OE;
input [1:0] RMODE,WMODE;
input [1:0] RBYTESEL,WBYTESEL;
input [31:0] DIN;
output [31:0] DOUT;
endmodule

module FLASH256K (...);
input[6:0]XADR;
input[5:0]YADR;
input XE,YE,SE;
input ERASE,PROG,NVSTR;
input [31:0] DIN;
output reg [31:0] DOUT;
parameter IDLE    =  4'd0,
          ERA_S1  =  4'd1,
		  ERA_S2  =  4'd2,
		  ERA_S3  =  4'd3,
		  ERA_S4  =  4'd4,
		  ERA_S5  =  4'd5,
		  PRO_S1  =  4'd6,
		  PRO_S2  =  4'd7,
		  PRO_S3  =  4'd8,
		  PRO_S4  =  4'd9,
		  PRO_S5  =  4'd10,
		  RD_S1   =  4'd11,
		  RD_S2   =  4'd12;		  
endmodule

module FLASH608K (...);
input[8:0]XADR;
input[5:0]YADR;
input XE,YE,SE;
input ERASE,PROG,NVSTR;
input [31:0] DIN;
output reg [31:0] DOUT;
parameter IDLE    =  4'd0,
          ERA_S1  =  4'd1,
		  ERA_S2  =  4'd2,
		  ERA_S3  =  4'd3,
		  ERA_S4  =  4'd4,
   		  ERA_S5  =  4'd5,
		  PRO_S1  =  4'd6,
		  PRO_S2  =  4'd7,
		  PRO_S3  =  4'd8,
		  PRO_S4  =  4'd9,
		  PRO_S5  =  4'd10,
		  RD_S1   =  4'd11,
		  RD_S2   =  4'd12;
endmodule

module DCS (...);
input CLK0, CLK1, CLK2, CLK3, SELFORCE;
input [3:0] CLKSEL;
output CLKOUT;
endmodule

module DQCE (...);
input CLKIN;
input CE;
output CLKOUT;
endmodule

module FLASH128K (...);
input [31:0] DIN;
input [14:0] ADDR;
input CS,AE,OE;
input PCLK;
input PROG, SERA, MASE;
input NVSTR;
input IFREN;
input RESETN;
output [31:0] DOUT;
output TBIT;
parameter IDLE  = 4'd0,
          READ_S1 = 4'd1,
          READ_S2 = 4'd2,
          PROG_S1 = 4'd3,
          PROG_S2 = 4'd4,
          PROG_S3 = 4'd5,
          PROG_S4 = 4'd6,
          SERA_S1 = 4'd7,
          SERA_S2 = 4'd8,
          SERA_S3 = 4'd9,
          SERA_S4 = 4'd10,
          MASE_S1 = 4'd11,
          MASE_S2 = 4'd12,
          MASE_S3 = 4'd13,
          MASE_S4 = 4'd14;
endmodule

module MCU (...);
endmodule

module USB20_PHY (...);
parameter DATABUS16_8 = 1'b0;
parameter ADP_PRBEN = 1'b0;
parameter TEST_MODE = 5'b00000;
parameter HSDRV1 = 1'b0; 
parameter HSDRV0 = 1'b0; 
parameter CLK_SEL = 1'b0;
parameter M = 4'b0000; 
parameter N = 6'b101000; 
parameter C = 2'b01; 
parameter FOC_LOCK = 1'b0;
input   [15:0]  DATAIN;
input   TXVLD;
input   TXVLDH;
input   RESET;
input   SUSPENDM;
input   [1:0]   XCVRSEL;
input   TERMSEL;
input   [1:0]   OPMODE;
output  [15:0]  DATAOUT;
output  TXREADY;
output  RXACTIVE;
output  RXVLD;
output  RXVLDH;
output  CLK;      
output  RXERROR;
inout   DP;
inout   DM;
output  [1:0]   LINESTATE;
input   IDPULLUP;
input   DPPD;
input   DMPD;
input   CHARGVBUS;
input   DISCHARGVBUS;
input   TXBITSTUFFEN;
input   TXBITSTUFFENH;
input   TXENN;
input   TXDAT;
input   TXSE0;
input   FSLSSERIAL;
output  HOSTDIS;
output  IDDIG;
output  ADPPRB;
output  ADPSNS;
output  SESSVLD;
output  VBUSVLD;
output  RXDP;
output  RXDM;
output  RXRCV;
output  LBKERR;
output  CLKRDY;
input   INTCLK;
inout   ID;
inout   VBUS;
inout   REXT;
input   XIN;
inout   XOUT;
input	TEST;
output	CLK480PAD;
input        SCANCLK; 
input        SCANEN; 
input        SCANMODE; 
input        TRESETN; 
input        SCANIN1; 
output       SCANOUT1; 
input        SCANIN2; 
output       SCANOUT2; 
input        SCANIN3; 
output       SCANOUT3; 
input        SCANIN4; 
output       SCANOUT4; 
input        SCANIN5; 
output       SCANOUT5; 
input        SCANIN6; 
output       SCANOUT6; 
endmodule

module ADC (...);
endmodule

module BANDGAP (...);
input BGEN;
endmodule

module CLKDIV2 (...);
parameter GSREN = "false"; 
input HCLKIN, RESETN;
output CLKOUT;
endmodule

module DCC (...);
output CLKOUT;
input CLKIN;
parameter DCC_EN = 1'b1; 
parameter FCLKIN = 50.0;
endmodule

module DHCENC (...);
input CLKIN, CE;
output CLKOUT, CLKOUTN;
endmodule

module EMCU (...);
endmodule

module FLASH64K (...);
input[4:0]XADR;
input[5:0]YADR;
input XE,YE,SE;
input ERASE,PROG,NVSTR;
input SLEEP;
input [31:0] DIN;
output reg [31:0] DOUT;
parameter IDLE    =  4'd0,
          ERA_S1  =  4'd1,
		  ERA_S2  =  4'd2,
		  ERA_S3  =  4'd3,
		  ERA_S4  =  4'd4,
		  ERA_S5  =  4'd5,
		  PRO_S1  =  4'd6,
		  PRO_S2  =  4'd7,
		  PRO_S3  =  4'd8,
		  PRO_S4  =  4'd9,
		  PRO_S5  =  4'd10,
		  RD_S1   =  4'd11,
		  RD_S2   =  4'd12;		  
endmodule

module FLASH64KZ (...);
input[4:0]XADR;
input[5:0]YADR;
input XE,YE,SE;
input ERASE,PROG,NVSTR;
input [31:0] DIN;
output reg [31:0] DOUT;
parameter IDLE    =  4'd0,
          ERA_S1  =  4'd1,
		  ERA_S2  =  4'd2,
		  ERA_S3  =  4'd3,
		  ERA_S4  =  4'd4,
		  ERA_S5  =  4'd5,
		  PRO_S1  =  4'd6,
		  PRO_S2  =  4'd7,
		  PRO_S3  =  4'd8,
		  PRO_S4  =  4'd9,
		  PRO_S5  =  4'd10,
		  RD_S1   =  4'd11,
		  RD_S2   =  4'd12;		  
endmodule

module I3C (...);
parameter ADDRESS = 7'b0000000;
input 	LGYS, CMS, ACS, AAS, STOPS, STRTS;
output 	LGYO, CMO, ACO, AAO, SIO, STOPO, STRTO;
input 	LGYC, CMC, ACC, AAC, SIC, STOPC, STRTC;
input	STRTHDS, SENDAHS, SENDALS, ACKHS;
input	ACKLS, STOPSUS, STOPHDS, SENDDHS;
input	SENDDLS, RECVDHS, RECVDLS, ADDRS;
output	PARITYERROR;
input 	[7:0] DI;
output 	[7:0] DOBUF;
output 	[7:0] DO;
output 	[7:0] STATE;
input	SDAI, SCLI;
output	SDAO, SCLO;
output	SDAOEN, SCLOEN;
output	SDAPULLO, SCLPULLO;
output	SDAPULLOEN, SCLPULLOEN;
input 	CE, RESET, CLK;
endmodule

module IODELAYA (...);
parameter C_STATIC_DLY = 0; 
input DI;
input  SDTAP;
input  SETN;
input  VALUE;
output DF;
output DO;
endmodule

module IODELAYC (...);
parameter C_STATIC_DLY = 0; 
parameter DYN_DA_SEL = "false"; 
parameter DA_SEL = 2'b00;
input DI;
input  SDTAP;
input  SETN;
input  VALUE;
input [1:0] DASEL;
input [1:0] DAADJ;
output DF;
output DO;
output DAO;
endmodule


module SPMI (...);
parameter FUNCTION_CTRL = 7'b0000000; 
parameter MSID_CLKSEL = 7'b0000000;
parameter RESPOND_DELAY = 4'b0000;
parameter SCLK_NORMAL_PERIOD = 7'b0000000;
parameter SCLK_LOW_PERIOD = 7'b0000000;
parameter CLK_FREQ = 7'b0000000;
parameter SHUTDOWN_BY_ENABLE = 1'b0; 
input	CLKEXT, ENEXT;
inout	SDATA, 	SCLK;
input 	CLK, CE, RESETN, LOCRESET;
input 	PA, SA, CA;
input	[3:0] 	ADDRI;
input	[7:0] 	DATAI;
output 	[3:0] 	ADDRO;
output 	[7:0] 	DATAO;
output 	[15:0] 	STATE;
output	[3:0]	CMD;
endmodule

module IODELAYB (...);
parameter C_STATIC_DLY = 0; 
parameter DELAY_MUX = 2'b00; 
parameter DA_SEL = 2'b00;
input DI;
input  SDTAP;
input  SETN;
input  VALUE;
input [1:0] DAADJ;
output DF;
output DO;
output DAO;
endmodule


module PLLO (...);
input CLKIN;
input CLKFB;
input RESET;
input RESET_P;
input RESET_I;
input RESET_S;
input [5:0] FBDSEL;
input [5:0] IDSEL;
input [6:0] ODSELA;
input [6:0] ODSELB;
input [6:0] ODSELC;
input [6:0] ODSELD;
input [3:0] DTA;
input [3:0] DTB;
input [4:0] ICPSEL;
input [2:0] LPFRES;
input [1:0] PSSEL;
input PSDIR;
input PSPULSE;
input ENCLKA;
input ENCLKB;
input ENCLKC;
input ENCLKD;
output LOCK;
output CLKOUTA;
output CLKOUTB;
output CLKOUTC;
output CLKOUTD;
parameter FCLKIN = "100.0"; 
parameter DYN_IDIV_SEL= "FALSE";
parameter IDIV_SEL = 0; 
parameter DYN_FBDIV_SEL= "FALSE";
parameter FBDIV_SEL = 0; 
parameter DYN_ODIVA_SEL= "FALSE";
parameter ODIVA_SEL = 6; 
parameter DYN_ODIVB_SEL= "FALSE";
parameter ODIVB_SEL = 6; 
parameter DYN_ODIVC_SEL= "FALSE";
parameter ODIVC_SEL = 6; 
parameter DYN_ODIVD_SEL= "FALSE";
parameter ODIVD_SEL = 6; 
parameter CLKOUTA_EN = "TRUE";
parameter CLKOUTB_EN = "TRUE";
parameter CLKOUTC_EN = "TRUE";
parameter CLKOUTD_EN = "TRUE";
parameter DYN_DTA_SEL = "FALSE"; 
parameter DYN_DTB_SEL = "FALSE"; 
parameter CLKOUTA_DT_DIR = 1'b1; 
parameter CLKOUTB_DT_DIR = 1'b1; 
parameter CLKOUTA_DT_STEP = 0; 
parameter CLKOUTB_DT_STEP = 0; 
parameter CLKA_IN_SEL = 2'b00;
parameter CLKA_OUT_SEL = 1'b0;
parameter CLKB_IN_SEL = 2'b00;
parameter CLKB_OUT_SEL = 1'b0;
parameter CLKC_IN_SEL = 2'b00;
parameter CLKC_OUT_SEL = 1'b0;
parameter CLKD_IN_SEL = 2'b00;
parameter CLKD_OUT_SEL = 1'b0;
parameter CLKFB_SEL = "INTERNAL"; 
parameter DYN_DPA_EN = "FALSE";
parameter DYN_PSB_SEL = "FALSE";
parameter DYN_PSC_SEL = "FALSE";
parameter DYN_PSD_SEL = "FALSE";
parameter PSB_COARSE = 1;
parameter PSB_FINE = 0;
parameter PSC_COARSE = 1;
parameter PSC_FINE = 0;
parameter PSD_COARSE = 1;
parameter PSD_FINE = 0;
parameter DTMS_ENB = "FALSE";
parameter DTMS_ENC = "FALSE";
parameter DTMS_END = "FALSE";
parameter RESET_I_EN = "FALSE";
parameter RESET_S_EN =  "FALSE";
parameter DYN_ICP_SEL= "FALSE";
parameter ICP_SEL = 5'bXXXXX;
parameter DYN_RES_SEL= "FALSE";
parameter LPR_REF = 7'bXXXXXXX;
endmodule

module DCCG (...);
output CLKOUT;
input CLKIN;
parameter DCC_MODE = 2'b00; 
parameter FCLKIN = 50.0;
endmodule

module FLASH96KA (...);
input[5:0]XADR;
input[5:0]YADR;
input XE,YE,SE;
input ERASE,PROG,NVSTR;
input [31:0] DIN;
input SLEEP;
output reg [31:0] DOUT;
parameter IDLE    =  4'd0,
          ERA_S1  =  4'd1,
		  ERA_S2  =  4'd2,
		  ERA_S3  =  4'd3,
		  ERA_S4  =  4'd4,
		  ERA_S5  =  4'd5,
		  PRO_S1  =  4'd6,
		  PRO_S2  =  4'd7,
		  PRO_S3  =  4'd8,
		  PRO_S4  =  4'd9,
		  PRO_S5  =  4'd10,
		  RD_S1   =  4'd11,
		  RD_S2   =  4'd12;		  
endmodule

module MIPI_DPHY_RX (...);
output [15:0] D0LN_HSRXD, D1LN_HSRXD, D2LN_HSRXD, D3LN_HSRXD;
output D0LN_HSRXD_VLD,D1LN_HSRXD_VLD,D2LN_HSRXD_VLD,D3LN_HSRXD_VLD;
output DI_LPRX0_N, DI_LPRX0_P, DI_LPRX1_N, DI_LPRX1_P, DI_LPRX2_N, DI_LPRX2_P, DI_LPRX3_N, DI_LPRX3_P;
output DI_LPRXCK_N, DI_LPRXCK_P;
output RX_CLK_O;          
output DESKEW_ERROR;      
inout  CK_N, CK_P, RX0_N, RX0_P, RX1_N, RX1_P, RX2_N, RX2_P, RX3_N, RX3_P;
input LPRX_EN_CK, LPRX_EN_D0, LPRX_EN_D1, LPRX_EN_D2, LPRX_EN_D3;
input HSRX_ODTEN_CK, HSRX_ODTEN_D0,  HSRX_ODTEN_D1, HSRX_ODTEN_D2, HSRX_ODTEN_D3;
input D0LN_HSRX_DREN,  D1LN_HSRX_DREN, D2LN_HSRX_DREN, D3LN_HSRX_DREN;
input HSRX_EN_CK;         
input HS_8BIT_MODE;       
input RX_CLK_1X;          
input RX_INVERT;          
input LALIGN_EN;          
input WALIGN_BY;          
input DO_LPTX0_N, DO_LPTX0_P, DO_LPTX1_N, DO_LPTX1_P, DO_LPTX2_N, DO_LPTX2_P, DO_LPTX3_N, DO_LPTX3_P;
input DO_LPTXCK_N, DO_LPTXCK_P;
input LPTX_EN_CK, LPTX_EN_D0, LPTX_EN_D1, LPTX_EN_D2, LPTX_EN_D3;
input BYTE_LENDIAN;       
input HSRX_STOP;          
input LPRX_ULP_LN0, LPRX_ULP_LN1, LPRX_ULP_LN2, LPRX_ULP_LN3, LPRX_ULP_CK;
input PWRON;              
input RESET;              
input [2:0] DESKEW_LNSEL; 
input [7:0] DESKEW_MTH;   
input [6:0] DESKEW_OWVAL; 
input DESKEW_REQ;         
input DRST_N;             
input ONE_BYTE0_MATCH;    
input WORD_LENDIAN;       
input [2:0] FIFO_RD_STD;  
parameter ALIGN_BYTE = 8'b10111000;
parameter MIPI_LANE0_EN = 1'b0;
parameter MIPI_LANE1_EN = 1'b0;
parameter MIPI_LANE2_EN = 1'b0;
parameter MIPI_LANE3_EN = 1'b0;
parameter MIPI_CK_EN = 1'b1;
parameter SYNC_CLK_SEL = 1'b1;
endmodule

module CLKDIVG (...);
input CLKIN;
input RESETN;
input CALIB;
output CLKOUT;
parameter DIV_MODE = "2"; 
parameter GSREN = "false"; 
endmodule
`,"lutrams.txt":`ram distributed $__GOWIN_LUTRAM_ {
	abits 4;
	width 4;
	cost 4;
	widthscale;
	init no_undef;
	prune_rom;
	port sw "W" {
		clock posedge;
	}
	port ar "R" {
	}
}
`,"lutrams_map.v":`module $__GOWIN_LUTRAM_(...);

parameter INIT = 64'bx;
parameter BITS_USED = 0;

input PORT_W_CLK;
input [3:0] PORT_W_ADDR;
input PORT_W_WR_EN;
input [3:0] PORT_W_WR_DATA;

input [3:0] PORT_R_ADDR;
output [3:0] PORT_R_RD_DATA;

function [15:0] init_slice;
input integer idx;
integer i;
for (i = 0; i < 16; i = i + 1)
	init_slice[i] = INIT[4*i+idx];
endfunction

generate

casez(BITS_USED)
4'b000z:
RAM16SDP1 #(
	.INIT_0(init_slice(0)),
) _TECHMAP_REPLACE_ (
	.WAD(PORT_W_ADDR),
	.RAD(PORT_R_ADDR),
	.DI(PORT_W_WR_DATA[0]),
	.DO(PORT_R_RD_DATA[0]),
	.CLK(PORT_W_CLK),
	.WRE(PORT_W_WR_EN)
);
4'b00zz:
RAM16SDP2 #(
	.INIT_0(init_slice(0)),
	.INIT_1(init_slice(1)),
) _TECHMAP_REPLACE_ (
	.WAD(PORT_W_ADDR),
	.RAD(PORT_R_ADDR),
	.DI(PORT_W_WR_DATA[1:0]),
	.DO(PORT_R_RD_DATA[1:0]),
	.CLK(PORT_W_CLK),
	.WRE(PORT_W_WR_EN)
);
default:
RAM16SDP4 #(
	.INIT_0(init_slice(0)),
	.INIT_1(init_slice(1)),
	.INIT_2(init_slice(2)),
	.INIT_3(init_slice(3)),
) _TECHMAP_REPLACE_ (
	.WAD(PORT_W_ADDR),
	.RAD(PORT_R_ADDR),
	.DI(PORT_W_WR_DATA),
	.DO(PORT_R_RD_DATA),
	.CLK(PORT_W_CLK),
	.WRE(PORT_W_WR_EN)
);
endcase

endgenerate

endmodule
`},greenpak4:{"cells_blackbox.v":`module \\$__COUNT_ (CE, CLK, OUT, POUT, RST, UP);

	input wire CE;
	input wire CLK;
	output reg OUT;
	output reg[WIDTH-1:0] POUT;
	input wire RST;
	input wire UP;

	parameter COUNT_TO = 1;
	parameter RESET_MODE = "RISING";
	parameter RESET_TO_MAX = "1";
	parameter HAS_POUT = 0;
	parameter HAS_CE = 0;
	parameter WIDTH = 8;
	parameter DIRECTION = "DOWN";

endmodule
`,"cells_latch.v":`module $_DLATCH_P_(input E, input D, output Q);
	GP_DLATCH _TECHMAP_REPLACE_ (
		.D(D),
		.nCLK(!E),
		.Q(Q)
		);
endmodule

module $_DLATCH_N_(input E, input D, output Q);
	GP_DLATCH _TECHMAP_REPLACE_ (
		.D(D),
		.nCLK(E),
		.Q(Q)
		);
endmodule
`,"cells_map.v":`module GP_DFFS(input D, CLK, nSET, output reg Q);
	parameter [0:0] INIT = 1'bx;
	GP_DFFSR #(
		.INIT(INIT),
		.SRMODE(1'b1),
	) _TECHMAP_REPLACE_ (
		.D(D),
		.CLK(CLK),
		.nSR(nSET),
		.Q(Q)
	);
endmodule

module GP_DFFR(input D, CLK, nRST, output reg Q);
	parameter [0:0] INIT = 1'bx;
	GP_DFFSR #(
		.INIT(INIT),
		.SRMODE(1'b0),
	) _TECHMAP_REPLACE_ (
		.D(D),
		.CLK(CLK),
		.nSR(nRST),
		.Q(Q)
	);
endmodule

module GP_DFFSI(input D, CLK, nSET, output reg nQ);
	parameter [0:0] INIT = 1'bx;
	GP_DFFSRI #(
		.INIT(INIT),
		.SRMODE(1'b1),
	) _TECHMAP_REPLACE_ (
		.D(D),
		.CLK(CLK),
		.nSR(nSET),
		.nQ(nQ)
	);
endmodule

module GP_DFFRI(input D, CLK, nRST, output reg nQ);
	parameter [0:0] INIT = 1'bx;
	GP_DFFSRI #(
		.INIT(INIT),
		.SRMODE(1'b0),
	) _TECHMAP_REPLACE_ (
		.D(D),
		.CLK(CLK),
		.nSR(nRST),
		.nQ(nQ)
	);
endmodule

module GP_DLATCHS(input D, nCLK, nSET, output reg Q);
	parameter [0:0] INIT = 1'bx;
	GP_DLATCHSR #(
		.INIT(INIT),
		.SRMODE(1'b1),
	) _TECHMAP_REPLACE_ (
		.D(D),
		.nCLK(nCLK),
		.nSR(nSET),
		.Q(Q)
	);
endmodule

module GP_DLATCHR(input D, nCLK, nRST, output reg Q);
	parameter [0:0] INIT = 1'bx;
	GP_DLATCHSR #(
		.INIT(INIT),
		.SRMODE(1'b0),
	) _TECHMAP_REPLACE_ (
		.D(D),
		.nCLK(nCLK),
		.nSR(nRST),
		.Q(Q)
	);
endmodule

module GP_DLATCHSI(input D, nCLK, nSET, output reg nQ);
	parameter [0:0] INIT = 1'bx;
	GP_DLATCHSRI #(
		.INIT(INIT),
		.SRMODE(1'b1),
	) _TECHMAP_REPLACE_ (
		.D(D),
		.nCLK(nCLK),
		.nSR(nSET),
		.nQ(nQ)
	);
endmodule

module GP_DLATCHRI(input D, nCLK, nRST, output reg nQ);
	parameter [0:0] INIT = 1'bx;
	GP_DLATCHSRI #(
		.INIT(INIT),
		.SRMODE(1'b0),
	) _TECHMAP_REPLACE_ (
		.D(D),
		.nCLK(nCLK),
		.nSR(nRST),
		.nQ(nQ)
	);
endmodule

module GP_OBUFT(input IN, input OE, output OUT);
	GP_IOBUF _TECHMAP_REPLACE_ (
		.IN(IN),
		.OE(OE),
		.IO(OUT),
		.OUT()
	);
endmodule

module \\$lut (A, Y);
	parameter WIDTH = 0;
	parameter LUT = 0;

	(* force_downto *)
	input [WIDTH-1:0] A;
	output Y;

	generate
		if (WIDTH == 1) begin
		if(LUT == 2'b01) begin
			GP_INV _TECHMAP_REPLACE_ (.OUT(Y), .IN(A[0]) );
		end
		else begin
			GP_2LUT #(.INIT({2'b00, LUT})) _TECHMAP_REPLACE_ (.OUT(Y),
				.IN0(A[0]), .IN1(1'b0));
		end
		end else
		if (WIDTH == 2) begin
			GP_2LUT #(.INIT(LUT)) _TECHMAP_REPLACE_ (.OUT(Y),
				.IN0(A[0]), .IN1(A[1]));
		end else
		if (WIDTH == 3) begin
			GP_3LUT #(.INIT(LUT)) _TECHMAP_REPLACE_ (.OUT(Y),
				.IN0(A[0]), .IN1(A[1]), .IN2(A[2]));
		end else
		if (WIDTH == 4) begin
			GP_4LUT #(.INIT(LUT)) _TECHMAP_REPLACE_ (.OUT(Y),
				.IN0(A[0]), .IN1(A[1]), .IN2(A[2]), .IN3(A[3]));
		end else begin
			wire _TECHMAP_FAIL_ = 1;
		end
	endgenerate
endmodule

module \\$__COUNT_ (CE, CLK, OUT, POUT, RST, UP);

	input wire CE;
	input wire CLK;
	output reg OUT;
	(* force_downto *)
	output reg[WIDTH-1:0] POUT;
	input wire RST;
	input wire UP;

	parameter COUNT_TO = 1;
	parameter RESET_MODE = "RISING";
	parameter RESET_TO_MAX = 0;
	parameter HAS_POUT = 0;
	parameter HAS_CE = 0;
	parameter WIDTH = 8;
	parameter DIRECTION = "DOWN";

	//If we have a DIRECTION other than DOWN fail... GP_COUNTx_ADV is not supported yet
	if(DIRECTION != "DOWN") begin
		initial begin
			$display("ERROR: \\$__COUNT_ support for GP_COUNTx_ADV is not yet implemented. This counter should never have been extracted (bug in extract_counter pass?).");
			$finish;
		end
	end

	//If counter is more than 14 bits wide, complain (also shouldn't happen)
	else if(WIDTH > 14) begin
		initial begin
			$display("ERROR: \\$__COUNT_ support for cascaded counters is not yet implemented. This counter should never have been extracted (bug in extract_counter pass?).");
			$finish;
		end
	end

	//If counter is more than 8 bits wide and has parallel output, we have a problem
	else if(WIDTH > 8 && HAS_POUT) begin
		initial begin
			$display("ERROR: \\$__COUNT_ support for 9-14 bit counters with parallel output is not yet implemented. This counter should never have been extracted (bug in extract_counter pass?).");
			$finish;
		end
	end

	//Looks like a legal counter! Do something with it
	else if(WIDTH <= 8) begin
		if(HAS_CE) begin
			wire ce_not;
			GP_INV ceinv(
				.IN(CE),
				.OUT(ce_not)
			);
			GP_COUNT8_ADV #(
				.COUNT_TO(COUNT_TO),
				.RESET_MODE(RESET_MODE),
				.RESET_VALUE(RESET_TO_MAX ? "COUNT_TO" : "ZERO"),
				.CLKIN_DIVIDE(1)
			) _TECHMAP_REPLACE_ (
				.CLK(CLK),
				.RST(RST),
				.OUT(OUT),
				.UP(1'b0),		//always count down for now
				.KEEP(ce_not),
				.POUT(POUT)
			);
		end
		else begin
			GP_COUNT8 #(
				.COUNT_TO(COUNT_TO),
				.RESET_MODE(RESET_MODE),
				.CLKIN_DIVIDE(1)
			) _TECHMAP_REPLACE_ (
				.CLK(CLK),
				.RST(RST),
				.OUT(OUT),
				.POUT(POUT)
			);
		end
	end

	else begin
		if(HAS_CE) begin
			wire ce_not;
			GP_INV ceinv(
				.IN(CE),
				.OUT(ce_not)
			);
			GP_COUNT14_ADV #(
				.COUNT_TO(COUNT_TO),
				.RESET_MODE(RESET_TO_MAX ? "COUNT_TO" : "ZERO"),
				.RESET_VALUE("COUNT_TO"),
				.CLKIN_DIVIDE(1)
			) _TECHMAP_REPLACE_ (
				.CLK(CLK),
				.RST(RST),
				.OUT(OUT),
				.UP(1'b0),		//always count down for now
				.KEEP(ce_not),
				.POUT(POUT)
			);
		end
		else begin
			GP_COUNT14 #(
				.COUNT_TO(COUNT_TO),
				.RESET_MODE(RESET_MODE),
				.CLKIN_DIVIDE(1)
			) _TECHMAP_REPLACE_ (
				.CLK(CLK),
				.RST(RST),
				.OUT(OUT)
			);
		end
	end

endmodule
`,"cells_sim.v":`\`timescale 1ns/1ps

\`include "cells_sim_ams.v"
\`include "cells_sim_digital.v"
\`include "cells_sim_wip.v"
`,"cells_sim_ams.v":`\`timescale 1ns/1ps

/*
 This file contains analog / mixed signal cells, or other things that are not possible to fully model
 in behavioral Verilog.

 It also contains some stuff like oscillators that use non-synthesizeable constructs such as delays.
 TODO: do we want a third file for those cells?
 */

module GP_ABUF(input wire IN, output wire OUT);

	assign OUT = IN;

	//must be 1, 5, 20, 50
	//values >1 only available with Vdd > 2.7V
	parameter BANDWIDTH_KHZ = 1;

endmodule

module GP_ACMP(input wire PWREN, input wire VIN, input wire VREF, output reg OUT);

	parameter BANDWIDTH = "HIGH";
	parameter VIN_ATTEN = 1;
	parameter VIN_ISRC_EN = 0;
	parameter HYSTERESIS = 0;

	initial OUT = 0;

endmodule

module GP_BANDGAP(output reg OK);
	parameter AUTO_PWRDN = 1;
	parameter CHOPPER_EN = 1;
	parameter OUT_DELAY = 100;

endmodule

module GP_DAC(input[7:0] DIN, input wire VREF, output reg VOUT);

	initial VOUT = 0;

	//analog hard IP is not supported for simulation

endmodule

module GP_LFOSC(input PWRDN, output reg CLKOUT);

	parameter PWRDN_EN = 0;
	parameter AUTO_PWRDN = 0;
	parameter OUT_DIV = 1;

	initial CLKOUT = 0;

	//auto powerdown not implemented for simulation
	//output dividers not implemented for simulation

	always begin
		if(PWRDN)
			CLKOUT = 0;
		else begin
			//half period of 1730 Hz
			#289017;
			CLKOUT = ~CLKOUT;
		end
	end

endmodule

module GP_PGA(input wire VIN_P, input wire VIN_N, input wire VIN_SEL, output reg VOUT);

	parameter GAIN = 1;
	parameter INPUT_MODE = "SINGLE";

	initial VOUT = 0;

	//cannot simulate mixed signal IP

endmodule

module GP_PWRDET(output reg VDD_LOW);
	initial VDD_LOW = 0;
endmodule

module GP_VREF(input VIN, output reg VOUT);
	parameter VIN_DIV = 1;
	parameter VREF = 0;
	//cannot simulate mixed signal IP
endmodule

module GP_POR(output reg RST_DONE);
	parameter POR_TIME = 500;

	initial begin
		RST_DONE = 0;

		if(POR_TIME == 4)
			#4000;
		else if(POR_TIME == 500)
			#500000;
		else begin
			$display("ERROR: bad POR_TIME for GP_POR cell");
			$finish;
		end

		RST_DONE = 1;

	end

endmodule
`,"cells_sim_digital.v":`\`timescale 1ns/1ps

/*
 This file contains simulation models for GreenPAK cells which are possible to fully model using synthesizeable
 behavioral Verilog constructs only.
 */

module GP_2LUT(input IN0, IN1, output OUT);
	parameter [3:0] INIT = 0;
	assign OUT = INIT[{IN1, IN0}];
endmodule

module GP_3LUT(input IN0, IN1, IN2, output OUT);
	parameter [7:0] INIT = 0;
	assign OUT = INIT[{IN2, IN1, IN0}];
endmodule

module GP_4LUT(
	input wire IN0,
	input wire IN1,
	input wire IN2,
	input wire IN3,
	output wire OUT);

	parameter [15:0] INIT = 0;
	assign OUT = INIT[{IN3, IN2, IN1, IN0}];
endmodule

module GP_CLKBUF(input wire IN, output wire OUT);
	assign OUT = IN;
endmodule

module GP_COUNT14(input CLK, input wire RST, output reg OUT);

	parameter RESET_MODE 	= "RISING";

	parameter COUNT_TO		= 14'h1;
	parameter CLKIN_DIVIDE	= 1;

	reg[13:0] count = COUNT_TO;

	initial begin
		if(CLKIN_DIVIDE != 1) begin
			$display("ERROR: CLKIN_DIVIDE values other than 1 not implemented");
			$finish;
		end
	end

	//Combinatorially output underflow flag whenever we wrap low
	always @(*) begin
		OUT <= (count == 14'h0);
	end

	//POR or SYSRST reset value is COUNT_TO. Datasheet is unclear but conversations w/ Silego confirm.
	//Runtime reset value is clearly 0 except in count/FSM cells where it's configurable but we leave at 0 for now.
	generate
		case(RESET_MODE)

			"RISING": begin
				always @(posedge CLK, posedge RST) begin
					if(RST)
						count		<= 0;
					else begin
						count		<= count - 1'd1;
						if(count == 0)
							count	<= COUNT_TO;
					end
				end
			end

			"FALLING": begin
				always @(posedge CLK, negedge RST) begin
					if(!RST)
						count		<= 0;
					else begin
						count		<= count - 1'd1;
						if(count == 0)
							count	<= COUNT_TO;
					end
				end
			end

			"BOTH": begin
				initial begin
					$display("Both-edge reset mode for GP_COUNT14 not implemented");
					$finish;
				end
			end

			"LEVEL": begin
				always @(posedge CLK, posedge RST) begin
					if(RST)
						count		<= 0;

					else begin
						count		<= count - 1'd1;
						if(count == 0)
							count	<= COUNT_TO;
					end
				end
			end

			default: begin
				initial begin
					$display("Invalid RESET_MODE on GP_COUNT14");
					$finish;
				end
			end

		endcase
	endgenerate

endmodule

module GP_COUNT14_ADV(input CLK, input RST, output reg OUT,
                     input UP, input KEEP, output reg[7:0] POUT);

	parameter RESET_MODE 	= "RISING";
	parameter RESET_VALUE   = "ZERO";

	parameter COUNT_TO		= 14'h1;
	parameter CLKIN_DIVIDE	= 1;

	initial begin
		if(CLKIN_DIVIDE != 1) begin
			$display("ERROR: CLKIN_DIVIDE values other than 1 not implemented");
			$finish;
		end
	end

	reg[13:0] count = COUNT_TO;

	//Combinatorially output underflow flag whenever we wrap low
	always @(*) begin
		if(UP)
			OUT <= (count == 14'h3fff);
		else
			OUT <= (count == 14'h0);
		POUT <= count[7:0];
	end

	//POR or SYSRST reset value is COUNT_TO. Datasheet is unclear but conversations w/ Silego confirm.
	//Runtime reset value is clearly 0 except in count/FSM cells where it's configurable but we leave at 0 for now.
	generate
		case(RESET_MODE)

			"RISING": begin
				always @(posedge CLK, posedge RST) begin

					//Resets
					if(RST) begin
						if(RESET_VALUE == "ZERO")
							count	<= 0;
						else
							count	<= COUNT_TO;
					end

					else if(KEEP) begin
					end
					else if(UP) begin
						count		<= count + 1'd1;
						if(count == 14'h3fff)
							count	<= COUNT_TO;
					end
					else begin
						count		<= count - 1'd1;

						if(count == 0)
							count	<= COUNT_TO;
					end

				end
			end

			"FALLING": begin
				always @(posedge CLK, negedge RST) begin

					//Resets
					if(!RST) begin
						if(RESET_VALUE == "ZERO")
							count	<= 0;
						else
							count	<= COUNT_TO;
					end

					else if(KEEP) begin
					end
					else if(UP) begin
						count		<= count + 1'd1;
						if(count == 14'h3fff)
							count	<= COUNT_TO;
					end
					else begin
						count		<= count - 1'd1;

						if(count == 0)
							count	<= COUNT_TO;
					end

				end
			end

			"BOTH": begin
				initial begin
					$display("Both-edge reset mode for GP_COUNT14_ADV not implemented");
					$finish;
				end
			end

			"LEVEL": begin
				always @(posedge CLK, posedge RST) begin

					//Resets
					if(RST) begin
						if(RESET_VALUE == "ZERO")
							count	<= 0;
						else
							count	<= COUNT_TO;
					end

					else begin

						if(KEEP) begin
						end
						else if(UP) begin
							count		<= count + 1'd1;
							if(count == 14'h3fff)
								count	<= COUNT_TO;
						end
						else begin
							count		<= count - 1'd1;

							if(count == 0)
								count	<= COUNT_TO;
						end

					end

				end
			end

			default: begin
				initial begin
					$display("Invalid RESET_MODE on GP_COUNT14_ADV");
					$finish;
				end
			end

		endcase
	endgenerate

endmodule

module GP_COUNT8_ADV(input CLK, input RST, output reg OUT,
                     input UP, input KEEP, output reg[7:0] POUT);

	parameter RESET_MODE 	= "RISING";
	parameter RESET_VALUE   = "ZERO";

	parameter COUNT_TO		= 8'h1;
	parameter CLKIN_DIVIDE	= 1;

	reg[7:0] count = COUNT_TO;

	initial begin
		if(CLKIN_DIVIDE != 1) begin
			$display("ERROR: CLKIN_DIVIDE values other than 1 not implemented");
			$finish;
		end
	end

	//Combinatorially output underflow flag whenever we wrap low
	always @(*) begin
		if(UP)
			OUT <= (count == 8'hff);
		else
			OUT <= (count == 8'h0);
		POUT <= count;
	end

	//POR or SYSRST reset value is COUNT_TO. Datasheet is unclear but conversations w/ Silego confirm.
	//Runtime reset value is clearly 0 except in count/FSM cells where it's configurable but we leave at 0 for now.
	generate
		case(RESET_MODE)

			"RISING": begin
				always @(posedge CLK, posedge RST) begin

					//Resets
					if(RST) begin
						if(RESET_VALUE == "ZERO")
							count	<= 0;
						else
							count	<= COUNT_TO;
					end

					//Main counter
					else if(KEEP) begin
					end
					else if(UP) begin
						count		<= count + 1'd1;
						if(count == 8'hff)
							count	<= COUNT_TO;
					end
					else begin
						count		<= count - 1'd1;

						if(count == 0)
							count	<= COUNT_TO;
					end

				end
			end

			"FALLING": begin
				always @(posedge CLK, negedge RST) begin

					//Resets
					if(!RST) begin
						if(RESET_VALUE == "ZERO")
							count	<= 0;
						else
							count	<= COUNT_TO;
					end

					//Main counter
					else if(KEEP) begin
					end
					else if(UP) begin
						count		<= count + 1'd1;
						if(count == 8'hff)
							count	<= COUNT_TO;
					end
					else begin
						count		<= count - 1'd1;

						if(count == 0)
							count	<= COUNT_TO;
					end

				end
			end

			"BOTH": begin
				initial begin
					$display("Both-edge reset mode for GP_COUNT8_ADV not implemented");
					$finish;
				end
			end

			"LEVEL": begin
				always @(posedge CLK, posedge RST) begin

					//Resets
					if(RST) begin
						if(RESET_VALUE == "ZERO")
							count	<= 0;
						else
							count	<= COUNT_TO;
					end

					else begin

						if(KEEP) begin
						end
						else if(UP) begin
							count		<= count + 1'd1;
							if(count == 8'hff)
								count	<= COUNT_TO;
						end
						else begin
							count		<= count - 1'd1;

							if(count == 0)
								count	<= COUNT_TO;
						end
					end

				end
			end

			default: begin
				initial begin
					$display("Invalid RESET_MODE on GP_COUNT8_ADV");
					$finish;
				end
			end

		endcase
	endgenerate

endmodule

module GP_COUNT8(
	input wire CLK,
	input wire RST,
	output reg OUT,
	output reg[7:0] POUT);

	parameter RESET_MODE 	= "RISING";

	parameter COUNT_TO		= 8'h1;
	parameter CLKIN_DIVIDE	= 1;

	initial begin
		if(CLKIN_DIVIDE != 1) begin
			$display("ERROR: CLKIN_DIVIDE values other than 1 not implemented");
			$finish;
		end
	end

	reg[7:0] count = COUNT_TO;

	//Combinatorially output underflow flag whenever we wrap low
	always @(*) begin
		OUT <= (count == 8'h0);
		POUT <= count;
	end

	//POR or SYSRST reset value is COUNT_TO. Datasheet is unclear but conversations w/ Silego confirm.
	//Runtime reset value is clearly 0 except in count/FSM cells where it's configurable but we leave at 0 for now.
	generate
		case(RESET_MODE)

			"RISING": begin
				always @(posedge CLK, posedge RST) begin
					if(RST)
						count	<= 0;
					else begin
						count		<= count - 1'd1;
						if(count == 0)
							count	<= COUNT_TO;
					end
				end
			end

			"FALLING": begin
				always @(posedge CLK, negedge RST) begin
					if(!RST)
						count	<= 0;
					else begin
						count		<= count - 1'd1;
						if(count == 0)
							count	<= COUNT_TO;
					end
				end
			end

			"BOTH": begin
				initial begin
					$display("Both-edge reset mode for GP_COUNT8 not implemented");
					$finish;
				end
			end

			"LEVEL": begin
				always @(posedge CLK, posedge RST) begin
					if(RST)
						count	<= 0;

					else begin
						count		<= count - 1'd1;
						if(count == 0)
							count	<= COUNT_TO;
					end
				end
			end

			default: begin
				initial begin
					$display("Invalid RESET_MODE on GP_COUNT8");
					$finish;
				end
			end

		endcase
	endgenerate

endmodule

module GP_DCMPREF(output reg[7:0]OUT);
	parameter[7:0] REF_VAL = 8'h00;
	initial OUT = REF_VAL;
endmodule

module GP_DCMPMUX(input[1:0] SEL, input[7:0] IN0, input[7:0] IN1, input[7:0] IN2, input[7:0] IN3, output reg[7:0] OUTA, output reg[7:0] OUTB);

	always @(*) begin
		case(SEL)
			2'd00: begin
				OUTA <= IN0;
				OUTB <= IN3;
			end

			2'd01: begin
				OUTA <= IN1;
				OUTB <= IN2;
			end

			2'd02: begin
				OUTA <= IN2;
				OUTB <= IN1;
			end

			2'd03: begin
				OUTA <= IN3;
				OUTB <= IN0;
			end

		endcase
	end
endmodule

module GP_DELAY(input IN, output reg OUT);

	parameter DELAY_STEPS = 1;
	parameter GLITCH_FILTER = 0;

	initial OUT = 0;

	generate

		if(GLITCH_FILTER) begin
			initial begin
				$display("ERROR: GP_DELAY glitch filter mode not implemented");
				$finish;
			end
		end

		//TODO: These delays are PTV dependent! For now, hard code 3v3 timing
		//Change simulation-mode delay depending on global Vdd range (how to specify this?)
		always @(*) begin
			case(DELAY_STEPS)
				1: #166 OUT = IN;
				2: #318 OUT = IN;
				2: #471 OUT = IN;
				3: #622 OUT = IN;
				default: begin
					$display("ERROR: GP_DELAY must have DELAY_STEPS in range [1,4]");
					$finish;
				end
			endcase
		end

	endgenerate

endmodule

module GP_DFF(input D, CLK, output reg Q);
	parameter [0:0] INIT = 1'bx;
	initial Q = INIT;
	always @(posedge CLK) begin
		Q <= D;
	end
endmodule

module GP_DFFI(input D, CLK, output reg nQ);
	parameter [0:0] INIT = 1'bx;
	initial nQ = INIT;
	always @(posedge CLK) begin
		nQ <= ~D;
	end
endmodule

module GP_DFFR(input D, CLK, nRST, output reg Q);
	parameter [0:0] INIT = 1'bx;
	initial Q = INIT;
	always @(posedge CLK, negedge nRST) begin
		if (!nRST)
			Q <= 1'b0;
		else
			Q <= D;
	end
endmodule

module GP_DFFRI(input D, CLK, nRST, output reg nQ);
	parameter [0:0] INIT = 1'bx;
	initial nQ = INIT;
	always @(posedge CLK, negedge nRST) begin
		if (!nRST)
			nQ <= 1'b1;
		else
			nQ <= ~D;
	end
endmodule

module GP_DFFS(input D, CLK, nSET, output reg Q);
	parameter [0:0] INIT = 1'bx;
	initial Q = INIT;
	always @(posedge CLK, negedge nSET) begin
		if (!nSET)
			Q <= 1'b1;
		else
			Q <= D;
	end
endmodule

module GP_DFFSI(input D, CLK, nSET, output reg nQ);
	parameter [0:0] INIT = 1'bx;
	initial nQ = INIT;
	always @(posedge CLK, negedge nSET) begin
		if (!nSET)
			nQ <= 1'b0;
		else
			nQ <= ~D;
	end
endmodule

module GP_DFFSR(input D, CLK, nSR, output reg Q);
	parameter [0:0] INIT = 1'bx;
	parameter [0:0] SRMODE = 1'bx;
	initial Q = INIT;
	always @(posedge CLK, negedge nSR) begin
		if (!nSR)
			Q <= SRMODE;
		else
			Q <= D;
	end
endmodule

module GP_DFFSRI(input D, CLK, nSR, output reg nQ);
	parameter [0:0] INIT = 1'bx;
	parameter [0:0] SRMODE = 1'bx;
	initial nQ = INIT;
	always @(posedge CLK, negedge nSR) begin
		if (!nSR)
			nQ <= ~SRMODE;
		else
			nQ <= ~D;
	end
endmodule

module GP_DLATCH(input D, input nCLK, output reg Q);
	parameter [0:0] INIT = 1'bx;
	initial Q = INIT;
	always @(*) begin
		if(!nCLK)
			Q <= D;
	end
endmodule

module GP_DLATCHI(input D, input nCLK, output reg nQ);
	parameter [0:0] INIT = 1'bx;
	initial nQ = INIT;
	always @(*) begin
		if(!nCLK)
			nQ <= ~D;
	end
endmodule

module GP_DLATCHR(input D, input nCLK, input nRST, output reg Q);
	parameter [0:0] INIT = 1'bx;
	initial Q = INIT;
	always @(*) begin
		if(!nRST)
			Q <= 1'b0;
		else if(!nCLK)
			Q <= D;
	end
endmodule

module GP_DLATCHRI(input D, input nCLK, input nRST, output reg nQ);
	parameter [0:0] INIT = 1'bx;
	initial nQ = INIT;
	always @(*) begin
		if(!nRST)
			nQ <= 1'b1;
		else if(!nCLK)
			nQ <= ~D;
	end
endmodule

module GP_DLATCHS(input D, input nCLK, input nSET, output reg Q);
	parameter [0:0] INIT = 1'bx;
	initial Q = INIT;
	always @(*) begin
		if(!nSET)
			Q <= 1'b1;
		else if(!nCLK)
			Q <= D;
	end
endmodule

module GP_DLATCHSI(input D, input nCLK, input nSET, output reg nQ);
	parameter [0:0] INIT = 1'bx;
	initial nQ = INIT;
	always @(*) begin
		if(!nSET)
			nQ <= 1'b0;
		else if(!nCLK)
			nQ <= ~D;
	end
endmodule

module GP_DLATCHSR(input D, input nCLK, input nSR, output reg Q);
	parameter [0:0] INIT = 1'bx;
	parameter[0:0] SRMODE = 1'bx;
	initial Q = INIT;
	always @(*) begin
		if(!nSR)
			Q <= SRMODE;
		else if(!nCLK)
			Q <= D;
	end
endmodule

module GP_DLATCHSRI(input D, input nCLK, input nSR, output reg nQ);
	parameter [0:0] INIT = 1'bx;
	parameter[0:0] SRMODE = 1'bx;
	initial nQ = INIT;
	always @(*) begin
		if(!nSR)
			nQ <= ~SRMODE;
		else if(!nCLK)
			nQ <= ~D;
	end
endmodule

module GP_IBUF(input IN, output OUT);
	assign OUT = IN;
endmodule

module GP_IOBUF(input IN, input OE, output OUT, inout IO);
	assign OUT = IO;
	assign IO = OE ? IN : 1'bz;
endmodule

module GP_INV(input IN, output OUT);
	assign OUT = ~IN;
endmodule

module GP_OBUF(input IN, output OUT);
	assign OUT = IN;
endmodule

module GP_OBUFT(input IN, input OE, output OUT);
	assign OUT = OE ? IN : 1'bz;
endmodule

module GP_PGEN(input wire nRST, input wire CLK, output reg OUT);
	initial OUT = 0;
	parameter PATTERN_DATA = 16'h0;
	parameter PATTERN_LEN = 5'd16;

	localparam COUNT_MAX =  PATTERN_LEN - 1'h1;

	reg[3:0] count = 0;
	always @(posedge CLK, negedge nRST) begin

		if(!nRST)
			count	<= 0;

		else begin
			count	<= count - 1'h1;
			if(count == 0)
				count <= COUNT_MAX;
		end
	end

	always @(*)
		OUT	= PATTERN_DATA[count];

endmodule

module GP_SHREG(input nRST, input CLK, input IN, output OUTA, output OUTB);

	parameter OUTA_TAP = 1;
	parameter OUTA_INVERT = 0;
	parameter OUTB_TAP = 1;

	reg[15:0] shreg = 0;

	always @(posedge CLK, negedge nRST) begin

		if(!nRST)
			shreg = 0;

		else
			shreg <= {shreg[14:0], IN};

	end

	assign OUTA = (OUTA_INVERT) ? ~shreg[OUTA_TAP - 1] : shreg[OUTA_TAP - 1];
	assign OUTB = shreg[OUTB_TAP - 1];

endmodule

module GP_VDD(output OUT);
       assign OUT = 1;
endmodule

module GP_VSS(output OUT);
       assign OUT = 0;
endmodule
`,"cells_sim_wip.v":`
//Cells still in this file have INCOMPLETE simulation models, need to finish them

module GP_DCMP(input[7:0] INP, input[7:0] INN, input CLK, input PWRDN, output reg GREATER, output reg EQUAL);
	parameter PWRDN_SYNC = 1'b0;
	parameter CLK_EDGE = "RISING";
	parameter GREATER_OR_EQUAL = 1'b0;

	//TODO implement power-down mode

	initial GREATER = 0;
	initial EQUAL = 0;

	wire clk_minv = (CLK_EDGE == "RISING") ? CLK : ~CLK;
	always @(posedge clk_minv) begin
		if(GREATER_OR_EQUAL)
			GREATER <= (INP >= INN);
		else
			GREATER <= (INP > INN);

		EQUAL <= (INP == INN);
	end

endmodule

module GP_EDGEDET(input IN, output reg OUT);

	parameter EDGE_DIRECTION = "RISING";
	parameter DELAY_STEPS = 1;
	parameter GLITCH_FILTER = 0;

	//not implemented for simulation

endmodule

module GP_RCOSC(input PWRDN, output reg CLKOUT_HARDIP, output reg CLKOUT_FABRIC);

	parameter PWRDN_EN = 0;
	parameter AUTO_PWRDN = 0;
	parameter HARDIP_DIV = 1;
	parameter FABRIC_DIV = 1;
	parameter OSC_FREQ = "25k";

	initial CLKOUT_HARDIP = 0;
	initial CLKOUT_FABRIC = 0;

	//output dividers not implemented for simulation
	//auto powerdown not implemented for simulation

	always begin
		if(PWRDN) begin
			CLKOUT_HARDIP = 0;
			CLKOUT_FABRIC = 0;
		end
		else begin

			if(OSC_FREQ == "25k") begin
				//half period of 25 kHz
				#20000;
			end

			else begin
				//half period of 2 MHz
				#250;
			end

			CLKOUT_HARDIP = ~CLKOUT_HARDIP;
			CLKOUT_FABRIC = ~CLKOUT_FABRIC;
		end
	end

endmodule

module GP_RINGOSC(input PWRDN, output reg CLKOUT_HARDIP, output reg CLKOUT_FABRIC);

	parameter PWRDN_EN = 0;
	parameter AUTO_PWRDN = 0;
	parameter HARDIP_DIV = 1;
	parameter FABRIC_DIV = 1;

	initial CLKOUT_HARDIP = 0;
	initial CLKOUT_FABRIC = 0;

	//output dividers not implemented for simulation
	//auto powerdown not implemented for simulation

	always begin
		if(PWRDN) begin
			CLKOUT_HARDIP = 0;
			CLKOUT_FABRIC = 0;
		end
		else begin
			//half period of 27 MHz
			#18.518;
			CLKOUT_HARDIP = ~CLKOUT_HARDIP;
			CLKOUT_FABRIC = ~CLKOUT_FABRIC;
		end
	end

endmodule

module GP_SPI(
	input SCK,
	inout SDAT,
	input CSN,
	input[7:0] TXD_HIGH,
	input[7:0] TXD_LOW,
	output reg[7:0] RXD_HIGH,
	output reg[7:0] RXD_LOW,
	output reg INT);

	initial RXD_HIGH = 0;
	initial RXD_LOW = 0;
	initial INT = 0;

	parameter DATA_WIDTH = 8;		//byte or word width
	parameter SPI_CPHA = 0;			//SPI clock phase
	parameter SPI_CPOL = 0;			//SPI clock polarity
	parameter DIRECTION = "INPUT";	//SPI data direction (either input to chip or output to host)
	//parallel output to fabric not yet implemented

	//TODO: write sim model
	//TODO: SPI SDIO control... can we use ADC output while SPI is input??
	//TODO: clock sync

endmodule

//keep constraint needed to prevent optimization since we have no outputs
(* keep *)
module GP_SYSRESET(input RST);
	parameter RESET_MODE = "EDGE";
	parameter EDGE_SPEED = 4;

	//cannot simulate whole system reset

endmodule
`,"gp_dff.lib":`library(gp_dff) {
  cell(GP_DFF) {
    area: 1;
    ff("IQ", "IQN") { clocked_on: CLK;
                      next_state: D; }
    pin(CLK) { direction: input;
                   clock: true; }
    pin(D) { direction: input; }
    pin(Q) { direction: output;
              function: "IQ"; }
  }
  cell(GP_DFFS) {
    area: 1;
    ff("IQ", "IQN") { clocked_on: CLK;
                  next_state: D;
                      preset: "nSET'"; }
    pin(CLK) { direction: input;
                 clock: true; }
    pin(D) { direction: input; }
    pin(Q) { direction: output;
              function: "IQ"; }
    pin(nSET) { direction: input; }
  }
  cell(GP_DFFR) {
    area: 1;
    ff("IQ", "IQN") { clocked_on: CLK;
                      next_state: D;
                           clear: "nRST'"; }
    pin(CLK) { direction: input;
                   clock: true; }
    pin(D) { direction: input; }
    pin(Q) { direction: output;
              function: "IQ"; }
    pin(nRST) { direction: input; }
  }
}
`},ice40:{"abc9_model.v":`(* abc9_box, lib_whitebox *)
module \\$__ICE40_CARRY_WRAPPER (
	(* abc9_carry *)
	output CO,
	output O,
	input A, B,
	(* abc9_carry *)
	input CI,
	input I0, I3
);
	parameter LUT = 0;
	parameter I3_IS_CI = 0;
	wire I3_OR_CI = I3_IS_CI ? CI : I3;
	SB_CARRY carry (
		.I0(A),
		.I1(B),
		.CI(CI),
		.CO(CO)
	);
	SB_LUT4 #(
		.LUT_INIT(LUT)
	) adder (
		.I0(I0),
		.I1(A),
		.I2(B),
		.I3(I3_OR_CI),
		.O(O)
	);
\`ifdef ICE40_HX
	specify
		// https://github.com/YosysHQ/icestorm/blob/be0bca0230d6fe1102e0a360b953fbb0d273a39f/icefuzz/timings_hx1k.txt#L79
		(CI => CO) = (126, 105);
		// https://github.com/YosysHQ/icestorm/blob/be0bca0230d6fe1102e0a360b953fbb0d273a39f/icefuzz/timings_hx1k.txt#L80
		(I0 => O) = (449, 386);
		// https://github.com/YosysHQ/icestorm/blob/be0bca0230d6fe1102e0a360b953fbb0d273a39f/icefuzz/timings_hx1k.txt#L82
		(A => CO) = (259, 245);
		// https://github.com/YosysHQ/icestorm/blob/be0bca0230d6fe1102e0a360b953fbb0d273a39f/icefuzz/timings_hx1k.txt#L83
		(A => O) = (400, 379);
		// https://github.com/YosysHQ/icestorm/blob/be0bca0230d6fe1102e0a360b953fbb0d273a39f/icefuzz/timings_hx1k.txt#L85
		(B => CO) = (231, 133);
		// https://github.com/YosysHQ/icestorm/blob/be0bca0230d6fe1102e0a360b953fbb0d273a39f/icefuzz/timings_hx1k.txt#L86
		(B => O) = (379, 351);
		// https://github.com/YosysHQ/icestorm/blob/be0bca0230d6fe1102e0a360b953fbb0d273a39f/icefuzz/timings_hx1k.txt#L88
		(I3 => O) = (316, 288);
		(CI => O) = (316, 288);
	endspecify
\`endif
\`ifdef ICE40_LP
	specify
		// https://github.com/YosysHQ/icestorm/blob/be0bca0230d6fe1102e0a360b953fbb0d273a39f/icefuzz/timings_lp1k.txt#L79
		(CI => CO) = (186, 155);
		// https://github.com/YosysHQ/icestorm/blob/be0bca0230d6fe1102e0a360b953fbb0d273a39f/icefuzz/timings_lp1k.txt#L80
		(I0 => O) = (662, 569);
		// https://github.com/YosysHQ/icestorm/blob/be0bca0230d6fe1102e0a360b953fbb0d273a39f/icefuzz/timings_lp1k.txt#L82
		(A => CO) = (382, 362);
		// https://github.com/YosysHQ/icestorm/blob/be0bca0230d6fe1102e0a360b953fbb0d273a39f/icefuzz/timings_lp1k.txt#L83
		(A => O) = (589, 558);
		// https://github.com/YosysHQ/icestorm/blob/be0bca0230d6fe1102e0a360b953fbb0d273a39f/icefuzz/timings_lp1k.txt#L85
		(B => CO) = (341, 196);
		// https://github.com/YosysHQ/icestorm/blob/be0bca0230d6fe1102e0a360b953fbb0d273a39f/icefuzz/timings_lp1k.txt#L86
		(B => O) = (558, 517);
		// https://github.com/YosysHQ/icestorm/blob/be0bca0230d6fe1102e0a360b953fbb0d273a39f/icefuzz/timings_lp1k.txt#L88
		(I3 => O) = (465, 423);
		(CI => O) = (465, 423);
	endspecify
\`endif
\`ifdef ICE40_U
	specify
		// https://github.com/YosysHQ/icestorm/blob/be0bca0230d6fe1102e0a360b953fbb0d273a39f/icefuzz/timings_up5k.txt#L91
		(CI => CO) = (278, 278);
		// https://github.com/YosysHQ/icestorm/blob/be0bca0230d6fe1102e0a360b953fbb0d273a39f/icefuzz/timings_up5k.txt#L92
		(I0 => O) = (1245, 1285);
		// https://github.com/YosysHQ/icestorm/blob/be0bca0230d6fe1102e0a360b953fbb0d273a39f/icefuzz/timings_up5k.txt#L94
		(A => CO) = (675, 662);
		// https://github.com/YosysHQ/icestorm/blob/be0bca0230d6fe1102e0a360b953fbb0d273a39f/icefuzz/timings_up5k.txt#L95
		(A => O) = (1179, 1232);
		// https://github.com/YosysHQ/icestorm/blob/be0bca0230d6fe1102e0a360b953fbb0d273a39f/icefuzz/timings_up5k.txt#L97
		(B => CO) = (609, 358);
		// https://github.com/YosysHQ/icestorm/blob/be0bca0230d6fe1102e0a360b953fbb0d273a39f/icefuzz/timings_up5k.txt#L98
		(B => O) = (1179, 1205);
		// https://github.com/YosysHQ/icestorm/blob/be0bca0230d6fe1102e0a360b953fbb0d273a39f/icefuzz/timings_up5k.txt#L100
		(I3 => O) = (861, 874);
		(CI => O) = (861, 874);
	endspecify
\`endif
endmodule
`,"arith_map.v":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

(* techmap_celltype = "$alu" *)
module _80_ice40_alu (A, B, CI, BI, X, Y, CO);
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;
	parameter A_WIDTH = 1;
	parameter B_WIDTH = 1;
	parameter Y_WIDTH = 1;

	(* force_downto *)
	input [A_WIDTH-1:0] A;
	(* force_downto *)
	input [B_WIDTH-1:0] B;
	(* force_downto *)
	output [Y_WIDTH-1:0] X, Y;

	input CI, BI;
	(* force_downto *)
	output [Y_WIDTH-1:0] CO;

	wire _TECHMAP_FAIL_ = Y_WIDTH <= 2;

	(* force_downto *)
	wire [Y_WIDTH-1:0] A_buf, B_buf;
	\\$pos #(.A_SIGNED(A_SIGNED), .A_WIDTH(A_WIDTH), .Y_WIDTH(Y_WIDTH)) A_conv (.A(A), .Y(A_buf));
	\\$pos #(.A_SIGNED(B_SIGNED), .A_WIDTH(B_WIDTH), .Y_WIDTH(Y_WIDTH)) B_conv (.A(B), .Y(B_buf));

	(* force_downto *)
	wire [Y_WIDTH-1:0] AA = A_buf;
	(* force_downto *)
	wire [Y_WIDTH-1:0] BB = BI ? ~B_buf : B_buf;
	(* force_downto *)
	wire [Y_WIDTH-1:0] C = {CO, CI};

	genvar i;
	generate for (i = 0; i < Y_WIDTH; i = i + 1) begin:slice
		\\$__ICE40_CARRY_WRAPPER #(
			//    A[0]: 1010 1010 1010 1010
			//    A[1]: 1100 1100 1100 1100
			//    A[2]: 1111 0000 1111 0000
			//    A[3]: 1111 1111 0000 0000
			.LUT(16'b 0110_1001_1001_0110),
			.I3_IS_CI(1'b1)
		) carry (
			.A(AA[i]),
			.B(BB[i]),
			.CI(C[i]),
			.I0(1'b0),
			.I3(1'bx),
			.CO(CO[i]),
			.O(Y[i])
		);
	end endgenerate

	assign X = AA ^ BB;
endmodule

`,"brams.txt":`ram block $__ICE40_RAM4K_ {
	abits 11;
	widths 2 4 8 16 per_port;
	cost 64;
	option "HAS_BE" 1 {
		byte 1;
	}
	init any;
	port sw "W" {
		option "HAS_BE" 0 {
			width 2 4 8;
		}
		option "HAS_BE" 1 {
			width 16;
			wrbe_separate;
		}
		clock anyedge;
	}
	port sr "R" {
		clock anyedge;
		rden;
	}
}
`,"brams_map.v":`module $__ICE40_RAM4K_ (...);

parameter INIT = 0;
parameter OPTION_HAS_BE = 1;
parameter PORT_R_WIDTH = 16;
parameter PORT_W_WIDTH = 16;
parameter PORT_W_WR_BE_WIDTH = 16;
parameter PORT_R_CLK_POL = 1;
parameter PORT_W_CLK_POL = 1;

input PORT_R_CLK;
input PORT_R_RD_EN;
input [10:0] PORT_R_ADDR;
output [PORT_R_WIDTH-1:0] PORT_R_RD_DATA;

input PORT_W_CLK;
input PORT_W_WR_EN;
input [15:0] PORT_W_WR_BE;
input [10:0] PORT_W_ADDR;
input [PORT_W_WIDTH-1:0] PORT_W_WR_DATA;

wire [15:0] RDATA;
wire [15:0] WDATA;
wire [15:0] MASK;
wire [10:0] RADDR = {PORT_R_ADDR[0], PORT_R_ADDR[1], PORT_R_ADDR[2], PORT_R_ADDR[10:3]};
wire [10:0] WADDR = {PORT_W_ADDR[0], PORT_W_ADDR[1], PORT_W_ADDR[2], PORT_W_ADDR[10:3]};

function [1:0] mode;
	input integer width;
	case (width)
	16: mode = 0;
	8: mode = 1;
	4: mode = 2;
	2: mode = 3;
	endcase
endfunction

function [255:0] slice_init;
	input [3:0] idx;
	integer i;
	reg [7:0] ri;
	reg [11:0] a;
	for (i = 0; i < 256; i = i + 1) begin
		ri = i;
		a = {idx, ri[7:4], ri[0], ri[1], ri[2], ri[3]};
		slice_init[i] = INIT[a];
	end
endfunction

\`define INSTANCE(type, rclk, wclk) \\
	type #( \\
		.INIT_0(slice_init(0)), \\
		.INIT_1(slice_init(1)), \\
		.INIT_2(slice_init(2)), \\
		.INIT_3(slice_init(3)), \\
		.INIT_4(slice_init(4)), \\
		.INIT_5(slice_init(5)), \\
		.INIT_6(slice_init(6)), \\
		.INIT_7(slice_init(7)), \\
		.INIT_8(slice_init(8)), \\
		.INIT_9(slice_init(9)), \\
		.INIT_A(slice_init(10)), \\
		.INIT_B(slice_init(11)), \\
		.INIT_C(slice_init(12)), \\
		.INIT_D(slice_init(13)), \\
		.INIT_E(slice_init(14)), \\
		.INIT_F(slice_init(15)), \\
		.READ_MODE(mode(PORT_R_WIDTH)), \\
		.WRITE_MODE(mode(PORT_W_WIDTH)) \\
	) _TECHMAP_REPLACE_ ( \\
		.RDATA(RDATA), \\
		.rclk(PORT_R_CLK), \\
		.RCLKE(PORT_R_RD_EN), \\
		.RE(1'b1), \\
		.RADDR(RADDR), \\
		.WDATA(WDATA), \\
		.wclk(PORT_W_CLK), \\
		.WCLKE(PORT_W_WR_EN), \\
		.WE(1'b1), \\
		.WADDR(WADDR), \\
		.MASK(MASK), \\
	);

generate

case(PORT_R_WIDTH)
	2: begin
		assign PORT_R_RD_DATA = {
			RDATA[11],
			RDATA[3]
		};
	end
	4: begin
		assign PORT_R_RD_DATA = {
			RDATA[13],
			RDATA[5],
			RDATA[9],
			RDATA[1]
		};
	end
	8: begin
		assign PORT_R_RD_DATA = {
			RDATA[14],
			RDATA[6],
			RDATA[10],
			RDATA[2],
			RDATA[12],
			RDATA[4],
			RDATA[8],
			RDATA[0]
		};
	end
	16: begin
		assign PORT_R_RD_DATA = {
			RDATA[15],
			RDATA[7],
			RDATA[11],
			RDATA[3],
			RDATA[13],
			RDATA[5],
			RDATA[9],
			RDATA[1],
			RDATA[14],
			RDATA[6],
			RDATA[10],
			RDATA[2],
			RDATA[12],
			RDATA[4],
			RDATA[8],
			RDATA[0]
		};
	end
endcase

case(PORT_W_WIDTH)
	2: begin
		assign {
			WDATA[11],
			WDATA[3]
		} = PORT_W_WR_DATA;
	end
	4: begin
		assign {
			WDATA[13],
			WDATA[5],
			WDATA[9],
			WDATA[1]
		} = PORT_W_WR_DATA;
	end
	8: begin
		assign {
			WDATA[14],
			WDATA[6],
			WDATA[10],
			WDATA[2],
			WDATA[12],
			WDATA[4],
			WDATA[8],
			WDATA[0]
		} = PORT_W_WR_DATA;
	end
	16: begin
		assign WDATA = {
			PORT_W_WR_DATA[15],
			PORT_W_WR_DATA[7],
			PORT_W_WR_DATA[11],
			PORT_W_WR_DATA[3],
			PORT_W_WR_DATA[13],
			PORT_W_WR_DATA[5],
			PORT_W_WR_DATA[9],
			PORT_W_WR_DATA[1],
			PORT_W_WR_DATA[14],
			PORT_W_WR_DATA[6],
			PORT_W_WR_DATA[10],
			PORT_W_WR_DATA[2],
			PORT_W_WR_DATA[12],
			PORT_W_WR_DATA[4],
			PORT_W_WR_DATA[8],
			PORT_W_WR_DATA[0]
		};
		assign MASK = ~{
			PORT_W_WR_BE[15],
			PORT_W_WR_BE[7],
			PORT_W_WR_BE[11],
			PORT_W_WR_BE[3],
			PORT_W_WR_BE[13],
			PORT_W_WR_BE[5],
			PORT_W_WR_BE[9],
			PORT_W_WR_BE[1],
			PORT_W_WR_BE[14],
			PORT_W_WR_BE[6],
			PORT_W_WR_BE[10],
			PORT_W_WR_BE[2],
			PORT_W_WR_BE[12],
			PORT_W_WR_BE[4],
			PORT_W_WR_BE[8],
			PORT_W_WR_BE[0]
		};
	end
endcase

if (PORT_R_CLK_POL) begin
	if (PORT_W_CLK_POL) begin
		\`INSTANCE(SB_RAM40_4K, RCLK, WCLK)
	end else begin
		\`INSTANCE(SB_RAM40_4KNW, RCLK, WCLKN)
	end
end else begin
	if (PORT_W_CLK_POL) begin
		\`INSTANCE(SB_RAM40_4KNR, RCLKN, WCLK)
	end else begin
		\`INSTANCE(SB_RAM40_4KNRNW, RCLKN, WCLKN)
	end
end

endgenerate

endmodule
`,"cells_map.v":`module \\$lut (A, Y);
  parameter WIDTH = 0;
  parameter LUT = 0;

  (* force_downto *)
  input [WIDTH-1:0] A;
  output Y;

  generate
    if (WIDTH == 1) begin
      localparam [15:0] INIT = {{8{LUT[1]}}, {8{LUT[0]}}};
      SB_LUT4 #(.LUT_INIT(INIT)) _TECHMAP_REPLACE_ (.O(Y),
        .I0(1'b0), .I1(1'b0), .I2(1'b0), .I3(A[0]));
    end else
    if (WIDTH == 2) begin
      localparam [15:0] INIT = {{4{LUT[3]}}, {4{LUT[2]}}, {4{LUT[1]}}, {4{LUT[0]}}};
      SB_LUT4 #(.LUT_INIT(INIT)) _TECHMAP_REPLACE_ (.O(Y),
        .I0(1'b0), .I1(1'b0), .I2(A[0]), .I3(A[1]));
    end else
    if (WIDTH == 3) begin
      localparam [15:0] INIT = {{2{LUT[7]}}, {2{LUT[6]}}, {2{LUT[5]}}, {2{LUT[4]}}, {2{LUT[3]}}, {2{LUT[2]}}, {2{LUT[1]}}, {2{LUT[0]}}};
      SB_LUT4 #(.LUT_INIT(INIT)) _TECHMAP_REPLACE_ (.O(Y),
        .I0(1'b0), .I1(A[0]), .I2(A[1]), .I3(A[2]));
    end else
    if (WIDTH == 4) begin
      SB_LUT4 #(.LUT_INIT(LUT)) _TECHMAP_REPLACE_ (.O(Y),
        .I0(A[0]), .I1(A[1]), .I2(A[2]), .I3(A[3]));
    end else begin
      wire _TECHMAP_FAIL_ = 1;
    end
  endgenerate
endmodule
`,"cells_sim.v":new URL("./cells_sim-15f559e1.v?hash=15f559e1",import.meta.url),"dsp_map.v":`module \\$__MUL16X16 (input [15:0] A, input [15:0] B, output [31:0] Y);
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;
	parameter A_WIDTH = 0;
	parameter B_WIDTH = 0;
	parameter Y_WIDTH = 0;

	SB_MAC16 #(
		.NEG_TRIGGER(1'b0),
		.C_REG(1'b0),
		.A_REG(1'b0),
		.B_REG(1'b0),
		.D_REG(1'b0),
		.TOP_8x8_MULT_REG(1'b0),
		.BOT_8x8_MULT_REG(1'b0),
		.PIPELINE_16x16_MULT_REG1(1'b0),
		.PIPELINE_16x16_MULT_REG2(1'b0),
		.TOPOUTPUT_SELECT(2'b11),
		.TOPADDSUB_LOWERINPUT(2'b0),
		.TOPADDSUB_UPPERINPUT(1'b0),
		.TOPADDSUB_CARRYSELECT(2'b0),
		.BOTOUTPUT_SELECT(2'b11),
		.BOTADDSUB_LOWERINPUT(2'b0),
		.BOTADDSUB_UPPERINPUT(1'b0),
		.BOTADDSUB_CARRYSELECT(2'b0),
		.MODE_8x8(1'b0),
		.A_SIGNED(A_SIGNED),
		.B_SIGNED(B_SIGNED)
	) _TECHMAP_REPLACE_ (
		.A(A),
		.B(B),
		.O(Y),
	);
endmodule
`,"ff_map.v":`module  \\$_DFF_N_ (input D, C, output Q); SB_DFFN _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C)); wire _TECHMAP_REMOVEINIT_Q_ = 1; endmodule
module  \\$_DFF_P_ (input D, C, output Q); SB_DFF  _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C)); wire _TECHMAP_REMOVEINIT_Q_ = 1; endmodule

module  \\$_DFFE_NP_ (input D, C, E, output Q); SB_DFFNE _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .E(E)); wire _TECHMAP_REMOVEINIT_Q_ = 1; endmodule
module  \\$_DFFE_PP_ (input D, C, E, output Q); SB_DFFE  _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .E(E)); wire _TECHMAP_REMOVEINIT_Q_ = 1; endmodule

module  \\$_DFF_NP0_ (input D, C, R, output Q); SB_DFFNR _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .R(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1; endmodule
module  \\$_DFF_NP1_ (input D, C, R, output Q); SB_DFFNS _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .S(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1; endmodule
module  \\$_DFF_PP0_ (input D, C, R, output Q); SB_DFFR  _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .R(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1; endmodule
module  \\$_DFF_PP1_ (input D, C, R, output Q); SB_DFFS  _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .S(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1; endmodule

module  \\$_DFFE_NP0P_ (input D, C, E, R, output Q); SB_DFFNER _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .E(E), .R(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1; endmodule
module  \\$_DFFE_NP1P_ (input D, C, E, R, output Q); SB_DFFNES _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .E(E), .S(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1; endmodule
module  \\$_DFFE_PP0P_ (input D, C, E, R, output Q); SB_DFFER  _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .E(E), .R(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1; endmodule
module  \\$_DFFE_PP1P_ (input D, C, E, R, output Q); SB_DFFES  _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .E(E), .S(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1; endmodule

module  \\$_SDFF_NP0_ (input D, C, R, output Q); SB_DFFNSR _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .R(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1; endmodule
module  \\$_SDFF_NP1_ (input D, C, R, output Q); SB_DFFNSS _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .S(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1; endmodule
module  \\$_SDFF_PP0_ (input D, C, R, output Q); SB_DFFSR  _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .R(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1; endmodule
module  \\$_SDFF_PP1_ (input D, C, R, output Q); SB_DFFSS  _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .S(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1; endmodule

module  \\$_SDFFCE_NP0P_ (input D, C, E, R, output Q); SB_DFFNESR _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .E(E), .R(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1; endmodule
module  \\$_SDFFCE_NP1P_ (input D, C, E, R, output Q); SB_DFFNESS _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .E(E), .S(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1; endmodule
module  \\$_SDFFCE_PP0P_ (input D, C, E, R, output Q); SB_DFFESR  _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .E(E), .R(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1; endmodule
module  \\$_SDFFCE_PP1P_ (input D, C, E, R, output Q); SB_DFFESS  _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .E(E), .S(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1; endmodule
`,"latches_map.v":`module \\$_DLATCH_N_ (E, D, Q);
  wire [1023:0] _TECHMAP_DO_ = "simplemap; opt";
  input E, D;
  output Q = !E ? D : Q;
endmodule

module \\$_DLATCH_P_ (E, D, Q);
  wire [1023:0] _TECHMAP_DO_ = "simplemap; opt";
  input E, D;
  output Q = E ? D : Q;
endmodule
`,"spram.txt":`ram huge $__ICE40_SPRAM_ {
	abits 14;
	width 16;
	cost 2048;
	byte 4;
	port srsw "A" {
		clock posedge;
		clken;
		wrbe_separate;
		rdwr no_change;
	}
}
`,"spram_map.v":`module $__ICE40_SPRAM_ (...);

input PORT_A_CLK;
input PORT_A_CLK_EN;
input PORT_A_WR_EN;
input [3:0] PORT_A_WR_BE;
input [13:0] PORT_A_ADDR;
input [15:0] PORT_A_WR_DATA;
output [15:0] PORT_A_RD_DATA;

SB_SPRAM256KA _TECHMAP_REPLACE_ (
	.ADDRESS(PORT_A_ADDR),
	.DATAIN(PORT_A_WR_DATA),
	.MASKWREN(PORT_A_WR_BE),
	.WREN(PORT_A_WR_EN),
	.CHIPSELECT(PORT_A_CLK_EN),
	.CLOCK(PORT_A_CLK),
	.STANDBY(1'b0),
	.SLEEP(1'b0),
	.POWEROFF(1'b1),
	.DATAOUT(PORT_A_RD_DATA),
);

endmodule
`},include:{backends:{cxxrtl:{runtime:{cxxrtl:{capi:{"cxxrtl_capi.cc":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2020  whitequark <whitequark@whitequark.org>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

// This file is a part of the CXXRTL C API. It should be used together with \`cxxrtl/capi/cxxrtl_capi.h\`.

#include <cxxrtl/capi/cxxrtl_capi.h>
#include <cxxrtl/cxxrtl.h>

struct _cxxrtl_handle {
	std::unique_ptr<cxxrtl::module> module;
	cxxrtl::debug_items objects;
};

// Private function for use by other units of the C API.
const cxxrtl::debug_items &cxxrtl_debug_items_from_handle(cxxrtl_handle handle) {
	return handle->objects;
}

cxxrtl_handle cxxrtl_create(cxxrtl_toplevel design) {
	return cxxrtl_create_at(design, "");
}

cxxrtl_handle cxxrtl_create_at(cxxrtl_toplevel design, const char *top_path_) {
	std::string top_path = top_path_;
	if (!top_path.empty()) {
		// module::debug_info() accepts either an empty path, or a path ending in space to simplify
		// the logic in generated code. While this is sketchy at best to expose in the C++ API, this
		// would be a lot worse in the C API, so don't expose it here.
		assert(top_path.back() != ' ');
		top_path += ' ';
	}

	cxxrtl_handle handle = new _cxxrtl_handle;
	handle->module = std::move(design->module);
	handle->module->debug_info(handle->objects, top_path);
	delete design;
	return handle;
}

void cxxrtl_destroy(cxxrtl_handle handle) {
	delete handle;
}

void cxxrtl_reset(cxxrtl_handle handle) {
	handle->module->reset();
}

int cxxrtl_eval(cxxrtl_handle handle) {
	return handle->module->eval();
}

int cxxrtl_commit(cxxrtl_handle handle) {
	return handle->module->commit();
}

size_t cxxrtl_step(cxxrtl_handle handle) {
	return handle->module->step();
}

struct cxxrtl_object *cxxrtl_get_parts(cxxrtl_handle handle, const char *name, size_t *parts) {
	auto it = handle->objects.table.find(name);
	if (it == handle->objects.table.end())
		return nullptr;
	*parts = it->second.size();
	return static_cast<cxxrtl_object*>(&it->second[0]);
}

void cxxrtl_enum(cxxrtl_handle handle, void *data,
                 void (*callback)(void *data, const char *name,
                                  cxxrtl_object *object, size_t parts)) {
	for (auto &it : handle->objects.table)
		callback(data, it.first.c_str(), static_cast<cxxrtl_object*>(&it.second[0]), it.second.size());
}

void cxxrtl_outline_eval(cxxrtl_outline outline) {
	outline->eval();
}

int cxxrtl_attr_type(cxxrtl_attr_set attrs_, const char *name) {
	auto attrs = (cxxrtl::metadata_map*)attrs_;
	if (!attrs->count(name))
		return CXXRTL_ATTR_NONE;
	switch (attrs->at(name).value_type) {
		case cxxrtl::metadata::UINT:
			return CXXRTL_ATTR_UNSIGNED_INT;
		case cxxrtl::metadata::SINT:
			return CXXRTL_ATTR_SIGNED_INT;
		case cxxrtl::metadata::STRING:
			return CXXRTL_ATTR_STRING;
		case cxxrtl::metadata::DOUBLE:
			return CXXRTL_ATTR_DOUBLE;
		default:
			// Present unsupported attribute type the same way as no attribute at all.
			return CXXRTL_ATTR_NONE;
	}
}

uint64_t cxxrtl_attr_get_unsigned_int(cxxrtl_attr_set attrs_, const char *name) {
	auto &attrs = *(cxxrtl::metadata_map*)attrs_;
	assert(attrs.count(name) && attrs.at(name).value_type == cxxrtl::metadata::UINT);
	return attrs[name].as_uint();
}

int64_t cxxrtl_attr_get_signed_int(cxxrtl_attr_set attrs_, const char *name) {
	auto &attrs = *(cxxrtl::metadata_map*)attrs_;
	assert(attrs.count(name) && attrs.at(name).value_type == cxxrtl::metadata::SINT);
	return attrs[name].as_sint();
}

const char *cxxrtl_attr_get_string(cxxrtl_attr_set attrs_, const char *name) {
	auto &attrs = *(cxxrtl::metadata_map*)attrs_;
	assert(attrs.count(name) && attrs.at(name).value_type == cxxrtl::metadata::STRING);
	return attrs[name].as_string().c_str();
}

double cxxrtl_attr_get_double(cxxrtl_attr_set attrs_, const char *name) {
	auto &attrs = *(cxxrtl::metadata_map*)attrs_;
	assert(attrs.count(name) && attrs.at(name).value_type == cxxrtl::metadata::DOUBLE);
	return attrs[name].as_double();
}
`,"cxxrtl_capi.h":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2020  whitequark <whitequark@whitequark.org>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef CXXRTL_CAPI_H
#define CXXRTL_CAPI_H

// This file is a part of the CXXRTL C API. It should be used together with \`cxxrtl_capi.cc\`.
//
// The CXXRTL C API makes it possible to drive CXXRTL designs using C or any other language that
// supports the C ABI, for example, Python. It does not provide a way to implement black boxes.

#include <stddef.h>
#include <stdint.h>
#include <assert.h>

#ifdef __cplusplus
extern "C" {
#endif

// Opaque reference to a design toplevel.
//
// A design toplevel can only be used to create a design handle.
typedef struct _cxxrtl_toplevel *cxxrtl_toplevel;

// The constructor for a design toplevel is provided as a part of generated code for that design.
// Its prototype matches:
//
// cxxrtl_toplevel <design-name>_create();

// Opaque reference to a design handle.
//
// A design handle is required by all operations in the C API.
typedef struct _cxxrtl_handle *cxxrtl_handle;

// Create a design handle from a design toplevel.
//
// The \`design\` is consumed by this operation and cannot be used afterwards.
cxxrtl_handle cxxrtl_create(cxxrtl_toplevel design);

// Create a design handle at a given hierarchy position from a design toplevel.
//
// This operation is similar to \`cxxrtl_create\`, except the full hierarchical name of every object
// is prepended with \`top_path\`.
cxxrtl_handle cxxrtl_create_at(cxxrtl_toplevel design, const char *top_path);

// Release all resources used by a design and its handle.
void cxxrtl_destroy(cxxrtl_handle handle);

// Reinitialize the design, replacing the internal state with the reset values while preserving
// black boxes.
//
// This operation is essentially equivalent to a power-on reset. Values, wires, and memories are
// returned to their reset state while preserving the state of black boxes and keeping all of
// the interior pointers obtained with e.g. \`cxxrtl_get\` valid.
void cxxrtl_reset(cxxrtl_handle handle);

// Evaluate the design, propagating changes on inputs to the \`next\` value of internal state and
// output wires.
//
// Returns 1 if the design is known to immediately converge, 0 otherwise.
int cxxrtl_eval(cxxrtl_handle handle);

// Commit the design, replacing the \`curr\` value of internal state and output wires with the \`next\`
// value.
//
// Return 1 if any of the \`curr\` values were updated, 0 otherwise.
int cxxrtl_commit(cxxrtl_handle handle);

// Simulate the design to a fixed point.
//
// Returns the number of delta cycles.
size_t cxxrtl_step(cxxrtl_handle handle);

// Type of a simulated object.
//
// The type of a simulated object indicates the way it is stored and the operations that are legal
// to perform on it (i.e. won't crash the simulation). It says very little about object semantics,
// which is specified through flags.
enum cxxrtl_type {
	// Values correspond to singly buffered netlist nodes, i.e. nodes driven exclusively by
	// combinatorial cells, or toplevel input nodes.
	//
	// Values can be inspected via the \`curr\` pointer. If the \`next\` pointer is NULL, the value is
	// driven by a constant and can never be modified. Otherwise, the value can be modified through
	// the \`next\` pointer (which is equal to \`curr\` if not NULL). Note that changes to the bits
	// driven by combinatorial cells will be ignored.
	//
	// Values always have depth 1.
	CXXRTL_VALUE = 0,

	// Wires correspond to doubly buffered netlist nodes, i.e. nodes driven, at least in part, by
	// storage cells, or by combinatorial cells that are a part of a feedback path. They are also
	// present in non-optimized builds.
	//
	// Wires can be inspected via the \`curr\` pointer and modified via the \`next\` pointer (which are
	// distinct for wires). Note that changes to the bits driven by combinatorial cells will be
	// ignored.
	//
	// Wires always have depth 1.
	CXXRTL_WIRE = 1,

	// Memories correspond to memory cells.
	//
	// Memories can be inspected and modified via the \`curr\` pointer. Due to a limitation of this
	// API, memories cannot yet be modified in a guaranteed race-free way, and the \`next\` pointer is
	// always NULL.
	CXXRTL_MEMORY = 2,

	// Aliases correspond to netlist nodes driven by another node such that their value is always
	// exactly equal.
	//
	// Aliases can be inspected via the \`curr\` pointer. They cannot be modified, and the \`next\`
	// pointer is always NULL.
	CXXRTL_ALIAS = 3,

	// Outlines correspond to netlist nodes that were optimized in a way that makes them inaccessible
	// outside of a module's \`eval()\` function. At the highest debug information level, every inlined
	// node has a corresponding outline object.
	//
	// Outlines can be inspected via the \`curr\` pointer and can never be modified; the \`next\` pointer
	// is always NULL. Unlike all other objects, the bits of an outline object are meaningful only
	// after a call to \`cxxrtl_outline_eval\` and until any subsequent modification to the netlist.
	// Observing this requirement is the responsibility of the caller; it is not enforced.
	//
	// Outlines always correspond to combinatorial netlist nodes that are not ports.
	CXXRTL_OUTLINE = 4,

	// More object types may be added in the future, but the existing ones will never change.
};

// Flags of a simulated object.
//
// The flags of a simulated object indicate its role in the netlist:
//  * The flags \`CXXRTL_INPUT\` and \`CXXRTL_OUTPUT\` designate module ports.
//  * The flags \`CXXRTL_DRIVEN_SYNC\`, \`CXXRTL_DRIVEN_COMB\`, and \`CXXRTL_UNDRIVEN\` specify
//    the semantics of node state. An object with several of these flags set has different bits
//    follow different semantics.
enum cxxrtl_flag {
	// Node is a module input port.
	//
	// This flag can be set on objects of type \`CXXRTL_VALUE\` and \`CXXRTL_WIRE\`. It may be combined
	// with \`CXXRTL_OUTPUT\`, as well as other flags.
	CXXRTL_INPUT = 1 << 0,

	// Node is a module output port.
	//
	// This flag can be set on objects of type \`CXXRTL_WIRE\`. It may be combined with \`CXXRTL_INPUT\`,
	// as well as other flags.
	CXXRTL_OUTPUT = 1 << 1,

	// Node is a module inout port.
	//
	// This flag can be set on objects of type \`CXXRTL_WIRE\`. It may be combined with other flags.
	CXXRTL_INOUT = (CXXRTL_INPUT|CXXRTL_OUTPUT),

	// Node has bits that are driven by a storage cell.
	//
	// This flag can be set on objects of type \`CXXRTL_WIRE\`. It may be combined with
	// \`CXXRTL_DRIVEN_COMB\` and \`CXXRTL_UNDRIVEN\`, as well as other flags.
	//
	// This flag is set on wires that have bits connected directly to the output of a flip-flop or
	// a latch, and hold its state. Many \`CXXRTL_WIRE\` objects may not have the \`CXXRTL_DRIVEN_SYNC\`
	// flag set; for example, output ports and feedback wires generally won't. Writing to the \`next\`
	// pointer of these wires updates stored state, and for designs without combinatorial loops,
	// capturing the value from every of these wires through the \`curr\` pointer creates a complete
	// snapshot of the design state.
	CXXRTL_DRIVEN_SYNC = 1 << 2,

	// Node has bits that are driven by a combinatorial cell or another node.
	//
	// This flag can be set on objects of type \`CXXRTL_VALUE\`, \`CXXRTL_WIRE\`, and \`CXXRTL_OUTLINE\`.
	// It may be combined with \`CXXRTL_DRIVEN_SYNC\` and \`CXXRTL_UNDRIVEN\`, as well as other flags.
	//
	// This flag is set on objects that have bits connected to the output of a combinatorial cell,
	// or directly to another node. For designs without combinatorial loops, writing to such bits
	// through the \`next\` pointer (if it is not NULL) has no effect.
	CXXRTL_DRIVEN_COMB = 1 << 3,

	// Node has bits that are not driven.
	//
	// This flag can be set on objects of type \`CXXRTL_VALUE\` and \`CXXRTL_WIRE\`. It may be combined
	// with \`CXXRTL_DRIVEN_SYNC\` and \`CXXRTL_DRIVEN_COMB\`, as well as other flags.
	//
	// This flag is set on objects that have bits not driven by an output of any cell or by another
	// node, such as inputs and dangling wires.
	CXXRTL_UNDRIVEN = 1 << 4,

	// More object flags may be added in the future, but the existing ones will never change.
};

// Description of a simulated object.
//
// The \`curr\` and \`next\` arrays can be accessed directly to inspect and, if applicable, modify
// the bits stored in the object.
struct cxxrtl_object {
	// Type of the object.
	//
	// All objects have the same memory layout determined by \`width\` and \`depth\`, but the type
	// determines all other properties of the object.
	uint32_t type; // actually \`enum cxxrtl_type\`

	// Flags of the object.
	uint32_t flags; // actually bit mask of \`enum cxxrtl_flags\`

	// Width of the object in bits.
	size_t width;

	// Index of the least significant bit.
	size_t lsb_at;

	// Depth of the object. Only meaningful for memories; for other objects, always 1.
	size_t depth;

	// Index of the first word. Only meaningful for memories; for other objects, always 0;
	size_t zero_at;

	// Bits stored in the object, as 32-bit chunks, least significant bits first.
	//
	// The width is rounded up to a multiple of 32; the padding bits are always set to 0 by
	// the simulation code, and must be always written as 0 when modified by user code.
	// In memories, every element is stored contiguously. Therefore, the total number of chunks
	// in any object is \`((width + 31) / 32) * depth\`.
	//
	// To allow the simulation to be partitioned into multiple independent units communicating
	// through wires, the bits are double buffered. To avoid race conditions, user code should
	// always read from \`curr\` and write to \`next\`. The \`curr\` pointer is always valid; for objects
	// that cannot be modified, or cannot be modified in a race-free way, \`next\` is NULL.
	//
	// In case where \`width == 0\`, \`curr\` is a non-NULL pointer unique for the wire. That is,
	// there is a 1-to-1 correspondence between simulation objects and \`curr\` pointers, regardless
	// of whether they have storage or not. (Aliases' \`curr\` pointer equals that of some other
	// simulated object.)
	uint32_t *curr;
	uint32_t *next;

	// Opaque reference to an outline. Only meaningful for outline objects.
	//
	// See the documentation of \`cxxrtl_outline\` for details. When creating a \`cxxrtl_object\`, set
	// this field to NULL.
	struct _cxxrtl_outline *outline;

	// Opaque reference to an attribute set.
	//
	// See the documentation of \`cxxrtl_attr_set\` for details. When creating a \`cxxrtl_object\`, set
	// this field to NULL.
	//
	// The lifetime of the pointers returned by \`cxxrtl_attr_*\` family of functions is the same as
	// the lifetime of this structure.
	struct _cxxrtl_attr_set *attrs;

	// More description fields may be added in the future, but the existing ones will never change.
};

// Retrieve description of a simulated object.
//
// The \`name\` is the full hierarchical name of the object in the Yosys notation, where public names
// have a \`\\\` prefix and hierarchy levels are separated by single spaces. For example, if
// the top-level module instantiates a module \`foo\`, which in turn contains a wire \`bar\`, the full
// hierarchical name is \`\\foo \\bar\`.
//
// The storage of a single abstract object may be split (usually with the \`splitnets\` pass) into
// many physical parts, all of which correspond to the same hierarchical name. To handle such cases,
// this function returns an array and writes its length to \`parts\`. The array is sorted by \`lsb_at\`.
//
// Returns the object parts if it was found, NULL otherwise. The returned parts are valid until
// the design is destroyed.
struct cxxrtl_object *cxxrtl_get_parts(cxxrtl_handle handle, const char *name, size_t *parts);

// Retrieve description of a single part simulated object.
//
// This function is a shortcut for the most common use of \`cxxrtl_get_parts\`. It asserts that,
// if the object exists, it consists of a single part. If assertions are disabled, it returns NULL
// for multi-part objects.
static inline struct cxxrtl_object *cxxrtl_get(cxxrtl_handle handle, const char *name) {
	size_t parts = 0;
	struct cxxrtl_object *object = cxxrtl_get_parts(handle, name, &parts);
	assert(object == NULL || parts == 1);
	if (object == NULL || parts == 1)
		return object;
	return NULL;
}

// Enumerate simulated objects.
//
// For every object in the simulation, \`callback\` is called with the provided \`data\`, the full
// hierarchical name of the object (see \`cxxrtl_get\` for details), and the object parts.
// The provided \`name\` and \`object\` values are valid until the design is destroyed.
void cxxrtl_enum(cxxrtl_handle handle, void *data,
                 void (*callback)(void *data, const char *name,
                                  struct cxxrtl_object *object, size_t parts));

// Opaque reference to an outline.
//
// An outline is a group of outline objects that are evaluated simultaneously. The identity of
// an outline can be compared to determine whether any two objects belong to the same outline.
typedef struct _cxxrtl_outline *cxxrtl_outline;

// Evaluate an outline.
//
// After evaluating an outline, the bits of every outline object contained in it are consistent
// with the current state of the netlist. In general, any further modification to the netlist
// causes every outline object to become stale, after which the corresponding outline must be
// re-evaluated, otherwise the bits read from that object are meaningless.
void cxxrtl_outline_eval(cxxrtl_outline outline);

// Opaque reference to an attribute set.
//
// An attribute set is a map between attribute names (always strings) and values (which may have
// several different types). To find out the type of an attribute, use \`cxxrtl_attr_type\`, and
// to retrieve the value of an attribute, use \`cxxrtl_attr_as_string\`.
typedef struct _cxxrtl_attr_set *cxxrtl_attr_set;

// Type of an attribute.
enum cxxrtl_attr_type {
	// Attribute is not present.
	CXXRTL_ATTR_NONE = 0,

	// Attribute has an unsigned integer value.
	CXXRTL_ATTR_UNSIGNED_INT = 1,

	// Attribute has an unsigned integer value.
	CXXRTL_ATTR_SIGNED_INT = 2,

	// Attribute has a string value.
	CXXRTL_ATTR_STRING = 3,

	// Attribute has a double precision floating point value.
	CXXRTL_ATTR_DOUBLE = 4,

	// More attribute types may be defined in the future, but the existing values will never change.
};

// Determine the presence and type of an attribute in an attribute set.
//
// This function returns one of the possible \`cxxrtl_attr_type\` values.
int cxxrtl_attr_type(cxxrtl_attr_set attrs, const char *name);

// Retrieve an unsigned integer valued attribute from an attribute set.
//
// This function asserts that \`cxxrtl_attr_type(attrs, name) == CXXRTL_ATTR_UNSIGNED_INT\`.
// If assertions are disabled, returns 0 if the attribute is missing or has an incorrect type.
uint64_t cxxrtl_attr_get_unsigned_int(cxxrtl_attr_set attrs, const char *name);

// Retrieve a signed integer valued attribute from an attribute set.
//
// This function asserts that \`cxxrtl_attr_type(attrs, name) == CXXRTL_ATTR_SIGNED_INT\`.
// If assertions are disabled, returns 0 if the attribute is missing or has an incorrect type.
int64_t cxxrtl_attr_get_signed_int(cxxrtl_attr_set attrs, const char *name);

// Retrieve a string valued attribute from an attribute set. The returned string is zero-terminated.
//
// This function asserts that \`cxxrtl_attr_type(attrs, name) == CXXRTL_ATTR_STRING\`. If assertions
// are disabled, returns NULL if the attribute is missing or has an incorrect type.
const char *cxxrtl_attr_get_string(cxxrtl_attr_set attrs, const char *name);

// Retrieve a double precision floating point valued attribute from an attribute set.
//
// This function asserts that \`cxxrtl_attr_type(attrs, name) == CXXRTL_ATTR_DOUBLE\`. If assertions
// are disabled, returns NULL if the attribute is missing or has an incorrect type.
double cxxrtl_attr_get_double(cxxrtl_attr_set attrs, const char *name);

#ifdef __cplusplus
}
#endif

#endif
`,"cxxrtl_capi_vcd.cc":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2020  whitequark <whitequark@whitequark.org>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

// This file is a part of the CXXRTL C API. It should be used together with \`cxxrtl/capi/cxxrtl_capi_vcd.h\`.

#include <cxxrtl/capi/cxxrtl_capi_vcd.h>
#include <cxxrtl/cxxrtl_vcd.h>

extern const cxxrtl::debug_items &cxxrtl_debug_items_from_handle(cxxrtl_handle handle);

struct _cxxrtl_vcd {
	cxxrtl::vcd_writer writer;
	bool flush = false;
};

cxxrtl_vcd cxxrtl_vcd_create() {
	return new _cxxrtl_vcd;
}

void cxxrtl_vcd_destroy(cxxrtl_vcd vcd) {
	delete vcd;
}

void cxxrtl_vcd_timescale(cxxrtl_vcd vcd, int number, const char *unit) {
	vcd->writer.timescale(number, unit);
}

void cxxrtl_vcd_add(cxxrtl_vcd vcd, const char *name, cxxrtl_object *object) {
	// Note the copy. We don't know whether \`object\` came from a design (in which case it is
	// an instance of \`debug_item\`), or from user code (in which case it is an instance of
	// \`cxxrtl_object\`), so casting the pointer wouldn't be safe.
	vcd->writer.add(name, cxxrtl::debug_item(*object));
}

void cxxrtl_vcd_add_from(cxxrtl_vcd vcd, cxxrtl_handle handle) {
	vcd->writer.add(cxxrtl_debug_items_from_handle(handle));
}

void cxxrtl_vcd_add_from_if(cxxrtl_vcd vcd, cxxrtl_handle handle, void *data,
														int (*filter)(void *data, const char *name,
														              const cxxrtl_object *object)) {
	vcd->writer.add(cxxrtl_debug_items_from_handle(handle),
		[=](const std::string &name, const cxxrtl::debug_item &item) {
			return filter(data, name.c_str(), static_cast<const cxxrtl_object*>(&item));
		});
}

void cxxrtl_vcd_add_from_without_memories(cxxrtl_vcd vcd, cxxrtl_handle handle) {
	vcd->writer.add_without_memories(cxxrtl_debug_items_from_handle(handle));
}

void cxxrtl_vcd_sample(cxxrtl_vcd vcd, uint64_t time) {
	if (vcd->flush) {
		vcd->writer.buffer.clear();
		vcd->flush = false;
	}
	vcd->writer.sample(time);
}

void cxxrtl_vcd_read(cxxrtl_vcd vcd, const char **data, size_t *size) {
	if (vcd->flush) {
		vcd->writer.buffer.clear();
		vcd->flush = false;
	}
	*data = vcd->writer.buffer.c_str();
	*size = vcd->writer.buffer.size();
	vcd->flush = true;
}
`,"cxxrtl_capi_vcd.h":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2020  whitequark <whitequark@whitequark.org>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef CXXRTL_CAPI_VCD_H
#define CXXRTL_CAPI_VCD_H

// This file is a part of the CXXRTL C API. It should be used together with \`cxxrtl_vcd_capi.cc\`.
//
// The CXXRTL C API for VCD writing makes it possible to insert virtual probes into designs and
// dump waveforms to Value Change Dump files.

#include <stddef.h>
#include <stdint.h>

#include <cxxrtl/capi/cxxrtl_capi.h>

#ifdef __cplusplus
extern "C" {
#endif

// Opaque reference to a VCD writer.
typedef struct _cxxrtl_vcd *cxxrtl_vcd;

// Create a VCD writer.
cxxrtl_vcd cxxrtl_vcd_create();

// Release all resources used by a VCD writer.
void cxxrtl_vcd_destroy(cxxrtl_vcd vcd);

// Set VCD timescale.
//
// The \`number\` must be 1, 10, or 100, and the \`unit\` must be one of \`"s"\`, \`"ms"\`, \`"us"\`, \`"ns"\`,
// \`"ps"\`, or \`"fs"\`.
//
// Timescale can only be set before the first call to \`cxxrtl_vcd_sample\`.
void cxxrtl_vcd_timescale(cxxrtl_vcd vcd, int number, const char *unit);

// Schedule a specific CXXRTL object to be sampled.
//
// The \`name\` is a full hierarchical name as described for \`cxxrtl_get\`; it does not need to match
// the original name of \`object\`, if any. The \`object\` must outlive the VCD writer, but there are
// no other requirements; if desired, it can be provided by user code, rather than come from
// a design.
//
// Objects can only be scheduled before the first call to \`cxxrtl_vcd_sample\`.
void cxxrtl_vcd_add(cxxrtl_vcd vcd, const char *name, struct cxxrtl_object *object);

// Schedule all CXXRTL objects in a simulation.
//
// The design \`handle\` must outlive the VCD writer.
//
// Objects can only be scheduled before the first call to \`cxxrtl_vcd_sample\`.
void cxxrtl_vcd_add_from(cxxrtl_vcd vcd, cxxrtl_handle handle);

// Schedule CXXRTL objects in a simulation that match a given predicate.
//
// For every object in the simulation, \`filter\` is called with the provided \`data\`, the full
// hierarchical name of the object (see \`cxxrtl_get\` for details), and the object description.
// The object will be sampled if the predicate returns a non-zero value.
//
// Objects can only be scheduled before the first call to \`cxxrtl_vcd_sample\`.
void cxxrtl_vcd_add_from_if(cxxrtl_vcd vcd, cxxrtl_handle handle, void *data,
                            int (*filter)(void *data, const char *name,
                                          const struct cxxrtl_object *object));

// Schedule all CXXRTL objects in a simulation except for memories.
//
// The design \`handle\` must outlive the VCD writer.
//
// Objects can only be scheduled before the first call to \`cxxrtl_vcd_sample\`.
void cxxrtl_vcd_add_from_without_memories(cxxrtl_vcd vcd, cxxrtl_handle handle);

// Sample all scheduled objects.
//
// First, \`time\` is written to the internal buffer. Second, the values of every signal changed since
// the previous call to \`cxxrtl_vcd_sample\` (all values if this is the first call) are written to
// the internal buffer. The contents of the buffer can be retrieved with \`cxxrtl_vcd_read\`.
void cxxrtl_vcd_sample(cxxrtl_vcd vcd, uint64_t time);

// Retrieve buffered VCD data.
//
// The pointer to the start of the next chunk of VCD data is assigned to \`*data\`, and the length
// of that chunk is assigned to \`*size\`. The pointer to the data is valid until the next call to
// \`cxxrtl_vcd_sample\` or \`cxxrtl_vcd_read\`. Once all of the buffered data has been retrieved,
// this function will always return zero sized chunks.
void cxxrtl_vcd_read(cxxrtl_vcd vcd, const char **data, size_t *size);

#ifdef __cplusplus
}
#endif

#endif
`},"cxxrtl.h":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2019-2020  whitequark <whitequark@whitequark.org>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

// This file is included by the designs generated with \`write_cxxrtl\`. It is not used in Yosys itself.
//
// The CXXRTL support library implements compile time specialized arbitrary width arithmetics, as well as provides
// composite lvalues made out of bit slices and concatenations of lvalues. This allows the \`write_cxxrtl\` pass
// to perform a straightforward translation of RTLIL structures to readable C++, relying on the C++ compiler
// to unwrap the abstraction and generate efficient code.

#ifndef CXXRTL_H
#define CXXRTL_H

#include <cstddef>
#include <cstdint>
#include <cstring>
#include <cassert>
#include <limits>
#include <type_traits>
#include <tuple>
#include <vector>
#include <map>
#include <algorithm>
#include <memory>
#include <functional>
#include <sstream>
#include <iostream>

// \`cxxrtl::debug_item\` has to inherit from \`cxxrtl_object\` to satisfy strict aliasing requirements.
#include <cxxrtl/capi/cxxrtl_capi.h>

#ifndef __has_attribute
#	define __has_attribute(x) 0
#endif

// CXXRTL essentially uses the C++ compiler as a hygienic macro engine that feeds an instruction selector.
// It generates a lot of specialized template functions with relatively large bodies that, when inlined
// into the caller and (for those with loops) unrolled, often expose many new optimization opportunities.
// Because of this, most of the CXXRTL runtime must be always inlined for best performance.
#if __has_attribute(always_inline)
#define CXXRTL_ALWAYS_INLINE inline __attribute__((__always_inline__))
#else
#define CXXRTL_ALWAYS_INLINE inline
#endif
// Conversely, some functions in the generated code are extremely large yet very cold, with both of these
// properties being extreme enough to confuse C++ compilers into spending pathological amounts of time
// on a futile (the code becomes worse) attempt to optimize the least important parts of code.
#if __has_attribute(optnone)
#define CXXRTL_EXTREMELY_COLD __attribute__((__optnone__))
#elif __has_attribute(optimize)
#define CXXRTL_EXTREMELY_COLD __attribute__((__optimize__(0)))
#else
#define CXXRTL_EXTREMELY_COLD
#endif

// CXXRTL uses assert() to check for C++ contract violations (which may result in e.g. undefined behavior
// of the simulation code itself), and CXXRTL_ASSERT to check for RTL contract violations (which may at
// most result in undefined simulation results).
//
// Though by default, CXXRTL_ASSERT() expands to assert(), it may be overridden e.g. when integrating
// the simulation into another process that should survive violating RTL contracts.
#ifndef CXXRTL_ASSERT
#ifndef CXXRTL_NDEBUG
#define CXXRTL_ASSERT(x) assert(x)
#else
#define CXXRTL_ASSERT(x)
#endif
#endif

namespace cxxrtl {

// All arbitrary-width values in CXXRTL are backed by arrays of unsigned integers called chunks. The chunk size
// is the same regardless of the value width to simplify manipulating values via FFI interfaces, e.g. driving
// and introspecting the simulation in Python.
//
// It is practical to use chunk sizes between 32 bits and platform register size because when arithmetics on
// narrower integer types is legalized by the C++ compiler, it inserts code to clear the high bits of the register.
// However, (a) most of our operations do not change those bits in the first place because of invariants that are
// invisible to the compiler, (b) we often operate on non-power-of-2 values and have to clear the high bits anyway.
// Therefore, using relatively wide chunks and clearing the high bits explicitly and only when we know they may be
// clobbered results in simpler generated code.
typedef uint32_t chunk_t;
typedef uint64_t wide_chunk_t;

template<typename T>
struct chunk_traits {
	static_assert(std::is_integral<T>::value && std::is_unsigned<T>::value,
	              "chunk type must be an unsigned integral type");
	using type = T;
	static constexpr size_t bits = std::numeric_limits<T>::digits;
	static constexpr T mask = std::numeric_limits<T>::max();
};

template<class T>
struct expr_base;

template<size_t Bits>
struct value : public expr_base<value<Bits>> {
	static constexpr size_t bits = Bits;

	using chunk = chunk_traits<chunk_t>;
	static constexpr chunk::type msb_mask = (Bits % chunk::bits == 0) ? chunk::mask
		: chunk::mask >> (chunk::bits - (Bits % chunk::bits));

	static constexpr size_t chunks = (Bits + chunk::bits - 1) / chunk::bits;
	chunk::type data[chunks] = {};

	value() = default;
	template<typename... Init>
	explicit constexpr value(Init ...init) : data{init...} {}

	value(const value<Bits> &) = default;
	value<Bits> &operator=(const value<Bits> &) = default;

	value(value<Bits> &&) = default;
	value<Bits> &operator=(value<Bits> &&) = default;

	// A (no-op) helper that forces the cast to value<>.
	CXXRTL_ALWAYS_INLINE
	const value<Bits> &val() const {
		return *this;
	}

	std::string str() const {
		std::stringstream ss;
		ss << *this;
		return ss.str();
	}

	// Conversion operations.
	//
	// These functions ensure that a conversion is never out of range, and should be always used, if at all
	// possible, instead of direct manipulation of the \`data\` member. For very large types, .slice() and
	// .concat() can be used to split them into more manageable parts.
	template<class IntegerT, typename std::enable_if<!std::is_signed<IntegerT>::value, int>::type = 0>
	CXXRTL_ALWAYS_INLINE
	IntegerT get() const {
		static_assert(std::numeric_limits<IntegerT>::is_integer && !std::numeric_limits<IntegerT>::is_signed,
		              "get<T>() requires T to be an unsigned integral type");
		static_assert(std::numeric_limits<IntegerT>::digits >= Bits,
		              "get<T>() requires T to be at least as wide as the value is");
		IntegerT result = 0;
		for (size_t n = 0; n < chunks; n++)
			result |= IntegerT(data[n]) << (n * chunk::bits);
		return result;
	}

	template<class IntegerT, typename std::enable_if<std::is_signed<IntegerT>::value, int>::type = 0>
	CXXRTL_ALWAYS_INLINE
	IntegerT get() const {
		auto unsigned_result = get<typename std::make_unsigned<IntegerT>::type>();
		IntegerT result;
		memcpy(&result, &unsigned_result, sizeof(IntegerT));
		return result;
	}

	template<class IntegerT, typename std::enable_if<!std::is_signed<IntegerT>::value, int>::type = 0>
	CXXRTL_ALWAYS_INLINE
	void set(IntegerT value) {
		static_assert(std::numeric_limits<IntegerT>::is_integer && !std::numeric_limits<IntegerT>::is_signed,
		              "set<T>() requires T to be an unsigned integral type");
		static_assert(std::numeric_limits<IntegerT>::digits >= Bits,
		              "set<T>() requires the value to be at least as wide as T is");
		for (size_t n = 0; n < chunks; n++)
			data[n] = (value >> (n * chunk::bits)) & chunk::mask;
	}

	template<class IntegerT, typename std::enable_if<std::is_signed<IntegerT>::value, int>::type = 0>
	CXXRTL_ALWAYS_INLINE
	void set(IntegerT value) {
		typename std::make_unsigned<IntegerT>::type unsigned_value;
		memcpy(&unsigned_value, &value, sizeof(IntegerT));
		set(unsigned_value);
	}

	// Operations with compile-time parameters.
	//
	// These operations are used to implement slicing, concatenation, and blitting.
	// The trunc, zext and sext operations add or remove most significant bits (i.e. on the left);
	// the rtrunc and rzext operations add or remove least significant bits (i.e. on the right).
	template<size_t NewBits>
	CXXRTL_ALWAYS_INLINE
	value<NewBits> trunc() const {
		static_assert(NewBits <= Bits, "trunc() may not increase width");
		value<NewBits> result;
		for (size_t n = 0; n < result.chunks; n++)
			result.data[n] = data[n];
		result.data[result.chunks - 1] &= result.msb_mask;
		return result;
	}

	template<size_t NewBits>
	CXXRTL_ALWAYS_INLINE
	value<NewBits> zext() const {
		static_assert(NewBits >= Bits, "zext() may not decrease width");
		value<NewBits> result;
		for (size_t n = 0; n < chunks; n++)
			result.data[n] = data[n];
		return result;
	}

	template<size_t NewBits>
	CXXRTL_ALWAYS_INLINE
	value<NewBits> sext() const {
		static_assert(NewBits >= Bits, "sext() may not decrease width");
		value<NewBits> result;
		for (size_t n = 0; n < chunks; n++)
			result.data[n] = data[n];
		if (is_neg()) {
			result.data[chunks - 1] |= ~msb_mask;
			for (size_t n = chunks; n < result.chunks; n++)
				result.data[n] = chunk::mask;
			result.data[result.chunks - 1] &= result.msb_mask;
		}
		return result;
	}

	template<size_t NewBits>
	CXXRTL_ALWAYS_INLINE
	value<NewBits> rtrunc() const {
		static_assert(NewBits <= Bits, "rtrunc() may not increase width");
		value<NewBits> result;
		constexpr size_t shift_chunks = (Bits - NewBits) / chunk::bits;
		constexpr size_t shift_bits   = (Bits - NewBits) % chunk::bits;
		chunk::type carry = 0;
		if (shift_chunks + result.chunks < chunks) {
			carry = (shift_bits == 0) ? 0
				: data[shift_chunks + result.chunks] << (chunk::bits - shift_bits);
		}
		for (size_t n = result.chunks; n > 0; n--) {
			result.data[n - 1] = carry | (data[shift_chunks + n - 1] >> shift_bits);
			carry = (shift_bits == 0) ? 0
				: data[shift_chunks + n - 1] << (chunk::bits - shift_bits);
		}
		return result;
	}

	template<size_t NewBits>
	CXXRTL_ALWAYS_INLINE
	value<NewBits> rzext() const {
		static_assert(NewBits >= Bits, "rzext() may not decrease width");
		value<NewBits> result;
		constexpr size_t shift_chunks = (NewBits - Bits) / chunk::bits;
		constexpr size_t shift_bits   = (NewBits - Bits) % chunk::bits;
		chunk::type carry = 0;
		for (size_t n = 0; n < chunks; n++) {
			result.data[shift_chunks + n] = (data[n] << shift_bits) | carry;
			carry = (shift_bits == 0) ? 0
				: data[n] >> (chunk::bits - shift_bits);
		}
		if (shift_chunks + chunks < result.chunks)
			result.data[shift_chunks + chunks] = carry;
		return result;
	}

	// Bit blit operation, i.e. a partial read-modify-write.
	template<size_t Stop, size_t Start>
	CXXRTL_ALWAYS_INLINE
	value<Bits> blit(const value<Stop - Start + 1> &source) const {
		static_assert(Stop >= Start, "blit() may not reverse bit order");
		constexpr chunk::type start_mask = ~(chunk::mask << (Start % chunk::bits));
		constexpr chunk::type stop_mask = (Stop % chunk::bits + 1 == chunk::bits) ? 0
			: (chunk::mask << (Stop % chunk::bits + 1));
		value<Bits> masked = *this;
		if (Start / chunk::bits == Stop / chunk::bits) {
			masked.data[Start / chunk::bits] &= stop_mask | start_mask;
		} else {
			masked.data[Start / chunk::bits] &= start_mask;
			for (size_t n = Start / chunk::bits + 1; n < Stop / chunk::bits; n++)
				masked.data[n] = 0;
			masked.data[Stop / chunk::bits] &= stop_mask;
		}
		value<Bits> shifted = source
			.template rzext<Stop + 1>()
			.template zext<Bits>();
		return masked.bit_or(shifted);
	}

	// Helpers for selecting extending or truncating operation depending on whether the result is wider or narrower
	// than the operand. In C++17 these can be replaced with \`if constexpr\`.
	template<size_t NewBits, typename = void>
	struct zext_cast {
		CXXRTL_ALWAYS_INLINE
		value<NewBits> operator()(const value<Bits> &val) {
			return val.template zext<NewBits>();
		}
	};

	template<size_t NewBits>
	struct zext_cast<NewBits, typename std::enable_if<(NewBits < Bits)>::type> {
		CXXRTL_ALWAYS_INLINE
		value<NewBits> operator()(const value<Bits> &val) {
			return val.template trunc<NewBits>();
		}
	};

	template<size_t NewBits, typename = void>
	struct sext_cast {
		CXXRTL_ALWAYS_INLINE
		value<NewBits> operator()(const value<Bits> &val) {
			return val.template sext<NewBits>();
		}
	};

	template<size_t NewBits>
	struct sext_cast<NewBits, typename std::enable_if<(NewBits < Bits)>::type> {
		CXXRTL_ALWAYS_INLINE
		value<NewBits> operator()(const value<Bits> &val) {
			return val.template trunc<NewBits>();
		}
	};

	template<size_t NewBits>
	CXXRTL_ALWAYS_INLINE
	value<NewBits> zcast() const {
		return zext_cast<NewBits>()(*this);
	}

	template<size_t NewBits>
	CXXRTL_ALWAYS_INLINE
	value<NewBits> scast() const {
		return sext_cast<NewBits>()(*this);
	}

	// Bit replication is far more efficient than the equivalent concatenation.
	template<size_t Count>
	CXXRTL_ALWAYS_INLINE
	value<Bits * Count> repeat() const {
		static_assert(Bits == 1, "repeat() is implemented only for 1-bit values");
		return *this ? value<Bits * Count>().bit_not() : value<Bits * Count>();
	}

	// Operations with run-time parameters (offsets, amounts, etc).
	//
	// These operations are used for computations.
	bool bit(size_t offset) const {
		return data[offset / chunk::bits] & (1 << (offset % chunk::bits));
	}

	void set_bit(size_t offset, bool value = true) {
		size_t offset_chunks = offset / chunk::bits;
		size_t offset_bits = offset % chunk::bits;
		data[offset_chunks] &= ~(1 << offset_bits);
		data[offset_chunks] |= value ? 1 << offset_bits : 0;
	}

	explicit operator bool() const {
		return !is_zero();
	}

	bool is_zero() const {
		for (size_t n = 0; n < chunks; n++)
			if (data[n] != 0)
				return false;
		return true;
	}

	bool is_neg() const {
		return data[chunks - 1] & (1 << ((Bits - 1) % chunk::bits));
	}

	bool operator ==(const value<Bits> &other) const {
		for (size_t n = 0; n < chunks; n++)
			if (data[n] != other.data[n])
				return false;
		return true;
	}

	bool operator !=(const value<Bits> &other) const {
		return !(*this == other);
	}

	value<Bits> bit_not() const {
		value<Bits> result;
		for (size_t n = 0; n < chunks; n++)
			result.data[n] = ~data[n];
		result.data[chunks - 1] &= msb_mask;
		return result;
	}

	value<Bits> bit_and(const value<Bits> &other) const {
		value<Bits> result;
		for (size_t n = 0; n < chunks; n++)
			result.data[n] = data[n] & other.data[n];
		return result;
	}

	value<Bits> bit_or(const value<Bits> &other) const {
		value<Bits> result;
		for (size_t n = 0; n < chunks; n++)
			result.data[n] = data[n] | other.data[n];
		return result;
	}

	value<Bits> bit_xor(const value<Bits> &other) const {
		value<Bits> result;
		for (size_t n = 0; n < chunks; n++)
			result.data[n] = data[n] ^ other.data[n];
		return result;
	}

	value<Bits> update(const value<Bits> &val, const value<Bits> &mask) const {
		return bit_and(mask.bit_not()).bit_or(val.bit_and(mask));
	}

	template<size_t AmountBits>
	value<Bits> shl(const value<AmountBits> &amount) const {
		// Ensure our early return is correct by prohibiting values larger than 4 Gbit.
		static_assert(Bits <= chunk::mask, "shl() of unreasonably large values is not supported");
		// Detect shifts definitely large than Bits early.
		for (size_t n = 1; n < amount.chunks; n++)
			if (amount.data[n] != 0)
				return {};
		// Past this point we can use the least significant chunk as the shift size.
		size_t shift_chunks = amount.data[0] / chunk::bits;
		size_t shift_bits   = amount.data[0] % chunk::bits;
		if (shift_chunks >= chunks)
			return {};
		value<Bits> result;
		chunk::type carry = 0;
		for (size_t n = 0; n < chunks - shift_chunks; n++) {
			result.data[shift_chunks + n] = (data[n] << shift_bits) | carry;
			carry = (shift_bits == 0) ? 0
				: data[n] >> (chunk::bits - shift_bits);
		}
		result.data[result.chunks - 1] &= result.msb_mask;
		return result;
	}

	template<size_t AmountBits, bool Signed = false>
	value<Bits> shr(const value<AmountBits> &amount) const {
		// Ensure our early return is correct by prohibiting values larger than 4 Gbit.
		static_assert(Bits <= chunk::mask, "shr() of unreasonably large values is not supported");
		// Detect shifts definitely large than Bits early.
		for (size_t n = 1; n < amount.chunks; n++)
			if (amount.data[n] != 0)
				return (Signed && is_neg()) ? value<Bits>().bit_not() : value<Bits>();
		// Past this point we can use the least significant chunk as the shift size.
		size_t shift_chunks = amount.data[0] / chunk::bits;
		size_t shift_bits   = amount.data[0] % chunk::bits;
		if (shift_chunks >= chunks)
			return (Signed && is_neg()) ? value<Bits>().bit_not() : value<Bits>();
		value<Bits> result;
		chunk::type carry = 0;
		for (size_t n = 0; n < chunks - shift_chunks; n++) {
			result.data[chunks - shift_chunks - 1 - n] = carry | (data[chunks - 1 - n] >> shift_bits);
			carry = (shift_bits == 0) ? 0
				: data[chunks - 1 - n] << (chunk::bits - shift_bits);
		}
		if (Signed && is_neg()) {
			size_t top_chunk_idx  = amount.data[0] > Bits ? 0 : (Bits - amount.data[0]) / chunk::bits;
			size_t top_chunk_bits = amount.data[0] > Bits ? 0 : (Bits - amount.data[0]) % chunk::bits;
			for (size_t n = top_chunk_idx + 1; n < chunks; n++)
				result.data[n] = chunk::mask;
			if (amount.data[0] != 0)
				result.data[top_chunk_idx] |= chunk::mask << top_chunk_bits;
			result.data[result.chunks - 1] &= result.msb_mask;
		}
		return result;
	}

	template<size_t AmountBits>
	value<Bits> sshr(const value<AmountBits> &amount) const {
		return shr<AmountBits, /*Signed=*/true>(amount);
	}

	template<size_t ResultBits, size_t SelBits>
	value<ResultBits> bmux(const value<SelBits> &sel) const {
		static_assert(ResultBits << SelBits == Bits, "invalid sizes used in bmux()");
		size_t amount = sel.data[0] * ResultBits;
		size_t shift_chunks = amount / chunk::bits;
		size_t shift_bits   = amount % chunk::bits;
		value<ResultBits> result;
		chunk::type carry = 0;
		if (ResultBits % chunk::bits + shift_bits > chunk::bits)
			carry = data[result.chunks + shift_chunks] << (chunk::bits - shift_bits);
		for (size_t n = 0; n < result.chunks; n++) {
			result.data[result.chunks - 1 - n] = carry | (data[result.chunks + shift_chunks - 1 - n] >> shift_bits);
			carry = (shift_bits == 0) ? 0
				: data[result.chunks + shift_chunks - 1 - n] << (chunk::bits - shift_bits);
		}
		result.data[result.chunks - 1] &= result.msb_mask;
		return result;
	}

	template<size_t ResultBits, size_t SelBits>
	value<ResultBits> demux(const value<SelBits> &sel) const {
		static_assert(Bits << SelBits == ResultBits, "invalid sizes used in demux()");
		size_t amount = sel.data[0] * Bits;
		size_t shift_chunks = amount / chunk::bits;
		size_t shift_bits   = amount % chunk::bits;
		value<ResultBits> result;
		chunk::type carry = 0;
		for (size_t n = 0; n < chunks; n++) {
			result.data[shift_chunks + n] = (data[n] << shift_bits) | carry;
			carry = (shift_bits == 0) ? 0
				: data[n] >> (chunk::bits - shift_bits);
		}
		if (Bits % chunk::bits + shift_bits > chunk::bits)
			result.data[shift_chunks + chunks] = carry;
		return result;
	}

	size_t ctpop() const {
		size_t count = 0;
		for (size_t n = 0; n < chunks; n++) {
			// This loop implements the population count idiom as recognized by LLVM and GCC.
			for (chunk::type x = data[n]; x != 0; count++)
				x = x & (x - 1);
		}
		return count;
	}

	size_t ctlz() const {
		size_t count = 0;
		for (size_t n = 0; n < chunks; n++) {
			chunk::type x = data[chunks - 1 - n];
			// First add to \`count\` as if the chunk is zero
			constexpr size_t msb_chunk_bits = Bits % chunk::bits != 0 ? Bits % chunk::bits : chunk::bits;
			count += (n == 0 ? msb_chunk_bits : chunk::bits);
			// If the chunk isn't zero, correct the \`count\` value and return
			if (x != 0) {
				for (; x != 0; count--)
					x >>= 1;
				break;
			}
		}
		return count;
	}

	template<bool Invert, bool CarryIn>
	std::pair<value<Bits>, bool /*CarryOut*/> alu(const value<Bits> &other) const {
		value<Bits> result;
		bool carry = CarryIn;
		for (size_t n = 0; n < result.chunks; n++) {
			result.data[n] = data[n] + (Invert ? ~other.data[n] : other.data[n]) + carry;
			if (result.chunks - 1 == n)
				result.data[result.chunks - 1] &= result.msb_mask;
			carry = (result.data[n] <  data[n]) ||
			        (result.data[n] == data[n] && carry);
		}
		return {result, carry};
	}

	value<Bits> add(const value<Bits> &other) const {
		return alu</*Invert=*/false, /*CarryIn=*/false>(other).first;
	}

	value<Bits> sub(const value<Bits> &other) const {
		return alu</*Invert=*/true, /*CarryIn=*/true>(other).first;
	}

	value<Bits> neg() const {
		return value<Bits>().sub(*this);
	}

	bool ucmp(const value<Bits> &other) const {
		bool carry;
		std::tie(std::ignore, carry) = alu</*Invert=*/true, /*CarryIn=*/true>(other);
		return !carry; // a.ucmp(b) \u2261 a u< b
	}

	bool scmp(const value<Bits> &other) const {
		value<Bits> result;
		bool carry;
		std::tie(result, carry) = alu</*Invert=*/true, /*CarryIn=*/true>(other);
		bool overflow = (is_neg() == !other.is_neg()) && (is_neg() != result.is_neg());
		return result.is_neg() ^ overflow; // a.scmp(b) \u2261 a s< b
	}

	template<size_t ResultBits>
	value<ResultBits> mul(const value<Bits> &other) const {
		value<ResultBits> result;
		wide_chunk_t wide_result[result.chunks + 1] = {};
		for (size_t n = 0; n < chunks; n++) {
			for (size_t m = 0; m < chunks && n + m < result.chunks; m++) {
				wide_result[n + m] += wide_chunk_t(data[n]) * wide_chunk_t(other.data[m]);
				wide_result[n + m + 1] += wide_result[n + m] >> chunk::bits;
				wide_result[n + m] &= chunk::mask;
			}
		}
		for (size_t n = 0; n < result.chunks; n++) {
			result.data[n] = wide_result[n];
		}
		result.data[result.chunks - 1] &= result.msb_mask;
		return result;
	}

	std::pair<value<Bits>, value<Bits>> udivmod(value<Bits> divisor) const {
		value<Bits> quotient;
		value<Bits> dividend = *this;
		if (dividend.ucmp(divisor))
			return {/*quotient=*/value<Bits>{0u}, /*remainder=*/dividend};
		int64_t divisor_shift = divisor.ctlz() - dividend.ctlz();
		assert(divisor_shift >= 0);
		divisor = divisor.shl(value<Bits>{(chunk::type) divisor_shift});
		for (size_t step = 0; step <= divisor_shift; step++) {
			quotient = quotient.shl(value<Bits>{1u});
			if (!dividend.ucmp(divisor)) {
				dividend = dividend.sub(divisor);
				quotient.set_bit(0, true);
			}
			divisor = divisor.shr(value<Bits>{1u});
		}
		return {quotient, /*remainder=*/dividend};
	}

	std::pair<value<Bits>, value<Bits>> sdivmod(const value<Bits> &other) const {
		value<Bits + 1> quotient;
		value<Bits + 1> remainder;
		value<Bits + 1> dividend = sext<Bits + 1>();
		value<Bits + 1> divisor = other.template sext<Bits + 1>();
		if (is_neg()) dividend = dividend.neg();
		if (other.is_neg()) divisor = divisor.neg();
		std::tie(quotient, remainder) = dividend.udivmod(divisor);
		if (is_neg() != other.is_neg()) quotient = quotient.neg();
		if (is_neg()) remainder = remainder.neg();
		return {quotient.template trunc<Bits>(), remainder.template trunc<Bits>()};
	}
};

// Expression template for a slice, usable as lvalue or rvalue, and composable with other expression templates here.
template<class T, size_t Stop, size_t Start>
struct slice_expr : public expr_base<slice_expr<T, Stop, Start>> {
	static_assert(Stop >= Start, "slice_expr() may not reverse bit order");
	static_assert(Start < T::bits && Stop < T::bits, "slice_expr() must be within bounds");
	static constexpr size_t bits = Stop - Start + 1;

	T &expr;

	slice_expr(T &expr) : expr(expr) {}
	slice_expr(const slice_expr<T, Stop, Start> &) = delete;

	CXXRTL_ALWAYS_INLINE
	operator value<bits>() const {
		return static_cast<const value<T::bits> &>(expr)
			.template rtrunc<T::bits - Start>()
			.template trunc<bits>();
	}

	CXXRTL_ALWAYS_INLINE
	slice_expr<T, Stop, Start> &operator=(const value<bits> &rhs) {
		// Generic partial assignment implemented using a read-modify-write operation on the sliced expression.
		expr = static_cast<const value<T::bits> &>(expr)
			.template blit<Stop, Start>(rhs);
		return *this;
	}

	// A helper that forces the cast to value<>, which allows deduction to work.
	CXXRTL_ALWAYS_INLINE
	value<bits> val() const {
		return static_cast<const value<bits> &>(*this);
	}
};

// Expression template for a concatenation, usable as lvalue or rvalue, and composable with other expression templates here.
template<class T, class U>
struct concat_expr : public expr_base<concat_expr<T, U>> {
	static constexpr size_t bits = T::bits + U::bits;

	T &ms_expr;
	U &ls_expr;

	concat_expr(T &ms_expr, U &ls_expr) : ms_expr(ms_expr), ls_expr(ls_expr) {}
	concat_expr(const concat_expr<T, U> &) = delete;

	CXXRTL_ALWAYS_INLINE
	operator value<bits>() const {
		value<bits> ms_shifted = static_cast<const value<T::bits> &>(ms_expr)
			.template rzext<bits>();
		value<bits> ls_extended = static_cast<const value<U::bits> &>(ls_expr)
			.template zext<bits>();
		return ms_shifted.bit_or(ls_extended);
	}

	CXXRTL_ALWAYS_INLINE
	concat_expr<T, U> &operator=(const value<bits> &rhs) {
		ms_expr = rhs.template rtrunc<T::bits>();
		ls_expr = rhs.template trunc<U::bits>();
		return *this;
	}

	// A helper that forces the cast to value<>, which allows deduction to work.
	CXXRTL_ALWAYS_INLINE
	value<bits> val() const {
		return static_cast<const value<bits> &>(*this);
	}
};

// Base class for expression templates, providing helper methods for operations that are valid on both rvalues and lvalues.
//
// Note that expression objects (slices and concatenations) constructed in this way should NEVER be captured because
// they refer to temporaries that will, in general, only live until the end of the statement. For example, both of
// these snippets perform use-after-free:
//
//    const auto &a = val.slice<7,0>().slice<1>();
//    value<1> b = a;
//
//    auto &&c = val.slice<7,0>().slice<1>();
//    c = value<1>{1u};
//
// An easy way to write code using slices and concatenations safely is to follow two simple rules:
//   * Never explicitly name any type except \`value<W>\` or \`const value<W> &\`.
//   * Never use a \`const auto &\` or \`auto &&\` in any such expression.
// Then, any code that compiles will be well-defined.
template<class T>
struct expr_base {
	template<size_t Stop, size_t Start = Stop>
	CXXRTL_ALWAYS_INLINE
	slice_expr<const T, Stop, Start> slice() const {
		return {*static_cast<const T *>(this)};
	}

	template<size_t Stop, size_t Start = Stop>
	CXXRTL_ALWAYS_INLINE
	slice_expr<T, Stop, Start> slice() {
		return {*static_cast<T *>(this)};
	}

	template<class U>
	CXXRTL_ALWAYS_INLINE
	concat_expr<const T, typename std::remove_reference<const U>::type> concat(const U &other) const {
		return {*static_cast<const T *>(this), other};
	}

	template<class U>
	CXXRTL_ALWAYS_INLINE
	concat_expr<T, typename std::remove_reference<U>::type> concat(U &&other) {
		return {*static_cast<T *>(this), other};
	}
};

template<size_t Bits>
std::ostream &operator<<(std::ostream &os, const value<Bits> &val) {
	auto old_flags = os.flags(std::ios::right);
	auto old_width = os.width(0);
	auto old_fill  = os.fill('0');
	os << val.bits << '\\'' << std::hex;
	for (size_t n = val.chunks - 1; n != (size_t)-1; n--) {
		if (n == val.chunks - 1 && Bits % value<Bits>::chunk::bits != 0)
			os.width((Bits % value<Bits>::chunk::bits + 3) / 4);
		else
			os.width((value<Bits>::chunk::bits + 3) / 4);
		os << val.data[n];
	}
	os.fill(old_fill);
	os.width(old_width);
	os.flags(old_flags);
	return os;
}

template<size_t Bits>
struct wire {
	static constexpr size_t bits = Bits;

	value<Bits> curr;
	value<Bits> next;

	wire() = default;
	explicit constexpr wire(const value<Bits> &init) : curr(init), next(init) {}
	template<typename... Init>
	explicit constexpr wire(Init ...init) : curr{init...}, next{init...} {}

	// Copying and copy-assigning values is natural. If, however, a value is replaced with a wire,
	// e.g. because a module is built with a different optimization level, then existing code could
	// unintentionally copy a wire instead, which would create a subtle but serious bug. To make sure
	// this doesn't happen, prohibit copying and copy-assigning wires.
	wire(const wire<Bits> &) = delete;
	wire<Bits> &operator=(const wire<Bits> &) = delete;

	wire(wire<Bits> &&) = default;
	wire<Bits> &operator=(wire<Bits> &&) = default;

	template<class IntegerT>
	CXXRTL_ALWAYS_INLINE
	IntegerT get() const {
		return curr.template get<IntegerT>();
	}

	template<class IntegerT>
	CXXRTL_ALWAYS_INLINE
	void set(IntegerT other) {
		next.template set<IntegerT>(other);
	}

	// This method intentionally takes a mandatory argument (to make it more difficult to misuse in
	// black box implementations, leading to missed observer events). It is generic over its argument
	// to allow the \`on_update\` method to be non-virtual.
	template<class ObserverT>
	bool commit(ObserverT &observer) {
		if (curr != next) {
			observer.on_update(curr.chunks, curr.data, next.data);
			curr = next;
			return true;
		}
		return false;
	}
};

template<size_t Bits>
std::ostream &operator<<(std::ostream &os, const wire<Bits> &val) {
	os << val.curr;
	return os;
}

template<size_t Width>
struct memory {
	const size_t depth;
	std::unique_ptr<value<Width>[]> data;

	explicit memory(size_t depth) : depth(depth), data(new value<Width>[depth]) {}

	memory(const memory<Width> &) = delete;
	memory<Width> &operator=(const memory<Width> &) = delete;

	memory(memory<Width> &&) = default;
	memory<Width> &operator=(memory<Width> &&other) {
		assert(depth == other.depth);
		data = std::move(other.data);
		write_queue = std::move(other.write_queue);
		return *this;
	}

	// An operator for direct memory reads. May be used at any time during the simulation.
	const value<Width> &operator [](size_t index) const {
		assert(index < depth);
		return data[index];
	}

	// An operator for direct memory writes. May only be used before the simulation is started. If used
	// after the simulation is started, the design may malfunction.
	value<Width> &operator [](size_t index) {
		assert(index < depth);
		return data[index];
	}

	// A simple way to make a writable memory would be to use an array of wires instead of an array of values.
	// However, there are two significant downsides to this approach: first, it has large overhead (2\xD7 space
	// overhead, and O(depth) time overhead during commit); second, it does not simplify handling write port
	// priorities. Although in principle write ports could be ordered or conditionally enabled in generated
	// code based on their priorities and selected addresses, the feedback arc set problem is computationally
	// expensive, and the heuristic based algorithms are not easily modified to guarantee (rather than prefer)
	// a particular write port evaluation order.
	//
	// The approach used here instead is to queue writes into a buffer during the eval phase, then perform
	// the writes during the commit phase in the priority order. This approach has low overhead, with both space
	// and time proportional to the amount of write ports. Because virtually every memory in a practical design
	// has at most two write ports, linear search is used on every write, being the fastest and simplest approach.
	struct write {
		size_t index;
		value<Width> val;
		value<Width> mask;
		int priority;
	};
	std::vector<write> write_queue;

	void update(size_t index, const value<Width> &val, const value<Width> &mask, int priority = 0) {
		assert(index < depth);
		// Queue up the write while keeping the queue sorted by priority.
		write_queue.insert(
			std::upper_bound(write_queue.begin(), write_queue.end(), priority,
				[](const int a, const write& b) { return a < b.priority; }),
			write { index, val, mask, priority });
	}

	// See the note for \`wire::commit()\`.
	template<class ObserverT>
	bool commit(ObserverT &observer) {
		bool changed = false;
		for (const write &entry : write_queue) {
			value<Width> elem = data[entry.index];
			elem = elem.update(entry.val, entry.mask);
			if (data[entry.index] != elem) {
				observer.on_update(value<Width>::chunks, data[0].data, elem.data, entry.index);
				changed |= true;
			}
			data[entry.index] = elem;
		}
		write_queue.clear();
		return changed;
	}
};

struct metadata {
	const enum {
		MISSING = 0,
		UINT   	= 1,
		SINT   	= 2,
		STRING 	= 3,
		DOUBLE 	= 4,
	} value_type;

	// In debug mode, using the wrong .as_*() function will assert.
	// In release mode, using the wrong .as_*() function will safely return a default value.
	const uint64_t    uint_value = 0;
	const int64_t     sint_value = 0;
	const std::string string_value = "";
	const double      double_value = 0.0;

	metadata() : value_type(MISSING) {}
	metadata(uint64_t value) : value_type(UINT), uint_value(value) {}
	metadata(int64_t value) : value_type(SINT), sint_value(value) {}
	metadata(const std::string &value) : value_type(STRING), string_value(value) {}
	metadata(const char *value) : value_type(STRING), string_value(value) {}
	metadata(double value) : value_type(DOUBLE), double_value(value) {}

	metadata(const metadata &) = default;
	metadata &operator=(const metadata &) = delete;

	uint64_t as_uint() const {
		assert(value_type == UINT);
		return uint_value;
	}

	int64_t as_sint() const {
		assert(value_type == SINT);
		return sint_value;
	}

	const std::string &as_string() const {
		assert(value_type == STRING);
		return string_value;
	}

	double as_double() const {
		assert(value_type == DOUBLE);
		return double_value;
	}

	// Internal CXXRTL use only.
	static std::map<std::string, metadata> deserialize(const char *ptr) {
		std::map<std::string, metadata> result;
		std::string name;
		// Grammar:
		// string   ::= [^\\0]+ \\0
		// metadata ::= [uid] .{8} | s <string>
		// map      ::= ( <string> <metadata> )* \\0
		for (;;) {
			if (*ptr) {
				name += *ptr++;
			} else if (!name.empty()) {
				ptr++;
				auto get_u64 = [&]() {
					uint64_t result = 0;
					for (size_t count = 0; count < 8; count++)
						result = (result << 8) | *ptr++;
					return result;
				};
				char type = *ptr++;
				if (type == 'u') {
					uint64_t value = get_u64();
					result.emplace(name, value);
				} else if (type == 'i') {
					int64_t value = (int64_t)get_u64();
					result.emplace(name, value);
				} else if (type == 'd') {
					double dvalue;
					uint64_t uvalue = get_u64();
					static_assert(sizeof(dvalue) == sizeof(uvalue), "double must be 64 bits in size");
					memcpy(&dvalue, &uvalue, sizeof(dvalue));
					result.emplace(name, dvalue);
				} else if (type == 's') {
					std::string value;
					while (*ptr)
						value += *ptr++;
					ptr++;
					result.emplace(name, value);
				} else {
					assert(false && "Unknown type specifier");
					return result;
				}
				name.clear();
			} else {
				return result;
			}
		}
	}
};

typedef std::map<std::string, metadata> metadata_map;

struct performer;

// An object that allows formatting a string lazily.
struct lazy_fmt {
	virtual std::string operator() () const = 0;
};

// Flavor of a \`$check\` cell.
enum class flavor {
	// Corresponds to a \`$assert\` cell in other flows, and a Verilog \`assert ()\` statement.
	ASSERT,
	// Corresponds to a \`$assume\` cell in other flows, and a Verilog \`assume ()\` statement.
	ASSUME,
	// Corresponds to a \`$live\` cell in other flows, and a Verilog \`assert (eventually)\` statement.
	ASSERT_EVENTUALLY,
	// Corresponds to a \`$fair\` cell in other flows, and a Verilog \`assume (eventually)\` statement.
	ASSUME_EVENTUALLY,
	// Corresponds to a \`$cover\` cell in other flows, and a Verilog \`cover ()\` statement.
	COVER,
};

// An object that can be passed to a \`eval()\` method in order to act on side effects. The default behavior implemented
// below is the same as the behavior of \`eval(nullptr)\`, except that \`-print-output\` option of \`write_cxxrtl\` is not
// taken into account.
struct performer {
	// Called by generated formatting code to evaluate a Verilog \`$time\` expression.
	virtual int64_t vlog_time() const { return 0; }

	// Called by generated formatting code to evaluate a Verilog \`$realtime\` expression.
	virtual double vlog_realtime() const { return vlog_time(); }

	// Called when a \`$print\` cell is triggered.
	virtual void on_print(const lazy_fmt &formatter, const metadata_map &attributes) {
		std::cout << formatter();
	}

	// Called when a \`$check\` cell is triggered.
	virtual void on_check(flavor type, bool condition, const lazy_fmt &formatter, const metadata_map &attributes) {
		if (type == flavor::ASSERT || type == flavor::ASSUME) {
			if (!condition)
				std::cerr << formatter();
			CXXRTL_ASSERT(condition && "Check failed");
		}
	}
};

// An object that can be passed to a \`commit()\` method in order to produce a replay log of every state change in
// the simulation. Unlike \`performer\`, \`observer\` does not use virtual calls as their overhead is unacceptable, and
// a comparatively heavyweight template-based solution is justified.
struct observer {
	// Called when the \`commit()\` method for a wire is about to update the \`chunks\` chunks at \`base\` with \`chunks\` chunks
	// at \`value\` that have a different bit pattern. It is guaranteed that \`chunks\` is equal to the wire chunk count and
	// \`base\` points to the first chunk.
	void on_update(size_t chunks, const chunk_t *base, const chunk_t *value) {}

	// Called when the \`commit()\` method for a memory is about to update the \`chunks\` chunks at \`&base[chunks * index]\`
	// with \`chunks\` chunks at \`value\` that have a different bit pattern. It is guaranteed that \`chunks\` is equal to
	// the memory element chunk count and \`base\` points to the first chunk of the first element of the memory.
	void on_update(size_t chunks, const chunk_t *base, const chunk_t *value, size_t index) {}
};

// Must be kept in sync with \`struct FmtPart\` in kernel/fmt.h!
// Default member initializers would make this a non-aggregate-type in C++11, so they are commented out.
struct fmt_part {
	enum {
		LITERAL   = 0,
		INTEGER   = 1,
		STRING    = 2,
		UNICHAR   = 3,
		VLOG_TIME = 4,
	} type;

	// LITERAL type
	std::string str;

	// INTEGER/STRING/UNICHAR types
	// + value<Bits> val;

	// INTEGER/STRING/VLOG_TIME types
	enum {
		RIGHT	= 0,
		LEFT	= 1,
		NUMERIC	= 2,
	} justify; // = RIGHT;
	char padding; // = '\\0';
	size_t width; // = 0;

	// INTEGER type
	unsigned base; // = 10;
	bool signed_; // = false;
	enum {
		MINUS		= 0,
		PLUS_MINUS	= 1,
		SPACE_MINUS	= 2,
	} sign; // = MINUS;
	bool hex_upper; // = false;
	bool show_base; // = false;
	bool group; // = false;

	// VLOG_TIME type
	bool realtime; // = false;
	// + int64_t itime;
	// + double ftime;

	// Format the part as a string.
	//
	// The values of \`vlog_time\` and \`vlog_realtime\` are used for Verilog \`$time\` and \`$realtime\`, correspondingly.
	template<size_t Bits>
	std::string render(value<Bits> val, performer *performer = nullptr)
	{
		// We might want to replace some of these bit() calls with direct
		// chunk access if it turns out to be slow enough to matter.
		std::string buf;
		std::string prefix;
		switch (type) {
			case LITERAL:
				return str;

			case STRING: {
				buf.reserve(Bits/8);
				for (int i = 0; i < Bits; i += 8) {
					char ch = 0;
					for (int j = 0; j < 8 && i + j < int(Bits); j++)
						if (val.bit(i + j))
							ch |= 1 << j;
					if (ch != 0)
						buf.append({ch});
				}
				std::reverse(buf.begin(), buf.end());
				break;
			}

			case UNICHAR: {
				uint32_t codepoint = val.template get<uint32_t>();
				if (codepoint >= 0x10000)
					buf += (char)(0xf0 |  (codepoint >> 18));
				else if (codepoint >= 0x800)
					buf += (char)(0xe0 |  (codepoint >> 12));
				else if (codepoint >= 0x80)
					buf += (char)(0xc0 |  (codepoint >>  6));
				else
					buf += (char)codepoint;
				if (codepoint >= 0x10000)
					buf += (char)(0x80 | ((codepoint >> 12) & 0x3f));
				if (codepoint >= 0x800)
					buf += (char)(0x80 | ((codepoint >>  6) & 0x3f));
				if (codepoint >= 0x80)
					buf += (char)(0x80 | ((codepoint >>  0) & 0x3f));
				break;
			}

			case INTEGER: {
				bool negative = signed_ && val.is_neg();
				if (negative) {
					prefix = "-";
					val = val.neg();
				} else {
					switch (sign) {
						case MINUS:       break;
						case PLUS_MINUS:  prefix = "+"; break;
						case SPACE_MINUS: prefix = " "; break;
					}
				}

				size_t val_width = Bits;
				if (base != 10) {
					val_width = 1;
					for (size_t index = 0; index < Bits; index++)
						if (val.bit(index))
							val_width = index + 1;
				}

				if (base == 2) {
					if (show_base)
						prefix += "0b";
					for (size_t index = 0; index < val_width; index++) {
						if (group && index > 0 && index % 4 == 0)
							buf += '_';
						buf += (val.bit(index) ? '1' : '0');
					}
				} else if (base == 8 || base == 16) {
					if (show_base)
						prefix += (base == 16) ? (hex_upper ? "0X" : "0x") : "0o";
					size_t step = (base == 16) ? 4 : 3;
					for (size_t index = 0; index < val_width; index += step) {
						if (group && index > 0 && index % (4 * step) == 0)
							buf += '_';
						uint8_t value = val.bit(index) | (val.bit(index + 1) << 1) | (val.bit(index + 2) << 2);
						if (step == 4)
							value |= val.bit(index + 3) << 3;
						buf += (hex_upper ? "0123456789ABCDEF" : "0123456789abcdef")[value];
					}
				} else if (base == 10) {
					if (show_base)
						prefix += "0d";
					if (val.is_zero())
						buf += '0';
					value<(Bits > 4 ? Bits : 4)> xval = val.template zext<(Bits > 4 ? Bits : 4)>();
					size_t index = 0;
					while (!xval.is_zero()) {
						if (group && index > 0 && index % 3 == 0)
							buf += '_';
						value<(Bits > 4 ? Bits : 4)> quotient, remainder;
						if (Bits >= 4)
							std::tie(quotient, remainder) = xval.udivmod(value<(Bits > 4 ? Bits : 4)>{10u});
						else
							std::tie(quotient, remainder) = std::make_pair(value<(Bits > 4 ? Bits : 4)>{0u}, xval);
						buf += '0' + remainder.template trunc<4>().template get<uint8_t>();
						xval = quotient;
						index++;
					}
				} else assert(false && "Unsupported base for fmt_part");
				if (justify == NUMERIC && group && padding == '0') {
					int group_size = base == 10 ? 3 : 4;
					while (prefix.size() + buf.size() < width) {
						if (buf.size() % (group_size + 1) == group_size)
							buf += '_';
						buf += '0';
					}
				}
				std::reverse(buf.begin(), buf.end());
				break;
			}

			case VLOG_TIME: {
				if (performer) {
					buf = realtime ? std::to_string(performer->vlog_realtime()) : std::to_string(performer->vlog_time());
				} else {
					buf = realtime ? std::to_string(0.0) : std::to_string(0);
				}
				break;
			}
		}

		std::string str;
		assert(width == 0 || padding != '\\0');
		if (prefix.size() + buf.size() < width) {
			size_t pad_width = width - prefix.size() - buf.size();
			switch (justify) {
				case LEFT:
					str += prefix;
					str += buf;
					str += std::string(pad_width, padding);
					break;
				case RIGHT:
					str += std::string(pad_width, padding);
					str += prefix;
					str += buf;
					break;
				case NUMERIC:
					str += prefix;
					str += std::string(pad_width, padding);
					str += buf;
					break;
				}
		} else {
			str += prefix;
			str += buf;
		}
		return str;
	}
};

// Tag class to disambiguate values/wires and their aliases.
struct debug_alias {};

// Tag declaration to disambiguate values and debug outlines.
using debug_outline = ::_cxxrtl_outline;

// This structure is intended for consumption via foreign function interfaces, like Python's ctypes.
// Because of this it uses a C-style layout that is easy to parse rather than more idiomatic C++.
//
// To avoid violating strict aliasing rules, this structure has to be a subclass of the one used
// in the C API, or it would not be possible to cast between the pointers to these.
//
// The \`attrs\` member cannot be owned by this structure because a \`cxxrtl_object\` can be created
// from external C code.
struct debug_item : ::cxxrtl_object {
	// Object types.
	enum : uint32_t {
		VALUE   = CXXRTL_VALUE,
		WIRE    = CXXRTL_WIRE,
		MEMORY  = CXXRTL_MEMORY,
		ALIAS   = CXXRTL_ALIAS,
		OUTLINE = CXXRTL_OUTLINE,
	};

	// Object flags.
	enum : uint32_t {
		INPUT  = CXXRTL_INPUT,
		OUTPUT = CXXRTL_OUTPUT,
		INOUT  = CXXRTL_INOUT,
		DRIVEN_SYNC = CXXRTL_DRIVEN_SYNC,
		DRIVEN_COMB = CXXRTL_DRIVEN_COMB,
		UNDRIVEN    = CXXRTL_UNDRIVEN,
	};

	debug_item(const ::cxxrtl_object &object) : cxxrtl_object(object) {}

	template<size_t Bits>
	debug_item(value<Bits> &item, size_t lsb_offset = 0, uint32_t flags_ = 0) {
		static_assert(Bits == 0 || sizeof(item) == value<Bits>::chunks * sizeof(chunk_t),
		              "value<Bits> is not compatible with C layout");
		type    = VALUE;
		flags   = flags_;
		width   = Bits;
		lsb_at  = lsb_offset;
		depth   = 1;
		zero_at = 0;
		curr    = item.data;
		next    = item.data;
		outline = nullptr;
		attrs   = nullptr;
	}

	template<size_t Bits>
	debug_item(const value<Bits> &item, size_t lsb_offset = 0) {
		static_assert(Bits == 0 || sizeof(item) == value<Bits>::chunks * sizeof(chunk_t),
		              "value<Bits> is not compatible with C layout");
		type    = VALUE;
		flags   = DRIVEN_COMB;
		width   = Bits;
		lsb_at  = lsb_offset;
		depth   = 1;
		zero_at = 0;
		curr    = const_cast<chunk_t*>(item.data);
		next    = nullptr;
		outline = nullptr;
		attrs   = nullptr;
	}

	template<size_t Bits>
	debug_item(wire<Bits> &item, size_t lsb_offset = 0, uint32_t flags_ = 0) {
		static_assert(Bits == 0 ||
		              (sizeof(item.curr) == value<Bits>::chunks * sizeof(chunk_t) &&
		               sizeof(item.next) == value<Bits>::chunks * sizeof(chunk_t)),
		              "wire<Bits> is not compatible with C layout");
		type    = WIRE;
		flags   = flags_;
		width   = Bits;
		lsb_at  = lsb_offset;
		depth   = 1;
		zero_at = 0;
		curr    = item.curr.data;
		next    = item.next.data;
		outline = nullptr;
		attrs   = nullptr;
	}

	template<size_t Width>
	debug_item(memory<Width> &item, size_t zero_offset = 0) {
		static_assert(Width == 0 || sizeof(item.data[0]) == value<Width>::chunks * sizeof(chunk_t),
		              "memory<Width> is not compatible with C layout");
		type    = MEMORY;
		flags   = 0;
		width   = Width;
		lsb_at  = 0;
		depth   = item.depth;
		zero_at = zero_offset;
		curr    = item.data ? item.data[0].data : nullptr;
		next    = nullptr;
		outline = nullptr;
		attrs   = nullptr;
	}

	template<size_t Bits>
	debug_item(debug_alias, const value<Bits> &item, size_t lsb_offset = 0) {
		static_assert(Bits == 0 || sizeof(item) == value<Bits>::chunks * sizeof(chunk_t),
		              "value<Bits> is not compatible with C layout");
		type    = ALIAS;
		flags   = DRIVEN_COMB;
		width   = Bits;
		lsb_at  = lsb_offset;
		depth   = 1;
		zero_at = 0;
		curr    = const_cast<chunk_t*>(item.data);
		next    = nullptr;
		outline = nullptr;
		attrs   = nullptr;
	}

	template<size_t Bits>
	debug_item(debug_alias, const wire<Bits> &item, size_t lsb_offset = 0) {
		static_assert(Bits == 0 ||
		              (sizeof(item.curr) == value<Bits>::chunks * sizeof(chunk_t) &&
		               sizeof(item.next) == value<Bits>::chunks * sizeof(chunk_t)),
		              "wire<Bits> is not compatible with C layout");
		type    = ALIAS;
		flags   = DRIVEN_COMB;
		width   = Bits;
		lsb_at  = lsb_offset;
		depth   = 1;
		zero_at = 0;
		curr    = const_cast<chunk_t*>(item.curr.data);
		next    = nullptr;
		outline = nullptr;
		attrs   = nullptr;
	}

	template<size_t Bits>
	debug_item(debug_outline &group, const value<Bits> &item, size_t lsb_offset = 0) {
		static_assert(Bits == 0 || sizeof(item) == value<Bits>::chunks * sizeof(chunk_t),
		              "value<Bits> is not compatible with C layout");
		type    = OUTLINE;
		flags   = DRIVEN_COMB;
		width   = Bits;
		lsb_at  = lsb_offset;
		depth   = 1;
		zero_at = 0;
		curr    = const_cast<chunk_t*>(item.data);
		next    = nullptr;
		outline = &group;
		attrs   = nullptr;
	}

	template<size_t Bits, class IntegerT>
	IntegerT get() const {
		assert(width == Bits && depth == 1);
		value<Bits> item;
		std::copy(curr, curr + value<Bits>::chunks, item.data);
		return item.template get<IntegerT>();
	}

	template<size_t Bits, class IntegerT>
	void set(IntegerT other) const {
		assert(width == Bits && depth == 1);
		value<Bits> item;
		item.template set<IntegerT>(other);
		std::copy(item.data, item.data + value<Bits>::chunks, next);
	}
};
static_assert(std::is_standard_layout<debug_item>::value, "debug_item is not compatible with C layout");

} // namespace cxxrtl

typedef struct _cxxrtl_attr_set {
	cxxrtl::metadata_map map;
} *cxxrtl_attr_set;

namespace cxxrtl {

// Representation of an attribute set in the C++ interface.
using debug_attrs = ::_cxxrtl_attr_set;

struct debug_items {
	// Debug items may be composed of multiple parts, but the attributes are shared between all of them.
	// There are additional invariants, not all of which are not checked by this code:
	// - Memories and non-memories cannot be mixed together.
	// - Bit indices (considering \`lsb_at\` and \`width\`) must not overlap.
	// - Row indices (considering \`depth\` and \`zero_at\`) must be the same.
	// - The \`INPUT\` and \`OUTPUT\` flags must be the same for all parts.
	// Other than that, the parts can be quite different, e.g. it is OK to mix a value, a wire, an alias,
	// and an outline, in the debug information for a single name in four parts.
	std::map<std::string, std::vector<debug_item>> table;
	std::map<std::string, std::unique_ptr<debug_attrs>> attrs_table;

	void add(const std::string &path, debug_item &&item, metadata_map &&item_attrs = {}) {
		assert((path.empty() || path[path.size() - 1] != ' ') && path.find("  ") == std::string::npos);
		std::unique_ptr<debug_attrs> &attrs = attrs_table[path];
		if (attrs.get() == nullptr)
			attrs = std::unique_ptr<debug_attrs>(new debug_attrs);
		for (auto attr : item_attrs)
			attrs->map.insert(attr);
		item.attrs = attrs.get();
		std::vector<debug_item> &parts = table[path];
		parts.emplace_back(item);
		std::sort(parts.begin(), parts.end(),
			[](const debug_item &a, const debug_item &b) {
				return a.lsb_at < b.lsb_at;
			});
	}

	// This overload exists to reduce excessive stack slot allocation in \`CXXRTL_EXTREMELY_COLD void debug_info()\`.
	template<class... T>
	void add(const std::string &base_path, const char *path, const char *serialized_item_attrs, T&&... args) {
		add(base_path + path, debug_item(std::forward<T>(args)...), metadata::deserialize(serialized_item_attrs));
	}

	size_t count(const std::string &path) const {
		if (table.count(path) == 0)
			return 0;
		return table.at(path).size();
	}

	const std::vector<debug_item> &at(const std::string &path) const {
		return table.at(path);
	}

	// Like \`at()\`, but operates only on single-part debug items.
	const debug_item &operator [](const std::string &path) const {
		const std::vector<debug_item> &parts = table.at(path);
		assert(parts.size() == 1);
		return parts.at(0);
	}

	bool is_memory(const std::string &path) const {
		return at(path).at(0).type == debug_item::MEMORY;
	}

	const metadata_map &attrs(const std::string &path) const {
		return attrs_table.at(path)->map;
	}
};

// Only \`module\` scopes are defined. The type is implicit, since Yosys does not currently support
// any other scope types.
struct debug_scope {
	std::string module_name;
	std::unique_ptr<debug_attrs> module_attrs;
	std::unique_ptr<debug_attrs> cell_attrs;
};

struct debug_scopes {
	std::map<std::string, debug_scope> table;

	void add(const std::string &path, const std::string &module_name, metadata_map &&module_attrs, metadata_map &&cell_attrs) {
		assert((path.empty() || path[path.size() - 1] != ' ') && path.find("  ") == std::string::npos);
		assert(table.count(path) == 0);
		debug_scope &scope = table[path];
		scope.module_name = module_name;
		scope.module_attrs = std::unique_ptr<debug_attrs>(new debug_attrs { module_attrs });
		scope.cell_attrs = std::unique_ptr<debug_attrs>(new debug_attrs { cell_attrs });
	}

	// This overload exists to reduce excessive stack slot allocation in \`CXXRTL_EXTREMELY_COLD void debug_info()\`.
	void add(const std::string &base_path, const char *path, const char *module_name, const char *serialized_module_attrs, const char *serialized_cell_attrs) {
		add(base_path + path, module_name, metadata::deserialize(serialized_module_attrs), metadata::deserialize(serialized_cell_attrs));
	}

	size_t contains(const std::string &path) const {
		return table.count(path);
	}

	const debug_scope &operator [](const std::string &path) const {
		return table.at(path);
	}
};

// Tag class to disambiguate the default constructor used by the toplevel module that calls \`reset()\`,
// and the constructor of interior modules that should not call it.
struct interior {};

// The core API of the \`module\` class consists of only four virtual methods: \`reset()\`, \`eval()\`,
// \`commit\`, and \`debug_info()\`. (The virtual destructor is made necessary by C++.) Every other method
// is a convenience method, and exists solely to simplify some common pattern for C++ API consumers.
// No behavior may be added to such convenience methods that other parts of CXXRTL can rely on, since
// there is no guarantee they will be called (and, for example, other CXXRTL libraries will often call
// the \`eval()\` and \`commit()\` directly instead, as well as being exposed in the C API).
struct module {
	module() {}
	virtual ~module() {}

	// Modules with black boxes cannot be copied. Although not all designs include black boxes,
	// delete the copy constructor and copy assignment operator to make sure that any downstream
	// code that manipulates modules doesn't accidentally depend on their availability.
	module(const module &) = delete;
	module &operator=(const module &) = delete;

	module(module &&) = default;
	module &operator=(module &&) = default;

	virtual void reset() = 0;

	// The \`eval()\` callback object, \`performer\`, is included in the virtual call signature since
	// the generated code has broadly identical performance properties.
	virtual bool eval(performer *performer = nullptr) = 0;

	// The \`commit()\` callback object, \`observer\`, is not included in the virtual call signature since
	// the generated code is severely pessimized by it. To observe commit events, the non-virtual
	// \`commit(observer *)\` overload must be called directly on a \`module\` subclass.
	virtual bool commit() = 0;

	size_t step(performer *performer = nullptr) {
		size_t deltas = 0;
		bool converged = false;
		do {
			converged = eval(performer);
			deltas++;
		} while (commit() && !converged);
		return deltas;
	}

	virtual void debug_info(debug_items *items, debug_scopes *scopes, std::string path, metadata_map &&cell_attrs = {}) {
		(void)items, (void)scopes, (void)path, (void)cell_attrs;
	}

	// Compatibility method.
#if __has_attribute(deprecated)
	__attribute__((deprecated("Use \`debug_info(path, &items, /*scopes=*/nullptr);\` instead. (\`path\` could be \\"top \\".)")))
#endif
	void debug_info(debug_items &items, std::string path) {
		debug_info(&items, /*scopes=*/nullptr, path);
	}
};

} // namespace cxxrtl

// Internal structures used to communicate with the implementation of the C interface.

typedef struct _cxxrtl_toplevel {
	std::unique_ptr<cxxrtl::module> module;
} *cxxrtl_toplevel;

typedef struct _cxxrtl_outline {
	std::function<void()> eval;
} *cxxrtl_outline;

// Definitions of internal Yosys cells. Other than the functions in this namespace, CXXRTL is fully generic
// and indepenent of Yosys implementation details.
//
// The \`write_cxxrtl\` pass translates internal cells (cells with names that start with \`$\`) to calls of these
// functions. All of Yosys arithmetic and logical cells perform sign or zero extension on their operands,
// whereas basic operations on arbitrary width values require operands to be of the same width. These functions
// bridge the gap by performing the necessary casts. They are named similar to \`cell_A[B]\`, where A and B are \`u\`
// if the corresponding operand is unsigned, and \`s\` if it is signed.
namespace cxxrtl_yosys {

using namespace cxxrtl;

// std::max isn't constexpr until C++14 for no particular reason (it's an oversight), so we define our own.
template<class T>
CXXRTL_ALWAYS_INLINE
constexpr T max(const T &a, const T &b) {
	return a > b ? a : b;
}

// Logic operations
template<size_t BitsY, size_t BitsA>
CXXRTL_ALWAYS_INLINE
value<BitsY> logic_not(const value<BitsA> &a) {
	return value<BitsY> { a ? 0u : 1u };
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> logic_and(const value<BitsA> &a, const value<BitsB> &b) {
	return value<BitsY> { (bool(a) && bool(b)) ? 1u : 0u };
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> logic_or(const value<BitsA> &a, const value<BitsB> &b) {
	return value<BitsY> { (bool(a) || bool(b)) ? 1u : 0u };
}

// Reduction operations
template<size_t BitsY, size_t BitsA>
CXXRTL_ALWAYS_INLINE
value<BitsY> reduce_and(const value<BitsA> &a) {
	return value<BitsY> { a.bit_not().is_zero() ? 1u : 0u };
}

template<size_t BitsY, size_t BitsA>
CXXRTL_ALWAYS_INLINE
value<BitsY> reduce_or(const value<BitsA> &a) {
	return value<BitsY> { a ? 1u : 0u };
}

template<size_t BitsY, size_t BitsA>
CXXRTL_ALWAYS_INLINE
value<BitsY> reduce_xor(const value<BitsA> &a) {
	return value<BitsY> { (a.ctpop() % 2) ? 1u : 0u };
}

template<size_t BitsY, size_t BitsA>
CXXRTL_ALWAYS_INLINE
value<BitsY> reduce_xnor(const value<BitsA> &a) {
	return value<BitsY> { (a.ctpop() % 2) ? 0u : 1u };
}

template<size_t BitsY, size_t BitsA>
CXXRTL_ALWAYS_INLINE
value<BitsY> reduce_bool(const value<BitsA> &a) {
	return value<BitsY> { a ? 1u : 0u };
}

// Bitwise operations
template<size_t BitsY, size_t BitsA>
CXXRTL_ALWAYS_INLINE
value<BitsY> not_u(const value<BitsA> &a) {
	return a.template zcast<BitsY>().bit_not();
}

template<size_t BitsY, size_t BitsA>
CXXRTL_ALWAYS_INLINE
value<BitsY> not_s(const value<BitsA> &a) {
	return a.template scast<BitsY>().bit_not();
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> and_uu(const value<BitsA> &a, const value<BitsB> &b) {
	return a.template zcast<BitsY>().bit_and(b.template zcast<BitsY>());
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> and_ss(const value<BitsA> &a, const value<BitsB> &b) {
	return a.template scast<BitsY>().bit_and(b.template scast<BitsY>());
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> or_uu(const value<BitsA> &a, const value<BitsB> &b) {
	return a.template zcast<BitsY>().bit_or(b.template zcast<BitsY>());
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> or_ss(const value<BitsA> &a, const value<BitsB> &b) {
	return a.template scast<BitsY>().bit_or(b.template scast<BitsY>());
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> xor_uu(const value<BitsA> &a, const value<BitsB> &b) {
	return a.template zcast<BitsY>().bit_xor(b.template zcast<BitsY>());
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> xor_ss(const value<BitsA> &a, const value<BitsB> &b) {
	return a.template scast<BitsY>().bit_xor(b.template scast<BitsY>());
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> xnor_uu(const value<BitsA> &a, const value<BitsB> &b) {
	return a.template zcast<BitsY>().bit_xor(b.template zcast<BitsY>()).bit_not();
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> xnor_ss(const value<BitsA> &a, const value<BitsB> &b) {
	return a.template scast<BitsY>().bit_xor(b.template scast<BitsY>()).bit_not();
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> shl_uu(const value<BitsA> &a, const value<BitsB> &b) {
	return a.template zcast<BitsY>().shl(b);
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> shl_su(const value<BitsA> &a, const value<BitsB> &b) {
	return a.template scast<BitsY>().shl(b);
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> sshl_uu(const value<BitsA> &a, const value<BitsB> &b) {
	return a.template zcast<BitsY>().shl(b);
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> sshl_su(const value<BitsA> &a, const value<BitsB> &b) {
	return a.template scast<BitsY>().shl(b);
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> shr_uu(const value<BitsA> &a, const value<BitsB> &b) {
	return a.shr(b).template zcast<BitsY>();
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> shr_su(const value<BitsA> &a, const value<BitsB> &b) {
	return a.shr(b).template scast<BitsY>();
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> sshr_uu(const value<BitsA> &a, const value<BitsB> &b) {
	return a.shr(b).template zcast<BitsY>();
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> sshr_su(const value<BitsA> &a, const value<BitsB> &b) {
	return a.sshr(b).template scast<BitsY>();
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> shift_uu(const value<BitsA> &a, const value<BitsB> &b) {
	return shr_uu<BitsY>(a, b);
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> shift_su(const value<BitsA> &a, const value<BitsB> &b) {
	return shr_su<BitsY>(a, b);
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> shift_us(const value<BitsA> &a, const value<BitsB> &b) {
	return b.is_neg() ? shl_uu<BitsY>(a, b.template sext<BitsB + 1>().neg()) : shr_uu<BitsY>(a, b);
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> shift_ss(const value<BitsA> &a, const value<BitsB> &b) {
	return b.is_neg() ? shl_su<BitsY>(a, b.template sext<BitsB + 1>().neg()) : shr_su<BitsY>(a, b);
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> shiftx_uu(const value<BitsA> &a, const value<BitsB> &b) {
	return shift_uu<BitsY>(a, b);
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> shiftx_su(const value<BitsA> &a, const value<BitsB> &b) {
	return shift_su<BitsY>(a, b);
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> shiftx_us(const value<BitsA> &a, const value<BitsB> &b) {
	return shift_us<BitsY>(a, b);
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> shiftx_ss(const value<BitsA> &a, const value<BitsB> &b) {
	return shift_ss<BitsY>(a, b);
}

// Comparison operations
template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> eq_uu(const value<BitsA> &a, const value<BitsB> &b) {
	constexpr size_t BitsExt = max(BitsA, BitsB);
	return value<BitsY>{ a.template zext<BitsExt>() == b.template zext<BitsExt>() ? 1u : 0u };
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> eq_ss(const value<BitsA> &a, const value<BitsB> &b) {
	constexpr size_t BitsExt = max(BitsA, BitsB);
	return value<BitsY>{ a.template sext<BitsExt>() == b.template sext<BitsExt>() ? 1u : 0u };
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> ne_uu(const value<BitsA> &a, const value<BitsB> &b) {
	constexpr size_t BitsExt = max(BitsA, BitsB);
	return value<BitsY>{ a.template zext<BitsExt>() != b.template zext<BitsExt>() ? 1u : 0u };
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> ne_ss(const value<BitsA> &a, const value<BitsB> &b) {
	constexpr size_t BitsExt = max(BitsA, BitsB);
	return value<BitsY>{ a.template sext<BitsExt>() != b.template sext<BitsExt>() ? 1u : 0u };
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> eqx_uu(const value<BitsA> &a, const value<BitsB> &b) {
	return eq_uu<BitsY>(a, b);
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> eqx_ss(const value<BitsA> &a, const value<BitsB> &b) {
	return eq_ss<BitsY>(a, b);
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> nex_uu(const value<BitsA> &a, const value<BitsB> &b) {
	return ne_uu<BitsY>(a, b);
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> nex_ss(const value<BitsA> &a, const value<BitsB> &b) {
	return ne_ss<BitsY>(a, b);
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> gt_uu(const value<BitsA> &a, const value<BitsB> &b) {
	constexpr size_t BitsExt = max(BitsA, BitsB);
	return value<BitsY> { b.template zext<BitsExt>().ucmp(a.template zext<BitsExt>()) ? 1u : 0u };
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> gt_ss(const value<BitsA> &a, const value<BitsB> &b) {
	constexpr size_t BitsExt = max(BitsA, BitsB);
	return value<BitsY> { b.template sext<BitsExt>().scmp(a.template sext<BitsExt>()) ? 1u : 0u };
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> ge_uu(const value<BitsA> &a, const value<BitsB> &b) {
	constexpr size_t BitsExt = max(BitsA, BitsB);
	return value<BitsY> { !a.template zext<BitsExt>().ucmp(b.template zext<BitsExt>()) ? 1u : 0u };
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> ge_ss(const value<BitsA> &a, const value<BitsB> &b) {
	constexpr size_t BitsExt = max(BitsA, BitsB);
	return value<BitsY> { !a.template sext<BitsExt>().scmp(b.template sext<BitsExt>()) ? 1u : 0u };
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> lt_uu(const value<BitsA> &a, const value<BitsB> &b) {
	constexpr size_t BitsExt = max(BitsA, BitsB);
	return value<BitsY> { a.template zext<BitsExt>().ucmp(b.template zext<BitsExt>()) ? 1u : 0u };
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> lt_ss(const value<BitsA> &a, const value<BitsB> &b) {
	constexpr size_t BitsExt = max(BitsA, BitsB);
	return value<BitsY> { a.template sext<BitsExt>().scmp(b.template sext<BitsExt>()) ? 1u : 0u };
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> le_uu(const value<BitsA> &a, const value<BitsB> &b) {
	constexpr size_t BitsExt = max(BitsA, BitsB);
	return value<BitsY> { !b.template zext<BitsExt>().ucmp(a.template zext<BitsExt>()) ? 1u : 0u };
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> le_ss(const value<BitsA> &a, const value<BitsB> &b) {
	constexpr size_t BitsExt = max(BitsA, BitsB);
	return value<BitsY> { !b.template sext<BitsExt>().scmp(a.template sext<BitsExt>()) ? 1u : 0u };
}

// Arithmetic operations
template<size_t BitsY, size_t BitsA>
CXXRTL_ALWAYS_INLINE
value<BitsY> pos_u(const value<BitsA> &a) {
	return a.template zcast<BitsY>();
}

template<size_t BitsY, size_t BitsA>
CXXRTL_ALWAYS_INLINE
value<BitsY> pos_s(const value<BitsA> &a) {
	return a.template scast<BitsY>();
}

template<size_t BitsY, size_t BitsA>
CXXRTL_ALWAYS_INLINE
value<BitsY> neg_u(const value<BitsA> &a) {
	return a.template zcast<BitsY>().neg();
}

template<size_t BitsY, size_t BitsA>
CXXRTL_ALWAYS_INLINE
value<BitsY> neg_s(const value<BitsA> &a) {
	return a.template scast<BitsY>().neg();
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> add_uu(const value<BitsA> &a, const value<BitsB> &b) {
	return a.template zcast<BitsY>().add(b.template zcast<BitsY>());
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> add_ss(const value<BitsA> &a, const value<BitsB> &b) {
	return a.template scast<BitsY>().add(b.template scast<BitsY>());
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> sub_uu(const value<BitsA> &a, const value<BitsB> &b) {
	return a.template zcast<BitsY>().sub(b.template zcast<BitsY>());
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> sub_ss(const value<BitsA> &a, const value<BitsB> &b) {
	return a.template scast<BitsY>().sub(b.template scast<BitsY>());
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> mul_uu(const value<BitsA> &a, const value<BitsB> &b) {
	constexpr size_t BitsM = BitsA >= BitsB ? BitsA : BitsB;
	return a.template zcast<BitsM>().template mul<BitsY>(b.template zcast<BitsM>());
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> mul_ss(const value<BitsA> &a, const value<BitsB> &b) {
	return a.template scast<BitsY>().template mul<BitsY>(b.template scast<BitsY>());
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
std::pair<value<BitsY>, value<BitsY>> divmod_uu(const value<BitsA> &a, const value<BitsB> &b) {
	constexpr size_t Bits = max(BitsY, max(BitsA, BitsB));
	value<Bits> quotient;
	value<Bits> remainder;
	value<Bits> dividend = a.template zext<Bits>();
	value<Bits> divisor = b.template zext<Bits>();
	std::tie(quotient, remainder) = dividend.udivmod(divisor);
	return {quotient.template trunc<BitsY>(), remainder.template trunc<BitsY>()};
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
std::pair<value<BitsY>, value<BitsY>> divmod_ss(const value<BitsA> &a, const value<BitsB> &b) {
	constexpr size_t Bits = max(BitsY, max(BitsA, BitsB));
	value<Bits> quotient;
	value<Bits> remainder;
	value<Bits> dividend = a.template sext<Bits>();
	value<Bits> divisor = b.template sext<Bits>();
	std::tie(quotient, remainder) = dividend.sdivmod(divisor);
	return {quotient.template trunc<BitsY>(), remainder.template trunc<BitsY>()};
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> div_uu(const value<BitsA> &a, const value<BitsB> &b) {
	return divmod_uu<BitsY>(a, b).first;
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> div_ss(const value<BitsA> &a, const value<BitsB> &b) {
	return divmod_ss<BitsY>(a, b).first;
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> mod_uu(const value<BitsA> &a, const value<BitsB> &b) {
	return divmod_uu<BitsY>(a, b).second;
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> mod_ss(const value<BitsA> &a, const value<BitsB> &b) {
	return divmod_ss<BitsY>(a, b).second;
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> modfloor_uu(const value<BitsA> &a, const value<BitsB> &b) {
	return divmod_uu<BitsY>(a, b).second;
}

// GHDL Modfloor operator. Returns r=a mod b, such that r has the same sign as b and
// a=b*N+r where N is some integer
// In practical terms, when a and b have different signs and the remainder returned by divmod_ss is not 0
// then return the remainder + b
template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> modfloor_ss(const value<BitsA> &a, const value<BitsB> &b) {
	value<BitsY> r;
	r = divmod_ss<BitsY>(a, b).second;
	if((b.is_neg() != a.is_neg()) && !r.is_zero())
		return add_ss<BitsY>(b, r);
	return r;
}

template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> divfloor_uu(const value<BitsA> &a, const value<BitsB> &b) {
	return divmod_uu<BitsY>(a, b).first;
}

// Divfloor. Similar to above: returns q=a//b, where q has the sign of a*b and a=b*q+N.
// In other words, returns (truncating) a/b, except if a and b have different signs
// and there's non-zero remainder, subtract one more towards floor.
template<size_t BitsY, size_t BitsA, size_t BitsB>
CXXRTL_ALWAYS_INLINE
value<BitsY> divfloor_ss(const value<BitsA> &a, const value<BitsB> &b) {
	value<BitsY> q, r;
	std::tie(q, r) = divmod_ss<BitsY>(a, b);
	if ((b.is_neg() != a.is_neg()) && !r.is_zero())
		return sub_uu<BitsY>(q, value<1> { 1u });
	return q;

}

// Memory helper
struct memory_index {
	bool valid;
	size_t index;

	template<size_t BitsAddr>
	memory_index(const value<BitsAddr> &addr, size_t offset, size_t depth) {
		static_assert(value<BitsAddr>::chunks <= 1, "memory address is too wide");
		size_t offset_index = addr.data[0];

		valid = (offset_index >= offset && offset_index < offset + depth);
		index = offset_index - offset;
	}
};

} // namespace cxxrtl_yosys

#endif
`,"cxxrtl_replay.h":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2023  Catherine <whitequark@whitequark.org>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef CXXRTL_REPLAY_H
#define CXXRTL_REPLAY_H

#if !defined(WIN32)
#include <unistd.h>
#define O_BINARY 0
#else
#include <io.h>
#endif

#include <fcntl.h>
#include <cstring>
#include <cstdio>
#include <atomic>
#include <unordered_map>

#include <cxxrtl/cxxrtl.h>
#include <cxxrtl/cxxrtl_time.h>

// Theory of operation
// ===================
//
// Log format
// ----------
//
// The replay log is a simple data format based on a sequence of 32-bit words. The following BNF-like grammar describes
// enough detail to understand the overall structure of the log data and be able to read hex dumps. For a greater
// degree of detail see the source code. The format is considered fully internal to CXXRTL and is subject to change
// without notice.
//
// <file>           ::= <file-header> <definitions> <sample>+
// <file-header>    ::= 0x52585843 0x00004c54
// <definitions>    ::= <packet-define>* <packet-end>
// <sample>         ::= <packet-sample> (<packet-change> | <packet-diag>)* <packet-end>
// <packet-define>  ::= 0xc0000000 ...
// <packet-sample>  ::= 0xc0000001 ...
// <packet-change>  ::= 0x0??????? <chunk>+ | 0x1??????? <index> <chunk>+ | 0x2??????? | 0x3???????
// <chunk>, <index> ::= 0x????????
// <packet-diag>    ::= <packet-break> | <packet-print> | <packet-assert> | <packet-assume>
// <packet-break>   ::= 0xc0000010 <message> <source-location>
// <packet-print>   ::= 0xc0000011 <message> <source-location>
// <packet-assert>  ::= 0xc0000012 <message> <source-location>
// <packet-assume>  ::= 0xc0000013 <message> <source-location>
// <packet-end>     ::= 0xFFFFFFFF
//
// The replay log contains sample data, however, it does not cover the entire design. Rather, it only contains sample
// data for the subset of debug items containing _design state_: inputs and registers/latches. This keeps its size to
// a minimum, and recording speed to a maximum. The player samples any missing data by setting the design state items
// to the same values they had during recording, and re-evaluating the design.
//
// Packets for diagnostics (prints, breakpoints, assertions, and assumptions) are used solely for diagnostics emitted
// by the C++ testbench driving the simulation, and are not recorded while evaluating the design. (Diagnostics emitted
// by the RTL can be reconstructed at replay time, so recording them would be a waste of space.)
//
// Limits
// ------
//
// The log may contain:
//
// * Up to 2**28-1 debug items containing design state.
// * Up to 2**32 chunks per debug item.
// * Up to 2**32 rows per memory.
// * Up to 2**32 samples.
//
// Of these limits, the last two are most likely to be eventually exceeded by practical recordings. However, other
// performance considerations will likely limit the size of such practical recordings first, so the log data format
// will undergo a breaking change at that point.
//
// Operations
// ----------
//
// As suggested by the name "replay log", this format is designed for recording (writing) once and playing (reading)
// many times afterwards, such that reading the format can be done linearly and quickly. The log format is designed to
// support three primary read operations:
//
// 1. Initialization
// 2. Rewinding (to time T)
// 3. Replaying (for N samples)
//
// During initialization, the player establishes the mapping between debug item names and their 28-bit identifiers in
// the log. It is done once.
//
// During rewinding, the player begins reading at the latest non-incremental sample that still lies before the requested
// sample time. It continues reading incremental samples after that point until it reaches the requested sample time.
// This process is very cheap as the design is not evaluated; it is essentially a (convoluted) memory copy operation.
//
// During replaying, the player evaluates the design at the current time, which causes all debug items to assume
// the values they had before recording. This process is expensive. Once done, the player advances to the next state
// by reading the next (complete or incremental) sample, as above. Since a range of samples is replayed, this process
// is repeated several times in a row.
//
// In principle, when replaying, the player could only read the state of the inputs and the time delta and use a normal
// eval/commit loop to progress the simulation, which is fully deterministic so its calculated design state should be
// exactly the same as the recorded design state. In practice, it is both faster and more reliable (in presence of e.g.
// user-defined black boxes) to read the recorded values instead of calculating them.
//
// Note: The operations described above are conceptual and do not correspond exactly to methods on \`cxxrtl::player\`.
// The \`cxxrtl::player::replay()\` method does not evaluate the design. This is so that delta cycles could be ignored
// if they are not of interest while replaying.

namespace cxxrtl {

// A single diagnostic that can be manipulated as an object (including being written to and read from a file).
// This differs from the base CXXRTL interface, where diagnostics can only be emitted via a procedure call, and are
// not materialized as objects.
struct diagnostic {
	// The \`BREAK\` flavor corresponds to a breakpoint, which is a diagnostic type that can currently only be emitted
	// by the C++ testbench code.
	enum flavor {
		BREAK  = 0,
		PRINT  = 1,
		ASSERT = 2,
		ASSUME = 3,
	};

	flavor type;
	std::string message;
	std::string location; // same format as the \`src\` attribute of \`$print\` or \`$check\` cell

	diagnostic()
	: type(BREAK) {}

	diagnostic(flavor type, const std::string &message, const std::string &location)
	: type(type), message(message), location(location) {}

	diagnostic(flavor type, const std::string &message, const char *file, unsigned line)
	: type(type), message(message), location(std::string(file) + ':' + std::to_string(line)) {}
};

// A spool stores CXXRTL design state changes in a file.
class spool {
public:
	// Unique pointer to a specific sample within a replay log. (Timestamps are not unique.)
	typedef uint32_t pointer_t;

	// Numeric identifier assigned to a debug item within a replay log. Range limited to [1, MAXIMUM_IDENT].
	typedef uint32_t ident_t;

	static constexpr uint16_t VERSION = 0x0400;

	static constexpr uint64_t HEADER_MAGIC = 0x00004c5452585843;
	static constexpr uint64_t VERSION_MASK = 0xffff000000000000;

	static constexpr uint32_t PACKET_DEFINE  = 0xc0000000;

	static constexpr uint32_t PACKET_SAMPLE  = 0xc0000001;
	enum sample_flag : uint32_t {
		EMPTY       = 0,
		INCREMENTAL = 1,
	};

	static constexpr uint32_t MAXIMUM_IDENT  = 0x0fffffff;
	static constexpr uint32_t CHANGE_MASK    = 0x30000000;

	static constexpr uint32_t PACKET_CHANGE  = 0x00000000/* | ident */;
	static constexpr uint32_t PACKET_CHANGEI = 0x10000000/* | ident */;
	static constexpr uint32_t PACKET_CHANGEL = 0x20000000/* | ident */;
	static constexpr uint32_t PACKET_CHANGEH = 0x30000000/* | ident */;

	static constexpr uint32_t PACKET_DIAGNOSTIC = 0xc0000010/* | diagnostic::flavor */;
	static constexpr uint32_t DIAGNOSTIC_MASK   = 0x0000000f;

	static constexpr uint32_t PACKET_END     = 0xffffffff;

	// Writing spools.

	class writer {
		int fd;
		size_t position;
		std::vector<uint32_t> buffer;

		// These functions aren't overloaded because of implicit numeric conversions.

		void emit_word(uint32_t word) {
			if (position + 1 == buffer.size())
				flush();
			buffer[position++] = word;
		}

		void emit_dword(uint64_t dword) {
			emit_word(dword >>  0);
			emit_word(dword >> 32);
		}

		void emit_ident(ident_t ident) {
			assert(ident <= MAXIMUM_IDENT);
			emit_word(ident);
		}

		void emit_size(size_t size) {
			assert(size <= std::numeric_limits<uint32_t>::max());
			emit_word(size);
		}

		// Same implementation as \`emit_size()\`, different declared intent.
		void emit_index(size_t index) {
			assert(index <= std::numeric_limits<uint32_t>::max());
			emit_word(index);
		}

		void emit_string(std::string str) {
			// Align to a word boundary, and add at least one terminating \\0.
			str.resize(str.size() + (sizeof(uint32_t) - (str.size() + sizeof(uint32_t)) % sizeof(uint32_t)));
			for (size_t index = 0; index < str.size(); index += sizeof(uint32_t)) {
				uint32_t word;
				memcpy(&word, &str[index], sizeof(uint32_t));
				emit_word(word);
			}
		}

		void emit_time(const time &timestamp) {
			const value<time::bits> &raw_timestamp(timestamp);
			emit_word(raw_timestamp.data[0]);
			emit_word(raw_timestamp.data[1]);
			emit_word(raw_timestamp.data[2]);
		}

	public:
		// Creates a writer, and transfers ownership of \`fd\`, which must be open for appending.
		//
		// The buffer size is currently fixed to a "reasonably large" size, determined empirically by measuring writer
		// performance on a representative design; large but not so large it would e.g. cause address space exhaustion
		// on 32-bit platforms.
		writer(spool &spool) : fd(spool.take_write()), position(0), buffer(32 * 1024 * 1024) {
			assert(fd != -1);
#if !defined(WIN32)
			int result = ftruncate(fd, 0);
#else
			int result = _chsize_s(fd, 0);
#endif
			assert(result == 0);
		}

		writer(writer &&moved) : fd(moved.fd), position(moved.position), buffer(moved.buffer) {
			moved.fd = -1;
			moved.position = 0;
		}

		writer(const writer &) = delete;
		writer &operator=(const writer &) = delete;

		// Both write() calls and fwrite() calls are too expensive to perform implicitly. The API consumer must determine
		// the optimal time to flush the writer and do that explicitly for best performance.
		void flush() {
			assert(fd != -1);
			size_t data_size = position * sizeof(uint32_t);
			size_t data_written = write(fd, buffer.data(), data_size);
			assert(data_size == data_written);
			position = 0;
		}

		~writer() {
			if (fd != -1) {
				flush();
				close(fd);
			}
		}

		void write_magic() {
			// \`CXXRTL\` followed by version in binary. This header will read backwards on big-endian machines, which allows
			// detection of this case, both visually and programmatically.
			emit_dword(((uint64_t)VERSION << 48) | HEADER_MAGIC);
		}

		void write_define(ident_t ident, const std::string &name, size_t part_index, size_t chunks, size_t depth) {
			emit_word(PACKET_DEFINE);
			emit_ident(ident);
			emit_string(name);
			emit_index(part_index);
			emit_size(chunks);
			emit_size(depth);
		}

		void write_sample(bool incremental, pointer_t pointer, const time &timestamp) {
			uint32_t flags = (incremental ? sample_flag::INCREMENTAL : 0);
			emit_word(PACKET_SAMPLE);
			emit_word(flags);
			emit_word(pointer);
			emit_time(timestamp);
		}

		void write_change(ident_t ident, size_t chunks, const chunk_t *data) {
			assert(ident <= MAXIMUM_IDENT);

			if (chunks == 1 && *data == 0) {
				emit_word(PACKET_CHANGEL | ident);
			} else if (chunks == 1 && *data == 1) {
				emit_word(PACKET_CHANGEH | ident);
			} else {
				emit_word(PACKET_CHANGE | ident);
				for (size_t offset = 0; offset < chunks; offset++)
					emit_word(data[offset]);
			}
		}

		void write_change(ident_t ident, size_t chunks, const chunk_t *data, size_t index) {
			assert(ident <= MAXIMUM_IDENT);

			emit_word(PACKET_CHANGEI | ident);
			emit_index(index);
			for (size_t offset = 0; offset < chunks; offset++)
				emit_word(data[offset]);
		}

		void write_diagnostic(const diagnostic &diagnostic) {
			emit_word(PACKET_DIAGNOSTIC | diagnostic.type);
			emit_string(diagnostic.message);
			emit_string(diagnostic.location);
		}

		void write_end() {
			emit_word(PACKET_END);
		}
	};

	// Reading spools.

	class reader {
		FILE *f;

		uint32_t absorb_word() {
			// If we're at end of file, \`fread\` will not write to \`word\`, and \`PACKET_END\` will be returned.
			uint32_t word = PACKET_END;
			fread(&word, sizeof(word), 1, f);
			return word;
		}

		uint64_t absorb_dword() {
			uint32_t lo = absorb_word();
			uint32_t hi = absorb_word();
			return ((uint64_t)hi << 32) | lo;
		}

		ident_t absorb_ident() {
			ident_t ident = absorb_word();
			assert(ident <= MAXIMUM_IDENT);
			return ident;
		}

		size_t absorb_size() {
			return absorb_word();
		}

		size_t absorb_index() {
			return absorb_word();
		}

		std::string absorb_string() {
			std::string str;
			do {
				size_t end = str.size();
				str.resize(end + 4);
				uint32_t word = absorb_word();
				memcpy(&str[end], &word, sizeof(uint32_t));
			} while (str.back() != '\\0');
			// Strings have no embedded zeroes besides the terminating one(s).
			return str.substr(0, str.find('\\0'));
		}

		time absorb_time() {
			value<time::bits> raw_timestamp;
			raw_timestamp.data[0] = absorb_word();
			raw_timestamp.data[1] = absorb_word();
			raw_timestamp.data[2] = absorb_word();
			return time(raw_timestamp);
		}

	public:
		typedef uint64_t pos_t;

		// Creates a reader, and transfers ownership of \`fd\`, which must be open for reading.
		reader(spool &spool) : f(fdopen(spool.take_read(), "r")) {
			assert(f != nullptr);
		}

		reader(reader &&moved) : f(moved.f) {
			moved.f = nullptr;
		}

		reader(const reader &) = delete;
		reader &operator=(const reader &) = delete;

		~reader() {
			if (f != nullptr)
				fclose(f);
		}

		pos_t position() {
			return ftell(f);
		}

		void rewind(pos_t position) {
			fseek(f, position, SEEK_SET);
		}

		void read_magic() {
			uint64_t magic = absorb_dword();
			assert((magic & ~VERSION_MASK) == HEADER_MAGIC);
			assert((magic >> 48) == VERSION);
		}

		bool read_define(ident_t &ident, std::string &name, size_t &part_index, size_t &chunks, size_t &depth) {
			uint32_t header = absorb_word();
			if (header == PACKET_END)
				return false;
			assert(header == PACKET_DEFINE);
			ident = absorb_ident();
			name = absorb_string();
			part_index = absorb_index();
			chunks = absorb_size();
			depth = absorb_size();
			return true;
		}

		bool read_sample(bool &incremental, pointer_t &pointer, time &timestamp) {
			uint32_t header = absorb_word();
			if (header == PACKET_END)
				return false;
			assert(header == PACKET_SAMPLE);
			uint32_t flags = absorb_word();
			incremental = (flags & sample_flag::INCREMENTAL);
			pointer = absorb_word();
			timestamp = absorb_time();
			return true;
		}

		bool read_header(uint32_t &header) {
			header = absorb_word();
			return header != PACKET_END;
		}

		// This method must be separate from \`read_change_data\` because \`chunks\` and \`depth\` can only be looked up
		// if \`ident\` is known.
		bool read_change_ident(uint32_t header, ident_t &ident) {
			if ((header & ~(CHANGE_MASK | MAXIMUM_IDENT)) != 0)
				return false; // some other packet
			ident = header & MAXIMUM_IDENT;
			return true;
		}

		void read_change_data(uint32_t header, size_t chunks, size_t depth, chunk_t *data) {
			uint32_t index = 0;
			switch (header & CHANGE_MASK) {
				case PACKET_CHANGEL:
					*data = 0;
					return;
				case PACKET_CHANGEH:
					*data = 1;
					return;
				case PACKET_CHANGE:
					break;
				case PACKET_CHANGEI:
					index = absorb_word();
					assert(index < depth);
					break;
				default:
					assert(false && "Unrecognized change packet");
			}
			for (size_t offset = 0; offset < chunks; offset++)
				data[chunks * index + offset] = absorb_word();
		}

		bool read_diagnostic(uint32_t header, diagnostic &diagnostic) {
			if ((header & ~DIAGNOSTIC_MASK) != PACKET_DIAGNOSTIC)
				return false; // some other packet
			uint32_t type = header & DIAGNOSTIC_MASK;
			assert(type == diagnostic::BREAK  || type == diagnostic::PRINT ||
			       type == diagnostic::ASSERT || type == diagnostic::ASSUME);
			diagnostic.type = (diagnostic::flavor)type;
			diagnostic.message = absorb_string();
			diagnostic.location = absorb_string();
			return true;
		}
	};

	// Opening spools. For certain uses of the record/replay mechanism, two distinct open files (two open files, i.e.
	// two distinct file pointers, and not just file descriptors, which share the file pointer if duplicated) are used,
	// for a reader and writer thread. This class manages the lifetime of the descriptors for these files. When only
	// one of them is used, the other is closed harmlessly when the spool is destroyed.
private:
	std::atomic<int> writefd;
	std::atomic<int> readfd;

public:
	spool(const std::string &filename)
		: writefd(open(filename.c_str(), O_CREAT|O_BINARY|O_WRONLY|O_APPEND, 0644)),
		  readfd(open(filename.c_str(), O_BINARY|O_RDONLY)) {
		assert(writefd.load() != -1 && readfd.load() != -1);
	}

	spool(spool &&moved) : writefd(moved.writefd.exchange(-1)), readfd(moved.readfd.exchange(-1)) {}

	spool(const spool &) = delete;
	spool &operator=(const spool &) = delete;

	~spool() {
		int fd;
		if ((fd = writefd.exchange(-1)) != -1)
			close(fd);
		if ((fd = readfd.exchange(-1)) != -1)
			close(fd);
	}

	// Atomically acquire a write file descriptor for the spool. Can be called once, and will return -1 the next time
	// it is called. Thread-safe.
	int take_write() {
		return writefd.exchange(-1);
	}

	// Atomically acquire a read file descriptor for the spool. Can be called once, and will return -1 the next time
	// it is called. Thread-safe.
	int take_read() {
		return readfd.exchange(-1);
	}
};

// A CXXRTL recorder samples design state, producing complete or incremental updates, and writes them to a spool.
class recorder {
	struct variable {
		spool::ident_t ident; /* <= spool::MAXIMUM_IDENT */
		size_t chunks;
		size_t depth; /* == 1 for wires */
		chunk_t *curr;
		bool memory;
	};

	spool::writer writer;
	std::vector<variable> variables;
	std::vector<size_t> inputs; // values of inputs must be recorded explicitly, as their changes are not observed
	std::unordered_map<const chunk_t*, spool::ident_t> ident_lookup;
	bool streaming = false; // whether variable definitions have been written
	spool::pointer_t pointer = 0;
	time timestamp;

public:
	template<typename ...Args>
	recorder(Args &&...args) : writer(std::forward<Args>(args)...) {}

	void start(module &module, std::string top_path = "") {
		debug_items items;
		module.debug_info(&items, /*scopes=*/nullptr, top_path);
		start(items);
	}

	void start(const debug_items &items) {
		assert(!streaming);

		writer.write_magic();
		for (auto item : items.table)
			for (size_t part_index = 0; part_index < item.second.size(); part_index++) {
				auto &part = item.second[part_index];
				if ((part.flags & debug_item::INPUT) || (part.flags & debug_item::DRIVEN_SYNC) ||
						(part.type == debug_item::MEMORY)) {
					variable var;
					var.ident = variables.size() + 1;
					var.chunks = (part.width + sizeof(chunk_t) * 8 - 1) / (sizeof(chunk_t) * 8);
					var.depth = part.depth;
					var.curr = part.curr;
					var.memory = (part.type == debug_item::MEMORY);
					ident_lookup[var.curr] = var.ident;

					assert(variables.size() < spool::MAXIMUM_IDENT);
					if (part.flags & debug_item::INPUT)
						inputs.push_back(variables.size());
					variables.push_back(var);

					writer.write_define(var.ident, item.first, part_index, var.chunks, var.depth);
				}
			}
		writer.write_end();
		streaming = true;
	}

	const time &latest_time() {
		return timestamp;
	}

	const time &advance_time(const time &delta) {
		assert(!delta.is_negative());
		timestamp += delta;
		return timestamp;
	}

	void record_complete() {
		assert(streaming);

		writer.write_sample(/*incremental=*/false, pointer++, timestamp);
		for (auto var : variables) {
			assert(var.ident != 0);
			if (!var.memory)
				writer.write_change(var.ident, var.chunks, var.curr);
			else
				for (size_t index = 0; index < var.depth; index++)
					writer.write_change(var.ident, var.chunks, &var.curr[var.chunks * index], index);
		}
		writer.write_end();
	}

	// This function is generic over ModuleT to encourage observer callbacks to be inlined into the commit function.
	template<class ModuleT>
	bool record_incremental(ModuleT &module) {
		assert(streaming);

		struct : observer {
			std::unordered_map<const chunk_t*, spool::ident_t> *ident_lookup;
			spool::writer *writer;

			CXXRTL_ALWAYS_INLINE
			void on_update(size_t chunks, const chunk_t *base, const chunk_t *value) {
				writer->write_change(ident_lookup->at(base), chunks, value);
			}

			CXXRTL_ALWAYS_INLINE
			void on_update(size_t chunks, const chunk_t *base, const chunk_t *value, size_t index) {
				writer->write_change(ident_lookup->at(base), chunks, value, index);
			}
		} record_observer;
		record_observer.ident_lookup = &ident_lookup;
		record_observer.writer = &writer;

		writer.write_sample(/*incremental=*/true, pointer++, timestamp);
		for (auto input_index : inputs) {
			variable &var = variables.at(input_index);
			assert(!var.memory);
			writer.write_change(var.ident, var.chunks, var.curr);
		}
		bool changed = module.commit(record_observer);
		writer.write_end();
		return changed;
	}

	void record_diagnostic(const diagnostic &diagnostic) {
		assert(streaming);

		// Emit an incremental delta cycle per diagnostic to simplify the logic of the recorder. This is inefficient, but
		// diagnostics should be rare enough that this inefficiency does not matter. If it turns out to be an issue, this
		// code should be changed to accumulate diagnostics to a buffer that is flushed in \`record_{complete,incremental}\`
		// and also in \`advance_time\` before the timestamp is changed. (Right now \`advance_time\` never writes to the spool.)
		writer.write_sample(/*incremental=*/true, pointer++, timestamp);
		writer.write_diagnostic(diagnostic);
		writer.write_end();
	}

	void flush() {
		writer.flush();
	}
};

// A CXXRTL player reads samples from a spool, and changes the design state accordingly. To start reading samples,
// a spool must have been initialized: the recorder must have been started and an initial complete sample must have
// been written.
class player {
	struct variable {
		size_t chunks;
		size_t depth; /* == 1 for wires */
		chunk_t *curr;
	};

	spool::reader reader;
	std::unordered_map<spool::ident_t, variable> variables;
	bool streaming = false; // whether variable definitions have been read
	bool initialized = false; // whether a sample has ever been read
	spool::pointer_t pointer = 0;
	time timestamp;

	std::map<spool::pointer_t, spool::reader::pos_t, std::greater<spool::pointer_t>> index_by_pointer;
	std::map<time, spool::reader::pos_t, std::greater<time>> index_by_timestamp;

	bool peek_sample(spool::pointer_t &pointer, time &timestamp) {
		bool incremental;
		auto position = reader.position();
		bool success = reader.read_sample(incremental, pointer, timestamp);
		reader.rewind(position);
		return success;
	}

public:
	template<typename ...Args>
	player(Args &&...args) : reader(std::forward<Args>(args)...) {}

	// The \`top_path\` must match the one given to the recorder.
	void start(module &module, std::string top_path = "") {
		debug_items items;
		module.debug_info(&items, /*scopes=*/nullptr, top_path);
		start(items);
	}

	void start(const debug_items &items) {
		assert(!streaming);

		reader.read_magic();
		while (true) {
			spool::ident_t ident;
			std::string name;
			size_t part_index;
			size_t chunks;
			size_t depth;
			if (!reader.read_define(ident, name, part_index, chunks, depth))
				break;
			assert(variables.count(ident) == 0);
			assert(items.count(name) != 0);
			assert(part_index < items.count(name));

			const debug_item &part = items.at(name).at(part_index);
			assert(chunks == (part.width + sizeof(chunk_t) * 8 - 1) / (sizeof(chunk_t) * 8));
			assert(depth == part.depth);

			variable &var = variables[ident];
			var.chunks = chunks;
			var.depth = depth;
			var.curr = part.curr;
		}
		assert(variables.size() > 0);
		streaming = true;

		// Establish the initial state of the design.
		std::vector<diagnostic> diagnostics;
		initialized = replay(&diagnostics);
		assert(initialized && diagnostics.empty());
	}

	// Returns the pointer of the current sample.
	spool::pointer_t current_pointer() {
		assert(initialized);
		return pointer;
	}

	// Returns the time of the current sample.
	const time &current_time() {
		assert(initialized);
		return timestamp;
	}

	// Returns \`true\` if there is a next sample to read, and sets \`pointer\` to its pointer if there is.
	bool get_next_pointer(spool::pointer_t &pointer) {
		assert(streaming);
		time timestamp;
		return peek_sample(pointer, timestamp);
	}

	// Returns \`true\` if there is a next sample to read, and sets \`timestamp\` to its time if there is.
	bool get_next_time(time &timestamp) {
		assert(streaming);
		uint32_t pointer;
		return peek_sample(pointer, timestamp);
	}

	// If this function returns \`true\`, then \`current_pointer() == at_pointer\`, and the module contains values that
	// correspond to this pointer in the replay log. To obtain a valid pointer, call \`current_pointer()\`; while pointers
	// are monotonically increasing for each consecutive sample, using arithmetic operations to create a new pointer is
	// not allowed. The \`diagnostics\` argument, if not \`nullptr\`, receives the diagnostics recorded in this sample.
	bool rewind_to(spool::pointer_t at_pointer, std::vector<diagnostic> *diagnostics) {
		assert(initialized);

		// The pointers in the replay log start from one that is greater than \`at_pointer\`. In this case the pointer will
		// never be reached.
		assert(index_by_pointer.size() > 0);
		if (at_pointer < index_by_pointer.rbegin()->first)
			return false;

		// Find the last complete sample whose pointer is less than or equal to \`at_pointer\`. Note that the comparison
		// function used here is \`std::greater\`, inverting the direction of \`lower_bound\`.
		auto position_it = index_by_pointer.lower_bound(at_pointer);
		assert(position_it != index_by_pointer.end());
		reader.rewind(position_it->second);

		// Replay samples until eventually arriving to \`at_pointer\` or encountering end of file.
		while(replay(diagnostics)) {
			if (pointer == at_pointer)
				return true;

			if (diagnostics)
				diagnostics->clear();
		}
		return false;
	}

	// If this function returns \`true\`, then \`current_time() <= at_or_before_timestamp\`, and the module contains values
	// that correspond to \`current_time()\` in the replay log. If \`current_time() == at_or_before_timestamp\` and there
	// are several consecutive samples with the same time, the module contains values that correspond to the first of
	// these samples. The \`diagnostics\` argument, if not \`nullptr\`, receives the diagnostics recorded in this sample.
	bool rewind_to_or_before(const time &at_or_before_timestamp, std::vector<diagnostic> *diagnostics) {
		assert(initialized);

		// The timestamps in the replay log start from one that is greater than \`at_or_before_timestamp\`. In this case
		// the timestamp will never be reached. Otherwise, this function will always succeed.
		assert(index_by_timestamp.size() > 0);
		if (at_or_before_timestamp < index_by_timestamp.rbegin()->first)
			return false;

		// Find the last complete sample whose timestamp is less than or equal to \`at_or_before_timestamp\`. Note that
		// the comparison function used here is \`std::greater\`, inverting the direction of \`lower_bound\`.
		auto position_it = index_by_timestamp.lower_bound(at_or_before_timestamp);
		assert(position_it != index_by_timestamp.end());
		reader.rewind(position_it->second);

		// Replay samples until eventually arriving to or past \`at_or_before_timestamp\` or encountering end of file.
		while (replay(diagnostics)) {
			if (timestamp == at_or_before_timestamp)
				break;

			time next_timestamp;
			if (!get_next_time(next_timestamp))
				break;
			if (next_timestamp > at_or_before_timestamp)
				break;

			if (diagnostics)
				diagnostics->clear();
		}
		return true;
	}

	// If this function returns \`true\`, then \`current_pointer()\` and \`current_time()\` are updated for the next sample
	// and the module now contains values that correspond to that sample. If it returns \`false\`, there was no next sample
	// to read. The \`diagnostics\` argument, if not \`nullptr\`, receives the diagnostics recorded in the next sample.
	bool replay(std::vector<diagnostic> *diagnostics) {
		assert(streaming);

		bool incremental;
		auto position = reader.position();
		if (!reader.read_sample(incremental, pointer, timestamp))
			return false;

		// The very first sample that is read must be a complete sample. This is required for the rewind functions to work.
		assert(initialized || !incremental);

		// It is possible (though not very useful) to have several complete samples with the same timestamp in a row.
		// Ensure that we associate the timestamp with the position of the first such complete sample. (This condition
		// works because the player never jumps over a sample.)
		if (!incremental && !index_by_pointer.count(pointer)) {
			assert(!index_by_timestamp.count(timestamp));
			index_by_pointer[pointer] = position;
			index_by_timestamp[timestamp] = position;
		}

		uint32_t header;
		while (reader.read_header(header)) {
			spool::ident_t ident;
			diagnostic diag;
			if (reader.read_change_ident(header, ident)) {
				variable &var = variables.at(ident);
				reader.read_change_data(header, var.chunks, var.depth, var.curr);
			} else if (reader.read_diagnostic(header, diag)) {
				if (diagnostics)
					diagnostics->push_back(diag);
			} else assert(false && "Unrecognized packet header");
		}
		return true;
	}
};

}

#endif
`,"cxxrtl_time.h":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2023  Catherine <whitequark@whitequark.org>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef CXXRTL_TIME_H
#define CXXRTL_TIME_H

#include <cinttypes>
#include <string>

#include <cxxrtl/cxxrtl.h>

namespace cxxrtl {

// A timestamp or a difference in time, stored as a 96-bit number of femtoseconds (10e-15 s). The range and resolution
// of this format can represent any VCD timestamp within approx. \xB11255321.2 years, without the need for a timescale.
class time {
public:
	static constexpr size_t bits = 96; // 3 chunks

private:
	static constexpr size_t resolution_digits = 15;

	static_assert(sizeof(chunk_t) == 4, "a chunk is expected to be 32-bit");
	static constexpr value<bits> resolution = value<bits> {
		chunk_t(1000000000000000ull & 0xffffffffull), chunk_t(1000000000000000ull >> 32), 0u
	};

	// Signed number of femtoseconds from the beginning of time.
	value<bits> raw;

public:
	constexpr time() {}

	explicit constexpr time(const value<bits> &raw) : raw(raw) {}
	explicit operator const value<bits> &() const { return raw; }

	static constexpr time maximum() {
		return time(value<bits> { 0xffffffffu, 0xffffffffu, 0x7fffffffu });
	}

	time(int64_t secs, int64_t femtos) {
		value<64> secs_val;
		secs_val.set(secs);
		value<64> femtos_val;
		femtos_val.set(femtos);
		raw = secs_val.sext<bits>().mul<bits>(resolution).add(femtos_val.sext<bits>());
	}

	bool is_zero() const {
		return raw.is_zero();
	}

	// Extracts the sign of the value.
	bool is_negative() const {
		return raw.is_neg();
	}

	// Extracts the number of whole seconds. Negative if the value is negative.
	int64_t secs() const {
		return raw.sdivmod(resolution).first.trunc<64>().get<int64_t>();
	}

	// Extracts the number of femtoseconds in the fractional second. Negative if the value is negative.
	int64_t femtos() const {
		return raw.sdivmod(resolution).second.trunc<64>().get<int64_t>();
	}

	bool operator==(const time &other) const {
		return raw == other.raw;
	}

	bool operator!=(const time &other) const {
		return raw != other.raw;
	}

	bool operator>(const time &other) const {
		return other.raw.scmp(raw);
	}

	bool operator>=(const time &other) const {
		return !raw.scmp(other.raw);
	}

	bool operator<(const time &other) const {
		return raw.scmp(other.raw);
	}

	bool operator<=(const time &other) const {
		return !other.raw.scmp(raw);
	}

	time operator+(const time &other) const {
		return time(raw.add(other.raw));
	}

	time &operator+=(const time &other) {
		*this = *this + other;
		return *this;
	}

	time operator-() const {
		return time(raw.neg());
	}

	time operator-(const time &other) const {
		return *this + (-other);
	}

	time &operator-=(const time &other) {
		*this = *this - other;
		return *this;
	}

	operator std::string() const {
		char buf[48]; // x=2**95; len(f"-{x/1_000_000_000_000_000}.{x^1_000_000_000_000_000}") == 48
		int64_t secs = this->secs();
		int64_t femtos = this->femtos();
		snprintf(buf, sizeof(buf), "%s%" PRIi64 ".%015" PRIi64,
			is_negative() ? "-" : "", secs >= 0 ? secs : -secs, femtos >= 0 ? femtos : -femtos);
		return buf;
	}

#if __cplusplus >= 201603L
	[[nodiscard("ignoring parse errors")]]
#endif
	bool parse(const std::string &str) {
		enum {
			parse_sign_opt,
			parse_integral,
			parse_fractional,
		} state = parse_sign_opt;
		bool negative = false;
		int64_t integral = 0;
		int64_t fractional = 0;
		size_t frac_digits = 0;
		for (auto chr : str) {
			switch (state) {
				case parse_sign_opt:
					state = parse_integral;
					if (chr == '+' || chr == '-') {
						negative = (chr == '-');
						break;
					}
					/* fallthrough */
				case parse_integral:
					if (chr >= '0' && chr <= '9') {
						integral *= 10;
						integral += chr - '0';
					} else if (chr == '.') {
						state = parse_fractional;
					} else {
						return false;
					}
					break;
				case parse_fractional:
					if (chr >= '0' && chr <= '9' && frac_digits < resolution_digits) {
						fractional *= 10;
						fractional += chr - '0';
						frac_digits++;
					} else {
						return false;
					}
					break;
			}
		}
		if (frac_digits == 0)
			return false;
		while (frac_digits++ < resolution_digits)
			fractional *= 10;
		*this = negative ? -time { integral, fractional} : time { integral, fractional };
		return true;
	}
};

// Out-of-line definition required until C++17.
constexpr value<time::bits> time::resolution;

std::ostream &operator<<(std::ostream &os, const time &val) {
	os << (std::string)val;
	return os;
}

// These literals are (confusingly) compatible with the ones from \`std::chrono\`: the \`std::chrono\` literals do not
// have an underscore (e.g. 1ms) and the \`cxxrtl::time\` literals do (e.g. 1_ms). This syntactic difference is
// a requirement of the C++ standard. Despite being compatible the literals should not be mixed in the same namespace.
namespace time_literals {

time operator""_s(unsigned long long seconds) {
	return time { (int64_t)seconds, 0 };
}

time operator""_ms(unsigned long long milliseconds) {
	return time { 0, (int64_t)milliseconds * 1000000000000 };
}

time operator""_us(unsigned long long microseconds) {
	return time { 0, (int64_t)microseconds * 1000000000 };
}

time operator""_ns(unsigned long long nanoseconds) {
	return time { 0, (int64_t)nanoseconds * 1000000 };
}

time operator""_ps(unsigned long long picoseconds) {
	return time { 0, (int64_t)picoseconds * 1000 };
}

time operator""_fs(unsigned long long femtoseconds) {
	return time { 0, (int64_t)femtoseconds };
}

};

};

#endif
`,"cxxrtl_vcd.h":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2020  whitequark <whitequark@whitequark.org>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef CXXRTL_VCD_H
#define CXXRTL_VCD_H

#include <cxxrtl/cxxrtl.h>

namespace cxxrtl {

class vcd_writer {
	struct variable {
		size_t ident;
		size_t width;
		chunk_t *curr;
		size_t cache_offset;
		debug_outline *outline;
		bool *outline_warm;
	};

	std::vector<std::string> current_scope;
	std::map<debug_outline*, bool> outlines;
	std::vector<variable> variables;
	std::vector<chunk_t> cache;
	std::map<chunk_t*, size_t> aliases;
	bool streaming = false;

	void emit_timescale(unsigned number, const std::string &unit) {
		assert(!streaming);
		assert(number == 1 || number == 10 || number == 100);
		assert(unit == "s" || unit == "ms" || unit == "us" ||
		       unit == "ns" || unit == "ps" || unit == "fs");
		buffer += "$timescale " + std::to_string(number) + " " + unit + " $end\\n";
	}

	void emit_scope(const std::vector<std::string> &scope) {
		assert(!streaming);
		while (current_scope.size() > scope.size() ||
		       (current_scope.size() > 0 &&
			current_scope[current_scope.size() - 1] != scope[current_scope.size() - 1])) {
			buffer += "$upscope $end\\n";
			current_scope.pop_back();
		}
		while (current_scope.size() < scope.size()) {
			buffer += "$scope module " + scope[current_scope.size()] + " $end\\n";
			current_scope.push_back(scope[current_scope.size()]);
		}
	}

	void emit_ident(size_t ident) {
		do {
			buffer += '!' + ident % 94; // "base94"
			ident /= 94;
		} while (ident != 0);
	}

	void emit_name(const std::string &name) {
		for (char c : name) {
			if (c == ':') {
				// Due to a bug, GTKWave cannot parse a colon in the variable name, causing the VCD file
				// to be unreadable. It cannot be escaped either, so replace it with the sideways colon.
				buffer += "..";
			} else {
				buffer += c;
			}
		}
	}

	void emit_var(const variable &var, const std::string &type, const std::string &name,
	              size_t lsb_at, bool multipart) {
		assert(!streaming);
		buffer += "$var " + type + " " + std::to_string(var.width) + " ";
		emit_ident(var.ident);
		buffer += " ";
		emit_name(name);
		if (multipart || name.back() == ']' || lsb_at != 0) {
			if (var.width == 1)
				buffer += " [" + std::to_string(lsb_at) + "]";
			else
				buffer += " [" + std::to_string(lsb_at + var.width - 1) + ":" + std::to_string(lsb_at) + "]";
		}
		buffer += " $end\\n";
	}

	void emit_enddefinitions() {
		assert(!streaming);
		buffer += "$enddefinitions $end\\n";
		streaming = true;
	}

	void emit_time(uint64_t timestamp) {
		assert(streaming);
		buffer += "#" + std::to_string(timestamp) + "\\n";
	}

	void emit_scalar(const variable &var) {
		assert(streaming);
		assert(var.width == 1);
		buffer += (*var.curr ? '1' : '0');
		emit_ident(var.ident);
		buffer += '\\n';
	}

	void emit_vector(const variable &var) {
		assert(streaming);
		buffer += 'b';
		for (size_t bit = var.width - 1; bit != (size_t)-1; bit--) {
			bool bit_curr = var.curr[bit / (8 * sizeof(chunk_t))] & (1 << (bit % (8 * sizeof(chunk_t))));
			buffer += (bit_curr ? '1' : '0');
		}
		buffer += ' ';
		emit_ident(var.ident);
		buffer += '\\n';
	}

	void reset_outlines() {
		for (auto &outline_it : outlines)
			outline_it.second = /*warm=*/(outline_it.first == nullptr);
	}

	variable &register_variable(size_t width, chunk_t *curr, bool constant = false, debug_outline *outline = nullptr) {
		if (aliases.count(curr)) {
			return variables[aliases[curr]];
		} else {
			auto outline_it = outlines.emplace(outline, /*warm=*/(outline == nullptr)).first;
			const size_t chunks = (width + (sizeof(chunk_t) * 8 - 1)) / (sizeof(chunk_t) * 8);
			aliases[curr] = variables.size();
			if (constant) {
				variables.emplace_back(variable { variables.size(), width, curr, (size_t)-1, outline_it->first, &outline_it->second });
			} else {
				variables.emplace_back(variable { variables.size(), width, curr, cache.size(), outline_it->first, &outline_it->second });
				cache.insert(cache.end(), &curr[0], &curr[chunks]);
			}
			return variables.back();
		}
	}

	bool test_variable(const variable &var) {
		if (var.cache_offset == (size_t)-1)
			return false; // constant
		if (!*var.outline_warm) {
			var.outline->eval();
			*var.outline_warm = true;
		}
		const size_t chunks = (var.width + (sizeof(chunk_t) * 8 - 1)) / (sizeof(chunk_t) * 8);
		if (std::equal(&var.curr[0], &var.curr[chunks], &cache[var.cache_offset])) {
			return false;
		} else {
			std::copy(&var.curr[0], &var.curr[chunks], &cache[var.cache_offset]);
			return true;
		}
	}

	static std::vector<std::string> split_hierarchy(const std::string &hier_name) {
		std::vector<std::string> hierarchy;
		size_t prev = 0;
		while (true) {
			size_t curr = hier_name.find_first_of(' ', prev);
			if (curr == std::string::npos) {
				hierarchy.push_back(hier_name.substr(prev));
				break;
			} else {
				hierarchy.push_back(hier_name.substr(prev, curr - prev));
				prev = curr + 1;
			}
		}
		return hierarchy;
	}

public:
	std::string buffer;

	void timescale(unsigned number, const std::string &unit) {
		emit_timescale(number, unit);
	}

	void add(const std::string &hier_name, const debug_item &item, bool multipart = false) {
		std::vector<std::string> scope = split_hierarchy(hier_name);
		std::string name = scope.back();
		scope.pop_back();

		emit_scope(scope);
		switch (item.type) {
			// Not the best naming but oh well...
			case debug_item::VALUE:
				emit_var(register_variable(item.width, item.curr, /*constant=*/item.next == nullptr),
				         "wire", name, item.lsb_at, multipart);
				break;
			case debug_item::WIRE:
				emit_var(register_variable(item.width, item.curr),
				         "reg", name, item.lsb_at, multipart);
				break;
			case debug_item::MEMORY: {
				const size_t stride = (item.width + (sizeof(chunk_t) * 8 - 1)) / (sizeof(chunk_t) * 8);
				for (size_t index = 0; index < item.depth; index++) {
					chunk_t *nth_curr = &item.curr[stride * index];
					std::string nth_name = name + '[' + std::to_string(index) + ']';
					emit_var(register_variable(item.width, nth_curr),
					         "reg", nth_name, item.lsb_at, multipart);
				}
				break;
			}
			case debug_item::ALIAS:
				// Like VALUE, but, even though \`item.next == nullptr\` always holds, the underlying value
				// can actually change, and must be tracked. In most cases the VCD identifier will be
				// unified with the aliased reg, but we should handle the case where only the alias is
				// added to the VCD writer, too.
				emit_var(register_variable(item.width, item.curr),
				         "wire", name, item.lsb_at, multipart);
				break;
			case debug_item::OUTLINE:
				emit_var(register_variable(item.width, item.curr, /*constant=*/false, item.outline),
				         "wire", name, item.lsb_at, multipart);
				break;
		}
	}

	template<class Filter>
	void add(const debug_items &items, const Filter &filter) {
		// \`debug_items\` is a map, so the items are already sorted in an order optimal for emitting
		// VCD scope sections.
		for (auto &it : items.table)
			for (auto &part : it.second)
				if (filter(it.first, part))
					add(it.first, part, it.second.size() > 1);
	}

	void add(const debug_items &items) {
		this->add(items, [](const std::string &, const debug_item &) {
			return true;
		});
	}

	void add_without_memories(const debug_items &items) {
		this->add(items, [](const std::string &, const debug_item &item) {
			return item.type != debug_item::MEMORY;
		});
	}

	void sample(uint64_t timestamp) {
		bool first_sample = !streaming;
		if (first_sample) {
			emit_scope({});
			emit_enddefinitions();
		}
		reset_outlines();
		emit_time(timestamp);
		for (auto var : variables)
			if (test_variable(var) || first_sample) {
				if (var.width == 1)
					emit_scalar(var);
				else
					emit_vector(var);
			}
	}
};

}

#endif
`}}},rtlil:{"rtlil_backend.h":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 *  ---
 *
 *  A very simple and straightforward backend for the RTLIL text
 *  representation.
 *
 */

#ifndef RTLIL_BACKEND_H
#define RTLIL_BACKEND_H

#include "kernel/yosys.h"
#include <stdio.h>

YOSYS_NAMESPACE_BEGIN

namespace RTLIL_BACKEND {
	void dump_const(std::ostream &f, const RTLIL::Const &data, int width = -1, int offset = 0, bool autoint = true);
	void dump_sigchunk(std::ostream &f, const RTLIL::SigChunk &chunk, bool autoint = true);
	void dump_sigspec(std::ostream &f, const RTLIL::SigSpec &sig, bool autoint = true);
	void dump_wire(std::ostream &f, std::string indent, const RTLIL::Wire *wire);
	void dump_memory(std::ostream &f, std::string indent, const RTLIL::Memory *memory);
	void dump_cell(std::ostream &f, std::string indent, const RTLIL::Cell *cell);
	void dump_proc_case_body(std::ostream &f, std::string indent, const RTLIL::CaseRule *cs);
	void dump_proc_switch(std::ostream &f, std::string indent, const RTLIL::SwitchRule *sw);
	void dump_proc_sync(std::ostream &f, std::string indent, const RTLIL::SyncRule *sy);
	void dump_proc(std::ostream &f, std::string indent, const RTLIL::Process *proc);
	void dump_conn(std::ostream &f, std::string indent, const RTLIL::SigSpec &left, const RTLIL::SigSpec &right);
	void dump_module(std::ostream &f, std::string indent, RTLIL::Module *module, RTLIL::Design *design, bool only_selected, bool flag_m = true, bool flag_n = false);
	void dump_design(std::ostream &f, RTLIL::Design *design, bool only_selected, bool flag_m = true, bool flag_n = false);
}

YOSYS_NAMESPACE_END

#endif
`}},frontends:{ast:{"ast.h":`/* -*- c++ -*-
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 *  ---
 *
 *  This is the AST frontend library.
 *
 *  The AST frontend library is not a frontend on it's own but provides a
 *  generic abstract syntax tree (AST) abstraction for HDL code and can be
 *  used by HDL frontends. See "ast.h" for an overview of the API and the
 *  Verilog frontend for an usage example.
 *
 */

#ifndef AST_H
#define AST_H

#include "kernel/rtlil.h"
#include "kernel/fmt.h"
#include <stdint.h>
#include <set>

YOSYS_NAMESPACE_BEGIN

namespace AST
{
	// all node types, type2str() must be extended
	// whenever a new node type is added here
	enum AstNodeType
	{
		AST_NONE,
		AST_DESIGN,
		AST_MODULE,
		AST_TASK,
		AST_FUNCTION,
		AST_DPI_FUNCTION,

		AST_WIRE,
		AST_MEMORY,
		AST_AUTOWIRE,
		AST_PARAMETER,
		AST_LOCALPARAM,
		AST_DEFPARAM,
		AST_PARASET,
		AST_ARGUMENT,
		AST_RANGE,
		AST_MULTIRANGE,
		AST_CONSTANT,
		AST_REALVALUE,
		AST_CELLTYPE,
		AST_IDENTIFIER,
		AST_PREFIX,
		AST_ASSERT,
		AST_ASSUME,
		AST_LIVE,
		AST_FAIR,
		AST_COVER,
		AST_ENUM,
		AST_ENUM_ITEM,

		AST_FCALL,
		AST_TO_BITS,
		AST_TO_SIGNED,
		AST_TO_UNSIGNED,
		AST_SELFSZ,
		AST_CAST_SIZE,
		AST_CONCAT,
		AST_REPLICATE,
		AST_BIT_NOT,
		AST_BIT_AND,
		AST_BIT_OR,
		AST_BIT_XOR,
		AST_BIT_XNOR,
		AST_REDUCE_AND,
		AST_REDUCE_OR,
		AST_REDUCE_XOR,
		AST_REDUCE_XNOR,
		AST_REDUCE_BOOL,
		AST_SHIFT_LEFT,
		AST_SHIFT_RIGHT,
		AST_SHIFT_SLEFT,
		AST_SHIFT_SRIGHT,
		AST_SHIFTX,
		AST_SHIFT,
		AST_LT,
		AST_LE,
		AST_EQ,
		AST_NE,
		AST_EQX,
		AST_NEX,
		AST_GE,
		AST_GT,
		AST_ADD,
		AST_SUB,
		AST_MUL,
		AST_DIV,
		AST_MOD,
		AST_POW,
		AST_POS,
		AST_NEG,
		AST_LOGIC_AND,
		AST_LOGIC_OR,
		AST_LOGIC_NOT,
		AST_TERNARY,
		AST_MEMRD,
		AST_MEMWR,
		AST_MEMINIT,

		AST_TCALL,
		AST_ASSIGN,
		AST_CELL,
		AST_PRIMITIVE,
		AST_CELLARRAY,
		AST_ALWAYS,
		AST_INITIAL,
		AST_BLOCK,
		AST_ASSIGN_EQ,
		AST_ASSIGN_LE,
		AST_CASE,
		AST_COND,
		AST_CONDX,
		AST_CONDZ,
		AST_DEFAULT,
		AST_FOR,
		AST_WHILE,
		AST_REPEAT,

		AST_GENVAR,
		AST_GENFOR,
		AST_GENIF,
		AST_GENCASE,
		AST_GENBLOCK,
		AST_TECALL,

		AST_POSEDGE,
		AST_NEGEDGE,
		AST_EDGE,

		AST_INTERFACE,
		AST_INTERFACEPORT,
		AST_INTERFACEPORTTYPE,
		AST_MODPORT,
		AST_MODPORTMEMBER,
		AST_PACKAGE,

		AST_WIRETYPE,
		AST_TYPEDEF,
		AST_STRUCT,
		AST_UNION,
		AST_STRUCT_ITEM,
		AST_BIND
	};

	struct AstSrcLocType {
		unsigned int first_line, last_line;
		unsigned int first_column, last_column;
		AstSrcLocType() : first_line(0), last_line(0), first_column(0), last_column(0) {}
		AstSrcLocType(int _first_line, int _first_column, int _last_line, int _last_column) : first_line(_first_line), last_line(_last_line), first_column(_first_column), last_column(_last_column) {}
	};

	// convert an node type to a string (e.g. for debug output)
	std::string type2str(AstNodeType type);

	// The AST is built using instances of this struct
	struct AstNode
	{
		// for dict<> and pool<>
		unsigned int hashidx_;
		unsigned int hash() const { return hashidx_; }

		// this nodes type
		AstNodeType type;

		// the list of child nodes for this node
		std::vector<AstNode*> children;

		// the list of attributes assigned to this node
		std::map<RTLIL::IdString, AstNode*> attributes;
		bool get_bool_attribute(RTLIL::IdString id);

		// node content - most of it is unused in most node types
		std::string str;
		std::vector<RTLIL::State> bits;
		bool is_input, is_output, is_reg, is_logic, is_signed, is_string, is_wand, is_wor, range_valid, range_swapped, was_checked, is_unsized, is_custom_type;
		int port_id, range_left, range_right;
		uint32_t integer;
		double realvalue;
		// set for IDs typed to an enumeration, not used
		bool is_enum;

		// Declared range for array dimension.
		struct dimension_t {
			int range_right;     // lsb in [msb:lsb]
			int range_width;     // msb - lsb + 1
			bool range_swapped;  // if the declared msb < lsb, msb and lsb above are swapped
		};
		// Packed and unpacked dimensions for arrays.
		// Unpacked dimensions go first, to follow the order of indexing.
		std::vector<dimension_t> dimensions;
		// Number of unpacked dimensions.
		int unpacked_dimensions;

		// this is set by simplify and used during RTLIL generation
		AstNode *id2ast;

		// this is used by simplify to detect if basic analysis has been performed already on the node
		bool basic_prep;

		// this is used for ID references in RHS expressions that should use the "new" value for non-blocking assignments
		bool lookahead;

		// this is the original sourcecode location that resulted in this AST node
		// it is automatically set by the constructor using AST::current_filename and
		// the AST::get_line_num() callback function.
		std::string filename;
		AstSrcLocType location;

		// are we embedded in an lvalue, param?
		// (see fixup_hierarchy_flags)
		bool in_lvalue;
		bool in_param;
		bool in_lvalue_from_above;
		bool in_param_from_above;

		// creating and deleting nodes
		AstNode(AstNodeType type = AST_NONE, AstNode *child1 = nullptr, AstNode *child2 = nullptr, AstNode *child3 = nullptr, AstNode *child4 = nullptr);
		AstNode *clone() const;
		void cloneInto(AstNode *other) const;
		void delete_children();
		~AstNode();

		enum mem2reg_flags
		{
			/* status flags */
			MEM2REG_FL_ALL       = 0x00000001,
			MEM2REG_FL_ASYNC     = 0x00000002,
			MEM2REG_FL_INIT      = 0x00000004,

			/* candidate flags */
			MEM2REG_FL_FORCED    = 0x00000100,
			MEM2REG_FL_SET_INIT  = 0x00000200,
			MEM2REG_FL_SET_ELSE  = 0x00000400,
			MEM2REG_FL_SET_ASYNC = 0x00000800,
			MEM2REG_FL_EQ2       = 0x00001000,
			MEM2REG_FL_CMPLX_LHS = 0x00002000,
			MEM2REG_FL_CONST_LHS = 0x00004000,
			MEM2REG_FL_VAR_LHS   = 0x00008000,

			/* proc flags */
			MEM2REG_FL_EQ1       = 0x01000000,
		};

		// simplify() creates a simpler AST by unrolling for-loops, expanding generate blocks, etc.
		// it also sets the id2ast pointers so that identifier lookups are fast in genRTLIL()
		bool simplify(bool const_fold, int stage, int width_hint, bool sign_hint);
		void replace_result_wire_name_in_function(const std::string &from, const std::string &to);
		AstNode *readmem(bool is_readmemh, std::string mem_filename, AstNode *memory, int start_addr, int finish_addr, bool unconditional_init);
		void expand_genblock(const std::string &prefix);
		void label_genblks(std::set<std::string>& existing, int &counter);
		void mem2reg_as_needed_pass1(dict<AstNode*, pool<std::string>> &mem2reg_places,
				dict<AstNode*, uint32_t> &mem2reg_flags, dict<AstNode*, uint32_t> &proc_flags, uint32_t &status_flags);
		bool mem2reg_as_needed_pass2(pool<AstNode*> &mem2reg_set, AstNode *mod, AstNode *block, AstNode *&async_block);
		bool mem2reg_check(pool<AstNode*> &mem2reg_set);
		void mem2reg_remove(pool<AstNode*> &mem2reg_set, vector<AstNode*> &delnodes);
		void meminfo(int &mem_width, int &mem_size, int &addr_bits);
		bool detect_latch(const std::string &var);
		const RTLIL::Module* lookup_cell_module();

		// additional functionality for evaluating constant functions
		struct varinfo_t {
			RTLIL::Const val;
			int offset;
			bool range_swapped;
			bool is_signed;
			AstNode *arg = nullptr;
			bool explicitly_sized;
		};
		bool has_const_only_constructs();
		bool replace_variables(std::map<std::string, varinfo_t> &variables, AstNode *fcall, bool must_succeed);
		AstNode *eval_const_function(AstNode *fcall, bool must_succeed);
		bool is_simple_const_expr();

		// helper for parsing format strings
		Fmt processFormat(int stage, bool sformat_like, int default_base = 10, size_t first_arg_at = 0, bool may_fail = false);

		bool is_recursive_function() const;
		std::pair<AstNode*, AstNode*> get_tern_choice();

		// create a human-readable text representation of the AST (for debugging)
		void dumpAst(FILE *f, std::string indent) const;
		void dumpVlog(FILE *f, std::string indent) const;

		// Generate RTLIL for a bind construct
		std::vector<RTLIL::Binding *> genBindings() const;

		// used by genRTLIL() for detecting expression width and sign
		void detectSignWidthWorker(int &width_hint, bool &sign_hint, bool *found_real = NULL);
		void detectSignWidth(int &width_hint, bool &sign_hint, bool *found_real = NULL);

		// create RTLIL code for this AST node
		// for expressions the resulting signal vector is returned
		// all generated cell instances, etc. are written to the RTLIL::Module pointed to by AST_INTERNAL::current_module
		RTLIL::SigSpec genRTLIL(int width_hint = -1, bool sign_hint = false);
		RTLIL::SigSpec genWidthRTLIL(int width, bool sgn, const dict<RTLIL::SigBit, RTLIL::SigBit> *new_subst_ptr = NULL);

		// compare AST nodes
		bool operator==(const AstNode &other) const;
		bool operator!=(const AstNode &other) const;
		bool contains(const AstNode *other) const;

		// helper functions for creating AST nodes for constants
		static AstNode *mkconst_int(uint32_t v, bool is_signed, int width = 32);
		static AstNode *mkconst_bits(const std::vector<RTLIL::State> &v, bool is_signed, bool is_unsized);
		static AstNode *mkconst_bits(const std::vector<RTLIL::State> &v, bool is_signed);
		static AstNode *mkconst_str(const std::vector<RTLIL::State> &v);
		static AstNode *mkconst_str(const std::string &str);

		// helper function to create an AST node for a temporary register
		AstNode *mktemp_logic(const std::string &name, AstNode *mod, bool nosync, int range_left, int range_right, bool is_signed);

		// helper function for creating sign-extended const objects
		RTLIL::Const bitsAsConst(int width, bool is_signed);
		RTLIL::Const bitsAsConst(int width = -1);
		RTLIL::Const bitsAsUnsizedConst(int width);
		RTLIL::Const asAttrConst() const;
		RTLIL::Const asParaConst() const;
		uint64_t asInt(bool is_signed);
		bool bits_only_01() const;
		bool asBool() const;

		// helper functions for real valued const eval
		int isConst() const; // return '1' for AST_CONSTANT and '2' for AST_REALVALUE
		double asReal(bool is_signed);
		RTLIL::Const realAsConst(int width);

		// helpers for enum
		void allocateDefaultEnumValues();
		void annotateTypedEnums(AstNode *template_node);

		// helpers for locations
		std::string loc_string() const;

		// Helper for looking up identifiers which are prefixed with the current module name
		std::string try_pop_module_prefix() const;

		// helper to clone the node with some of its subexpressions replaced with zero (this is used
		// to evaluate widths of dynamic ranges)
		AstNode *clone_at_zero();

		void set_attribute(RTLIL::IdString key, AstNode *node)
		{
			attributes[key] = node;
			node->set_in_param_flag(true);
		}

		// helper to set in_lvalue/in_param flags from the hierarchy context (the actual flag
		// can be overridden based on the intrinsic properties of this node, i.e. based on its type)
		void set_in_lvalue_flag(bool flag, bool no_descend = false);
		void set_in_param_flag(bool flag, bool no_descend = false);

		// fix up the hierarchy flags (in_lvalue/in_param) of this node and its children
		//
		// to keep the flags in sync, fixup_hierarchy_flags(true) needs to be called once after
		// parsing the AST to walk the full tree, then plain fixup_hierarchy_flags() performs
		// localized fixups after modifying children/attributes of a particular node
		void fixup_hierarchy_flags(bool force_descend = false);

		// helpers for indexing
		AstNode *make_index_range(AstNode *node, bool unpacked_range = false);
		AstNode *get_struct_member() const;

		// helper to print errors from simplify/genrtlil code
		[[noreturn]] void input_error(const char *format, ...) const YS_ATTRIBUTE(format(printf, 2, 3));
	};

	// process an AST tree (ast must point to an AST_DESIGN node) and generate RTLIL code
	void process(RTLIL::Design *design, AstNode *ast, bool nodisplay, bool dump_ast1, bool dump_ast2, bool no_dump_ptr, bool dump_vlog1, bool dump_vlog2, bool dump_rtlil, bool nolatches, bool nomeminit,
			bool nomem2reg, bool mem2reg, bool noblackbox, bool lib, bool nowb, bool noopt, bool icells, bool pwires, bool nooverwrite, bool overwrite, bool defer, bool autowire);

	// parametric modules are supported directly by the AST library
	// therefore we need our own derivate of RTLIL::Module with overloaded virtual functions
	struct AstModule : RTLIL::Module {
		AstNode *ast;
		bool nolatches, nomeminit, nomem2reg, mem2reg, noblackbox, lib, nowb, noopt, icells, pwires, autowire;
		~AstModule() override;
		RTLIL::IdString derive(RTLIL::Design *design, const dict<RTLIL::IdString, RTLIL::Const> &parameters, bool mayfail) override;
		RTLIL::IdString derive(RTLIL::Design *design, const dict<RTLIL::IdString, RTLIL::Const> &parameters, const dict<RTLIL::IdString, RTLIL::Module*> &interfaces, const dict<RTLIL::IdString, RTLIL::IdString> &modports, bool mayfail) override;
		std::string derive_common(RTLIL::Design *design, const dict<RTLIL::IdString, RTLIL::Const> &parameters, AstNode **new_ast_out, bool quiet = false);
		void expand_interfaces(RTLIL::Design *design, const dict<RTLIL::IdString, RTLIL::Module *> &local_interfaces) override;
		bool reprocess_if_necessary(RTLIL::Design *design) override;
		RTLIL::Module *clone() const override;
		void loadconfig() const;
	};

	// this must be set by the language frontend before parsing the sources
	// the AstNode constructor then uses current_filename and get_line_num()
	// to initialize the filename and linenum properties of new nodes
	extern std::string current_filename;
	extern void (*set_line_num)(int);
	extern int (*get_line_num)();

	// set set_line_num and get_line_num to internal dummy functions (done by simplify() and AstModule::derive
	// to control the filename and linenum properties of new nodes not generated by a frontend parser)
	void use_internal_line_num();

	// call a DPI function
	AstNode *dpi_call(const std::string &rtype, const std::string &fname, const std::vector<std::string> &argtypes, const std::vector<AstNode*> &args);

	// Helper functions related to handling SystemVerilog interfaces
	std::pair<std::string,std::string> split_modport_from_type(std::string name_type);
	AstNode * find_modport(AstNode *intf, std::string name);
	void explode_interface_port(AstNode *module_ast, RTLIL::Module * intfmodule, std::string intfname, AstNode *modport);

	// Helper for setting the src attribute.
	void set_src_attr(RTLIL::AttrObject *obj, const AstNode *ast);

	// generate standard $paramod... derived module name; parameters should be
	// in the order they are declared in the instantiated module
	std::string derived_module_name(std::string stripped_name, const std::vector<std::pair<RTLIL::IdString, RTLIL::Const>> &parameters);

	// used to provide simplify() access to the current design for looking up
	// modules, ports, wires, etc.
	void set_simplify_design_context(const RTLIL::Design *design);
}

namespace AST_INTERNAL
{
	// internal state variables
	extern bool flag_nodisplay, flag_dump_ast1, flag_dump_ast2, flag_no_dump_ptr, flag_dump_rtlil, flag_nolatches, flag_nomeminit;
	extern bool flag_nomem2reg, flag_mem2reg, flag_lib, flag_noopt, flag_icells, flag_pwires, flag_autowire;
	extern AST::AstNode *current_ast, *current_ast_mod;
	extern std::map<std::string, AST::AstNode*> current_scope;
	extern const dict<RTLIL::SigBit, RTLIL::SigBit> *genRTLIL_subst_ptr;
	extern RTLIL::SigSpec ignoreThisSignalsInInitial;
	extern AST::AstNode *current_always, *current_top_block, *current_block, *current_block_child;
	extern RTLIL::Module *current_module;
	extern bool current_always_clocked;
	extern dict<std::string, int> current_memwr_count;
	extern dict<std::string, pool<int>> current_memwr_visible;
	struct LookaheadRewriter;
	struct ProcessGenerator;

	// Create and add a new AstModule from new_ast, then use it to replace
	// old_module in design, renaming old_module to move it out of the way.
	// Return the new module.
	//
	// If original_ast is not null, it will be used as the AST node for the
	// new module. Otherwise, new_ast will be used.
	RTLIL::Module *
	process_and_replace_module(RTLIL::Design *design,
	                           RTLIL::Module *old_module,
	                           AST::AstNode *new_ast,
	                           AST::AstNode *original_ast = nullptr);
}

YOSYS_NAMESPACE_END

#endif
`,"ast_binding.h":`/* -*- c++ -*-
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 *  ---
 *
 *  This header declares the AST::Binding class
 *
 *  This is used to support the bind directive and is to RTLIL::Binding as
 *  AST::AstModule is to RTLIL::Module, holding a syntax-level representation of
 *  cells until we get to a stage where they make sense. In the case of a bind
 *  directive, this is when we elaborate the design in the hierarchy pass.
 *
 */

#ifndef AST_BINDING_H
#define AST_BINDING_H

#include "kernel/rtlil.h"
#include "kernel/binding.h"

#include <memory>

YOSYS_NAMESPACE_BEGIN

namespace AST
{
	class Binding : public RTLIL::Binding
	{
	public:
		Binding(RTLIL::IdString  target_type,
		        RTLIL::IdString  target_name,
		        const AstNode   &cell);

		std::string describe() const override;

	private:
		// The syntax-level representation of the cell to be bound.
		std::unique_ptr<AstNode> ast_node;
	};
}

YOSYS_NAMESPACE_END

#endif
`},blif:{"blifparse.h":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef ABC_BLIFPARSE
#define ABC_BLIFPARSE

#include "kernel/yosys.h"

YOSYS_NAMESPACE_BEGIN

extern void parse_blif(RTLIL::Design *design, std::istream &f, IdString dff_name,
		bool run_clean = false, bool sop_mode = false, bool wideports = false);

YOSYS_NAMESPACE_END

#endif
`}},kernel:{"binding.h":`/* -*- c++ -*-
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef BINDING_H
#define BINDING_H

#include "kernel/rtlil.h"

YOSYS_NAMESPACE_BEGIN

struct RTLIL::Binding
{
	// Represents a bind construct.
	//
	// The target of the binding is represented by target_type and
	// target_name (see comments above the fields).

	Binding(RTLIL::IdString target_type,
	        RTLIL::IdString target_name);

	virtual ~Binding() {}

	// Return a string describing the binding
	virtual std::string describe() const = 0;

protected:
	// May be empty. If not, it's the name of the module or interface to
	// bind to.
	RTLIL::IdString target_type;

	// If target_type is nonempty (the usual case), this is a hierarchical
	// reference to the bind target. If target_type is empty, we have to
	// wait until the hierarchy pass to figure out whether this was the name
	// of a module/interface type or an instance.
	RTLIL::IdString target_name;

	// An attribute name which contains an ID that's unique across binding
	// instances (used to ensure we don't apply a binding twice to a module)
	RTLIL::IdString attr_name;
};

YOSYS_NAMESPACE_END

#endif
`,"cellaigs.h":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef CELLAIGS_H
#define CELLAIGS_H

#include "kernel/yosys.h"

YOSYS_NAMESPACE_BEGIN

struct AigNode
{
	IdString portname;
	int portbit;
	bool inverter;
	int left_parent, right_parent;
	vector<pair<IdString, int>> outports;

	AigNode();
	bool operator==(const AigNode &other) const;
	unsigned int hash() const;
};

struct Aig
{
	string name;
	vector<AigNode> nodes;
	Aig(Cell *cell);

	bool operator==(const Aig &other) const;
	unsigned int hash() const;
};

YOSYS_NAMESPACE_END

#endif
`,"celledges.h":`/* -*- c++ -*-
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef CELLEDGES_H
#define CELLEDGES_H

#include "kernel/yosys.h"
#include "kernel/sigtools.h"

YOSYS_NAMESPACE_BEGIN

struct AbstractCellEdgesDatabase
{
	virtual ~AbstractCellEdgesDatabase() { }
	virtual void add_edge(RTLIL::Cell *cell, RTLIL::IdString from_port, int from_bit, RTLIL::IdString to_port, int to_bit, int delay) = 0;
	bool add_edges_from_cell(RTLIL::Cell *cell);
};

struct FwdCellEdgesDatabase : AbstractCellEdgesDatabase
{
	SigMap &sigmap;
	dict<SigBit, pool<SigBit>> db;
	FwdCellEdgesDatabase(SigMap &sigmap) : sigmap(sigmap) { }

	void add_edge(RTLIL::Cell *cell, RTLIL::IdString from_port, int from_bit, RTLIL::IdString to_port, int to_bit, int) override {
		SigBit from_sigbit = sigmap(cell->getPort(from_port)[from_bit]);
		SigBit to_sigbit = sigmap(cell->getPort(to_port)[to_bit]);
		db[from_sigbit].insert(to_sigbit);
	}
};

struct RevCellEdgesDatabase : AbstractCellEdgesDatabase
{
	SigMap &sigmap;
	dict<SigBit, pool<SigBit>> db;
	RevCellEdgesDatabase(SigMap &sigmap) : sigmap(sigmap) { }

	void add_edge(RTLIL::Cell *cell, RTLIL::IdString from_port, int from_bit, RTLIL::IdString to_port, int to_bit, int) override {
		SigBit from_sigbit = sigmap(cell->getPort(from_port)[from_bit]);
		SigBit to_sigbit = sigmap(cell->getPort(to_port)[to_bit]);
		db[to_sigbit].insert(from_sigbit);
	}
};

YOSYS_NAMESPACE_END

#endif
`,"celltypes.h":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef CELLTYPES_H
#define CELLTYPES_H

#include "kernel/yosys.h"

YOSYS_NAMESPACE_BEGIN

struct CellType
{
	RTLIL::IdString type;
	pool<RTLIL::IdString> inputs, outputs;
	bool is_evaluable;
};

struct CellTypes
{
	dict<RTLIL::IdString, CellType> cell_types;

	CellTypes()
	{
	}

	CellTypes(RTLIL::Design *design)
	{
		setup(design);
	}

	void setup(RTLIL::Design *design = NULL)
	{
		if (design)
			setup_design(design);

		setup_internals();
		setup_internals_mem();
		setup_internals_anyinit();
		setup_stdcells();
		setup_stdcells_mem();
	}

	void setup_type(RTLIL::IdString type, const pool<RTLIL::IdString> &inputs, const pool<RTLIL::IdString> &outputs, bool is_evaluable = false)
	{
		CellType ct = {type, inputs, outputs, is_evaluable};
		cell_types[ct.type] = ct;
	}

	void setup_module(RTLIL::Module *module)
	{
		pool<RTLIL::IdString> inputs, outputs;
		for (RTLIL::IdString wire_name : module->ports) {
			RTLIL::Wire *wire = module->wire(wire_name);
			if (wire->port_input)
				inputs.insert(wire->name);
			if (wire->port_output)
				outputs.insert(wire->name);
		}
		setup_type(module->name, inputs, outputs);
	}

	void setup_design(RTLIL::Design *design)
	{
		for (auto module : design->modules())
			setup_module(module);
	}

	void setup_internals()
	{
		setup_internals_eval();

		setup_type(ID($tribuf), {ID::A, ID::EN}, {ID::Y}, true);

		setup_type(ID($assert), {ID::A, ID::EN}, pool<RTLIL::IdString>(), true);
		setup_type(ID($assume), {ID::A, ID::EN}, pool<RTLIL::IdString>(), true);
		setup_type(ID($live), {ID::A, ID::EN}, pool<RTLIL::IdString>(), true);
		setup_type(ID($fair), {ID::A, ID::EN}, pool<RTLIL::IdString>(), true);
		setup_type(ID($cover), {ID::A, ID::EN}, pool<RTLIL::IdString>(), true);
		setup_type(ID($initstate), pool<RTLIL::IdString>(), {ID::Y}, true);
		setup_type(ID($anyconst), pool<RTLIL::IdString>(), {ID::Y}, true);
		setup_type(ID($anyseq), pool<RTLIL::IdString>(), {ID::Y}, true);
		setup_type(ID($allconst), pool<RTLIL::IdString>(), {ID::Y}, true);
		setup_type(ID($allseq), pool<RTLIL::IdString>(), {ID::Y}, true);
		setup_type(ID($equiv), {ID::A, ID::B}, {ID::Y}, true);
		setup_type(ID($specify2), {ID::EN, ID::SRC, ID::DST}, pool<RTLIL::IdString>(), true);
		setup_type(ID($specify3), {ID::EN, ID::SRC, ID::DST, ID::DAT}, pool<RTLIL::IdString>(), true);
		setup_type(ID($specrule), {ID::EN_SRC, ID::EN_DST, ID::SRC, ID::DST}, pool<RTLIL::IdString>(), true);
		setup_type(ID($print), {ID::EN, ID::ARGS, ID::TRG}, pool<RTLIL::IdString>());
		setup_type(ID($check), {ID::A, ID::EN, ID::ARGS, ID::TRG}, pool<RTLIL::IdString>());
		setup_type(ID($set_tag), {ID::A, ID::SET, ID::CLR}, {ID::Y});
		setup_type(ID($get_tag), {ID::A}, {ID::Y});
		setup_type(ID($overwrite_tag), {ID::A, ID::SET, ID::CLR}, pool<RTLIL::IdString>());
		setup_type(ID($original_tag), {ID::A}, {ID::Y});
		setup_type(ID($future_ff), {ID::A}, {ID::Y});
		setup_type(ID($scopeinfo), {}, {});
	}

	void setup_internals_eval()
	{
		std::vector<RTLIL::IdString> unary_ops = {
			ID($not), ID($pos), ID($neg),
			ID($reduce_and), ID($reduce_or), ID($reduce_xor), ID($reduce_xnor), ID($reduce_bool),
			ID($logic_not), ID($slice), ID($lut), ID($sop)
		};

		std::vector<RTLIL::IdString> binary_ops = {
			ID($and), ID($or), ID($xor), ID($xnor),
			ID($shl), ID($shr), ID($sshl), ID($sshr), ID($shift), ID($shiftx),
			ID($lt), ID($le), ID($eq), ID($ne), ID($eqx), ID($nex), ID($ge), ID($gt),
			ID($add), ID($sub), ID($mul), ID($div), ID($mod), ID($divfloor), ID($modfloor), ID($pow),
			ID($logic_and), ID($logic_or), ID($concat), ID($macc),
			ID($bweqx)
		};

		for (auto type : unary_ops)
			setup_type(type, {ID::A}, {ID::Y}, true);

		for (auto type : binary_ops)
			setup_type(type, {ID::A, ID::B}, {ID::Y}, true);

		for (auto type : std::vector<RTLIL::IdString>({ID($mux), ID($pmux), ID($bwmux)}))
			setup_type(type, {ID::A, ID::B, ID::S}, {ID::Y}, true);

		for (auto type : std::vector<RTLIL::IdString>({ID($bmux), ID($demux)}))
			setup_type(type, {ID::A, ID::S}, {ID::Y}, true);

		setup_type(ID($lcu), {ID::P, ID::G, ID::CI}, {ID::CO}, true);
		setup_type(ID($alu), {ID::A, ID::B, ID::CI, ID::BI}, {ID::X, ID::Y, ID::CO}, true);
		setup_type(ID($fa), {ID::A, ID::B, ID::C}, {ID::X, ID::Y}, true);
	}

	void setup_internals_ff()
	{
		setup_type(ID($sr), {ID::SET, ID::CLR}, {ID::Q});
		setup_type(ID($ff), {ID::D}, {ID::Q});
		setup_type(ID($dff), {ID::CLK, ID::D}, {ID::Q});
		setup_type(ID($dffe), {ID::CLK, ID::EN, ID::D}, {ID::Q});
		setup_type(ID($dffsr), {ID::CLK, ID::SET, ID::CLR, ID::D}, {ID::Q});
		setup_type(ID($dffsre), {ID::CLK, ID::SET, ID::CLR, ID::D, ID::EN}, {ID::Q});
		setup_type(ID($adff), {ID::CLK, ID::ARST, ID::D}, {ID::Q});
		setup_type(ID($adffe), {ID::CLK, ID::ARST, ID::D, ID::EN}, {ID::Q});
		setup_type(ID($aldff), {ID::CLK, ID::ALOAD, ID::AD, ID::D}, {ID::Q});
		setup_type(ID($aldffe), {ID::CLK, ID::ALOAD, ID::AD, ID::D, ID::EN}, {ID::Q});
		setup_type(ID($sdff), {ID::CLK, ID::SRST, ID::D}, {ID::Q});
		setup_type(ID($sdffe), {ID::CLK, ID::SRST, ID::D, ID::EN}, {ID::Q});
		setup_type(ID($sdffce), {ID::CLK, ID::SRST, ID::D, ID::EN}, {ID::Q});
		setup_type(ID($dlatch), {ID::EN, ID::D}, {ID::Q});
		setup_type(ID($adlatch), {ID::EN, ID::D, ID::ARST}, {ID::Q});
		setup_type(ID($dlatchsr), {ID::EN, ID::SET, ID::CLR, ID::D}, {ID::Q});
	}

	void setup_internals_anyinit()
	{
		setup_type(ID($anyinit), {ID::D}, {ID::Q});
	}

	void setup_internals_mem()
	{
		setup_internals_ff();

		setup_type(ID($memrd), {ID::CLK, ID::EN, ID::ADDR}, {ID::DATA});
		setup_type(ID($memrd_v2), {ID::CLK, ID::EN, ID::ARST, ID::SRST, ID::ADDR}, {ID::DATA});
		setup_type(ID($memwr), {ID::CLK, ID::EN, ID::ADDR, ID::DATA}, pool<RTLIL::IdString>());
		setup_type(ID($memwr_v2), {ID::CLK, ID::EN, ID::ADDR, ID::DATA}, pool<RTLIL::IdString>());
		setup_type(ID($meminit), {ID::ADDR, ID::DATA}, pool<RTLIL::IdString>());
		setup_type(ID($meminit_v2), {ID::ADDR, ID::DATA, ID::EN}, pool<RTLIL::IdString>());
		setup_type(ID($mem), {ID::RD_CLK, ID::RD_EN, ID::RD_ADDR, ID::WR_CLK, ID::WR_EN, ID::WR_ADDR, ID::WR_DATA}, {ID::RD_DATA});
		setup_type(ID($mem_v2), {ID::RD_CLK, ID::RD_EN, ID::RD_ARST, ID::RD_SRST, ID::RD_ADDR, ID::WR_CLK, ID::WR_EN, ID::WR_ADDR, ID::WR_DATA}, {ID::RD_DATA});

		setup_type(ID($fsm), {ID::CLK, ID::ARST, ID::CTRL_IN}, {ID::CTRL_OUT});
	}

	void setup_stdcells()
	{
		setup_stdcells_eval();

		setup_type(ID($_TBUF_), {ID::A, ID::E}, {ID::Y}, true);
	}

	void setup_stdcells_eval()
	{
		setup_type(ID($_BUF_), {ID::A}, {ID::Y}, true);
		setup_type(ID($_NOT_), {ID::A}, {ID::Y}, true);
		setup_type(ID($_AND_), {ID::A, ID::B}, {ID::Y}, true);
		setup_type(ID($_NAND_), {ID::A, ID::B}, {ID::Y}, true);
		setup_type(ID($_OR_),  {ID::A, ID::B}, {ID::Y}, true);
		setup_type(ID($_NOR_),  {ID::A, ID::B}, {ID::Y}, true);
		setup_type(ID($_XOR_), {ID::A, ID::B}, {ID::Y}, true);
		setup_type(ID($_XNOR_), {ID::A, ID::B}, {ID::Y}, true);
		setup_type(ID($_ANDNOT_), {ID::A, ID::B}, {ID::Y}, true);
		setup_type(ID($_ORNOT_), {ID::A, ID::B}, {ID::Y}, true);
		setup_type(ID($_MUX_), {ID::A, ID::B, ID::S}, {ID::Y}, true);
		setup_type(ID($_NMUX_), {ID::A, ID::B, ID::S}, {ID::Y}, true);
		setup_type(ID($_MUX4_), {ID::A, ID::B, ID::C, ID::D, ID::S, ID::T}, {ID::Y}, true);
		setup_type(ID($_MUX8_), {ID::A, ID::B, ID::C, ID::D, ID::E, ID::F, ID::G, ID::H, ID::S, ID::T, ID::U}, {ID::Y}, true);
		setup_type(ID($_MUX16_), {ID::A, ID::B, ID::C, ID::D, ID::E, ID::F, ID::G, ID::H, ID::I, ID::J, ID::K, ID::L, ID::M, ID::N, ID::O, ID::P, ID::S, ID::T, ID::U, ID::V}, {ID::Y}, true);
		setup_type(ID($_AOI3_), {ID::A, ID::B, ID::C}, {ID::Y}, true);
		setup_type(ID($_OAI3_), {ID::A, ID::B, ID::C}, {ID::Y}, true);
		setup_type(ID($_AOI4_), {ID::A, ID::B, ID::C, ID::D}, {ID::Y}, true);
		setup_type(ID($_OAI4_), {ID::A, ID::B, ID::C, ID::D}, {ID::Y}, true);
	}

	void setup_stdcells_mem()
	{
		std::vector<char> list_np = {'N', 'P'}, list_01 = {'0', '1'};

		for (auto c1 : list_np)
		for (auto c2 : list_np)
			setup_type(stringf("$_SR_%c%c_", c1, c2), {ID::S, ID::R}, {ID::Q});

		setup_type(ID($_FF_), {ID::D}, {ID::Q});

		for (auto c1 : list_np)
			setup_type(stringf("$_DFF_%c_", c1), {ID::C, ID::D}, {ID::Q});

		for (auto c1 : list_np)
		for (auto c2 : list_np)
			setup_type(stringf("$_DFFE_%c%c_", c1, c2), {ID::C, ID::D, ID::E}, {ID::Q});

		for (auto c1 : list_np)
		for (auto c2 : list_np)
		for (auto c3 : list_01)
			setup_type(stringf("$_DFF_%c%c%c_", c1, c2, c3), {ID::C, ID::R, ID::D}, {ID::Q});

		for (auto c1 : list_np)
		for (auto c2 : list_np)
		for (auto c3 : list_01)
		for (auto c4 : list_np)
			setup_type(stringf("$_DFFE_%c%c%c%c_", c1, c2, c3, c4), {ID::C, ID::R, ID::D, ID::E}, {ID::Q});

		for (auto c1 : list_np)
		for (auto c2 : list_np)
			setup_type(stringf("$_ALDFF_%c%c_", c1, c2), {ID::C, ID::L, ID::AD, ID::D}, {ID::Q});

		for (auto c1 : list_np)
		for (auto c2 : list_np)
		for (auto c3 : list_np)
			setup_type(stringf("$_ALDFFE_%c%c%c_", c1, c2, c3), {ID::C, ID::L, ID::AD, ID::D, ID::E}, {ID::Q});

		for (auto c1 : list_np)
		for (auto c2 : list_np)
		for (auto c3 : list_np)
			setup_type(stringf("$_DFFSR_%c%c%c_", c1, c2, c3), {ID::C, ID::S, ID::R, ID::D}, {ID::Q});

		for (auto c1 : list_np)
		for (auto c2 : list_np)
		for (auto c3 : list_np)
		for (auto c4 : list_np)
			setup_type(stringf("$_DFFSRE_%c%c%c%c_", c1, c2, c3, c4), {ID::C, ID::S, ID::R, ID::D, ID::E}, {ID::Q});

		for (auto c1 : list_np)
		for (auto c2 : list_np)
		for (auto c3 : list_01)
			setup_type(stringf("$_SDFF_%c%c%c_", c1, c2, c3), {ID::C, ID::R, ID::D}, {ID::Q});

		for (auto c1 : list_np)
		for (auto c2 : list_np)
		for (auto c3 : list_01)
		for (auto c4 : list_np)
			setup_type(stringf("$_SDFFE_%c%c%c%c_", c1, c2, c3, c4), {ID::C, ID::R, ID::D, ID::E}, {ID::Q});

		for (auto c1 : list_np)
		for (auto c2 : list_np)
		for (auto c3 : list_01)
		for (auto c4 : list_np)
			setup_type(stringf("$_SDFFCE_%c%c%c%c_", c1, c2, c3, c4), {ID::C, ID::R, ID::D, ID::E}, {ID::Q});

		for (auto c1 : list_np)
			setup_type(stringf("$_DLATCH_%c_", c1), {ID::E, ID::D}, {ID::Q});

		for (auto c1 : list_np)
		for (auto c2 : list_np)
		for (auto c3 : list_01)
			setup_type(stringf("$_DLATCH_%c%c%c_", c1, c2, c3), {ID::E, ID::R, ID::D}, {ID::Q});

		for (auto c1 : list_np)
		for (auto c2 : list_np)
		for (auto c3 : list_np)
			setup_type(stringf("$_DLATCHSR_%c%c%c_", c1, c2, c3), {ID::E, ID::S, ID::R, ID::D}, {ID::Q});
	}

	void clear()
	{
		cell_types.clear();
	}

	bool cell_known(RTLIL::IdString type) const
	{
		return cell_types.count(type) != 0;
	}

	bool cell_output(RTLIL::IdString type, RTLIL::IdString port) const
	{
		auto it = cell_types.find(type);
		return it != cell_types.end() && it->second.outputs.count(port) != 0;
	}

	bool cell_input(RTLIL::IdString type, RTLIL::IdString port) const
	{
		auto it = cell_types.find(type);
		return it != cell_types.end() && it->second.inputs.count(port) != 0;
	}

	bool cell_evaluable(RTLIL::IdString type) const
	{
		auto it = cell_types.find(type);
		return it != cell_types.end() && it->second.is_evaluable;
	}

	static RTLIL::Const eval_not(RTLIL::Const v)
	{
		for (auto &bit : v.bits)
			if (bit == State::S0) bit = State::S1;
			else if (bit == State::S1) bit = State::S0;
		return v;
	}

	static RTLIL::Const eval(RTLIL::IdString type, const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len, bool *errp = nullptr)
	{
		if (type == ID($sshr) && !signed1)
			type = ID($shr);
		if (type == ID($sshl) && !signed1)
			type = ID($shl);

		if (type != ID($sshr) && type != ID($sshl) && type != ID($shr) && type != ID($shl) && type != ID($shift) && type != ID($shiftx) &&
				type != ID($pos) && type != ID($neg) && type != ID($not)) {
			if (!signed1 || !signed2)
				signed1 = false, signed2 = false;
		}

#define HANDLE_CELL_TYPE(_t) if (type == ID($##_t)) return const_ ## _t(arg1, arg2, signed1, signed2, result_len);
		HANDLE_CELL_TYPE(not)
		HANDLE_CELL_TYPE(and)
		HANDLE_CELL_TYPE(or)
		HANDLE_CELL_TYPE(xor)
		HANDLE_CELL_TYPE(xnor)
		HANDLE_CELL_TYPE(reduce_and)
		HANDLE_CELL_TYPE(reduce_or)
		HANDLE_CELL_TYPE(reduce_xor)
		HANDLE_CELL_TYPE(reduce_xnor)
		HANDLE_CELL_TYPE(reduce_bool)
		HANDLE_CELL_TYPE(logic_not)
		HANDLE_CELL_TYPE(logic_and)
		HANDLE_CELL_TYPE(logic_or)
		HANDLE_CELL_TYPE(shl)
		HANDLE_CELL_TYPE(shr)
		HANDLE_CELL_TYPE(sshl)
		HANDLE_CELL_TYPE(sshr)
		HANDLE_CELL_TYPE(shift)
		HANDLE_CELL_TYPE(shiftx)
		HANDLE_CELL_TYPE(lt)
		HANDLE_CELL_TYPE(le)
		HANDLE_CELL_TYPE(eq)
		HANDLE_CELL_TYPE(ne)
		HANDLE_CELL_TYPE(eqx)
		HANDLE_CELL_TYPE(nex)
		HANDLE_CELL_TYPE(ge)
		HANDLE_CELL_TYPE(gt)
		HANDLE_CELL_TYPE(add)
		HANDLE_CELL_TYPE(sub)
		HANDLE_CELL_TYPE(mul)
		HANDLE_CELL_TYPE(div)
		HANDLE_CELL_TYPE(mod)
		HANDLE_CELL_TYPE(divfloor)
		HANDLE_CELL_TYPE(modfloor)
		HANDLE_CELL_TYPE(pow)
		HANDLE_CELL_TYPE(pos)
		HANDLE_CELL_TYPE(neg)
#undef HANDLE_CELL_TYPE

		if (type == ID($_BUF_))
			return arg1;
		if (type == ID($_NOT_))
			return eval_not(arg1);
		if (type == ID($_AND_))
			return const_and(arg1, arg2, false, false, 1);
		if (type == ID($_NAND_))
			return eval_not(const_and(arg1, arg2, false, false, 1));
		if (type == ID($_OR_))
			return const_or(arg1, arg2, false, false, 1);
		if (type == ID($_NOR_))
			return eval_not(const_or(arg1, arg2, false, false, 1));
		if (type == ID($_XOR_))
			return const_xor(arg1, arg2, false, false, 1);
		if (type == ID($_XNOR_))
			return const_xnor(arg1, arg2, false, false, 1);
		if (type == ID($_ANDNOT_))
			return const_and(arg1, eval_not(arg2), false, false, 1);
		if (type == ID($_ORNOT_))
			return const_or(arg1, eval_not(arg2), false, false, 1);

		if (errp != nullptr) {
			*errp = true;
			return State::Sm;
		}

		log_abort();
	}

	static RTLIL::Const eval(RTLIL::Cell *cell, const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool *errp = nullptr)
	{
		if (cell->type == ID($slice)) {
			RTLIL::Const ret;
			int width = cell->parameters.at(ID::Y_WIDTH).as_int();
			int offset = cell->parameters.at(ID::OFFSET).as_int();
			ret.bits.insert(ret.bits.end(), arg1.bits.begin()+offset, arg1.bits.begin()+offset+width);
			return ret;
		}

		if (cell->type == ID($concat)) {
			RTLIL::Const ret = arg1;
			ret.bits.insert(ret.bits.end(), arg2.bits.begin(), arg2.bits.end());
			return ret;
		}

		if (cell->type == ID($bmux))
		{
			return const_bmux(arg1, arg2);
		}

		if (cell->type == ID($demux))
		{
			return const_demux(arg1, arg2);
		}

		if (cell->type == ID($bweqx))
		{
			return const_bweqx(arg1, arg2);
		}

		if (cell->type == ID($lut))
		{
			int width = cell->parameters.at(ID::WIDTH).as_int();

			std::vector<RTLIL::State> t = cell->parameters.at(ID::LUT).bits;
			while (GetSize(t) < (1 << width))
				t.push_back(State::S0);
			t.resize(1 << width);

			return const_bmux(t, arg1);
		}

		if (cell->type == ID($sop))
		{
			int width = cell->parameters.at(ID::WIDTH).as_int();
			int depth = cell->parameters.at(ID::DEPTH).as_int();
			std::vector<RTLIL::State> t = cell->parameters.at(ID::TABLE).bits;

			while (GetSize(t) < width*depth*2)
				t.push_back(State::S0);

			RTLIL::State default_ret = State::S0;

			for (int i = 0; i < depth; i++)
			{
				bool match = true;
				bool match_x = true;

				for (int j = 0; j < width; j++) {
					RTLIL::State a = arg1.bits.at(j);
					if (t.at(2*width*i + 2*j + 0) == State::S1) {
						if (a == State::S1) match_x = false;
						if (a != State::S0) match = false;
					}
					if (t.at(2*width*i + 2*j + 1) == State::S1) {
						if (a == State::S0) match_x = false;
						if (a != State::S1) match = false;
					}
				}

				if (match)
					return State::S1;

				if (match_x)
					default_ret = State::Sx;
			}

			return default_ret;
		}

		bool signed_a = cell->parameters.count(ID::A_SIGNED) > 0 && cell->parameters[ID::A_SIGNED].as_bool();
		bool signed_b = cell->parameters.count(ID::B_SIGNED) > 0 && cell->parameters[ID::B_SIGNED].as_bool();
		int result_len = cell->parameters.count(ID::Y_WIDTH) > 0 ? cell->parameters[ID::Y_WIDTH].as_int() : -1;
		return eval(cell->type, arg1, arg2, signed_a, signed_b, result_len, errp);
	}

	static RTLIL::Const eval(RTLIL::Cell *cell, const RTLIL::Const &arg1, const RTLIL::Const &arg2, const RTLIL::Const &arg3, bool *errp = nullptr)
	{
		if (cell->type.in(ID($mux), ID($_MUX_)))
			return const_mux(arg1, arg2, arg3);
		if (cell->type == ID($bwmux))
			return const_bwmux(arg1, arg2, arg3);
		if (cell->type == ID($pmux))
			return const_pmux(arg1, arg2, arg3);
		if (cell->type == ID($_AOI3_))
			return eval_not(const_or(const_and(arg1, arg2, false, false, 1), arg3, false, false, 1));
		if (cell->type == ID($_OAI3_))
			return eval_not(const_and(const_or(arg1, arg2, false, false, 1), arg3, false, false, 1));

		log_assert(arg3.bits.size() == 0);
		return eval(cell, arg1, arg2, errp);
	}

	static RTLIL::Const eval(RTLIL::Cell *cell, const RTLIL::Const &arg1, const RTLIL::Const &arg2, const RTLIL::Const &arg3, const RTLIL::Const &arg4, bool *errp = nullptr)
	{
		if (cell->type == ID($_AOI4_))
			return eval_not(const_or(const_and(arg1, arg2, false, false, 1), const_and(arg3, arg4, false, false, 1), false, false, 1));
		if (cell->type == ID($_OAI4_))
			return eval_not(const_and(const_or(arg1, arg2, false, false, 1), const_or(arg3, arg4, false, false, 1), false, false, 1));

		log_assert(arg4.bits.size() == 0);
		return eval(cell, arg1, arg2, arg3, errp);
	}
};

// initialized by yosys_setup()
extern CellTypes yosys_celltypes;

YOSYS_NAMESPACE_END

#endif
`,"consteval.h":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef CONSTEVAL_H
#define CONSTEVAL_H

#include "kernel/rtlil.h"
#include "kernel/sigtools.h"
#include "kernel/celltypes.h"
#include "kernel/macc.h"

YOSYS_NAMESPACE_BEGIN

struct ConstEval
{
	RTLIL::Module *module;
	SigMap assign_map;
	SigMap values_map;
	SigPool stop_signals;
	SigSet<RTLIL::Cell*> sig2driver;
	std::set<RTLIL::Cell*> busy;
	std::vector<SigMap> stack;
	RTLIL::State defaultval;

	ConstEval(RTLIL::Module *module, RTLIL::State defaultval = RTLIL::State::Sm) : module(module), assign_map(module), defaultval(defaultval)
	{
		CellTypes ct;
		ct.setup_internals();
		ct.setup_stdcells();

		for (auto &it : module->cells_) {
			if (!ct.cell_known(it.second->type))
				continue;
			for (auto &it2 : it.second->connections())
				if (ct.cell_output(it.second->type, it2.first))
					sig2driver.insert(assign_map(it2.second), it.second);
		}
	}

	void clear()
	{
		values_map.clear();
		stop_signals.clear();
	}

	void push()
	{
		stack.push_back(values_map);
	}

	void pop()
	{
		values_map.swap(stack.back());
		stack.pop_back();
	}

	void set(RTLIL::SigSpec sig, RTLIL::Const value)
	{
		assign_map.apply(sig);
#ifndef NDEBUG
		RTLIL::SigSpec current_val = values_map(sig);
		for (int i = 0; i < GetSize(current_val); i++)
			log_assert(current_val[i].wire != NULL || current_val[i] == value.bits[i]);
#endif
		values_map.add(sig, RTLIL::SigSpec(value));
	}

	void stop(RTLIL::SigSpec sig)
	{
		assign_map.apply(sig);
		stop_signals.add(sig);
	}

	bool eval(RTLIL::Cell *cell, RTLIL::SigSpec &undef)
	{
		if (cell->type == ID($lcu))
		{
			RTLIL::SigSpec sig_p = cell->getPort(ID::P);
			RTLIL::SigSpec sig_g = cell->getPort(ID::G);
			RTLIL::SigSpec sig_ci = cell->getPort(ID::CI);
			RTLIL::SigSpec sig_co = values_map(assign_map(cell->getPort(ID::CO)));

			if (sig_co.is_fully_const())
				return true;

			if (!eval(sig_p, undef, cell))
				return false;

			if (!eval(sig_g, undef, cell))
				return false;

			if (!eval(sig_ci, undef, cell))
				return false;

			if (sig_p.is_fully_def() && sig_g.is_fully_def() && sig_ci.is_fully_def())
			{
				RTLIL::Const coval(RTLIL::Sx, GetSize(sig_co));
				bool carry = sig_ci.as_bool();

				for (int i = 0; i < GetSize(coval); i++) {
					carry = (sig_g[i] == State::S1) || (sig_p[i] == RTLIL::S1 && carry);
					coval.bits[i] = carry ? State::S1 : State::S0;
				}

				set(sig_co, coval);
			}
			else
				set(sig_co, RTLIL::Const(RTLIL::Sx, GetSize(sig_co)));

			return true;
		}

		RTLIL::SigSpec sig_a, sig_b, sig_s, sig_y;

		log_assert(cell->hasPort(ID::Y));
		sig_y = values_map(assign_map(cell->getPort(ID::Y)));
		if (sig_y.is_fully_const())
			return true;

		if (cell->hasPort(ID::S)) {
			sig_s = cell->getPort(ID::S);
		}

		if (cell->hasPort(ID::A))
			sig_a = cell->getPort(ID::A);

		if (cell->hasPort(ID::B))
			sig_b = cell->getPort(ID::B);

		if (cell->type.in(ID($mux), ID($pmux), ID($_MUX_), ID($_NMUX_)))
		{
			std::vector<RTLIL::SigSpec> y_candidates;
			int count_set_s_bits = 0;

			if (!eval(sig_s, undef, cell))
				return false;

			for (int i = 0; i < sig_s.size(); i++)
			{
				RTLIL::State s_bit = sig_s.extract(i, 1).as_const().bits.at(0);
				RTLIL::SigSpec b_slice = sig_b.extract(sig_y.size()*i, sig_y.size());

				if (s_bit == RTLIL::State::Sx || s_bit == RTLIL::State::S1)
					y_candidates.push_back(b_slice);

				if (s_bit == RTLIL::State::S1)
					count_set_s_bits++;
			}

			if (count_set_s_bits == 0)
				y_candidates.push_back(sig_a);

			std::vector<RTLIL::Const> y_values;

			log_assert(y_candidates.size() > 0);
			for (auto &yc : y_candidates) {
				if (!eval(yc, undef, cell))
					return false;
				if (cell->type == ID($_NMUX_))
					y_values.push_back(RTLIL::const_not(yc.as_const(), Const(), false, false, GetSize(yc)));
				else
					y_values.push_back(yc.as_const());
			}

			if (y_values.size() > 1)
			{
				std::vector<RTLIL::State> master_bits = y_values.at(0).bits;

				for (size_t i = 1; i < y_values.size(); i++) {
					std::vector<RTLIL::State> &slave_bits = y_values.at(i).bits;
					log_assert(master_bits.size() == slave_bits.size());
					for (size_t j = 0; j < master_bits.size(); j++)
						if (master_bits[j] != slave_bits[j])
							master_bits[j] = RTLIL::State::Sx;
				}

				set(sig_y, RTLIL::Const(master_bits));
			}
			else
				set(sig_y, y_values.front());
		}
		else if (cell->type == ID($bmux))
		{
			if (!eval(sig_s, undef, cell))
				return false;

			if (sig_s.is_fully_def()) {
				int sel = sig_s.as_int();
				int width = GetSize(sig_y);
				SigSpec res = sig_a.extract(sel * width, width);
				if (!eval(res, undef, cell))
					return false;
				set(sig_y, res.as_const());
			} else {
				if (!eval(sig_a, undef, cell))
					return false;
				set(sig_y, const_bmux(sig_a.as_const(), sig_s.as_const()));
			}
		}
		else if (cell->type == ID($demux))
		{
			if (!eval(sig_a, undef, cell))
				return false;
			if (sig_a.is_fully_zero()) {
				set(sig_y, Const(0, GetSize(sig_y)));
			} else {
				if (!eval(sig_s, undef, cell))
					return false;
				set(sig_y, const_demux(sig_a.as_const(), sig_s.as_const()));
			}
		}
		else if (cell->type == ID($fa))
		{
			RTLIL::SigSpec sig_c = cell->getPort(ID::C);
			RTLIL::SigSpec sig_x = cell->getPort(ID::X);
			int width = GetSize(sig_c);

			if (!eval(sig_a, undef, cell))
				return false;

			if (!eval(sig_b, undef, cell))
				return false;

			if (!eval(sig_c, undef, cell))
				return false;

			RTLIL::Const t1 = const_xor(sig_a.as_const(), sig_b.as_const(), false, false, width);
			RTLIL::Const val_y = const_xor(t1, sig_c.as_const(), false, false, width);

			RTLIL::Const t2 = const_and(sig_a.as_const(), sig_b.as_const(), false, false, width);
			RTLIL::Const t3 = const_and(sig_c.as_const(), t1, false, false, width);
			RTLIL::Const val_x = const_or(t2, t3, false, false, width);

			for (int i = 0; i < GetSize(val_y); i++)
				if (val_y.bits[i] == RTLIL::Sx)
					val_x.bits[i] = RTLIL::Sx;

			set(sig_y, val_y);
			set(sig_x, val_x);
		}
		else if (cell->type == ID($alu))
		{
			bool signed_a = cell->parameters.count(ID::A_SIGNED) > 0 && cell->parameters[ID::A_SIGNED].as_bool();
			bool signed_b = cell->parameters.count(ID::B_SIGNED) > 0 && cell->parameters[ID::B_SIGNED].as_bool();

			RTLIL::SigSpec sig_ci = cell->getPort(ID::CI);
			RTLIL::SigSpec sig_bi = cell->getPort(ID::BI);

			if (!eval(sig_a, undef, cell))
				return false;

			if (!eval(sig_b, undef, cell))
				return false;

			if (!eval(sig_ci, undef, cell))
				return false;

			if (!eval(sig_bi, undef, cell))
				return false;

			RTLIL::SigSpec sig_x = cell->getPort(ID::X);
			RTLIL::SigSpec sig_co = cell->getPort(ID::CO);

			bool any_input_undef = !(sig_a.is_fully_def() && sig_b.is_fully_def() && sig_ci.is_fully_def() && sig_bi.is_fully_def());
			sig_a.extend_u0(GetSize(sig_y), signed_a);
			sig_b.extend_u0(GetSize(sig_y), signed_b);

			bool carry = sig_ci[0] == State::S1;
			bool b_inv = sig_bi[0] == State::S1;

			for (int i = 0; i < GetSize(sig_y); i++)
			{
				RTLIL::SigSpec x_inputs = { sig_a[i], sig_b[i], sig_bi[0] };

				if (!x_inputs.is_fully_def()) {
					set(sig_x[i], RTLIL::Sx);
				} else {
					bool bit_a = sig_a[i] == State::S1;
					bool bit_b = (sig_b[i] == State::S1) != b_inv;
					bool bit_x = bit_a != bit_b;
					set(sig_x[i], bit_x ? State::S1 : State::S0);
				}

				if (any_input_undef) {
					set(sig_y[i], RTLIL::Sx);
					set(sig_co[i], RTLIL::Sx);
				} else {
					bool bit_a = sig_a[i] == State::S1;
					bool bit_b = (sig_b[i] == State::S1) != b_inv;
					bool bit_y = (bit_a != bit_b) != carry;
					carry = (bit_a && bit_b) || (bit_a && carry) || (bit_b && carry);
					set(sig_y[i], bit_y ? State::S1 : State::S0);
					set(sig_co[i], carry ? State::S1 : State::S0);
				}
			}
		}
		else if (cell->type == ID($macc))
		{
			Macc macc;
			macc.from_cell(cell);

			if (!eval(macc.bit_ports, undef, cell))
				return false;

			for (auto &port : macc.ports) {
				if (!eval(port.in_a, undef, cell))
					return false;
				if (!eval(port.in_b, undef, cell))
					return false;
			}

			RTLIL::Const result(0, GetSize(cell->getPort(ID::Y)));
			if (!macc.eval(result))
				log_abort();

			set(cell->getPort(ID::Y), result);
		}
		else
		{
			RTLIL::SigSpec sig_c, sig_d;

			if (cell->type.in(ID($_AOI3_), ID($_OAI3_), ID($_AOI4_), ID($_OAI4_))) {
				if (cell->hasPort(ID::C))
					sig_c = cell->getPort(ID::C);
				if (cell->hasPort(ID::D))
					sig_d = cell->getPort(ID::D);
			}

			if (sig_a.size() > 0 && !eval(sig_a, undef, cell))
				return false;
			if (sig_b.size() > 0 && !eval(sig_b, undef, cell))
				return false;
			if (sig_c.size() > 0 && !eval(sig_c, undef, cell))
				return false;
			if (sig_d.size() > 0 && !eval(sig_d, undef, cell))
				return false;

			bool eval_err = false;
			RTLIL::Const eval_ret = CellTypes::eval(cell, sig_a.as_const(), sig_b.as_const(), sig_c.as_const(), sig_d.as_const(), &eval_err);

			if (eval_err)
				return false;

			set(sig_y, eval_ret);
		}

		return true;
	}

	bool eval(RTLIL::SigSpec &sig, RTLIL::SigSpec &undef, RTLIL::Cell *busy_cell = NULL)
	{
		assign_map.apply(sig);
		values_map.apply(sig);

		if (sig.is_fully_const())
			return true;

		if (stop_signals.check_any(sig)) {
			undef = stop_signals.extract(sig);
			return false;
		}

		if (busy_cell) {
			if (busy.count(busy_cell) > 0) {
				undef = sig;
				return false;
			}
			busy.insert(busy_cell);
		}

		std::set<RTLIL::Cell*> driver_cells;
		sig2driver.find(sig, driver_cells);
		for (auto cell : driver_cells) {
			if (!eval(cell, undef)) {
				if (busy_cell)
					busy.erase(busy_cell);
				return false;
			}
		}

		if (busy_cell)
			busy.erase(busy_cell);

		values_map.apply(sig);
		if (sig.is_fully_const())
			return true;

		if (defaultval != RTLIL::State::Sm) {
			for (auto &bit : sig)
				if (bit.wire) bit = defaultval;
			return true;
		}

		for (auto &c : sig.chunks())
			if (c.wire != NULL)
				undef.append(c);
		return false;
	}

	bool eval(RTLIL::SigSpec &sig)
	{
		RTLIL::SigSpec undef;
		return eval(sig, undef);
	}
};

YOSYS_NAMESPACE_END

#endif
`,"constids.inc":`X(A)
X(abc9_box)
X(abc9_box_id)
X(abc9_box_seq)
X(abc9_bypass)
X(abc9_carry)
X(abc9_flop)
X(abc9_keep)
X(abc9_lut)
X(abc9_mergeability)
X(abc9_scc_id)
X(abcgroup)
X(ABITS)
X(AD)
X(ADDR)
X(allconst)
X(allseq)
X(ALOAD)
X(ALOAD_POLARITY)
X(always_comb)
X(always_ff)
X(always_latch)
X(anyconst)
X(anyseq)
X(ARGS)
X(ARGS_WIDTH)
X(ARST)
X(ARST_POLARITY)
X(ARST_VALUE)
X(A_SIGNED)
X(A_WIDTH)
X(B)
X(BI)
X(BITS_USED)
X(blackbox)
X(B_SIGNED)
X(bugpoint_keep)
X(B_WIDTH)
X(BYTE)
X(C)
X(cells_not_processed)
X(CE_OVER_SRST)
X(CFG_ABITS)
X(CFG_DBITS)
X(CFG_INIT)
X(CI)
X(CLK)
X(clkbuf_driver)
X(clkbuf_inhibit)
X(clkbuf_inv)
X(clkbuf_sink)
X(CLK_ENABLE)
X(CLK_POLARITY)
X(CLR)
X(CLR_POLARITY)
X(CO)
X(COLLISION_X_MASK)
X(CONFIG)
X(CONFIG_WIDTH)
X(CTRL_IN)
X(CTRL_IN_WIDTH)
X(CTRL_OUT)
X(CTRL_OUT_WIDTH)
X(D)
X(DAT)
X(DATA)
X(DAT_DST_PEN)
X(DAT_DST_POL)
X(defaultvalue)
X(DELAY)
X(DEPTH)
X(DST)
X(DST_EN)
X(DST_PEN)
X(DST_POL)
X(DST_WIDTH)
X(dynports)
X(E)
X(EDGE_EN)
X(EDGE_POL)
X(EN)
X(EN_DST)
X(EN_POLARITY)
X(EN_SRC)
X(enum_base_type)
X(enum_type)
X(equiv_merged)
X(equiv_region)
X(extract_order)
X(F)
X(FLAVOR)
X(FORMAT)
X(force_downto)
X(force_upto)
X(fsm_encoding)
X(fsm_export)
X(FULL)
X(full_case)
X(G)
X(gclk)
X(gentb_clock)
X(gentb_constant)
X(gentb_skip)
X(H)
X(hdlname)
X(hierconn)
X(I)
X(INIT)
X(INIT_VALUE)
X(init)
X(initial_top)
X(interface_modport)
X(interfaces_replaced_in_module)
X(interface_type)
X(invertible_pin)
X(iopad_external_pin)
X(is_interface)
X(J)
X(K)
X(keep)
X(keep_hierarchy)
X(L)
X(lib_whitebox)
X(localparam)
X(logic_block)
X(lram)
X(LUT)
X(lut_keep)
X(M)
X(maximize)
X(mem2reg)
X(MEMID)
X(minimize)
X(module_not_derived)
X(N)
X(NAME)
X(noblackbox)
X(nolatches)
X(nomem2init)
X(nomem2reg)
X(nomeminit)
X(nosync)
X(nowrshmsk)
X(no_ram)
X(no_rw_check)
X(O)
X(OFFSET)
X(onehot)
X(P)
X(parallel_case)
X(parameter)
X(PORTID)
X(PRIORITY)
X(PRIORITY_MASK)
X(Q)
X(qwp_position)
X(R)
X(ram_block)
X(ram_style)
X(ramstyle)
X(RD_ADDR)
X(RD_ARST)
X(RD_ARST_VALUE)
X(RD_CE_OVER_SRST)
X(RD_CLK)
X(RD_CLK_ENABLE)
X(RD_CLK_POLARITY)
X(RD_COLLISION_X_MASK)
X(RD_DATA)
X(RD_EN)
X(RD_INIT_VALUE)
X(RD_PORTS)
X(RD_SRST)
X(RD_SRST_VALUE)
X(RD_TRANSPARENCY_MASK)
X(RD_TRANSPARENT)
X(RD_WIDE_CONTINUATION)
X(reg)
X(replaced_by_gclk)
X(reprocess_after)
X(rom_block)
X(rom_style)
X(romstyle)
X(S)
X(SET)
X(SET_POLARITY)
X(SIZE)
X(SRC)
X(src)
X(SRC_DST_PEN)
X(SRC_DST_POL)
X(SRC_EN)
X(SRC_PEN)
X(SRC_POL)
X(SRC_WIDTH)
X(SRST)
X(SRST_POLARITY)
X(SRST_VALUE)
X(sta_arrival)
X(STATE_BITS)
X(STATE_NUM)
X(STATE_NUM_LOG2)
X(STATE_RST)
X(STATE_TABLE)
X(smtlib2_module)
X(smtlib2_comb_expr)
X(submod)
X(syn_ramstyle)
X(syn_romstyle)
X(S_WIDTH)
X(T)
X(TABLE)
X(TAG)
X(techmap_autopurge)
X(_TECHMAP_BITS_CONNMAP_)
X(_TECHMAP_CELLNAME_)
X(_TECHMAP_CELLTYPE_)
X(techmap_celltype)
X(_TECHMAP_FAIL_)
X(techmap_maccmap)
X(_TECHMAP_REPLACE_)
X(techmap_simplemap)
X(_techmap_special_)
X(techmap_wrap)
X(_TECHMAP_PLACEHOLDER_)
X(techmap_chtype)
X(T_FALL_MAX)
X(T_FALL_MIN)
X(T_FALL_TYP)
X(T_LIMIT)
X(T_LIMIT2)
X(T_LIMIT2_MAX)
X(T_LIMIT2_MIN)
X(T_LIMIT2_TYP)
X(T_LIMIT_MAX)
X(T_LIMIT_MIN)
X(T_LIMIT_TYP)
X(to_delete)
X(top)
X(TRANS_NUM)
X(TRANSPARENCY_MASK)
X(TRANSPARENT)
X(TRANS_TABLE)
X(TRG)
X(TRG_ENABLE)
X(TRG_POLARITY)
X(TRG_WIDTH)
X(T_RISE_MAX)
X(T_RISE_MIN)
X(T_RISE_TYP)
X(TYPE)
X(U)
X(unique)
X(unused_bits)
X(V)
X(via_celltype)
X(wand)
X(whitebox)
X(WIDTH)
X(wildcard_port_conns)
X(wiretype)
X(wor)
X(WORDS)
X(WR_ADDR)
X(WR_CLK)
X(WR_CLK_ENABLE)
X(WR_CLK_POLARITY)
X(WR_DATA)
X(WR_EN)
X(WR_PORTS)
X(WR_PRIORITY_MASK)
X(WR_WIDE_CONTINUATION)
X(X)
X(xprop_decoder)
X(Y)
X(Y_WIDTH)
`,"cost.h":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef COST_H
#define COST_H

#include "kernel/yosys.h"

YOSYS_NAMESPACE_BEGIN

struct CellCosts
{
	static const dict<RTLIL::IdString, int>& default_gate_cost() {
		static const dict<RTLIL::IdString, int> db = {
			{ ID($_BUF_),    1 },
			{ ID($_NOT_),    2 },
			{ ID($_AND_),    4 },
			{ ID($_NAND_),   4 },
			{ ID($_OR_),     4 },
			{ ID($_NOR_),    4 },
			{ ID($_ANDNOT_), 4 },
			{ ID($_ORNOT_),  4 },
			{ ID($_XOR_),    5 },
			{ ID($_XNOR_),   5 },
			{ ID($_AOI3_),   6 },
			{ ID($_OAI3_),   6 },
			{ ID($_AOI4_),   7 },
			{ ID($_OAI4_),   7 },
			{ ID($_MUX_),    4 },
			{ ID($_NMUX_),   4 }
		};
		return db;
	}

	static const dict<RTLIL::IdString, int>& cmos_gate_cost() {
		static const dict<RTLIL::IdString, int> db = {
			{ ID($_BUF_),     1 },
			{ ID($_NOT_),     2 },
			{ ID($_AND_),     6 },
			{ ID($_NAND_),    4 },
			{ ID($_OR_),      6 },
			{ ID($_NOR_),     4 },
			{ ID($_ANDNOT_),  6 },
			{ ID($_ORNOT_),   6 },
			{ ID($_XOR_),    12 },
			{ ID($_XNOR_),   12 },
			{ ID($_AOI3_),    6 },
			{ ID($_OAI3_),    6 },
			{ ID($_AOI4_),    8 },
			{ ID($_OAI4_),    8 },
			{ ID($_MUX_),    12 },
			{ ID($_NMUX_),   10 }
		};
		return db;
	}

	dict<RTLIL::IdString, int> mod_cost_cache;
	const dict<RTLIL::IdString, int> *gate_cost = nullptr;
	Design *design = nullptr;

	int get(RTLIL::IdString type) const
	{
		if (gate_cost && gate_cost->count(type))
			return gate_cost->at(type);

		log_warning("Can't determine cost of %s cell.\\n", log_id(type));
		return 1;
	}

	int get(RTLIL::Cell *cell)
	{
		if (gate_cost && gate_cost->count(cell->type))
			return gate_cost->at(cell->type);

		if (design && design->module(cell->type) && cell->parameters.empty())
		{
			RTLIL::Module *mod = design->module(cell->type);

			if (mod->attributes.count(ID(cost)))
				return mod->attributes.at(ID(cost)).as_int();

			if (mod_cost_cache.count(mod->name))
				return mod_cost_cache.at(mod->name);

			int module_cost = 1;
			for (auto c : mod->cells())
				module_cost += get(c);

			mod_cost_cache[mod->name] = module_cost;
			return module_cost;
		}

		log_warning("Can't determine cost of %s cell (%d parameters).\\n", log_id(cell->type), GetSize(cell->parameters));
		return 1;
	}
};

YOSYS_NAMESPACE_END

#endif
`,"ff.h":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2020  Marcelina Ko\u015Bcielnicka <mwk@0x04.net>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef FF_H
#define FF_H

#include "kernel/yosys.h"
#include "kernel/ffinit.h"

YOSYS_NAMESPACE_BEGIN

// Describes a flip-flop or a latch.
//
// If has_gclk, this is a formal verification FF with implicit global clock:
// Q is simply previous cycle's D. Additionally if is_anyinit is true, this is
// an $anyinit cell which always has an undefined initialization value. Note
// that $anyinit is not considered to be among the FF celltypes, so a pass has
// to explicitly opt-in to process $anyinit cells with FfData.
//
// Otherwise, the FF/latch can have any number of features selected by has_*
// attributes that determine Q's value (in order of decreasing priority):
//
// - on start, register is initialized to val_init
// - if has_sr is present:
//   - sig_clr is per-bit async clear, and sets the corresponding bit to 0
//     if active
//   - sig_set is per-bit async set, and sets the corresponding bit to 1
//     if active
// - if has_arst is present:
//   - sig_arst is whole-reg async reset, and sets the whole register to val_arst
// - if has_aload is present:
//   - sig_aload is whole-reg async load (aka latch gate enable), and sets the whole
//     register to sig_ad
// - if has_clk is present, and we're currently on a clock edge:
//   - if has_ce is present and ce_over_srst is true:
//     - ignore clock edge (don't change value) unless sig_ce is active
//   - if has_srst is present:
//     - sig_srst is whole-reg sync reset and sets the register to val_srst
//   - if has_ce is present and ce_over_srst is false:
//     - ignore clock edge (don't change value) unless sig_ce is active
//   - set whole reg to sig_d
// - if nothing of the above applies, the reg value remains unchanged
//
// Since the yosys FF cell library isn't fully generic, not all combinations
// of the features above can be supported:
//
// - only one of has_srst, has_arst, has_sr can be used
// - if has_clk is used together with has_aload, then has_srst, has_arst,
//   has_sr cannot be used
//
// The valid feature combinations are thus:
//
// - has_clk + optional has_ce [dff/dffe]
// - has_clk + optional has_ce + has_arst [adff/adffe]
// - has_clk + optional has_ce + has_aload [aldff/aldffe]
// - has_clk + optional has_ce + has_sr [dffsr/dffsre]
// - has_clk + optional has_ce + has_srst [sdff/sdffe/sdffce]
// - has_aload [dlatch]
// - has_aload + has_arst [adlatch]
// - has_aload + has_sr [dlatchsr]
// - has_sr [sr]
// - has_arst [does not correspond to a native cell, represented as dlatch with const D input]
// - empty set [not a cell \u2014 will be emitted as a simple direct connection]

struct FfData {
	Module *module;
	FfInitVals *initvals;
	Cell *cell;
	IdString name;
	// The FF output.
	SigSpec sig_q;
	// The sync data input, present if has_clk or has_gclk.
	SigSpec sig_d;
	// The async data input, present if has_aload.
	SigSpec sig_ad;
	// The sync clock, present if has_clk.
	SigSpec sig_clk;
	// The clock enable, present if has_ce.
	SigSpec sig_ce;
	// The async load enable, present if has_aload.
	SigSpec sig_aload;
	// The async reset, preset if has_arst.
	SigSpec sig_arst;
	// The sync reset, preset if has_srst.
	SigSpec sig_srst;
	// The async clear (per-lane), present if has_sr.
	SigSpec sig_clr;
	// The async set (per-lane), present if has_sr.
	SigSpec sig_set;
	// True if this is a clocked (edge-sensitive) flip-flop.
	bool has_clk;
	// True if this is a $ff, exclusive with every other has_*.
	bool has_gclk;
	// True if this FF has a clock enable.  Depends on has_clk.
	bool has_ce;
	// True if this FF has async load function \u2014 this includes D latches.
	// If this and has_clk are both set, has_arst and has_sr cannot be set.
	bool has_aload;
	// True if this FF has sync set/reset.  Depends on has_clk, exclusive
	// with has_arst, has_sr, has_aload.
	bool has_srst;
	// True if this FF has async set/reset.  Exclusive with has_srst,
	// has_sr.  If this and has_clk are both set, has_aload cannot be set.
	bool has_arst;
	// True if this FF has per-bit async set + clear.  Exclusive with
	// has_srst, has_arst.  If this and has_clk are both set, has_aload
	// cannot be set.
	bool has_sr;
	// If has_ce and has_srst are both set, determines their relative
	// priorities: if true, inactive ce disables srst; if false, srst
	// operates independent of ce.
	bool ce_over_srst;
	// True if this FF is a fine cell, false if it is a coarse cell.
	// If true, width must be 1.
	bool is_fine;
	// True if this FF is an $anyinit cell.  Depends on has_gclk.
	bool is_anyinit;
	// Polarities, corresponding to sig_*.  True means active-high, false
	// means active-low.
	bool pol_clk;
	bool pol_ce;
	bool pol_aload;
	bool pol_arst;
	bool pol_srst;
	bool pol_clr;
	bool pol_set;
	// The value loaded by sig_arst.
	Const val_arst;
	// The value loaded by sig_srst.
	Const val_srst;
	// The initial value at power-up.
	Const val_init;
	// The FF data width in bits.
	int width;
	dict<IdString, Const> attributes;

	FfData(Module *module = nullptr, FfInitVals *initvals = nullptr, IdString name = IdString()) : module(module), initvals(initvals), cell(nullptr), name(name) {
		width = 0;
		has_clk = false;
		has_gclk = false;
		has_ce = false;
		has_aload = false;
		has_srst = false;
		has_arst = false;
		has_sr = false;
		ce_over_srst = false;
		is_fine = false;
		is_anyinit = false;
		pol_clk = false;
		pol_aload = false;
		pol_ce = false;
		pol_arst = false;
		pol_srst = false;
		pol_clr = false;
		pol_set = false;
	}

	FfData(FfInitVals *initvals, Cell *cell_);

	// Returns a FF identical to this one, but only keeping bit indices from the argument.
	FfData slice(const std::vector<int> &bits);

	void add_dummy_ce();
	void add_dummy_srst();
	void add_dummy_arst();
	void add_dummy_aload();
	void add_dummy_sr();
	void add_dummy_clk();

	void arst_to_aload();
	void arst_to_sr();

	void aload_to_sr();

	// Given a FF with both has_ce and has_srst, sets ce_over_srst to the given value and
	// fixes up control signals appropriately to preserve semantics.
	void convert_ce_over_srst(bool val);

	void unmap_ce();
	void unmap_srst();

	void unmap_ce_srst() {
		unmap_ce();
		unmap_srst();
	}

	Cell *emit();

	// Removes init attribute from the Q output, but keeps val_init unchanged.
	// It will be automatically reattached on emit.  Use this before changing sig_q.
	void remove_init() {
		if (initvals)
			initvals->remove_init(sig_q);
	}

	void remove();

	// Flip the sense of the given bit slices of the FF: insert inverters on data
	// inputs and output, flip the corresponding init/reset bits, swap clr/set
	// inputs with proper priority fix.
	void flip_bits(const pool<int> &bits);

	void flip_rst_bits(const pool<int> &bits);
};

YOSYS_NAMESPACE_END

#endif
`,"ffinit.h":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2020  Marcelina Ko\u015Bcielnicka <mwk@0x04.net>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef FFINIT_H
#define FFINIT_H

#include "kernel/yosys.h"
#include "kernel/sigtools.h"

YOSYS_NAMESPACE_BEGIN

struct FfInitVals
{
	const SigMap *sigmap;
	dict<SigBit, std::pair<State,SigBit>> initbits;

	void set(const SigMap *sigmap_, RTLIL::Module *module)
	{
		sigmap = sigmap_;
		initbits.clear();
		for (auto wire : module->wires())
		{
			if (wire->attributes.count(ID::init) == 0)
				continue;

			SigSpec wirebits = (*sigmap)(wire);
			Const initval = wire->attributes.at(ID::init);

			for (int i = 0; i < GetSize(wirebits) && i < GetSize(initval); i++)
			{
				SigBit bit = wirebits[i];
				State val = initval[i];

				if (val != State::S0 && val != State::S1 && bit.wire != nullptr)
					continue;

				if (initbits.count(bit)) {
					if (initbits.at(bit).first != val)
						log_error("Conflicting init values for signal %s (%s = %s != %s).\\n",
								log_signal(bit), log_signal(SigBit(wire, i)),
								log_signal(val), log_signal(initbits.at(bit).first));
					continue;
				}

				initbits[bit] = std::make_pair(val,SigBit(wire,i));
			}
		}
	}

	RTLIL::State operator()(RTLIL::SigBit bit) const
	{
		auto it = initbits.find((*sigmap)(bit));
		if (it != initbits.end())
			return it->second.first;
		else
			return State::Sx;
	}

	RTLIL::Const operator()(const RTLIL::SigSpec &sig) const
	{
		RTLIL::Const res;
		for (auto bit : sig)
			res.bits.push_back((*this)(bit));
		return res;
	}

	void set_init(RTLIL::SigBit bit, RTLIL::State val)
	{
		SigBit mbit = (*sigmap)(bit);
		SigBit abit = bit;
		auto it = initbits.find(mbit);
		if (it != initbits.end())
			abit = it->second.second;
		else if (val == State::Sx)
			return;
		log_assert(abit.wire);
		initbits[mbit] = std::make_pair(val,abit);
		auto it2 = abit.wire->attributes.find(ID::init);
		if (it2 != abit.wire->attributes.end()) {
			it2->second[abit.offset] = val;
			if (it2->second.is_fully_undef())
				abit.wire->attributes.erase(it2);
		} else if (val != State::Sx) {
			Const cval(State::Sx, GetSize(abit.wire));
			cval[abit.offset] = val;
			abit.wire->attributes[ID::init] = cval;
		}
	}

	void set_init(const RTLIL::SigSpec &sig, RTLIL::Const val)
	{
		log_assert(GetSize(sig) == GetSize(val));
		for (int i = 0; i < GetSize(sig); i++)
			set_init(sig[i], val[i]);
	}

	void remove_init(RTLIL::SigBit bit)
	{
		set_init(bit, State::Sx);
	}

	void remove_init(const RTLIL::SigSpec &sig)
	{
		for (auto bit : sig)
			remove_init(bit);
	}

	void clear()
	{
		initbits.clear();
	}

	FfInitVals (const SigMap *sigmap, RTLIL::Module *module)
	{
		set(sigmap, module);
	}

	FfInitVals () {}
};


YOSYS_NAMESPACE_END

#endif
`,"ffmerge.h":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2021  Marcelina Ko\u015Bcielnicka <mwk@0x04.net>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef FFMERGE_H
#define FFMERGE_H

#include "kernel/ffinit.h"
#include "kernel/ff.h"

YOSYS_NAMESPACE_BEGIN

// A helper class for passes that want to merge FFs on the input or output
// of a cell into the cell itself.
//
// The procedure is:
//
// 1. Construct this class (at beginning of processing for a given module).
// 2. For every considered cell:
//
//    a. Call find_output_ff for every considered output.
//    b. Call find_input_ff for every considered input.
//    c. Look at the FF description returned (if any) from each call, reject
//       results that cannot be merged into given cell for any reason.
//       If both inputs and outputs are being merged, take care of FF bits that
//       are returned in both input and output results (a FF bit cannot be
//       merged to both).  Decide on the final set of FF bits to merge.
//    d. Call remove_output_ff for every find_output_ff result that will be used
//       for merging.  This removes the actual FF bits from design and from index.
//    e. Call mark_input_ff for every find_input_ff result that will be used
//       for merging.  This updates the index disallowing further usage of these
//       FF bits for output FF merging, if they were eligible before.  The actual
//       FF bits are still left in the design and can be merged into other inputs.
//       If the FF bits are not otherwise used, they will be removed by later
//       opt passes.
//    f. Merge the FFs into the cell.
//
// Note that, if both inputs and outputs are being considered for merging in
// a single pass, the result may be nondeterministic (depending on cell iteration
// order) because a given FF bit could be eligible for both input and output merge,
// perhaps in different cells.  For this reason, it may be a good idea to separate
// input and output merging.

struct FfMergeHelper
{
	const SigMap *sigmap;
	RTLIL::Module *module;
	FfInitVals *initvals;

	dict<SigBit, std::pair<Cell*, int>> dff_driver;
	dict<SigBit, pool<std::pair<Cell*, int>>> dff_sink;
	dict<SigBit, int> sigbit_users_count;

	// Returns true if all bits in sig are completely unused.
	bool is_output_unused(RTLIL::SigSpec sig);

	// Finds the FF to merge into a given cell output.  Takes sig, which
	// is the current cell output \u2014 it will be the sig_d of the found FF.
	// If found, returns true, and fills the two output arguments.
	//
	// For every bit of sig, this function finds a FF bit that has
	// the same sig_d, and fills the output FfData according to the FF
	// bits found.  This function will only consider FF bits that are
	// the only user of the given sig bits \u2014 if any bit in sig is used
	// by anything other than a single FF, this function will return false.
	//
	// The returned FfData structure does not correspond to any actual FF
	// cell in the design \u2014 it is the amalgamation of extracted FF bits,
	// possibly coming from several FF cells.
	//
	// If some of the bits in sig have no users at all, this function
	// will accept them as well (and fill returned FfData with dummy values
	// for the given bit, effectively synthesizing an unused FF bit of the
	// appropriate type).  However, if all bits in sig are completely
	// unused, this function will fail and return false (having no idea
	// what kind of FF to produce) \u2014 use the above helper if that case
	// is important to handle.
	//
	// Note that this function does not remove the FF bits returned from
	// the design \u2014 this is so that the caller can decide whether to accept
	// this FF for merging or not.  If the result is accepted,
	// remove_output_ff should be called on the second output argument.
	bool find_output_ff(RTLIL::SigSpec sig, FfData &ff, pool<std::pair<Cell *, int>> &bits);

	// Like above, but returns a FF to merge into a given cell input.  Takes
	// sig_q, which is the current cell input \u2014 it will search for FFs with
	// matching sig_q.
	//
	// As opposed to find_output_ff, this function doesn't care about usage
	// counts, and may return FF bits that also have other fanout.  This
	// should not be a problem for input FF merging.
	//
	// As a special case, if some of the bits in sig_q are constant, this
	// function will accept them as well, by synthesizing in-place
	// a constant-input FF bit (with matching initial value and reset value).
	// However, this will not work if the input is all-constant \u2014 if the caller
	// cares about this case, it needs to check for it explicitely.
	bool find_input_ff(RTLIL::SigSpec sig, FfData &ff, pool<std::pair<Cell *, int>> &bits);

	// To be called on find_output_ff result that will be merged.  This
	// marks the given FF bits as used up (and not to be considered for
	// further merging as inputs), and reconnects their Q ports to a dummy
	// wire (since the wire previously connected there will now be driven
	// by the merged-to cell instead).
	void remove_output_ff(const pool<std::pair<Cell *, int>> &bits);

	// To be called on find_input_ff result that will be merged.  This
	// marks the given FF bits as used, and disallows merging them as
	// outputs.  They can, however, still be merged as inputs again
	// (perhaps for another cell).
	void mark_input_ff(const pool<std::pair<Cell *, int>> &bits);

	void set(FfInitVals *initvals_, RTLIL::Module *module_);

	void clear();

	FfMergeHelper(FfInitVals *initvals, RTLIL::Module *module) {
		set(initvals, module);
	}

	FfMergeHelper() {}
};

YOSYS_NAMESPACE_END

#endif
`,"fmt.h":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2020  whitequark <whitequark@whitequark.org>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef FMT_H
#define FMT_H

#include "kernel/yosys.h"

YOSYS_NAMESPACE_BEGIN

// Verilog format argument, such as the arguments in:
//   $display("foo %d bar %01x", 4'b0, $signed(2'b11))
struct VerilogFmtArg {
	enum {
		STRING  = 0,
		INTEGER = 1,
		TIME    = 2,
	} type;

	// All types
	std::string filename;
	unsigned first_line;

	// STRING type
	std::string str;

	// INTEGER type
	RTLIL::SigSpec sig;
	bool signed_ = false;

	// TIME type
	bool realtime = false;
};

// RTLIL format part, such as the substitutions in:
//   "foo {4:> 4du} bar {2:<01hs}"
// Must be kept in sync with \`struct fmt_part\` in backends/cxxrtl/runtime/cxxrtl/cxxrtl.h!
struct FmtPart {
	enum {
		LITERAL  	= 0,
		INTEGER 	= 1,
		STRING    = 2,
		UNICHAR   = 3,
		VLOG_TIME = 4,
	} type;

	// LITERAL type
	std::string str;

	// INTEGER/STRING/UNICHAR types
	RTLIL::SigSpec sig;

	// INTEGER/STRING/VLOG_TIME types
	enum {
		RIGHT	= 0,
		LEFT	= 1,
		NUMERIC	= 2,
	} justify = RIGHT;
	char padding = '\\0';
	size_t width = 0;

	// INTEGER type
	unsigned base = 10;
	bool signed_ = false;
	enum {
		MINUS		= 0,
		PLUS_MINUS	= 1,
		SPACE_MINUS	= 2,
	} sign = MINUS;
	bool hex_upper = false;
	bool show_base = false;
	bool group = false;

	// VLOG_TIME type
	bool realtime = false;
};

struct Fmt {
public:
	std::vector<FmtPart> parts;

	void append_literal(const std::string &str);

	void parse_rtlil(const RTLIL::Cell *cell);
	void emit_rtlil(RTLIL::Cell *cell) const;

	void parse_verilog(const std::vector<VerilogFmtArg> &args, bool sformat_like, int default_base, RTLIL::IdString task_name, RTLIL::IdString module_name);
	std::vector<VerilogFmtArg> emit_verilog() const;

	void emit_cxxrtl(std::ostream &os, std::string indent, std::function<void(const RTLIL::SigSpec &)> emit_sig, const std::string &context) const;

	std::string render() const;

private:
	void apply_verilog_automatic_sizing_and_add(FmtPart &part);
};

YOSYS_NAMESPACE_END

#endif
`,"hashlib.h":`// This is free and unencumbered software released into the public domain.
//
// Anyone is free to copy, modify, publish, use, compile, sell, or
// distribute this software, either in source code form or as a compiled
// binary, for any purpose, commercial or non-commercial, and by any
// means.

// -------------------------------------------------------
// Written by Claire Xenia Wolf <claire@yosyshq.com> in 2014
// -------------------------------------------------------

#ifndef HASHLIB_H
#define HASHLIB_H

#include <stdexcept>
#include <algorithm>
#include <string>
#include <vector>

#include <stdint.h>

namespace hashlib {

const int hashtable_size_trigger = 2;
const int hashtable_size_factor = 3;

// The XOR version of DJB2
inline unsigned int mkhash(unsigned int a, unsigned int b) {
	return ((a << 5) + a) ^ b;
}

// traditionally 5381 is used as starting value for the djb2 hash
const unsigned int mkhash_init = 5381;

// The ADD version of DJB2
// (use this version for cache locality in b)
inline unsigned int mkhash_add(unsigned int a, unsigned int b) {
	return ((a << 5) + a) + b;
}

inline unsigned int mkhash_xorshift(unsigned int a) {
	if (sizeof(a) == 4) {
		a ^= a << 13;
		a ^= a >> 17;
		a ^= a << 5;
	} else if (sizeof(a) == 8) {
		a ^= a << 13;
		a ^= a >> 7;
		a ^= a << 17;
	} else
		throw std::runtime_error("mkhash_xorshift() only implemented for 32 bit and 64 bit ints");
	return a;
}

template<typename T> struct hash_ops {
	static inline bool cmp(const T &a, const T &b) {
		return a == b;
	}
	static inline unsigned int hash(const T &a) {
		return a.hash();
	}
};

struct hash_int_ops {
	template<typename T>
	static inline bool cmp(T a, T b) {
		return a == b;
	}
};

template<> struct hash_ops<bool> : hash_int_ops
{
	static inline unsigned int hash(bool a) {
		return a ? 1 : 0;
	}
};
template<> struct hash_ops<int32_t> : hash_int_ops
{
	static inline unsigned int hash(int32_t a) {
		return a;
	}
};
template<> struct hash_ops<int64_t> : hash_int_ops
{
	static inline unsigned int hash(int64_t a) {
		return mkhash((unsigned int)(a), (unsigned int)(a >> 32));
	}
};
template<> struct hash_ops<uint32_t> : hash_int_ops
{
	static inline unsigned int hash(uint32_t a) {
		return a;
	}
};
template<> struct hash_ops<uint64_t> : hash_int_ops
{
	static inline unsigned int hash(uint64_t a) {
		return mkhash((unsigned int)(a), (unsigned int)(a >> 32));
	}
};

template<> struct hash_ops<std::string> {
	static inline bool cmp(const std::string &a, const std::string &b) {
		return a == b;
	}
	static inline unsigned int hash(const std::string &a) {
		unsigned int v = 0;
		for (auto c : a)
			v = mkhash(v, c);
		return v;
	}
};

template<typename P, typename Q> struct hash_ops<std::pair<P, Q>> {
	static inline bool cmp(std::pair<P, Q> a, std::pair<P, Q> b) {
		return a == b;
	}
	static inline unsigned int hash(std::pair<P, Q> a) {
		return mkhash(hash_ops<P>::hash(a.first), hash_ops<Q>::hash(a.second));
	}
};

template<typename... T> struct hash_ops<std::tuple<T...>> {
	static inline bool cmp(std::tuple<T...> a, std::tuple<T...> b) {
		return a == b;
	}
	template<size_t I = 0>
	static inline typename std::enable_if<I == sizeof...(T), unsigned int>::type hash(std::tuple<T...>) {
		return mkhash_init;
	}
	template<size_t I = 0>
	static inline typename std::enable_if<I != sizeof...(T), unsigned int>::type hash(std::tuple<T...> a) {
		typedef hash_ops<typename std::tuple_element<I, std::tuple<T...>>::type> element_ops_t;
		return mkhash(hash<I+1>(a), element_ops_t::hash(std::get<I>(a)));
	}
};

template<typename T> struct hash_ops<std::vector<T>> {
	static inline bool cmp(std::vector<T> a, std::vector<T> b) {
		return a == b;
	}
	static inline unsigned int hash(std::vector<T> a) {
		unsigned int h = mkhash_init;
		for (auto k : a)
			h = mkhash(h, hash_ops<T>::hash(k));
		return h;
	}
};

struct hash_cstr_ops {
	static inline bool cmp(const char *a, const char *b) {
		for (int i = 0; a[i] || b[i]; i++)
			if (a[i] != b[i])
				return false;
		return true;
	}
	static inline unsigned int hash(const char *a) {
		unsigned int hash = mkhash_init;
		while (*a)
			hash = mkhash(hash, *(a++));
		return hash;
	}
};

struct hash_ptr_ops {
	static inline bool cmp(const void *a, const void *b) {
		return a == b;
	}
	static inline unsigned int hash(const void *a) {
		return (uintptr_t)a;
	}
};

struct hash_obj_ops {
	static inline bool cmp(const void *a, const void *b) {
		return a == b;
	}
	template<typename T>
	static inline unsigned int hash(const T *a) {
		return a ? a->hash() : 0;
	}
};

template<typename T>
inline unsigned int mkhash(const T &v) {
	return hash_ops<T>().hash(v);
}

inline int hashtable_size(int min_size)
{
	static std::vector<int> zero_and_some_primes = {
		0, 23, 29, 37, 47, 59, 79, 101, 127, 163, 211, 269, 337, 431, 541, 677,
		853, 1069, 1361, 1709, 2137, 2677, 3347, 4201, 5261, 6577, 8231, 10289,
		12889, 16127, 20161, 25219, 31531, 39419, 49277, 61603, 77017, 96281,
		120371, 150473, 188107, 235159, 293957, 367453, 459317, 574157, 717697,
		897133, 1121423, 1401791, 1752239, 2190299, 2737937, 3422429, 4278037,
		5347553, 6684443, 8355563, 10444457, 13055587, 16319519, 20399411,
		25499291, 31874149, 39842687, 49803361, 62254207, 77817767, 97272239,
		121590311, 151987889, 189984863, 237481091, 296851369, 371064217
	};

	for (auto p : zero_and_some_primes)
		if (p >= min_size) return p;

	if (sizeof(int) == 4)
		throw std::length_error("hash table exceeded maximum size.\\nDesign is likely too large for yosys to handle, if possible try not to flatten the design.");

	for (auto p : zero_and_some_primes)
		if (100129 * p > min_size) return 100129 * p;

	throw std::length_error("hash table exceeded maximum size.");
}

template<typename K, typename T, typename OPS = hash_ops<K>> class dict;
template<typename K, int offset = 0, typename OPS = hash_ops<K>> class idict;
template<typename K, typename OPS = hash_ops<K>> class pool;
template<typename K, typename OPS = hash_ops<K>> class mfp;

template<typename K, typename T, typename OPS>
class dict
{
	struct entry_t
	{
		std::pair<K, T> udata;
		int next;

		entry_t() { }
		entry_t(const std::pair<K, T> &udata, int next) : udata(udata), next(next) { }
		entry_t(std::pair<K, T> &&udata, int next) : udata(std::move(udata)), next(next) { }
		bool operator<(const entry_t &other) const { return udata.first < other.udata.first; }
	};

	std::vector<int> hashtable;
	std::vector<entry_t> entries;
	OPS ops;

#ifdef NDEBUG
	static inline void do_assert(bool) { }
#else
	static inline void do_assert(bool cond) {
		if (!cond) throw std::runtime_error("dict<> assert failed.");
	}
#endif

	int do_hash(const K &key) const
	{
		unsigned int hash = 0;
		if (!hashtable.empty())
			hash = ops.hash(key) % (unsigned int)(hashtable.size());
		return hash;
	}

	void do_rehash()
	{
		hashtable.clear();
		hashtable.resize(hashtable_size(entries.capacity() * hashtable_size_factor), -1);

		for (int i = 0; i < int(entries.size()); i++) {
			do_assert(-1 <= entries[i].next && entries[i].next < int(entries.size()));
			int hash = do_hash(entries[i].udata.first);
			entries[i].next = hashtable[hash];
			hashtable[hash] = i;
		}
	}

	int do_erase(int index, int hash)
	{
		do_assert(index < int(entries.size()));
		if (hashtable.empty() || index < 0)
			return 0;

		int k = hashtable[hash];
		do_assert(0 <= k && k < int(entries.size()));

		if (k == index) {
			hashtable[hash] = entries[index].next;
		} else {
			while (entries[k].next != index) {
				k = entries[k].next;
				do_assert(0 <= k && k < int(entries.size()));
			}
			entries[k].next = entries[index].next;
		}

		int back_idx = entries.size()-1;

		if (index != back_idx)
		{
			int back_hash = do_hash(entries[back_idx].udata.first);

			k = hashtable[back_hash];
			do_assert(0 <= k && k < int(entries.size()));

			if (k == back_idx) {
				hashtable[back_hash] = index;
			} else {
				while (entries[k].next != back_idx) {
					k = entries[k].next;
					do_assert(0 <= k && k < int(entries.size()));
				}
				entries[k].next = index;
			}

			entries[index] = std::move(entries[back_idx]);
		}

		entries.pop_back();

		if (entries.empty())
			hashtable.clear();

		return 1;
	}

	int do_lookup(const K &key, int &hash) const
	{
		if (hashtable.empty())
			return -1;

		if (entries.size() * hashtable_size_trigger > hashtable.size()) {
			((dict*)this)->do_rehash();
			hash = do_hash(key);
		}

		int index = hashtable[hash];

		while (index >= 0 && !ops.cmp(entries[index].udata.first, key)) {
			index = entries[index].next;
			do_assert(-1 <= index && index < int(entries.size()));
		}

		return index;
	}

	int do_insert(const K &key, int &hash)
	{
		if (hashtable.empty()) {
			entries.emplace_back(std::pair<K, T>(key, T()), -1);
			do_rehash();
			hash = do_hash(key);
		} else {
			entries.emplace_back(std::pair<K, T>(key, T()), hashtable[hash]);
			hashtable[hash] = entries.size() - 1;
		}
		return entries.size() - 1;
	}

	int do_insert(const std::pair<K, T> &value, int &hash)
	{
		if (hashtable.empty()) {
			entries.emplace_back(value, -1);
			do_rehash();
			hash = do_hash(value.first);
		} else {
			entries.emplace_back(value, hashtable[hash]);
			hashtable[hash] = entries.size() - 1;
		}
		return entries.size() - 1;
	}

	int do_insert(std::pair<K, T> &&rvalue, int &hash)
	{
		if (hashtable.empty()) {
			auto key = rvalue.first;
			entries.emplace_back(std::forward<std::pair<K, T>>(rvalue), -1);
			do_rehash();
			hash = do_hash(key);
		} else {
			entries.emplace_back(std::forward<std::pair<K, T>>(rvalue), hashtable[hash]);
			hashtable[hash] = entries.size() - 1;
		}
		return entries.size() - 1;
	}

public:
	class const_iterator
	{
		friend class dict;
	protected:
		const dict *ptr;
		int index;
		const_iterator(const dict *ptr, int index) : ptr(ptr), index(index) { }
	public:
		typedef std::forward_iterator_tag iterator_category;
		typedef std::pair<K, T> value_type;
		typedef ptrdiff_t difference_type;
		typedef std::pair<K, T>* pointer;
		typedef std::pair<K, T>& reference;
		const_iterator() { }
		const_iterator operator++() { index--; return *this; }
		const_iterator operator+=(int amt) { index -= amt; return *this; }
		bool operator<(const const_iterator &other) const { return index > other.index; }
		bool operator==(const const_iterator &other) const { return index == other.index; }
		bool operator!=(const const_iterator &other) const { return index != other.index; }
		const std::pair<K, T> &operator*() const { return ptr->entries[index].udata; }
		const std::pair<K, T> *operator->() const { return &ptr->entries[index].udata; }
	};

	class iterator
	{
		friend class dict;
	protected:
		dict *ptr;
		int index;
		iterator(dict *ptr, int index) : ptr(ptr), index(index) { }
	public:
		typedef std::forward_iterator_tag iterator_category;
		typedef std::pair<K, T> value_type;
		typedef ptrdiff_t difference_type;
		typedef std::pair<K, T>* pointer;
		typedef std::pair<K, T>& reference;
		iterator() { }
		iterator operator++() { index--; return *this; }
		iterator operator+=(int amt) { index -= amt; return *this; }
		bool operator<(const iterator &other) const { return index > other.index; }
		bool operator==(const iterator &other) const { return index == other.index; }
		bool operator!=(const iterator &other) const { return index != other.index; }
		std::pair<K, T> &operator*() { return ptr->entries[index].udata; }
		std::pair<K, T> *operator->() { return &ptr->entries[index].udata; }
		const std::pair<K, T> &operator*() const { return ptr->entries[index].udata; }
		const std::pair<K, T> *operator->() const { return &ptr->entries[index].udata; }
		operator const_iterator() const { return const_iterator(ptr, index); }
	};

	constexpr dict()
	{
	}

	dict(const dict &other)
	{
		entries = other.entries;
		do_rehash();
	}

	dict(dict &&other)
	{
		swap(other);
	}

	dict &operator=(const dict &other) {
		entries = other.entries;
		do_rehash();
		return *this;
	}

	dict &operator=(dict &&other) {
		clear();
		swap(other);
		return *this;
	}

	dict(const std::initializer_list<std::pair<K, T>> &list)
	{
		for (auto &it : list)
			insert(it);
	}

	template<class InputIterator>
	dict(InputIterator first, InputIterator last)
	{
		insert(first, last);
	}

	template<class InputIterator>
	void insert(InputIterator first, InputIterator last)
	{
		for (; first != last; ++first)
			insert(*first);
	}

	std::pair<iterator, bool> insert(const K &key)
	{
		int hash = do_hash(key);
		int i = do_lookup(key, hash);
		if (i >= 0)
			return std::pair<iterator, bool>(iterator(this, i), false);
		i = do_insert(key, hash);
		return std::pair<iterator, bool>(iterator(this, i), true);
	}

	std::pair<iterator, bool> insert(const std::pair<K, T> &value)
	{
		int hash = do_hash(value.first);
		int i = do_lookup(value.first, hash);
		if (i >= 0)
			return std::pair<iterator, bool>(iterator(this, i), false);
		i = do_insert(value, hash);
		return std::pair<iterator, bool>(iterator(this, i), true);
	}

	std::pair<iterator, bool> insert(std::pair<K, T> &&rvalue)
	{
		int hash = do_hash(rvalue.first);
		int i = do_lookup(rvalue.first, hash);
		if (i >= 0)
			return std::pair<iterator, bool>(iterator(this, i), false);
		i = do_insert(std::forward<std::pair<K, T>>(rvalue), hash);
		return std::pair<iterator, bool>(iterator(this, i), true);
	}

	std::pair<iterator, bool> emplace(K const &key, T const &value)
	{
		int hash = do_hash(key);
		int i = do_lookup(key, hash);
		if (i >= 0)
			return std::pair<iterator, bool>(iterator(this, i), false);
		i = do_insert(std::make_pair(key, value), hash);
		return std::pair<iterator, bool>(iterator(this, i), true);
	}

	std::pair<iterator, bool> emplace(K const &key, T &&rvalue)
	{
		int hash = do_hash(key);
		int i = do_lookup(key, hash);
		if (i >= 0)
			return std::pair<iterator, bool>(iterator(this, i), false);
		i = do_insert(std::make_pair(key, std::forward<T>(rvalue)), hash);
		return std::pair<iterator, bool>(iterator(this, i), true);
	}

	std::pair<iterator, bool> emplace(K &&rkey, T const &value)
	{
		int hash = do_hash(rkey);
		int i = do_lookup(rkey, hash);
		if (i >= 0)
			return std::pair<iterator, bool>(iterator(this, i), false);
		i = do_insert(std::make_pair(std::forward<K>(rkey), value), hash);
		return std::pair<iterator, bool>(iterator(this, i), true);
	}

	std::pair<iterator, bool> emplace(K &&rkey, T &&rvalue)
	{
		int hash = do_hash(rkey);
		int i = do_lookup(rkey, hash);
		if (i >= 0)
			return std::pair<iterator, bool>(iterator(this, i), false);
		i = do_insert(std::make_pair(std::forward<K>(rkey), std::forward<T>(rvalue)), hash);
		return std::pair<iterator, bool>(iterator(this, i), true);
	}

	int erase(const K &key)
	{
		int hash = do_hash(key);
		int index = do_lookup(key, hash);
		return do_erase(index, hash);
	}

	iterator erase(iterator it)
	{
		int hash = do_hash(it->first);
		do_erase(it.index, hash);
		return ++it;
	}

	int count(const K &key) const
	{
		int hash = do_hash(key);
		int i = do_lookup(key, hash);
		return i < 0 ? 0 : 1;
	}

	int count(const K &key, const_iterator it) const
	{
		int hash = do_hash(key);
		int i = do_lookup(key, hash);
		return i < 0 || i > it.index ? 0 : 1;
	}

	iterator find(const K &key)
	{
		int hash = do_hash(key);
		int i = do_lookup(key, hash);
		if (i < 0)
			return end();
		return iterator(this, i);
	}

	const_iterator find(const K &key) const
	{
		int hash = do_hash(key);
		int i = do_lookup(key, hash);
		if (i < 0)
			return end();
		return const_iterator(this, i);
	}

	T& at(const K &key)
	{
		int hash = do_hash(key);
		int i = do_lookup(key, hash);
		if (i < 0)
			throw std::out_of_range("dict::at()");
		return entries[i].udata.second;
	}

	const T& at(const K &key) const
	{
		int hash = do_hash(key);
		int i = do_lookup(key, hash);
		if (i < 0)
			throw std::out_of_range("dict::at()");
		return entries[i].udata.second;
	}

	const T& at(const K &key, const T &defval) const
	{
		int hash = do_hash(key);
		int i = do_lookup(key, hash);
		if (i < 0)
			return defval;
		return entries[i].udata.second;
	}

	T& operator[](const K &key)
	{
		int hash = do_hash(key);
		int i = do_lookup(key, hash);
		if (i < 0)
			i = do_insert(std::pair<K, T>(key, T()), hash);
		return entries[i].udata.second;
	}

	template<typename Compare = std::less<K>>
	void sort(Compare comp = Compare())
	{
		std::sort(entries.begin(), entries.end(), [comp](const entry_t &a, const entry_t &b){ return comp(b.udata.first, a.udata.first); });
		do_rehash();
	}

	void swap(dict &other)
	{
		hashtable.swap(other.hashtable);
		entries.swap(other.entries);
	}

	bool operator==(const dict &other) const {
		if (size() != other.size())
			return false;
		for (auto &it : entries) {
			auto oit = other.find(it.udata.first);
			if (oit == other.end() || !(oit->second == it.udata.second))
				return false;
		}
		return true;
	}

	bool operator!=(const dict &other) const {
		return !operator==(other);
	}

	unsigned int hash() const {
		unsigned int h = mkhash_init;
		for (auto &entry : entries) {
			h ^= hash_ops<K>::hash(entry.udata.first);
			h ^= hash_ops<T>::hash(entry.udata.second);
		}
		return h;
	}

	void reserve(size_t n) { entries.reserve(n); }
	size_t size() const { return entries.size(); }
	bool empty() const { return entries.empty(); }
	void clear() { hashtable.clear(); entries.clear(); }

	iterator begin() { return iterator(this, int(entries.size())-1); }
	iterator element(int n) { return iterator(this, int(entries.size())-1-n); }
	iterator end() { return iterator(nullptr, -1); }

	const_iterator begin() const { return const_iterator(this, int(entries.size())-1); }
	const_iterator element(int n) const { return const_iterator(this, int(entries.size())-1-n); }
	const_iterator end() const { return const_iterator(nullptr, -1); }
};

template<typename K, typename OPS>
class pool
{
	template<typename, int, typename> friend class idict;

protected:
	struct entry_t
	{
		K udata;
		int next;

		entry_t() { }
		entry_t(const K &udata, int next) : udata(udata), next(next) { }
		entry_t(K &&udata, int next) : udata(std::move(udata)), next(next) { }
	};

	std::vector<int> hashtable;
	std::vector<entry_t> entries;
	OPS ops;

#ifdef NDEBUG
	static inline void do_assert(bool) { }
#else
	static inline void do_assert(bool cond) {
		if (!cond) throw std::runtime_error("pool<> assert failed.");
	}
#endif

	int do_hash(const K &key) const
	{
		unsigned int hash = 0;
		if (!hashtable.empty())
			hash = ops.hash(key) % (unsigned int)(hashtable.size());
		return hash;
	}

	void do_rehash()
	{
		hashtable.clear();
		hashtable.resize(hashtable_size(entries.capacity() * hashtable_size_factor), -1);

		for (int i = 0; i < int(entries.size()); i++) {
			do_assert(-1 <= entries[i].next && entries[i].next < int(entries.size()));
			int hash = do_hash(entries[i].udata);
			entries[i].next = hashtable[hash];
			hashtable[hash] = i;
		}
	}

	int do_erase(int index, int hash)
	{
		do_assert(index < int(entries.size()));
		if (hashtable.empty() || index < 0)
			return 0;

		int k = hashtable[hash];
		if (k == index) {
			hashtable[hash] = entries[index].next;
		} else {
			while (entries[k].next != index) {
				k = entries[k].next;
				do_assert(0 <= k && k < int(entries.size()));
			}
			entries[k].next = entries[index].next;
		}

		int back_idx = entries.size()-1;

		if (index != back_idx)
		{
			int back_hash = do_hash(entries[back_idx].udata);

			k = hashtable[back_hash];
			if (k == back_idx) {
				hashtable[back_hash] = index;
			} else {
				while (entries[k].next != back_idx) {
					k = entries[k].next;
					do_assert(0 <= k && k < int(entries.size()));
				}
				entries[k].next = index;
			}

			entries[index] = std::move(entries[back_idx]);
		}

		entries.pop_back();

		if (entries.empty())
			hashtable.clear();

		return 1;
	}

	int do_lookup(const K &key, int &hash) const
	{
		if (hashtable.empty())
			return -1;

		if (entries.size() * hashtable_size_trigger > hashtable.size()) {
			((pool*)this)->do_rehash();
			hash = do_hash(key);
		}

		int index = hashtable[hash];

		while (index >= 0 && !ops.cmp(entries[index].udata, key)) {
			index = entries[index].next;
			do_assert(-1 <= index && index < int(entries.size()));
		}

		return index;
	}

	int do_insert(const K &value, int &hash)
	{
		if (hashtable.empty()) {
			entries.emplace_back(value, -1);
			do_rehash();
			hash = do_hash(value);
		} else {
			entries.emplace_back(value, hashtable[hash]);
			hashtable[hash] = entries.size() - 1;
		}
		return entries.size() - 1;
	}

	int do_insert(K &&rvalue, int &hash)
	{
		if (hashtable.empty()) {
			entries.emplace_back(std::forward<K>(rvalue), -1);
			do_rehash();
			hash = do_hash(rvalue);
		} else {
			entries.emplace_back(std::forward<K>(rvalue), hashtable[hash]);
			hashtable[hash] = entries.size() - 1;
		}
		return entries.size() - 1;
	}

public:
	class const_iterator
	{
		friend class pool;
	protected:
		const pool *ptr;
		int index;
		const_iterator(const pool *ptr, int index) : ptr(ptr), index(index) { }
	public:
		typedef std::forward_iterator_tag iterator_category;
		typedef K value_type;
		typedef ptrdiff_t difference_type;
		typedef K* pointer;
		typedef K& reference;
		const_iterator() { }
		const_iterator operator++() { index--; return *this; }
		bool operator==(const const_iterator &other) const { return index == other.index; }
		bool operator!=(const const_iterator &other) const { return index != other.index; }
		const K &operator*() const { return ptr->entries[index].udata; }
		const K *operator->() const { return &ptr->entries[index].udata; }
	};

	class iterator
	{
		friend class pool;
	protected:
		pool *ptr;
		int index;
		iterator(pool *ptr, int index) : ptr(ptr), index(index) { }
	public:
		typedef std::forward_iterator_tag iterator_category;
		typedef K value_type;
		typedef ptrdiff_t difference_type;
		typedef K* pointer;
		typedef K& reference;
		iterator() { }
		iterator operator++() { index--; return *this; }
		bool operator==(const iterator &other) const { return index == other.index; }
		bool operator!=(const iterator &other) const { return index != other.index; }
		K &operator*() { return ptr->entries[index].udata; }
		K *operator->() { return &ptr->entries[index].udata; }
		const K &operator*() const { return ptr->entries[index].udata; }
		const K *operator->() const { return &ptr->entries[index].udata; }
		operator const_iterator() const { return const_iterator(ptr, index); }
	};

	constexpr pool()
	{
	}

	pool(const pool &other)
	{
		entries = other.entries;
		do_rehash();
	}

	pool(pool &&other)
	{
		swap(other);
	}

	pool &operator=(const pool &other) {
		entries = other.entries;
		do_rehash();
		return *this;
	}

	pool &operator=(pool &&other) {
		clear();
		swap(other);
		return *this;
	}

	pool(const std::initializer_list<K> &list)
	{
		for (auto &it : list)
			insert(it);
	}

	template<class InputIterator>
	pool(InputIterator first, InputIterator last)
	{
		insert(first, last);
	}

	template<class InputIterator>
	void insert(InputIterator first, InputIterator last)
	{
		for (; first != last; ++first)
			insert(*first);
	}

	std::pair<iterator, bool> insert(const K &value)
	{
		int hash = do_hash(value);
		int i = do_lookup(value, hash);
		if (i >= 0)
			return std::pair<iterator, bool>(iterator(this, i), false);
		i = do_insert(value, hash);
		return std::pair<iterator, bool>(iterator(this, i), true);
	}

	std::pair<iterator, bool> insert(K &&rvalue)
	{
		int hash = do_hash(rvalue);
		int i = do_lookup(rvalue, hash);
		if (i >= 0)
			return std::pair<iterator, bool>(iterator(this, i), false);
		i = do_insert(std::forward<K>(rvalue), hash);
		return std::pair<iterator, bool>(iterator(this, i), true);
	}

	template<typename... Args>
	std::pair<iterator, bool> emplace(Args&&... args)
	{
		return insert(K(std::forward<Args>(args)...));
	}

	int erase(const K &key)
	{
		int hash = do_hash(key);
		int index = do_lookup(key, hash);
		return do_erase(index, hash);
	}

	iterator erase(iterator it)
	{
		int hash = do_hash(*it);
		do_erase(it.index, hash);
		return ++it;
	}

	int count(const K &key) const
	{
		int hash = do_hash(key);
		int i = do_lookup(key, hash);
		return i < 0 ? 0 : 1;
	}

	int count(const K &key, const_iterator it) const
	{
		int hash = do_hash(key);
		int i = do_lookup(key, hash);
		return i < 0 || i > it.index ? 0 : 1;
	}

	iterator find(const K &key)
	{
		int hash = do_hash(key);
		int i = do_lookup(key, hash);
		if (i < 0)
			return end();
		return iterator(this, i);
	}

	const_iterator find(const K &key) const
	{
		int hash = do_hash(key);
		int i = do_lookup(key, hash);
		if (i < 0)
			return end();
		return const_iterator(this, i);
	}

	bool operator[](const K &key)
	{
		int hash = do_hash(key);
		int i = do_lookup(key, hash);
		return i >= 0;
	}

	template<typename Compare = std::less<K>>
	void sort(Compare comp = Compare())
	{
		std::sort(entries.begin(), entries.end(), [comp](const entry_t &a, const entry_t &b){ return comp(b.udata, a.udata); });
		do_rehash();
	}

	K pop()
	{
		iterator it = begin();
		K ret = *it;
		erase(it);
		return ret;
	}

	void swap(pool &other)
	{
		hashtable.swap(other.hashtable);
		entries.swap(other.entries);
	}

	bool operator==(const pool &other) const {
		if (size() != other.size())
			return false;
		for (auto &it : entries)
			if (!other.count(it.udata))
				return false;
		return true;
	}

	bool operator!=(const pool &other) const {
		return !operator==(other);
	}

	unsigned int hash() const {
		unsigned int hashval = mkhash_init;
		for (auto &it : entries)
			hashval ^= ops.hash(it.udata);
		return hashval;
	}

	void reserve(size_t n) { entries.reserve(n); }
	size_t size() const { return entries.size(); }
	bool empty() const { return entries.empty(); }
	void clear() { hashtable.clear(); entries.clear(); }

	iterator begin() { return iterator(this, int(entries.size())-1); }
	iterator element(int n) { return iterator(this, int(entries.size())-1-n); }
	iterator end() { return iterator(nullptr, -1); }

	const_iterator begin() const { return const_iterator(this, int(entries.size())-1); }
	const_iterator element(int n) const { return const_iterator(this, int(entries.size())-1-n); }
	const_iterator end() const { return const_iterator(nullptr, -1); }
};

template<typename K, int offset, typename OPS>
class idict
{
	pool<K, OPS> database;

public:
	class const_iterator
	{
		friend class idict;
	protected:
		const idict &container;
		int index;
		const_iterator(const idict &container, int index) : container(container), index(index) { }
	public:
		typedef std::forward_iterator_tag iterator_category;
		typedef K value_type;
		typedef ptrdiff_t difference_type;
		typedef K* pointer;
		typedef K& reference;
		const_iterator() { }
		const_iterator operator++() { index++; return *this; }
		bool operator==(const const_iterator &other) const { return index == other.index; }
		bool operator!=(const const_iterator &other) const { return index != other.index; }
		const K &operator*() const { return container[index]; }
		const K *operator->() const { return &container[index]; }
	};

	constexpr idict()
	{
	}

	int operator()(const K &key)
	{
		int hash = database.do_hash(key);
		int i = database.do_lookup(key, hash);
		if (i < 0)
			i = database.do_insert(key, hash);
		return i + offset;
	}

	int at(const K &key) const
	{
		int hash = database.do_hash(key);
		int i = database.do_lookup(key, hash);
		if (i < 0)
			throw std::out_of_range("idict::at()");
		return i + offset;
	}

	int at(const K &key, int defval) const
	{
		int hash = database.do_hash(key);
		int i = database.do_lookup(key, hash);
		if (i < 0)
			return defval;
		return i + offset;
	}

	int count(const K &key) const
	{
		int hash = database.do_hash(key);
		int i = database.do_lookup(key, hash);
		return i < 0 ? 0 : 1;
	}

	void expect(const K &key, int i)
	{
		int j = (*this)(key);
		if (i != j)
			throw std::out_of_range("idict::expect()");
	}

	const K &operator[](int index) const
	{
		return database.entries.at(index - offset).udata;
	}

	void swap(idict &other)
	{
		database.swap(other.database);
	}

	void reserve(size_t n) { database.reserve(n); }
	size_t size() const { return database.size(); }
	bool empty() const { return database.empty(); }
	void clear() { database.clear(); }

	const_iterator begin() const { return const_iterator(*this, offset); }
	const_iterator element(int n) const { return const_iterator(*this, n); }
	const_iterator end() const { return const_iterator(*this, offset + size()); }
};

template<typename K, typename OPS>
class mfp
{
	mutable idict<K, 0, OPS> database;
	mutable std::vector<int> parents;

public:
	typedef typename idict<K, 0, OPS>::const_iterator const_iterator;

	constexpr mfp()
	{
	}

	int operator()(const K &key) const
	{
		int i = database(key);
		parents.resize(database.size(), -1);
		return i;
	}

	const K &operator[](int index) const
	{
		return database[index];
	}

	int ifind(int i) const
	{
		int p = i, k = i;

		while (parents[p] != -1)
			p = parents[p];

		while (k != p) {
			int next_k = parents[k];
			parents[k] = p;
			k = next_k;
		}

		return p;
	}

	void imerge(int i, int j)
	{
		i = ifind(i);
		j = ifind(j);

		if (i != j)
			parents[i] = j;
	}

	void ipromote(int i)
	{
		int k = i;

		while (k != -1) {
			int next_k = parents[k];
			parents[k] = i;
			k = next_k;
		}

		parents[i] = -1;
	}

	int lookup(const K &a) const
	{
		return ifind((*this)(a));
	}

	const K &find(const K &a) const
	{
		int i = database.at(a, -1);
		if (i < 0)
			return a;
		return (*this)[ifind(i)];
	}

	void merge(const K &a, const K &b)
	{
		imerge((*this)(a), (*this)(b));
	}

	void promote(const K &a)
	{
		int i = database.at(a, -1);
		if (i >= 0)
			ipromote(i);
	}

	void swap(mfp &other)
	{
		database.swap(other.database);
		parents.swap(other.parents);
	}

	void reserve(size_t n) { database.reserve(n); }
	size_t size() const { return database.size(); }
	bool empty() const { return database.empty(); }
	void clear() { database.clear(); parents.clear(); }

	const_iterator begin() const { return database.begin(); }
	const_iterator element(int n) const { return database.element(n); }
	const_iterator end() const { return database.end(); }
};

} /* namespace hashlib */

#endif
`,"json.h":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2022  Jannis Harder <jix@yosyshq.com> <me@jix.one>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef JSON_H
#define JSON_H

#include "kernel/yosys.h"
#include "libs/json11/json11.hpp"
#include <functional>

YOSYS_NAMESPACE_BEGIN

using json11::Json;

class PrettyJson
{
    enum Scope {
        VALUE,
        OBJECT_FIRST,
        OBJECT,
        ARRAY_FIRST,
        ARRAY,
    };

    struct Target {
        virtual void emit(const char *data) = 0;
        virtual void flush() {};
        virtual ~Target() {};
    };

    std::string newline_indent = "\\n";
    std::vector<std::unique_ptr<Target>> targets;
    std::vector<Scope> state = {VALUE};
    int compact_depth = INT_MAX;
public:

    void emit_to_log();
    void append_to_string(std::string &target);
    bool write_to_file(const std::string &path);

    bool active() { return !targets.empty(); }

    void compact() { compact_depth = GetSize(state); }

    void line(bool space_if_inline = true);
    void raw(const char *raw_json);
    void flush();
    void begin_object();
    void begin_array();
    void end_object();
    void end_array();
    void name(const char *name);
    void begin_value();
    void end_value();
    void value_json(const Json &value);
    void value(unsigned int value) { value_json(Json((int)value)); }
    template<typename T>
    void value(T &&value) { value_json(Json(std::forward<T>(value))); };

    void entry_json(const char *name, const Json &value);
    void entry(const char *name, unsigned int value) { entry_json(name, Json((int)value)); }
    template<typename T>
    void entry(const char *name, T &&value) { entry_json(name, Json(std::forward<T>(value))); };

    template<typename T>
    void object(const T &&values)
    {
        begin_object();
        for (auto &item : values)
            entry(item.first, item.second);
        end_object();
    }

    template<typename T>
    void array(const T &&values)
    {
        begin_object();
        for (auto &item : values)
            value(item);
        end_object();
    }
};



YOSYS_NAMESPACE_END

#endif
`,"log.h":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef LOG_H
#define LOG_H

#include "kernel/yosys_common.h"

#include <time.h>

#include <regex>
#define YS_REGEX_COMPILE(param) std::regex(param, \\
				std::regex_constants::nosubs | \\
				std::regex_constants::optimize | \\
				std::regex_constants::egrep)
#define YS_REGEX_COMPILE_WITH_SUBS(param) std::regex(param, \\
				std::regex_constants::optimize | \\
				std::regex_constants::egrep)

#if defined(_WIN32)
#  include <intrin.h>
#else
#  include <sys/time.h>
#  include <sys/resource.h>
#  if defined(__unix__) || (defined(__APPLE__) && defined(__MACH__))
#    include <signal.h>
#  endif
#endif

#if defined(_MSC_VER)
// At least this is not in MSVC++ 2013.
#  define __PRETTY_FUNCTION__ __FUNCTION__
#endif

// from libs/sha1/sha1.h
class SHA1;

YOSYS_NAMESPACE_BEGIN

#define S__LINE__sub2(x) #x
#define S__LINE__sub1(x) S__LINE__sub2(x)
#define S__LINE__ S__LINE__sub1(__LINE__)

// YS_DEBUGTRAP is a macro that is functionally equivalent to a breakpoint
// if the platform provides such functionality, and does nothing otherwise.
// If no debugger is attached, it starts a just-in-time debugger if available,
// and crashes the process otherwise.
#if defined(_WIN32)
# define YS_DEBUGTRAP __debugbreak()
#else
# ifndef __has_builtin
// __has_builtin is a GCC/Clang extension; on a different compiler (or old enough GCC/Clang)
// that does not have it, using __has_builtin(...) is a syntax error.
#  define __has_builtin(x) 0
# endif
# if __has_builtin(__builtin_debugtrap)
#  define YS_DEBUGTRAP __builtin_debugtrap()
# elif defined(__unix__) || (defined(__APPLE__) && defined(__MACH__))
#  define YS_DEBUGTRAP raise(SIGTRAP)
# else
#  define YS_DEBUGTRAP do {} while(0)
# endif
#endif

// YS_DEBUGTRAP_IF_DEBUGGING is a macro that is functionally equivalent to a breakpoint
// if a debugger is attached, and does nothing otherwise.
#if defined(_WIN32)
# define YS_DEBUGTRAP_IF_DEBUGGING do { if (IsDebuggerPresent()) DebugBreak(); } while(0)
# elif defined(__unix__) || (defined(__APPLE__) && defined(__MACH__))
// There is no reliable (or portable) *nix equivalent of IsDebuggerPresent(). However,
// debuggers will stop when SIGTRAP is raised, even if the action is set to ignore.
# define YS_DEBUGTRAP_IF_DEBUGGING do { \\
		auto old = signal(SIGTRAP, SIG_IGN); raise(SIGTRAP); signal(SIGTRAP, old); \\
	} while(0)
#else
# define YS_DEBUGTRAP_IF_DEBUGGING do {} while(0)
#endif

struct log_cmd_error_exception { };

extern std::vector<FILE*> log_files;
extern std::vector<std::ostream*> log_streams;
extern std::vector<std::string> log_scratchpads;
extern std::map<std::string, std::set<std::string>> log_hdump;
extern std::vector<std::regex> log_warn_regexes, log_nowarn_regexes, log_werror_regexes;
extern std::set<std::string> log_warnings, log_experimentals, log_experimentals_ignored;
extern int log_warnings_count;
extern int log_warnings_count_noexpect;
extern bool log_expect_no_warnings;
extern bool log_hdump_all;
extern FILE *log_errfile;
extern SHA1 *log_hasher;

extern bool log_time;
extern bool log_error_stderr;
extern bool log_cmd_error_throw;
extern bool log_quiet_warnings;
extern int log_verbose_level;
extern string log_last_error;
extern void (*log_error_atexit)();

extern int log_make_debug;
extern int log_force_debug;
extern int log_debug_suppressed;

void logv(const char *format, va_list ap);
void logv_header(RTLIL::Design *design, const char *format, va_list ap);
void logv_warning(const char *format, va_list ap);
void logv_warning_noprefix(const char *format, va_list ap);
[[noreturn]] void logv_error(const char *format, va_list ap);
[[noreturn]] void logv_file_error(const string &filename, int lineno, const char *format, va_list ap);

void log(const char *format, ...)  YS_ATTRIBUTE(format(printf, 1, 2));
void log_header(RTLIL::Design *design, const char *format, ...) YS_ATTRIBUTE(format(printf, 2, 3));
void log_warning(const char *format, ...) YS_ATTRIBUTE(format(printf, 1, 2));
void log_experimental(const char *format, ...) YS_ATTRIBUTE(format(printf, 1, 2));

void set_verific_logging(void (*cb)(int msg_type, const char *message_id, const char* file_path, unsigned int left_line, unsigned int left_col, unsigned int right_line, unsigned int right_col, const char *msg));
extern void (*log_verific_callback)(int msg_type, const char *message_id, const char* file_path, unsigned int left_line, unsigned int left_col, unsigned int right_line, unsigned int right_col, const char *msg);

// Log with filename to report a problem in a source file.
void log_file_warning(const std::string &filename, int lineno, const char *format, ...) YS_ATTRIBUTE(format(printf, 3, 4));
void log_file_info(const std::string &filename, int lineno, const char *format, ...) YS_ATTRIBUTE(format(printf, 3, 4));

void log_warning_noprefix(const char *format, ...) YS_ATTRIBUTE(format(printf, 1, 2));
[[noreturn]] void log_error(const char *format, ...) YS_ATTRIBUTE(format(printf, 1, 2));
[[noreturn]] void log_file_error(const string &filename, int lineno, const char *format, ...) YS_ATTRIBUTE(format(printf, 3, 4));
[[noreturn]] void log_cmd_error(const char *format, ...) YS_ATTRIBUTE(format(printf, 1, 2));

#ifndef NDEBUG
static inline bool ys_debug(int n = 0) { if (log_force_debug) return true; log_debug_suppressed += n; return false; }
#else
static inline bool ys_debug(int = 0) { return false; }
#endif
#  define log_debug(...) do { if (ys_debug(1)) log(__VA_ARGS__); } while (0)

static inline void log_suppressed() {
	if (log_debug_suppressed && !log_make_debug) {
		log("<suppressed ~%d debug messages>\\n", log_debug_suppressed);
		log_debug_suppressed = 0;
	}
}

struct LogMakeDebugHdl {
	bool status = false;
	LogMakeDebugHdl(bool start_on = false) {
		if (start_on)
			on();
	}
	~LogMakeDebugHdl() {
		off();
	}
	void on() {
		if (status) return;
		status=true;
		log_make_debug++;
	}
	void off_silent() {
		if (!status) return;
		status=false;
		log_make_debug--;
	}
	void off() {
		off_silent();
	}
};

void log_spacer();
void log_push();
void log_pop();

void log_backtrace(const char *prefix, int levels);
void log_reset_stack();
void log_flush();

struct LogExpectedItem
{
	LogExpectedItem(const std::regex &pat, int expected) :
			pattern(pat), expected_count(expected), current_count(0) {}
	LogExpectedItem() : expected_count(0), current_count(0) {}

	std::regex pattern;
	int expected_count;
	int current_count;
};

extern dict<std::string, LogExpectedItem> log_expect_log, log_expect_warning, log_expect_error;
void log_check_expected();

const char *log_signal(const RTLIL::SigSpec &sig, bool autoint = true);
const char *log_const(const RTLIL::Const &value, bool autoint = true);
const char *log_id(const RTLIL::IdString &id);

template<typename T> static inline const char *log_id(T *obj, const char *nullstr = nullptr) {
	if (nullstr && obj == nullptr)
		return nullstr;
	return log_id(obj->name);
}

void log_module(RTLIL::Module *module, std::string indent = "");
void log_cell(RTLIL::Cell *cell, std::string indent = "");
void log_wire(RTLIL::Wire *wire, std::string indent = "");

#ifndef NDEBUG
static inline void log_assert_worker(bool cond, const char *expr, const char *file, int line) {
	if (!cond) log_error("Assert \`%s' failed in %s:%d.\\n", expr, file, line);
}
#  define log_assert(_assert_expr_) YOSYS_NAMESPACE_PREFIX log_assert_worker(_assert_expr_, #_assert_expr_, __FILE__, __LINE__)
#else
#  define log_assert(_assert_expr_) do { if (0) { (void)(_assert_expr_); } } while(0)
#endif

#define log_abort() YOSYS_NAMESPACE_PREFIX log_error("Abort in %s:%d.\\n", __FILE__, __LINE__)
#define log_ping() YOSYS_NAMESPACE_PREFIX log("-- %s:%d %s --\\n", __FILE__, __LINE__, __PRETTY_FUNCTION__)


// ---------------------------------------------------
// This is the magic behind the code coverage counters
// ---------------------------------------------------

#if defined(YOSYS_ENABLE_COVER) && (defined(__linux__) || defined(__FreeBSD__))

#define cover(_id) do { \\
    static CoverData __d __attribute__((section("yosys_cover_list"), aligned(1), used)) = { __FILE__, __FUNCTION__, _id, __LINE__, 0 }; \\
    __d.counter++; \\
} while (0)

struct CoverData {
	const char *file, *func, *id;
	int line, counter;
} YS_ATTRIBUTE(packed);

// this two symbols are created by the linker for the "yosys_cover_list" ELF section
extern "C" struct CoverData __start_yosys_cover_list[];
extern "C" struct CoverData __stop_yosys_cover_list[];

extern dict<std::string, std::pair<std::string, int>> extra_coverage_data;

void cover_extra(std::string parent, std::string id, bool increment = true);
dict<std::string, std::pair<std::string, int>> get_coverage_data();

#define cover_list(_id, ...) do { cover(_id); \\
	std::string r = cover_list_worker(_id, __VA_ARGS__); \\
	log_assert(r.empty()); \\
} while (0)

static inline std::string cover_list_worker(std::string, std::string last) {
	return last;
}

template<typename... T>
std::string cover_list_worker(std::string prefix, std::string first, T... rest) {
	std::string selected = cover_list_worker(prefix, rest...);
	cover_extra(prefix, prefix + "." + first, first == selected);
	return first == selected ? "" : selected;
}

#else
#  define cover(...) do { } while (0)
#  define cover_list(...) do { } while (0)
#endif


// ------------------------------------------------------------
// everything below this line are utilities for troubleshooting
// ------------------------------------------------------------

// simple timer for performance measurements
// toggle the '#if 1' to get a baseline for the performance penalty added by the measurement
struct PerformanceTimer
{
#if 1
	int64_t total_ns;

	PerformanceTimer() {
		total_ns = 0;
	}

	static int64_t query() {
#  ifdef _WIN32
		return 0;
#  elif defined(RUSAGE_SELF)
		struct rusage rusage;
		int64_t t = 0;
		for (int who : {RUSAGE_SELF, RUSAGE_CHILDREN}) {
			if (getrusage(who, &rusage) == -1) {
				log_cmd_error("getrusage failed!\\n");
				log_abort();
			}
			t += 1000000000ULL * (int64_t) rusage.ru_utime.tv_sec + (int64_t) rusage.ru_utime.tv_usec * 1000ULL;
			t += 1000000000ULL * (int64_t) rusage.ru_stime.tv_sec + (int64_t) rusage.ru_stime.tv_usec * 1000ULL;
		}
		return t;
#  else
#    error "Don't know how to measure per-process CPU time. Need alternative method (times()/clocks()/gettimeofday()?)."
#  endif
	}

	void reset() {
		total_ns = 0;
	}

	void begin() {
		total_ns -= query();
	}

	void end() {
		total_ns += query();
	}

	float sec() const {
		return total_ns * 1e-9f;
	}
#else
	static int64_t query() { return 0; }
	void reset() { }
	void begin() { }
	void end() { }
	float sec() const { return 0; }
#endif
};

// simple API for quickly dumping values when debugging

static inline void log_dump_val_worker(short v) { log("%d", v); }
static inline void log_dump_val_worker(unsigned short v) { log("%u", v); }
static inline void log_dump_val_worker(int v) { log("%d", v); }
static inline void log_dump_val_worker(unsigned int v) { log("%u", v); }
static inline void log_dump_val_worker(long int v) { log("%ld", v); }
static inline void log_dump_val_worker(unsigned long int v) { log("%lu", v); }
#ifndef _WIN32
static inline void log_dump_val_worker(long long int v) { log("%lld", v); }
static inline void log_dump_val_worker(unsigned long long int v) { log("%lld", v); }
#endif
static inline void log_dump_val_worker(char c) { log(c >= 32 && c < 127 ? "'%c'" : "'\\\\x%02x'", c); }
static inline void log_dump_val_worker(unsigned char c) { log(c >= 32 && c < 127 ? "'%c'" : "'\\\\x%02x'", c); }
static inline void log_dump_val_worker(bool v) { log("%s", v ? "true" : "false"); }
static inline void log_dump_val_worker(double v) { log("%f", v); }
static inline void log_dump_val_worker(char *v) { log("%s", v); }
static inline void log_dump_val_worker(const char *v) { log("%s", v); }
static inline void log_dump_val_worker(std::string v) { log("%s", v.c_str()); }
static inline void log_dump_val_worker(PerformanceTimer p) { log("%f seconds", p.sec()); }
static inline void log_dump_args_worker(const char *p) { log_assert(*p == 0); }
void log_dump_val_worker(RTLIL::IdString v);
void log_dump_val_worker(RTLIL::SigSpec v);
void log_dump_val_worker(RTLIL::State v);

template<typename K, typename T, typename OPS> static inline void log_dump_val_worker(dict<K, T, OPS> &v);
template<typename K, typename OPS> static inline void log_dump_val_worker(pool<K, OPS> &v);
template<typename K> static inline void log_dump_val_worker(std::vector<K> &v);
template<typename T> static inline void log_dump_val_worker(T *ptr);

template<typename K, typename T, typename OPS>
static inline void log_dump_val_worker(dict<K, T, OPS> &v) {
	log("{");
	bool first = true;
	for (auto &it : v) {
		log(first ? " " : ", ");
		log_dump_val_worker(it.first);
		log(": ");
		log_dump_val_worker(it.second);
		first = false;
	}
	log(" }");
}

template<typename K, typename OPS>
static inline void log_dump_val_worker(pool<K, OPS> &v) {
	log("{");
	bool first = true;
	for (auto &it : v) {
		log(first ? " " : ", ");
		log_dump_val_worker(it);
		first = false;
	}
	log(" }");
}

template<typename K>
static inline void log_dump_val_worker(std::vector<K> &v) {
	log("{");
	bool first = true;
	for (auto &it : v) {
		log(first ? " " : ", ");
		log_dump_val_worker(it);
		first = false;
	}
	log(" }");
}

template<typename T>
static inline void log_dump_val_worker(T *ptr) { log("%p", ptr); }

template<typename T, typename ... Args>
void log_dump_args_worker(const char *p, T first, Args ... args)
{
	int next_p_state = 0;
	const char *next_p = p;
	while (*next_p && (next_p_state != 0 || *next_p != ',')) {
		if (*next_p == '"')
			do {
				next_p++;
				while (*next_p == '\\\\' && *(next_p + 1))
					next_p += 2;
			} while (*next_p && *next_p != '"');
		if (*next_p == '\\'') {
			next_p++;
			if (*next_p == '\\\\')
				next_p++;
			if (*next_p)
				next_p++;
		}
		if (*next_p == '(' || *next_p == '[' || *next_p == '{')
			next_p_state++;
		if ((*next_p == ')' || *next_p == ']' || *next_p == '}') && next_p_state > 0)
			next_p_state--;
		next_p++;
	}
	log("\\n\\t%.*s => ", int(next_p - p), p);
	if (*next_p == ',')
		next_p++;
	while (*next_p == ' ' || *next_p == '\\t' || *next_p == '\\r' || *next_p == '\\n')
		next_p++;
	log_dump_val_worker(first);
	log_dump_args_worker(next_p, args ...);
}

#define log_dump(...) do { \\
	log("DEBUG DUMP IN %s AT %s:%d:", __PRETTY_FUNCTION__, __FILE__, __LINE__); \\
	log_dump_args_worker(#__VA_ARGS__, __VA_ARGS__); \\
	log("\\n"); \\
} while (0)

YOSYS_NAMESPACE_END

#include "kernel/yosys.h"

#endif
`,"macc.h":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef MACC_H
#define MACC_H

#include "kernel/yosys.h"

YOSYS_NAMESPACE_BEGIN

struct Macc
{
	struct port_t {
		RTLIL::SigSpec in_a, in_b;
		bool is_signed, do_subtract;
	};

	std::vector<port_t> ports;
	RTLIL::SigSpec bit_ports;

	void optimize(int width)
	{
		std::vector<port_t> new_ports;
		RTLIL::SigSpec new_bit_ports;
		RTLIL::Const off(0, width);

		for (auto &port : ports)
		{
			if (GetSize(port.in_a) == 0 && GetSize(port.in_b) == 0)
				continue;

			if (GetSize(port.in_a) < GetSize(port.in_b))
				std::swap(port.in_a, port.in_b);

			if (GetSize(port.in_a) == 1 && GetSize(port.in_b) == 0 && !port.is_signed && !port.do_subtract) {
				bit_ports.append(port.in_a);
				continue;
			}

			if (port.in_a.is_fully_const() && port.in_b.is_fully_const()) {
				RTLIL::Const v = port.in_a.as_const();
				if (GetSize(port.in_b))
					v = const_mul(v, port.in_b.as_const(), port.is_signed, port.is_signed, width);
				if (port.do_subtract)
					off = const_sub(off, v, port.is_signed, port.is_signed, width);
				else
					off = const_add(off, v, port.is_signed, port.is_signed, width);
				continue;
			}

			if (port.is_signed) {
				while (GetSize(port.in_a) > 1 && port.in_a[GetSize(port.in_a)-1] == port.in_a[GetSize(port.in_a)-2])
					port.in_a.remove(GetSize(port.in_a)-1);
				while (GetSize(port.in_b) > 1 && port.in_b[GetSize(port.in_b)-1] == port.in_b[GetSize(port.in_b)-2])
					port.in_b.remove(GetSize(port.in_b)-1);
			} else {
				while (GetSize(port.in_a) > 1 && port.in_a[GetSize(port.in_a)-1] == State::S0)
					port.in_a.remove(GetSize(port.in_a)-1);
				while (GetSize(port.in_b) > 1 && port.in_b[GetSize(port.in_b)-1] == State::S0)
					port.in_b.remove(GetSize(port.in_b)-1);
			}

			new_ports.push_back(port);
		}

		for (auto &bit : bit_ports)
			if (bit == State::S1)
				off = const_add(off, RTLIL::Const(1, width), false, false, width);
			else if (bit != State::S0)
				new_bit_ports.append(bit);

		if (off.as_bool()) {
			port_t port;
			port.in_a = off;
			port.is_signed = false;
			port.do_subtract = false;
			new_ports.push_back(port);
		}

		new_ports.swap(ports);
		bit_ports = new_bit_ports;
	}

	void from_cell(RTLIL::Cell *cell)
	{
		RTLIL::SigSpec port_a = cell->getPort(ID::A);

		ports.clear();
		bit_ports = cell->getPort(ID::B);

		std::vector<RTLIL::State> config_bits = cell->getParam(ID::CONFIG).bits;
		int config_cursor = 0;

		int config_width = cell->getParam(ID::CONFIG_WIDTH).as_int();
		log_assert(GetSize(config_bits) >= config_width);

		int num_bits = 0;
		if (config_bits[config_cursor++] == State::S1) num_bits |= 1;
		if (config_bits[config_cursor++] == State::S1) num_bits |= 2;
		if (config_bits[config_cursor++] == State::S1) num_bits |= 4;
		if (config_bits[config_cursor++] == State::S1) num_bits |= 8;

		int port_a_cursor = 0;
		while (port_a_cursor < GetSize(port_a))
		{
			log_assert(config_cursor + 2 + 2*num_bits <= config_width);

			port_t this_port;
			this_port.is_signed = config_bits[config_cursor++] == State::S1;
			this_port.do_subtract = config_bits[config_cursor++] == State::S1;

			int size_a = 0;
			for (int i = 0; i < num_bits; i++)
				if (config_bits[config_cursor++] == State::S1)
					size_a |= 1 << i;

			this_port.in_a = port_a.extract(port_a_cursor, size_a);
			port_a_cursor += size_a;

			int size_b = 0;
			for (int i = 0; i < num_bits; i++)
				if (config_bits[config_cursor++] == State::S1)
					size_b |= 1 << i;

			this_port.in_b = port_a.extract(port_a_cursor, size_b);
			port_a_cursor += size_b;

			if (size_a || size_b)
				ports.push_back(this_port);
		}

		log_assert(config_cursor == config_width);
		log_assert(port_a_cursor == GetSize(port_a));
	}

	void to_cell(RTLIL::Cell *cell) const
	{
		RTLIL::SigSpec port_a;
		std::vector<RTLIL::State> config_bits;
		int max_size = 0, num_bits = 0;

		for (auto &port : ports) {
			max_size = max(max_size, GetSize(port.in_a));
			max_size = max(max_size, GetSize(port.in_b));
		}

		while (max_size)
			num_bits++, max_size /= 2;

		log_assert(num_bits < 16);
		config_bits.push_back(num_bits & 1 ? State::S1 : State::S0);
		config_bits.push_back(num_bits & 2 ? State::S1 : State::S0);
		config_bits.push_back(num_bits & 4 ? State::S1 : State::S0);
		config_bits.push_back(num_bits & 8 ? State::S1 : State::S0);

		for (auto &port : ports)
		{
			if (GetSize(port.in_a) == 0)
				continue;

			config_bits.push_back(port.is_signed ? State::S1 : State::S0);
			config_bits.push_back(port.do_subtract ? State::S1 : State::S0);

			int size_a = GetSize(port.in_a);
			for (int i = 0; i < num_bits; i++)
				config_bits.push_back(size_a & (1 << i) ? State::S1 : State::S0);

			int size_b = GetSize(port.in_b);
			for (int i = 0; i < num_bits; i++)
				config_bits.push_back(size_b & (1 << i) ? State::S1 : State::S0);

			port_a.append(port.in_a);
			port_a.append(port.in_b);
		}

		cell->setPort(ID::A, port_a);
		cell->setPort(ID::B, bit_ports);
		cell->setParam(ID::CONFIG, config_bits);
		cell->setParam(ID::CONFIG_WIDTH, GetSize(config_bits));
		cell->setParam(ID::A_WIDTH, GetSize(port_a));
		cell->setParam(ID::B_WIDTH, GetSize(bit_ports));
	}

	bool eval(RTLIL::Const &result) const
	{
		for (auto &bit : result.bits)
			bit = State::S0;

		for (auto &port : ports)
		{
			if (!port.in_a.is_fully_const() || !port.in_b.is_fully_const())
				return false;

			RTLIL::Const summand;
			if (GetSize(port.in_b) == 0)
				summand = const_pos(port.in_a.as_const(), port.in_b.as_const(), port.is_signed, port.is_signed, GetSize(result));
			else
				summand = const_mul(port.in_a.as_const(), port.in_b.as_const(), port.is_signed, port.is_signed, GetSize(result));

			if (port.do_subtract)
				result = const_sub(result, summand, port.is_signed, port.is_signed, GetSize(result));
			else
				result = const_add(result, summand, port.is_signed, port.is_signed, GetSize(result));
		}

		for (auto bit : bit_ports) {
			if (bit.wire)
				return false;
			result = const_add(result, bit.data, false, false, GetSize(result));
		}

		return true;
	}

	Macc(RTLIL::Cell *cell = nullptr)
	{
		if (cell != nullptr)
			from_cell(cell);
	}
};

YOSYS_NAMESPACE_END

#endif
`,"mem.h":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2020  Marcelina Ko\u015Bcielnicka <mwk@0x04.net>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef MEM_H
#define MEM_H

#include "kernel/yosys.h"
#include "kernel/ffinit.h"

YOSYS_NAMESPACE_BEGIN

struct MemRd : RTLIL::AttrObject {
	bool removed;
	Cell *cell;
	int wide_log2;
	bool clk_enable, clk_polarity, ce_over_srst;
	Const arst_value, srst_value, init_value;
	// One bit for every write port, true iff simultanous read on this
	// port and write on the other port will bypass the written data
	// to this port's output (default behavior is to read old value).
	// Can only be set for write ports that have the same clock domain.
	std::vector<bool> transparency_mask;
	// One bit for every write port, true iff simultanous read on this
	// port and write on the other port will return an all-X (don't care)
	// value.  Mutually exclusive with transparency_mask.
	// Can only be set for write ports that have the same clock domain.
	// For optimization purposes, this will also be set if we can
	// determine that the two ports can never be active simultanously
	// (making the above vacuously true).
	std::vector<bool> collision_x_mask;
	SigSpec clk, en, arst, srst, addr, data;

	MemRd() : removed(false), cell(nullptr), wide_log2(0), clk_enable(false), clk_polarity(true), ce_over_srst(false), clk(State::Sx), en(State::S1), arst(State::S0), srst(State::S0) {}

	// Returns the address of given subword index accessed by this port.
	SigSpec sub_addr(int sub) {
		SigSpec res = addr;
		for (int i = 0; i < wide_log2; i++)
			res[i] = State(sub >> i & 1);
		return res;
	}
};

struct MemWr : RTLIL::AttrObject {
	bool removed;
	Cell *cell;
	int wide_log2;
	bool clk_enable, clk_polarity;
	std::vector<bool> priority_mask;
	SigSpec clk, en, addr, data;

	MemWr() : removed(false), cell(nullptr) {}

	// Returns the address of given subword index accessed by this port.
	SigSpec sub_addr(int sub) {
		SigSpec res = addr;
		for (int i = 0; i < wide_log2; i++)
			res[i] = State(sub >> i & 1);
		return res;
	}

	std::pair<SigSpec, std::vector<int>> compress_en();
	SigSpec decompress_en(const std::vector<int> &swizzle, SigSpec sig);
};

struct MemInit : RTLIL::AttrObject {
	bool removed;
	Cell *cell;
	Const addr;
	Const data;
	Const en;
	MemInit() : removed(false), cell(nullptr) {}
};

struct Mem : RTLIL::AttrObject {
	Module *module;
	IdString memid;
	bool packed;
	RTLIL::Memory *mem;
	Cell *cell;
	int width, start_offset, size;
	std::vector<MemInit> inits;
	std::vector<MemRd> rd_ports;
	std::vector<MemWr> wr_ports;

	// Removes this memory from the module.  The data in helper structures
	// is unaffected except for the cell/mem fields.
	void remove();

	// Commits all changes in helper structures into the module \u2014 ports and
	// inits marked as removed are actually removed, new ports/inits create
	// new cells, modified port/inits are commited into their existing
	// cells.  Note that this reindexes the ports and inits array (actually
	// removing the ports/inits marked as removed).
	void emit();

	// Marks all inits as removed.
	void clear_inits();

	// Coalesces inits: whenever two inits have overlapping or touching
	// address ranges, they are combined into one, with the higher-priority
	// one's data overwriting the other.  Running this results in
	// an inits list equivalent to the original, in which all entries
	// cover disjoint (and non-touching) address ranges, and all enable
	// masks are all-1.
	void coalesce_inits();

	// Checks consistency of this memory and all its ports/inits, using
	// log_assert.
	void check();

	// Gathers all initialization data into a single big const covering
	// the whole memory.  For all non-initialized bits, Sx will be returned.
	Const get_init_data() const;

	// Constructs and returns the helper structures for all memories
	// in a module.
	static std::vector<Mem> get_all_memories(Module *module);

	// Constructs and returns the helper structures for all selected
	// memories in a module.
	static std::vector<Mem> get_selected_memories(Module *module);

	// Converts a synchronous read port into an asynchronous one by
	// extracting the data (or, in some rare cases, address) register
	// into a separate cell, together with any soft-transparency
	// logic necessary to preserve its semantics.  Returns the created
	// register cell, if any.  Note that in some rare cases this function
	// may succeed and perform a conversion without creating a new
	// register \u2014 a nullptr result doesn't imply nothing was done.
	Cell *extract_rdff(int idx, FfInitVals *initvals);

	// Splits all wide ports in this memory into equivalent narrow ones.
	// This function performs no modifications at all to the actual
	// netlist unless and until emit() is called.
	void narrow();

	// If write port idx2 currently has priority over write port idx1,
	// inserts extra logic on idx1's enable signal to disable writes
	// when idx2 is writing to the same address, then removes the priority
	// from the priority mask.  If there is a memory port that is
	// transparent with idx1, but not with idx2, that port is converted
	// to use soft transparency logic.
	void emulate_priority(int idx1, int idx2, FfInitVals *initvals);

	// Creates soft-transparency logic on read port ridx, bypassing the
	// data from write port widx.  Should only be called when ridx is
	// transparent wrt widx in the first place.  Once we're done, the
	// transparency_mask bit will be cleared, and the collision_x_mask
	// bit will be set instead (since whatever value is read will be
	// replaced by the soft transparency logic).
	void emulate_transparency(int widx, int ridx, FfInitVals *initvals);

	// Prepares for merging write port idx2 into idx1 (where idx1 < idx2).
	// Specifically, takes care of priority masks: any priority relations
	// that idx2 had are replicated onto idx1, unless they conflict with
	// priorities already present on idx1, in which case emulate_priority
	// is called.  Likewise, ensures transparency and undefined collision
	// masks of all read ports have the same values for both ports,
	// calling emulate_transparency if necessary.
	void prepare_wr_merge(int idx1, int idx2, FfInitVals *initvals);

	// Prepares for merging read port idx2 into idx1.
	// Specifically, makes sure the transparency and undefined collision
	// masks of both ports are equal, by changing undefined behavior
	// of one port to the other's defined behavior, or by calling
	// emulate_transparency if necessary.
	void prepare_rd_merge(int idx1, int idx2, FfInitVals *initvals);

	// Prepares the memory for widening a port to a given width.  This
	// involves ensuring that start_offset and size are aligned to the
	// target width.
	void widen_prep(int wide_log2);

	// Widens a write port up to a given width.  The newly port is
	// equivalent to the original, made by replicating enable/data bits
	// and masking enable bits with decoders on the low part of the
	// original address.
	void widen_wr_port(int idx, int wide_log2);

	// Emulates a sync read port's enable functionality in soft logic,
	// changing the actual read port's enable to be always-on.
	void emulate_rden(int idx, FfInitVals *initvals);

	// Emulates a sync read port's initial/reset value functionality in
	// soft logic, removing it from the actual read port.
	void emulate_reset(int idx, bool emu_init, bool emu_arst, bool emu_srst, FfInitVals *initvals);

	// Given a read port with ce_over_srst set, converts it to a port
	// with ce_over_srst unset without changing its behavior by adding
	// emulation logic.
	void emulate_rd_ce_over_srst(int idx);

	// Given a read port with ce_over_srst unset, converts it to a port
	// with ce_over_srst set without changing its behavior by adding
	// emulation logic.
	void emulate_rd_srst_over_ce(int idx);

	// Returns true iff emulate_read_first makes sense to call.
	bool emulate_read_first_ok();

	// Emulates all read-first read-write port relationships in terms of
	// all-transparent ports, by delaying all write ports by one cycle.
	// This can only be used when all read ports and all write ports are
	// in the same clock domain.
	void emulate_read_first(FfInitVals *initvals);

	Mem(Module *module, IdString memid, int width, int start_offset, int size) : module(module), memid(memid), packed(false), mem(nullptr), cell(nullptr), width(width), start_offset(start_offset), size(size) {}
};

YOSYS_NAMESPACE_END

#endif
`,"modtools.h":`/* -*- c++ -*-
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef MODTOOLS_H
#define MODTOOLS_H

#include "kernel/yosys.h"
#include "kernel/sigtools.h"
#include "kernel/celltypes.h"

YOSYS_NAMESPACE_BEGIN

struct ModIndex : public RTLIL::Monitor
{
	struct PortInfo {
		RTLIL::Cell* cell;
		RTLIL::IdString port;
		int offset;

		PortInfo() : cell(), port(), offset() { }
		PortInfo(RTLIL::Cell* _c, RTLIL::IdString _p, int _o) : cell(_c), port(_p), offset(_o) { }

		bool operator<(const PortInfo &other) const {
			if (cell != other.cell)
				return cell < other.cell;
			if (offset != other.offset)
				return offset < other.offset;
			return port < other.port;
		}

		bool operator==(const PortInfo &other) const {
			return cell == other.cell && port == other.port && offset == other.offset;
		}

		unsigned int hash() const {
			return mkhash_add(mkhash(cell->name.hash(), port.hash()), offset);
		}
	};

	struct SigBitInfo
	{
		bool is_input, is_output;
		pool<PortInfo> ports;

		SigBitInfo() : is_input(false), is_output(false) { }

		bool operator==(const SigBitInfo &other) const {
			return is_input == other.is_input && is_output == other.is_output && ports == other.ports;
		}

		void merge(const SigBitInfo &other)
		{
			is_input = is_input || other.is_input;
			is_output = is_output || other.is_output;
			ports.insert(other.ports.begin(), other.ports.end());
		}
	};

	SigMap sigmap;
	RTLIL::Module *module;
	std::map<RTLIL::SigBit, SigBitInfo> database;
	int auto_reload_counter;
	bool auto_reload_module;

	void port_add(RTLIL::Cell *cell, RTLIL::IdString port, const RTLIL::SigSpec &sig)
	{
		for (int i = 0; i < GetSize(sig); i++) {
			RTLIL::SigBit bit = sigmap(sig[i]);
			if (bit.wire)
				database[bit].ports.insert(PortInfo(cell, port, i));
		}
	}

	void port_del(RTLIL::Cell *cell, RTLIL::IdString port, const RTLIL::SigSpec &sig)
	{
		for (int i = 0; i < GetSize(sig); i++) {
			RTLIL::SigBit bit = sigmap(sig[i]);
			if (bit.wire)
				database[bit].ports.erase(PortInfo(cell, port, i));
		}
	}

	const SigBitInfo &info(RTLIL::SigBit bit)
	{
		return database[sigmap(bit)];
	}

	void reload_module(bool reset_sigmap = true)
	{
		if (reset_sigmap) {
			sigmap.clear();
			sigmap.set(module);
		}

		database.clear();
		for (auto wire : module->wires())
			if (wire->port_input || wire->port_output)
				for (int i = 0; i < GetSize(wire); i++) {
					RTLIL::SigBit bit = sigmap(RTLIL::SigBit(wire, i));
					if (bit.wire && wire->port_input)
						database[bit].is_input = true;
					if (bit.wire && wire->port_output)
						database[bit].is_output = true;
				}
		for (auto cell : module->cells())
			for (auto &conn : cell->connections())
				port_add(cell, conn.first, conn.second);

		if (auto_reload_module) {
			if (++auto_reload_counter > 2)
				log_warning("Auto-reload in ModIndex -- possible performance bug!\\n");
			auto_reload_module = false;
		}
	}

	void check()
	{
#ifndef NDEBUG
		if (auto_reload_module)
			return;

		for (auto it : database)
			log_assert(it.first == sigmap(it.first));

		auto database_bak = std::move(database);
		reload_module(false);

		if (!(database == database_bak))
		{
			for (auto &it : database_bak)
				if (!database.count(it.first))
					log("ModuleIndex::check(): Only in database_bak, not database: %s\\n", log_signal(it.first));

			for (auto &it : database)
				if (!database_bak.count(it.first))
					log("ModuleIndex::check(): Only in database, not database_bak: %s\\n", log_signal(it.first));
				else if (!(it.second == database_bak.at(it.first)))
					log("ModuleIndex::check(): Different content for database[%s].\\n", log_signal(it.first));

			log_assert(database == database_bak);
		}
#endif
	}

	void notify_connect(RTLIL::Cell *cell, const RTLIL::IdString &port, const RTLIL::SigSpec &old_sig, const RTLIL::SigSpec &sig) override
	{
		log_assert(module == cell->module);

		if (auto_reload_module)
			return;

		port_del(cell, port, old_sig);
		port_add(cell, port, sig);
	}

	void notify_connect(RTLIL::Module *mod, const RTLIL::SigSig &sigsig) override
	{
		log_assert(module == mod);

		if (auto_reload_module)
			return;

		for (int i = 0; i < GetSize(sigsig.first); i++)
		{
			RTLIL::SigBit lhs = sigmap(sigsig.first[i]);
			RTLIL::SigBit rhs = sigmap(sigsig.second[i]);
			bool has_lhs = database.count(lhs) != 0;
			bool has_rhs = database.count(rhs) != 0;

			if (!has_lhs && !has_rhs) {
				sigmap.add(lhs, rhs);
			} else
			if (!has_rhs) {
				SigBitInfo new_info = database.at(lhs);
				database.erase(lhs);
				sigmap.add(lhs, rhs);
				lhs = sigmap(lhs);
				if (lhs.wire)
					database[lhs] = new_info;
			} else
			if (!has_lhs) {
				SigBitInfo new_info = database.at(rhs);
				database.erase(rhs);
				sigmap.add(lhs, rhs);
				rhs = sigmap(rhs);
				if (rhs.wire)
					database[rhs] = new_info;
			} else {
				SigBitInfo new_info = database.at(lhs);
				new_info.merge(database.at(rhs));
				database.erase(lhs);
				database.erase(rhs);
				sigmap.add(lhs, rhs);
				rhs = sigmap(rhs);
				if (rhs.wire)
					database[rhs] = new_info;
			}
		}
	}

	void notify_connect(RTLIL::Module *mod, const std::vector<RTLIL::SigSig>&) override
	{
		log_assert(module == mod);
		auto_reload_module = true;
	}

	void notify_blackout(RTLIL::Module *mod) override
	{
		log_assert(module == mod);
		auto_reload_module = true;
	}

	ModIndex(RTLIL::Module *_m) : sigmap(_m), module(_m)
	{
		auto_reload_counter = 0;
		auto_reload_module = true;
		module->monitors.insert(this);
	}

	~ModIndex()
	{
		module->monitors.erase(this);
	}

	SigBitInfo *query(RTLIL::SigBit bit)
	{
		if (auto_reload_module)
			reload_module();

		auto it = database.find(sigmap(bit));
		if (it == database.end())
			return nullptr;
		else
			return &it->second;
	}

	bool query_is_input(RTLIL::SigBit bit)
	{
		const SigBitInfo *info = query(bit);
		if (info == nullptr)
			return false;
		return info->is_input;
	}

	bool query_is_output(RTLIL::SigBit bit)
	{
		const SigBitInfo *info = query(bit);
		if (info == nullptr)
			return false;
		return info->is_output;
	}

	pool<PortInfo> &query_ports(RTLIL::SigBit bit)
	{
		static pool<PortInfo> empty_result_set;
		SigBitInfo *info = query(bit);
		if (info == nullptr)
			return empty_result_set;
		return info->ports;
	}

	void dump_db()
	{
		log("--- ModIndex Dump ---\\n");

		if (auto_reload_module) {
			log("AUTO-RELOAD\\n");
			reload_module();
		}

		for (auto &it : database) {
			log("BIT %s:\\n", log_signal(it.first));
			if (it.second.is_input)
				log("  PRIMARY INPUT\\n");
			if (it.second.is_output)
				log("  PRIMARY OUTPUT\\n");
			for (auto &port : it.second.ports)
				log("  PORT: %s.%s[%d] (%s)\\n", log_id(port.cell),
						log_id(port.port), port.offset, log_id(port.cell->type));
		}
	}
};

struct ModWalker
{
	struct PortBit
	{
		RTLIL::Cell *cell;
		RTLIL::IdString port;
		int offset;

		bool operator<(const PortBit &other) const {
			if (cell != other.cell)
				return cell < other.cell;
			if (port != other.port)
				return port < other.port;
			return offset < other.offset;
		}

		bool operator==(const PortBit &other) const {
			return cell == other.cell && port == other.port && offset == other.offset;
		}

		unsigned int hash() const {
			return mkhash_add(mkhash(cell->name.hash(), port.hash()), offset);
		}
	};

	RTLIL::Design *design;
	RTLIL::Module *module;

	CellTypes ct;
	SigMap sigmap;

	dict<RTLIL::SigBit, pool<PortBit>> signal_drivers;
	dict<RTLIL::SigBit, pool<PortBit>> signal_consumers;
	pool<RTLIL::SigBit> signal_inputs, signal_outputs;

	dict<RTLIL::Cell*, pool<RTLIL::SigBit>> cell_outputs, cell_inputs;

	void add_wire(RTLIL::Wire *wire)
	{
		if (wire->port_input) {
			std::vector<RTLIL::SigBit> bits = sigmap(wire);
			for (auto bit : bits)
				if (bit.wire != NULL)
					signal_inputs.insert(bit);
		}

		if (wire->port_output) {
			std::vector<RTLIL::SigBit> bits = sigmap(wire);
			for (auto bit : bits)
				if (bit.wire != NULL)
					signal_outputs.insert(bit);
		}
	}

	void add_cell_port(RTLIL::Cell *cell, RTLIL::IdString port, std::vector<RTLIL::SigBit> bits, bool is_output, bool is_input)
	{
		for (int i = 0; i < int(bits.size()); i++)
			if (bits[i].wire != NULL) {
				PortBit pbit = { cell, port, i };
				if (is_output) {
					signal_drivers[bits[i]].insert(pbit);
					cell_outputs[cell].insert(bits[i]);
				}
				if (is_input) {
					signal_consumers[bits[i]].insert(pbit);
					cell_inputs[cell].insert(bits[i]);
				}
			}
	}

	void add_cell(RTLIL::Cell *cell)
	{
		if (ct.cell_known(cell->type)) {
			for (auto &conn : cell->connections())
				add_cell_port(cell, conn.first, sigmap(conn.second),
						ct.cell_output(cell->type, conn.first),
						ct.cell_input(cell->type, conn.first));
		} else {
			for (auto &conn : cell->connections())
				add_cell_port(cell, conn.first, sigmap(conn.second), true, true);
		}
	}

	ModWalker(RTLIL::Design *design, RTLIL::Module *module = nullptr) : design(design), module(NULL)
	{
		ct.setup(design);
		if (module)
			setup(module);
	}

	void setup(RTLIL::Module *module, CellTypes *filter_ct = NULL)
	{
		this->module = module;

		sigmap.set(module);

		signal_drivers.clear();
		signal_consumers.clear();
		signal_inputs.clear();
		signal_outputs.clear();
		cell_inputs.clear();
		cell_outputs.clear();

		for (auto &it : module->wires_)
			add_wire(it.second);
		for (auto &it : module->cells_)
			if (filter_ct == NULL || filter_ct->cell_known(it.second->type))
				add_cell(it.second);
	}

	// get_* methods -- single RTLIL::SigBit

	inline bool get_drivers(pool<PortBit> &result, RTLIL::SigBit bit) const
	{
		bool found = false;
		if (signal_drivers.count(bit)) {
			const pool<PortBit> &r = signal_drivers.at(bit);
			result.insert(r.begin(), r.end());
			found = true;
		}
		return found;
	}

	inline bool get_consumers(pool<PortBit> &result, RTLIL::SigBit bit) const
	{
		bool found = false;
		if (signal_consumers.count(bit)) {
			const pool<PortBit> &r = signal_consumers.at(bit);
			result.insert(r.begin(), r.end());
			found = true;
		}
		return found;
	}

	inline bool get_inputs(pool<RTLIL::SigBit> &result, RTLIL::SigBit bit) const
	{
		bool found = false;
		if (signal_inputs.count(bit))
			result.insert(bit), found = true;
		return found;
	}

	inline bool get_outputs(pool<RTLIL::SigBit> &result, RTLIL::SigBit bit) const
	{
		bool found = false;
		if (signal_outputs.count(bit))
			result.insert(bit), found = true;
		return found;
	}

	// get_* methods -- container of RTLIL::SigBit's (always by reference)

	template<typename T>
	inline bool get_drivers(pool<PortBit> &result, const T &bits) const
	{
		bool found = false;
		for (RTLIL::SigBit bit : bits)
			if (signal_drivers.count(bit)) {
				const pool<PortBit> &r = signal_drivers.at(bit);
				result.insert(r.begin(), r.end());
				found = true;
			}
		return found;
	}

	template<typename T>
	inline bool get_consumers(pool<PortBit> &result, const T &bits) const
	{
		bool found = false;
		for (RTLIL::SigBit bit : bits)
			if (signal_consumers.count(bit)) {
				const pool<PortBit> &r = signal_consumers.at(bit);
				result.insert(r.begin(), r.end());
				found = true;
			}
		return found;
	}

	template<typename T>
	inline bool get_inputs(pool<RTLIL::SigBit> &result, const T &bits) const
	{
		bool found = false;
		for (RTLIL::SigBit bit : bits)
			if (signal_inputs.count(bit))
				result.insert(bit), found = true;
		return found;
	}

	template<typename T>
	inline bool get_outputs(pool<RTLIL::SigBit> &result, const T &bits) const
	{
		bool found = false;
		for (RTLIL::SigBit bit : bits)
			if (signal_outputs.count(bit))
				result.insert(bit), found = true;
		return found;
	}

	// get_* methods -- call by RTLIL::SigSpec (always by value)

	bool get_drivers(pool<PortBit> &result, RTLIL::SigSpec signal) const
	{
		std::vector<RTLIL::SigBit> bits = sigmap(signal);
		return get_drivers(result, bits);
	}

	bool get_consumers(pool<PortBit> &result, RTLIL::SigSpec signal) const
	{
		std::vector<RTLIL::SigBit> bits = sigmap(signal);
		return get_consumers(result, bits);
	}

	bool get_inputs(pool<RTLIL::SigBit> &result, RTLIL::SigSpec signal) const
	{
		std::vector<RTLIL::SigBit> bits = sigmap(signal);
		return get_inputs(result, bits);
	}

	bool get_outputs(pool<RTLIL::SigBit> &result, RTLIL::SigSpec signal) const
	{
		std::vector<RTLIL::SigBit> bits = sigmap(signal);
		return get_outputs(result, bits);
	}

	// has_* methods -- call by reference

	template<typename T>
	inline bool has_drivers(const T &sig) const {
		pool<PortBit> result;
		return get_drivers(result, sig);
	}

	template<typename T>
	inline bool has_consumers(const T &sig) const {
		pool<PortBit> result;
		return get_consumers(result, sig);
	}

	template<typename T>
	inline bool has_inputs(const T &sig) const {
		pool<RTLIL::SigBit> result;
		return get_inputs(result, sig);
	}

	template<typename T>
	inline bool has_outputs(const T &sig) const {
		pool<RTLIL::SigBit> result;
		return get_outputs(result, sig);
	}

	// has_* methods -- call by value

	inline bool has_drivers(RTLIL::SigSpec sig) const {
		pool<PortBit> result;
		return get_drivers(result, sig);
	}

	inline bool has_consumers(RTLIL::SigSpec sig) const {
		pool<PortBit> result;
		return get_consumers(result, sig);
	}

	inline bool has_inputs(RTLIL::SigSpec sig) const {
		pool<RTLIL::SigBit> result;
		return get_inputs(result, sig);
	}

	inline bool has_outputs(RTLIL::SigSpec sig) const {
		pool<RTLIL::SigBit> result;
		return get_outputs(result, sig);
	}
};

YOSYS_NAMESPACE_END

#endif
`,"qcsat.h":`/* -*- c++ -*-
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2021  Marcelina Ko\u015Bcielnicka <mwk@0x04.net>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef QCSAT_H
#define QCSAT_H

#include "kernel/satgen.h"
#include "kernel/modtools.h"

YOSYS_NAMESPACE_BEGIN

// This is a helper class meant for easy construction of quick SAT queries
// to a combinatorial input cone of some set of signals, meant for SAT-based
// optimizations.  Various knobs are provided to set just how much of the
// cone should be included in the model \u2014 since this class is meant for
// optimization, it should not be a correctness problem when some cells are
// skipped and the solver spuriously returns SAT with a solution that
// cannot exist in reality due to skipped constraints (ie. only UNSAT results
// from this class should be considered binding).
struct QuickConeSat {
	ModWalker &modwalker;
	ezSatPtr ez;
	SatGen satgen;

	// The effort level knobs.

	// The maximum "complexity level" of cells that will be imported.
	// - 1: bitwise operations, muxes, equality comparisons, lut, sop, fa
	// - 2: addition, subtraction, greater/less than comparisons, lcu
	// - 3: shifts
	// - 4: multiplication, division, power
	int max_cell_complexity = 2;
	// The maximum number of cells to import, or 0 for no limit.
	int max_cell_count = 0;
	// If non-0, skip importing cells with more than this number of output bits.
	int max_cell_outs = 0;

	// Internal state.
	pool<RTLIL::Cell*> imported_cells;
	pool<RTLIL::Wire*> imported_onehot;
	pool<RTLIL::SigBit> bits_queue;

	QuickConeSat(ModWalker &modwalker) : modwalker(modwalker), ez(), satgen(ez.get(), &modwalker.sigmap) {}

	// Imports a signal into the SAT solver, queues its input cone to be
	// imported in the next prepare() call.
	std::vector<int> importSig(SigSpec sig);
	int importSigBit(SigBit bit);

	// Imports the input cones of all previously importSig'd signals into
	// the SAT solver.
	void prepare();

	// Returns the "complexity level" of a given cell.
	static int cell_complexity(RTLIL::Cell *cell);
};

YOSYS_NAMESPACE_END

#endif
`,"register.h":`/* -*- c++ -*-
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef REGISTER_H
#define REGISTER_H

#include "kernel/yosys_common.h"
#include "kernel/yosys.h"

YOSYS_NAMESPACE_BEGIN

struct Pass
{
	std::string pass_name, short_help;
	Pass(std::string name, std::string short_help = "** document me **");
	virtual ~Pass();

	virtual void help();
	virtual void clear_flags();
	virtual void execute(std::vector<std::string> args, RTLIL::Design *design) = 0;

	int call_counter;
	int64_t runtime_ns;
	bool experimental_flag = false;

	void experimental() {
		experimental_flag = true;
	}

	struct pre_post_exec_state_t {
		Pass *parent_pass;
		int64_t begin_ns;
	};

	pre_post_exec_state_t pre_execute();
	void post_execute(pre_post_exec_state_t state);

	void cmd_log_args(const std::vector<std::string> &args);
	void cmd_error(const std::vector<std::string> &args, size_t argidx, std::string msg);
	void extra_args(std::vector<std::string> args, size_t argidx, RTLIL::Design *design, bool select = true);

	static void call(RTLIL::Design *design, std::string command);
	static void call(RTLIL::Design *design, std::vector<std::string> args);

	static void call_on_selection(RTLIL::Design *design, const RTLIL::Selection &selection, std::string command);
	static void call_on_selection(RTLIL::Design *design, const RTLIL::Selection &selection, std::vector<std::string> args);

	static void call_on_module(RTLIL::Design *design, RTLIL::Module *module, std::string command);
	static void call_on_module(RTLIL::Design *design, RTLIL::Module *module, std::vector<std::string> args);

	Pass *next_queued_pass;
	virtual void run_register();
	static void init_register();
	static void done_register();

	virtual void on_register();
	virtual void on_shutdown();
	virtual bool replace_existing_pass() const { return false; }
};

struct ScriptPass : Pass
{
	bool block_active, help_mode;
	RTLIL::Design *active_design;
	std::string active_run_from, active_run_to;

	ScriptPass(std::string name, std::string short_help = "** document me **") : Pass(name, short_help) { }

	virtual void script() = 0;

	bool check_label(std::string label, std::string info = std::string());
	void run(std::string command, std::string info = std::string());
	void run_nocheck(std::string command, std::string info = std::string());
	void run_script(RTLIL::Design *design, std::string run_from = std::string(), std::string run_to = std::string());
	void help_script();
};

struct Frontend : Pass
{
	// for reading of here documents
	static FILE *current_script_file;
	static std::string last_here_document;

	std::string frontend_name;
	Frontend(std::string name, std::string short_help = "** document me **");
	void run_register() override;
	~Frontend() override;
	void execute(std::vector<std::string> args, RTLIL::Design *design) override final;
	virtual void execute(std::istream *&f, std::string filename, std::vector<std::string> args, RTLIL::Design *design) = 0;

	static std::vector<std::string> next_args;
	void extra_args(std::istream *&f, std::string &filename, std::vector<std::string> args, size_t argidx, bool bin_input = false);

	static void frontend_call(RTLIL::Design *design, std::istream *f, std::string filename, std::string command);
	static void frontend_call(RTLIL::Design *design, std::istream *f, std::string filename, std::vector<std::string> args);
};

struct Backend : Pass
{
	std::string backend_name;
	Backend(std::string name, std::string short_help = "** document me **");
	void run_register() override;
	~Backend() override;
	void execute(std::vector<std::string> args, RTLIL::Design *design) override final;
	virtual void execute(std::ostream *&f, std::string filename,  std::vector<std::string> args, RTLIL::Design *design) = 0;

	void extra_args(std::ostream *&f, std::string &filename, std::vector<std::string> args, size_t argidx, bool bin_output = false);

	static void backend_call(RTLIL::Design *design, std::ostream *f, std::string filename, std::string command);
	static void backend_call(RTLIL::Design *design, std::ostream *f, std::string filename, std::vector<std::string> args);
};

// implemented in passes/cmds/select.cc
extern void handle_extra_select_args(Pass *pass, const std::vector<std::string> &args, size_t argidx, size_t args_size, RTLIL::Design *design);
extern RTLIL::Selection eval_select_args(const vector<string> &args, RTLIL::Design *design);
extern void eval_select_op(vector<RTLIL::Selection> &work, const string &op, RTLIL::Design *design);

extern std::map<std::string, Pass*> pass_register;
extern std::map<std::string, Frontend*> frontend_register;
extern std::map<std::string, Backend*> backend_register;

YOSYS_NAMESPACE_END

#endif
`,"rtlil.h":`/* -*- c++ -*-
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef RTLIL_H
#define RTLIL_H

#include "kernel/yosys_common.h"
#include "kernel/yosys.h"

YOSYS_NAMESPACE_BEGIN

namespace RTLIL
{
	enum State : unsigned char {
		S0 = 0,
		S1 = 1,
		Sx = 2, // undefined value or conflict
		Sz = 3, // high-impedance / not-connected
		Sa = 4, // don't care (used only in cases)
		Sm = 5  // marker (used internally by some passes)
	};

	enum SyncType : unsigned char {
		ST0 = 0, // level sensitive: 0
		ST1 = 1, // level sensitive: 1
		STp = 2, // edge sensitive: posedge
		STn = 3, // edge sensitive: negedge
		STe = 4, // edge sensitive: both edges
		STa = 5, // always active
		STg = 6, // global clock
		STi = 7  // init
	};

	enum ConstFlags : unsigned char {
		CONST_FLAG_NONE   = 0,
		CONST_FLAG_STRING = 1,
		CONST_FLAG_SIGNED = 2,  // only used for parameters
		CONST_FLAG_REAL   = 4   // only used for parameters
	};

	struct Const;
	struct AttrObject;
	struct Selection;
	struct Monitor;
	struct Design;
	struct Module;
	struct Wire;
	struct Memory;
	struct Cell;
	struct SigChunk;
	struct SigBit;
	struct SigSpecIterator;
	struct SigSpecConstIterator;
	struct SigSpec;
	struct CaseRule;
	struct SwitchRule;
	struct MemWriteAction;
	struct SyncRule;
	struct Process;
	struct Binding;

	typedef std::pair<SigSpec, SigSpec> SigSig;

	struct IdString
	{
		#undef YOSYS_XTRACE_GET_PUT
		#undef YOSYS_SORT_ID_FREE_LIST
		#undef YOSYS_USE_STICKY_IDS
		#undef YOSYS_NO_IDS_REFCNT

		// the global id string cache

		static bool destruct_guard_ok; // POD, will be initialized to zero
		static struct destruct_guard_t {
			destruct_guard_t() { destruct_guard_ok = true; }
			~destruct_guard_t() { destruct_guard_ok = false; }
		} destruct_guard;

		static std::vector<char*> global_id_storage_;
		static dict<char*, int, hash_cstr_ops> global_id_index_;
	#ifndef YOSYS_NO_IDS_REFCNT
		static std::vector<int> global_refcount_storage_;
		static std::vector<int> global_free_idx_list_;
	#endif

	#ifdef YOSYS_USE_STICKY_IDS
		static int last_created_idx_ptr_;
		static int last_created_idx_[8];
	#endif

		static inline void xtrace_db_dump()
		{
		#ifdef YOSYS_XTRACE_GET_PUT
			for (int idx = 0; idx < GetSize(global_id_storage_); idx++)
			{
				if (global_id_storage_.at(idx) == nullptr)
					log("#X# DB-DUMP index %d: FREE\\n", idx);
				else
					log("#X# DB-DUMP index %d: '%s' (ref %d)\\n", idx, global_id_storage_.at(idx), global_refcount_storage_.at(idx));
			}
		#endif
		}

		static inline void checkpoint()
		{
		#ifdef YOSYS_USE_STICKY_IDS
			last_created_idx_ptr_ = 0;
			for (int i = 0; i < 8; i++) {
				if (last_created_idx_[i])
					put_reference(last_created_idx_[i]);
				last_created_idx_[i] = 0;
			}
		#endif
		#ifdef YOSYS_SORT_ID_FREE_LIST
			std::sort(global_free_idx_list_.begin(), global_free_idx_list_.end(), std::greater<int>());
		#endif
		}

		static inline int get_reference(int idx)
		{
			if (idx) {
		#ifndef YOSYS_NO_IDS_REFCNT
				global_refcount_storage_[idx]++;
		#endif
		#ifdef YOSYS_XTRACE_GET_PUT
				if (yosys_xtrace)
					log("#X# GET-BY-INDEX '%s' (index %d, refcount %d)\\n", global_id_storage_.at(idx), idx, global_refcount_storage_.at(idx));
		#endif
			}
			return idx;
		}

		static int get_reference(const char *p)
		{
			log_assert(destruct_guard_ok);

			if (!p[0])
				return 0;

			auto it = global_id_index_.find((char*)p);
			if (it != global_id_index_.end()) {
		#ifndef YOSYS_NO_IDS_REFCNT
				global_refcount_storage_.at(it->second)++;
		#endif
		#ifdef YOSYS_XTRACE_GET_PUT
				if (yosys_xtrace)
					log("#X# GET-BY-NAME '%s' (index %d, refcount %d)\\n", global_id_storage_.at(it->second), it->second, global_refcount_storage_.at(it->second));
		#endif
				return it->second;
			}

			log_assert(p[0] == '$' || p[0] == '\\\\');
			log_assert(p[1] != 0);
			for (const char *c = p; *c; c++)
				if ((unsigned)*c <= (unsigned)' ')
					log_error("Found control character or space (0x%02x) in string '%s' which is not allowed in RTLIL identifiers\\n", *c, p);

		#ifndef YOSYS_NO_IDS_REFCNT
			if (global_free_idx_list_.empty()) {
				if (global_id_storage_.empty()) {
					global_refcount_storage_.push_back(0);
					global_id_storage_.push_back((char*)"");
					global_id_index_[global_id_storage_.back()] = 0;
				}
				log_assert(global_id_storage_.size() < 0x40000000);
				global_free_idx_list_.push_back(global_id_storage_.size());
				global_id_storage_.push_back(nullptr);
				global_refcount_storage_.push_back(0);
			}

			int idx = global_free_idx_list_.back();
			global_free_idx_list_.pop_back();
			global_id_storage_.at(idx) = strdup(p);
			global_id_index_[global_id_storage_.at(idx)] = idx;
			global_refcount_storage_.at(idx)++;
		#else
			if (global_id_storage_.empty()) {
				global_id_storage_.push_back((char*)"");
				global_id_index_[global_id_storage_.back()] = 0;
			}
			int idx = global_id_storage_.size();
			global_id_storage_.push_back(strdup(p));
			global_id_index_[global_id_storage_.back()] = idx;
		#endif

			if (yosys_xtrace) {
				log("#X# New IdString '%s' with index %d.\\n", p, idx);
				log_backtrace("-X- ", yosys_xtrace-1);
			}

		#ifdef YOSYS_XTRACE_GET_PUT
			if (yosys_xtrace)
				log("#X# GET-BY-NAME '%s' (index %d, refcount %d)\\n", global_id_storage_.at(idx), idx, global_refcount_storage_.at(idx));
		#endif

		#ifdef YOSYS_USE_STICKY_IDS
			// Avoid Create->Delete->Create pattern
			if (last_created_idx_[last_created_idx_ptr_])
				put_reference(last_created_idx_[last_created_idx_ptr_]);
			last_created_idx_[last_created_idx_ptr_] = idx;
			get_reference(last_created_idx_[last_created_idx_ptr_]);
			last_created_idx_ptr_ = (last_created_idx_ptr_ + 1) & 7;
		#endif

			return idx;
		}

	#ifndef YOSYS_NO_IDS_REFCNT
		static inline void put_reference(int idx)
		{
			// put_reference() may be called from destructors after the destructor of
			// global_refcount_storage_ has been run. in this case we simply do nothing.
			if (!destruct_guard_ok || !idx)
				return;

		#ifdef YOSYS_XTRACE_GET_PUT
			if (yosys_xtrace) {
				log("#X# PUT '%s' (index %d, refcount %d)\\n", global_id_storage_.at(idx), idx, global_refcount_storage_.at(idx));
			}
		#endif

			int &refcount = global_refcount_storage_[idx];

			if (--refcount > 0)
				return;

			log_assert(refcount == 0);
			free_reference(idx);
		}
		static inline void free_reference(int idx)
		{
			if (yosys_xtrace) {
				log("#X# Removed IdString '%s' with index %d.\\n", global_id_storage_.at(idx), idx);
				log_backtrace("-X- ", yosys_xtrace-1);
			}

			global_id_index_.erase(global_id_storage_.at(idx));
			free(global_id_storage_.at(idx));
			global_id_storage_.at(idx) = nullptr;
			global_free_idx_list_.push_back(idx);
		}
	#else
		static inline void put_reference(int) { }
	#endif

		// the actual IdString object is just is a single int

		int index_;

		inline IdString() : index_(0) { }
		inline IdString(const char *str) : index_(get_reference(str)) { }
		inline IdString(const IdString &str) : index_(get_reference(str.index_)) { }
		inline IdString(IdString &&str) : index_(str.index_) { str.index_ = 0; }
		inline IdString(const std::string &str) : index_(get_reference(str.c_str())) { }
		inline ~IdString() { put_reference(index_); }

		inline void operator=(const IdString &rhs) {
			put_reference(index_);
			index_ = get_reference(rhs.index_);
		}

		inline void operator=(const char *rhs) {
			IdString id(rhs);
			*this = id;
		}

		inline void operator=(const std::string &rhs) {
			IdString id(rhs);
			*this = id;
		}

		inline const char *c_str() const {
			return global_id_storage_.at(index_);
		}

		inline std::string str() const {
			return std::string(global_id_storage_.at(index_));
		}

		inline bool operator<(const IdString &rhs) const {
			return index_ < rhs.index_;
		}

		inline bool operator==(const IdString &rhs) const { return index_ == rhs.index_; }
		inline bool operator!=(const IdString &rhs) const { return index_ != rhs.index_; }

		// The methods below are just convenience functions for better compatibility with std::string.

		bool operator==(const std::string &rhs) const { return c_str() == rhs; }
		bool operator!=(const std::string &rhs) const { return c_str() != rhs; }

		bool operator==(const char *rhs) const { return strcmp(c_str(), rhs) == 0; }
		bool operator!=(const char *rhs) const { return strcmp(c_str(), rhs) != 0; }

		char operator[](size_t i) const {
                        const char *p = c_str();
#ifndef NDEBUG
			for (; i != 0; i--, p++)
				log_assert(*p != 0);
			return *p;
#else
			return *(p + i);
#endif
		}

		std::string substr(size_t pos = 0, size_t len = std::string::npos) const {
			if (len == std::string::npos || len >= strlen(c_str() + pos))
				return std::string(c_str() + pos);
			else
				return std::string(c_str() + pos, len);
		}

		int compare(size_t pos, size_t len, const char* s) const {
			return strncmp(c_str()+pos, s, len);
		}

		bool begins_with(const char* prefix) const {
			size_t len = strlen(prefix);
			if (size() < len) return false;
			return compare(0, len, prefix) == 0;
		}

		bool ends_with(const char* suffix) const {
			size_t len = strlen(suffix);
			if (size() < len) return false;
			return compare(size()-len, len, suffix) == 0;
		}

		bool contains(const char* str) const {
			return strstr(c_str(), str);
		}

		size_t size() const {
			return strlen(c_str());
		}

		bool empty() const {
			return c_str()[0] == 0;
		}

		void clear() {
			*this = IdString();
		}

		unsigned int hash() const {
			return index_;
		}

		// The following is a helper key_compare class. Instead of for example std::set<Cell*>
		// use std::set<Cell*, IdString::compare_ptr_by_name<Cell>> if the order of cells in the
		// set has an influence on the algorithm.

		template<typename T> struct compare_ptr_by_name {
			bool operator()(const T *a, const T *b) const {
				return (a == nullptr || b == nullptr) ? (a < b) : (a->name < b->name);
			}
		};

		// often one needs to check if a given IdString is part of a list (for example a list
		// of cell types). the following functions helps with that.

		template<typename... Args>
		bool in(Args... args) const {
			// Credit: https://articles.emptycrate.com/2016/05/14/folds_in_cpp11_ish.html
			bool result = false;
			(void) std::initializer_list<int>{ (result = result || in(args), 0)... };
			return result;
		}

		bool in(const IdString &rhs) const { return *this == rhs; }
		bool in(const char *rhs) const { return *this == rhs; }
		bool in(const std::string &rhs) const { return *this == rhs; }
		bool in(const pool<IdString> &rhs) const { return rhs.count(*this) != 0; }

		bool isPublic() const { return begins_with("\\\\"); }
	};

	namespace ID {
#define X(_id) extern IdString _id;
#include "kernel/constids.inc"
#undef X
	};

	extern dict<std::string, std::string> constpad;

	const pool<IdString> &builtin_ff_cell_types();

	static inline std::string escape_id(const std::string &str) {
		if (str.size() > 0 && str[0] != '\\\\' && str[0] != '$')
			return "\\\\" + str;
		return str;
	}

	static inline std::string unescape_id(const std::string &str) {
		if (str.size() < 2)
			return str;
		if (str[0] != '\\\\')
			return str;
		if (str[1] == '$' || str[1] == '\\\\')
			return str;
		if (str[1] >= '0' && str[1] <= '9')
			return str;
		return str.substr(1);
	}

	static inline std::string unescape_id(const RTLIL::IdString &str) {
		return unescape_id(str.str());
	}

	static inline const char *id2cstr(const RTLIL::IdString &str) {
		return log_id(str);
	}

	template <typename T> struct sort_by_name_id {
		bool operator()(T *a, T *b) const {
			return a->name < b->name;
		}
	};

	template <typename T> struct sort_by_name_str {
		bool operator()(T *a, T *b) const {
			return strcmp(a->name.c_str(), b->name.c_str()) < 0;
		}
	};

	struct sort_by_id_str {
		bool operator()(const RTLIL::IdString &a, const RTLIL::IdString &b) const {
			return strcmp(a.c_str(), b.c_str()) < 0;
		}
	};

	static inline std::string encode_filename(const std::string &filename)
	{
		std::stringstream val;
		if (!std::any_of(filename.begin(), filename.end(), [](char c) {
			return static_cast<unsigned char>(c) < 33 || static_cast<unsigned char>(c) > 126;
		})) return filename;
		for (unsigned char const c : filename) {
			if (c < 33 || c > 126)
				val << stringf("$%02x", c);
			else
				val << c;
		}
		return val.str();
	}

	// see calc.cc for the implementation of this functions
	RTLIL::Const const_not         (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);
	RTLIL::Const const_and         (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);
	RTLIL::Const const_or          (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);
	RTLIL::Const const_xor         (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);
	RTLIL::Const const_xnor        (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);

	RTLIL::Const const_reduce_and  (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);
	RTLIL::Const const_reduce_or   (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);
	RTLIL::Const const_reduce_xor  (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);
	RTLIL::Const const_reduce_xnor (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);
	RTLIL::Const const_reduce_bool (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);

	RTLIL::Const const_logic_not   (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);
	RTLIL::Const const_logic_and   (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);
	RTLIL::Const const_logic_or    (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);

	RTLIL::Const const_shl         (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);
	RTLIL::Const const_shr         (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);
	RTLIL::Const const_sshl        (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);
	RTLIL::Const const_sshr        (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);
	RTLIL::Const const_shift       (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);
	RTLIL::Const const_shiftx      (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);

	RTLIL::Const const_lt          (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);
	RTLIL::Const const_le          (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);
	RTLIL::Const const_eq          (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);
	RTLIL::Const const_ne          (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);
	RTLIL::Const const_eqx         (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);
	RTLIL::Const const_nex         (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);
	RTLIL::Const const_ge          (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);
	RTLIL::Const const_gt          (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);

	RTLIL::Const const_add         (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);
	RTLIL::Const const_sub         (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);
	RTLIL::Const const_mul         (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);
	RTLIL::Const const_div         (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);
	RTLIL::Const const_divfloor    (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);
	RTLIL::Const const_modfloor    (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);
	RTLIL::Const const_mod         (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);
	RTLIL::Const const_pow         (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);

	RTLIL::Const const_pos         (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);
	RTLIL::Const const_neg         (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);

	RTLIL::Const const_mux         (const RTLIL::Const &arg1, const RTLIL::Const &arg2, const RTLIL::Const &arg3);
	RTLIL::Const const_pmux        (const RTLIL::Const &arg1, const RTLIL::Const &arg2, const RTLIL::Const &arg3);
	RTLIL::Const const_bmux        (const RTLIL::Const &arg1, const RTLIL::Const &arg2);
	RTLIL::Const const_demux       (const RTLIL::Const &arg1, const RTLIL::Const &arg2);

	RTLIL::Const const_bweqx       (const RTLIL::Const &arg1, const RTLIL::Const &arg2);
	RTLIL::Const const_bwmux       (const RTLIL::Const &arg1, const RTLIL::Const &arg2, const RTLIL::Const &arg3);


	// This iterator-range-pair is used for Design::modules(), Module::wires() and Module::cells().
	// It maintains a reference counter that is used to make sure that the container is not modified while being iterated over.

	template<typename T>
	struct ObjIterator {
		using iterator_category = std::forward_iterator_tag;
		using value_type = T;
		using difference_type = ptrdiff_t;
		using pointer = T*;
		using reference = T&;
		typename dict<RTLIL::IdString, T>::iterator it;
		dict<RTLIL::IdString, T> *list_p;
		int *refcount_p;

		ObjIterator() : list_p(nullptr), refcount_p(nullptr) {
		}

		ObjIterator(decltype(list_p) list_p, int *refcount_p) : list_p(list_p), refcount_p(refcount_p) {
			if (list_p->empty()) {
				this->list_p = nullptr;
				this->refcount_p = nullptr;
			} else {
				it = list_p->begin();
				(*refcount_p)++;
			}
		}

		ObjIterator(const RTLIL::ObjIterator<T> &other) {
			it = other.it;
			list_p = other.list_p;
			refcount_p = other.refcount_p;
			if (refcount_p)
				(*refcount_p)++;
		}

		ObjIterator &operator=(const RTLIL::ObjIterator<T> &other) {
			if (refcount_p)
				(*refcount_p)--;
			it = other.it;
			list_p = other.list_p;
			refcount_p = other.refcount_p;
			if (refcount_p)
				(*refcount_p)++;
			return *this;
		}

		~ObjIterator() {
			if (refcount_p)
				(*refcount_p)--;
		}

		inline T operator*() const {
			log_assert(list_p != nullptr);
			return it->second;
		}

		inline bool operator!=(const RTLIL::ObjIterator<T> &other) const {
			if (list_p == nullptr || other.list_p == nullptr)
				return list_p != other.list_p;
			return it != other.it;
		}


		inline bool operator==(const RTLIL::ObjIterator<T> &other) const {
			return !(*this != other);
		}

		inline ObjIterator<T>& operator++() {
			log_assert(list_p != nullptr);
			if (++it == list_p->end()) {
				(*refcount_p)--;
				list_p = nullptr;
				refcount_p = nullptr;
			}
			return *this;
		}

		inline ObjIterator<T>& operator+=(int amt) {
			log_assert(list_p != nullptr);
			it += amt;
			if (it == list_p->end()) {
				(*refcount_p)--;
				list_p = nullptr;
				refcount_p = nullptr;
			}
			return *this;
		}

		inline ObjIterator<T> operator+(int amt) {
			log_assert(list_p != nullptr);
			ObjIterator<T> new_obj(*this);
			new_obj.it += amt;
			if (new_obj.it == list_p->end()) {
				(*(new_obj.refcount_p))--;
				new_obj.list_p = nullptr;
				new_obj.refcount_p = nullptr;
			}
			return new_obj;
		}

		inline const ObjIterator<T> operator++(int) {
			ObjIterator<T> result(*this);
			++(*this);
			return result;
		}
	};

	template<typename T>
	struct ObjRange
	{
		dict<RTLIL::IdString, T> *list_p;
		int *refcount_p;

		ObjRange(decltype(list_p) list_p, int *refcount_p) : list_p(list_p), refcount_p(refcount_p) { }
		RTLIL::ObjIterator<T> begin() { return RTLIL::ObjIterator<T>(list_p, refcount_p); }
		RTLIL::ObjIterator<T> end() { return RTLIL::ObjIterator<T>(); }

		size_t size() const {
			return list_p->size();
		}

		operator pool<T>() const {
			pool<T> result;
			for (auto &it : *list_p)
				result.insert(it.second);
			return result;
		}

		operator std::vector<T>() const {
			std::vector<T> result;
			result.reserve(list_p->size());
			for (auto &it : *list_p)
				result.push_back(it.second);
			return result;
		}

		pool<T> to_pool() const { return *this; }
		std::vector<T> to_vector() const { return *this; }
	};
};

struct RTLIL::Const
{
	int flags;
	std::vector<RTLIL::State> bits;

	Const() : flags(RTLIL::CONST_FLAG_NONE) {}
	Const(const std::string &str);
	Const(int val, int width = 32);
	Const(RTLIL::State bit, int width = 1);
	Const(const std::vector<RTLIL::State> &bits) : bits(bits) { flags = CONST_FLAG_NONE; }
	Const(const std::vector<bool> &bits);
	Const(const RTLIL::Const &c) = default;
	RTLIL::Const &operator =(const RTLIL::Const &other) = default;

	bool operator <(const RTLIL::Const &other) const;
	bool operator ==(const RTLIL::Const &other) const;
	bool operator !=(const RTLIL::Const &other) const;

	bool as_bool() const;
	int as_int(bool is_signed = false) const;
	std::string as_string() const;
	static Const from_string(const std::string &str);

	std::string decode_string() const;

	inline int size() const { return bits.size(); }
	inline bool empty() const { return bits.empty(); }
	inline RTLIL::State &operator[](int index) { return bits.at(index); }
	inline const RTLIL::State &operator[](int index) const { return bits.at(index); }
	inline decltype(bits)::iterator begin() { return bits.begin(); }
	inline decltype(bits)::iterator end() { return bits.end(); }

	bool is_fully_zero() const;
	bool is_fully_ones() const;
	bool is_fully_def() const;
	bool is_fully_undef() const;
	bool is_fully_undef_x_only() const;
	bool is_onehot(int *pos = nullptr) const;

	inline RTLIL::Const extract(int offset, int len = 1, RTLIL::State padding = RTLIL::State::S0) const {
		RTLIL::Const ret;
		ret.bits.reserve(len);
		for (int i = offset; i < offset + len; i++)
			ret.bits.push_back(i < GetSize(bits) ? bits[i] : padding);
		return ret;
	}

	void extu(int width) {
		bits.resize(width, RTLIL::State::S0);
	}

	void exts(int width) {
		bits.resize(width, bits.empty() ? RTLIL::State::Sx : bits.back());
	}

	inline unsigned int hash() const {
		unsigned int h = mkhash_init;
		for (auto b : bits)
			h = mkhash(h, b);
		return h;
	}
};

struct RTLIL::AttrObject
{
	dict<RTLIL::IdString, RTLIL::Const> attributes;

	bool has_attribute(const RTLIL::IdString &id) const;

	void set_bool_attribute(const RTLIL::IdString &id, bool value=true);
	bool get_bool_attribute(const RTLIL::IdString &id) const;

	bool get_blackbox_attribute(bool ignore_wb=false) const {
		return get_bool_attribute(ID::blackbox) || (!ignore_wb && get_bool_attribute(ID::whitebox));
	}

	void set_string_attribute(const RTLIL::IdString& id, string value);
	string get_string_attribute(const RTLIL::IdString &id) const;

	void set_strpool_attribute(const RTLIL::IdString& id, const pool<string> &data);
	void add_strpool_attribute(const RTLIL::IdString& id, const pool<string> &data);
	pool<string> get_strpool_attribute(const RTLIL::IdString &id) const;

	void set_src_attribute(const std::string &src) {
		set_string_attribute(ID::src, src);
	}
	std::string get_src_attribute() const {
		return get_string_attribute(ID::src);
	}

	void set_hdlname_attribute(const vector<string> &hierarchy);
	vector<string> get_hdlname_attribute() const;

	void set_intvec_attribute(const RTLIL::IdString& id, const vector<int> &data);
	vector<int> get_intvec_attribute(const RTLIL::IdString &id) const;
};

struct RTLIL::SigChunk
{
	RTLIL::Wire *wire;
	std::vector<RTLIL::State> data; // only used if wire == NULL, LSB at index 0
	int width, offset;

	SigChunk() : wire(nullptr), width(0), offset(0) {}
	SigChunk(const RTLIL::Const &value) : wire(nullptr), data(value.bits), width(GetSize(data)), offset(0) {}
	SigChunk(RTLIL::Const &&value) : wire(nullptr), data(std::move(value.bits)), width(GetSize(data)), offset(0) {}
	SigChunk(RTLIL::Wire *wire) : wire(wire), width(GetSize(wire)), offset(0) {}
	SigChunk(RTLIL::Wire *wire, int offset, int width = 1) : wire(wire), width(width), offset(offset) {}
	SigChunk(const std::string &str) : SigChunk(RTLIL::Const(str)) {}
	SigChunk(int val, int width = 32) : SigChunk(RTLIL::Const(val, width)) {}
	SigChunk(RTLIL::State bit, int width = 1) : SigChunk(RTLIL::Const(bit, width)) {}
	SigChunk(const RTLIL::SigBit &bit);

	RTLIL::SigChunk extract(int offset, int length) const;
	inline int size() const { return width; }
	inline bool is_wire() const { return wire != NULL; }

	bool operator <(const RTLIL::SigChunk &other) const;
	bool operator ==(const RTLIL::SigChunk &other) const;
	bool operator !=(const RTLIL::SigChunk &other) const;
};

struct RTLIL::SigBit
{
	RTLIL::Wire *wire;
	union {
		RTLIL::State data; // used if wire == NULL
		int offset;        // used if wire != NULL
	};

	SigBit();
	SigBit(RTLIL::State bit);
	explicit SigBit(bool bit);
	SigBit(RTLIL::Wire *wire);
	SigBit(RTLIL::Wire *wire, int offset);
	SigBit(const RTLIL::SigChunk &chunk);
	SigBit(const RTLIL::SigChunk &chunk, int index);
	SigBit(const RTLIL::SigSpec &sig);
	SigBit(const RTLIL::SigBit &sigbit) = default;
	RTLIL::SigBit &operator =(const RTLIL::SigBit &other) = default;

	inline bool is_wire() const { return wire != NULL; }

	bool operator <(const RTLIL::SigBit &other) const;
	bool operator ==(const RTLIL::SigBit &other) const;
	bool operator !=(const RTLIL::SigBit &other) const;
	unsigned int hash() const;
};

struct RTLIL::SigSpecIterator
{
	typedef std::input_iterator_tag iterator_category;
	typedef RTLIL::SigBit value_type;
	typedef ptrdiff_t difference_type;
	typedef RTLIL::SigBit* pointer;
	typedef RTLIL::SigBit& reference;

	RTLIL::SigSpec *sig_p;
	int index;

	inline RTLIL::SigBit &operator*() const;
	inline bool operator!=(const RTLIL::SigSpecIterator &other) const { return index != other.index; }
	inline bool operator==(const RTLIL::SigSpecIterator &other) const { return index == other.index; }
	inline void operator++() { index++; }
};

struct RTLIL::SigSpecConstIterator
{
	typedef std::input_iterator_tag iterator_category;
	typedef RTLIL::SigBit value_type;
	typedef ptrdiff_t difference_type;
	typedef RTLIL::SigBit* pointer;
	typedef RTLIL::SigBit& reference;

	const RTLIL::SigSpec *sig_p;
	int index;

	inline const RTLIL::SigBit &operator*() const;
	inline bool operator!=(const RTLIL::SigSpecConstIterator &other) const { return index != other.index; }
	inline bool operator==(const RTLIL::SigSpecIterator &other) const { return index == other.index; }
	inline void operator++() { index++; }
};

struct RTLIL::SigSpec
{
private:
	int width_;
	unsigned long hash_;
	std::vector<RTLIL::SigChunk> chunks_; // LSB at index 0
	std::vector<RTLIL::SigBit> bits_; // LSB at index 0

	void pack() const;
	void unpack() const;
	void updhash() const;

	inline bool packed() const {
		return bits_.empty();
	}

	inline void inline_unpack() const {
		if (!chunks_.empty())
			unpack();
	}

	// Only used by Module::remove(const pool<Wire*> &wires)
	// but cannot be more specific as it isn't yet declared
	friend struct RTLIL::Module;

public:
	SigSpec() : width_(0), hash_(0) {}
	SigSpec(std::initializer_list<RTLIL::SigSpec> parts);

	SigSpec(const RTLIL::Const &value);
	SigSpec(RTLIL::Const &&value);
	SigSpec(const RTLIL::SigChunk &chunk);
	SigSpec(RTLIL::SigChunk &&chunk);
	SigSpec(RTLIL::Wire *wire);
	SigSpec(RTLIL::Wire *wire, int offset, int width = 1);
	SigSpec(const std::string &str);
	SigSpec(int val, int width = 32);
	SigSpec(RTLIL::State bit, int width = 1);
	SigSpec(const RTLIL::SigBit &bit, int width = 1);
	SigSpec(const std::vector<RTLIL::SigChunk> &chunks);
	SigSpec(const std::vector<RTLIL::SigBit> &bits);
	SigSpec(const pool<RTLIL::SigBit> &bits);
	SigSpec(const std::set<RTLIL::SigBit> &bits);
	explicit SigSpec(bool bit);

	size_t get_hash() const {
		if (!hash_) hash();
		return hash_;
	}

	inline const std::vector<RTLIL::SigChunk> &chunks() const { pack(); return chunks_; }
	inline const std::vector<RTLIL::SigBit> &bits() const { inline_unpack(); return bits_; }

	inline int size() const { return width_; }
	inline bool empty() const { return width_ == 0; }

	inline RTLIL::SigBit &operator[](int index) { inline_unpack(); return bits_.at(index); }
	inline const RTLIL::SigBit &operator[](int index) const { inline_unpack(); return bits_.at(index); }

	inline RTLIL::SigSpecIterator begin() { RTLIL::SigSpecIterator it; it.sig_p = this; it.index = 0; return it; }
	inline RTLIL::SigSpecIterator end() { RTLIL::SigSpecIterator it; it.sig_p = this; it.index = width_; return it; }

	inline RTLIL::SigSpecConstIterator begin() const { RTLIL::SigSpecConstIterator it; it.sig_p = this; it.index = 0; return it; }
	inline RTLIL::SigSpecConstIterator end() const { RTLIL::SigSpecConstIterator it; it.sig_p = this; it.index = width_; return it; }

	void sort();
	void sort_and_unify();

	void replace(const RTLIL::SigSpec &pattern, const RTLIL::SigSpec &with);
	void replace(const RTLIL::SigSpec &pattern, const RTLIL::SigSpec &with, RTLIL::SigSpec *other) const;

	void replace(const dict<RTLIL::SigBit, RTLIL::SigBit> &rules);
	void replace(const dict<RTLIL::SigBit, RTLIL::SigBit> &rules, RTLIL::SigSpec *other) const;

	void replace(const std::map<RTLIL::SigBit, RTLIL::SigBit> &rules);
	void replace(const std::map<RTLIL::SigBit, RTLIL::SigBit> &rules, RTLIL::SigSpec *other) const;

	void replace(int offset, const RTLIL::SigSpec &with);

	void remove(const RTLIL::SigSpec &pattern);
	void remove(const RTLIL::SigSpec &pattern, RTLIL::SigSpec *other) const;
	void remove2(const RTLIL::SigSpec &pattern, RTLIL::SigSpec *other);

	void remove(const pool<RTLIL::SigBit> &pattern);
	void remove(const pool<RTLIL::SigBit> &pattern, RTLIL::SigSpec *other) const;
	void remove2(const pool<RTLIL::SigBit> &pattern, RTLIL::SigSpec *other);
	void remove2(const std::set<RTLIL::SigBit> &pattern, RTLIL::SigSpec *other);
	void remove2(const pool<RTLIL::Wire*> &pattern, RTLIL::SigSpec *other);

	void remove(int offset, int length = 1);
	void remove_const();

	RTLIL::SigSpec extract(const RTLIL::SigSpec &pattern, const RTLIL::SigSpec *other = NULL) const;
	RTLIL::SigSpec extract(const pool<RTLIL::SigBit> &pattern, const RTLIL::SigSpec *other = NULL) const;
	RTLIL::SigSpec extract(int offset, int length = 1) const;
	RTLIL::SigSpec extract_end(int offset) const { return extract(offset, width_ - offset); }

	RTLIL::SigBit lsb() const { log_assert(width_); return (*this)[0]; };
	RTLIL::SigBit msb() const { log_assert(width_); return (*this)[width_ - 1]; };

	void append(const RTLIL::SigSpec &signal);
	inline void append(Wire *wire) { append(RTLIL::SigSpec(wire)); }
	inline void append(const RTLIL::SigChunk &chunk) { append(RTLIL::SigSpec(chunk)); }
	inline void append(const RTLIL::Const &const_) { append(RTLIL::SigSpec(const_)); }

	void append(const RTLIL::SigBit &bit);
	inline void append(RTLIL::State state) { append(RTLIL::SigBit(state)); }
	inline void append(bool bool_) { append(RTLIL::SigBit(bool_)); }

	void extend_u0(int width, bool is_signed = false);

	RTLIL::SigSpec repeat(int num) const;

	void reverse() { inline_unpack(); std::reverse(bits_.begin(), bits_.end()); }

	bool operator <(const RTLIL::SigSpec &other) const;
	bool operator ==(const RTLIL::SigSpec &other) const;
	inline bool operator !=(const RTLIL::SigSpec &other) const { return !(*this == other); }

	bool is_wire() const;
	bool is_chunk() const;
	inline bool is_bit() const { return width_ == 1; }

	bool is_fully_const() const;
	bool is_fully_zero() const;
	bool is_fully_ones() const;
	bool is_fully_def() const;
	bool is_fully_undef() const;
	bool has_const() const;
	bool has_marked_bits() const;
	bool is_onehot(int *pos = nullptr) const;

	bool as_bool() const;
	int as_int(bool is_signed = false) const;
	std::string as_string() const;
	RTLIL::Const as_const() const;
	RTLIL::Wire *as_wire() const;
	RTLIL::SigChunk as_chunk() const;
	RTLIL::SigBit as_bit() const;

	bool match(const char* pattern) const;

	std::set<RTLIL::SigBit> to_sigbit_set() const;
	pool<RTLIL::SigBit> to_sigbit_pool() const;
	std::vector<RTLIL::SigBit> to_sigbit_vector() const;
	std::map<RTLIL::SigBit, RTLIL::SigBit> to_sigbit_map(const RTLIL::SigSpec &other) const;
	dict<RTLIL::SigBit, RTLIL::SigBit> to_sigbit_dict(const RTLIL::SigSpec &other) const;

	static bool parse(RTLIL::SigSpec &sig, RTLIL::Module *module, std::string str);
	static bool parse_sel(RTLIL::SigSpec &sig, RTLIL::Design *design, RTLIL::Module *module, std::string str);
	static bool parse_rhs(const RTLIL::SigSpec &lhs, RTLIL::SigSpec &sig, RTLIL::Module *module, std::string str);

	operator std::vector<RTLIL::SigChunk>() const { return chunks(); }
	operator std::vector<RTLIL::SigBit>() const { return bits(); }
	const RTLIL::SigBit &at(int offset, const RTLIL::SigBit &defval) { return offset < width_ ? (*this)[offset] : defval; }

	unsigned int hash() const { if (!hash_) updhash(); return hash_; };

#ifndef NDEBUG
	void check(Module *mod = nullptr) const;
#else
	void check(Module *mod = nullptr) const { (void)mod; }
#endif
};

struct RTLIL::Selection
{
	bool full_selection;
	pool<RTLIL::IdString> selected_modules;
	dict<RTLIL::IdString, pool<RTLIL::IdString>> selected_members;

	Selection(bool full = true) : full_selection(full) { }

	bool selected_module(const RTLIL::IdString &mod_name) const;
	bool selected_whole_module(const RTLIL::IdString &mod_name) const;
	bool selected_member(const RTLIL::IdString &mod_name, const RTLIL::IdString &memb_name) const;
	void optimize(RTLIL::Design *design);

	template<typename T1> void select(T1 *module) {
		if (!full_selection && selected_modules.count(module->name) == 0) {
			selected_modules.insert(module->name);
			selected_members.erase(module->name);
		}
	}

	template<typename T1, typename T2> void select(T1 *module, T2 *member) {
		if (!full_selection && selected_modules.count(module->name) == 0)
			selected_members[module->name].insert(member->name);
	}

	bool empty() const {
		return !full_selection && selected_modules.empty() && selected_members.empty();
	}
};

struct RTLIL::Monitor
{
	unsigned int hashidx_;
	unsigned int hash() const { return hashidx_; }

	Monitor() {
		static unsigned int hashidx_count = 123456789;
		hashidx_count = mkhash_xorshift(hashidx_count);
		hashidx_ = hashidx_count;
	}

	virtual ~Monitor() { }
	virtual void notify_module_add(RTLIL::Module*) { }
	virtual void notify_module_del(RTLIL::Module*) { }
	virtual void notify_connect(RTLIL::Cell*, const RTLIL::IdString&, const RTLIL::SigSpec&, const RTLIL::SigSpec&) { }
	virtual void notify_connect(RTLIL::Module*, const RTLIL::SigSig&) { }
	virtual void notify_connect(RTLIL::Module*, const std::vector<RTLIL::SigSig>&) { }
	virtual void notify_blackout(RTLIL::Module*) { }
};

// Forward declaration; defined in preproc.h.
struct define_map_t;

struct RTLIL::Design
{
	unsigned int hashidx_;
	unsigned int hash() const { return hashidx_; }

	pool<RTLIL::Monitor*> monitors;
	dict<std::string, std::string> scratchpad;

	int refcount_modules_;
	dict<RTLIL::IdString, RTLIL::Module*> modules_;
	std::vector<RTLIL::Binding*> bindings_;

	std::vector<AST::AstNode*> verilog_packages, verilog_globals;
	std::unique_ptr<define_map_t> verilog_defines;

	std::vector<RTLIL::Selection> selection_stack;
	dict<RTLIL::IdString, RTLIL::Selection> selection_vars;
	std::string selected_active_module;

	Design();
	~Design();

	RTLIL::ObjRange<RTLIL::Module*> modules();
	RTLIL::Module *module(const RTLIL::IdString &name);
	const RTLIL::Module *module(const RTLIL::IdString &name) const;
	RTLIL::Module *top_module();

	bool has(const RTLIL::IdString &id) const {
		return modules_.count(id) != 0;
	}

	void add(RTLIL::Module *module);
	void add(RTLIL::Binding *binding);

	RTLIL::Module *addModule(RTLIL::IdString name);
	void remove(RTLIL::Module *module);
	void rename(RTLIL::Module *module, RTLIL::IdString new_name);

	void scratchpad_unset(const std::string &varname);

	void scratchpad_set_int(const std::string &varname, int value);
	void scratchpad_set_bool(const std::string &varname, bool value);
	void scratchpad_set_string(const std::string &varname, std::string value);

	int scratchpad_get_int(const std::string &varname, int default_value = 0) const;
	bool scratchpad_get_bool(const std::string &varname, bool default_value = false) const;
	std::string scratchpad_get_string(const std::string &varname, const std::string &default_value = std::string()) const;

	void sort();
	void check();
	void optimize();

	bool selected_module(const RTLIL::IdString &mod_name) const;
	bool selected_whole_module(const RTLIL::IdString &mod_name) const;
	bool selected_member(const RTLIL::IdString &mod_name, const RTLIL::IdString &memb_name) const;

	bool selected_module(RTLIL::Module *mod) const;
	bool selected_whole_module(RTLIL::Module *mod) const;

	RTLIL::Selection &selection() {
		return selection_stack.back();
	}

	const RTLIL::Selection &selection() const {
		return selection_stack.back();
	}

	bool full_selection() const {
		return selection_stack.back().full_selection;
	}

	template<typename T1> bool selected(T1 *module) const {
		return selected_module(module->name);
	}

	template<typename T1, typename T2> bool selected(T1 *module, T2 *member) const {
		return selected_member(module->name, member->name);
	}

	template<typename T1> void select(T1 *module) {
		if (selection_stack.size() > 0) {
			RTLIL::Selection &sel = selection_stack.back();
			sel.select(module);
		}
	}

	template<typename T1, typename T2> void select(T1 *module, T2 *member) {
		if (selection_stack.size() > 0) {
			RTLIL::Selection &sel = selection_stack.back();
			sel.select(module, member);
		}
	}


	std::vector<RTLIL::Module*> selected_modules() const;
	std::vector<RTLIL::Module*> selected_whole_modules() const;
	std::vector<RTLIL::Module*> selected_whole_modules_warn(bool include_wb = false) const;
#ifdef WITH_PYTHON
	static std::map<unsigned int, RTLIL::Design*> *get_all_designs(void);
#endif
};

struct RTLIL::Module : public RTLIL::AttrObject
{
	unsigned int hashidx_;
	unsigned int hash() const { return hashidx_; }

protected:
	void add(RTLIL::Wire *wire);
	void add(RTLIL::Cell *cell);
	void add(RTLIL::Process *process);

public:
	RTLIL::Design *design;
	pool<RTLIL::Monitor*> monitors;

	int refcount_wires_;
	int refcount_cells_;

	dict<RTLIL::IdString, RTLIL::Wire*> wires_;
	dict<RTLIL::IdString, RTLIL::Cell*> cells_;

	std::vector<RTLIL::SigSig>   connections_;
	std::vector<RTLIL::Binding*> bindings_;

	RTLIL::IdString name;
	idict<RTLIL::IdString> avail_parameters;
	dict<RTLIL::IdString, RTLIL::Const> parameter_default_values;
	dict<RTLIL::IdString, RTLIL::Memory*> memories;
	dict<RTLIL::IdString, RTLIL::Process*> processes;

	Module();
	virtual ~Module();
	virtual RTLIL::IdString derive(RTLIL::Design *design, const dict<RTLIL::IdString, RTLIL::Const> &parameters, bool mayfail = false);
	virtual RTLIL::IdString derive(RTLIL::Design *design, const dict<RTLIL::IdString, RTLIL::Const> &parameters, const dict<RTLIL::IdString, RTLIL::Module*> &interfaces, const dict<RTLIL::IdString, RTLIL::IdString> &modports, bool mayfail = false);
	virtual size_t count_id(const RTLIL::IdString& id);
	virtual void expand_interfaces(RTLIL::Design *design, const dict<RTLIL::IdString, RTLIL::Module *> &local_interfaces);
	virtual bool reprocess_if_necessary(RTLIL::Design *design);

	virtual void sort();
	virtual void check();
	virtual void optimize();
	virtual void makeblackbox();

	void connect(const RTLIL::SigSig &conn);
	void connect(const RTLIL::SigSpec &lhs, const RTLIL::SigSpec &rhs);
	void new_connections(const std::vector<RTLIL::SigSig> &new_conn);
	const std::vector<RTLIL::SigSig> &connections() const;

	std::vector<RTLIL::IdString> ports;
	void fixup_ports();

	template<typename T> void rewrite_sigspecs(T &functor);
	template<typename T> void rewrite_sigspecs2(T &functor);
	void cloneInto(RTLIL::Module *new_mod) const;
	virtual RTLIL::Module *clone() const;

	bool has_memories() const;
	bool has_processes() const;

	bool has_memories_warn() const;
	bool has_processes_warn() const;

	std::vector<RTLIL::Wire*> selected_wires() const;
	std::vector<RTLIL::Cell*> selected_cells() const;

	template<typename T> bool selected(T *member) const {
		return design->selected_member(name, member->name);
	}

	RTLIL::Wire* wire(const RTLIL::IdString &id) {
		auto it = wires_.find(id);
		return it == wires_.end() ? nullptr : it->second;
	}
	RTLIL::Cell* cell(const RTLIL::IdString &id) {
		auto it = cells_.find(id);
		return it == cells_.end() ? nullptr : it->second;
	}

	const RTLIL::Wire* wire(const RTLIL::IdString &id) const{
		auto it = wires_.find(id);
		return it == wires_.end() ? nullptr : it->second;
	}
	const RTLIL::Cell* cell(const RTLIL::IdString &id) const {
		auto it = cells_.find(id);
		return it == cells_.end() ? nullptr : it->second;
	}

	RTLIL::ObjRange<RTLIL::Wire*> wires() { return RTLIL::ObjRange<RTLIL::Wire*>(&wires_, &refcount_wires_); }
	RTLIL::ObjRange<RTLIL::Cell*> cells() { return RTLIL::ObjRange<RTLIL::Cell*>(&cells_, &refcount_cells_); }

	void add(RTLIL::Binding *binding);

	// Removing wires is expensive. If you have to remove wires, remove them all at once.
	void remove(const pool<RTLIL::Wire*> &wires);
	void remove(RTLIL::Cell *cell);
	void remove(RTLIL::Process *process);

	void rename(RTLIL::Wire *wire, RTLIL::IdString new_name);
	void rename(RTLIL::Cell *cell, RTLIL::IdString new_name);
	void rename(RTLIL::IdString old_name, RTLIL::IdString new_name);

	void swap_names(RTLIL::Wire *w1, RTLIL::Wire *w2);
	void swap_names(RTLIL::Cell *c1, RTLIL::Cell *c2);

	RTLIL::IdString uniquify(RTLIL::IdString name);
	RTLIL::IdString uniquify(RTLIL::IdString name, int &index);

	RTLIL::Wire *addWire(RTLIL::IdString name, int width = 1);
	RTLIL::Wire *addWire(RTLIL::IdString name, const RTLIL::Wire *other);

	RTLIL::Cell *addCell(RTLIL::IdString name, RTLIL::IdString type);
	RTLIL::Cell *addCell(RTLIL::IdString name, const RTLIL::Cell *other);

	RTLIL::Memory *addMemory(RTLIL::IdString name, const RTLIL::Memory *other);

	RTLIL::Process *addProcess(RTLIL::IdString name);
	RTLIL::Process *addProcess(RTLIL::IdString name, const RTLIL::Process *other);

	// The add* methods create a cell and return the created cell. All signals must exist in advance.

	RTLIL::Cell* addNot (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = "");
	RTLIL::Cell* addPos (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = "");
	RTLIL::Cell* addNeg (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = "");

	RTLIL::Cell* addAnd  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = "");
	RTLIL::Cell* addOr   (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = "");
	RTLIL::Cell* addXor  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = "");
	RTLIL::Cell* addXnor (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = "");

	RTLIL::Cell* addReduceAnd  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = "");
	RTLIL::Cell* addReduceOr   (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = "");
	RTLIL::Cell* addReduceXor  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = "");
	RTLIL::Cell* addReduceXnor (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = "");
	RTLIL::Cell* addReduceBool (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = "");

	RTLIL::Cell* addShl    (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = "");
	RTLIL::Cell* addShr    (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = "");
	RTLIL::Cell* addSshl   (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = "");
	RTLIL::Cell* addSshr   (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = "");
	RTLIL::Cell* addShift  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = "");
	RTLIL::Cell* addShiftx (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = "");

	RTLIL::Cell* addLt  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = "");
	RTLIL::Cell* addLe  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = "");
	RTLIL::Cell* addEq  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = "");
	RTLIL::Cell* addNe  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = "");
	RTLIL::Cell* addEqx (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = "");
	RTLIL::Cell* addNex (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = "");
	RTLIL::Cell* addGe  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = "");
	RTLIL::Cell* addGt  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = "");

	RTLIL::Cell* addAdd (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = "");
	RTLIL::Cell* addSub (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = "");
	RTLIL::Cell* addMul (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = "");
	// truncating division
	RTLIL::Cell* addDiv (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = "");
	// truncating modulo
	RTLIL::Cell* addMod (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = "");
	RTLIL::Cell* addDivFloor (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = "");
	RTLIL::Cell* addModFloor (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = "");
	RTLIL::Cell* addPow (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool a_signed = false, bool b_signed = false, const std::string &src = "");

	RTLIL::Cell* addFa (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_c, const RTLIL::SigSpec &sig_x, const RTLIL::SigSpec &sig_y, const std::string &src = "");

	RTLIL::Cell* addLogicNot (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = "");
	RTLIL::Cell* addLogicAnd (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = "");
	RTLIL::Cell* addLogicOr  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = "");

	RTLIL::Cell* addMux  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_s, const RTLIL::SigSpec &sig_y, const std::string &src = "");
	RTLIL::Cell* addPmux (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_s, const RTLIL::SigSpec &sig_y, const std::string &src = "");
	RTLIL::Cell* addBmux (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_s, const RTLIL::SigSpec &sig_y, const std::string &src = "");
	RTLIL::Cell* addDemux (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_s, const RTLIL::SigSpec &sig_y, const std::string &src = "");

	RTLIL::Cell* addBweqx  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, const std::string &src = "");
	RTLIL::Cell* addBwmux  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_s, const RTLIL::SigSpec &sig_y, const std::string &src = "");

	RTLIL::Cell* addSlice  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_y, RTLIL::Const offset, const std::string &src = "");
	RTLIL::Cell* addConcat (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, const std::string &src = "");
	RTLIL::Cell* addLut    (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_y, RTLIL::Const lut, const std::string &src = "");
	RTLIL::Cell* addTribuf (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_en, const RTLIL::SigSpec &sig_y, const std::string &src = "");
	RTLIL::Cell* addAssert (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_en, const std::string &src = "");
	RTLIL::Cell* addAssume (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_en, const std::string &src = "");
	RTLIL::Cell* addLive   (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_en, const std::string &src = "");
	RTLIL::Cell* addFair   (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_en, const std::string &src = "");
	RTLIL::Cell* addCover  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_en, const std::string &src = "");
	RTLIL::Cell* addEquiv  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, const std::string &src = "");

	RTLIL::Cell* addSr    (RTLIL::IdString name, const RTLIL::SigSpec &sig_set, const RTLIL::SigSpec &sig_clr, const RTLIL::SigSpec &sig_q, bool set_polarity = true, bool clr_polarity = true, const std::string &src = "");
	RTLIL::Cell* addFf    (RTLIL::IdString name, const RTLIL::SigSpec &sig_d, const RTLIL::SigSpec &sig_q, const std::string &src = "");
	RTLIL::Cell* addDff   (RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const RTLIL::SigSpec &sig_d,   const RTLIL::SigSpec &sig_q, bool clk_polarity = true, const std::string &src = "");
	RTLIL::Cell* addDffe  (RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const RTLIL::SigSpec &sig_en,  const RTLIL::SigSpec &sig_d, const RTLIL::SigSpec &sig_q, bool clk_polarity = true, bool en_polarity = true, const std::string &src = "");
	RTLIL::Cell* addDffsr (RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const RTLIL::SigSpec &sig_set, const RTLIL::SigSpec &sig_clr, RTLIL::SigSpec sig_d, const RTLIL::SigSpec &sig_q, bool clk_polarity = true, bool set_polarity = true, bool clr_polarity = true, const std::string &src = "");
	RTLIL::Cell* addDffsre (RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const RTLIL::SigSpec &sig_en, const RTLIL::SigSpec &sig_set, const RTLIL::SigSpec &sig_clr, RTLIL::SigSpec sig_d, const RTLIL::SigSpec &sig_q, bool clk_polarity = true, bool en_polarity = true, bool set_polarity = true, bool clr_polarity = true, const std::string &src = "");
	RTLIL::Cell* addAdff (RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const RTLIL::SigSpec &sig_arst, const RTLIL::SigSpec &sig_d, const RTLIL::SigSpec &sig_q, RTLIL::Const arst_value, bool clk_polarity = true, bool arst_polarity = true, const std::string &src = "");
	RTLIL::Cell* addAdffe (RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const RTLIL::SigSpec &sig_en, const RTLIL::SigSpec &sig_arst,  const RTLIL::SigSpec &sig_d, const RTLIL::SigSpec &sig_q, RTLIL::Const arst_value, bool clk_polarity = true, bool en_polarity = true, bool arst_polarity = true, const std::string &src = "");
	RTLIL::Cell* addAldff (RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const RTLIL::SigSpec &sig_aload, const RTLIL::SigSpec &sig_d, const RTLIL::SigSpec &sig_q, const RTLIL::SigSpec &sig_ad, bool clk_polarity = true, bool aload_polarity = true, const std::string &src = "");
	RTLIL::Cell* addAldffe (RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const RTLIL::SigSpec &sig_en, const RTLIL::SigSpec &sig_aload,  const RTLIL::SigSpec &sig_d, const RTLIL::SigSpec &sig_q, const RTLIL::SigSpec &sig_ad, bool clk_polarity = true, bool en_polarity = true, bool aload_polarity = true, const std::string &src = "");
	RTLIL::Cell* addSdff (RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const RTLIL::SigSpec &sig_srst, const RTLIL::SigSpec &sig_d, const RTLIL::SigSpec &sig_q, RTLIL::Const srst_value, bool clk_polarity = true, bool srst_polarity = true, const std::string &src = "");
	RTLIL::Cell* addSdffe (RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const RTLIL::SigSpec &sig_en, const RTLIL::SigSpec &sig_srst,  const RTLIL::SigSpec &sig_d, const RTLIL::SigSpec &sig_q, RTLIL::Const srst_value, bool clk_polarity = true, bool en_polarity = true, bool srst_polarity = true, const std::string &src = "");
	RTLIL::Cell* addSdffce (RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const RTLIL::SigSpec &sig_en, const RTLIL::SigSpec &sig_srst, const RTLIL::SigSpec &sig_d, const RTLIL::SigSpec &sig_q, RTLIL::Const srst_value, bool clk_polarity = true, bool en_polarity = true, bool srst_polarity = true, const std::string &src = "");
	RTLIL::Cell* addDlatch (RTLIL::IdString name, const RTLIL::SigSpec &sig_en, const RTLIL::SigSpec &sig_d, const RTLIL::SigSpec &sig_q, bool en_polarity = true, const std::string &src = "");
	RTLIL::Cell* addAdlatch (RTLIL::IdString name, const RTLIL::SigSpec &sig_en, const RTLIL::SigSpec &sig_arst, const RTLIL::SigSpec &sig_d, const RTLIL::SigSpec &sig_q, RTLIL::Const arst_value, bool en_polarity = true, bool arst_polarity = true, const std::string &src = "");
	RTLIL::Cell* addDlatchsr (RTLIL::IdString name, const RTLIL::SigSpec &sig_en, const RTLIL::SigSpec &sig_set, const RTLIL::SigSpec &sig_clr, RTLIL::SigSpec sig_d, const RTLIL::SigSpec &sig_q, bool en_polarity = true, bool set_polarity = true, bool clr_polarity = true, const std::string &src = "");

	RTLIL::Cell* addBufGate    (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_y, const std::string &src = "");
	RTLIL::Cell* addNotGate    (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_y, const std::string &src = "");
	RTLIL::Cell* addAndGate    (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const RTLIL::SigBit &sig_y, const std::string &src = "");
	RTLIL::Cell* addNandGate   (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const RTLIL::SigBit &sig_y, const std::string &src = "");
	RTLIL::Cell* addOrGate     (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const RTLIL::SigBit &sig_y, const std::string &src = "");
	RTLIL::Cell* addNorGate    (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const RTLIL::SigBit &sig_y, const std::string &src = "");
	RTLIL::Cell* addXorGate    (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const RTLIL::SigBit &sig_y, const std::string &src = "");
	RTLIL::Cell* addXnorGate   (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const RTLIL::SigBit &sig_y, const std::string &src = "");
	RTLIL::Cell* addAndnotGate (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const RTLIL::SigBit &sig_y, const std::string &src = "");
	RTLIL::Cell* addOrnotGate  (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const RTLIL::SigBit &sig_y, const std::string &src = "");
	RTLIL::Cell* addMuxGate    (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const RTLIL::SigBit &sig_s, const RTLIL::SigBit &sig_y, const std::string &src = "");
	RTLIL::Cell* addNmuxGate   (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const RTLIL::SigBit &sig_s, const RTLIL::SigBit &sig_y, const std::string &src = "");
	RTLIL::Cell* addAoi3Gate   (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const RTLIL::SigBit &sig_c, const RTLIL::SigBit &sig_y, const std::string &src = "");
	RTLIL::Cell* addOai3Gate   (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const RTLIL::SigBit &sig_c, const RTLIL::SigBit &sig_y, const std::string &src = "");
	RTLIL::Cell* addAoi4Gate   (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const RTLIL::SigBit &sig_c, const RTLIL::SigBit &sig_d, const RTLIL::SigBit &sig_y, const std::string &src = "");
	RTLIL::Cell* addOai4Gate   (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const RTLIL::SigBit &sig_c, const RTLIL::SigBit &sig_d, const RTLIL::SigBit &sig_y, const std::string &src = "");

	RTLIL::Cell* addSrGate     (RTLIL::IdString name, const RTLIL::SigSpec &sig_set, const RTLIL::SigSpec &sig_clr,
			const RTLIL::SigSpec &sig_q, bool set_polarity = true, bool clr_polarity = true, const std::string &src = "");
	RTLIL::Cell* addFfGate     (RTLIL::IdString name, const RTLIL::SigSpec &sig_d, const RTLIL::SigSpec &sig_q, const std::string &src = "");
	RTLIL::Cell* addDffGate    (RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const RTLIL::SigSpec &sig_d, const RTLIL::SigSpec &sig_q, bool clk_polarity = true, const std::string &src = "");
	RTLIL::Cell* addDffeGate   (RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const RTLIL::SigSpec &sig_en, const RTLIL::SigSpec &sig_d, const RTLIL::SigSpec &sig_q, bool clk_polarity = true, bool en_polarity = true, const std::string &src = "");
	RTLIL::Cell* addDffsrGate  (RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const RTLIL::SigSpec &sig_set, const RTLIL::SigSpec &sig_clr,
			RTLIL::SigSpec sig_d, const RTLIL::SigSpec &sig_q, bool clk_polarity = true, bool set_polarity = true, bool clr_polarity = true, const std::string &src = "");
	RTLIL::Cell* addDffsreGate (RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const RTLIL::SigSpec &sig_en, const RTLIL::SigSpec &sig_set, const RTLIL::SigSpec &sig_clr,
			RTLIL::SigSpec sig_d, const RTLIL::SigSpec &sig_q, bool clk_polarity = true, bool en_polarity = true, bool set_polarity = true, bool clr_polarity = true, const std::string &src = "");
	RTLIL::Cell* addAdffGate   (RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const RTLIL::SigSpec &sig_arst, const RTLIL::SigSpec &sig_d, const RTLIL::SigSpec &sig_q,
			bool arst_value = false, bool clk_polarity = true, bool arst_polarity = true, const std::string &src = "");
	RTLIL::Cell* addAdffeGate  (RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const RTLIL::SigSpec &sig_en, const RTLIL::SigSpec &sig_arst, const RTLIL::SigSpec &sig_d, const RTLIL::SigSpec &sig_q,
			bool arst_value = false, bool clk_polarity = true, bool en_polarity = true, bool arst_polarity = true, const std::string &src = "");
	RTLIL::Cell* addAldffGate   (RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const RTLIL::SigSpec &sig_aload, const RTLIL::SigSpec &sig_d, const RTLIL::SigSpec &sig_q,
			const RTLIL::SigSpec &sig_ad, bool clk_polarity = true, bool aload_polarity = true, const std::string &src = "");
	RTLIL::Cell* addAldffeGate  (RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const RTLIL::SigSpec &sig_en, const RTLIL::SigSpec &sig_aload, const RTLIL::SigSpec &sig_d, const RTLIL::SigSpec &sig_q,
			const RTLIL::SigSpec &sig_ad, bool clk_polarity = true, bool en_polarity = true, bool aload_polarity = true, const std::string &src = "");
	RTLIL::Cell* addSdffGate   (RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const RTLIL::SigSpec &sig_srst, const RTLIL::SigSpec &sig_d, const RTLIL::SigSpec &sig_q,
			bool srst_value = false, bool clk_polarity = true, bool srst_polarity = true, const std::string &src = "");
	RTLIL::Cell* addSdffeGate  (RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const RTLIL::SigSpec &sig_en, const RTLIL::SigSpec &sig_srst, const RTLIL::SigSpec &sig_d, const RTLIL::SigSpec &sig_q,
			bool srst_value = false, bool clk_polarity = true, bool en_polarity = true, bool srst_polarity = true, const std::string &src = "");
	RTLIL::Cell* addSdffceGate (RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const RTLIL::SigSpec &sig_en, const RTLIL::SigSpec &sig_srst, const RTLIL::SigSpec &sig_d, const RTLIL::SigSpec &sig_q,
			bool srst_value = false, bool clk_polarity = true, bool en_polarity = true, bool srst_polarity = true, const std::string &src = "");
	RTLIL::Cell* addDlatchGate (RTLIL::IdString name, const RTLIL::SigSpec &sig_en, const RTLIL::SigSpec &sig_d, const RTLIL::SigSpec &sig_q, bool en_polarity = true, const std::string &src = "");
	RTLIL::Cell* addAdlatchGate(RTLIL::IdString name, const RTLIL::SigSpec &sig_en, const RTLIL::SigSpec &sig_arst, const RTLIL::SigSpec &sig_d, const RTLIL::SigSpec &sig_q,
			bool arst_value = false, bool en_polarity = true, bool arst_polarity = true, const std::string &src = "");
	RTLIL::Cell* addDlatchsrGate  (RTLIL::IdString name, const RTLIL::SigSpec &sig_en, const RTLIL::SigSpec &sig_set, const RTLIL::SigSpec &sig_clr,
			RTLIL::SigSpec sig_d, const RTLIL::SigSpec &sig_q, bool en_polarity = true, bool set_polarity = true, bool clr_polarity = true, const std::string &src = "");

	RTLIL::Cell* addAnyinit(RTLIL::IdString name, const RTLIL::SigSpec &sig_d, const RTLIL::SigSpec &sig_q, const std::string &src = "");

	// The methods without the add* prefix create a cell and an output signal. They return the newly created output signal.

	RTLIL::SigSpec Not (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, bool is_signed = false, const std::string &src = "");
	RTLIL::SigSpec Pos (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, bool is_signed = false, const std::string &src = "");
	RTLIL::SigSpec Neg (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, bool is_signed = false, const std::string &src = "");

	RTLIL::SigSpec And  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = "");
	RTLIL::SigSpec Or   (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = "");
	RTLIL::SigSpec Xor  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = "");
	RTLIL::SigSpec Xnor (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = "");

	RTLIL::SigSpec ReduceAnd  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, bool is_signed = false, const std::string &src = "");
	RTLIL::SigSpec ReduceOr   (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, bool is_signed = false, const std::string &src = "");
	RTLIL::SigSpec ReduceXor  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, bool is_signed = false, const std::string &src = "");
	RTLIL::SigSpec ReduceXnor (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, bool is_signed = false, const std::string &src = "");
	RTLIL::SigSpec ReduceBool (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, bool is_signed = false, const std::string &src = "");

	RTLIL::SigSpec Shl    (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = "");
	RTLIL::SigSpec Shr    (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = "");
	RTLIL::SigSpec Sshl   (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = "");
	RTLIL::SigSpec Sshr   (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = "");
	RTLIL::SigSpec Shift  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = "");
	RTLIL::SigSpec Shiftx (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = "");

	RTLIL::SigSpec Lt  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = "");
	RTLIL::SigSpec Le  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = "");
	RTLIL::SigSpec Eq  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = "");
	RTLIL::SigSpec Ne  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = "");
	RTLIL::SigSpec Eqx (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = "");
	RTLIL::SigSpec Nex (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = "");
	RTLIL::SigSpec Ge  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = "");
	RTLIL::SigSpec Gt  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = "");

	RTLIL::SigSpec Add (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = "");
	RTLIL::SigSpec Sub (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = "");
	RTLIL::SigSpec Mul (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = "");
	// truncating division
	RTLIL::SigSpec Div (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = "");
	// truncating modulo
	RTLIL::SigSpec Mod (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = "");
	RTLIL::SigSpec DivFloor (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = "");
	RTLIL::SigSpec ModFloor (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = "");
	RTLIL::SigSpec Pow (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool a_signed = false, bool b_signed = false, const std::string &src = "");

	RTLIL::SigSpec LogicNot (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, bool is_signed = false, const std::string &src = "");
	RTLIL::SigSpec LogicAnd (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = "");
	RTLIL::SigSpec LogicOr  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = "");

	RTLIL::SigSpec Mux      (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_s, const std::string &src = "");
	RTLIL::SigSpec Pmux     (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_s, const std::string &src = "");
	RTLIL::SigSpec Bmux     (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_s, const std::string &src = "");
	RTLIL::SigSpec Demux     (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_s, const std::string &src = "");

	RTLIL::SigSpec Bweqx      (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const std::string &src = "");
	RTLIL::SigSpec Bwmux      (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_s, const std::string &src = "");

	RTLIL::SigBit BufGate    (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const std::string &src = "");
	RTLIL::SigBit NotGate    (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const std::string &src = "");
	RTLIL::SigBit AndGate    (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const std::string &src = "");
	RTLIL::SigBit NandGate   (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const std::string &src = "");
	RTLIL::SigBit OrGate     (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const std::string &src = "");
	RTLIL::SigBit NorGate    (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const std::string &src = "");
	RTLIL::SigBit XorGate    (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const std::string &src = "");
	RTLIL::SigBit XnorGate   (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const std::string &src = "");
	RTLIL::SigBit AndnotGate (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const std::string &src = "");
	RTLIL::SigBit OrnotGate  (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const std::string &src = "");
	RTLIL::SigBit MuxGate    (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const RTLIL::SigBit &sig_s, const std::string &src = "");
	RTLIL::SigBit NmuxGate   (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const RTLIL::SigBit &sig_s, const std::string &src = "");
	RTLIL::SigBit Aoi3Gate   (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const RTLIL::SigBit &sig_c, const std::string &src = "");
	RTLIL::SigBit Oai3Gate   (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const RTLIL::SigBit &sig_c, const std::string &src = "");
	RTLIL::SigBit Aoi4Gate   (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const RTLIL::SigBit &sig_c, const RTLIL::SigBit &sig_d, const std::string &src = "");
	RTLIL::SigBit Oai4Gate   (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const RTLIL::SigBit &sig_c, const RTLIL::SigBit &sig_d, const std::string &src = "");

	RTLIL::SigSpec Anyconst  (RTLIL::IdString name, int width = 1, const std::string &src = "");
	RTLIL::SigSpec Anyseq    (RTLIL::IdString name, int width = 1, const std::string &src = "");
	RTLIL::SigSpec Allconst  (RTLIL::IdString name, int width = 1, const std::string &src = "");
	RTLIL::SigSpec Allseq    (RTLIL::IdString name, int width = 1, const std::string &src = "");
	RTLIL::SigSpec Initstate (RTLIL::IdString name, const std::string &src = "");

	RTLIL::SigSpec SetTag          (RTLIL::IdString name, const std::string &tag, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_s, const RTLIL::SigSpec &sig_c, const std::string &src = "");
	RTLIL::Cell*   addSetTag       (RTLIL::IdString name, const std::string &tag, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_s, const RTLIL::SigSpec &sig_c, const RTLIL::SigSpec &sig_y, const std::string &src = "");
	RTLIL::SigSpec GetTag          (RTLIL::IdString name, const std::string &tag, const RTLIL::SigSpec &sig_a, const std::string &src = "");
	RTLIL::Cell*   addOverwriteTag (RTLIL::IdString name, const std::string &tag, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_s, const RTLIL::SigSpec &sig_c, const std::string &src = "");
	RTLIL::SigSpec OriginalTag     (RTLIL::IdString name, const std::string &tag, const RTLIL::SigSpec &sig_a, const std::string &src = "");
	RTLIL::SigSpec FutureFF        (RTLIL::IdString name, const RTLIL::SigSpec &sig_e, const std::string &src = "");

#ifdef WITH_PYTHON
	static std::map<unsigned int, RTLIL::Module*> *get_all_modules(void);
#endif
};

struct RTLIL::Wire : public RTLIL::AttrObject
{
	unsigned int hashidx_;
	unsigned int hash() const { return hashidx_; }

protected:
	// use module->addWire() and module->remove() to create or destroy wires
	friend struct RTLIL::Module;
	Wire();
	~Wire();

public:
	// do not simply copy wires
	Wire(RTLIL::Wire &other) = delete;
	void operator=(RTLIL::Wire &other) = delete;

	RTLIL::Module *module;
	RTLIL::IdString name;
	int width, start_offset, port_id;
	bool port_input, port_output, upto, is_signed;

#ifdef WITH_PYTHON
	static std::map<unsigned int, RTLIL::Wire*> *get_all_wires(void);
#endif
};

inline int GetSize(RTLIL::Wire *wire) {
	return wire->width;
}

struct RTLIL::Memory : public RTLIL::AttrObject
{
	unsigned int hashidx_;
	unsigned int hash() const { return hashidx_; }

	Memory();

	RTLIL::IdString name;
	int width, start_offset, size;
#ifdef WITH_PYTHON
	~Memory();
	static std::map<unsigned int, RTLIL::Memory*> *get_all_memorys(void);
#endif
};

struct RTLIL::Cell : public RTLIL::AttrObject
{
	unsigned int hashidx_;
	unsigned int hash() const { return hashidx_; }

protected:
	// use module->addCell() and module->remove() to create or destroy cells
	friend struct RTLIL::Module;
	Cell();
	~Cell();

public:
	// do not simply copy cells
	Cell(RTLIL::Cell &other) = delete;
	void operator=(RTLIL::Cell &other) = delete;

	RTLIL::Module *module;
	RTLIL::IdString name;
	RTLIL::IdString type;
	dict<RTLIL::IdString, RTLIL::SigSpec> connections_;
	dict<RTLIL::IdString, RTLIL::Const> parameters;

	// access cell ports
	bool hasPort(const RTLIL::IdString &portname) const;
	void unsetPort(const RTLIL::IdString &portname);
	void setPort(const RTLIL::IdString &portname, RTLIL::SigSpec signal);
	const RTLIL::SigSpec &getPort(const RTLIL::IdString &portname) const;
	const dict<RTLIL::IdString, RTLIL::SigSpec> &connections() const;

	// information about cell ports
	bool known() const;
	bool input(const RTLIL::IdString &portname) const;
	bool output(const RTLIL::IdString &portname) const;

	// access cell parameters
	bool hasParam(const RTLIL::IdString &paramname) const;
	void unsetParam(const RTLIL::IdString &paramname);
	void setParam(const RTLIL::IdString &paramname, RTLIL::Const value);
	const RTLIL::Const &getParam(const RTLIL::IdString &paramname) const;

	void sort();
	void check();
	void fixup_parameters(bool set_a_signed = false, bool set_b_signed = false);

	bool has_keep_attr() const {
		return get_bool_attribute(ID::keep) || (module && module->design && module->design->module(type) &&
				module->design->module(type)->get_bool_attribute(ID::keep));
	}

	template<typename T> void rewrite_sigspecs(T &functor);
	template<typename T> void rewrite_sigspecs2(T &functor);

#ifdef WITH_PYTHON
	static std::map<unsigned int, RTLIL::Cell*> *get_all_cells(void);
#endif

	bool has_memid() const;
	bool is_mem_cell() const;
};

struct RTLIL::CaseRule : public RTLIL::AttrObject
{
	std::vector<RTLIL::SigSpec> compare;
	std::vector<RTLIL::SigSig> actions;
	std::vector<RTLIL::SwitchRule*> switches;

	~CaseRule();

	bool empty() const;

	template<typename T> void rewrite_sigspecs(T &functor);
	template<typename T> void rewrite_sigspecs2(T &functor);
	RTLIL::CaseRule *clone() const;
};

struct RTLIL::SwitchRule : public RTLIL::AttrObject
{
	RTLIL::SigSpec signal;
	std::vector<RTLIL::CaseRule*> cases;

	~SwitchRule();

	bool empty() const;

	template<typename T> void rewrite_sigspecs(T &functor);
	template<typename T> void rewrite_sigspecs2(T &functor);
	RTLIL::SwitchRule *clone() const;
};

struct RTLIL::MemWriteAction : RTLIL::AttrObject
{
	RTLIL::IdString memid;
	RTLIL::SigSpec address;
	RTLIL::SigSpec data;
	RTLIL::SigSpec enable;
	RTLIL::Const priority_mask;
};

struct RTLIL::SyncRule
{
	RTLIL::SyncType type;
	RTLIL::SigSpec signal;
	std::vector<RTLIL::SigSig> actions;
	std::vector<RTLIL::MemWriteAction> mem_write_actions;

	template<typename T> void rewrite_sigspecs(T &functor);
	template<typename T> void rewrite_sigspecs2(T &functor);
	RTLIL::SyncRule *clone() const;
};

struct RTLIL::Process : public RTLIL::AttrObject
{
	unsigned int hashidx_;
	unsigned int hash() const { return hashidx_; }

protected:
	// use module->addProcess() and module->remove() to create or destroy processes
	friend struct RTLIL::Module;
	Process();
	~Process();

public:
	RTLIL::IdString name;
	RTLIL::Module *module;
	RTLIL::CaseRule root_case;
	std::vector<RTLIL::SyncRule*> syncs;

	template<typename T> void rewrite_sigspecs(T &functor);
	template<typename T> void rewrite_sigspecs2(T &functor);
	RTLIL::Process *clone() const;
};


inline RTLIL::SigBit::SigBit() : wire(NULL), data(RTLIL::State::S0) { }
inline RTLIL::SigBit::SigBit(RTLIL::State bit) : wire(NULL), data(bit) { }
inline RTLIL::SigBit::SigBit(bool bit) : wire(NULL), data(bit ? State::S1 : State::S0) { }
inline RTLIL::SigBit::SigBit(RTLIL::Wire *wire) : wire(wire), offset(0) { log_assert(wire && wire->width == 1); }
inline RTLIL::SigBit::SigBit(RTLIL::Wire *wire, int offset) : wire(wire), offset(offset) { log_assert(wire != nullptr); }
inline RTLIL::SigBit::SigBit(const RTLIL::SigChunk &chunk) : wire(chunk.wire) { log_assert(chunk.width == 1); if (wire) offset = chunk.offset; else data = chunk.data[0]; }
inline RTLIL::SigBit::SigBit(const RTLIL::SigChunk &chunk, int index) : wire(chunk.wire) { if (wire) offset = chunk.offset + index; else data = chunk.data[index]; }

inline bool RTLIL::SigBit::operator<(const RTLIL::SigBit &other) const {
	if (wire == other.wire)
		return wire ? (offset < other.offset) : (data < other.data);
	if (wire != nullptr && other.wire != nullptr)
		return wire->name < other.wire->name;
	return (wire != nullptr) < (other.wire != nullptr);
}

inline bool RTLIL::SigBit::operator==(const RTLIL::SigBit &other) const {
	return (wire == other.wire) && (wire ? (offset == other.offset) : (data == other.data));
}

inline bool RTLIL::SigBit::operator!=(const RTLIL::SigBit &other) const {
	return (wire != other.wire) || (wire ? (offset != other.offset) : (data != other.data));
}

inline unsigned int RTLIL::SigBit::hash() const {
	if (wire)
		return mkhash_add(wire->name.hash(), offset);
	return data;
}

inline RTLIL::SigBit &RTLIL::SigSpecIterator::operator*() const {
	return (*sig_p)[index];
}

inline const RTLIL::SigBit &RTLIL::SigSpecConstIterator::operator*() const {
	return (*sig_p)[index];
}

inline RTLIL::SigBit::SigBit(const RTLIL::SigSpec &sig) {
	log_assert(sig.size() == 1 && sig.chunks().size() == 1);
	*this = SigBit(sig.chunks().front());
}

template<typename T>
void RTLIL::Module::rewrite_sigspecs(T &functor)
{
	for (auto &it : cells_)
		it.second->rewrite_sigspecs(functor);
	for (auto &it : processes)
		it.second->rewrite_sigspecs(functor);
	for (auto &it : connections_) {
		functor(it.first);
		functor(it.second);
	}
}

template<typename T>
void RTLIL::Module::rewrite_sigspecs2(T &functor)
{
	for (auto &it : cells_)
		it.second->rewrite_sigspecs2(functor);
	for (auto &it : processes)
		it.second->rewrite_sigspecs2(functor);
	for (auto &it : connections_) {
		functor(it.first, it.second);
	}
}

template<typename T>
void RTLIL::Cell::rewrite_sigspecs(T &functor) {
	for (auto &it : connections_)
		functor(it.second);
}

template<typename T>
void RTLIL::Cell::rewrite_sigspecs2(T &functor) {
	for (auto &it : connections_)
		functor(it.second);
}

template<typename T>
void RTLIL::CaseRule::rewrite_sigspecs(T &functor) {
	for (auto &it : compare)
		functor(it);
	for (auto &it : actions) {
		functor(it.first);
		functor(it.second);
	}
	for (auto it : switches)
		it->rewrite_sigspecs(functor);
}

template<typename T>
void RTLIL::CaseRule::rewrite_sigspecs2(T &functor) {
	for (auto &it : compare)
		functor(it);
	for (auto &it : actions) {
		functor(it.first, it.second);
	}
	for (auto it : switches)
		it->rewrite_sigspecs2(functor);
}

template<typename T>
void RTLIL::SwitchRule::rewrite_sigspecs(T &functor)
{
	functor(signal);
	for (auto it : cases)
		it->rewrite_sigspecs(functor);
}

template<typename T>
void RTLIL::SwitchRule::rewrite_sigspecs2(T &functor)
{
	functor(signal);
	for (auto it : cases)
		it->rewrite_sigspecs2(functor);
}

template<typename T>
void RTLIL::SyncRule::rewrite_sigspecs(T &functor)
{
	functor(signal);
	for (auto &it : actions) {
		functor(it.first);
		functor(it.second);
	}
	for (auto &it : mem_write_actions) {
		functor(it.address);
		functor(it.data);
		functor(it.enable);
	}
}

template<typename T>
void RTLIL::SyncRule::rewrite_sigspecs2(T &functor)
{
	functor(signal);
	for (auto &it : actions) {
		functor(it.first, it.second);
	}
	for (auto &it : mem_write_actions) {
		functor(it.address);
		functor(it.data);
		functor(it.enable);
	}
}

template<typename T>
void RTLIL::Process::rewrite_sigspecs(T &functor)
{
	root_case.rewrite_sigspecs(functor);
	for (auto it : syncs)
		it->rewrite_sigspecs(functor);
}

template<typename T>
void RTLIL::Process::rewrite_sigspecs2(T &functor)
{
	root_case.rewrite_sigspecs2(functor);
	for (auto it : syncs)
		it->rewrite_sigspecs2(functor);
}

YOSYS_NAMESPACE_END

#endif
`,"satgen.h":`/* -*- c++ -*-
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef SATGEN_H
#define SATGEN_H

#include "kernel/rtlil.h"
#include "kernel/sigtools.h"
#include "kernel/celltypes.h"
#include "kernel/macc.h"

#include "libs/ezsat/ezminisat.h"

YOSYS_NAMESPACE_BEGIN

// defined in kernel/register.cc
extern struct SatSolver *yosys_satsolver_list;
extern struct SatSolver *yosys_satsolver;

struct SatSolver
{
	string name;
	SatSolver *next;
	virtual ezSAT *create() = 0;

	SatSolver(string name) : name(name) {
		next = yosys_satsolver_list;
		yosys_satsolver_list = this;
	}

	virtual ~SatSolver() {
		auto p = &yosys_satsolver_list;
		while (*p) {
			if (*p == this)
				*p = next;
			else
				p = &(*p)->next;
		}
		if (yosys_satsolver == this)
			yosys_satsolver = yosys_satsolver_list;
	}
};

struct ezSatPtr : public std::unique_ptr<ezSAT> {
	ezSatPtr() : unique_ptr<ezSAT>(yosys_satsolver->create()) { }
};

struct SatGen
{
	ezSAT *ez;
	SigMap *sigmap;
	std::string prefix;
	SigPool initial_state;
	std::map<std::string, RTLIL::SigSpec> asserts_a, asserts_en;
	std::map<std::string, RTLIL::SigSpec> assumes_a, assumes_en;
	std::map<std::string, std::map<RTLIL::SigBit, int>> imported_signals;
	std::map<std::pair<std::string, int>, bool> initstates;
	bool ignore_div_by_zero;
	bool model_undef;
	bool def_formal = false;

	SatGen(ezSAT *ez, SigMap *sigmap, std::string prefix = std::string()) :
			ez(ez), sigmap(sigmap), prefix(prefix), ignore_div_by_zero(false), model_undef(false)
	{
	}

	void setContext(SigMap *sigmap, std::string prefix = std::string())
	{
		this->sigmap = sigmap;
		this->prefix = prefix;
	}

	std::vector<int> importSigSpecWorker(RTLIL::SigSpec sig, std::string &pf, bool undef_mode, bool dup_undef)
	{
		log_assert(!undef_mode || model_undef);
		sigmap->apply(sig);

		std::vector<int> vec;
		vec.reserve(GetSize(sig));

		for (auto &bit : sig)
			if (bit.wire == NULL) {
				if (model_undef && dup_undef && bit == RTLIL::State::Sx)
					vec.push_back(ez->frozen_literal());
				else
					vec.push_back(bit == (undef_mode ? RTLIL::State::Sx : RTLIL::State::S1) ? ez->CONST_TRUE : ez->CONST_FALSE);
			} else {
				std::string name = pf + (bit.wire->width == 1 ? stringf("%s", log_id(bit.wire)) : stringf("%s [%d]", log_id(bit.wire->name), bit.offset));
				vec.push_back(ez->frozen_literal(name));
				imported_signals[pf][bit] = vec.back();
			}
		return vec;
	}

	std::vector<int> importSigSpec(RTLIL::SigSpec sig, int timestep = -1)
	{
		log_assert(timestep != 0);
		std::string pf = prefix + (timestep == -1 ? "" : stringf("@%d:", timestep));
		return importSigSpecWorker(sig, pf, false, false);
	}

	std::vector<int> importDefSigSpec(RTLIL::SigSpec sig, int timestep = -1)
	{
		log_assert(timestep != 0);
		std::string pf = prefix + (timestep == -1 ? "" : stringf("@%d:", timestep));
		return importSigSpecWorker(sig, pf, false, true);
	}

	std::vector<int> importUndefSigSpec(RTLIL::SigSpec sig, int timestep = -1)
	{
		log_assert(timestep != 0);
		std::string pf = "undef:" + prefix + (timestep == -1 ? "" : stringf("@%d:", timestep));
		return importSigSpecWorker(sig, pf, true, false);
	}

	int importSigBit(RTLIL::SigBit bit, int timestep = -1)
	{
		log_assert(timestep != 0);
		std::string pf = prefix + (timestep == -1 ? "" : stringf("@%d:", timestep));
		return importSigSpecWorker(bit, pf, false, false).front();
	}

	int importDefSigBit(RTLIL::SigBit bit, int timestep = -1)
	{
		log_assert(timestep != 0);
		std::string pf = prefix + (timestep == -1 ? "" : stringf("@%d:", timestep));
		return importSigSpecWorker(bit, pf, false, true).front();
	}

	int importUndefSigBit(RTLIL::SigBit bit, int timestep = -1)
	{
		log_assert(timestep != 0);
		std::string pf = "undef:" + prefix + (timestep == -1 ? "" : stringf("@%d:", timestep));
		return importSigSpecWorker(bit, pf, true, false).front();
	}

	bool importedSigBit(RTLIL::SigBit bit, int timestep = -1)
	{
		log_assert(timestep != 0);
		std::string pf = prefix + (timestep == -1 ? "" : stringf("@%d:", timestep));
		return imported_signals[pf].count(bit) != 0;
	}

	void getAsserts(RTLIL::SigSpec &sig_a, RTLIL::SigSpec &sig_en, int timestep = -1)
	{
		std::string pf = prefix + (timestep == -1 ? "" : stringf("@%d:", timestep));
		sig_a = asserts_a[pf];
		sig_en = asserts_en[pf];
	}

	void getAssumes(RTLIL::SigSpec &sig_a, RTLIL::SigSpec &sig_en, int timestep = -1)
	{
		std::string pf = prefix + (timestep == -1 ? "" : stringf("@%d:", timestep));
		sig_a = assumes_a[pf];
		sig_en = assumes_en[pf];
	}

	int importAsserts(int timestep = -1)
	{
		std::vector<int> check_bits, enable_bits;
		std::string pf = prefix + (timestep == -1 ? "" : stringf("@%d:", timestep));
		if (model_undef) {
			check_bits = ez->vec_and(ez->vec_not(importUndefSigSpec(asserts_a[pf], timestep)), importDefSigSpec(asserts_a[pf], timestep));
			enable_bits = ez->vec_and(ez->vec_not(importUndefSigSpec(asserts_en[pf], timestep)), importDefSigSpec(asserts_en[pf], timestep));
		} else {
			check_bits = importDefSigSpec(asserts_a[pf], timestep);
			enable_bits = importDefSigSpec(asserts_en[pf], timestep);
		}
		return ez->vec_reduce_and(ez->vec_or(check_bits, ez->vec_not(enable_bits)));
	}

	int importAssumes(int timestep = -1)
	{
		std::vector<int> check_bits, enable_bits;
		std::string pf = prefix + (timestep == -1 ? "" : stringf("@%d:", timestep));
		if (model_undef) {
			check_bits = ez->vec_and(ez->vec_not(importUndefSigSpec(assumes_a[pf], timestep)), importDefSigSpec(assumes_a[pf], timestep));
			enable_bits = ez->vec_and(ez->vec_not(importUndefSigSpec(assumes_en[pf], timestep)), importDefSigSpec(assumes_en[pf], timestep));
		} else {
			check_bits = importDefSigSpec(assumes_a[pf], timestep);
			enable_bits = importDefSigSpec(assumes_en[pf], timestep);
		}
		return ez->vec_reduce_and(ez->vec_or(check_bits, ez->vec_not(enable_bits)));
	}

	int signals_eq(RTLIL::SigSpec lhs, RTLIL::SigSpec rhs, int timestep_lhs = -1, int timestep_rhs = -1)
	{
		if (timestep_rhs < 0)
			timestep_rhs = timestep_lhs;

		log_assert(lhs.size() == rhs.size());

		std::vector<int> vec_lhs = importSigSpec(lhs, timestep_lhs);
		std::vector<int> vec_rhs = importSigSpec(rhs, timestep_rhs);

		if (!model_undef)
			return ez->vec_eq(vec_lhs, vec_rhs);

		std::vector<int> undef_lhs = importUndefSigSpec(lhs, timestep_lhs);
		std::vector<int> undef_rhs = importUndefSigSpec(rhs, timestep_rhs);

		std::vector<int> eq_bits;
		for (int i = 0; i < lhs.size(); i++)
			eq_bits.push_back(ez->AND(ez->IFF(undef_lhs.at(i), undef_rhs.at(i)),
					ez->IFF(ez->OR(vec_lhs.at(i), undef_lhs.at(i)), ez->OR(vec_rhs.at(i), undef_rhs.at(i)))));
		return ez->expression(ezSAT::OpAnd, eq_bits);
	}

	void extendSignalWidth(std::vector<int> &vec_a, std::vector<int> &vec_b, RTLIL::Cell *cell, size_t y_width = 0, bool forced_signed = false)
	{
		bool is_signed = forced_signed;
		if (!forced_signed && cell->parameters.count(ID::A_SIGNED) > 0 && cell->parameters.count(ID::B_SIGNED) > 0)
			is_signed = cell->parameters[ID::A_SIGNED].as_bool() && cell->parameters[ID::B_SIGNED].as_bool();
		while (vec_a.size() < vec_b.size() || vec_a.size() < y_width)
			vec_a.push_back(is_signed && vec_a.size() > 0 ? vec_a.back() : ez->CONST_FALSE);
		while (vec_b.size() < vec_a.size() || vec_b.size() < y_width)
			vec_b.push_back(is_signed && vec_b.size() > 0 ? vec_b.back() : ez->CONST_FALSE);
	}

	void extendSignalWidth(std::vector<int> &vec_a, std::vector<int> &vec_b, std::vector<int> &vec_y, RTLIL::Cell *cell, bool forced_signed = false)
	{
		extendSignalWidth(vec_a, vec_b, cell, vec_y.size(), forced_signed);
		while (vec_y.size() < vec_a.size())
			vec_y.push_back(ez->literal());
	}

	void extendSignalWidthUnary(std::vector<int> &vec_a, std::vector<int> &vec_y, RTLIL::Cell *cell, bool forced_signed = false)
	{
		bool is_signed = forced_signed || (cell->parameters.count(ID::A_SIGNED) > 0 && cell->parameters[ID::A_SIGNED].as_bool());
		while (vec_a.size() < vec_y.size())
			vec_a.push_back(is_signed && vec_a.size() > 0 ? vec_a.back() : ez->CONST_FALSE);
		while (vec_y.size() < vec_a.size())
			vec_y.push_back(ez->literal());
	}

	void undefGating(std::vector<int> &vec_y, std::vector<int> &vec_yy, std::vector<int> &vec_undef)
	{
		log_assert(model_undef);
		log_assert(vec_y.size() == vec_yy.size());
		if (vec_y.size() > vec_undef.size()) {
			std::vector<int> trunc_y(vec_y.begin(), vec_y.begin() + vec_undef.size());
			std::vector<int> trunc_yy(vec_yy.begin(), vec_yy.begin() + vec_undef.size());
			ez->assume(ez->expression(ezSAT::OpAnd, ez->vec_or(vec_undef, ez->vec_iff(trunc_y, trunc_yy))));
		} else {
			log_assert(vec_y.size() == vec_undef.size());
			ez->assume(ez->expression(ezSAT::OpAnd, ez->vec_or(vec_undef, ez->vec_iff(vec_y, vec_yy))));
		}
	}

	std::pair<std::vector<int>, std::vector<int>> mux(int s, int undef_s, const std::vector<int> &a, const std::vector<int> &undef_a, const std::vector<int> &b, const std::vector<int> &undef_b) {
		std::vector<int> res;
		std::vector<int> undef_res;
		res = ez->vec_ite(s, b, a);
		if (model_undef) {
			std::vector<int> unequal_ab = ez->vec_not(ez->vec_iff(a, b));
			std::vector<int> undef_ab = ez->vec_or(unequal_ab, ez->vec_or(undef_a, undef_b));
			undef_res = ez->vec_ite(undef_s, undef_ab, ez->vec_ite(s, undef_b, undef_a));
		}
		return std::make_pair(res, undef_res);
	}

	void undefGating(int y, int yy, int undef)
	{
		ez->assume(ez->OR(undef, ez->IFF(y, yy)));
	}

	void setInitState(int timestep)
	{
		auto key = make_pair(prefix, timestep);
		log_assert(initstates.count(key) == 0 || initstates.at(key) == true);
		initstates[key] = true;
	}

	bool importCell(RTLIL::Cell *cell, int timestep = -1);
};

YOSYS_NAMESPACE_END

#endif
`,"scopeinfo.h":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2024  Jannis Harder <jix@yosyshq.com> <me@jix.one>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef SCOPEINFO_H
#define SCOPEINFO_H

#include <vector>
#include <algorithm>

#include "kernel/yosys.h"
#include "kernel/celltypes.h"

YOSYS_NAMESPACE_BEGIN

template<typename T>
class IdTree
{
public:
	struct Cursor;

protected:
	IdTree *parent = nullptr;
	IdString scope_name;
	int depth = 0;

	pool<IdString> names;
	dict<IdString, T> entries;
public: // XXX
	dict<IdString, std::unique_ptr<IdTree>> subtrees;

	template<typename P, typename T_ref>
	static Cursor do_insert(IdTree *tree, P begin, P end, T_ref &&value)
	{
		log_assert(begin != end && "path must be non-empty");
		while (true) {
			IdString name = *begin;
			++begin;
			log_assert(!name.empty());
			tree->names.insert(name);
			if (begin == end) {
				tree->entries.emplace(name, std::forward<T_ref>(value));
				return Cursor(tree, name);
			}
			auto &unique = tree->subtrees[name];
			if (!unique) {
				unique.reset(new IdTree);
				unique->scope_name = name;
				unique->parent = tree;
				unique->depth = tree->depth + 1;
			}
			tree = unique.get();
		}
	}

public:
	IdTree() = default;
	IdTree(const IdTree &) = delete;
	IdTree(IdTree &&) = delete;

	// A cursor remains valid as long as the (sub-)IdTree it points at is alive
	struct Cursor
	{
		friend class IdTree;
	protected:
	public:
		IdTree *target;
		IdString scope_name;

		Cursor() : target(nullptr) {}
		Cursor(IdTree *target, IdString scope_name) : target(target), scope_name(scope_name) {
			if (scope_name.empty())
				log_assert(target->parent == nullptr);
		}

		Cursor do_first_child() {
			IdTree *tree = nullptr;
			if (scope_name.empty()) {
				tree = target;
			} else {
				auto found = target->subtrees.find(scope_name);
				if (found != target->subtrees.end()) {
					tree = found->second.get();
				} else {
					return Cursor();
				}
			}
			if (tree->names.empty()) {
				return Cursor();
			}
			return Cursor(tree, *tree->names.begin());
		}

		Cursor do_next_sibling() {
			if (scope_name.empty())
				return Cursor();
			auto found = target->names.find(scope_name);
			if (found == target->names.end())
				return Cursor();
			++found;
			if (found == target->names.end())
				return Cursor();
			return Cursor(target, *found);
		}

		Cursor do_parent() {
			if (scope_name.empty())
				return Cursor();
			if (target->parent != nullptr)
				return Cursor(target->parent, target->scope_name);
			return Cursor(target, IdString());
		}

		Cursor do_next_preorder() {
			Cursor current = *this;
			Cursor next = current.do_first_child();
			if (next.valid())
				return next;
			while (current.valid()) {
				if (next.valid())
					return next;
				next = current.do_next_sibling();
				if (next.valid())
					return next;
				current = current.do_parent();
			}
			return current;
		}

		Cursor do_child(IdString name) {
			IdTree *tree = nullptr;
			if (scope_name.empty()) {
				tree = target;
			} else {
				auto found = target->subtrees.find(scope_name);
				if (found != target->subtrees.end()) {
					tree = found->second.get();
				} else {
					return Cursor();
				}
			}
			auto found = tree->names.find(name);
			if (found == tree->names.end()) {
				return Cursor();
			}
			return Cursor(tree, *found);
		}

	public:
		bool operator==(const Cursor &other) const {
			return target == other.target && scope_name == other.scope_name;
		}
		bool operator!=(const Cursor &other) const {
			return !(*this == other);
		}

		bool valid() const {
			return target != nullptr;
		}

		int depth() const {
			log_assert(valid());
			return target->depth + !scope_name.empty();
		}

		bool is_root() const {
			return target != nullptr && scope_name.empty();
		}

		bool has_entry() const {
			log_assert(valid());
			return !scope_name.empty() && target->entries.count(scope_name);
		}

		T &entry() {
			log_assert(!scope_name.empty());
			return target->entries.at(scope_name);
		}

		void assign_path_to(std::vector<IdString> &out_path) {
			log_assert(valid());
			out_path.clear();
			if (scope_name.empty())
				return;
			out_path.push_back(scope_name);
			IdTree *current = target;
			while (current->parent) {
				out_path.push_back(current->scope_name);
				current = current->parent;
			}
			std::reverse(out_path.begin(), out_path.end());
		}

		std::vector<IdString> path() {
			std::vector<IdString> result;
			assign_path_to(result);
			return result;
		}

		std::string path_str() {
			std::string result;
			for (const auto &item : path()) {
				if (!result.empty())
					result.push_back(' ');
				result += RTLIL::unescape_id(item);
			}
			return result;
		}

		Cursor first_child() {
			log_assert(valid());
			return do_first_child();
		}

		Cursor next_preorder() {
			log_assert(valid());
			return do_next_preorder();
		}

		Cursor parent() {
			log_assert(valid());
			return do_parent();
		}

		Cursor child(IdString name) {
			log_assert(valid());
			return do_child(name);
		}

		Cursor common_ancestor(Cursor other) {
			Cursor current = *this;

			while (current != other) {
				if (!current.valid() || !other.valid())
					return Cursor();
				int delta = current.depth() - other.depth();
				if (delta >= 0)
					current = current.do_parent();
				if (delta <= 0)
					other = other.do_parent();
			}
			return current;
		}
	};

	template<typename P>
	Cursor insert(P begin, P end, const T &value) {
		return do_insert(this, begin, end, value);
	}

	template<typename P>
	Cursor insert(P begin, P end, T &&value) {
		return do_insert(this, begin, end, std::move(value));
	}

	template<typename P>
	Cursor insert(const P &path, const T &value) {
		return do_insert(this, path.begin(), path.end(), value);
	}

	template<typename P>
	Cursor insert(const P &path, T &&value) {
		return do_insert(this, path.begin(), path.end(), std::move(value));
	}

	Cursor cursor() {
		return parent ? Cursor(this->parent, this->scope_name) : Cursor(this, IdString());
	}

	template<typename P>
	Cursor cursor(P begin, P end) {
		Cursor current = cursor();
		for (; begin != end; ++begin) {
			current = current.do_child(*begin);
			if (!current.valid())
				break;
		}
		return current;
	}

	template<typename P>
	Cursor cursor(const P &path) {
		return cursor(path.begin(), path.end());
	}
};


struct ModuleItem {
	enum class Type {
		Wire,
		Cell,
	};
	Type type;
	void *ptr;

	ModuleItem(Wire *wire) : type(Type::Wire), ptr(wire) {}
	ModuleItem(Cell *cell) : type(Type::Cell), ptr(cell) {}

	bool is_wire() const { return type == Type::Wire; }
	bool is_cell() const { return type == Type::Cell; }

	Wire *wire() const { return type == Type::Wire ? static_cast<Wire *>(ptr) : nullptr; }
	Cell *cell() const { return type == Type::Cell ? static_cast<Cell *>(ptr) : nullptr; }

	bool operator==(const ModuleItem &other) const { return ptr == other.ptr && type == other.type; }
	unsigned int hash() const { return (uintptr_t)ptr; }
};

static inline void log_dump_val_worker(typename IdTree<ModuleItem>::Cursor cursor ) { log("%p %s", cursor.target, log_id(cursor.scope_name)); }

template<typename T>
static inline void log_dump_val_worker(const typename std::unique_ptr<T> &cursor ) { log("unique %p", cursor.get()); }

template<typename O>
std::vector<IdString> parse_hdlname(const O* object)
{
	std::vector<IdString> path;
	if (!object->name.isPublic())
		return path;
	for (auto const &item : object->get_hdlname_attribute())
		path.push_back("\\\\" + item);
	if (path.empty())
		path.push_back(object->name);
	return path;
}

template<typename O>
std::pair<std::vector<IdString>, IdString> parse_scopename(const O* object)
{
	std::vector<IdString> path;
	IdString trailing = object->name;
	if (object->name.isPublic()) {
		for (auto const &item : object->get_hdlname_attribute())
			path.push_back("\\\\" + item);
		if (!path.empty()) {
			trailing = path.back();
			path.pop_back();
		}
	} else {
		for (auto const &item : split_tokens(object->get_string_attribute(ID(scopename)), " "))
			path.push_back("\\\\" + item);

	}
	return {path, trailing};
}

struct ModuleHdlnameIndex {
	typedef IdTree<ModuleItem>::Cursor Cursor;

	RTLIL::Module *module;
	IdTree<ModuleItem> tree;
	dict<ModuleItem, Cursor> lookup;

	ModuleHdlnameIndex(RTLIL::Module *module) : module(module) {}

private:
	template<typename I, typename Filter>
	void index_items(I begin, I end, Filter filter);

public:
	// Index all wires and cells of the module
	void index();

	// Index all wires of the module
	void index_wires();

	// Index all cells of the module
	void index_cells();

	// Index only the $scopeinfo cells of the module.
	// This is sufficient when using \`containing_scope\`.
	void index_scopeinfo_cells();


	// Return the cursor for the containing scope of some RTLIL object (Wire/Cell/...)
	template<typename O>
	std::pair<Cursor, IdString> containing_scope(O *object) {
		auto pair = parse_scopename(object);
		return {tree.cursor(pair.first), pair.second};
	}

	// Return a vector of source locations starting from the indexed module to
	// the scope represented by the cursor. The vector alternates module and
	// module item source locations, using empty strings for missing src
	// attributes.
	std::vector<std::string> scope_sources(Cursor cursor);

	// Return a vector of source locations starting from the indexed module to
	// the passed RTLIL object (Wire/Cell/...). The vector alternates module
	// and module item source locations, using empty strings for missing src
	// attributes.
	template<typename O>
	std::vector<std::string> sources(O *object) {
		auto pair = parse_scopename(object);
		std::vector<std::string> result = scope_sources(tree.cursor(pair.first));
		result.push_back(object->get_src_attribute());
		return result;
	}
};

enum class ScopeinfoAttrs {
	Module,
	Cell,
};

// Check whether the flattened module or flattened cell corresponding to a $scopeinfo cell had a specific attribute.
bool scopeinfo_has_attribute(const RTLIL::Cell *scopeinfo, ScopeinfoAttrs attrs, const RTLIL::IdString &id);

// Get a specific attribute from the flattened module or flattened cell corresponding to a $scopeinfo cell.
RTLIL::Const scopeinfo_get_attribute(const RTLIL::Cell *scopeinfo, ScopeinfoAttrs attrs, const RTLIL::IdString &id);

// Get all attribute from the flattened module or flattened cell corresponding to a $scopeinfo cell.
dict<RTLIL::IdString, RTLIL::Const> scopeinfo_attributes(const RTLIL::Cell *scopeinfo, ScopeinfoAttrs attrs);

YOSYS_NAMESPACE_END

#endif
`,"sigtools.h":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef SIGTOOLS_H
#define SIGTOOLS_H

#include "kernel/yosys.h"

YOSYS_NAMESPACE_BEGIN

struct SigPool
{
	struct bitDef_t : public std::pair<RTLIL::Wire*, int> {
		bitDef_t() : std::pair<RTLIL::Wire*, int>(NULL, 0) { }
		bitDef_t(const RTLIL::SigBit &bit) : std::pair<RTLIL::Wire*, int>(bit.wire, bit.offset) { }
		unsigned int hash() const { return first->name.hash() + second; }
	};

	pool<bitDef_t> bits;

	void clear()
	{
		bits.clear();
	}

	void add(const RTLIL::SigSpec &sig)
	{
		for (auto &bit : sig)
			if (bit.wire != NULL)
				bits.insert(bit);
	}

	void add(const SigPool &other)
	{
		for (auto &bit : other.bits)
			bits.insert(bit);
	}

	void del(const RTLIL::SigSpec &sig)
	{
		for (auto &bit : sig)
			if (bit.wire != NULL)
				bits.erase(bit);
	}

	void del(const SigPool &other)
	{
		for (auto &bit : other.bits)
			bits.erase(bit);
	}

	void expand(const RTLIL::SigSpec &from, const RTLIL::SigSpec &to)
	{
		log_assert(GetSize(from) == GetSize(to));
		for (int i = 0; i < GetSize(from); i++) {
			bitDef_t bit_from(from[i]), bit_to(to[i]);
			if (bit_from.first != NULL && bit_to.first != NULL && bits.count(bit_from) > 0)
				bits.insert(bit_to);
		}
	}

	RTLIL::SigSpec extract(const RTLIL::SigSpec &sig) const
	{
		RTLIL::SigSpec result;
		for (auto &bit : sig)
			if (bit.wire != NULL && bits.count(bit))
				result.append(bit);
		return result;
	}

	RTLIL::SigSpec remove(const RTLIL::SigSpec &sig) const
	{
		RTLIL::SigSpec result;
		for (auto &bit : sig)
			if (bit.wire != NULL && bits.count(bit) == 0)
				result.append(bit);
		return result;
	}

	bool check(const RTLIL::SigBit &bit) const
	{
		return bit.wire != NULL && bits.count(bit);
	}

	bool check_any(const RTLIL::SigSpec &sig) const
	{
		for (auto &bit : sig)
			if (bit.wire != NULL && bits.count(bit))
				return true;
		return false;
	}

	bool check_all(const RTLIL::SigSpec &sig) const
	{
		for (auto &bit : sig)
			if (bit.wire != NULL && bits.count(bit) == 0)
				return false;
		return true;
	}

	RTLIL::SigSpec export_one() const
	{
		for (auto &bit : bits)
			return RTLIL::SigSpec(bit.first, bit.second);
		return RTLIL::SigSpec();
	}

	RTLIL::SigSpec export_all() const
	{
		pool<RTLIL::SigBit> sig;
		for (auto &bit : bits)
			sig.insert(RTLIL::SigBit(bit.first, bit.second));
		return sig;
	}

	size_t size() const
	{
		return bits.size();
	}
};

template <typename T, class Compare = void>
struct SigSet
{
	static_assert(!std::is_same<Compare,void>::value, "Default value for \`Compare' class not found for SigSet<T>. Please specify.");

	struct bitDef_t : public std::pair<RTLIL::Wire*, int> {
		bitDef_t() : std::pair<RTLIL::Wire*, int>(NULL, 0) { }
		bitDef_t(const RTLIL::SigBit &bit) : std::pair<RTLIL::Wire*, int>(bit.wire, bit.offset) { }
		unsigned int hash() const { return first->name.hash() + second; }
	};

	dict<bitDef_t, std::set<T, Compare>> bits;

	void clear()
	{
		bits.clear();
	}

	void insert(const RTLIL::SigSpec &sig, T data)
	{
		for (const auto &bit : sig)
			if (bit.wire != NULL)
				bits[bit].insert(data);
	}

	void insert(const RTLIL::SigSpec& sig, const std::set<T> &data)
	{
		for (const auto &bit : sig)
			if (bit.wire != NULL)
				bits[bit].insert(data.begin(), data.end());
	}

	void erase(const RTLIL::SigSpec& sig)
	{
		for (const auto &bit : sig)
			if (bit.wire != NULL)
				bits[bit].clear();
	}

	void erase(const RTLIL::SigSpec &sig, T data)
	{
		for (const auto &bit : sig)
			if (bit.wire != NULL)
				bits[bit].erase(data);
	}

	void erase(const RTLIL::SigSpec &sig, const std::set<T> &data)
	{
		for (const auto &bit : sig)
			if (bit.wire != NULL)
				bits[bit].erase(data.begin(), data.end());
	}

	void find(const RTLIL::SigSpec &sig, std::set<T> &result)
	{
		for (const auto &bit : sig)
			if (bit.wire != NULL) {
				auto &data = bits[bit];
				result.insert(data.begin(), data.end());
			}
	}

	void find(const RTLIL::SigSpec &sig, pool<T> &result)
	{
		for (const auto &bit : sig)
			if (bit.wire != NULL) {
				auto &data = bits[bit];
				result.insert(data.begin(), data.end());
			}
	}

	std::set<T> find(const RTLIL::SigSpec &sig)
	{
		std::set<T> result;
		find(sig, result);
		return result;
	}

	bool has(const RTLIL::SigSpec &sig)
	{
		for (auto &bit : sig)
			if (bit.wire != NULL && bits.count(bit))
				return true;
		return false;
	}
};

template<typename T>
class SigSet<T, typename std::enable_if<!std::is_pointer<T>::value>::type> : public SigSet<T, std::less<T>> {};
template<typename T>
using sort_by_name_id_guard = typename std::enable_if<std::is_same<T,RTLIL::Cell*>::value>::type;
template<typename T>
class SigSet<T, sort_by_name_id_guard<T>> : public SigSet<T, RTLIL::sort_by_name_id<typename std::remove_pointer<T>::type>> {};

struct SigMap
{
	mfp<SigBit> database;

	SigMap(RTLIL::Module *module = NULL)
	{
		if (module != NULL)
			set(module);
	}

	void swap(SigMap &other)
	{
		database.swap(other.database);
	}

	void clear()
	{
		database.clear();
	}

	void set(RTLIL::Module *module)
	{
		int bitcount = 0;
		for (auto &it : module->connections())
			bitcount += it.first.size();

		database.clear();
		database.reserve(bitcount);

		for (auto &it : module->connections())
			add(it.first, it.second);
	}

	void add(const RTLIL::SigSpec& from, const RTLIL::SigSpec& to)
	{
		log_assert(GetSize(from) == GetSize(to));

		for (int i = 0; i < GetSize(from); i++)
		{
			int bfi = database.lookup(from[i]);
			int bti = database.lookup(to[i]);

			const RTLIL::SigBit &bf = database[bfi];
			const RTLIL::SigBit &bt = database[bti];

			if (bf.wire || bt.wire)
			{
				database.imerge(bfi, bti);

				if (bf.wire == nullptr)
					database.ipromote(bfi);

				if (bt.wire == nullptr)
					database.ipromote(bti);
			}
		}
	}

	void add(const RTLIL::SigBit &bit)
	{
		const auto &b = database.find(bit);
		if (b.wire != nullptr)
			database.promote(bit);
	}

	void add(const RTLIL::SigSpec &sig)
	{
		for (const auto &bit : sig)
			add(bit);
	}

	inline void add(Wire *wire) { return add(RTLIL::SigSpec(wire)); }

	void apply(RTLIL::SigBit &bit) const
	{
		bit = database.find(bit);
	}

	void apply(RTLIL::SigSpec &sig) const
	{
		for (auto &bit : sig)
			apply(bit);
	}

	RTLIL::SigBit operator()(RTLIL::SigBit bit) const
	{
		apply(bit);
		return bit;
	}

	RTLIL::SigSpec operator()(RTLIL::SigSpec sig) const
	{
		apply(sig);
		return sig;
	}

	RTLIL::SigSpec operator()(RTLIL::Wire *wire) const
	{
		SigSpec sig(wire);
		apply(sig);
		return sig;
	}

	RTLIL::SigSpec allbits() const
	{
		RTLIL::SigSpec sig;
		for (const auto &bit : database)
			if (bit.wire != nullptr)
				sig.append(bit);
		return sig;
	}
};

YOSYS_NAMESPACE_END

#endif /* SIGTOOLS_H */
`,"timinginfo.h":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *            (C) 2020  Eddie Hung    <eddie@fpgeh.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef TIMINGINFO_H
#define TIMINGINFO_H

#include "kernel/yosys.h"

YOSYS_NAMESPACE_BEGIN

struct TimingInfo
{
	struct NameBit
	{
		RTLIL::IdString name;
		int offset;
		NameBit() : offset(0) {}
		NameBit(const RTLIL::IdString name, int offset) : name(name), offset(offset) {}
		explicit NameBit(const RTLIL::SigBit &b) : name(b.wire->name), offset(b.offset) {}
		bool operator==(const NameBit& nb) const { return nb.name == name && nb.offset == offset; }
		bool operator!=(const NameBit& nb) const { return !operator==(nb); }
		unsigned int hash() const { return mkhash_add(name.hash(), offset); }
	};
	struct BitBit
	{
		NameBit first, second;
		BitBit(const NameBit &first, const NameBit &second) : first(first), second(second) {}
		BitBit(const SigBit &first, const SigBit &second) : first(first), second(second) {}
		bool operator==(const BitBit& bb) const { return bb.first == first && bb.second == second; }
		unsigned int hash() const { return mkhash_add(first.hash(), second.hash()); }
	};

	struct ModuleTiming
	{
		dict<BitBit, int> comb;
		dict<NameBit, std::pair<int,NameBit>> arrival, required;
		bool has_inputs;
	};

	dict<RTLIL::IdString, ModuleTiming> data;

	TimingInfo()
	{
	}

	TimingInfo(RTLIL::Design *design)
	{
		setup(design);
	}

	void setup(RTLIL::Design *design)
	{
		for (auto module : design->modules()) {
			if (!module->get_blackbox_attribute())
				continue;
			setup_module(module);
		}
	}

	const ModuleTiming& setup_module(RTLIL::Module *module)
	{
		auto r = data.insert(module->name);
		log_assert(r.second);
		auto &t = r.first->second;

		for (auto cell : module->cells()) {
			if (cell->type == ID($specify2)) {
				auto en = cell->getPort(ID::EN);
				if (en.is_fully_const() && !en.as_bool())
					continue;
				auto src = cell->getPort(ID::SRC);
				auto dst = cell->getPort(ID::DST);
				for (const auto &c : src.chunks())
					if (!c.wire || !c.wire->port_input)
						log_error("Module '%s' contains specify cell '%s' where SRC '%s' is not a module input.\\n", log_id(module), log_id(cell), log_signal(src));
				for (const auto &c : dst.chunks())
					if (!c.wire || !c.wire->port_output)
						log_error("Module '%s' contains specify cell '%s' where DST '%s' is not a module output.\\n", log_id(module), log_id(cell), log_signal(dst));
				int rise_max = cell->getParam(ID::T_RISE_MAX).as_int();
				int fall_max = cell->getParam(ID::T_FALL_MAX).as_int();
				int max = std::max(rise_max,fall_max);
				if (max < 0)
					log_error("Module '%s' contains specify cell '%s' with T_{RISE,FALL}_MAX < 0.\\n", log_id(module), log_id(cell));
				if (cell->getParam(ID::FULL).as_bool()) {
					for (const auto &s : src)
						for (const auto &d : dst) {
							auto r = t.comb.insert(BitBit(s,d));
							if (!r.second)
								log_error("Module '%s' contains multiple specify cells for SRC '%s' and DST '%s'.\\n", log_id(module), log_signal(s), log_signal(d));
							r.first->second = max;
						}
				}
				else {
					log_assert(GetSize(src) == GetSize(dst));
					for (auto i = 0; i < GetSize(src); i++) {
						const auto &s = src[i];
						const auto &d = dst[i];
						auto r = t.comb.insert(BitBit(s,d));
						if (!r.second)
							log_error("Module '%s' contains multiple specify cells for SRC '%s' and DST '%s'.\\n", log_id(module), log_signal(s), log_signal(d));
						r.first->second = max;
					}
				}
			}
			else if (cell->type == ID($specify3)) {
				auto src = cell->getPort(ID::SRC).as_bit();
				auto dst = cell->getPort(ID::DST);
				if (!src.wire || !src.wire->port_input)
					log_error("Module '%s' contains specify cell '%s' where SRC '%s' is not a module input.\\n", log_id(module), log_id(cell), log_signal(src));
				for (const auto &c : dst.chunks())
					if (!c.wire->port_output)
						log_error("Module '%s' contains specify cell '%s' where DST '%s' is not a module output.\\n", log_id(module), log_id(cell), log_signal(dst));
				int rise_max = cell->getParam(ID::T_RISE_MAX).as_int();
				int fall_max = cell->getParam(ID::T_FALL_MAX).as_int();
				int max = std::max(rise_max,fall_max);
				if (max < 0) {
					log_warning("Module '%s' contains specify cell '%s' with T_{RISE,FALL}_MAX < 0 which is currently unsupported. Clamping to 0.\\n", log_id(module), log_id(cell));
					max = 0;
				}
				for (const auto &d : dst) {
					auto r = t.arrival.insert(NameBit(d));
					auto &v = r.first->second;
					if (r.second || v.first < max) {
						v.first = max;
						v.second = NameBit(src);
					}
				}
			}
			else if (cell->type == ID($specrule)) {
				IdString type = cell->getParam(ID::TYPE).decode_string();
				if (type != ID($setup) && type != ID($setuphold))
					continue;
				auto src = cell->getPort(ID::SRC);
				auto dst = cell->getPort(ID::DST).as_bit();
				for (const auto &c : src.chunks())
					if (!c.wire || !c.wire->port_input)
						log_error("Module '%s' contains specify cell '%s' where SRC '%s' is not a module input.\\n", log_id(module), log_id(cell), log_signal(src));
				if (!dst.wire || !dst.wire->port_input)
					log_error("Module '%s' contains specify cell '%s' where DST '%s' is not a module input.\\n", log_id(module), log_id(cell), log_signal(dst));
				int max = cell->getParam(ID::T_LIMIT_MAX).as_int();
				if (max < 0) {
					log_warning("Module '%s' contains specify cell '%s' with T_LIMIT_MAX < 0 which is currently unsupported. Clamping to 0.\\n", log_id(module), log_id(cell));
					max = 0;
				}
				for (const auto &s : src) {
					auto r = t.required.insert(NameBit(s));
					auto &v = r.first->second;
					if (r.second || v.first < max) {
						v.first = max;
						v.second = NameBit(dst);
					}
				}
			}
		}

		for (auto port_name : module->ports) {
			auto wire = module->wire(port_name);
			if (wire->port_input) {
				t.has_inputs = true;
				break;
			}
		}

		return t;
	}

	decltype(data)::const_iterator find(RTLIL::IdString module_name) const { return data.find(module_name); }
	decltype(data)::const_iterator end() const { return data.end(); }
	int count(RTLIL::IdString module_name) const { return data.count(module_name); }
	const ModuleTiming& at(RTLIL::IdString module_name) const { return data.at(module_name); }
};

YOSYS_NAMESPACE_END

#endif
`,"utils.h":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

// This file contains various c++ utility routines and helper classes that
// do not depend on any other components of yosys (except stuff like log_*).

#include "kernel/yosys.h"

#ifndef UTILS_H
#define UTILS_H

YOSYS_NAMESPACE_BEGIN

// ------------------------------------------------
// A map-like container, but you can save and restore the state
// ------------------------------------------------

template<typename Key, typename T, typename OPS = hash_ops<Key>>
struct stackmap
{
private:
	std::vector<dict<Key, T*, OPS>> backup_state;
	dict<Key, T, OPS> current_state;
	static T empty_tuple;

public:
	stackmap() { }
	stackmap(const dict<Key, T, OPS> &other) : current_state(other) { }

	template<typename Other>
	void operator=(const Other &other)
	{
		for (auto &it : current_state)
			if (!backup_state.empty() && backup_state.back().count(it.first) == 0)
				backup_state.back()[it.first] = new T(it.second);
		current_state.clear();

		for (auto &it : other)
			set(it.first, it.second);
	}

	bool has(const Key &k)
	{
		return current_state.count(k) != 0;
	}

	void set(const Key &k, const T &v)
	{
		if (!backup_state.empty() && backup_state.back().count(k) == 0)
			backup_state.back()[k] = current_state.count(k) ? new T(current_state.at(k)) : nullptr;
		current_state[k] = v;
	}

	void unset(const Key &k)
	{
		if (!backup_state.empty() && backup_state.back().count(k) == 0)
			backup_state.back()[k] = current_state.count(k) ? new T(current_state.at(k)) : nullptr;
		current_state.erase(k);
	}

	const T &get(const Key &k)
	{
		if (current_state.count(k) == 0)
			return empty_tuple;
		return current_state.at(k);
	}

	void reset(const Key &k)
	{
		for (int i = GetSize(backup_state)-1; i >= 0; i--)
			if (backup_state[i].count(k) != 0) {
				if (backup_state[i].at(k) == nullptr)
					current_state.erase(k);
				else
					current_state[k] = *backup_state[i].at(k);
				return;
			}
		current_state.erase(k);
	}

	const dict<Key, T, OPS> &stdmap()
	{
		return current_state;
	}

	void save()
	{
		backup_state.resize(backup_state.size()+1);
	}

	void restore()
	{
		log_assert(!backup_state.empty());
		for (auto &it : backup_state.back())
			if (it.second != nullptr) {
				current_state[it.first] = *it.second;
				delete it.second;
			} else
				current_state.erase(it.first);
		backup_state.pop_back();
	}

	~stackmap()
	{
		while (!backup_state.empty())
			restore();
	}
};


// ------------------------------------------------
// A simple class for topological sorting
// ------------------------------------------------

template <typename T, typename C = std::less<T>, typename OPS = hash_ops<T>> class TopoSort
{
      public:
	// We use this ordering of the edges in the adjacency matrix for
	// exact compatibility with an older implementation.
	struct IndirectCmp {
                IndirectCmp(const std::vector<T> &nodes) : node_cmp_(), nodes_(nodes) {}
		bool operator()(int a, int b) const
		{
                        log_assert(static_cast<size_t>(a) < nodes_.size());
			log_assert(static_cast<size_t>(b) < nodes_.size());
			return node_cmp_(nodes_[a], nodes_[b]);
		}
		const C node_cmp_;
		const std::vector<T> &nodes_;
	};

	bool analyze_loops;
	std::map<T, int, C> node_to_index;
	std::vector<std::set<int, IndirectCmp>> edges;
	std::vector<T> sorted;
	std::set<std::vector<T>> loops;

	TopoSort() : indirect_cmp(nodes)
	{
		analyze_loops = true;
		found_loops = false;
	}

	int node(T n)
	{
                auto rv = node_to_index.emplace(n, static_cast<int>(nodes.size()));
                if (rv.second) {
      	              nodes.push_back(n);
		      edges.push_back(std::set<int, IndirectCmp>(indirect_cmp));
		}
		return rv.first->second;
	}

	void edge(int l_index, int r_index) { edges[r_index].insert(l_index); }

	void edge(T left, T right) { edge(node(left), node(right)); }

	bool has_node(const T &node) { return node_to_index.find(node) != node_to_index.end(); }

	bool sort()
	{
		log_assert(GetSize(node_to_index) == GetSize(edges));
		log_assert(GetSize(nodes) == GetSize(edges));

		loops.clear();
		sorted.clear();
		found_loops = false;

		std::vector<bool> marked_cells(edges.size(), false);
		std::vector<bool> active_cells(edges.size(), false);
		std::vector<int> active_stack;
		sorted.reserve(edges.size());

		for (const auto &it : node_to_index)
			sort_worker(it.second, marked_cells, active_cells, active_stack);

		log_assert(GetSize(sorted) == GetSize(nodes));

		return !found_loops;
	}

	// Build the more expensive representation of edges for
	// a few passes that use it directly.
	std::map<T, std::set<T, C>, C> get_database()
	{
		std::map<T, std::set<T, C>, C> database;
		for (size_t i = 0; i < nodes.size(); ++i) {
			std::set<T, C> converted_edge_set;
			for (int other_node : edges[i]) {
				converted_edge_set.insert(nodes[other_node]);
			}
			database.emplace(nodes[i], converted_edge_set);
		}
		return database;
	}

      private:
	bool found_loops;
	std::vector<T> nodes;
	const IndirectCmp indirect_cmp;

	void sort_worker(const int root_index, std::vector<bool> &marked_cells, std::vector<bool> &active_cells, std::vector<int> &active_stack)
	{
		if (active_cells[root_index]) {
			found_loops = true;
			if (analyze_loops) {
				std::vector<T> loop;
				for (int i = GetSize(active_stack) - 1; i >= 0; i--) {
					const int index = active_stack[i];
					loop.push_back(nodes[index]);
					if (index == root_index)
						break;
				}
				loops.insert(loop);
			}
			return;
		}

		if (marked_cells[root_index])
			return;

		if (!edges[root_index].empty()) {
			if (analyze_loops)
				active_stack.push_back(root_index);
			active_cells[root_index] = true;

			for (int left_n : edges[root_index])
				sort_worker(left_n, marked_cells, active_cells, active_stack);

			if (analyze_loops)
				active_stack.pop_back();
			active_cells[root_index] = false;
		}

		marked_cells[root_index] = true;
		sorted.push_back(nodes[root_index]);
	}
};

YOSYS_NAMESPACE_END

#endif
`,"yosys.h":`/* -*- c++ -*-
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */


// *** NOTE TO THE READER ***
//
// Maybe you have just opened this file in the hope to learn more about the
// Yosys API. Let me congratulate you on this great decision!  ;)
//
// If you want to know how the design is represented by Yosys in the memory,
// you should read "kernel/rtlil.h".
//
// If you want to know how to register a command with Yosys, you could read
// "kernel/register.h", but it would be easier to just look at a simple
// example instead. A simple one would be "passes/cmds/log.cc".
//
// This header is very boring. It just defines some general things that
// belong nowhere else and includes the interesting headers.
//
// Find more information in the "guidelines/GettingStarted" file.


#ifndef YOSYS_H
#define YOSYS_H

#include "kernel/yosys_common.h"

#include "kernel/log.h"
#include "kernel/rtlil.h"
#include "kernel/register.h"

YOSYS_NAMESPACE_BEGIN

void yosys_setup();

#ifdef WITH_PYTHON
bool yosys_already_setup();
#endif

void yosys_shutdown();

#ifdef YOSYS_ENABLE_TCL
Tcl_Interp *yosys_get_tcl_interp();
#endif

extern RTLIL::Design *yosys_design;

RTLIL::Design *yosys_get_design();
std::string proc_self_dirname();
std::string proc_share_dirname();
std::string proc_program_prefix();
const char *create_prompt(RTLIL::Design *design, int recursion_counter);
std::vector<std::string> glob_filename(const std::string &filename_pattern);
void rewrite_filename(std::string &filename);

void run_pass(std::string command, RTLIL::Design *design = nullptr);
bool run_frontend(std::string filename, std::string command, RTLIL::Design *design = nullptr, std::string *from_to_label = nullptr);
void run_backend(std::string filename, std::string command, RTLIL::Design *design = nullptr);
void shell(RTLIL::Design *design);

// journal of all input and output files read (for "yosys -E")
extern std::set<std::string> yosys_input_files, yosys_output_files;

// from kernel/version_*.o (cc source generated from Makefile)
extern const char *yosys_version_str;

// from passes/cmds/design.cc
extern std::map<std::string, RTLIL::Design*> saved_designs;
extern std::vector<RTLIL::Design*> pushed_designs;

// from passes/cmds/pluginc.cc
extern std::map<std::string, void*> loaded_plugins;
#ifdef WITH_PYTHON
extern std::map<std::string, void*> loaded_python_plugins;
#endif
extern std::map<std::string, std::string> loaded_plugin_aliases;
void load_plugin(std::string filename, std::vector<std::string> aliases);

extern std::string yosys_share_dirname;
extern std::string yosys_abc_executable;

YOSYS_NAMESPACE_END

#endif
`,"yosys_common.h":`/* -*- c++ -*-
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef YOSYS_COMMON_H
#define YOSYS_COMMON_H

#include <map>
#include <set>
#include <tuple>
#include <vector>
#include <string>
#include <algorithm>
#include <functional>
#include <unordered_map>
#include <unordered_set>
#include <initializer_list>
#include <stdexcept>
#include <memory>
#include <cmath>
#include <cstddef>

#include <sstream>
#include <fstream>
#include <istream>
#include <ostream>
#include <iostream>

#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <stdio.h>
#include <limits.h>
#include <sys/stat.h>
#include <errno.h>

#ifdef WITH_PYTHON
#include <Python.h>
#endif

#ifndef _YOSYS_
#  error It looks like you are trying to build Yosys without the config defines set. \\
         When building Yosys with a custom make system, make sure you set all the \\
         defines the Yosys Makefile would set for your build configuration.
#endif

#ifdef YOSYS_ENABLE_TCL
#  include <tcl.h>
#  ifdef YOSYS_MXE_HACKS
extern Tcl_Command Tcl_CreateCommand(Tcl_Interp *interp, const char *cmdName, Tcl_CmdProc *proc, ClientData clientData, Tcl_CmdDeleteProc *deleteProc);
extern Tcl_Interp *Tcl_CreateInterp(void);
extern void Tcl_Preserve(ClientData data);
extern void Tcl_Release(ClientData clientData);
extern int Tcl_InterpDeleted(Tcl_Interp *interp);
extern void Tcl_DeleteInterp(Tcl_Interp *interp);
extern int Tcl_Eval(Tcl_Interp *interp, const char *script);
extern int Tcl_EvalFile(Tcl_Interp *interp, const char *fileName);
extern void Tcl_Finalize(void);
extern int Tcl_GetCommandInfo(Tcl_Interp *interp, const char *cmdName, Tcl_CmdInfo *infoPtr);
extern const char *Tcl_GetStringResult(Tcl_Interp *interp);
extern Tcl_Obj *Tcl_NewStringObj(const char *bytes, int length);
extern Tcl_Obj *Tcl_NewIntObj(int intValue);
extern Tcl_Obj *Tcl_NewListObj(int objc, Tcl_Obj *const objv[]);
extern Tcl_Obj *Tcl_ObjSetVar2(Tcl_Interp *interp, Tcl_Obj *part1Ptr, Tcl_Obj *part2Ptr, Tcl_Obj *newValuePtr, int flags);
#  endif
#  undef CONST
#  undef INLINE
#endif

#ifdef _WIN32
#  undef NOMINMAX
#  define NOMINMAX 1
#  undef YY_NO_UNISTD_H
#  define YY_NO_UNISTD_H 1

#  include <windows.h>
#  include <io.h>
#  include <direct.h>

#  define strtok_r strtok_s
#  define strdup _strdup
#  define snprintf _snprintf
#  define getcwd _getcwd
#  define mkdir _mkdir
#  define popen _popen
#  define pclose _pclose

#  ifndef __MINGW32__
#    define PATH_MAX MAX_PATH
#    define isatty _isatty
#    define fileno _fileno
#  endif

// The following defines conflict with our identifiers:
#  undef CONST
// \`wingdi.h\` defines a TRANSPARENT macro that conflicts with X(TRANSPARENT) entry in kernel/constids.inc
#  undef TRANSPARENT
#endif

#ifndef PATH_MAX
#  define PATH_MAX 4096
#endif


#define YOSYS_NAMESPACE          Yosys
#define PRIVATE_NAMESPACE_BEGIN  namespace {
#define PRIVATE_NAMESPACE_END    }
#define YOSYS_NAMESPACE_BEGIN    namespace Yosys {
#define YOSYS_NAMESPACE_END      }
#define YOSYS_NAMESPACE_PREFIX   Yosys::
#define USING_YOSYS_NAMESPACE    using namespace Yosys;

#if defined(__GNUC__) || defined(__clang__)
#  define YS_ATTRIBUTE(...) __attribute__((__VA_ARGS__))
#elif defined(_MSC_VER)
#  define YS_ATTRIBUTE(...)
#else
#  define YS_ATTRIBUTE(...)
#endif

#if defined(__GNUC__) || defined(__clang__)
#  define YS_MAYBE_UNUSED __attribute__((__unused__))
#else
#  define YS_MAYBE_UNUSED
#endif

#if __cplusplus >= 201703L
#  define YS_FALLTHROUGH [[fallthrough]];
#elif defined(__clang__)
#  define YS_FALLTHROUGH [[clang::fallthrough]];
#elif defined(__GNUC__)
#  define YS_FALLTHROUGH [[gnu::fallthrough]];
#else
#  define YS_FALLTHROUGH
#endif


YOSYS_NAMESPACE_BEGIN

// Note: All headers included in hashlib.h must be included
// outside of YOSYS_NAMESPACE before this or bad things will happen.
#ifdef HASHLIB_H
#  undef HASHLIB_H
#  include "kernel/hashlib.h"
#else
#  include "kernel/hashlib.h"
#  undef HASHLIB_H
#endif


using std::vector;
using std::string;
using std::tuple;
using std::pair;

using std::make_tuple;
using std::make_pair;
using std::get;
using std::min;
using std::max;

// A primitive shared string implementation that does not
// move its .c_str() when the object is copied or moved.
struct shared_str {
	std::shared_ptr<string> content;
	shared_str() { }
	shared_str(string s) { content = std::shared_ptr<string>(new string(s)); }
	shared_str(const char *s) { content = std::shared_ptr<string>(new string(s)); }
	const char *c_str() const { return content->c_str(); }
	const string &str() const { return *content; }
	bool operator==(const shared_str &other) const { return *content == *other.content; }
	unsigned int hash() const { return hashlib::hash_ops<std::string>::hash(*content); }
};

using hashlib::mkhash;
using hashlib::mkhash_init;
using hashlib::mkhash_add;
using hashlib::mkhash_xorshift;
using hashlib::hash_ops;
using hashlib::hash_cstr_ops;
using hashlib::hash_ptr_ops;
using hashlib::hash_obj_ops;
using hashlib::dict;
using hashlib::idict;
using hashlib::pool;
using hashlib::mfp;

namespace RTLIL {
	struct IdString;
	struct Const;
	struct SigBit;
	struct SigSpec;
	struct Wire;
	struct Cell;
	struct Memory;
	struct Process;
	struct Module;
	struct Design;
	struct Monitor;
    struct Selection;
	struct SigChunk;
	enum State : unsigned char;

	typedef std::pair<SigSpec, SigSpec> SigSig;

    namespace ID {}
}

namespace AST {
	struct AstNode;
}

using RTLIL::IdString;
using RTLIL::Const;
using RTLIL::SigBit;
using RTLIL::SigSpec;
using RTLIL::Wire;
using RTLIL::Cell;
using RTLIL::Module;
using RTLIL::Design;

using RTLIL::State;
using RTLIL::SigChunk;
using RTLIL::SigSig;

namespace hashlib {
	template<> struct hash_ops<RTLIL::Wire*> : hash_obj_ops {};
	template<> struct hash_ops<RTLIL::Cell*> : hash_obj_ops {};
	template<> struct hash_ops<RTLIL::Memory*> : hash_obj_ops {};
	template<> struct hash_ops<RTLIL::Process*> : hash_obj_ops {};
	template<> struct hash_ops<RTLIL::Module*> : hash_obj_ops {};
	template<> struct hash_ops<RTLIL::Design*> : hash_obj_ops {};
	template<> struct hash_ops<RTLIL::Monitor*> : hash_obj_ops {};
	template<> struct hash_ops<AST::AstNode*> : hash_obj_ops {};

	template<> struct hash_ops<const RTLIL::Wire*> : hash_obj_ops {};
	template<> struct hash_ops<const RTLIL::Cell*> : hash_obj_ops {};
	template<> struct hash_ops<const RTLIL::Memory*> : hash_obj_ops {};
	template<> struct hash_ops<const RTLIL::Process*> : hash_obj_ops {};
	template<> struct hash_ops<const RTLIL::Module*> : hash_obj_ops {};
	template<> struct hash_ops<const RTLIL::Design*> : hash_obj_ops {};
	template<> struct hash_ops<const RTLIL::Monitor*> : hash_obj_ops {};
	template<> struct hash_ops<const AST::AstNode*> : hash_obj_ops {};
}

void memhasher_on();
void memhasher_off();
void memhasher_do();

extern bool memhasher_active;
inline void memhasher() { if (memhasher_active) memhasher_do(); }

void yosys_banner();
int ceil_log2(int x) YS_ATTRIBUTE(const);

inline std::string vstringf(const char *fmt, va_list ap)
{
        // For the common case of strings shorter than 128, save a heap
        // allocation by using a stack allocated buffer.
        const int kBufSize = 128;
        char buf[kBufSize];
        buf[0] = '\\0';
        va_list apc;
        va_copy(apc, ap);
        int n = vsnprintf(buf, kBufSize, fmt, apc);
        va_end(apc);
        if (n < kBufSize)
          return std::string(buf);

        std::string string;
        char *str = NULL;
#if defined(_WIN32 )|| defined(__CYGWIN__)
        int sz = 2 * kBufSize, rc;
        while (1) {
		va_copy(apc, ap);
		str = (char*)realloc(str, sz);
		rc = vsnprintf(str, sz, fmt, apc);
		va_end(apc);
		if (rc >= 0 && rc < sz)
			break;
		sz *= 2;
	}
	if (str != NULL) {
		string = str;
		free(str);
	}
	return string;
#else
        if (vasprintf(&str, fmt, ap) < 0)
          str = NULL;
        if (str != NULL) {
          string = str;
          free(str);
        }
	return string;
#endif
}

std::string stringf(const char *fmt, ...) YS_ATTRIBUTE(format(printf, 1, 2));

inline std::string stringf(const char *fmt, ...)
{
	std::string string;
	va_list ap;

	va_start(ap, fmt);
	string = vstringf(fmt, ap);
	va_end(ap);

	return string;
}

int readsome(std::istream &f, char *s, int n);
std::string next_token(std::string &text, const char *sep = " \\t\\r\\n", bool long_strings = false);
std::vector<std::string> split_tokens(const std::string &text, const char *sep = " \\t\\r\\n");
bool patmatch(const char *pattern, const char *string);
#if !defined(YOSYS_DISABLE_SPAWN)
int run_command(const std::string &command, std::function<void(const std::string&)> process_line = std::function<void(const std::string&)>());
#endif
std::string get_base_tmpdir();
std::string make_temp_file(std::string template_str = get_base_tmpdir() + "/yosys_XXXXXX");
std::string make_temp_dir(std::string template_str = get_base_tmpdir() + "/yosys_XXXXXX");
bool check_file_exists(std::string filename, bool is_exec = false);
bool check_directory_exists(const std::string& dirname);
bool is_absolute_path(std::string filename);
void remove_directory(std::string dirname);
bool create_directory(const std::string& dirname);
std::string escape_filename_spaces(const std::string& filename);

template<typename T> int GetSize(const T &obj) { return obj.size(); }
inline int GetSize(RTLIL::Wire *wire);

extern int autoidx;
extern int yosys_xtrace;

RTLIL::IdString new_id(std::string file, int line, std::string func);
RTLIL::IdString new_id_suffix(std::string file, int line, std::string func, std::string suffix);

#define NEW_ID \\
	YOSYS_NAMESPACE_PREFIX new_id(__FILE__, __LINE__, __FUNCTION__)
#define NEW_ID_SUFFIX(suffix) \\
	YOSYS_NAMESPACE_PREFIX new_id_suffix(__FILE__, __LINE__, __FUNCTION__, suffix)

// Create a statically allocated IdString object, using for example ID::A or ID($add).
//
// Recipe for Converting old code that is using conversion of strings like ID::A and
// "$add" for creating IdStrings: Run below SED command on the .cc file and then use for
// example "meld foo.cc foo.cc.orig" to manually compile errors, if necessary.
//
//  sed -i.orig -r 's/"\\\\\\\\([a-zA-Z0-9_]+)"/ID(\\1)/g; s/"(\\$[a-zA-Z0-9_]+)"/ID(\\1)/g;' <filename>
//
#define ID(_id) ([]() { const char *p = "\\\\" #_id, *q = p[1] == '$' ? p+1 : p; \\
        static const YOSYS_NAMESPACE_PREFIX RTLIL::IdString id(q); return id; })()
namespace ID = RTLIL::ID;

namespace hashlib {
	template<> struct hash_ops<RTLIL::State> : hash_ops<int> {};
}


YOSYS_NAMESPACE_END

#endif
`,"yw.h":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2022  Jannis Harder <jix@yosyshq.com> <me@jix.one>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef YW_H
#define YW_H

#include "kernel/yosys.h"
#include "kernel/mem.h"

YOSYS_NAMESPACE_BEGIN

struct IdPath : public std::vector<RTLIL::IdString>
{
	template<typename... T>
	IdPath(T&&... args) : std::vector<RTLIL::IdString>(std::forward<T>(args)...) { }
	IdPath prefix() const { return {begin(), end() - !empty()}; }
	std::string str() const;

	bool has_address() const { int tmp; return get_address(tmp); };
	bool get_address(int &addr) const;

	int hash() const { return hashlib::hash_ops<std::vector<RTLIL::IdString>>::hash(*this); }
};

struct WitnessHierarchyItem {
	RTLIL::Module *module;
	RTLIL::Wire *wire = nullptr;
	RTLIL::Cell *cell = nullptr;
	Mem *mem = nullptr;

	WitnessHierarchyItem(RTLIL::Module *module, RTLIL::Wire *wire) : module(module), wire(wire) {}
	WitnessHierarchyItem(RTLIL::Module *module, RTLIL::Cell *cell) : module(module), cell(cell) {}
	WitnessHierarchyItem(RTLIL::Module *module, Mem *mem) : module(module), mem(mem) {}
};

template<typename D, typename T>
void witness_hierarchy(RTLIL::Module *module, D data, T callback);

template<class T> static std::vector<std::string> witness_path(T *obj) {
	std::vector<std::string> path;
	if (obj->name.isPublic()) {
		auto hdlname = obj->get_string_attribute(ID::hdlname);
		for (auto token : split_tokens(hdlname))
			path.push_back("\\\\" + token);
	}
	if (path.empty())
		path.push_back(obj->name.str());
	return path;
}

struct ReadWitness
{
	struct Clock {
		IdPath path;
		int offset;
		bool is_posedge = false;
		bool is_negedge = false;
	};

	struct Signal {
		IdPath path;
		int offset;
		int width;
		bool init_only;

		int bits_offset;
	};

	struct Step {
		std::string bits;
	};

	std::string filename;
	std::vector<Clock> clocks;
	std::vector<Signal> signals;
	std::vector<Step> steps;

	ReadWitness(const std::string &filename);

	RTLIL::Const get_bits(int t, int bits_offset, int width) const;
};

template<typename D, typename T>
void witness_hierarchy_recursion(IdPath &path, int hdlname_mode, RTLIL::Module *module, D data, T &callback)
{
	auto const &const_path = path;
	size_t path_size = path.size();
	for (auto wire : module->wires())
	{
		auto hdlname = hdlname_mode < 0 ? std::vector<std::string>() : wire->get_hdlname_attribute();
		for (auto item : hdlname)
			path.push_back("\\\\" + item);
		if (hdlname.size() == 1 && path.back() == wire->name)
			hdlname.clear();
		if (!hdlname.empty())
			callback(const_path, WitnessHierarchyItem(module, wire), data);
		path.resize(path_size);
		if (hdlname.empty() || hdlname_mode <= 0) {
			path.push_back(wire->name);
			callback(const_path, WitnessHierarchyItem(module, wire), data);
			path.pop_back();
		}
	}

	for (auto cell : module->cells())
	{
		Module *child = module->design->module(cell->type);
		if (child == nullptr)
			continue;

		auto hdlname = hdlname_mode < 0 ? std::vector<std::string>() : cell->get_hdlname_attribute();
		for (auto item : hdlname)
			path.push_back("\\\\" + item);
		if (hdlname.size() == 1 && path.back() == cell->name)
			hdlname.clear();
		if (!hdlname.empty()) {
			D child_data = callback(const_path, WitnessHierarchyItem(module, cell), data);
			witness_hierarchy_recursion<D, T>(path, 1, child, child_data, callback);
		}
		path.resize(path_size);
		if (hdlname.empty() || hdlname_mode <= 0) {
			path.push_back(cell->name);
			D child_data = callback(const_path, WitnessHierarchyItem(module, cell), data);
			witness_hierarchy_recursion<D, T>(path, hdlname.empty() ? hdlname_mode : -1, child, child_data, callback);
			path.pop_back();
		}
	}

	for (auto mem : Mem::get_all_memories(module)) {
		std::vector<std::string> hdlname;

		if (hdlname_mode >= 0 && mem.cell != nullptr)
			hdlname = mem.cell->get_hdlname_attribute();
		for (auto item : hdlname)
			path.push_back("\\\\" + item);
		if (hdlname.size() == 1 && path.back() == mem.cell->name)
			hdlname.clear();
		if (!hdlname.empty()) {
			callback(const_path, WitnessHierarchyItem(module, &mem), data);
		}
		path.resize(path_size);

		if (hdlname.empty() || hdlname_mode <= 0) {
			path.push_back(mem.memid);
			callback(const_path, WitnessHierarchyItem(module, &mem), data);
			path.pop_back();

			if (mem.cell != nullptr && mem.cell->name != mem.memid) {
				path.push_back(mem.cell->name);
				callback(const_path, WitnessHierarchyItem(module, &mem), data);
				path.pop_back();
			}
		}
	}
}

template<typename D, typename T>
void witness_hierarchy(RTLIL::Module *module, D data, T callback)
{
	IdPath path;
	witness_hierarchy_recursion<D, T>(path, 0, module, data, callback);
}

YOSYS_NAMESPACE_END

#endif
`},libs:{ezsat:{"ezminisat.h":`/*
 *  ezSAT -- A simple and easy to use CNF generator for SAT solvers
 *
 *  Copyright (C) 2013  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef EZMINISAT_H
#define EZMINISAT_H

#define EZMINISAT_SIMPSOLVER 1
#define EZMINISAT_VERBOSITY 0
#define EZMINISAT_INCREMENTAL 1

#include "ezsat.h"
#include <time.h>

// minisat is using limit macros and format macros in their headers that
// can be the source of some troubles when used from c++11. therefore we
// don't force ezSAT users to use minisat headers..
namespace Minisat {
	class Solver;
	class SimpSolver;
}

class ezMiniSAT : public ezSAT
{
private:
#if EZMINISAT_SIMPSOLVER
	typedef Minisat::SimpSolver Solver;
#else
	typedef Minisat::Solver Solver;
#endif
	Solver *minisatSolver;
	std::vector<int> minisatVars;
	bool foundContradiction;

#if EZMINISAT_SIMPSOLVER && EZMINISAT_INCREMENTAL
	std::set<int> cnfFrozenVars;
#endif

#ifndef _WIN32
	static ezMiniSAT *alarmHandlerThis;
	static clock_t alarmHandlerTimeout;
	static void alarmHandler(int);
#endif

public:
	ezMiniSAT();
	virtual ~ezMiniSAT();
	virtual void clear();
#if EZMINISAT_SIMPSOLVER && EZMINISAT_INCREMENTAL
	virtual void freeze(int id);
	virtual bool eliminated(int idx);
#endif
	virtual bool solver(const std::vector<int> &modelExpressions, std::vector<bool> &modelValues, const std::vector<int> &assumptions);
};

#endif
`,"ezsat.h":`/*
 *  ezSAT -- A simple and easy to use CNF generator for SAT solvers
 *
 *  Copyright (C) 2013  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef EZSAT_H
#define EZSAT_H

#include <set>
#include <map>
#include <vector>
#include <string>
#include <stdio.h>
#include <stdint.h>

class ezSAT
{
	// each token (terminal or non-terminal) is represented by an integer number
	//
	// the zero token:
	// the number zero is not used as valid token number and is used to encode
	// unused parameters for the functions.
	//
	// positive numbers are literals, with 1 = CONST_TRUE and 2 = CONST_FALSE;
	//
	// negative numbers are non-literal expressions. each expression is represented
	// by an operator id and a list of expressions (literals or non-literals).

public:
	enum OpId {
		OpNot, OpAnd, OpOr, OpXor, OpIFF, OpITE
	};

	static const int CONST_TRUE;
	static const int CONST_FALSE;

private:
	bool flag_keep_cnf;
	bool flag_non_incremental;

	bool non_incremental_solve_used_up;

	std::map<std::string, int> literalsCache;
	std::vector<std::string> literals;

	std::map<std::pair<OpId, std::vector<int>>, int> expressionsCache;
	std::vector<std::pair<OpId, std::vector<int>>> expressions;

	bool cnfConsumed;
	int cnfVariableCount, cnfClausesCount;
	std::vector<int> cnfLiteralVariables, cnfExpressionVariables;
	std::vector<std::vector<int>> cnfClauses, cnfClausesBackup;

	void add_clause(const std::vector<int> &args);
	void add_clause(const std::vector<int> &args, bool argsPolarity, int a = 0, int b = 0, int c = 0);
	void add_clause(int a, int b = 0, int c = 0);

	int bind_cnf_not(const std::vector<int> &args);
	int bind_cnf_and(const std::vector<int> &args);
	int bind_cnf_or(const std::vector<int> &args);

protected:
	void preSolverCallback();

public:
	int solverTimeout;
	bool solverTimoutStatus;

	ezSAT();
	virtual ~ezSAT();

	unsigned int statehash;
	void addhash(unsigned int);

	void keep_cnf() { flag_keep_cnf = true; }
	void non_incremental() { flag_non_incremental = true; }

	bool mode_keep_cnf() const { return flag_keep_cnf; }
	bool mode_non_incremental() const { return flag_non_incremental; }

	// manage expressions

	int value(bool val);
	int literal();
	int literal(const std::string &name);
	int frozen_literal();
	int frozen_literal(const std::string &name);
	int expression(OpId op, int a = 0, int b = 0, int c = 0, int d = 0, int e = 0, int f = 0);
	int expression(OpId op, const std::vector<int> &args);

	void lookup_literal(int id, std::string &name) const;
	const std::string &lookup_literal(int id) const;

	void lookup_expression(int id, OpId &op, std::vector<int> &args) const;
	const std::vector<int> &lookup_expression(int id, OpId &op) const;

	int parse_string(const std::string &text);
	std::string to_string(int id) const;

	int numLiterals() const { return literals.size(); }
	int numExpressions() const { return expressions.size(); }

	int eval(int id, const std::vector<int> &values) const;

	// SAT solver interface
	// If you are planning on using the solver API (and not simply create a CNF) you must use a child class
	// of ezSAT that actually implements a solver backend, such as ezMiniSAT (see ezminisat.h).

	virtual bool solver(const std::vector<int> &modelExpressions, std::vector<bool> &modelValues, const std::vector<int> &assumptions);

	bool solve(const std::vector<int> &modelExpressions, std::vector<bool> &modelValues, const std::vector<int> &assumptions) {
		return solver(modelExpressions, modelValues, assumptions);
	}

	bool solve(const std::vector<int> &modelExpressions, std::vector<bool> &modelValues, int a = 0, int b = 0, int c = 0, int d = 0, int e = 0, int f = 0) {
		std::vector<int> assumptions;
		if (a != 0) assumptions.push_back(a);
		if (b != 0) assumptions.push_back(b);
		if (c != 0) assumptions.push_back(c);
		if (d != 0) assumptions.push_back(d);
		if (e != 0) assumptions.push_back(e);
		if (f != 0) assumptions.push_back(f);
		return solver(modelExpressions, modelValues, assumptions);
	}

	bool solve(int a = 0, int b = 0, int c = 0, int d = 0, int e = 0, int f = 0) {
		std::vector<int> assumptions, modelExpressions;
		std::vector<bool> modelValues;
		if (a != 0) assumptions.push_back(a);
		if (b != 0) assumptions.push_back(b);
		if (c != 0) assumptions.push_back(c);
		if (d != 0) assumptions.push_back(d);
		if (e != 0) assumptions.push_back(e);
		if (f != 0) assumptions.push_back(f);
		return solver(modelExpressions, modelValues, assumptions);
	}

	void setSolverTimeout(int newTimeoutSeconds) {
		solverTimeout = newTimeoutSeconds;
	}

	bool getSolverTimoutStatus() {
		return solverTimoutStatus;
	}

	// manage CNF (usually only accessed by SAT solvers)

	virtual void clear();
	virtual void freeze(int id);
	virtual bool eliminated(int idx);
	void assume(int id);
	void assume(int id, int context_id) { assume(OR(id, NOT(context_id))); }
	int bind(int id, bool auto_freeze = true);
	int bound(int id) const;

	int numCnfVariables() const { return cnfVariableCount; }
	int numCnfClauses() const { return cnfClausesCount; }
	const std::vector<std::vector<int>> &cnf() const { return cnfClauses; }

	void consumeCnf();
	void consumeCnf(std::vector<std::vector<int>> &cnf);

	// use this function to get the full CNF in keep_cnf mode
	void getFullCnf(std::vector<std::vector<int>> &full_cnf) const;

	std::string cnfLiteralInfo(int idx) const;

	// simple helpers for build expressions easily

	struct _V {
		int id;
		std::string name;
		_V(int id) : id(id) { }
		_V(const char *name) : id(0), name(name) { }
		_V(const std::string &name) : id(0), name(name) { }
		int get(ezSAT *that) {
			if (name.empty())
				return id;
			return that->frozen_literal(name);
		}
	};

	int VAR(_V a) {
		return a.get(this);
	}

	int NOT(_V a) {
		return expression(OpNot, a.get(this));
	}

	int AND(_V a = 0, _V b = 0, _V c = 0, _V d = 0, _V e = 0, _V f = 0) {
		return expression(OpAnd, a.get(this), b.get(this), c.get(this), d.get(this), e.get(this), f.get(this));
	}

	int OR(_V a = 0, _V b = 0, _V c = 0, _V d = 0, _V e = 0, _V f = 0) {
		return expression(OpOr, a.get(this), b.get(this), c.get(this), d.get(this), e.get(this), f.get(this));
	}

	int XOR(_V a = 0, _V b = 0, _V c = 0, _V d = 0, _V e = 0, _V f = 0) {
		return expression(OpXor, a.get(this), b.get(this), c.get(this), d.get(this), e.get(this), f.get(this));
	}

	int IFF(_V a, _V b = 0, _V c = 0, _V d = 0, _V e = 0, _V f = 0) {
		return expression(OpIFF, a.get(this), b.get(this), c.get(this), d.get(this), e.get(this), f.get(this));
	}

	int ITE(_V a, _V b, _V c) {
		return expression(OpITE, a.get(this), b.get(this), c.get(this));
	}

	void SET(_V a, _V b) {
		assume(IFF(a.get(this), b.get(this)));
	}

	// simple helpers for building expressions with bit vectors

	std::vector<int> vec_const(const std::vector<bool> &bits);
	std::vector<int> vec_const_signed(int64_t value, int numBits);
	std::vector<int> vec_const_unsigned(uint64_t value, int numBits);
	std::vector<int> vec_var(int numBits);
	std::vector<int> vec_var(std::string name, int numBits);
	std::vector<int> vec_cast(const std::vector<int> &vec1, int toBits, bool signExtend = false);

	std::vector<int> vec_not(const std::vector<int> &vec1);
	std::vector<int> vec_and(const std::vector<int> &vec1, const std::vector<int> &vec2);
	std::vector<int> vec_or(const std::vector<int> &vec1, const std::vector<int> &vec2);
	std::vector<int> vec_xor(const std::vector<int> &vec1, const std::vector<int> &vec2);

	std::vector<int> vec_iff(const std::vector<int> &vec1, const std::vector<int> &vec2);
	std::vector<int> vec_ite(const std::vector<int> &vec1, const std::vector<int> &vec2, const std::vector<int> &vec3);
	std::vector<int> vec_ite(int sel, const std::vector<int> &vec1, const std::vector<int> &vec2);

	std::vector<int> vec_count(const std::vector<int> &vec, int numBits, bool clip = true);
	std::vector<int> vec_add(const std::vector<int> &vec1, const std::vector<int> &vec2);
	std::vector<int> vec_sub(const std::vector<int> &vec1, const std::vector<int> &vec2);
	std::vector<int> vec_neg(const std::vector<int> &vec);

	void vec_cmp(const std::vector<int> &vec1, const std::vector<int> &vec2, int &carry, int &overflow, int &sign, int &zero);

	int vec_lt_signed(const std::vector<int> &vec1, const std::vector<int> &vec2);
	int vec_le_signed(const std::vector<int> &vec1, const std::vector<int> &vec2);
	int vec_ge_signed(const std::vector<int> &vec1, const std::vector<int> &vec2);
	int vec_gt_signed(const std::vector<int> &vec1, const std::vector<int> &vec2);

	int vec_lt_unsigned(const std::vector<int> &vec1, const std::vector<int> &vec2);
	int vec_le_unsigned(const std::vector<int> &vec1, const std::vector<int> &vec2);
	int vec_ge_unsigned(const std::vector<int> &vec1, const std::vector<int> &vec2);
	int vec_gt_unsigned(const std::vector<int> &vec1, const std::vector<int> &vec2);

	int vec_eq(const std::vector<int> &vec1, const std::vector<int> &vec2);
	int vec_ne(const std::vector<int> &vec1, const std::vector<int> &vec2);

	std::vector<int> vec_shl(const std::vector<int> &vec1, int shift, bool signExtend = false);
	std::vector<int> vec_srl(const std::vector<int> &vec1, int shift);

	std::vector<int> vec_shr(const std::vector<int> &vec1, int shift, bool signExtend = false) { return vec_shl(vec1, -shift, signExtend); }
	std::vector<int> vec_srr(const std::vector<int> &vec1, int shift) { return vec_srl(vec1, -shift); }

	std::vector<int> vec_shift(const std::vector<int> &vec1, int shift, int extend_left, int extend_right);
	std::vector<int> vec_shift_right(const std::vector<int> &vec1, const std::vector<int> &vec2, bool vec2_signed, int extend_left, int extend_right);
	std::vector<int> vec_shift_left(const std::vector<int> &vec1, const std::vector<int> &vec2, bool vec2_signed, int extend_left, int extend_right);

	void vec_append(std::vector<int> &vec, const std::vector<int> &vec1) const;
	void vec_append_signed(std::vector<int> &vec, const std::vector<int> &vec1, int64_t value);
	void vec_append_unsigned(std::vector<int> &vec, const std::vector<int> &vec1, uint64_t value);

	int64_t vec_model_get_signed(const std::vector<int> &modelExpressions, const std::vector<bool> &modelValues, const std::vector<int> &vec1) const;
	uint64_t vec_model_get_unsigned(const std::vector<int> &modelExpressions, const std::vector<bool> &modelValues, const std::vector<int> &vec1) const;

	int vec_reduce_and(const std::vector<int> &vec1);
	int vec_reduce_or(const std::vector<int> &vec1);

	void vec_set(const std::vector<int> &vec1, const std::vector<int> &vec2);
	void vec_set_signed(const std::vector<int> &vec1, int64_t value);
	void vec_set_unsigned(const std::vector<int> &vec1, uint64_t value);

	// helpers for generating ezSATbit and ezSATvec objects

	struct ezSATbit bit(_V a);
	struct ezSATvec vec(const std::vector<int> &vec);

	// printing CNF and internal state

	void printDIMACS(FILE *f, bool verbose = false) const;
	void printInternalState(FILE *f) const;

	// more sophisticated constraints (designed to be used directly with assume(..))

	int onehot(const std::vector<int> &vec, bool max_only = false);
	int manyhot(const std::vector<int> &vec, int min_hot, int max_hot = -1);
	int ordered(const std::vector<int> &vec1, const std::vector<int> &vec2, bool allow_equal = true);
};

// helper classes for using operator overloading when generating complex expressions

struct ezSATbit
{
	ezSAT &sat;
	int id;

	ezSATbit(ezSAT &sat, ezSAT::_V a) : sat(sat), id(sat.VAR(a)) { }

	ezSATbit operator ~() { return ezSATbit(sat, sat.NOT(id)); }
	ezSATbit operator &(const ezSATbit &other) { return ezSATbit(sat, sat.AND(id, other.id)); }
	ezSATbit operator |(const ezSATbit &other) { return ezSATbit(sat, sat.OR(id, other.id)); }
	ezSATbit operator ^(const ezSATbit &other) { return ezSATbit(sat, sat.XOR(id, other.id)); }
	ezSATbit operator ==(const ezSATbit &other) { return ezSATbit(sat, sat.IFF(id, other.id)); }
	ezSATbit operator !=(const ezSATbit &other) { return ezSATbit(sat, sat.NOT(sat.IFF(id, other.id))); }

	operator int() const { return id; }
	operator ezSAT::_V() const { return ezSAT::_V(id); }
	operator std::vector<int>() const { return std::vector<int>(1, id); }
};

struct ezSATvec
{
	ezSAT &sat;
	std::vector<int> vec;

	ezSATvec(ezSAT &sat, const std::vector<int> &vec) : sat(sat), vec(vec) { }

	ezSATvec operator ~() { return ezSATvec(sat, sat.vec_not(vec)); }
	ezSATvec operator -() { return ezSATvec(sat, sat.vec_neg(vec)); }

	ezSATvec operator &(const ezSATvec &other) { return ezSATvec(sat, sat.vec_and(vec, other.vec)); }
	ezSATvec operator |(const ezSATvec &other) { return ezSATvec(sat, sat.vec_or(vec, other.vec)); }
	ezSATvec operator ^(const ezSATvec &other) { return ezSATvec(sat, sat.vec_xor(vec, other.vec)); }

	ezSATvec operator +(const ezSATvec &other) { return ezSATvec(sat, sat.vec_add(vec, other.vec)); }
	ezSATvec operator -(const ezSATvec &other) { return ezSATvec(sat, sat.vec_sub(vec, other.vec)); }

	ezSATbit operator < (const ezSATvec &other) { return ezSATbit(sat, sat.vec_lt_unsigned(vec, other.vec)); }
	ezSATbit operator <=(const ezSATvec &other) { return ezSATbit(sat, sat.vec_le_unsigned(vec, other.vec)); }
	ezSATbit operator ==(const ezSATvec &other) { return ezSATbit(sat, sat.vec_eq(vec, other.vec)); }
	ezSATbit operator !=(const ezSATvec &other) { return ezSATbit(sat, sat.vec_ne(vec, other.vec)); }
	ezSATbit operator >=(const ezSATvec &other) { return ezSATbit(sat, sat.vec_ge_unsigned(vec, other.vec)); }
	ezSATbit operator > (const ezSATvec &other) { return ezSATbit(sat, sat.vec_gt_unsigned(vec, other.vec)); }

	ezSATvec operator <<(int shift) { return ezSATvec(sat, sat.vec_shl(vec, shift)); }
	ezSATvec operator >>(int shift) { return ezSATvec(sat, sat.vec_shr(vec, shift)); }

	operator std::vector<int>() const { return vec; }
};

#endif
`},json11:{"json11.hpp":`/* json11
 *
 * json11 is a tiny JSON library for C++11, providing JSON parsing and serialization.
 *
 * The core object provided by the library is json11::Json. A Json object represents any JSON
 * value: null, bool, number (int or double), string (std::string), array (std::vector), or
 * object (std::map).
 *
 * Json objects act like values: they can be assigned, copied, moved, compared for equality or
 * order, etc. There are also helper methods Json::dump, to serialize a Json to a string, and
 * Json::parse (static) to parse a std::string as a Json object.
 *
 * Internally, the various types of Json object are represented by the JsonValue class
 * hierarchy.
 *
 * A note on numbers - JSON specifies the syntax of number formatting but not its semantics,
 * so some JSON implementations distinguish between integers and floating-point numbers, while
 * some don't. In json11, we choose the latter. Because some JSON implementations (namely
 * Javascript itself) treat all numbers as the same type, distinguishing the two leads
 * to JSON that will be *silently* changed by a round-trip through those implementations.
 * Dangerous! To avoid that risk, json11 stores all numbers as double internally, but also
 * provides integer helpers.
 *
 * Fortunately, double-precision IEEE754 ('double') can precisely store any integer in the
 * range +/-2^53, which includes every 'int' on most systems. (Timestamps often use int64
 * or long long to avoid the Y2038K problem; a double storing microseconds since some epoch
 * will be exact for +/- 275 years.)
 */

/* Copyright (c) 2013 Dropbox, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#pragma once

#include <string>
#include <vector>
#include <map>
#include <memory>
#include <initializer_list>

#ifdef _MSC_VER
    #if _MSC_VER <= 1800 // VS 2013
        #ifndef noexcept
            #define noexcept throw()
        #endif

        #ifndef snprintf
            #define snprintf _snprintf_s
        #endif
    #endif
#endif

namespace json11 {

enum JsonParse {
    STANDARD, COMMENTS
};

class JsonValue;

class Json final {
public:
    // Types
    enum Type {
        NUL, NUMBER, BOOL, STRING, ARRAY, OBJECT
    };

    // Array and object typedefs
    typedef std::vector<Json> array;
    typedef std::map<std::string, Json> object;

    // Constructors for the various types of JSON value.
    Json() noexcept;                // NUL
    Json(std::nullptr_t) noexcept;  // NUL
    Json(double value);             // NUMBER
    Json(int value);                // NUMBER
    Json(bool value);               // BOOL
    Json(const std::string &value); // STRING
    Json(std::string &&value);      // STRING
    Json(const char * value);       // STRING
    Json(const array &values);      // ARRAY
    Json(array &&values);           // ARRAY
    Json(const object &values);     // OBJECT
    Json(object &&values);          // OBJECT

    // Implicit constructor: anything with a to_json() function.
    template <class T, class = decltype(&T::to_json)>
    Json(const T & t) : Json(t.to_json()) {}

    // Implicit constructor: map-like objects (std::map, std::unordered_map, etc)
    template <class M, typename std::enable_if<
        std::is_constructible<std::string, decltype(std::declval<M>().begin()->first)>::value
        && std::is_constructible<Json, decltype(std::declval<M>().begin()->second)>::value,
            int>::type = 0>
    Json(const M & m) : Json(object(m.begin(), m.end())) {}

    // Implicit constructor: vector-like objects (std::list, std::vector, std::set, etc)
    template <class V, typename std::enable_if<
        std::is_constructible<Json, decltype(*std::declval<V>().begin())>::value,
            int>::type = 0>
    Json(const V & v) : Json(array(v.begin(), v.end())) {}

    // This prevents Json(some_pointer) from accidentally producing a bool. Use
    // Json(bool(some_pointer)) if that behavior is desired.
    Json(void *) = delete;

    // Accessors
    Type type() const;

    bool is_null()   const { return type() == NUL; }
    bool is_number() const { return type() == NUMBER; }
    bool is_bool()   const { return type() == BOOL; }
    bool is_string() const { return type() == STRING; }
    bool is_array()  const { return type() == ARRAY; }
    bool is_object() const { return type() == OBJECT; }

    // Return the enclosed value if this is a number, 0 otherwise. Note that json11 does not
    // distinguish between integer and non-integer numbers - number_value() and int_value()
    // can both be applied to a NUMBER-typed object.
    double number_value() const;
    int int_value() const;

    // Return the enclosed value if this is a boolean, false otherwise.
    bool bool_value() const;
    // Return the enclosed string if this is a string, "" otherwise.
    const std::string &string_value() const;
    // Return the enclosed std::vector if this is an array, or an empty vector otherwise.
    const array &array_items() const;
    // Return the enclosed std::map if this is an object, or an empty map otherwise.
    const object &object_items() const;

    // Return a reference to arr[i] if this is an array, Json() otherwise.
    const Json & operator[](size_t i) const;
    // Return a reference to obj[key] if this is an object, Json() otherwise.
    const Json & operator[](const std::string &key) const;

    // Serialize.
    void dump(std::string &out) const;
    std::string dump() const {
        std::string out;
        dump(out);
        return out;
    }

    // Parse. If parse fails, return Json() and assign an error message to err.
    static Json parse(const std::string & in,
                      std::string & err,
                      JsonParse strategy = JsonParse::STANDARD);
    static Json parse(const char * in,
                      std::string & err,
                      JsonParse strategy = JsonParse::STANDARD) {
        if (in) {
            return parse(std::string(in), err, strategy);
        } else {
            err = "null input";
            return nullptr;
        }
    }
    // Parse multiple objects, concatenated or separated by whitespace
    static std::vector<Json> parse_multi(
        const std::string & in,
        std::string::size_type & parser_stop_pos,
        std::string & err,
        JsonParse strategy = JsonParse::STANDARD);

    static inline std::vector<Json> parse_multi(
        const std::string & in,
        std::string & err,
        JsonParse strategy = JsonParse::STANDARD) {
        std::string::size_type parser_stop_pos;
        return parse_multi(in, parser_stop_pos, err, strategy);
    }

    bool operator== (const Json &rhs) const;
    bool operator<  (const Json &rhs) const;
    bool operator!= (const Json &rhs) const { return !(*this == rhs); }
    bool operator<= (const Json &rhs) const { return !(rhs < *this); }
    bool operator>  (const Json &rhs) const { return  (rhs < *this); }
    bool operator>= (const Json &rhs) const { return !(*this < rhs); }

    /* has_shape(types, err)
     *
     * Return true if this is a JSON object and, for each item in types, has a field of
     * the given type. If not, return false and set err to a descriptive message.
     */
    typedef std::initializer_list<std::pair<std::string, Type>> shape;
    bool has_shape(const shape & types, std::string & err) const;

private:
    std::shared_ptr<JsonValue> m_ptr;
};

// Internal class hierarchy - JsonValue objects are not exposed to users of this API.
class JsonValue {
protected:
    friend class Json;
    friend class JsonInt;
    friend class JsonDouble;
    virtual Json::Type type() const = 0;
    virtual bool equals(const JsonValue * other) const = 0;
    virtual bool less(const JsonValue * other) const = 0;
    virtual void dump(std::string &out) const = 0;
    virtual double number_value() const;
    virtual int int_value() const;
    virtual bool bool_value() const;
    virtual const std::string &string_value() const;
    virtual const Json::array &array_items() const;
    virtual const Json &operator[](size_t i) const;
    virtual const Json::object &object_items() const;
    virtual const Json &operator[](const std::string &key) const;
    virtual ~JsonValue() {}
};

} // namespace json11
`},sha1:{"sha1.h":`/*
    sha1.h - header of

    ============
    SHA-1 in C++
    ============

    100% Public Domain.

    Original C Code
        -- Steve Reid <steve@edmweb.com>
    Small changes to fit into bglibs
        -- Bruce Guenter <bruce@untroubled.org>
    Translation to simpler C++ Code
        -- Volker Grabsch <vog@notjusthosting.com>
    Fixing bugs and improving style
        -- Eugene Hopkinson <slowriot at voxelstorm dot com>
*/

#ifndef SHA1_HPP
#define SHA1_HPP


#include <iostream>
#include <string>
#include <stdint.h>

class SHA1
{
public:
    SHA1();
    void update(const std::string &s);
    void update(std::istream &is);
    std::string final();
    static std::string from_file(const std::string &filename);

private:
    static constexpr unsigned int DIGEST_INTS = 5;  /* number of 32bit integers per SHA1 digest */
    static constexpr unsigned int BLOCK_INTS = 16;  /* number of 32bit integers per SHA1 block */
    static constexpr unsigned int BLOCK_BYTES = BLOCK_INTS * 4;

    uint32_t digest[DIGEST_INTS];
    std::string buffer;
    uint64_t transforms;

    void reset();
    void transform(uint32_t block[BLOCK_BYTES]);

    static void read(std::istream &is, std::string &s, size_t max);
    static void buffer_to_block(const std::string &buffer, uint32_t block[BLOCK_INTS]);
};

std::string sha1(const std::string &string);



#endif /* SHA1_HPP */
`}},passes:{fsm:{"fsmdata.h":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef FSMDATA_H
#define FSMDATA_H

#include "kernel/yosys.h"

YOSYS_NAMESPACE_BEGIN

struct FsmData
{
	int num_inputs, num_outputs, state_bits, reset_state;
	struct transition_t { int state_in, state_out; RTLIL::Const ctrl_in, ctrl_out; };
	std::vector<transition_t> transition_table;
	std::vector<RTLIL::Const> state_table;

	void copy_to_cell(RTLIL::Cell *cell)
	{
		cell->parameters[ID::CTRL_IN_WIDTH] = RTLIL::Const(num_inputs);
		cell->parameters[ID::CTRL_OUT_WIDTH] = RTLIL::Const(num_outputs);

		int state_num_log2 = 0;
		for (int i = state_table.size(); i > 0; i = i >> 1)
			state_num_log2++;
		state_num_log2 = max(state_num_log2, 1);

		cell->parameters[ID::STATE_BITS] = RTLIL::Const(state_bits);
		cell->parameters[ID::STATE_NUM] = RTLIL::Const(state_table.size());
		cell->parameters[ID::STATE_NUM_LOG2] = RTLIL::Const(state_num_log2);
		cell->parameters[ID::STATE_RST] = RTLIL::Const(reset_state);
		cell->parameters[ID::STATE_TABLE] = RTLIL::Const();

		for (int i = 0; i < int(state_table.size()); i++) {
			std::vector<RTLIL::State> &bits_table = cell->parameters[ID::STATE_TABLE].bits;
			std::vector<RTLIL::State> &bits_state = state_table[i].bits;
			bits_table.insert(bits_table.end(), bits_state.begin(), bits_state.end());
		}

		cell->parameters[ID::TRANS_NUM] = RTLIL::Const(transition_table.size());
		cell->parameters[ID::TRANS_TABLE] = RTLIL::Const();
		for (int i = 0; i < int(transition_table.size()); i++)
		{
			std::vector<RTLIL::State> &bits_table = cell->parameters[ID::TRANS_TABLE].bits;
			transition_t &tr = transition_table[i];

			RTLIL::Const const_state_in = RTLIL::Const(tr.state_in, state_num_log2);
			RTLIL::Const const_state_out = RTLIL::Const(tr.state_out, state_num_log2);
			std::vector<RTLIL::State> &bits_state_in = const_state_in.bits;
			std::vector<RTLIL::State> &bits_state_out = const_state_out.bits;

			std::vector<RTLIL::State> &bits_ctrl_in = tr.ctrl_in.bits;
			std::vector<RTLIL::State> &bits_ctrl_out = tr.ctrl_out.bits;

			// append lsb first
			bits_table.insert(bits_table.end(), bits_ctrl_out.begin(), bits_ctrl_out.end());
			bits_table.insert(bits_table.end(), bits_state_out.begin(), bits_state_out.end());
			bits_table.insert(bits_table.end(), bits_ctrl_in.begin(), bits_ctrl_in.end());
			bits_table.insert(bits_table.end(), bits_state_in.begin(), bits_state_in.end());
		}
	}

	void copy_from_cell(RTLIL::Cell *cell)
	{
		num_inputs = cell->parameters[ID::CTRL_IN_WIDTH].as_int();
		num_outputs = cell->parameters[ID::CTRL_OUT_WIDTH].as_int();

		state_bits = cell->parameters[ID::STATE_BITS].as_int();
		reset_state = cell->parameters[ID::STATE_RST].as_int();

		int state_num = cell->parameters[ID::STATE_NUM].as_int();
		int state_num_log2 = cell->parameters[ID::STATE_NUM_LOG2].as_int();
		int trans_num = cell->parameters[ID::TRANS_NUM].as_int();

		if (reset_state < 0 || reset_state >= state_num)
			reset_state = -1;

		const RTLIL::Const &state_table = cell->parameters[ID::STATE_TABLE];
		const RTLIL::Const &trans_table = cell->parameters[ID::TRANS_TABLE];

		for (int i = 0; i < state_num; i++) {
			RTLIL::Const state_code;
			int off_begin = i*state_bits, off_end = off_begin + state_bits;
			state_code.bits.insert(state_code.bits.begin(), state_table.bits.begin()+off_begin, state_table.bits.begin()+off_end);
			this->state_table.push_back(state_code);
		}

		for (int i = 0; i < trans_num; i++)
		{
			auto off_ctrl_out = trans_table.bits.begin() + i*(num_inputs+num_outputs+2*state_num_log2);
			auto off_state_out = off_ctrl_out + num_outputs;
			auto off_ctrl_in = off_state_out + state_num_log2;
			auto off_state_in = off_ctrl_in + num_inputs;
			auto off_end = off_state_in + state_num_log2;

			RTLIL::Const state_in, state_out, ctrl_in, ctrl_out;
			ctrl_out.bits.insert(state_in.bits.begin(), off_ctrl_out, off_state_out);
			state_out.bits.insert(state_out.bits.begin(), off_state_out, off_ctrl_in);
			ctrl_in.bits.insert(ctrl_in.bits.begin(), off_ctrl_in, off_state_in);
			state_in.bits.insert(state_in.bits.begin(), off_state_in, off_end);

			transition_t tr;
			tr.state_in = state_in.as_int();
			tr.state_out = state_out.as_int();
			tr.ctrl_in = ctrl_in;
			tr.ctrl_out = ctrl_out;

			if (tr.state_in < 0 || tr.state_in >= state_num)
				tr.state_in = -1;
			if (tr.state_out < 0 || tr.state_out >= state_num)
				tr.state_out = -1;

			transition_table.push_back(tr);
		}
	}

	void log_info(RTLIL::Cell *cell)
	{
		log("-------------------------------------\\n");
		log("\\n");
		log("  Information on FSM %s (%s):\\n", cell->name.c_str(), cell->parameters[ID::NAME].decode_string().c_str());
		log("\\n");
		log("  Number of input signals:  %3d\\n", num_inputs);
		log("  Number of output signals: %3d\\n", num_outputs);
		log("  Number of state bits:     %3d\\n", state_bits);

		log("\\n");
		log("  Input signals:\\n");
		RTLIL::SigSpec sig_in = cell->getPort(ID::CTRL_IN);
		for (int i = 0; i < GetSize(sig_in); i++)
			log("  %3d: %s\\n", i, log_signal(sig_in[i]));

		log("\\n");
		log("  Output signals:\\n");
		RTLIL::SigSpec sig_out = cell->getPort(ID::CTRL_OUT);
		for (int i = 0; i < GetSize(sig_out); i++)
			log("  %3d: %s\\n", i, log_signal(sig_out[i]));

		log("\\n");
		log("  State encoding:\\n");
		for (int i = 0; i < GetSize(state_table); i++)
			log("  %3d: %10s%s\\n", i, log_signal(state_table[i], false),
					int(i) == reset_state ? "  <RESET STATE>" : "");

		log("\\n");
		log("  Transition Table (state_in, ctrl_in, state_out, ctrl_out):\\n");
		for (int i = 0; i < GetSize(transition_table); i++) {
			transition_t &tr = transition_table[i];
			log("  %5d: %5d %s   -> %5d %s\\n", i, tr.state_in, log_signal(tr.ctrl_in), tr.state_out, log_signal(tr.ctrl_out));
		}

		log("\\n");
		log("-------------------------------------\\n");
	}

	// implemented in fsm_opt.cc
	static void optimize_fsm(RTLIL::Cell *cell, RTLIL::Module *module);
};

YOSYS_NAMESPACE_END

#endif
`}}},intel:{common:{"altpll_bb.v":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */
/* No clearbox model */
\`ifdef NO_CLEARBOX
(* blackbox *)
module altpll
  ( inclk,
    fbin,
    pllena,
    clkswitch,
    areset,
    pfdena,
    clkena,
    extclkena,
    scanclk,
    scanaclr,
    scanclkena,
    scanread,
    scanwrite,
    scandata,
    phasecounterselect,
    phaseupdown,
    phasestep,
    configupdate,
    fbmimicbidir,
    clk,
    extclk,
    clkbad,
    enable0,
    enable1,
    activeclock,
    clkloss,
    locked,
    scandataout,
    scandone,
    sclkout0,
    sclkout1,
    phasedone,
    vcooverrange,
    vcounderrange,
    fbout,
    fref,
    icdrclk,
    c0,
    c1,
    c2,
    c3,
    c4);

   parameter   intended_device_family    = "MAX 10";
   parameter   operation_mode            = "NORMAL";
   parameter   pll_type                  = "AUTO";
   parameter   qualify_conf_done         = "OFF";
   parameter   compensate_clock          = "CLK0";
   parameter   scan_chain                = "LONG";
   parameter   primary_clock             = "inclk0";
   parameter   inclk0_input_frequency    = 1000;
   parameter   inclk1_input_frequency    = 0;
   parameter   gate_lock_signal          = "NO";
   parameter   gate_lock_counter         = 0;
   parameter   lock_high                 = 1;
   parameter   lock_low                  = 0;
   parameter   valid_lock_multiplier     = 1;
   parameter   invalid_lock_multiplier   = 5;
   parameter   switch_over_type          = "AUTO";
   parameter   switch_over_on_lossclk    = "OFF" ;
   parameter   switch_over_on_gated_lock = "OFF" ;
   parameter   enable_switch_over_counter = "OFF";
   parameter   switch_over_counter       = 0;
   parameter   feedback_source           = "EXTCLK0" ;
   parameter   bandwidth                 = 0;
   parameter   bandwidth_type            = "UNUSED";
   parameter   lpm_hint                  = "UNUSED";
   parameter   spread_frequency          = 0;
   parameter   down_spread               = "0.0";
   parameter   self_reset_on_gated_loss_lock = "OFF";
   parameter   self_reset_on_loss_lock = "OFF";
   parameter   lock_window_ui           = "0.05";
   parameter   width_clock              = 6;
   parameter   width_phasecounterselect = 4;
   parameter   charge_pump_current_bits = 9999;
   parameter   loop_filter_c_bits = 9999;
   parameter   loop_filter_r_bits = 9999;
   parameter   scan_chain_mif_file = "UNUSED";
   parameter   clk9_multiply_by        = 1;
   parameter   clk8_multiply_by        = 1;
   parameter   clk7_multiply_by        = 1;
   parameter   clk6_multiply_by        = 1;
   parameter   clk5_multiply_by        = 1;
   parameter   clk4_multiply_by        = 1;
   parameter   clk3_multiply_by        = 1;
   parameter   clk2_multiply_by        = 1;
   parameter   clk1_multiply_by        = 1;
   parameter   clk0_multiply_by        = 1;
   parameter   clk9_divide_by          = 1;
   parameter   clk8_divide_by          = 1;
   parameter   clk7_divide_by          = 1;
   parameter   clk6_divide_by          = 1;
   parameter   clk5_divide_by          = 1;
   parameter   clk4_divide_by          = 1;
   parameter   clk3_divide_by          = 1;
   parameter   clk2_divide_by          = 1;
   parameter   clk1_divide_by          = 1;
   parameter   clk0_divide_by          = 1;
   parameter   clk9_phase_shift        = "0";
   parameter   clk8_phase_shift        = "0";
   parameter   clk7_phase_shift        = "0";
   parameter   clk6_phase_shift        = "0";
   parameter   clk5_phase_shift        = "0";
   parameter   clk4_phase_shift        = "0";
   parameter   clk3_phase_shift        = "0";
   parameter   clk2_phase_shift        = "0";
   parameter   clk1_phase_shift        = "0";
   parameter   clk0_phase_shift        = "0";

   parameter   clk9_duty_cycle         = 50;
   parameter   clk8_duty_cycle         = 50;
   parameter   clk7_duty_cycle         = 50;
   parameter   clk6_duty_cycle         = 50;
   parameter   clk5_duty_cycle         = 50;
   parameter   clk4_duty_cycle         = 50;
   parameter   clk3_duty_cycle         = 50;
   parameter   clk2_duty_cycle         = 50;
   parameter   clk1_duty_cycle         = 50;
   parameter   clk0_duty_cycle         = 50;

   parameter   clk9_use_even_counter_mode    = "OFF";
   parameter   clk8_use_even_counter_mode    = "OFF";
   parameter   clk7_use_even_counter_mode    = "OFF";
   parameter   clk6_use_even_counter_mode    = "OFF";
   parameter   clk5_use_even_counter_mode    = "OFF";
   parameter   clk4_use_even_counter_mode    = "OFF";
   parameter   clk3_use_even_counter_mode    = "OFF";
   parameter   clk2_use_even_counter_mode    = "OFF";
   parameter   clk1_use_even_counter_mode    = "OFF";
   parameter   clk0_use_even_counter_mode    = "OFF";
   parameter   clk9_use_even_counter_value   = "OFF";
   parameter   clk8_use_even_counter_value   = "OFF";
   parameter   clk7_use_even_counter_value   = "OFF";
   parameter   clk6_use_even_counter_value   = "OFF";
   parameter   clk5_use_even_counter_value   = "OFF";
   parameter   clk4_use_even_counter_value   = "OFF";
   parameter   clk3_use_even_counter_value   = "OFF";
   parameter   clk2_use_even_counter_value   = "OFF";
   parameter   clk1_use_even_counter_value   = "OFF";
   parameter   clk0_use_even_counter_value   = "OFF";

   parameter   clk2_output_frequency   = 0;
   parameter   clk1_output_frequency   = 0;
   parameter   clk0_output_frequency   = 0;

   parameter   vco_min             = 0;
   parameter   vco_max             = 0;
   parameter   vco_center          = 0;
   parameter   pfd_min             = 0;
   parameter   pfd_max             = 0;
   parameter   m_initial           = 1;
   parameter   m                   = 0;
   parameter   n                   = 1;
   parameter   m2                  = 1;
   parameter   n2                  = 1;
   parameter   ss                  = 0;
   parameter   l0_high             = 1;
   parameter   l1_high             = 1;
   parameter   g0_high             = 1;
   parameter   g1_high             = 1;
   parameter   g2_high             = 1;
   parameter   g3_high             = 1;
   parameter   e0_high             = 1;
   parameter   e1_high             = 1;
   parameter   e2_high             = 1;
   parameter   e3_high             = 1;
   parameter   l0_low              = 1;
   parameter   l1_low              = 1;
   parameter   g0_low              = 1;
   parameter   g1_low              = 1;
   parameter   g2_low              = 1;
   parameter   g3_low              = 1;
   parameter   e0_low              = 1;
   parameter   e1_low              = 1;
   parameter   e2_low              = 1;
   parameter   e3_low              = 1;
   parameter   l0_initial          = 1;
   parameter   l1_initial          = 1;
   parameter   g0_initial          = 1;
   parameter   g1_initial          = 1;
   parameter   g2_initial          = 1;
   parameter   g3_initial          = 1;
   parameter   e0_initial          = 1;
   parameter   e1_initial          = 1;
   parameter   e2_initial          = 1;
   parameter   e3_initial          = 1;
   parameter   l0_mode             = "bypass";
   parameter   l1_mode             = "bypass";
   parameter   g0_mode             = "bypass";
   parameter   g1_mode             = "bypass";
   parameter   g2_mode             = "bypass";
   parameter   g3_mode             = "bypass";
   parameter   e0_mode             = "bypass";
   parameter   e1_mode             = "bypass";
   parameter   e2_mode             = "bypass";
   parameter   e3_mode             = "bypass";
   parameter   l0_ph               = 0;
   parameter   l1_ph               = 0;
   parameter   g0_ph               = 0;
   parameter   g1_ph               = 0;
   parameter   g2_ph               = 0;
   parameter   g3_ph               = 0;
   parameter   e0_ph               = 0;
   parameter   e1_ph               = 0;
   parameter   e2_ph               = 0;
   parameter   e3_ph               = 0;
   parameter   m_ph                = 0;
   parameter   l0_time_delay       = 0;
   parameter   l1_time_delay       = 0;
   parameter   g0_time_delay       = 0;
   parameter   g1_time_delay       = 0;
   parameter   g2_time_delay       = 0;
   parameter   g3_time_delay       = 0;
   parameter   e0_time_delay       = 0;
   parameter   e1_time_delay       = 0;
   parameter   e2_time_delay       = 0;
   parameter   e3_time_delay       = 0;
   parameter   m_time_delay        = 0;
   parameter   n_time_delay        = 0;
   parameter   extclk3_counter     = "e3" ;
   parameter   extclk2_counter     = "e2" ;
   parameter   extclk1_counter     = "e1" ;
   parameter   extclk0_counter     = "e0" ;
   parameter   clk9_counter        = "c9" ;
   parameter   clk8_counter        = "c8" ;
   parameter   clk7_counter        = "c7" ;
   parameter   clk6_counter        = "c6" ;
   parameter   clk5_counter        = "l1" ;
   parameter   clk4_counter        = "l0" ;
   parameter   clk3_counter        = "g3" ;
   parameter   clk2_counter        = "g2" ;
   parameter   clk1_counter        = "g1" ;
   parameter   clk0_counter        = "g0" ;
   parameter   enable0_counter     = "l0";
   parameter   enable1_counter     = "l0";
   parameter   charge_pump_current = 2;
   parameter   loop_filter_r       = "1.0";
   parameter   loop_filter_c       = 5;
   parameter   vco_post_scale      = 0;
   parameter   vco_frequency_control = "AUTO";
   parameter   vco_phase_shift_step = 0;
   parameter   lpm_type            = "altpll";

   parameter port_clkena0 = "PORT_CONNECTIVITY";
   parameter port_clkena1 = "PORT_CONNECTIVITY";
   parameter port_clkena2 = "PORT_CONNECTIVITY";
   parameter port_clkena3 = "PORT_CONNECTIVITY";
   parameter port_clkena4 = "PORT_CONNECTIVITY";
   parameter port_clkena5 = "PORT_CONNECTIVITY";
   parameter port_extclkena0 = "PORT_CONNECTIVITY";
   parameter port_extclkena1 = "PORT_CONNECTIVITY";
   parameter port_extclkena2 = "PORT_CONNECTIVITY";
   parameter port_extclkena3 = "PORT_CONNECTIVITY";
   parameter port_extclk0 = "PORT_CONNECTIVITY";
   parameter port_extclk1 = "PORT_CONNECTIVITY";
   parameter port_extclk2 = "PORT_CONNECTIVITY";
   parameter port_extclk3 = "PORT_CONNECTIVITY";
   parameter port_clk0 = "PORT_CONNECTIVITY";
   parameter port_clk1 = "PORT_CONNECTIVITY";
   parameter port_clk2 = "PORT_CONNECTIVITY";
   parameter port_clk3 = "PORT_CONNECTIVITY";
   parameter port_clk4 = "PORT_CONNECTIVITY";
   parameter port_clk5 = "PORT_CONNECTIVITY";
   parameter port_clk6 = "PORT_CONNECTIVITY";
   parameter port_clk7 = "PORT_CONNECTIVITY";
   parameter port_clk8 = "PORT_CONNECTIVITY";
   parameter port_clk9 = "PORT_CONNECTIVITY";
   parameter port_scandata = "PORT_CONNECTIVITY";
   parameter port_scandataout = "PORT_CONNECTIVITY";
   parameter port_scandone = "PORT_CONNECTIVITY";
   parameter port_sclkout1 = "PORT_CONNECTIVITY";
   parameter port_sclkout0 = "PORT_CONNECTIVITY";
   parameter port_clkbad0 = "PORT_CONNECTIVITY";
   parameter port_clkbad1 = "PORT_CONNECTIVITY";
   parameter port_activeclock = "PORT_CONNECTIVITY";
   parameter port_clkloss = "PORT_CONNECTIVITY";
   parameter port_inclk1 = "PORT_CONNECTIVITY";
   parameter port_inclk0 = "PORT_CONNECTIVITY";
   parameter port_fbin = "PORT_CONNECTIVITY";
   parameter port_fbout = "PORT_CONNECTIVITY";
   parameter port_pllena = "PORT_CONNECTIVITY";
   parameter port_clkswitch = "PORT_CONNECTIVITY";
   parameter port_areset = "PORT_CONNECTIVITY";
   parameter port_pfdena = "PORT_CONNECTIVITY";
   parameter port_scanclk = "PORT_CONNECTIVITY";
   parameter port_scanaclr = "PORT_CONNECTIVITY";
   parameter port_scanread = "PORT_CONNECTIVITY";
   parameter port_scanwrite = "PORT_CONNECTIVITY";
   parameter port_enable0 = "PORT_CONNECTIVITY";
   parameter port_enable1 = "PORT_CONNECTIVITY";
   parameter port_locked = "PORT_CONNECTIVITY";
   parameter port_configupdate = "PORT_CONNECTIVITY";
   parameter port_phasecounterselect = "PORT_CONNECTIVITY";
   parameter port_phasedone = "PORT_CONNECTIVITY";
   parameter port_phasestep = "PORT_CONNECTIVITY";
   parameter port_phaseupdown = "PORT_CONNECTIVITY";
   parameter port_vcooverrange = "PORT_CONNECTIVITY";
   parameter port_vcounderrange = "PORT_CONNECTIVITY";
   parameter port_scanclkena = "PORT_CONNECTIVITY";
   parameter using_fbmimicbidir_port = "ON";

   input [1:0] inclk;
   input       fbin;
   input       pllena;
   input       clkswitch;
   input       areset;
   input       pfdena;
   input       clkena;
   input       extclkena;
   input       scanclk;
   input       scanaclr;
   input       scanclkena;
   input       scanread;
   input       scanwrite;
   input       scandata;
   input       phasecounterselect;
   input       phaseupdown;
   input       phasestep;
   input       configupdate;
   inout       fbmimicbidir;


   output [width_clock-1:0] clk;
   output [3:0]             extclk;
   output [1:0]             clkbad;
   output                   enable0;
   output                   enable1;
   output                   activeclock;
   output                   clkloss;
   output                   locked;
   output                   scandataout;
   output                   scandone;
   output                   sclkout0;
   output                   sclkout1;
   output                   phasedone;
   output                   vcooverrange;
   output                   vcounderrange;
   output                   fbout;
   output                   fref;
   output                   icdrclk;
   output                   c0, c1, c2, c3, c4;

endmodule // altpll
\`endif
`,"brams_m9k.txt":`bram $__M9K_ALTSYNCRAM_SINGLEPORT_FULL
  init   1
  abits  13 @M1
  dbits  1  @M1
  abits  12 @M2
  dbits  2  @M2
  abits  11 @M3
  dbits  4  @M3
  abits  10 @M4
  dbits  8  @M4
  abits  10 @M5
  dbits  9  @M5
  abits  9  @M6
  dbits  16 @M6
  abits  9  @M7
  dbits  18 @M7
  abits  8  @M8
  dbits  32 @M8
  abits  8  @M9
  dbits  36 @M9
  groups 2
  ports  1 1
  wrmode 0 1
  enable 1 1
  transp 0 0
  clocks 2 3
  clkpol 2 3
endbram

match $__M9K_ALTSYNCRAM_SINGLEPORT_FULL
  min efficiency 2
  make_transp
endmatch
`,"brams_map_m9k.v":`module \\$__M9K_ALTSYNCRAM_SINGLEPORT_FULL (CLK2, CLK3, A1ADDR, A1DATA, A1EN, B1ADDR, B1DATA, B1EN);

   parameter CFG_ABITS = 8;
   parameter CFG_DBITS = 36;
   parameter ABITS = 1;
   parameter DBITS = 1;
   parameter CLKPOL2 = 1;
   parameter CLKPOL3 = 1;

   input CLK2;
   input CLK3;
   //Read data
   output [CFG_DBITS-1:0] A1DATA;
   input [CFG_ABITS-1:0]  A1ADDR;
   input                  A1EN;
   //Write data
   output [CFG_DBITS-1:0] B1DATA;
   input [CFG_ABITS-1:0]  B1ADDR;
   input                  B1EN;

   wire [CFG_DBITS-1:0]   B1DATA_t;

   localparam MODE = CFG_DBITS == 1  ? 1:
                     CFG_DBITS == 2  ? 2:
                     CFG_DBITS == 4  ? 3:
                     CFG_DBITS == 8  ? 4:
                     CFG_DBITS == 9  ? 5:
                     CFG_DBITS == 16 ? 6:
                     CFG_DBITS == 18 ? 7:
                     CFG_DBITS == 32 ? 8:
                     CFG_DBITS == 36 ? 9:
                     'bx;

   localparam NUMWORDS = CFG_DBITS == 1  ? 8192:
                         CFG_DBITS == 2  ? 4096:
                         CFG_DBITS == 4  ? 2048:
                         CFG_DBITS == 8  ? 1024:
                         CFG_DBITS == 9  ? 1024:
                         CFG_DBITS == 16 ?  512:
                         CFG_DBITS == 18 ?  512:
                         CFG_DBITS == 32 ?  256:
                         CFG_DBITS == 36 ?  256:
                         'bx;

   altsyncram  #(.clock_enable_input_b           ("ALTERNATE"   ),
                 .clock_enable_input_a           ("ALTERNATE"   ),
                 .clock_enable_output_b          ("NORMAL"      ),
                 .clock_enable_output_a          ("NORMAL"      ),
                 .wrcontrol_aclr_a               ("NONE"        ),
                 .indata_aclr_a                  ("NONE"        ),
                 .address_aclr_a                 ("NONE"        ),
                 .outdata_aclr_a                 ("NONE"        ),
                 .outdata_reg_a                  ("UNREGISTERED"),
                 .operation_mode                 ("SINGLE_PORT" ),
                 .intended_device_family         ("CYCLONE IVE" ),
                 .outdata_reg_a                  ("UNREGISTERED"),
                 .lpm_type                       ("altsyncram"  ),
                 .init_type                      ("unused"      ),
                 .ram_block_type                 ("AUTO"        ),
                 .lpm_hint                       ("ENABLE_RUNTIME_MOD=NO"), // Forced value
                 .power_up_uninitialized         ("FALSE"),
                 .read_during_write_mode_port_a  ("NEW_DATA_NO_NBE_READ"), // Forced value
                 .width_byteena_a                (1), // Forced value
                 .numwords_b                     ( NUMWORDS     ),
                 .numwords_a                     ( NUMWORDS     ),
                 .widthad_b                      ( CFG_DBITS    ),
                 .width_b                        ( CFG_ABITS    ),
                 .widthad_a                      ( CFG_DBITS    ),
                 .width_a                        ( CFG_ABITS    )
                 ) _TECHMAP_REPLACE_ (
                                      .data_a(B1DATA),
                                      .address_a(B1ADDR),
                                      .wren_a(B1EN),
                                      .rden_a(A1EN),
                                      .q_a(A1DATA),
                                      .data_b(B1DATA),
                                      .address_b(0),
                                      .wren_b(1'b0),
                                      .rden_b(1'b0),
                                      .q_b(),
                                      .clock0(CLK2),
                                      .clock1(1'b1), // Unused in single port mode
                                      .clocken0(1'b1),
                                      .clocken1(1'b1),
                                      .clocken2(1'b1),
                                      .clocken3(1'b1),
                                      .aclr0(1'b0),
                                      .aclr1(1'b0),
                                      .addressstall_a(1'b0),
                                      .addressstall_b(1'b0));

endmodule

`,"ff_map.v":`// Async Active Low Reset DFF
module  \\$_DFFE_PN0P_ (input D, C, R, E, output Q);
   parameter _TECHMAP_WIREINIT_Q_ = 1'bx;
   generate if (_TECHMAP_WIREINIT_Q_ === 1'b1) begin
     dffeas #(.is_wysiwyg("TRUE"), .power_up("high")) _TECHMAP_REPLACE_ (.d(D), .q(Q), .clk(C), .clrn(R), .prn(1'b1), .ena(E), .asdata(1'b0), .aload(1'b0), .sclr(1'b0), .sload(1'b0));
   end else begin
     dffeas #(.is_wysiwyg("TRUE"), .power_up("low")) _TECHMAP_REPLACE_ (.d(D), .q(Q), .clk(C), .clrn(R), .prn(1'b1), .ena(E), .asdata(1'b0), .aload(1'b0), .sclr(1'b0), .sload(1'b0));
   end
   endgenerate
   wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule
`,"m9k_bb.v":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */
(* blackbox *)
module altsyncram(data_a, address_a, wren_a, rden_a, q_a, data_b, address_b,  wren_b, rden_b,
                  q_b, clock0, clock1, clocken0, clocken1, clocken2, clocken3, aclr0, aclr1,
                  addressstall_a, addressstall_b);

   parameter clock_enable_input_b          = "ALTERNATE";
   parameter clock_enable_input_a          = "ALTERNATE";
   parameter clock_enable_output_b         = "NORMAL";
   parameter clock_enable_output_a         = "NORMAL";
   parameter wrcontrol_aclr_a              = "NONE";
   parameter indata_aclr_a                 = "NONE";
   parameter address_aclr_a                = "NONE";
   parameter outdata_aclr_a                = "NONE";
   parameter outdata_reg_a                 = "UNREGISTERED";
   parameter operation_mode                = "SINGLE_PORT";
   parameter intended_device_family        = "MAX 10 FPGA";
   parameter outdata_reg_b                 = "UNREGISTERED";
   parameter lpm_type                      = "altsyncram";
   parameter init_type                     = "unused";
   parameter ram_block_type                = "AUTO";
   parameter lpm_hint                      = "ENABLE_RUNTIME_MOD=NO";
   parameter power_up_uninitialized        = "FALSE";
   parameter read_during_write_mode_port_a = "NEW_DATA_NO_NBE_READ";
   parameter width_byteena_a               = 1;
   parameter numwords_b                    = 0;
   parameter numwords_a                    = 0;
   parameter widthad_b                     = 1;
   parameter width_b                       = 1;
   parameter widthad_a                     = 1;
   parameter width_a                       = 1;

   // Port A declarations
   output [35:0] q_a;
   input [35:0]  data_a;
   input [7:0]   address_a;
   input         wren_a;
   input         rden_a;
   // Port B declarations
   output [35:0] q_b;
   input [35:0]  data_b;
   input [7:0]   address_b;
   input         wren_b;
   input         rden_b;
   // Control signals
   input         clock0, clock1;
   input         clocken0, clocken1, clocken2, clocken3;
   input         aclr0, aclr1;
   input         addressstall_a;
   input         addressstall_b;
   // TODO: Implement the correct simulation model

endmodule // altsyncram
`},cyclone10lp:{"cells_map.v":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */
// > c60k28 (Viacheslav, VT) [at] yandex [dot] com
// > Intel FPGA technology mapping. User must first simulate the generated \\
// > netlist before going to test it on board.

// Input buffer map
module \\$__inpad (input I, output O);
   cyclone10lp_io_ibuf _TECHMAP_REPLACE_ (.o(O), .i(I), .ibar(1'b0));
endmodule

// Output buffer map
module \\$__outpad (input I, output O);
   cyclone10lp_io_obuf _TECHMAP_REPLACE_ (.o(O), .i(I), .oe(1'b1));
endmodule

// LUT Map
/* 0 -> datac
 1 -> cin */
module \\$lut (A, Y);
   parameter WIDTH  = 0;
   parameter LUT    = 0;
   (* force_downto *)
   input [WIDTH-1:0] A;
   output            Y;
   generate
      if (WIDTH == 1) begin
	 assign Y = ~A[0]; // Not need to spend 1 logic cell for such an easy function
      end else
        if (WIDTH == 2) begin
           cyclone10lp_lcell_comb #(.lut_mask({4{LUT}}),
                                   .sum_lutc_input("datac")) _TECHMAP_REPLACE_ (.combout(Y),
                                                                                .dataa(A[0]),
                                                                                .datab(A[1]),
                                                                                .datac(1'b1),
                                                                                .datad(1'b1));
        end else
          if(WIDTH == 3) begin
	     cyclone10lp_lcell_comb #(.lut_mask({2{LUT}}),
                                     .sum_lutc_input("datac")) _TECHMAP_REPLACE_ (.combout(Y),
                                                                                  .dataa(A[0]),
                                                                                  .datab(A[1]),
                                                                                  .datac(A[2]),
                                                                                  .datad(1'b1));
          end else
            if(WIDTH == 4) begin
	       cyclone10lp_lcell_comb #(.lut_mask(LUT),
                                       .sum_lutc_input("datac")) _TECHMAP_REPLACE_ (.combout(Y),
                                                                                    .dataa(A[0]),
                                                                                    .datab(A[1]),
                                                                                    .datac(A[2]),
                                                                                    .datad(A[3]));
            end else
	             wire _TECHMAP_FAIL_ = 1;
   endgenerate

endmodule


`,"cells_sim.v":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */
module VCC (output V);
   assign V = 1'b1;
endmodule // VCC

module GND (output G);
   assign G = 1'b0;
endmodule // GND

/* Altera Cyclone 10 LP devices Input Buffer Primitive */
module cyclone10lp_io_ibuf
  (output o, input i, input ibar);
   assign ibar = ibar;
   assign o    = i;
endmodule // cyclone10lp_io_ibuf

/* Altera Cyclone 10 LP devices Output Buffer Primitive */
module cyclone10lp_io_obuf
  (output o, input i, input oe);
   assign o  = i;
   assign oe = oe;
endmodule // cyclone10lp_io_obuf

/* Altera Cyclone IV (E) 4-input non-fracturable LUT Primitive */
module cyclone10lp_lcell_comb
  (output combout, cout,
   input dataa, datab, datac, datad, cin);

   /* Internal parameters which define the behaviour
    of the LUT primitive.
    lut_mask define the lut function, can be expressed in 16-digit bin or hex.
    sum_lutc_input define the type of LUT (combinational | arithmetic).
    dont_touch for retiming || carry options.
    lpm_type for WYSIWYG */

   parameter lut_mask   = 16'hFFFF;
   parameter dont_touch = "off";
   parameter lpm_type   = "cyclone10lp_lcell_comb";
   parameter sum_lutc_input = "datac";

   reg [1:0]                        lut_type;
   reg                              cout_rt;
   reg                              combout_rt;
   wire                             dataa_w;
   wire                             datab_w;
   wire                             datac_w;
   wire                             datad_w;
   wire                             cin_w;

   assign dataa_w = dataa;
   assign datab_w = datab;
   assign datac_w = datac;
   assign datad_w = datad;

   function lut_data;
      input [15:0]                  mask;
      input                         dataa, datab, datac, datad;
      reg [7:0]                     s3;
      reg [3:0]                     s2;
      reg [1:0]                     s1;
      begin
         s3 = datad ? mask[15:8] : mask[7:0];
         s2 = datac ?   s3[7:4]  :   s3[3:0];
         s1 = datab ?   s2[3:2]  :   s2[1:0];
         lut_data = dataa ? s1[1] : s1[0];
      end

   endfunction

   initial begin
      if (sum_lutc_input == "datac") lut_type = 0;
      else
        if (sum_lutc_input == "cin")   lut_type = 1;
        else begin
           $error("Error in sum_lutc_input. Parameter %s is not a valid value.\\n", sum_lutc_input);
           $finish();
        end
   end

   always @(dataa_w or datab_w or datac_w or datad_w or cin_w) begin
      if (lut_type == 0) begin // logic function
         combout_rt = lut_data(lut_mask, dataa_w, datab_w,
                               datac_w, datad_w);
      end
      else if (lut_type == 1) begin // arithmetic function
         combout_rt = lut_data(lut_mask, dataa_w, datab_w,
                               cin_w, datad_w);
      end
      cout_rt = lut_data(lut_mask, dataa_w, datab_w, cin_w, 'b0);
   end

   assign combout = combout_rt & 1'b1;
   assign cout = cout_rt & 1'b1;

endmodule // cyclone10lp_lcell_comb

/* Altera D Flip-Flop Primitive */
module dffeas
  (output q,
   input d, clk, clrn, prn, ena,
   input asdata, aload, sclr, sload);

   // Timing simulation is not covered
   parameter power_up="dontcare";
   parameter is_wysiwyg="false";

   reg   q_tmp;
   wire  reset;
   reg [7:0] debug_net;

   assign reset       = (prn && sclr && ~clrn && ena);
   assign q           = q_tmp & 1'b1;

   always @(posedge clk, posedge aload) begin
      if(reset)        q_tmp <= 0;
      else q_tmp <= d;
   end
   assign q = q_tmp;

endmodule // dffeas
`},cycloneiv:{"cells_map.v":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */
// > c60k28 (Viacheslav, VT) [at] yandex [dot] com
// > Intel FPGA technology mapping. User must first simulate the generated \\
// > netlist before going to test it on board.

// Input buffer map
module \\$__inpad (input I, output O);
    cycloneiv_io_ibuf _TECHMAP_REPLACE_ (.o(O), .i(I), .ibar(1'b0));
endmodule

// Output buffer map
module \\$__outpad (input I, output O);
    cycloneiv_io_obuf _TECHMAP_REPLACE_ (.o(O), .i(I), .oe(1'b1));
endmodule

// LUT Map
/* 0 -> datac
   1 -> cin */
module \\$lut (A, Y);
   parameter WIDTH  = 0;
   parameter LUT    = 0;
   (* force_downto *)
   input [WIDTH-1:0] A;
   output            Y;
   generate
      if (WIDTH == 1) begin
	   assign Y = ~A[0]; // Not need to spend 1 logic cell for such an easy function
      end else
      if (WIDTH == 2) begin
           cycloneiv_lcell_comb #(.lut_mask({4{LUT}}), .sum_lutc_input("datac")) _TECHMAP_REPLACE_ (.combout(Y), .dataa(A[0]), .datab(A[1]), .datac(1'b1),.datad(1'b1));
      end else
      if(WIDTH == 3) begin
	   cycloneiv_lcell_comb #(.lut_mask({2{LUT}}), .sum_lutc_input("datac")) _TECHMAP_REPLACE_ (.combout(Y), .dataa(A[0]), .datab(A[1]), .datac(A[2]),.datad(1'b1));
      end else
      if(WIDTH == 4) begin
	   cycloneiv_lcell_comb #(.lut_mask(LUT), .sum_lutc_input("datac")) _TECHMAP_REPLACE_ (.combout(Y), .dataa(A[0]), .datab(A[1]), .datac(A[2]),.datad(A[3]));
      end else
	   wire _TECHMAP_FAIL_ = 1;
   endgenerate
endmodule //


`,"cells_sim.v":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

module VCC (output V);
   assign V = 1'b1;
endmodule // VCC

module GND (output G);
   assign G = 1'b0;
endmodule // GND

/* Altera Cyclone IV (GX) devices Input Buffer Primitive */
module cycloneiv_io_ibuf
  (output o, input i, input ibar);
   assign ibar = ibar;
   assign o    = i;
endmodule // fiftyfivenm_io_ibuf

/* Altera Cyclone IV (GX)  devices Output Buffer Primitive */
module cycloneiv_io_obuf
  (output o, input i, input oe);
   assign o  = i;
   assign oe = oe;
endmodule // fiftyfivenm_io_obuf

/* Altera Cyclone IV (GX) 4-input non-fracturable LUT Primitive */
module cycloneiv_lcell_comb
  (output combout, cout,
   input dataa, datab, datac, datad, cin);

   /* Internal parameters which define the behaviour
    of the LUT primitive.
    lut_mask define the lut function, can be expressed in 16-digit bin or hex.
    sum_lutc_input define the type of LUT (combinational | arithmetic).
    dont_touch for retiming || carry options.
    lpm_type for WYSIWYG */

   parameter lut_mask = 16'hFFFF;
   parameter dont_touch = "off";
   parameter lpm_type = "cycloneiv_lcell_comb";
   parameter sum_lutc_input = "datac";

   reg [1:0] lut_type;
   reg       cout_rt;
   reg       combout_rt;
   wire      dataa_w;
   wire      datab_w;
   wire      datac_w;
   wire      datad_w;
   wire      cin_w;

   assign dataa_w = dataa;
   assign datab_w = datab;
   assign datac_w = datac;
   assign datad_w = datad;

   function lut_data;
      input [15:0] mask;
      input        dataa, datab, datac, datad;
      reg [7:0]    s3;
      reg [3:0]    s2;
      reg [1:0]    s1;
      begin
         s3 = datad ? mask[15:8] : mask[7:0];
         s2 = datac ?   s3[7:4]  :   s3[3:0];
         s1 = datab ?   s2[3:2]  :   s2[1:0];
         lut_data = dataa ? s1[1] : s1[0];
      end

   endfunction

   initial begin
      if (sum_lutc_input == "datac") lut_type = 0;
      else
        if (sum_lutc_input == "cin")   lut_type = 1;
        else begin
           $error("Error in sum_lutc_input. Parameter %s is not a valid value.\\n", sum_lutc_input);
           $finish();
        end
   end

   always @(dataa_w or datab_w or datac_w or datad_w or cin_w) begin
      if (lut_type == 0) begin // logic function
         combout_rt = lut_data(lut_mask, dataa_w, datab_w,
                               datac_w, datad_w);
      end
      else if (lut_type == 1) begin // arithmetic function
         combout_rt = lut_data(lut_mask, dataa_w, datab_w,
                               cin_w, datad_w);
      end
      cout_rt = lut_data(lut_mask, dataa_w, datab_w, cin_w, 'b0);
   end

   assign combout = combout_rt & 1'b1;
   assign cout = cout_rt & 1'b1;

endmodule // cycloneiv_lcell_comb

/* Altera D Flip-Flop Primitive */
module dffeas
  (output q,
   input d, clk, clrn, prn, ena,
   input asdata, aload, sclr, sload);

   // Timing simulation is not covered
   parameter power_up="dontcare";
   parameter is_wysiwyg="false";

   reg   q_tmp;
   wire  reset;
   reg [7:0] debug_net;

   assign reset       = (prn && sclr && ~clrn && ena);
   assign q           = q_tmp & 1'b1;

   always @(posedge clk, posedge aload) begin
      if(reset)        q_tmp <= 0;
      else q_tmp <= d;
   end
   assign q = q_tmp;

endmodule // dffeas

/* Cyclone IV GX altpll clearbox model */
(* blackbox *)
module cycloneiv_pll
  (inclk,
   fbin,
   fbout,
   clkswitch,
   areset,
   pfdena,
   scanclk,
   scandata,
   scanclkena,
   configupdate,
   clk,
   phasecounterselect,
   phaseupdown,
   phasestep,
   clkbad,
   activeclock,
   locked,
   scandataout,
   scandone,
   phasedone,
   vcooverrange,
   vcounderrange,
   fref,
   icdrclk);

   parameter operation_mode                = "normal";
   parameter pll_type                      = "auto";
   parameter compensate_clock              = "clock0";
   parameter inclk0_input_frequency        = 0;
   parameter inclk1_input_frequency        = 0;
   parameter self_reset_on_loss_lock       = "off";
   parameter switch_over_type              = "auto";
   parameter switch_over_counter           = 1;
   parameter enable_switch_over_counter    = "off";
   parameter bandwidth                     = 0;
   parameter bandwidth_type                = "auto";
   parameter use_dc_coupling               = "false";
   parameter lock_high = 0;
   parameter lock_low = 0;
   parameter lock_window_ui                = "0.05";
   parameter test_bypass_lock_detect       = "off";
   parameter clk0_output_frequency         = 0;
   parameter clk0_multiply_by              = 0;
   parameter clk0_divide_by                = 0;
   parameter clk0_phase_shift              = "0";
   parameter clk0_duty_cycle               = 50;
   parameter clk1_output_frequency         = 0;
   parameter clk1_multiply_by              = 0;
   parameter clk1_divide_by                = 0;
   parameter clk1_phase_shift              = "0";
   parameter clk1_duty_cycle               = 50;
   parameter clk2_output_frequency         = 0;
   parameter clk2_multiply_by              = 0;
   parameter clk2_divide_by                = 0;
   parameter clk2_phase_shift              = "0";
   parameter clk2_duty_cycle               = 50;
   parameter clk3_output_frequency         = 0;
   parameter clk3_multiply_by              = 0;
   parameter clk3_divide_by                = 0;
   parameter clk3_phase_shift              = "0";
   parameter clk3_duty_cycle               = 50;
   parameter clk4_output_frequency         = 0;
   parameter clk4_multiply_by              = 0;
   parameter clk4_divide_by                = 0;
   parameter clk4_phase_shift              = "0";
   parameter clk4_duty_cycle               = 50;
   parameter pfd_min                       = 0;
   parameter pfd_max                       = 0;
   parameter vco_min                       = 0;
   parameter vco_max                       = 0;
   parameter vco_center                    = 0;
   // Advanced user parameters
   parameter m_initial = 1;
   parameter m = 0;
   parameter n = 1;
   parameter c0_high = 1;
   parameter c0_low = 1;
   parameter c0_initial = 1;
   parameter c0_mode = "bypass";
   parameter c0_ph = 0;
   parameter c1_high = 1;
   parameter c1_low = 1;
   parameter c1_initial = 1;
   parameter c1_mode = "bypass";
   parameter c1_ph = 0;
   parameter c2_high = 1;
   parameter c2_low = 1;
   parameter c2_initial = 1;
   parameter c2_mode = "bypass";
   parameter c2_ph = 0;
   parameter c3_high = 1;
   parameter c3_low = 1;
   parameter c3_initial = 1;
   parameter c3_mode = "bypass";
   parameter c3_ph = 0;
   parameter c4_high = 1;
   parameter c4_low = 1;
   parameter c4_initial = 1;
   parameter c4_mode = "bypass";
   parameter c4_ph = 0;
   parameter m_ph = 0;
   parameter clk0_counter = "unused";
   parameter clk1_counter = "unused";
   parameter clk2_counter = "unused";
   parameter clk3_counter = "unused";
   parameter clk4_counter = "unused";
   parameter c1_use_casc_in = "off";
   parameter c2_use_casc_in = "off";
   parameter c3_use_casc_in = "off";
   parameter c4_use_casc_in = "off";
   parameter m_test_source  = -1;
   parameter c0_test_source = -1;
   parameter c1_test_source = -1;
   parameter c2_test_source = -1;
   parameter c3_test_source = -1;
   parameter c4_test_source = -1;
   parameter vco_multiply_by = 0;
   parameter vco_divide_by = 0;
   parameter vco_post_scale = 1;
   parameter vco_frequency_control = "auto";
   parameter vco_phase_shift_step = 0;
   parameter charge_pump_current = 10;
   parameter loop_filter_r = "1.0";
   parameter loop_filter_c = 0;
   parameter pll_compensation_delay = 0;
   parameter lpm_type = "cycloneiv_pll";
   parameter phase_counter_select_width = 3;

   input [1:0] inclk;
   input       fbin;
   input       clkswitch;
   input       areset;
   input       pfdena;
   input [phase_counter_select_width - 1:0] phasecounterselect;
   input                                    phaseupdown;
   input                                    phasestep;
   input                                    scanclk;
   input                                    scanclkena;
   input                                    scandata;
   input                                    configupdate;

   output [4:0]                             clk;
   output [1:0]                             clkbad;
   output                                   activeclock;
   output                                   locked;
   output                                   scandataout;
   output                                   scandone;
   output                                   fbout;
   output                                   phasedone;
   output                                   vcooverrange;
   output                                   vcounderrange;
   output                                   fref;
   output                                   icdrclk;

endmodule // cycloneive_pll


`},cycloneive:{"cells_map.v":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */
// > c60k28 (Viacheslav, VT) [at] yandex [dot] com
// > Intel FPGA technology mapping. User must first simulate the generated \\
// > netlist before going to test it on board.

// Input buffer map
module \\$__inpad (input I, output O);
   cycloneive_io_ibuf _TECHMAP_REPLACE_ (.o(O), .i(I), .ibar(1'b0));
endmodule

// Output buffer map
module \\$__outpad (input I, output O);
   cycloneive_io_obuf _TECHMAP_REPLACE_ (.o(O), .i(I), .oe(1'b1));
endmodule

// LUT Map
/* 0 -> datac
 1 -> cin */
module \\$lut (A, Y);
   parameter WIDTH  = 0;
   parameter LUT    = 0;
   (* force_downto *)
   input [WIDTH-1:0] A;
   output            Y;
   generate
      if (WIDTH == 1) begin
	 assign Y = ~A[0]; // Not need to spend 1 logic cell for such an easy function
      end else
        if (WIDTH == 2) begin
           cycloneive_lcell_comb #(.lut_mask({4{LUT}}),
                                   .sum_lutc_input("datac")) _TECHMAP_REPLACE_ (.combout(Y),
                                                                                .dataa(A[0]),
                                                                                .datab(A[1]),
                                                                                .datac(1'b1),
                                                                                .datad(1'b1));
        end else
          if(WIDTH == 3) begin
	     cycloneive_lcell_comb #(.lut_mask({2{LUT}}),
                                     .sum_lutc_input("datac")) _TECHMAP_REPLACE_ (.combout(Y),
                                                                                  .dataa(A[0]),
                                                                                  .datab(A[1]),
                                                                                  .datac(A[2]),
                                                                                  .datad(1'b1));
          end else
            if(WIDTH == 4) begin
	       cycloneive_lcell_comb #(.lut_mask(LUT),
                                       .sum_lutc_input("datac")) _TECHMAP_REPLACE_ (.combout(Y),
                                                                                    .dataa(A[0]),
                                                                                    .datab(A[1]),
                                                                                    .datac(A[2]),
                                                                                    .datad(A[3]));
            end else
	             wire _TECHMAP_FAIL_ = 1;
   endgenerate

endmodule


`,"cells_sim.v":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */
module VCC (output V);
   assign V = 1'b1;
endmodule // VCC

module GND (output G);
   assign G = 1'b0;
endmodule // GND

/* Altera Cyclone IV (E) devices Input Buffer Primitive */
module cycloneive_io_ibuf
  (output o, input i, input ibar);
   assign ibar = ibar;
   assign o    = i;
endmodule // fiftyfivenm_io_ibuf

/* Altera Cyclone IV (E)  devices Output Buffer Primitive */
module cycloneive_io_obuf
  (output o, input i, input oe);
   assign o  = i;
   assign oe = oe;
endmodule // fiftyfivenm_io_obuf

/* Altera Cyclone IV (E) 4-input non-fracturable LUT Primitive */
module cycloneive_lcell_comb
  (output combout, cout,
   input dataa, datab, datac, datad, cin);

   /* Internal parameters which define the behaviour
    of the LUT primitive.
    lut_mask define the lut function, can be expressed in 16-digit bin or hex.
    sum_lutc_input define the type of LUT (combinational | arithmetic).
    dont_touch for retiming || carry options.
    lpm_type for WYSIWYG */

   parameter lut_mask   = 16'hFFFF;
   parameter dont_touch = "off";
   parameter lpm_type   = "cycloneive_lcell_comb";
   parameter sum_lutc_input = "datac";

   reg [1:0]                        lut_type;
   reg                              cout_rt;
   reg                              combout_rt;
   wire                             dataa_w;
   wire                             datab_w;
   wire                             datac_w;
   wire                             datad_w;
   wire                             cin_w;

   assign dataa_w = dataa;
   assign datab_w = datab;
   assign datac_w = datac;
   assign datad_w = datad;

   function lut_data;
      input [15:0]                  mask;
      input                         dataa, datab, datac, datad;
      reg [7:0]                     s3;
      reg [3:0]                     s2;
      reg [1:0]                     s1;
      begin
         s3 = datad ? mask[15:8] : mask[7:0];
         s2 = datac ?   s3[7:4]  :   s3[3:0];
         s1 = datab ?   s2[3:2]  :   s2[1:0];
         lut_data = dataa ? s1[1] : s1[0];
      end

   endfunction

   initial begin
      if (sum_lutc_input == "datac") lut_type = 0;
      else
        if (sum_lutc_input == "cin")   lut_type = 1;
        else begin
           $error("Error in sum_lutc_input. Parameter %s is not a valid value.\\n", sum_lutc_input);
           $finish();
        end
   end

   always @(dataa_w or datab_w or datac_w or datad_w or cin_w) begin
      if (lut_type == 0) begin // logic function
         combout_rt = lut_data(lut_mask, dataa_w, datab_w,
                               datac_w, datad_w);
      end
      else if (lut_type == 1) begin // arithmetic function
         combout_rt = lut_data(lut_mask, dataa_w, datab_w,
                               cin_w, datad_w);
      end
      cout_rt = lut_data(lut_mask, dataa_w, datab_w, cin_w, 'b0);
   end

   assign combout = combout_rt & 1'b1;
   assign cout = cout_rt & 1'b1;

endmodule // cycloneive_lcell_comb

/* Altera D Flip-Flop Primitive */
module dffeas
  (output q,
   input d, clk, clrn, prn, ena,
   input asdata, aload, sclr, sload);

   // Timing simulation is not covered
   parameter power_up="dontcare";
   parameter is_wysiwyg="false";

   reg   q_tmp;
   wire  reset;
   reg [7:0] debug_net;

   assign reset       = (prn && sclr && ~clrn && ena);
   assign q           = q_tmp & 1'b1;

   always @(posedge clk, posedge aload) begin
      if(reset)        q_tmp <= 0;
      else q_tmp <= d;
   end
   assign q = q_tmp;

endmodule // dffeas

/* Cyclone IV E altpll clearbox model */
(* blackbox *)
module cycloneive_pll
  (inclk,
   fbin,
   fbout,
   clkswitch,
   areset,
   pfdena,
   scanclk,
   scandata,
   scanclkena,
   configupdate,
   clk,
   phasecounterselect,
   phaseupdown,
   phasestep,
   clkbad,
   activeclock,
   locked,
   scandataout,
   scandone,
   phasedone,
   vcooverrange,
   vcounderrange);

   parameter operation_mode                = "normal";
   parameter pll_type                      = "auto";
   parameter compensate_clock              = "clock0";
   parameter inclk0_input_frequency        = 0;
   parameter inclk1_input_frequency        = 0;
   parameter self_reset_on_loss_lock       = "off";
   parameter switch_over_type              = "auto";
   parameter switch_over_counter           = 1;
   parameter enable_switch_over_counter    = "off";
   parameter bandwidth                     = 0;
   parameter bandwidth_type                = "auto";
   parameter use_dc_coupling               = "false";
   parameter lock_high = 0;
   parameter lock_low = 0;
   parameter lock_window_ui                = "0.05";
   parameter test_bypass_lock_detect       = "off";
   parameter clk0_output_frequency         = 0;
   parameter clk0_multiply_by              = 0;
   parameter clk0_divide_by                = 0;
   parameter clk0_phase_shift              = "0";
   parameter clk0_duty_cycle               = 50;
   parameter clk1_output_frequency         = 0;
   parameter clk1_multiply_by              = 0;
   parameter clk1_divide_by                = 0;
   parameter clk1_phase_shift              = "0";
   parameter clk1_duty_cycle               = 50;
   parameter clk2_output_frequency         = 0;
   parameter clk2_multiply_by              = 0;
   parameter clk2_divide_by                = 0;
   parameter clk2_phase_shift              = "0";
   parameter clk2_duty_cycle               = 50;
   parameter clk3_output_frequency         = 0;
   parameter clk3_multiply_by              = 0;
   parameter clk3_divide_by                = 0;
   parameter clk3_phase_shift              = "0";
   parameter clk3_duty_cycle               = 50;
   parameter clk4_output_frequency         = 0;
   parameter clk4_multiply_by              = 0;
   parameter clk4_divide_by                = 0;
   parameter clk4_phase_shift              = "0";
   parameter clk4_duty_cycle               = 50;
   parameter pfd_min                       = 0;
   parameter pfd_max                       = 0;
   parameter vco_min                       = 0;
   parameter vco_max                       = 0;
   parameter vco_center                    = 0;
   // Advanced user parameters
   parameter m_initial = 1;
   parameter m = 0;
   parameter n = 1;
   parameter c0_high = 1;
   parameter c0_low = 1;
   parameter c0_initial = 1;
   parameter c0_mode = "bypass";
   parameter c0_ph = 0;
   parameter c1_high = 1;
   parameter c1_low = 1;
   parameter c1_initial = 1;
   parameter c1_mode = "bypass";
   parameter c1_ph = 0;
   parameter c2_high = 1;
   parameter c2_low = 1;
   parameter c2_initial = 1;
   parameter c2_mode = "bypass";
   parameter c2_ph = 0;
   parameter c3_high = 1;
   parameter c3_low = 1;
   parameter c3_initial = 1;
   parameter c3_mode = "bypass";
   parameter c3_ph = 0;
   parameter c4_high = 1;
   parameter c4_low = 1;
   parameter c4_initial = 1;
   parameter c4_mode = "bypass";
   parameter c4_ph = 0;
   parameter m_ph = 0;
   parameter clk0_counter = "unused";
   parameter clk1_counter = "unused";
   parameter clk2_counter = "unused";
   parameter clk3_counter = "unused";
   parameter clk4_counter = "unused";
   parameter c1_use_casc_in = "off";
   parameter c2_use_casc_in = "off";
   parameter c3_use_casc_in = "off";
   parameter c4_use_casc_in = "off";
   parameter m_test_source  = -1;
   parameter c0_test_source = -1;
   parameter c1_test_source = -1;
   parameter c2_test_source = -1;
   parameter c3_test_source = -1;
   parameter c4_test_source = -1;
   parameter vco_multiply_by = 0;
   parameter vco_divide_by = 0;
   parameter vco_post_scale = 1;
   parameter vco_frequency_control = "auto";
   parameter vco_phase_shift_step = 0;
   parameter charge_pump_current = 10;
   parameter loop_filter_r = "1.0";
   parameter loop_filter_c = 0;
   parameter pll_compensation_delay = 0;
   parameter lpm_type = "cycloneive_pll";
   parameter phase_counter_select_width = 3;

   input [1:0] inclk;
   input       fbin;
   input       clkswitch;
   input       areset;
   input       pfdena;
   input [phase_counter_select_width - 1:0] phasecounterselect;
   input                                    phaseupdown;
   input                                    phasestep;
   input                                    scanclk;
   input                                    scanclkena;
   input                                    scandata;
   input                                    configupdate;

   output [4:0]                             clk;
   output [1:0]                             clkbad;
   output                                   activeclock;
   output                                   locked;
   output                                   scandataout;
   output                                   scandone;
   output                                   fbout;
   output                                   phasedone;
   output                                   vcooverrange;
   output                                   vcounderrange;

endmodule // cycloneive_pll
`},max10:{"cells_map.v":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */
// > c60k28 (Viacheslav, VT) [at] yandex [dot] com
// > Intel FPGA technology mapping. User must first simulate the generated \\
// > netlist before going to test it on board.

// Input buffer map
module \\$__inpad (input I, output O);
   fiftyfivenm_io_ibuf _TECHMAP_REPLACE_ (.o(O), .i(I), .ibar(1'b0));
endmodule

// Output buffer map
module \\$__outpad (input I, output O);
   fiftyfivenm_io_obuf _TECHMAP_REPLACE_ (.o(O), .i(I), .oe(1'b1));
endmodule

// LUT Map
/* 0 -> datac
   1 -> cin */
module \\$lut (A, Y);
   parameter WIDTH  = 0;
   parameter LUT    = 0;
   (* force_downto *)
   input [WIDTH-1:0] A;
   output            Y;
   generate
      if (WIDTH == 1) begin
	   assign Y = ~A[0]; // Not need to spend 1 logic cell for such an easy function
      end else
      if (WIDTH == 2) begin
           fiftyfivenm_lcell_comb #(.lut_mask({4{LUT}}), .sum_lutc_input("datac")) _TECHMAP_REPLACE_ (.combout(Y), .dataa(A[0]), .datab(A[1]), .datac(1'b1),.datad(1'b1));
      end else
      if(WIDTH == 3) begin
	      fiftyfivenm_lcell_comb #(.lut_mask({2{LUT}}), .sum_lutc_input("datac")) _TECHMAP_REPLACE_ (.combout(Y), .dataa(A[0]), .datab(A[1]), .datac(A[2]),.datad(1'b1));
      end else
      if(WIDTH == 4) begin
         fiftyfivenm_lcell_comb #(.lut_mask(LUT), .sum_lutc_input("datac")) _TECHMAP_REPLACE_ (.combout(Y), .dataa(A[0]), .datab(A[1]), .datac(A[2]),.datad(A[3]));
      end else
	   wire _TECHMAP_FAIL_ = 1;
   endgenerate
endmodule //


`,"cells_sim.v":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

module VCC (output V);
   assign V = 1'b1;
endmodule // VCC

module GND (output G);
   assign G = 1'b0;
endmodule // GND

/* Altera MAX10 devices Input Buffer Primitive */
module fiftyfivenm_io_ibuf
  (output o, input i, input ibar);
   assign ibar = ibar;
   assign o    = i;
endmodule // fiftyfivenm_io_ibuf

/* Altera MAX10 devices Output Buffer Primitive */
module fiftyfivenm_io_obuf
  (output o, input i, input oe);
   assign o  = i;
   assign oe = oe;
endmodule // fiftyfivenm_io_obuf

/* Altera MAX10 4-input non-fracturable LUT Primitive */
module fiftyfivenm_lcell_comb
  (output combout, cout,
   input dataa, datab, datac, datad, cin);

   /* Internal parameters which define the behaviour
    of the LUT primitive.
    lut_mask define the lut function, can be expressed in 16-digit bin or hex.
    sum_lutc_input define the type of LUT (combinational | arithmetic).
    dont_touch for retiming || carry options.
    lpm_type for WYSIWYG */

   parameter lut_mask = 16'hFFFF;
   parameter dont_touch = "off";
   parameter lpm_type = "fiftyfivenm_lcell_comb";
   parameter sum_lutc_input = "datac";

   reg [1:0] lut_type;
   reg       cout_rt;
   reg       combout_rt;
   wire      dataa_w;
   wire      datab_w;
   wire      datac_w;
   wire      datad_w;
   wire      cin_w;

   assign dataa_w = dataa;
   assign datab_w = datab;
   assign datac_w = datac;
   assign datad_w = datad;

   function lut_data;
      input [15:0] mask;
      input        dataa, datab, datac, datad;
      reg [7:0]    s3;
      reg [3:0]    s2;
      reg [1:0]    s1;
      begin
         s3 = datad ? mask[15:8] : mask[7:0];
         s2 = datac ?   s3[7:4]  :   s3[3:0];
         s1 = datab ?   s2[3:2]  :   s2[1:0];
         lut_data = dataa ? s1[1] : s1[0];
      end

   endfunction

   initial begin
      if (sum_lutc_input == "datac") lut_type = 0;
      else
        if (sum_lutc_input == "cin")   lut_type = 1;
        else begin
           $error("Error in sum_lutc_input. Parameter %s is not a valid value.\\n", sum_lutc_input);
           $finish();
        end
   end

   always @(dataa_w or datab_w or datac_w or datad_w or cin_w) begin
      if (lut_type == 0) begin // logic function
         combout_rt = lut_data(lut_mask, dataa_w, datab_w,
                               datac_w, datad_w);
      end
      else if (lut_type == 1) begin // arithmetic function
         combout_rt = lut_data(lut_mask, dataa_w, datab_w,
                               cin_w, datad_w);
      end
      cout_rt = lut_data(lut_mask, dataa_w, datab_w, cin_w, 'b0);
   end

   assign combout = combout_rt & 1'b1;
   assign cout = cout_rt & 1'b1;

endmodule // fiftyfivenm_lcell_comb

/* Altera D Flip-Flop Primitive */
module dffeas
  (output q,
   input d, clk, clrn, prn, ena,
   input asdata, aload, sclr, sload);

   // Timing simulation is not covered
   parameter power_up="dontcare";
   parameter is_wysiwyg="false";

   reg   q_tmp;
   wire  reset;
   reg [7:0] debug_net;

   assign reset       = (prn && sclr && ~clrn && ena);
   assign q           = q_tmp & 1'b1;

   always @(posedge clk, posedge aload) begin
      if(reset)        q_tmp <= 0;
      else q_tmp <= d;
   end
   assign q = q_tmp;

endmodule // dffeas

/* MAX10 altpll clearbox model */
(* blackbox *)
module fiftyfivenm_pll
  (inclk,
   fbin,
   fbout,
   clkswitch,
   areset,
   pfdena,
   scanclk,
   scandata,
   scanclkena,
   configupdate,
   clk,
   phasecounterselect,
   phaseupdown,
   phasestep,
   clkbad,
   activeclock,
   locked,
   scandataout,
   scandone,
   phasedone,
   vcooverrange,
   vcounderrange);

   parameter operation_mode                = "normal";
   parameter pll_type                      = "auto";
   parameter compensate_clock              = "clock0";
   parameter inclk0_input_frequency        = 0;
   parameter inclk1_input_frequency        = 0;
   parameter self_reset_on_loss_lock       = "off";
   parameter switch_over_type              = "auto";
   parameter switch_over_counter           = 1;
   parameter enable_switch_over_counter    = "off";
   parameter bandwidth                     = 0;
   parameter bandwidth_type                = "auto";
   parameter use_dc_coupling               = "false";
   parameter lock_high = 0;
   parameter lock_low = 0;
   parameter lock_window_ui                = "0.05";
   parameter test_bypass_lock_detect       = "off";
   parameter clk0_output_frequency         = 0;
   parameter clk0_multiply_by              = 0;
   parameter clk0_divide_by                = 0;
   parameter clk0_phase_shift              = "0";
   parameter clk0_duty_cycle               = 50;
   parameter clk1_output_frequency         = 0;
   parameter clk1_multiply_by              = 0;
   parameter clk1_divide_by                = 0;
   parameter clk1_phase_shift              = "0";
   parameter clk1_duty_cycle               = 50;
   parameter clk2_output_frequency         = 0;
   parameter clk2_multiply_by              = 0;
   parameter clk2_divide_by                = 0;
   parameter clk2_phase_shift              = "0";
   parameter clk2_duty_cycle               = 50;
   parameter clk3_output_frequency         = 0;
   parameter clk3_multiply_by              = 0;
   parameter clk3_divide_by                = 0;
   parameter clk3_phase_shift              = "0";
   parameter clk3_duty_cycle               = 50;
   parameter clk4_output_frequency         = 0;
   parameter clk4_multiply_by              = 0;
   parameter clk4_divide_by                = 0;
   parameter clk4_phase_shift              = "0";
   parameter clk4_duty_cycle               = 50;
   parameter pfd_min                       = 0;
   parameter pfd_max                       = 0;
   parameter vco_min                       = 0;
   parameter vco_max                       = 0;
   parameter vco_center                    = 0;
   // Advanced user parameters
   parameter m_initial = 1;
   parameter m = 0;
   parameter n = 1;
   parameter c0_high = 1;
   parameter c0_low = 1;
   parameter c0_initial = 1;
   parameter c0_mode = "bypass";
   parameter c0_ph = 0;
   parameter c1_high = 1;
   parameter c1_low = 1;
   parameter c1_initial = 1;
   parameter c1_mode = "bypass";
   parameter c1_ph = 0;
   parameter c2_high = 1;
   parameter c2_low = 1;
   parameter c2_initial = 1;
   parameter c2_mode = "bypass";
   parameter c2_ph = 0;
   parameter c3_high = 1;
   parameter c3_low = 1;
   parameter c3_initial = 1;
   parameter c3_mode = "bypass";
   parameter c3_ph = 0;
   parameter c4_high = 1;
   parameter c4_low = 1;
   parameter c4_initial = 1;
   parameter c4_mode = "bypass";
   parameter c4_ph = 0;
   parameter m_ph = 0;
   parameter clk0_counter = "unused";
   parameter clk1_counter = "unused";
   parameter clk2_counter = "unused";
   parameter clk3_counter = "unused";
   parameter clk4_counter = "unused";
   parameter c1_use_casc_in = "off";
   parameter c2_use_casc_in = "off";
   parameter c3_use_casc_in = "off";
   parameter c4_use_casc_in = "off";
   parameter m_test_source  = -1;
   parameter c0_test_source = -1;
   parameter c1_test_source = -1;
   parameter c2_test_source = -1;
   parameter c3_test_source = -1;
   parameter c4_test_source = -1;
   parameter vco_multiply_by = 0;
   parameter vco_divide_by = 0;
   parameter vco_post_scale = 1;
   parameter vco_frequency_control = "auto";
   parameter vco_phase_shift_step = 0;
   parameter charge_pump_current = 10;
   parameter loop_filter_r = "1.0";
   parameter loop_filter_c = 0;
   parameter pll_compensation_delay = 0;
   parameter lpm_type = "fiftyfivenm_pll";
   parameter phase_counter_select_width = 3;

   input [1:0] inclk;
   input       fbin;
   input       clkswitch;
   input       areset;
   input       pfdena;
   input [phase_counter_select_width - 1:0] phasecounterselect;
   input                                    phaseupdown;
   input                                    phasestep;
   input                                    scanclk;
   input                                    scanclkena;
   input                                    scandata;
   input                                    configupdate;
   output [4:0]                             clk;
   output [1:0]                             clkbad;
   output                                   activeclock;
   output                                   locked;
   output                                   scandataout;
   output                                   scandone;
   output                                   fbout;
   output                                   phasedone;
   output                                   vcooverrange;
   output                                   vcounderrange;

endmodule // cycloneive_pll
`}},intel_alm:{common:{"abc9_map.v":`// This file exists to map purely-synchronous flops to ABC9 flops, while 
// mapping flops with asynchronous-clear as boxes, this is because ABC9 
// doesn't support asynchronous-clear flops in sequential synthesis.

module MISTRAL_FF(
    input DATAIN, CLK, ACLR, ENA, SCLR, SLOAD, SDATA,
    output reg Q
);

parameter _TECHMAP_CONSTMSK_ACLR_ = 1'b0;

// If the async-clear is constant, we assume it's disabled.
if (_TECHMAP_CONSTMSK_ACLR_ != 1'b0)
    $__MISTRAL_FF_SYNCONLY _TECHMAP_REPLACE_ (.DATAIN(DATAIN), .CLK(CLK), .ENA(ENA), .SCLR(SCLR), .SLOAD(SLOAD), .SDATA(SDATA), .Q(Q));
else
    wire _TECHMAP_FAIL_ = 1;

endmodule
`,"abc9_model.v":`// This is a purely-synchronous flop, that ABC9 can use for sequential synthesis.
(* abc9_flop, lib_whitebox *)
module $__MISTRAL_FF_SYNCONLY (
    input DATAIN, CLK, ENA, SCLR, SLOAD, SDATA,
    output reg Q
);

MISTRAL_FF ff (.DATAIN(DATAIN), .CLK(CLK), .ENA(ENA), .ACLR(1'b1), .SCLR(SCLR), .SLOAD(SLOAD), .SDATA(SDATA), .Q(Q));

endmodule
`,"abc9_unmap.v":`// After performing sequential synthesis, map the synchronous flops back to
// standard MISTRAL_FF flops.

module $__MISTRAL_FF_SYNCONLY (
    input DATAIN, CLK, ENA, SCLR, SLOAD, SDATA,
    output reg Q
);

MISTRAL_FF _TECHMAP_REPLACE_ (.DATAIN(DATAIN), .CLK(CLK), .ACLR(1'b1), .ENA(ENA), .SCLR(SCLR), .SLOAD(SLOAD), .SDATA(SDATA), .Q(Q));

endmodule
`,"alm_map.v":`module \\$lut (A, Y);

parameter WIDTH = 1;
parameter LUT = 0;

(* force_downto *)
input [WIDTH-1:0] A;
output Y;

generate
    if (WIDTH == 1) begin
        generate
            if (LUT == 2'b00) begin
                assign Y = 1'b0;
            end
            else if (LUT == 2'b01) begin
                MISTRAL_NOT _TECHMAP_REPLACE_(
                    .A(A[0]), .Q(Y)
                );
            end
            else if (LUT == 2'b10) begin
                assign Y = A;
            end
            else if (LUT == 2'b11) begin
                assign Y = 1'b1;
            end
        endgenerate
    end else
    if (WIDTH == 2) begin
        MISTRAL_ALUT2 #(.LUT(LUT)) _TECHMAP_REPLACE_(
            .A(A[0]), .B(A[1]), .Q(Y)
        );
    end else
    if (WIDTH == 3) begin
        MISTRAL_ALUT3 #(.LUT(LUT)) _TECHMAP_REPLACE_(
            .A(A[0]), .B(A[1]), .C(A[2]), .Q(Y)
        );
    end else
    if (WIDTH == 4) begin
        MISTRAL_ALUT4 #(.LUT(LUT)) _TECHMAP_REPLACE_(
            .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]), .Q(Y)
        );
    end else
    if (WIDTH == 5) begin
        MISTRAL_ALUT5 #(.LUT(LUT)) _TECHMAP_REPLACE_ (
            .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]), .E(A[4]), .Q(Y)
        );
    end else
    if (WIDTH == 6) begin
        MISTRAL_ALUT6 #(.LUT(LUT)) _TECHMAP_REPLACE_ (
            .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]), .E(A[4]), .F(A[5]), .Q(Y)
        );
    end else begin
        wire _TECHMAP_FAIL_ = 1'b1;
    end
endgenerate
endmodule
`,"alm_sim.v":`// The core logic primitive of the Cyclone V is the Adaptive Logic Module
// (ALM). Each ALM is made up of an 8-input, 2-output look-up table, covered
// in this file, connected to combinational outputs, a carry chain, and four
// D flip-flops (which are covered as MISTRAL_FF in dff_sim.v).
//
// The ALM is vertically symmetric, so I find it helps to think in terms of
// half-ALMs, as that's predominantly the unit that synth_intel_alm uses.
//
// ALMs are quite flexible, having multiple modes.
//
// Normal (combinational) mode
// ---------------------------
// The ALM can implement:
// - a single 6-input function (with the other inputs usable for flip-flop access)
// - two 5-input functions that share two inputs
// - a 5-input and a 4-input function that share one input
// - a 5-input and a 3-or-less-input function that share no inputs
// - two 4-or-less-input functions that share no inputs
//
// Normal-mode functions are represented as MISTRAL_ALUTN cells with N inputs.
// It would be possible to represent a normal mode function as a single cell -
// the vendor cyclone{v,10gx}_lcell_comb cell does exactly that - but I felt
// it was more user-friendly to print out the specific function sizes
// separately.
//
// With the exception of MISTRAL_ALUT6, you can think of two normal-mode cells
// fitting inside a single ALM.
//
// Extended (7-input) mode
// -----------------------
// The ALM can also fit a 7-input function made of two 5-input functions that
// share four inputs, multiplexed by another input.
//
// Because this can't accept arbitrary 7-input functions, Yosys can't handle
// it, so it doesn't have a cell, but I would likely call it MISTRAL_ALUT7(E?)
// if it did, and it would take up a full ALM.
//
// It might be possible to add an extraction pass to examine all ALUT5 cells
// that feed into ALUT3 cells to see if they can be combined into an extended
// ALM, but I don't think it will be worth it.
//
// Arithmetic mode
// ---------------
// In arithmetic mode, each half-ALM uses its carry chain to perform fast addition
// of two four-input functions that share three inputs. Oddly, the result of
// one of the functions is inverted before being added (you can see this as
// the dot on a full-adder input of Figure 1-8 in the Handbook).
//
// The cell for an arithmetic-mode half-ALM is MISTRAL_ALM_ARITH. One idea
// I've had (or rather was suggested by mwk) is that functions that feed into
// arithmetic-mode cells could be packed directly into the arithmetic-mode
// cell as a function, which reduces the number of ALMs needed.
//
// Shared arithmetic mode
// ----------------------
// Shared arithmetic mode looks a lot like arithmetic mode, but here the
// output of every other four-input function goes to the input of the adder
// the next bit along. What this means is that adding three bits together can
// be done in an ALM, because functions can be used to implement addition that
// then feeds into the carry chain. This means that three bits can be added per
// ALM, as opposed to two in the arithmetic mode.
//
// Shared arithmetic mode doesn't currently have a cell, but I intend to add
// it as MISTRAL_ALM_SHARED, and have it occupy a full ALM. Because it adds
// three bits per cell, it makes addition shorter and use less ALMs, but
// I don't know enough to tell whether it's more efficient to use shared
// arithmetic mode to shorten the carry chain, or plain arithmetic mode with
// the functions packed in.

\`default_nettype none

// Cyclone V LUT output timings (picoseconds):
//
//          CARRY   A    B    C   D   E    F   G
//  COMBOUT    -  605  583  510 512   -   97 400 (LUT6)
//  COMBOUT    -  602  583  457 510 302   93 483 (LUT7)
//   SUMOUT  368 1342 1323  887 927   -  785   -
// CARRYOUT   71 1082 1062  866 813   - 1198   -

(* abc9_lut=2, lib_whitebox *)
module MISTRAL_ALUT6(input A, B, C, D, E, F, output Q);

parameter [63:0] LUT = 64'h0000_0000_0000_0000;

\`ifdef cyclonev
specify
    (A => Q) = 605;
    (B => Q) = 583;
    (C => Q) = 510;
    (D => Q) = 512;
    (E => Q) = 400;
    (F => Q) = 97;
endspecify
\`endif

assign Q = LUT >> {F, E, D, C, B, A};

endmodule


(* abc9_lut=1, lib_whitebox *)
module MISTRAL_ALUT5(input A, B, C, D, E, output Q);

parameter [31:0] LUT = 32'h0000_0000;

\`ifdef cyclonev
specify
    (A => Q) = 583;
    (B => Q) = 510;
    (C => Q) = 512;
    (D => Q) = 400;
    (E => Q) = 97;
endspecify
\`endif

assign Q = LUT >> {E, D, C, B, A};

endmodule


(* abc9_lut=1, lib_whitebox *)
module MISTRAL_ALUT4(input A, B, C, D, output Q);

parameter [15:0] LUT = 16'h0000;

\`ifdef cyclonev
specify
    (A => Q) = 510;
    (B => Q) = 512;
    (C => Q) = 400;
    (D => Q) = 97;
endspecify
\`endif

assign Q = LUT >> {D, C, B, A};

endmodule


(* abc9_lut=1, lib_whitebox *)
module MISTRAL_ALUT3(input A, B, C, output Q);

parameter [7:0] LUT = 8'h00;

\`ifdef cyclonev
specify
    (A => Q) = 510;
    (B => Q) = 400;
    (C => Q) = 97;
endspecify
\`endif

assign Q = LUT >> {C, B, A};

endmodule


(* abc9_lut=1, lib_whitebox *)
module MISTRAL_ALUT2(input A, B, output Q);

parameter [3:0] LUT = 4'h0;

\`ifdef cyclonev
specify
    (A => Q) = 400;
    (B => Q) = 97;
endspecify
\`endif

assign Q = LUT >> {B, A};

endmodule


(* abc9_lut=1, lib_whitebox *)
module MISTRAL_NOT(input A, output Q);

\`ifdef cyclonev
specify
    (A => Q) = 97;
endspecify
\`endif

assign Q = ~A;

endmodule

(* abc9_box, lib_whitebox *)
module MISTRAL_ALUT_ARITH(input A, B, C, D0, D1, (* abc9_carry *) input CI, output SO, (* abc9_carry *) output CO);

parameter LUT0 = 16'h0000;
parameter LUT1 = 16'h0000;

\`ifdef cyclonev
specify
    (A  => SO) = 1342;
    (B  => SO) = 1323;
    (C  => SO) = 927;
    (D0 => SO) = 887;
    (D1 => SO) = 785;
    (CI => SO) = 368;

    (A  => CO) = 1082;
    (B  => CO) = 1062;
    (C  => CO) = 813;
    (D0 => CO) = 866;
    (D1 => CO) = 1198;
    (CI => CO) = 36; // Divided by 2 to account for there being two ALUT_ARITHs in an ALM)
endspecify
\`endif

wire q0, q1;

assign q0 = LUT0 >> {D0, C, B, A};
assign q1 = LUT1 >> {D1, C, B, A};

assign {CO, SO} = q0 + !q1 + CI;

endmodule
`,"arith_alm_map.v":`\`default_nettype none

module \\$alu (A, B, CI, BI, X, Y, CO);

parameter A_SIGNED = 0;
parameter B_SIGNED = 0;
parameter A_WIDTH = 1;
parameter B_WIDTH = 1;
parameter Y_WIDTH = 1;

parameter _TECHMAP_CONSTMSK_CI_ = 0;
parameter _TECHMAP_CONSTVAL_CI_ = 0;

(* force_downto *)
input [A_WIDTH-1:0] A;
(* force_downto *)
input [B_WIDTH-1:0] B;
input CI, BI;
(* force_downto *)
output [Y_WIDTH-1:0] X, Y, CO;

(* force_downto *)
wire [Y_WIDTH-1:0] A_buf, B_buf;
\\$pos #(.A_SIGNED(A_SIGNED), .A_WIDTH(A_WIDTH), .Y_WIDTH(Y_WIDTH)) A_conv (.A(A), .Y(A_buf));
\\$pos #(.A_SIGNED(B_SIGNED), .A_WIDTH(B_WIDTH), .Y_WIDTH(Y_WIDTH)) B_conv (.A(B), .Y(B_buf));

(* force_downto *)
wire [Y_WIDTH-1:0] AA = A_buf;
(* force_downto *)
wire [Y_WIDTH-1:0] BB = BI ? ~B_buf : B_buf;
(* force_downto *)
wire [Y_WIDTH-1:0] BX = B_buf;
wire [Y_WIDTH:0] ALM_CARRY;

// Start of carry chain
generate
    if (_TECHMAP_CONSTMSK_CI_ == 1 && _TECHMAP_CONSTVAL_CI_ == 1'b0) begin
        assign ALM_CARRY[0] = _TECHMAP_CONSTVAL_CI_;
    end else begin
        MISTRAL_ALUT_ARITH #(
            .LUT0(16'b1010_1010_1010_1010), // Q = A
            .LUT1(16'b0000_0000_0000_0000), // Q = 0 (LUT1's input to the adder is inverted)
        ) alm_start (
            .A(CI), .B(1'b1), .C(1'b1), .D0(1'b1), .D1(1'b1),
            .CI(1'b0),
            .CO(ALM_CARRY[0])
        );
    end
endgenerate

// Carry chain
genvar i;
generate for (i = 0; i < Y_WIDTH; i = i + 1) begin:slice
    // TODO: mwk suggests that a pass could merge pre-adder logic into this.
    MISTRAL_ALUT_ARITH #(
        .LUT0(16'b1010_1010_1010_1010), // Q = A
        .LUT1(16'b1100_0011_1100_0011), // Q = C ? B : ~B (LUT1's input to the adder is inverted)
    ) alm_i (
        .A(AA[i]), .B(BX[i]), .C(BI), .D0(1'b1), .D1(1'b1),
        .CI(ALM_CARRY[i]),
        .SO(Y[i]),
        .CO(ALM_CARRY[i+1])
    );

    // ALM carry chain is not directly accessible, so calculate the carry through soft logic if really needed.
    assign CO[i] = (AA[i] && BB[i]) || ((Y[i] ^ AA[i] ^ BB[i]) && (AA[i] || BB[i]));
end endgenerate

assign X = AA ^ BB;

endmodule
`,"bram_m10k.txt":`bram $__MISTRAL_M10K
    init   1
    abits 13   @D8192x1
    dbits  1   @D8192x1
    abits 12   @D4096x2
    dbits  2   @D4096x2
    abits 11   @D2048x5
    dbits  5   @D2048x5
    abits 10   @D1024x10
    dbits 10   @D1024x10
    abits  9   @D512x20
    dbits 20   @D512x20
    abits  8   @D256x40
    dbits 40   @D256x40
    groups 2
    ports  1 1
    wrmode 1 0
    # read enable; write enable + byte enables (only for multiples of 8)
    enable 1 1
    transp 0 0
    clocks 1 1
    clkpol 1 1
endbram


match $__MISTRAL_M10K
    min efficiency 5
    make_transp
endmatch
`,"bram_m10k_map.v":`// Stub to invert M10K write-enable.

module \\$__MISTRAL_M10K (CLK1, A1ADDR, A1DATA, A1EN, B1ADDR, B1DATA, B1EN);

parameter INIT = 0;

parameter CFG_ABITS = 10;
parameter CFG_DBITS = 10;

input CLK1;
input [CFG_ABITS-1:0] A1ADDR, B1ADDR;
input [CFG_DBITS-1:0] A1DATA;
input A1EN, B1EN;
output reg [CFG_DBITS-1:0] B1DATA;

// Normal M10K configs use WREN[1], which is negative-true.
// However, 8x40-bit mode uses WREN[0], which is positive-true.
wire a1en;
if (CFG_DBITS == 40)
    assign a1en = A1EN;
else
    assign a1en = !A1EN;

MISTRAL_M10K #(.INIT(INIT), .CFG_ABITS(CFG_ABITS), .CFG_DBITS(CFG_DBITS)) _TECHMAP_REPLACE_ (.CLK1(CLK1), .A1ADDR(A1ADDR), .A1DATA(A1DATA), .A1EN(a1en), .B1ADDR(B1ADDR), .B1DATA(B1DATA), .B1EN(B1EN));

endmodule
`,"dff_map.v":`\`default_nettype none

// D flip-flop with async reset and enable
module \\$_DFFE_PN0P_ (input D, C, R, E, output Q);
    wire _TECHMAP_REMOVEINIT_Q_ = 1'b1;
    MISTRAL_FF _TECHMAP_REPLACE_(.DATAIN(D), .CLK(C), .ACLR(R), .ENA(E), .SCLR(1'b0), .SLOAD(1'b0), .SDATA(1'b0), .Q(Q));
endmodule

// D flip-flop with sync reset and enable (enable has priority)
module \\$_SDFFCE_PP0P_ (input D, C, R, E, output Q);
    wire _TECHMAP_REMOVEINIT_Q_ = 1'b1;
    MISTRAL_FF _TECHMAP_REPLACE_(.DATAIN(D), .CLK(C), .ACLR(1'b1), .ENA(E), .SCLR(R), .SLOAD(1'b0), .SDATA(1'b0), .Q(Q));
endmodule
`,"dff_sim.v":`// The four D flip-flops (DFFs) in a Cyclone V/10GX Adaptive Logic Module (ALM)
// act as one-bit memory cells that can be placed very flexibly (wherever there's
// an ALM); each flop is represented by a MISTRAL_FF cell.
//
// The flops in these chips are rather flexible in some ways, but in practice
// quite crippled by FPGA standards.
//
// What the flops can do
// ---------------------
// The core flop acts as a single-bit memory that initialises to zero at chip
// reset. It takes in data on the rising edge of CLK if ENA is high,
// and outputs it to Q. The ENA (clock enable) pin can therefore be used to
// capture the input only if a condition is true.
//
// The data itself is zero if SCLR (synchronous clear) is high, else it comes
// from SDATA (synchronous data) if SLOAD (synchronous load) is high, or DATAIN
// if SLOAD is low.
//
// If ACLR (asynchronous clear) is low then Q is forced to zero, regardless of
// the synchronous inputs or CLK edge. This is most often used for an FPGA-wide
// power-on reset.
//
// An asynchronous set that sets Q to one can be emulated by inverting the input
// and output of the flop, resulting in ACLR forcing Q to zero, which then gets
// inverted to produce one. Likewise, logic can operate on the falling edge of
// CLK if CLK is inverted before being passed as an input.
//
// What the flops *can't* do
// -------------------------
// The trickiest part of the above capabilities is the lack of configurable
// initialisation state. For example, it isn't possible to implement a flop with
// asynchronous clear that initialises to one, because the hardware initialises
// to zero. Likewise, you can't emulate a flop with asynchronous set that
// initialises to zero, because the inverters mean the flop initialises to one.
//
// If the input design requires one of these cells (which appears to be rare
// in practice) then synth_intel_alm will fail to synthesize the design where
// other Yosys synthesis scripts might succeed.
//
// This stands in notable contrast to e.g. Xilinx flip-flops, which have
// configurable initialisation state and native synchronous/asynchronous
// set/clear (although not at the same time), which means they can generally
// implement a much wider variety of logic.

// DATAIN: synchronous data input
// CLK: clock input (positive edge)
// ACLR: asynchronous clear (negative-true)
// ENA: clock-enable
// SCLR: synchronous clear
// SLOAD: synchronous load
// SDATA: synchronous load data
//
// Q: data output
//
// Note: the DFFEAS primitive is mostly emulated; it does not reflect what the hardware implements.

(* abc9_box, lib_whitebox *)
module MISTRAL_FF(
    input DATAIN,
    (* clkbuf_sink *) input CLK,
    input ACLR, ENA, SCLR, SLOAD, SDATA,
    output reg Q
);

\`ifdef cyclonev
specify
    if (ENA && ACLR !== 1'b0 && !SCLR && !SLOAD) (posedge CLK => (Q : DATAIN)) = 731;
    if (ENA && SCLR) (posedge CLK => (Q : 1'b0)) = 890;
    if (ENA && !SCLR && SLOAD) (posedge CLK => (Q : SDATA)) = 618;

    $setup(DATAIN, posedge CLK, /* -196 */ 0);
    $setup(ENA, posedge CLK, /* -196 */ 0);
    $setup(SCLR, posedge CLK, /* -196 */ 0);
    $setup(SLOAD, posedge CLK, /* -196 */ 0);
    $setup(SDATA, posedge CLK, /* -196 */ 0);

    if (ACLR === 1'b0) (ACLR => Q) = 282;
endspecify
\`endif

initial begin
    // Altera flops initialise to zero.
	Q = 0;
end

always @(posedge CLK, negedge ACLR) begin
    // Asynchronous clear
    if (!ACLR) Q <= 0;
    // Clock-enable
	else if (ENA) begin
        // Synchronous clear
        if (SCLR) Q <= 0;
        // Synchronous load
        else if (SLOAD) Q <= SDATA;
        else Q <= DATAIN;
    end
end

endmodule
`,"dsp_map.v":`\`default_nettype none

module __MUL27X27(A, B, Y);

parameter A_SIGNED = 1;
parameter B_SIGNED = 1;
parameter A_WIDTH = 27;
parameter B_WIDTH = 27;
parameter Y_WIDTH = 54;

input [A_WIDTH-1:0] A;
input [B_WIDTH-1:0] B;
output [Y_WIDTH-1:0] Y;

MISTRAL_MUL27X27 _TECHMAP_REPLACE_ (.A(A), .B(B), .Y(Y));

endmodule


module __MUL18X18(A, B, Y);

parameter A_SIGNED = 1;
parameter B_SIGNED = 1;
parameter A_WIDTH = 18;
parameter B_WIDTH = 18;
parameter Y_WIDTH = 36;

input [A_WIDTH-1:0] A;
input [B_WIDTH-1:0] B;
output [Y_WIDTH-1:0] Y;

MISTRAL_MUL18X18 _TECHMAP_REPLACE_ (.A(A), .B(B), .Y(Y));

endmodule


module __MUL9X9(A, B, Y);

parameter A_SIGNED = 1;
parameter B_SIGNED = 1;
parameter A_WIDTH = 9;
parameter B_WIDTH = 9;
parameter Y_WIDTH = 18;

input [A_WIDTH-1:0] A;
input [B_WIDTH-1:0] B;
output [Y_WIDTH-1:0] Y;

MISTRAL_MUL9X9 _TECHMAP_REPLACE_ (.A(A), .B(B), .Y(Y));

endmodule
`,"dsp_sim.v":`\`default_nettype none

(* abc9_box *)
module MISTRAL_MUL27X27(input [26:0] A, input [26:0] B, output [53:0] Y);

parameter A_SIGNED = 1;
parameter B_SIGNED = 1;

\`ifdef cyclonev
specify
    (A *> Y) = 3732;
    (B *> Y) = 3928;
endspecify
\`endif
\`ifdef arriav
// NOTE: Arria V appears to have only one set of timings for all DSP modes...
specify
    (A *> Y) = 1895;
    (B *> Y) = 2053;
endspecify
\`endif
\`ifdef cyclone10gx
// TODO: Cyclone 10 GX timings; the below are for Cyclone V
specify
    (A *> Y) = 3732;
    (B *> Y) = 3928;
endspecify
\`endif

wire [53:0] A_, B_;

if (A_SIGNED)
    assign A_ = $signed(A);
else
    assign A_ = $unsigned(A);

if (B_SIGNED)
    assign B_ = $signed(B);
else
    assign B_ = $unsigned(B);

assign Y = A_ * B_;

endmodule

(* abc9_box *)
module MISTRAL_MUL18X18(input [17:0] A, input [17:0] B, output [35:0] Y);

parameter A_SIGNED = 1;
parameter B_SIGNED = 1;

\`ifdef cyclonev
specify
    (A *> Y) = 3180;
    (B *> Y) = 3982;
endspecify
\`endif
\`ifdef arriav
// NOTE: Arria V appears to have only one set of timings for all DSP modes...
specify
    (A *> Y) = 1895;
    (B *> Y) = 2053;
endspecify
\`endif
\`ifdef cyclone10gx
// TODO: Cyclone 10 GX timings; the below are for Cyclone V
specify
    (A *> Y) = 3180;
    (B *> Y) = 3982;
endspecify
\`endif

wire [35:0] A_, B_;

if (A_SIGNED)
    assign A_ = $signed(A);
else
    assign A_ = $unsigned(A);

if (B_SIGNED)
    assign B_ = $signed(B);
else
    assign B_ = $unsigned(B);

assign Y = A_ * B_;

endmodule

(* abc9_box *)
module MISTRAL_MUL9X9(input [8:0] A, input [8:0] B, output [17:0] Y);

parameter A_SIGNED = 1;
parameter B_SIGNED = 1;

\`ifdef cyclonev
specify
    (A *> Y) = 2818;
    (B *> Y) = 3051;
endspecify
\`endif
\`ifdef arriav
// NOTE: Arria V appears to have only one set of timings for all DSP modes...
specify
    (A *> Y) = 1895;
    (B *> Y) = 2053;
endspecify
\`endif
\`ifdef cyclone10gx
// TODO: Cyclone 10 GX timings; the below are for Cyclone V
specify
    (A *> Y) = 2818;
    (B *> Y) = 3051;
endspecify
\`endif

wire [17:0] A_, B_;

if (A_SIGNED)
    assign A_ = $signed(A);
else
    assign A_ = $unsigned(A);

if (B_SIGNED)
    assign B_ = $signed(B);
else
    assign B_ = $unsigned(B);

assign Y = A_ * B_;

endmodule
`,"lutram_mlab.txt":`bram MISTRAL_MLAB
    init   0   # TODO: Re-enable when Yosys remembers the original filename.
    abits  5
    dbits  1
    groups 2
    ports  1 1
    wrmode 1 0
    # write enable
    enable 1 0
    transp 0 0
    clocks 1 0
    clkpol 1 1
endbram

match MISTRAL_MLAB
    min efficiency 5
    make_outreg
endmatch`,"megafunction_bb.v":`// Intel megafunction declarations, to avoid Yosys complaining.
\`default_nettype none

(* blackbox *)
module altera_pll
#(
    parameter reference_clock_frequency       = "0 ps",
	parameter fractional_vco_multiplier       = "false",
    parameter pll_type                        = "General",
    parameter pll_subtype                     = "General",
    parameter number_of_clocks                   = 1,
    parameter operation_mode                  = "internal feedback",
    parameter deserialization_factor           = 4,
    parameter data_rate                       = 0,
    
    parameter sim_additional_refclk_cycles_to_lock      = 0,
    parameter output_clock_frequency0           = "0 ps",
    parameter phase_shift0                      = "0 ps",
    parameter duty_cycle0                      = 50,
    
    parameter output_clock_frequency1           = "0 ps",
    parameter phase_shift1                      = "0 ps",
    parameter duty_cycle1                      = 50,
    
    parameter output_clock_frequency2           = "0 ps",
    parameter phase_shift2                      = "0 ps",
    parameter duty_cycle2                      = 50,
    
    parameter output_clock_frequency3           = "0 ps",
    parameter phase_shift3                      = "0 ps",
    parameter duty_cycle3                      = 50,
    
    parameter output_clock_frequency4           = "0 ps",
    parameter phase_shift4                      = "0 ps",
    parameter duty_cycle4                      = 50,
    
    parameter output_clock_frequency5           = "0 ps",
    parameter phase_shift5                      = "0 ps",
    parameter duty_cycle5                      = 50,
    
    parameter output_clock_frequency6           = "0 ps",
    parameter phase_shift6                      = "0 ps",
    parameter duty_cycle6                      = 50,
    
    parameter output_clock_frequency7           = "0 ps",
    parameter phase_shift7                      = "0 ps",
    parameter duty_cycle7                      = 50,
    
    parameter output_clock_frequency8           = "0 ps",
    parameter phase_shift8                      = "0 ps",
    parameter duty_cycle8                      = 50,
    
    parameter output_clock_frequency9           = "0 ps",
    parameter phase_shift9                      = "0 ps",
    parameter duty_cycle9                      = 50,    

    
    parameter output_clock_frequency10           = "0 ps",
    parameter phase_shift10                      = "0 ps",
    parameter duty_cycle10                      = 50,
    
    parameter output_clock_frequency11           = "0 ps",
    parameter phase_shift11                      = "0 ps",
    parameter duty_cycle11                      = 50,
    
    parameter output_clock_frequency12           = "0 ps",
    parameter phase_shift12                      = "0 ps",
    parameter duty_cycle12                      = 50,
    
    parameter output_clock_frequency13           = "0 ps",
    parameter phase_shift13                      = "0 ps",
    parameter duty_cycle13                      = 50,
    
    parameter output_clock_frequency14           = "0 ps",
    parameter phase_shift14                      = "0 ps",
    parameter duty_cycle14                      = 50,
    
    parameter output_clock_frequency15           = "0 ps",
    parameter phase_shift15                      = "0 ps",
    parameter duty_cycle15                      = 50,
    
    parameter output_clock_frequency16           = "0 ps",
    parameter phase_shift16                      = "0 ps",
    parameter duty_cycle16                      = 50,
    
    parameter output_clock_frequency17           = "0 ps",
    parameter phase_shift17                      = "0 ps",
    parameter duty_cycle17                      = 50,
    
    parameter clock_name_0 = "",
    parameter clock_name_1 = "",
    parameter clock_name_2 = "",
    parameter clock_name_3 = "",
    parameter clock_name_4 = "",
    parameter clock_name_5 = "",
    parameter clock_name_6 = "",
    parameter clock_name_7 = "",
    parameter clock_name_8 = "",

    parameter clock_name_global_0 = "false",
    parameter clock_name_global_1 = "false",
    parameter clock_name_global_2 = "false",
    parameter clock_name_global_3 = "false",
    parameter clock_name_global_4 = "false",
    parameter clock_name_global_5 = "false",
    parameter clock_name_global_6 = "false",
    parameter clock_name_global_7 = "false",
    parameter clock_name_global_8 = "false",

    parameter m_cnt_hi_div                       = 1,
    parameter m_cnt_lo_div                       = 1,
    parameter m_cnt_bypass_en                   = "false",
    parameter m_cnt_odd_div_duty_en           = "false",
    parameter n_cnt_hi_div                       = 1,
    parameter n_cnt_lo_div                       = 1,
    parameter n_cnt_bypass_en                   = "false",
    parameter n_cnt_odd_div_duty_en           = "false",
    parameter c_cnt_hi_div0                      = 1, 
    parameter c_cnt_lo_div0                      = 1,
    parameter c_cnt_bypass_en0                  = "false",
	parameter c_cnt_in_src0                     = "ph_mux_clk",
    parameter c_cnt_odd_div_duty_en0              = "false",
    parameter c_cnt_prst0                  = 1,
    parameter c_cnt_ph_mux_prst0                  = 0,
    parameter c_cnt_hi_div1                      = 1, 
    parameter c_cnt_lo_div1                      = 1,
    parameter c_cnt_bypass_en1                  = "false",
	parameter c_cnt_in_src1                     = "ph_mux_clk",
    parameter c_cnt_odd_div_duty_en1              = "false",
    parameter c_cnt_prst1                  = 1,
    parameter c_cnt_ph_mux_prst1                  = 0,
    parameter c_cnt_hi_div2                      = 1, 
    parameter c_cnt_lo_div2                                              = 1,
    parameter c_cnt_bypass_en2                  = "false",
	parameter c_cnt_in_src2                     = "ph_mux_clk",
    parameter c_cnt_odd_div_duty_en2 = "false",
    parameter c_cnt_prst2                  = 1,
    parameter c_cnt_ph_mux_prst2                  = 0,
    parameter c_cnt_hi_div3                      = 1, 
    parameter c_cnt_lo_div3                                              = 1,
    parameter c_cnt_bypass_en3                  = "false",
	parameter c_cnt_in_src3                     = "ph_mux_clk",
    parameter c_cnt_odd_div_duty_en3 = "false",
    parameter c_cnt_prst3                  = 1,
    parameter c_cnt_ph_mux_prst3                  = 0,
    parameter c_cnt_hi_div4                      = 1, 
    parameter c_cnt_lo_div4                                              = 1,
    parameter c_cnt_bypass_en4                  = "false",
	parameter c_cnt_in_src4                     = "ph_mux_clk",
    parameter c_cnt_odd_div_duty_en4 = "false",
    parameter c_cnt_prst4                  = 1,
    parameter c_cnt_ph_mux_prst4                  = 0,
    parameter c_cnt_hi_div5                      = 1, 
    parameter c_cnt_lo_div5                                              = 1,
    parameter c_cnt_bypass_en5                  = "false",
	parameter c_cnt_in_src5                     = "ph_mux_clk",
    parameter c_cnt_odd_div_duty_en5 = "false",
    parameter c_cnt_prst5                  = 1,
    parameter c_cnt_ph_mux_prst5                  = 0,
    parameter c_cnt_hi_div6                      = 1, 
    parameter c_cnt_lo_div6                                              = 1,
    parameter c_cnt_bypass_en6                  = "false",
	parameter c_cnt_in_src6                     = "ph_mux_clk",
    parameter c_cnt_odd_div_duty_en6 = "false",
    parameter c_cnt_prst6                  = 1,
    parameter c_cnt_ph_mux_prst6                  = 0,
    parameter c_cnt_hi_div7                      = 1, 
    parameter c_cnt_lo_div7                                              = 1,
    parameter c_cnt_bypass_en7                  = "false",
	parameter c_cnt_in_src7                     = "ph_mux_clk",
    parameter c_cnt_odd_div_duty_en7 = "false",
    parameter c_cnt_prst7                  = 1,
    parameter c_cnt_ph_mux_prst7                  = 0,
    parameter c_cnt_hi_div8                      = 1, 
    parameter c_cnt_lo_div8                                              = 1,
    parameter c_cnt_bypass_en8                  = "false",
	parameter c_cnt_in_src8                     = "ph_mux_clk",
    parameter c_cnt_odd_div_duty_en8 = "false",
    parameter c_cnt_prst8                  = 1,
    parameter c_cnt_ph_mux_prst8                  = 0,
    parameter c_cnt_hi_div9                      = 1, 
    parameter c_cnt_lo_div9                                              = 1,
    parameter c_cnt_bypass_en9                  = "false",
	parameter c_cnt_in_src9                     = "ph_mux_clk",
    parameter c_cnt_odd_div_duty_en9 = "false",
    parameter c_cnt_prst9                  = 1,
    parameter c_cnt_ph_mux_prst9                  = 0,
    parameter c_cnt_hi_div10                      = 1, 
    parameter c_cnt_lo_div10                                              = 1,
    parameter c_cnt_bypass_en10                  = "false",
	parameter c_cnt_in_src10                     = "ph_mux_clk",
    parameter c_cnt_odd_div_duty_en10 = "false",
    parameter c_cnt_prst10                  = 1,
    parameter c_cnt_ph_mux_prst10                  = 0,
    parameter c_cnt_hi_div11                      = 1, 
    parameter c_cnt_lo_div11                                              = 1,
    parameter c_cnt_bypass_en11                  = "false",
	parameter c_cnt_in_src11                     = "ph_mux_clk",
    parameter c_cnt_odd_div_duty_en11 = "false",
    parameter c_cnt_prst11                  = 1,
    parameter c_cnt_ph_mux_prst11                  = 0,
    parameter c_cnt_hi_div12                      = 1, 
    parameter c_cnt_lo_div12                                              = 1,
    parameter c_cnt_bypass_en12                  = "false",
	parameter c_cnt_in_src12                     = "ph_mux_clk",
    parameter c_cnt_odd_div_duty_en12 = "false",
    parameter c_cnt_prst12                  = 1,
    parameter c_cnt_ph_mux_prst12                  = 0,
    parameter c_cnt_hi_div13                      = 1, 
    parameter c_cnt_lo_div13                                              = 1,
    parameter c_cnt_bypass_en13                  = "false",
	parameter c_cnt_in_src13                     = "ph_mux_clk",
    parameter c_cnt_odd_div_duty_en13 = "false",
    parameter c_cnt_prst13                  = 1,
    parameter c_cnt_ph_mux_prst13                  = 0,
    parameter c_cnt_hi_div14                      = 1, 
    parameter c_cnt_lo_div14                                              = 1,
    parameter c_cnt_bypass_en14                  = "false",
	parameter c_cnt_in_src14                     = "ph_mux_clk",
    parameter c_cnt_odd_div_duty_en14 = "false",
    parameter c_cnt_prst14                  = 1,
    parameter c_cnt_ph_mux_prst14                  = 0,
    parameter c_cnt_hi_div15                      = 1, 
    parameter c_cnt_lo_div15                                              = 1,
    parameter c_cnt_bypass_en15                  = "false",
	parameter c_cnt_in_src15                     = "ph_mux_clk",
    parameter c_cnt_odd_div_duty_en15 = "false",
    parameter c_cnt_prst15                  = 1,
    parameter c_cnt_ph_mux_prst15                  = 0,
    parameter c_cnt_hi_div16                      = 1, 
    parameter c_cnt_lo_div16                                              = 1,
    parameter c_cnt_bypass_en16                  = "false",
	parameter c_cnt_in_src16                     = "ph_mux_clk",
    parameter c_cnt_odd_div_duty_en16 = "false",
    parameter c_cnt_prst16                  = 1,
    parameter c_cnt_ph_mux_prst16                  = 0,
    parameter c_cnt_hi_div17                      = 1, 
    parameter c_cnt_lo_div17                                              = 1,
    parameter c_cnt_bypass_en17                  = "false",
	parameter c_cnt_in_src17                     = "ph_mux_clk",
    parameter c_cnt_odd_div_duty_en17 = "false",
    parameter c_cnt_prst17                  = 1,
    parameter c_cnt_ph_mux_prst17                  = 0,
    parameter pll_vco_div = 1,
	parameter pll_slf_rst = "false",
	parameter pll_bw_sel = "low",
    parameter pll_output_clk_frequency = "0 MHz",
    parameter pll_cp_current = 0,
    parameter pll_bwctrl = 0,
    parameter pll_fractional_division = 1,
    parameter pll_fractional_cout = 24,
    parameter pll_dsm_out_sel = "1st_order",
    parameter mimic_fbclk_type = "gclk",
    parameter pll_fbclk_mux_1 = "glb",
    parameter pll_fbclk_mux_2 = "fb_1",
    parameter pll_m_cnt_in_src = "ph_mux_clk",
	parameter pll_vcoph_div = 1,
    parameter refclk1_frequency = "0 MHz",
    parameter pll_clkin_0_src = "clk_0",
    parameter pll_clkin_1_src = "clk_0",
    parameter pll_clk_loss_sw_en = "false",
    parameter pll_auto_clk_sw_en = "false",
    parameter pll_manu_clk_sw_en = "false", 
    parameter pll_clk_sw_dly = 0,
    parameter pll_extclk_0_cnt_src = "pll_extclk_cnt_src_vss",	
    parameter pll_extclk_1_cnt_src = "pll_extclk_cnt_src_vss"
) (
    //input
    input    refclk,
    input    refclk1,
    input    fbclk,
    input    rst,
    input    phase_en,
    input    updn,
    input    [2:0] num_phase_shifts,
    input    scanclk,
    input    [4:0] cntsel,
    input    [63:0] reconfig_to_pll,
    input    extswitch,
    input    adjpllin,
    input    cclk,
    
    //output
    output    [ number_of_clocks -1 : 0] outclk,
    output    fboutclk,
    output    locked,
    output    phase_done,
    output    [63:0]    reconfig_from_pll,
    output    activeclk,
    output    [1:0] clkbad,
	output    [7:0] phout,
	output	  [1:0] lvds_clk,
	output	  [1:0] loaden,
	output    [1:0] extclk_out,
    output    [ number_of_clocks -1 : 0] cascade_out,

    //inout
    inout zdbfbclk
);

endmodule


(* blackbox *)
module altera_std_synchronizer(clk, din, dout, reset_n);

parameter depth = 2;

input clk;
input reset_n;
input din;
output dout;

endmodule

(* blackbox *)
module altddio_in (
    datain,    // required port, DDR input data
    inclock,   // required port, input reference clock to sample data by
    inclocken, // enable data clock
    aset,      // asynchronous set
    aclr,      // asynchronous clear
    sset,      // synchronous set
    sclr,      // synchronous clear
    dataout_h, // data sampled at the rising edge of inclock
    dataout_l  // data sampled at the falling edge of inclock
);

parameter width = 1;
parameter power_up_high = "OFF";
parameter invert_input_clocks = "OFF";
parameter intended_device_family = "Stratix";
parameter lpm_type = "altddio_in";
parameter lpm_hint = "UNUSED";

input [width-1:0] datain;
input inclock;
input inclocken;
input aset;
input aclr;
input sset;
input sclr;

output [width-1:0] dataout_h;
output [width-1:0] dataout_l;

endmodule


(* blackbox *)
module altddio_out (
    datain_h,
    datain_l,
    outclock,
    outclocken,
    aset,
    aclr,
    sset,
    sclr,
    oe,
    dataout,
    oe_out
);

parameter width = 1;
parameter power_up_high = "OFF";
parameter oe_reg = "UNUSED";
parameter extend_oe_disable = "UNUSED";
parameter intended_device_family = "Stratix";
parameter invert_output = "OFF";
parameter lpm_type = "altddio_out";
parameter lpm_hint = "UNUSED";

input [width-1:0] datain_h;
input [width-1:0] datain_l;
input outclock;
input outclocken;
input aset;
input aclr;
input sset;
input sclr;
input oe;

output [width-1:0] dataout;
output [width-1:0] oe_out;

endmodule


(* blackbox *)
module altddio_bidir (
    datain_h,
    datain_l,
    inclock,
    inclocken,
    outclock,
    outclocken,
    aset,
    aclr,
    sset,
    sclr,
    oe,
    dataout_h,
    dataout_l,
    combout,
    oe_out,
    dqsundelayedout,
    padio
);

// GLOBAL PARAMETER DECLARATION
parameter width = 1; // required parameter
parameter power_up_high = "OFF";
parameter oe_reg = "UNUSED";
parameter extend_oe_disable = "UNUSED";
parameter implement_input_in_lcell = "UNUSED";
parameter invert_output = "OFF";
parameter intended_device_family = "Stratix";
parameter lpm_type = "altddio_bidir";
parameter lpm_hint = "UNUSED";

// INPUT PORT DECLARATION
input [width-1:0] datain_h;
input [width-1:0] datain_l;
input inclock;
input inclocken;
input outclock;
input outclocken;
input aset;
input aclr;
input sset;
input sclr;
input oe;

// OUTPUT PORT DECLARATION
output [width-1:0] dataout_h;
output [width-1:0] dataout_l;
output [width-1:0] combout;
output [width-1:0] oe_out;
output [width-1:0] dqsundelayedout;
// BIDIRECTIONAL PORT DECLARATION
inout  [width-1:0] padio;

endmodule


(* blackbox *)
module altiobuf_in(datain, dataout);

parameter enable_bus_hold = "FALSE";
parameter use_differential_mode = "FALSE";
parameter number_of_channels = 1;

input [number_of_channels-1:0] datain;
output [number_of_channels-1:0] dataout;

endmodule

(* blackbox *)
module altiobuf_out(datain, dataout);

parameter enable_bus_hold = "FALSE";
parameter use_differential_mode = "FALSE";
parameter use_oe = "FALSE";
parameter number_of_channels = 1;

input [number_of_channels-1:0] datain;
output [number_of_channels-1:0] dataout;

endmodule

(* blackbox *)
module altiobuf_bidir(dataio, oe, datain, dataout);

parameter number_of_channels = 1;
parameter enable_bus_hold = "OFF";

inout [number_of_channels-1:0] dataio;
input [number_of_channels-1:0] datain;
output [number_of_channels-1:0] dataout;
input [number_of_channels-1:0] oe;

endmodule

(* blackbox *)
module altsyncram(clock0, clock1, address_a, data_a, rden_a, wren_a, byteena_a, q_a, addressstall_a, address_b, data_b, rden_b, wren_b, byteena_b, q_b, addressstall_b, clocken0, clocken1, clocken2, clocken3, aclr0, aclr1, eccstatus);

parameter lpm_type = "altsyncram";
parameter operation_mode = "dual_port";
parameter ram_block_type = "auto";
parameter intended_device_family = "auto";
parameter power_up_uninitialized = "false";
parameter read_during_write_mode_mixed_ports = "dontcare";
parameter byte_size = 8;
parameter widthad_a = 1;
parameter width_a = 1;
parameter width_byteena_a = 1;
parameter numwords_a = 1;
parameter clock_enable_input_a = "clocken0";
parameter widthad_b = 1;
parameter width_b = 1;
parameter numwords_b = 1;
parameter address_aclr_b = "aclr0";
parameter address_reg_b = "";
parameter outdata_aclr_b = "aclr0";
parameter outdata_reg_b = "";
parameter clock_enable_input_b = "clocken0";
parameter clock_enable_output_b = "clocken0";

input clock0, clock1;
input [widthad_a-1:0] address_a;
input [width_a-1:0] data_a;
input rden_a;
input wren_a;
input [(width_a/8)-1:0] byteena_a;
input addressstall_a;

output [width_a-1:0] q_a;

input wren_b;
input rden_b;
input [widthad_b-1:0] address_b;
input [width_b-1:0] data_b;
input [(width_b/8)-1:0] byteena_b;
input addressstall_b;

output [width_b-1:0] q_b;

input clocken0;
input clocken1;
input clocken2;
input clocken3;

input aclr0;
input aclr1;

output eccstatus;

endmodule

(* blackbox *)
module cyclonev_mlab_cell(portaaddr, portadatain, portbaddr, portbdataout, ena0, clk0, clk1);

parameter logical_ram_name = "";
parameter logical_ram_depth = 32;
parameter logical_ram_width = 20;
parameter mixed_port_feed_through_mode = "new";
parameter first_bit_number = 0;
parameter first_address = 0;
parameter last_address = 31;
parameter address_width = 5;
parameter data_width = 1;
parameter byte_enable_mask_width = 1;
parameter port_b_data_out_clock = "NONE";
parameter [639:0] mem_init0 = 640'b0;

input [address_width-1:0] portaaddr, portbaddr;
input [data_width-1:0] portadatain;
output [data_width-1:0] portbdataout;
input ena0, clk0, clk1;

endmodule

(* blackbox *)
module cyclonev_mac(ax, ay, resulta);

parameter ax_width = 9;
parameter signed_max = "true";
parameter ay_scan_in_width = 9;
parameter signed_may = "true";
parameter result_a_width = 18;
parameter operation_mode = "M9x9";

input [ax_width-1:0] ax;
input [ay_scan_in_width-1:0] ay;
output [result_a_width-1:0] resulta;

endmodule

(* blackbox *)
module cyclone10gx_mac(ax, ay, resulta);

parameter ax_width = 18;
parameter signed_max = "true";
parameter ay_scan_in_width = 18;
parameter signed_may = "true";
parameter result_a_width = 36;
parameter operation_mode = "M18X18_FULL";

input [ax_width-1:0] ax;
input [ay_scan_in_width-1:0] ay;
output [result_a_width-1:0] resulta;

endmodule

(* blackbox *)
module cyclonev_ram_block(portaaddr, portadatain, portawe, portbaddr, portbdataout, portbre, clk0);

parameter operation_mode = "dual_port";
parameter logical_ram_name = "";
parameter port_a_address_width = 10;
parameter port_a_data_width = 10;
parameter port_a_logical_ram_depth = 1024;
parameter port_a_logical_ram_width = 10;
parameter port_a_first_address = 0;
parameter port_a_last_address = 1023;
parameter port_a_first_bit_number = 0;
parameter port_b_address_width = 10;
parameter port_b_data_width = 10;
parameter port_b_logical_ram_depth = 1024;
parameter port_b_logical_ram_width = 10;
parameter port_b_first_address = 0;
parameter port_b_last_address = 1023;
parameter port_b_first_bit_number = 0;
parameter port_b_address_clock = "clock0";
parameter port_b_read_enable_clock = "clock0";
parameter mem_init0 = "";
parameter mem_init1 = "";
parameter mem_init2 = "";
parameter mem_init3 = "";
parameter mem_init4 = "";

input [port_a_address_width-1:0] portaaddr;
input [port_b_address_width-1:0] portbaddr;
input [port_a_data_width-1:0] portadatain;
output [port_b_data_width-1:0] portbdataout;
input clk0, portawe, portbre;

endmodule

(* blackbox *)
module cyclone10gx_io_ibuf(i, ibar, dynamicterminationcontrol, o);

parameter differential_mode ="false";
parameter bus_hold = "false";
parameter simulate_z_as = "Z";
parameter lpm_type = "cyclone10gx_io_ibuf";

(* iopad_external_pin *) input i;
(* iopad_external_pin *) input ibar;
input dynamicterminationcontrol;
output o;

endmodule

(* blackbox *)
module cyclone10gx_io_obuf(i, oe, dynamicterminationcontrol, seriesterminationcontrol, parallelterminationcontrol, devoe, o, obar);

parameter open_drain_output = "false";
parameter bus_hold = "false";
parameter shift_series_termination_control = "false";
parameter sim_dynamic_termination_control_is_connected = "false";
parameter lpm_type = "cyclone10gx_io_obuf";

input i;
input oe;
input devoe;
input dynamicterminationcontrol;
input [15:0] seriesterminationcontrol;
input [15:0] parallelterminationcontrol;
(* iopad_external_pin *) output o;
(* iopad_external_pin *) output obar;

endmodule

(* blackbox *)
module cyclonev_clkena(inclk, ena, enaout, outclk);

parameter clock_type = "auto";
parameter ena_register_mode = "always enabled";
parameter lpm_type = "cyclonev_clkena";
parameter ena_register_power_up = "high";
parameter disable_mode = "low";
parameter test_syn = "high";

input inclk;
input ena;
output enaout;
output outclk;

endmodule

(* blackbox *)
module cyclone10gx_clkena(inclk, ena, enaout, outclk);

parameter clock_type = "auto";
parameter ena_register_mode = "always enabled";
parameter lpm_type = "cyclone10gx_clkena";
parameter ena_register_power_up = "high";
parameter disable_mode = "low";
parameter test_syn = "high";

input inclk;
input ena;
output enaout;
output outclk;

endmodule

// Internal interfaces
(* keep *)
module cyclonev_oscillator(oscena, clkout, clkout1);

input oscena;
output clkout;
output clkout1;

endmodule

// HPS interfaces
(* keep *)
module cyclonev_hps_interface_mpu_general_purpose(gp_in, gp_out);

input [31:0] gp_in;
output [31:0] gp_out;

endmodule
`,"mem_sim.v":`// The MLAB
// --------
// In addition to Logic Array Blocks (LABs) that contain ten Adaptive Logic
// Modules (ALMs, see alm_sim.v), the Cyclone V also contains
// Memory/Logic Array Blocks (MLABs) that can act as either ten ALMs, or utilise
// the memory the ALM uses to store the look-up table data for general usage,
// producing a 32 address by 20-bit block of memory. MLABs are spread out
// around the chip, so they can be placed near where they are needed, rather than
// being comparatively limited in placement for a deep but narrow memory such as
// the M10K memory block.
//
// MLABs are used mainly for shallow but wide memories, such as CPU register
// files (which have perhaps 32 registers that are comparatively wide (16/32-bit))
// or shift registers (by using the output of the Nth bit as input for the N+1th
// bit).
//
// For historical reasons a MISTRAL_MLAB cell represents a 32 address by 1-bit cell,
// and 20 of them represent a physical MLAB.
//
// How the MLAB works
// ------------------
// MLABs are poorly documented, so the following information is based mainly
// on the simulation model and my knowledge of how memories like these work.
// Additionally, note that the ports of MISTRAL_MLAB are the ones auto-generated
// by the Yosys \`memory_bram\` pass, and it doesn't make sense to me to use
// \`techmap\` just for the sake of renaming the cell ports.
//
// The MLAB can be initialised to any value.
//
// The MLAB takes in data from A1DATA at the rising edge of CLK1, and if A1EN
// is high, writes it to the address in A1ADDR. A1EN can therefore be used to
// conditionally write data to the MLAB.
//
// Simultaneously, the MLAB reads data from B1ADDR, and outputs it to B1DATA,
// asynchronous to CLK1 and ignoring A1EN. If a synchronous read is needed
// then the output can be fed to embedded flops.

// The vendor sim model outputs 'x for a very short period (a few
// combinational delta cycles) after each write. This has been omitted from
// the following model because it's very difficult to trigger this in practice
// as clock cycles will be much longer than any potential blip of 'x, so the
// model can be treated as always returning a defined result.

(* abc9_box, lib_whitebox *)
module MISTRAL_MLAB(input [4:0] A1ADDR, input A1DATA, A1EN,
    (* clkbuf_sink *) input CLK1,
    input [4:0] B1ADDR, output B1DATA);

reg [31:0] mem = 32'b0;

\`ifdef cyclonev
specify
    $setup(A1ADDR, posedge CLK1, 86);
    $setup(A1DATA, posedge CLK1, 86);
    $setup(A1EN, posedge CLK1, 86);

    (B1ADDR[0] => B1DATA) = 487;
    (B1ADDR[1] => B1DATA) = 475;
    (B1ADDR[2] => B1DATA) = 382;
    (B1ADDR[3] => B1DATA) = 284;
    (B1ADDR[4] => B1DATA) = 96;
endspecify
\`endif

always @(posedge CLK1)
    if (A1EN) mem[A1ADDR] <= A1DATA;

assign B1DATA = mem[B1ADDR];

endmodule

// The M10K
// --------
// TODO

module MISTRAL_M10K(CLK1, A1ADDR, A1DATA, A1EN, B1ADDR, B1DATA, B1EN);

parameter INIT = 0;

parameter CFG_ABITS = 10;
parameter CFG_DBITS = 10;

(* clkbuf_sink *) input CLK1;
input [CFG_ABITS-1:0] A1ADDR, B1ADDR;
input [CFG_DBITS-1:0] A1DATA;
input A1EN, B1EN;
output reg [CFG_DBITS-1:0] B1DATA;

reg [2**CFG_ABITS * CFG_DBITS - 1 : 0] mem = INIT;

\`ifdef cyclonev
specify
    $setup(A1ADDR, posedge CLK1, 125);
    $setup(A1DATA, posedge CLK1, 97);
    $setup(A1EN, posedge CLK1, 140);
    $setup(B1ADDR, posedge CLK1, 125);
    $setup(B1EN, posedge CLK1, 161);

    if (B1EN) (posedge CLK1 => (B1DATA : A1DATA)) = 1004;
endspecify
\`endif

always @(posedge CLK1) begin
    if (!A1EN)
        mem[(A1ADDR + 1) * CFG_DBITS - 1 : A1ADDR * CFG_DBITS] <= A1DATA;

    if (B1EN)
        B1DATA <= mem[(B1ADDR + 1) * CFG_DBITS - 1 : B1ADDR * CFG_DBITS];
end

endmodule
`,"misc_sim.v":`module MISTRAL_IB((* iopad_external_pin *)  input PAD, output O);
	assign O = PAD;
endmodule

module MISTRAL_OB((* iopad_external_pin *)  output PAD, input I);
	assign PAD = I;
endmodule

module MISTRAL_IO((* iopad_external_pin *)  inout PAD, input I, input OE, output O);
	assign PAD = OE ? I : 1'bz;
	assign O = PAD;
endmodule

// Eventually, we should support clock enables and model them here too.
// For now, CLKENA is used as a basic entry point to global routing.
module MISTRAL_CLKBUF (
	input A,
	(* clkbuf_driver *) output Q
);
	assign Q = A;
endmodule`},cyclonev:{"cells_sim.v":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */
module VCC (output V);
   assign V = 1'b1;
endmodule // VCC

module GND (output G);
   assign G = 1'b0;
endmodule // GND

/* Altera Cyclone V devices Input Buffer Primitive */
module cyclonev_io_ibuf
  (output o,
   (* iopad_external_pin *) input i,
   (* iopad_external_pin *) input ibar,
   input dynamicterminationcontrol);

   parameter differential_mode = "false";
   parameter bus_hold = "false";
   parameter simulate_z_as = "Z";
   parameter lpm_type = "cyclonev_io_ibuf";

   assign o    = i;
endmodule // cyclonev_io_ibuf

/* Altera Cyclone V devices Output Buffer Primitive */
module cyclonev_io_obuf
  ((* iopad_external_pin *) output o,
   input i, oe, dynamicterminationcontrol,
   input [15:0] seriesterminationcontrol, parallelterminationcontrol,
   input devoe,
   (* iopad_external_pin *) output obar);

   parameter open_drain_output = "false";
   parameter bus_hold = "false";
   parameter shift_series_termination_control = "false";
   parameter sim_dynamic_termination_control_is_connected = "false";
   parameter lpm_type = "cyclonev_io_obuf";

   assign o  = oe ? i : 1'bz;
endmodule // cyclonev_io_obuf

/* Altera Cyclone V LUT Primitive */
module cyclonev_lcell_comb
  (output combout, cout, sumout, shareout,
   input dataa, datab, datac, datad,
   input datae, dataf, datag, cin,
   input sharein);

   parameter lut_mask      = 64'hFFFFFFFFFFFFFFFF;
   parameter dont_touch    = "off";
   parameter lpm_type      = "cyclonev_lcell_comb";
   parameter shared_arith  = "off";
   parameter extended_lut  = "off";

   // Internal variables
   // Sub mask for fragmented LUTs
   wire [15:0] mask_a, mask_b, mask_c, mask_d;
   // Independent output for fragmented LUTs
   wire        output_0, output_1, output_2, output_3;
   // Extended mode uses mux to define the output
   wire        mux_0, mux_1;
   // Input for hold the shared LUT mode value
   wire        shared_lut_alm;

   // Simulation model of 4-input LUT
   function lut4;
      input [15:0] mask;
      input        dataa, datab, datac, datad;
      reg [7:0]    s3;
      reg [3:0]    s2;
      reg [1:0]    s1;
      begin
         s3   = datad ? mask[15:8] : mask[7:0];
         s2   = datac ?   s3[7:4]  :   s3[3:0];
         s1   = datab ?   s2[3:2]  :   s2[1:0];
         lut4 = dataa ? s1[1] : s1[0];
      end
   endfunction // lut4

   // Simulation model of 5-input LUT
   function lut5;
      input [31:0] mask; // wp-01003.pdf, page 3: "a 5-LUT can be built with two 4-LUTs and a multiplexer.
      input        dataa, datab, datac, datad, datae;
      reg          upper_lut_value;
      reg          lower_lut_value;
      begin
         upper_lut_value = lut4(mask[31:16], dataa, datab, datac, datad);
         lower_lut_value = lut4(mask[15:0], dataa, datab, datac, datad);
         lut5            = (datae) ? upper_lut_value : lower_lut_value;
      end
   endfunction // lut5

   // Simulation model of 6-input LUT
   function lut6;
      input [63:0] mask;
      input        dataa, datab, datac, datad, datae, dataf;
      reg          upper_lut_value;
      reg          lower_lut_value;
      reg          out_0, out_1, out_2, out_3;
      begin
         upper_lut_value = lut5(mask[63:32], dataa, datab, datac, datad, datae);
         lower_lut_value = lut5(mask[31:0], dataa, datab, datac, datad, datae);
         lut6            = (dataf) ?  upper_lut_value : lower_lut_value;
      end
   endfunction // lut6

   assign {mask_a, mask_b, mask_c, mask_d} = {lut_mask[15:0], lut_mask[31:16], lut_mask[47:32], lut_mask[63:48]};
\`ifdef ADVANCED_ALM
   always @(*) begin
      if(extended_lut == "on")
        shared_lut_alm = datag;
      else
        shared_lut_alm = datac;
      // Build the ALM behaviour
      out_0 = lut4(mask_a, dataa, datab, datac, datad);
      out_1 = lut4(mask_b, dataa, datab, shared_lut_alm, datad);
      out_2 = lut4(mask_c, dataa, datab, datac, datad);
      out_3 = lut4(mask_d, dataa, datab, shared_lut_alm, datad);
   end
\`else
   \`ifdef DEBUG
       initial $display("Advanced ALM lut combine is not implemented yet");
   \`endif
\`endif
endmodule // cyclonev_lcell_comb


/* Altera D Flip-Flop Primitive */
module dffeas
  (output q,
   input d, clk, clrn, prn, ena,
   input asdata, aload, sclr, sload);

   // Timing simulation is not covered
   parameter power_up="dontcare";
   parameter is_wysiwyg="false";

   reg   q_tmp;
   wire  reset;
   reg [7:0] debug_net;

   assign reset       = (prn && sclr && ~clrn && ena);
   assign q           = q_tmp & 1'b1;

   always @(posedge clk, posedge aload) begin
      if(reset)        q_tmp <= 0;
      else q_tmp <= d;
   end
   assign q = q_tmp;

endmodule // dffeas
`}},lattice:{"arith_map_ccu2c.v":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *  Copyright (C) 2018  gatecat <gatecat@ds0.me>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

(* techmap_celltype = "$alu" *)
module _80_ccu2c_alu (A, B, CI, BI, X, Y, CO);
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;
	parameter A_WIDTH = 1;
	parameter B_WIDTH = 1;
	parameter Y_WIDTH = 1;

	(* force_downto *)
	input [A_WIDTH-1:0] A;
	(* force_downto *)
	input [B_WIDTH-1:0] B;
	(* force_downto *)
	output [Y_WIDTH-1:0] X, Y;

	input CI, BI;
	(* force_downto *)
	output [Y_WIDTH-1:0] CO;

	wire _TECHMAP_FAIL_ = Y_WIDTH <= 4;

	(* force_downto *)
	wire [Y_WIDTH-1:0] A_buf, B_buf;
	\\$pos #(.A_SIGNED(A_SIGNED), .A_WIDTH(A_WIDTH), .Y_WIDTH(Y_WIDTH)) A_conv (.A(A), .Y(A_buf));
	\\$pos #(.A_SIGNED(B_SIGNED), .A_WIDTH(B_WIDTH), .Y_WIDTH(Y_WIDTH)) B_conv (.A(B), .Y(B_buf));

	function integer round_up2;
		input integer N;
		begin
			round_up2 = ((N + 1) / 2) * 2;
		end
	endfunction

	localparam Y_WIDTH2 = round_up2(Y_WIDTH);

	(* force_downto *)
	wire [Y_WIDTH2-1:0] AA = A_buf;
	(* force_downto *)
	wire [Y_WIDTH2-1:0] BB = BI ? ~B_buf : B_buf;
	(* force_downto *)
	wire [Y_WIDTH2-1:0] BX = B_buf;
	(* force_downto *)
	wire [Y_WIDTH2-1:0] C = {CO, CI};
	(* force_downto *)
	wire [Y_WIDTH2-1:0] FCO, Y1;

	genvar i;
	generate for (i = 0; i < Y_WIDTH2; i = i + 2) begin:slice
		CCU2C #(
			.INIT0(16'b1001011010101010),
			.INIT1(16'b1001011010101010),
			.INJECT1_0("NO"),
			.INJECT1_1("NO")
	   ) ccu2c_i (
			.CIN(C[i]),
			.A0(AA[i]), .B0(BX[i]), .C0(BI), .D0(1'b1),
			.A1(AA[i+1]), .B1(BX[i+1]), .C1(BI), .D1(1'b1),
			.S0(Y[i]), .S1(Y1[i]),
			.COUT(FCO[i])
		);

		assign CO[i] = (AA[i] && BB[i]) || (C[i] && (AA[i] || BB[i]));
		if (i+1 < Y_WIDTH) begin
			assign CO[i+1] = FCO[i];
			assign Y[i+1] = Y1[i];
		end
	end endgenerate

	assign X = AA ^ BB;
endmodule
`,"arith_map_ccu2d.v":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *  Copyright (C) 2018  gatecat <gatecat@ds0.me>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

(* techmap_celltype = "$alu" *)
module _80_ccu2d_alu (A, B, CI, BI, X, Y, CO);
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;
	parameter A_WIDTH = 1;
	parameter B_WIDTH = 1;
	parameter Y_WIDTH = 1;

	(* force_downto *)
	input [A_WIDTH-1:0] A;
	(* force_downto *)
	input [B_WIDTH-1:0] B;
	(* force_downto *)
	output [Y_WIDTH-1:0] X, Y;

	input CI, BI;
	(* force_downto *)
	output [Y_WIDTH-1:0] CO;

	wire _TECHMAP_FAIL_ = Y_WIDTH <= 4;

	(* force_downto *)
	wire [Y_WIDTH-1:0] A_buf, B_buf;
	\\$pos #(.A_SIGNED(A_SIGNED), .A_WIDTH(A_WIDTH), .Y_WIDTH(Y_WIDTH)) A_conv (.A(A), .Y(A_buf));
	\\$pos #(.A_SIGNED(B_SIGNED), .A_WIDTH(B_WIDTH), .Y_WIDTH(Y_WIDTH)) B_conv (.A(B), .Y(B_buf));

	function integer round_up2;
		input integer N;
		begin
			round_up2 = ((N + 1) / 2) * 2;
		end
	endfunction

	localparam Y_WIDTH2 = round_up2(Y_WIDTH);

	(* force_downto *)
	wire [Y_WIDTH2-1:0] AA = A_buf;
	(* force_downto *)
	wire [Y_WIDTH2-1:0] BB = BI ? ~B_buf : B_buf;
	(* force_downto *)
	wire [Y_WIDTH2-1:0] BX = B_buf;
	(* force_downto *)
	wire [Y_WIDTH2-1:0] C = {CO, CI};
	(* force_downto *)
	wire [Y_WIDTH2-1:0] FCO, Y1;

	genvar i;
	generate for (i = 0; i < Y_WIDTH2; i = i + 2) begin:slice
		CCU2D #(
			.INIT0(16'b0101_1010_1001_0110),
			.INIT1(16'b0101_1010_1001_0110),
			.INJECT1_0("NO"),
			.INJECT1_1("NO")
		) ccu2d_i (
			.CIN(C[i]),
			.A0(AA[i]), .B0(BX[i]), .C0(BI), .D0(1'b0),
			.A1(AA[i+1]), .B1(BX[i+1]), .C1(BI), .D1(1'b0),
			.S0(Y[i]), .S1(Y1[i]),
			.COUT(FCO[i])
		);

		assign CO[i] = (AA[i] && BB[i]) || (C[i] && (AA[i] || BB[i]));
		if (i+1 < Y_WIDTH) begin
			assign CO[i+1] = FCO[i];
			assign Y[i+1] = Y1[i];
		end
	end endgenerate

	assign X = AA ^ BB;
endmodule
`,"brams_16kd.txt":`ram block $__DP16KD_ {
	abits 14;
	widths 1 2 4 9 18 per_port;
	byte 9;
	cost 128;
	init no_undef;
	port srsw "A" "B" {
		clock anyedge;
		clken;
		wrbe_separate;
		portoption "WRITEMODE" "NORMAL" {
			rdwr no_change;
		}
		portoption "WRITEMODE" "WRITETHROUGH" {
			rdwr new;
		}
		portoption "WRITEMODE" "READBEFOREWRITE" {
			rdwr old;
		}
		option "RESETMODE" "SYNC" {
			rdsrst zero ungated block_wr;
		}
		option "RESETMODE" "ASYNC" {
			rdarst zero;
		}
		rdinit zero;
	}
}

ram block $__PDPW16KD_ {
	abits 14;
	widths 1 2 4 9 18 36 per_port;
	byte 9;
	cost 128;
	init no_undef;
	port sr "R" {
		clock anyedge;
		clken;
		option "RESETMODE" "SYNC" {
			rdsrst zero ungated;
		}
		option "RESETMODE" "ASYNC" {
			rdarst zero;
		}
		rdinit zero;
	}
	port sw "W" {
		width 36;
		clock anyedge;
		clken;
	}
}
`,"brams_8kc.txt":`ram block $__DP8KC_ {
	abits 13;
	widths 1 2 4 9 per_port;
	cost 64;
	init no_undef;
	port srsw "A" "B" {
		clock posedge;
		clken;
		portoption "WRITEMODE" "NORMAL" {
			rdwr no_change;
		}
		portoption "WRITEMODE" "WRITETHROUGH" {
			rdwr new;
		}
		portoption "WRITEMODE" "READBEFOREWRITE" {
			rdwr old;
		}
		option "RESETMODE" "SYNC" {
			rdsrst zero ungated block_wr;
		}
		option "RESETMODE" "ASYNC" {
			rdarst zero;
		}
		rdinit zero;
	}
}

ram block $__PDPW8KC_ {
	abits 13;
	widths 1 2 4 9 18 per_port;
	byte 9;
	cost 64;
	init no_undef;
	port sr "R" {
		# width 2 cannot be supported because of quirks
		# of the primitive, and memlib requires us to
		# remove width 1 as well
		width 4 9 18;
		clock posedge;
		clken;
		option "RESETMODE" "SYNC" {
			rdsrst zero ungated;
		}
		option "RESETMODE" "ASYNC" {
			rdarst zero;
		}
		rdinit zero;
	}
	port sw "W" {
		width 18;
		clock posedge;
		clken;
	}
}
`,"brams_map_16kd.v":`module $__DP16KD_ (...);

parameter INIT = 0;
parameter OPTION_RESETMODE = "SYNC";

parameter PORT_A_WIDTH = 18;
parameter PORT_A_WR_BE_WIDTH = 2;
parameter PORT_A_CLK_POL = 1;
parameter PORT_A_OPTION_WRITEMODE = "NORMAL";

input PORT_A_CLK;
input PORT_A_CLK_EN;
input PORT_A_WR_EN;
input PORT_A_RD_SRST;
input PORT_A_RD_ARST;
input [13:0] PORT_A_ADDR;
input [PORT_A_WR_BE_WIDTH-1:0] PORT_A_WR_BE;
input [PORT_A_WIDTH-1:0] PORT_A_WR_DATA;
output [PORT_A_WIDTH-1:0] PORT_A_RD_DATA;

parameter PORT_B_WIDTH = 18;
parameter PORT_B_WR_BE_WIDTH = 2;
parameter PORT_B_CLK_POL = 1;
parameter PORT_B_OPTION_WRITEMODE = "NORMAL";

input PORT_B_CLK;
input PORT_B_CLK_EN;
input PORT_B_WR_EN;
input PORT_B_RD_SRST;
input PORT_B_RD_ARST;
input [13:0] PORT_B_ADDR;
input [PORT_B_WR_BE_WIDTH-1:0] PORT_B_WR_BE;
input [PORT_B_WIDTH-1:0] PORT_B_WR_DATA;
output [PORT_B_WIDTH-1:0] PORT_B_RD_DATA;

function [319:0] init_slice;
	input integer idx;
	integer i, j;
	init_slice = 0;
	for (i = 0; i < 16; i = i + 1) begin
		init_slice[i*20+:18] = INIT[(idx * 16 + i) * 18+:18];
	end
endfunction

wire [17:0] DOA;
wire [17:0] DOB;
wire [17:0] DIA = PORT_A_WR_DATA;
wire [17:0] DIB = PORT_B_WR_DATA;

assign PORT_A_RD_DATA = DOA;
assign PORT_B_RD_DATA = DOB;

DP16KD #(
	.INITVAL_00(init_slice('h00)),
	.INITVAL_01(init_slice('h01)),
	.INITVAL_02(init_slice('h02)),
	.INITVAL_03(init_slice('h03)),
	.INITVAL_04(init_slice('h04)),
	.INITVAL_05(init_slice('h05)),
	.INITVAL_06(init_slice('h06)),
	.INITVAL_07(init_slice('h07)),
	.INITVAL_08(init_slice('h08)),
	.INITVAL_09(init_slice('h09)),
	.INITVAL_0A(init_slice('h0a)),
	.INITVAL_0B(init_slice('h0b)),
	.INITVAL_0C(init_slice('h0c)),
	.INITVAL_0D(init_slice('h0d)),
	.INITVAL_0E(init_slice('h0e)),
	.INITVAL_0F(init_slice('h0f)),
	.INITVAL_10(init_slice('h10)),
	.INITVAL_11(init_slice('h11)),
	.INITVAL_12(init_slice('h12)),
	.INITVAL_13(init_slice('h13)),
	.INITVAL_14(init_slice('h14)),
	.INITVAL_15(init_slice('h15)),
	.INITVAL_16(init_slice('h16)),
	.INITVAL_17(init_slice('h17)),
	.INITVAL_18(init_slice('h18)),
	.INITVAL_19(init_slice('h19)),
	.INITVAL_1A(init_slice('h1a)),
	.INITVAL_1B(init_slice('h1b)),
	.INITVAL_1C(init_slice('h1c)),
	.INITVAL_1D(init_slice('h1d)),
	.INITVAL_1E(init_slice('h1e)),
	.INITVAL_1F(init_slice('h1f)),
	.INITVAL_20(init_slice('h20)),
	.INITVAL_21(init_slice('h21)),
	.INITVAL_22(init_slice('h22)),
	.INITVAL_23(init_slice('h23)),
	.INITVAL_24(init_slice('h24)),
	.INITVAL_25(init_slice('h25)),
	.INITVAL_26(init_slice('h26)),
	.INITVAL_27(init_slice('h27)),
	.INITVAL_28(init_slice('h28)),
	.INITVAL_29(init_slice('h29)),
	.INITVAL_2A(init_slice('h2a)),
	.INITVAL_2B(init_slice('h2b)),
	.INITVAL_2C(init_slice('h2c)),
	.INITVAL_2D(init_slice('h2d)),
	.INITVAL_2E(init_slice('h2e)),
	.INITVAL_2F(init_slice('h2f)),
	.INITVAL_30(init_slice('h30)),
	.INITVAL_31(init_slice('h31)),
	.INITVAL_32(init_slice('h32)),
	.INITVAL_33(init_slice('h33)),
	.INITVAL_34(init_slice('h34)),
	.INITVAL_35(init_slice('h35)),
	.INITVAL_36(init_slice('h36)),
	.INITVAL_37(init_slice('h37)),
	.INITVAL_38(init_slice('h38)),
	.INITVAL_39(init_slice('h39)),
	.INITVAL_3A(init_slice('h3a)),
	.INITVAL_3B(init_slice('h3b)),
	.INITVAL_3C(init_slice('h3c)),
	.INITVAL_3D(init_slice('h3d)),
	.INITVAL_3E(init_slice('h3e)),
	.INITVAL_3F(init_slice('h3f)),
	.DATA_WIDTH_A(PORT_A_WIDTH),
	.DATA_WIDTH_B(PORT_B_WIDTH),
	.REGMODE_A("NOREG"),
	.REGMODE_B("NOREG"),
	.RESETMODE(OPTION_RESETMODE),
	.ASYNC_RESET_RELEASE(OPTION_RESETMODE),
	.CSDECODE_A("0b000"),
	.CSDECODE_B("0b000"),
	.CLKAMUX(PORT_A_CLK_POL ? "CLKA" : "INV"),
	.CLKBMUX(PORT_B_CLK_POL ? "CLKB" : "INV"),
	.WRITEMODE_A(PORT_A_OPTION_WRITEMODE),
	.WRITEMODE_B(PORT_B_OPTION_WRITEMODE),
	.GSR("AUTO")
) _TECHMAP_REPLACE_ (
	.CLKA(PORT_A_CLK),
	.WEA(PORT_A_WIDTH == 18 ? PORT_A_WR_EN : (PORT_A_WR_EN | PORT_A_WR_BE[0])),
	.CEA(PORT_A_CLK_EN),
	.OCEA(1'b1),
	.RSTA(OPTION_RESETMODE == "SYNC" ? PORT_A_RD_SRST : PORT_A_RD_ARST),
	.CSA0(1'b0),
	.CSA1(1'b0),
	.CSA2(1'b0),
	.ADA0(PORT_A_WIDTH == 18 ? PORT_A_WR_BE[0] : PORT_A_ADDR[0]),
	.ADA1(PORT_A_WIDTH == 18 ? PORT_A_WR_BE[1] : PORT_A_ADDR[1]),
	.ADA2(PORT_A_ADDR[2]),
	.ADA3(PORT_A_ADDR[3]),
	.ADA4(PORT_A_ADDR[4]),
	.ADA5(PORT_A_ADDR[5]),
	.ADA6(PORT_A_ADDR[6]),
	.ADA7(PORT_A_ADDR[7]),
	.ADA8(PORT_A_ADDR[8]),
	.ADA9(PORT_A_ADDR[9]),
	.ADA10(PORT_A_ADDR[10]),
	.ADA11(PORT_A_ADDR[11]),
	.ADA12(PORT_A_ADDR[12]),
	.ADA13(PORT_A_ADDR[13]),
	.DIA0(DIA[0]),
	.DIA1(DIA[1]),
	.DIA2(DIA[2]),
	.DIA3(DIA[3]),
	.DIA4(DIA[4]),
	.DIA5(DIA[5]),
	.DIA6(DIA[6]),
	.DIA7(DIA[7]),
	.DIA8(DIA[8]),
	.DIA9(DIA[9]),
	.DIA10(DIA[10]),
	.DIA11(DIA[11]),
	.DIA12(DIA[12]),
	.DIA13(DIA[13]),
	.DIA14(DIA[14]),
	.DIA15(DIA[15]),
	.DIA16(DIA[16]),
	.DIA17(DIA[17]),
	.DOA0(DOA[0]),
	.DOA1(DOA[1]),
	.DOA2(DOA[2]),
	.DOA3(DOA[3]),
	.DOA4(DOA[4]),
	.DOA5(DOA[5]),
	.DOA6(DOA[6]),
	.DOA7(DOA[7]),
	.DOA8(DOA[8]),
	.DOA9(DOA[9]),
	.DOA10(DOA[10]),
	.DOA11(DOA[11]),
	.DOA12(DOA[12]),
	.DOA13(DOA[13]),
	.DOA14(DOA[14]),
	.DOA15(DOA[15]),
	.DOA16(DOA[16]),
	.DOA17(DOA[17]),

	.CLKB(PORT_B_CLK),
	.WEB(PORT_B_WIDTH == 18 ? PORT_B_WR_EN : (PORT_B_WR_EN | PORT_B_WR_BE[0])),
	.CEB(PORT_B_CLK_EN),
	.OCEB(1'b1),
	.RSTB(OPTION_RESETMODE == "SYNC" ? PORT_B_RD_SRST : PORT_B_RD_ARST),
	.CSB0(1'b0),
	.CSB1(1'b0),
	.CSB2(1'b0),
	.ADB0(PORT_B_WIDTH == 18 ? PORT_B_WR_BE[0] : PORT_B_ADDR[0]),
	.ADB1(PORT_B_WIDTH == 18 ? PORT_B_WR_BE[1] : PORT_B_ADDR[1]),
	.ADB2(PORT_B_ADDR[2]),
	.ADB3(PORT_B_ADDR[3]),
	.ADB4(PORT_B_ADDR[4]),
	.ADB5(PORT_B_ADDR[5]),
	.ADB6(PORT_B_ADDR[6]),
	.ADB7(PORT_B_ADDR[7]),
	.ADB8(PORT_B_ADDR[8]),
	.ADB9(PORT_B_ADDR[9]),
	.ADB10(PORT_B_ADDR[10]),
	.ADB11(PORT_B_ADDR[11]),
	.ADB12(PORT_B_ADDR[12]),
	.ADB13(PORT_B_ADDR[13]),
	.DIB0(DIB[0]),
	.DIB1(DIB[1]),
	.DIB2(DIB[2]),
	.DIB3(DIB[3]),
	.DIB4(DIB[4]),
	.DIB5(DIB[5]),
	.DIB6(DIB[6]),
	.DIB7(DIB[7]),
	.DIB8(DIB[8]),
	.DIB9(DIB[9]),
	.DIB10(DIB[10]),
	.DIB11(DIB[11]),
	.DIB12(DIB[12]),
	.DIB13(DIB[13]),
	.DIB14(DIB[14]),
	.DIB15(DIB[15]),
	.DIB16(DIB[16]),
	.DIB17(DIB[17]),
	.DOB0(DOB[0]),
	.DOB1(DOB[1]),
	.DOB2(DOB[2]),
	.DOB3(DOB[3]),
	.DOB4(DOB[4]),
	.DOB5(DOB[5]),
	.DOB6(DOB[6]),
	.DOB7(DOB[7]),
	.DOB8(DOB[8]),
	.DOB9(DOB[9]),
	.DOB10(DOB[10]),
	.DOB11(DOB[11]),
	.DOB12(DOB[12]),
	.DOB13(DOB[13]),
	.DOB14(DOB[14]),
	.DOB15(DOB[15]),
	.DOB16(DOB[16]),
	.DOB17(DOB[17]),
);

endmodule


module $__PDPW16KD_ (...);

parameter INIT = 0;
parameter OPTION_RESETMODE = "SYNC";

parameter PORT_R_WIDTH = 36;
parameter PORT_R_CLK_POL = 1;

input PORT_R_CLK;
input PORT_R_CLK_EN;
input PORT_R_RD_SRST;
input PORT_R_RD_ARST;
input [13:0] PORT_R_ADDR;
output [PORT_R_WIDTH-1:0] PORT_R_RD_DATA;

parameter PORT_W_WIDTH = 36;
parameter PORT_W_WR_EN_WIDTH = 4;
parameter PORT_W_CLK_POL = 1;

input PORT_W_CLK;
input PORT_W_CLK_EN;
input [13:0] PORT_W_ADDR;
input [PORT_W_WR_EN_WIDTH-1:0] PORT_W_WR_EN;
input [PORT_W_WIDTH-1:0] PORT_W_WR_DATA;

function [319:0] init_slice;
	input integer idx;
	integer i, j;
	init_slice = 0;
	for (i = 0; i < 16; i = i + 1) begin
		init_slice[i*20+:18] = INIT[(idx * 16 + i) * 18+:18];
	end
endfunction

wire [35:0] DI = PORT_W_WR_DATA;
wire [35:0] DO;

assign PORT_R_RD_DATA = PORT_R_WIDTH == 36 ? DO : DO[35:18];

DP16KD #(
	.INITVAL_00(init_slice('h00)),
	.INITVAL_01(init_slice('h01)),
	.INITVAL_02(init_slice('h02)),
	.INITVAL_03(init_slice('h03)),
	.INITVAL_04(init_slice('h04)),
	.INITVAL_05(init_slice('h05)),
	.INITVAL_06(init_slice('h06)),
	.INITVAL_07(init_slice('h07)),
	.INITVAL_08(init_slice('h08)),
	.INITVAL_09(init_slice('h09)),
	.INITVAL_0A(init_slice('h0a)),
	.INITVAL_0B(init_slice('h0b)),
	.INITVAL_0C(init_slice('h0c)),
	.INITVAL_0D(init_slice('h0d)),
	.INITVAL_0E(init_slice('h0e)),
	.INITVAL_0F(init_slice('h0f)),
	.INITVAL_10(init_slice('h10)),
	.INITVAL_11(init_slice('h11)),
	.INITVAL_12(init_slice('h12)),
	.INITVAL_13(init_slice('h13)),
	.INITVAL_14(init_slice('h14)),
	.INITVAL_15(init_slice('h15)),
	.INITVAL_16(init_slice('h16)),
	.INITVAL_17(init_slice('h17)),
	.INITVAL_18(init_slice('h18)),
	.INITVAL_19(init_slice('h19)),
	.INITVAL_1A(init_slice('h1a)),
	.INITVAL_1B(init_slice('h1b)),
	.INITVAL_1C(init_slice('h1c)),
	.INITVAL_1D(init_slice('h1d)),
	.INITVAL_1E(init_slice('h1e)),
	.INITVAL_1F(init_slice('h1f)),
	.INITVAL_20(init_slice('h20)),
	.INITVAL_21(init_slice('h21)),
	.INITVAL_22(init_slice('h22)),
	.INITVAL_23(init_slice('h23)),
	.INITVAL_24(init_slice('h24)),
	.INITVAL_25(init_slice('h25)),
	.INITVAL_26(init_slice('h26)),
	.INITVAL_27(init_slice('h27)),
	.INITVAL_28(init_slice('h28)),
	.INITVAL_29(init_slice('h29)),
	.INITVAL_2A(init_slice('h2a)),
	.INITVAL_2B(init_slice('h2b)),
	.INITVAL_2C(init_slice('h2c)),
	.INITVAL_2D(init_slice('h2d)),
	.INITVAL_2E(init_slice('h2e)),
	.INITVAL_2F(init_slice('h2f)),
	.INITVAL_30(init_slice('h30)),
	.INITVAL_31(init_slice('h31)),
	.INITVAL_32(init_slice('h32)),
	.INITVAL_33(init_slice('h33)),
	.INITVAL_34(init_slice('h34)),
	.INITVAL_35(init_slice('h35)),
	.INITVAL_36(init_slice('h36)),
	.INITVAL_37(init_slice('h37)),
	.INITVAL_38(init_slice('h38)),
	.INITVAL_39(init_slice('h39)),
	.INITVAL_3A(init_slice('h3a)),
	.INITVAL_3B(init_slice('h3b)),
	.INITVAL_3C(init_slice('h3c)),
	.INITVAL_3D(init_slice('h3d)),
	.INITVAL_3E(init_slice('h3e)),
	.INITVAL_3F(init_slice('h3f)),
	.DATA_WIDTH_A(PORT_W_WIDTH),
	.DATA_WIDTH_B(PORT_R_WIDTH),
	.REGMODE_A("NOREG"),
	.REGMODE_B("NOREG"),
	.RESETMODE(OPTION_RESETMODE),
	.ASYNC_RESET_RELEASE(OPTION_RESETMODE),
	.CSDECODE_A("0b000"),
	.CSDECODE_B("0b000"),
	.CLKAMUX(PORT_W_CLK_POL ? "CLKA" : "INV"),
	.CLKBMUX(PORT_R_CLK_POL ? "CLKB" : "INV"),
	.GSR("AUTO")
) _TECHMAP_REPLACE_ (
	.CLKA(PORT_W_CLK),
	.WEA(PORT_W_WIDTH >= 18 ? 1'b1 : PORT_W_WR_EN[0]),
	.CEA(PORT_W_CLK_EN),
	.OCEA(1'b0),
	.RSTA(1'b0),
	.CSA0(1'b0),
	.CSA1(1'b0),
	.CSA2(1'b0),
	.ADA0(PORT_W_WIDTH >= 18 ? PORT_W_WR_EN[0] : PORT_W_ADDR[0]),
	.ADA1(PORT_W_WIDTH >= 18 ? PORT_W_WR_EN[1] : PORT_W_ADDR[1]),
	.ADA2(PORT_W_WIDTH >= 36 ? PORT_W_WR_EN[2] : PORT_W_ADDR[2]),
	.ADA3(PORT_W_WIDTH >= 36 ? PORT_W_WR_EN[3] : PORT_W_ADDR[3]),
	.ADA4(PORT_W_ADDR[4]),
	.ADA5(PORT_W_ADDR[5]),
	.ADA6(PORT_W_ADDR[6]),
	.ADA7(PORT_W_ADDR[7]),
	.ADA8(PORT_W_ADDR[8]),
	.ADA9(PORT_W_ADDR[9]),
	.ADA10(PORT_W_ADDR[10]),
	.ADA11(PORT_W_ADDR[11]),
	.ADA12(PORT_W_ADDR[12]),
	.ADA13(PORT_W_ADDR[13]),
	.DIA0(DI[0]),
	.DIA1(DI[1]),
	.DIA2(DI[2]),
	.DIA3(DI[3]),
	.DIA4(DI[4]),
	.DIA5(DI[5]),
	.DIA6(DI[6]),
	.DIA7(DI[7]),
	.DIA8(DI[8]),
	.DIA9(DI[9]),
	.DIA10(DI[10]),
	.DIA11(DI[11]),
	.DIA12(DI[12]),
	.DIA13(DI[13]),
	.DIA14(DI[14]),
	.DIA15(DI[15]),
	.DIA16(DI[16]),
	.DIA17(DI[17]),
	.DIB0(DI[18]),
	.DIB1(DI[19]),
	.DIB2(DI[20]),
	.DIB3(DI[21]),
	.DIB4(DI[22]),
	.DIB5(DI[23]),
	.DIB6(DI[24]),
	.DIB7(DI[25]),
	.DIB8(DI[26]),
	.DIB9(DI[27]),
	.DIB10(DI[28]),
	.DIB11(DI[29]),
	.DIB12(DI[30]),
	.DIB13(DI[31]),
	.DIB14(DI[32]),
	.DIB15(DI[33]),
	.DIB16(DI[34]),
	.DIB17(DI[35]),

	.CLKB(PORT_R_CLK),
	.WEB(1'b0),
	.CEB(PORT_R_CLK_EN),
	.OCEB(1'b1),
	.RSTB(OPTION_RESETMODE == "SYNC" ? PORT_R_RD_SRST : PORT_R_RD_ARST),
	.CSB0(1'b0),
	.CSB1(1'b0),
	.CSB2(1'b0),
	.ADB0(PORT_R_ADDR[0]),
	.ADB1(PORT_R_ADDR[1]),
	.ADB2(PORT_R_ADDR[2]),
	.ADB3(PORT_R_ADDR[3]),
	.ADB4(PORT_R_ADDR[4]),
	.ADB5(PORT_R_ADDR[5]),
	.ADB6(PORT_R_ADDR[6]),
	.ADB7(PORT_R_ADDR[7]),
	.ADB8(PORT_R_ADDR[8]),
	.ADB9(PORT_R_ADDR[9]),
	.ADB10(PORT_R_ADDR[10]),
	.ADB11(PORT_R_ADDR[11]),
	.ADB12(PORT_R_ADDR[12]),
	.ADB13(PORT_R_ADDR[13]),
	.DOA0(DO[0]),
	.DOA1(DO[1]),
	.DOA2(DO[2]),
	.DOA3(DO[3]),
	.DOA4(DO[4]),
	.DOA5(DO[5]),
	.DOA6(DO[6]),
	.DOA7(DO[7]),
	.DOA8(DO[8]),
	.DOA9(DO[9]),
	.DOA10(DO[10]),
	.DOA11(DO[11]),
	.DOA12(DO[12]),
	.DOA13(DO[13]),
	.DOA14(DO[14]),
	.DOA15(DO[15]),
	.DOA16(DO[16]),
	.DOA17(DO[17]),
	.DOB0(DO[18]),
	.DOB1(DO[19]),
	.DOB2(DO[20]),
	.DOB3(DO[21]),
	.DOB4(DO[22]),
	.DOB5(DO[23]),
	.DOB6(DO[24]),
	.DOB7(DO[25]),
	.DOB8(DO[26]),
	.DOB9(DO[27]),
	.DOB10(DO[28]),
	.DOB11(DO[29]),
	.DOB12(DO[30]),
	.DOB13(DO[31]),
	.DOB14(DO[32]),
	.DOB15(DO[33]),
	.DOB16(DO[34]),
	.DOB17(DO[35]),
);

endmodule
`,"brams_map_8kc.v":`module $__DP8KC_ (...);

parameter INIT = 0;
parameter OPTION_RESETMODE = "SYNC";

parameter PORT_A_WIDTH = 18;
parameter PORT_A_OPTION_WRITEMODE = "NORMAL";

input PORT_A_CLK;
input PORT_A_CLK_EN;
input PORT_A_WR_EN;
input PORT_A_RD_SRST;
input PORT_A_RD_ARST;
input [12:0] PORT_A_ADDR;
input [PORT_A_WIDTH-1:0] PORT_A_WR_DATA;
output [PORT_A_WIDTH-1:0] PORT_A_RD_DATA;

parameter PORT_B_WIDTH = 18;
parameter PORT_B_OPTION_WRITEMODE = "NORMAL";

input PORT_B_CLK;
input PORT_B_CLK_EN;
input PORT_B_WR_EN;
input PORT_B_RD_SRST;
input PORT_B_RD_ARST;
input [12:0] PORT_B_ADDR;
input [PORT_B_WIDTH-1:0] PORT_B_WR_DATA;
output [PORT_B_WIDTH-1:0] PORT_B_RD_DATA;

function [319:0] init_slice;
	input integer idx;
	integer i, j;
	init_slice = 0;
	for (i = 0; i < 16; i = i + 1) begin
		init_slice[i*20+:18] = INIT[(idx * 16 + i) * 18+:18];
	end
endfunction

wire [8:0] DOA;
wire [8:0] DOB;
wire [8:0] DIA;
wire [8:0] DIB;

case(PORT_A_WIDTH)
	1: assign DIA = {7'bx, PORT_A_WR_DATA[0], 1'bx};
	2: assign DIA = {3'bx, PORT_A_WR_DATA[1], 2'bx, PORT_A_WR_DATA[0], 2'bx};
	default: assign DIA = PORT_A_WR_DATA;
endcase

case(PORT_B_WIDTH)
	1: assign DIB = {7'bx, PORT_B_WR_DATA[0], 1'bx};
	2: assign DIB = {3'bx, PORT_B_WR_DATA[1], 2'bx, PORT_B_WR_DATA[0], 2'bx};
	default: assign DIB = PORT_B_WR_DATA;
endcase

assign PORT_A_RD_DATA = DOA;
assign PORT_B_RD_DATA = DOB;

DP8KC #(
	.INITVAL_00(init_slice('h00)),
	.INITVAL_01(init_slice('h01)),
	.INITVAL_02(init_slice('h02)),
	.INITVAL_03(init_slice('h03)),
	.INITVAL_04(init_slice('h04)),
	.INITVAL_05(init_slice('h05)),
	.INITVAL_06(init_slice('h06)),
	.INITVAL_07(init_slice('h07)),
	.INITVAL_08(init_slice('h08)),
	.INITVAL_09(init_slice('h09)),
	.INITVAL_0A(init_slice('h0a)),
	.INITVAL_0B(init_slice('h0b)),
	.INITVAL_0C(init_slice('h0c)),
	.INITVAL_0D(init_slice('h0d)),
	.INITVAL_0E(init_slice('h0e)),
	.INITVAL_0F(init_slice('h0f)),
	.INITVAL_10(init_slice('h10)),
	.INITVAL_11(init_slice('h11)),
	.INITVAL_12(init_slice('h12)),
	.INITVAL_13(init_slice('h13)),
	.INITVAL_14(init_slice('h14)),
	.INITVAL_15(init_slice('h15)),
	.INITVAL_16(init_slice('h16)),
	.INITVAL_17(init_slice('h17)),
	.INITVAL_18(init_slice('h18)),
	.INITVAL_19(init_slice('h19)),
	.INITVAL_1A(init_slice('h1a)),
	.INITVAL_1B(init_slice('h1b)),
	.INITVAL_1C(init_slice('h1c)),
	.INITVAL_1D(init_slice('h1d)),
	.INITVAL_1E(init_slice('h1e)),
	.INITVAL_1F(init_slice('h1f)),
	.DATA_WIDTH_A(PORT_A_WIDTH),
	.DATA_WIDTH_B(PORT_B_WIDTH),
	.REGMODE_A("NOREG"),
	.REGMODE_B("NOREG"),
	.RESETMODE(OPTION_RESETMODE),
	.ASYNC_RESET_RELEASE(OPTION_RESETMODE),
	.CSDECODE_A("0b000"),
	.CSDECODE_B("0b000"),
	.WRITEMODE_A(PORT_A_OPTION_WRITEMODE),
	.WRITEMODE_B(PORT_B_OPTION_WRITEMODE),
	.GSR("AUTO")
) _TECHMAP_REPLACE_ (
	.CLKA(PORT_A_CLK),
	.WEA(PORT_A_WR_EN),
	.CEA(PORT_A_CLK_EN),
	.OCEA(1'b1),
	.RSTA(OPTION_RESETMODE == "SYNC" ? PORT_A_RD_SRST : PORT_A_RD_ARST),
	.CSA0(1'b0),
	.CSA1(1'b0),
	.CSA2(1'b0),
	.ADA0(PORT_A_WIDTH == 9 ? 1'b1 : PORT_A_ADDR[0]),
	.ADA1(PORT_A_ADDR[1]),
	.ADA2(PORT_A_ADDR[2]),
	.ADA3(PORT_A_ADDR[3]),
	.ADA4(PORT_A_ADDR[4]),
	.ADA5(PORT_A_ADDR[5]),
	.ADA6(PORT_A_ADDR[6]),
	.ADA7(PORT_A_ADDR[7]),
	.ADA8(PORT_A_ADDR[8]),
	.ADA9(PORT_A_ADDR[9]),
	.ADA10(PORT_A_ADDR[10]),
	.ADA11(PORT_A_ADDR[11]),
	.ADA12(PORT_A_ADDR[12]),
	.DIA0(DIA[0]),
	.DIA1(DIA[1]),
	.DIA2(DIA[2]),
	.DIA3(DIA[3]),
	.DIA4(DIA[4]),
	.DIA5(DIA[5]),
	.DIA6(DIA[6]),
	.DIA7(DIA[7]),
	.DIA8(DIA[8]),
	.DOA0(DOA[0]),
	.DOA1(DOA[1]),
	.DOA2(DOA[2]),
	.DOA3(DOA[3]),
	.DOA4(DOA[4]),
	.DOA5(DOA[5]),
	.DOA6(DOA[6]),
	.DOA7(DOA[7]),
	.DOA8(DOA[8]),

	.CLKB(PORT_B_CLK),
	.WEB(PORT_B_WR_EN),
	.CEB(PORT_B_CLK_EN),
	.OCEB(1'b1),
	.RSTB(OPTION_RESETMODE == "SYNC" ? PORT_B_RD_SRST : PORT_B_RD_ARST),
	.CSB0(1'b0),
	.CSB1(1'b0),
	.CSB2(1'b0),
	.ADB0(PORT_B_WIDTH == 9 ? 1'b1 : PORT_B_ADDR[0]),
	.ADB1(PORT_B_ADDR[1]),
	.ADB2(PORT_B_ADDR[2]),
	.ADB3(PORT_B_ADDR[3]),
	.ADB4(PORT_B_ADDR[4]),
	.ADB5(PORT_B_ADDR[5]),
	.ADB6(PORT_B_ADDR[6]),
	.ADB7(PORT_B_ADDR[7]),
	.ADB8(PORT_B_ADDR[8]),
	.ADB9(PORT_B_ADDR[9]),
	.ADB10(PORT_B_ADDR[10]),
	.ADB11(PORT_B_ADDR[11]),
	.ADB12(PORT_B_ADDR[12]),
	.DIB0(DIB[0]),
	.DIB1(DIB[1]),
	.DIB2(DIB[2]),
	.DIB3(DIB[3]),
	.DIB4(DIB[4]),
	.DIB5(DIB[5]),
	.DIB6(DIB[6]),
	.DIB7(DIB[7]),
	.DIB8(DIB[8]),
	.DOB0(DOB[0]),
	.DOB1(DOB[1]),
	.DOB2(DOB[2]),
	.DOB3(DOB[3]),
	.DOB4(DOB[4]),
	.DOB5(DOB[5]),
	.DOB6(DOB[6]),
	.DOB7(DOB[7]),
	.DOB8(DOB[8]),
);

endmodule


module $__PDPW8KC_ (...);

parameter INIT = 0;
parameter OPTION_RESETMODE = "SYNC";

parameter PORT_R_WIDTH = 18;

input PORT_R_CLK;
input PORT_R_CLK_EN;
input PORT_R_RD_SRST;
input PORT_R_RD_ARST;
input [12:0] PORT_R_ADDR;
output [PORT_R_WIDTH-1:0] PORT_R_RD_DATA;

parameter PORT_W_WIDTH = 18;
parameter PORT_W_WR_EN_WIDTH = 2;

input PORT_W_CLK;
input PORT_W_CLK_EN;
input [12:0] PORT_W_ADDR;
input [PORT_W_WR_EN_WIDTH-1:0] PORT_W_WR_EN;
input [PORT_W_WIDTH-1:0] PORT_W_WR_DATA;

function [319:0] init_slice;
	input integer idx;
	integer i, j;
	init_slice = 0;
	for (i = 0; i < 16; i = i + 1) begin
		init_slice[i*20+:18] = INIT[(idx * 16 + i) * 18+:18];
	end
endfunction

wire [17:0] DI = PORT_W_WR_DATA;
wire [17:0] DO;

assign PORT_R_RD_DATA = PORT_R_WIDTH == 18 ? DO : DO[17:9];

DP8KC #(
	.INITVAL_00(init_slice('h00)),
	.INITVAL_01(init_slice('h01)),
	.INITVAL_02(init_slice('h02)),
	.INITVAL_03(init_slice('h03)),
	.INITVAL_04(init_slice('h04)),
	.INITVAL_05(init_slice('h05)),
	.INITVAL_06(init_slice('h06)),
	.INITVAL_07(init_slice('h07)),
	.INITVAL_08(init_slice('h08)),
	.INITVAL_09(init_slice('h09)),
	.INITVAL_0A(init_slice('h0a)),
	.INITVAL_0B(init_slice('h0b)),
	.INITVAL_0C(init_slice('h0c)),
	.INITVAL_0D(init_slice('h0d)),
	.INITVAL_0E(init_slice('h0e)),
	.INITVAL_0F(init_slice('h0f)),
	.INITVAL_10(init_slice('h10)),
	.INITVAL_11(init_slice('h11)),
	.INITVAL_12(init_slice('h12)),
	.INITVAL_13(init_slice('h13)),
	.INITVAL_14(init_slice('h14)),
	.INITVAL_15(init_slice('h15)),
	.INITVAL_16(init_slice('h16)),
	.INITVAL_17(init_slice('h17)),
	.INITVAL_18(init_slice('h18)),
	.INITVAL_19(init_slice('h19)),
	.INITVAL_1A(init_slice('h1a)),
	.INITVAL_1B(init_slice('h1b)),
	.INITVAL_1C(init_slice('h1c)),
	.INITVAL_1D(init_slice('h1d)),
	.INITVAL_1E(init_slice('h1e)),
	.INITVAL_1F(init_slice('h1f)),
	.DATA_WIDTH_A(PORT_W_WIDTH),
	.DATA_WIDTH_B(PORT_R_WIDTH),
	.REGMODE_A("NOREG"),
	.REGMODE_B("NOREG"),
	.RESETMODE(OPTION_RESETMODE),
	.ASYNC_RESET_RELEASE(OPTION_RESETMODE),
	.CSDECODE_A("0b000"),
	.CSDECODE_B("0b000"),
	.GSR("AUTO")
) _TECHMAP_REPLACE_ (
	.CLKA(PORT_W_CLK),
	.WEA(PORT_W_WIDTH >= 9 ? 1'b1 : PORT_W_WR_EN[0]),
	.CEA(PORT_W_CLK_EN),
	.OCEA(1'b0),
	.RSTA(1'b0),
	.CSA0(1'b0),
	.CSA1(1'b0),
	.CSA2(1'b0),
	.ADA0(PORT_W_WIDTH >= 9 ? PORT_W_WR_EN[0] : PORT_W_ADDR[0]),
	.ADA1(PORT_W_WIDTH >= 18 ? PORT_W_WR_EN[1] : PORT_W_ADDR[1]),
	.ADA2(PORT_W_ADDR[2]),
	.ADA3(PORT_W_ADDR[3]),
	.ADA4(PORT_W_ADDR[4]),
	.ADA5(PORT_W_ADDR[5]),
	.ADA6(PORT_W_ADDR[6]),
	.ADA7(PORT_W_ADDR[7]),
	.ADA8(PORT_W_ADDR[8]),
	.ADA9(PORT_W_ADDR[9]),
	.ADA10(PORT_W_ADDR[10]),
	.ADA11(PORT_W_ADDR[11]),
	.ADA12(PORT_W_ADDR[12]),
	.DIA0(DI[0]),
	.DIA1(DI[1]),
	.DIA2(DI[2]),
	.DIA3(DI[3]),
	.DIA4(DI[4]),
	.DIA5(DI[5]),
	.DIA6(DI[6]),
	.DIA7(DI[7]),
	.DIA8(DI[8]),
	.DIB0(DI[9]),
	.DIB1(DI[10]),
	.DIB2(DI[11]),
	.DIB3(DI[12]),
	.DIB4(DI[13]),
	.DIB5(DI[14]),
	.DIB6(DI[15]),
	.DIB7(DI[16]),
	.DIB8(DI[17]),

	.CLKB(PORT_R_CLK),
	.WEB(1'b0),
	.CEB(PORT_R_CLK_EN),
	.OCEB(1'b1),
	.RSTB(OPTION_RESETMODE == "SYNC" ? PORT_R_RD_SRST : PORT_R_RD_ARST),
	.CSB0(1'b0),
	.CSB1(1'b0),
	.CSB2(1'b0),
	.ADB0(PORT_R_ADDR[0]),
	.ADB1(PORT_R_ADDR[1]),
	.ADB2(PORT_R_ADDR[2]),
	.ADB3(PORT_R_ADDR[3]),
	.ADB4(PORT_R_ADDR[4]),
	.ADB5(PORT_R_ADDR[5]),
	.ADB6(PORT_R_ADDR[6]),
	.ADB7(PORT_R_ADDR[7]),
	.ADB8(PORT_R_ADDR[8]),
	.ADB9(PORT_R_ADDR[9]),
	.ADB10(PORT_R_ADDR[10]),
	.ADB11(PORT_R_ADDR[11]),
	.ADB12(PORT_R_ADDR[12]),
	.DOA0(DO[0]),
	.DOA1(DO[1]),
	.DOA2(DO[2]),
	.DOA3(DO[3]),
	.DOA4(DO[4]),
	.DOA5(DO[5]),
	.DOA6(DO[6]),
	.DOA7(DO[7]),
	.DOA8(DO[8]),
	.DOB0(DO[9]),
	.DOB1(DO[10]),
	.DOB2(DO[11]),
	.DOB3(DO[12]),
	.DOB4(DO[13]),
	.DOB5(DO[14]),
	.DOB6(DO[15]),
	.DOB7(DO[16]),
	.DOB8(DO[17]),
);

endmodule
`,"ccu2c_sim.vh":`// ---------------------------------------
(* abc9_box, lib_whitebox *)
module CCU2C(
	(* abc9_carry *)
	input  CIN,
	input  A0, B0, C0, D0, A1, B1, C1, D1,
	output S0, S1,
	(* abc9_carry *)
	output COUT
);
	parameter [15:0] INIT0 = 16'h0000;
	parameter [15:0] INIT1 = 16'h0000;
	parameter INJECT1_0 = "YES";
	parameter INJECT1_1 = "YES";

	// First half
	wire LUT4_0, LUT2_0;
	LUT4 #(.INIT(INIT0)) lut4_0(.A(A0), .B(B0), .C(C0), .D(D0), .Z(LUT4_0));
	LUT2 #(.INIT(INIT0[3:0])) lut2_0(.A(A0), .B(B0), .Z(LUT2_0));
	wire gated_cin_0 = (INJECT1_0 == "YES") ? 1'b0 : CIN;
	assign S0 = LUT4_0 ^ gated_cin_0;

	wire gated_lut2_0 = (INJECT1_0 == "YES") ? 1'b0 : LUT2_0;
	wire cout_0 = (~LUT4_0 & gated_lut2_0) | (LUT4_0 & CIN);

	// Second half
	wire LUT4_1, LUT2_1;
	LUT4 #(.INIT(INIT1)) lut4_1(.A(A1), .B(B1), .C(C1), .D(D1), .Z(LUT4_1));
	LUT2 #(.INIT(INIT1[3:0])) lut2_1(.A(A1), .B(B1), .Z(LUT2_1));
	wire gated_cin_1 = (INJECT1_1 == "YES") ? 1'b0 : cout_0;
	assign S1 = LUT4_1 ^ gated_cin_1;

	wire gated_lut2_1 = (INJECT1_1 == "YES") ? 1'b0 : LUT2_1;
	assign COUT = (~LUT4_1 & gated_lut2_1) | (LUT4_1 & cout_0);

	specify
		(A0 => S0) = 379;
		(B0 => S0) = 379;
		(C0 => S0) = 275;
		(D0 => S0) = 141;
		(CIN => S0) = 257;
		(A0 => S1) = 630;
		(B0 => S1) = 630;
		(C0 => S1) = 526;
		(D0 => S1) = 392;
		(A1 => S1) = 379;
		(B1 => S1) = 379;
		(C1 => S1) = 275;
		(D1 => S1) = 141;
		(CIN => S1) = 273;
		(A0 => COUT) = 516;
		(B0 => COUT) = 516;
		(C0 => COUT) = 412;
		(D0 => COUT) = 278;
		(A1 => COUT) = 516;
		(B1 => COUT) = 516;
		(C1 => COUT) = 412;
		(D1 => COUT) = 278;
		(CIN => COUT) = 43;
	endspecify
endmodule
`,"ccu2d_sim.vh":`// ---------------------------------------
(* lib_whitebox *)
module CCU2D (
	input  CIN,
	input  A0, B0, C0, D0, A1, B1, C1, D1,
	output S0, S1,
	output COUT
);
	parameter [15:0] INIT0 = 16'h0000;
	parameter [15:0] INIT1 = 16'h0000;
	parameter INJECT1_0 = "YES";
	parameter INJECT1_1 = "YES";

	// First half
	wire LUT4_0, LUT2_0;
	LUT4 #(.INIT(INIT0)) lut4_0(.A(A0), .B(B0), .C(C0), .D(D0), .Z(LUT4_0));
	LUT2 #(.INIT(~INIT0[15:12])) lut2_0(.A(A0), .B(B0), .Z(LUT2_0));
	wire gated_cin_0 = (INJECT1_0 == "YES") ? 1'b0 : CIN;
	assign S0 = LUT4_0 ^ gated_cin_0;

	wire gated_lut2_0 = (INJECT1_0 == "YES") ? 1'b0 : LUT2_0;
	wire cout_0 = (~LUT4_0 & gated_lut2_0) | (LUT4_0 & CIN);

	// Second half
	wire LUT4_1, LUT2_1;
	LUT4 #(.INIT(INIT1)) lut4_1(.A(A1), .B(B1), .C(C1), .D(D1), .Z(LUT4_1));
	LUT2 #(.INIT(~INIT1[15:12])) lut2_1(.A(A1), .B(B1), .Z(LUT2_1));
	wire gated_cin_1 = (INJECT1_1 == "YES") ? 1'b0 : cout_0;
	assign S1 = LUT4_1 ^ gated_cin_1;

	wire gated_lut2_1 = (INJECT1_1 == "YES") ? 1'b0 : LUT2_1;
	assign COUT = (~LUT4_1 & gated_lut2_1) | (LUT4_1 & cout_0);
endmodule
`,"cells_bb_ecp5.v":`// Created by cells_xtra.py from Lattice models

(* blackbox *) (* keep *)
module GSR (...);
    input GSR;
endmodule

(* blackbox *)
module PUR (...);
    parameter RST_PULSE = 1;
    input PUR;
endmodule

(* blackbox *) (* keep *)
module SGSR (...);
    input GSR;
    input CLK;
endmodule

(* blackbox *)
module DP16KD (...);
    parameter DATA_WIDTH_A = 18;
    parameter DATA_WIDTH_B = 18;
    parameter REGMODE_A = "NOREG";
    parameter REGMODE_B = "NOREG";
    parameter RESETMODE = "SYNC";
    parameter ASYNC_RESET_RELEASE = "SYNC";
    parameter WRITEMODE_A = "NORMAL";
    parameter WRITEMODE_B = "NORMAL";
    parameter CSDECODE_A = "0b000";
    parameter CSDECODE_B = "0b000";
    parameter GSR = "ENABLED";
    parameter INITVAL_00 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_01 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_02 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_03 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_04 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_05 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_06 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_07 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_08 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_09 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_10 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_11 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_12 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_13 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_14 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_15 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_16 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_17 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_18 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_19 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_20 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_21 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_22 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_23 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_24 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_25 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_26 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_27 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_28 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_29 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_2A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_2B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_2C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_2D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_2E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_2F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_30 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_31 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_32 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_33 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_34 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_35 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_36 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_37 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_38 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_39 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_3A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_3B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_3C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_3D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_3E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_3F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INIT_DATA = "STATIC";
    input DIA17;
    input DIA16;
    input DIA15;
    input DIA14;
    input DIA13;
    input DIA12;
    input DIA11;
    input DIA10;
    input DIA9;
    input DIA8;
    input DIA7;
    input DIA6;
    input DIA5;
    input DIA4;
    input DIA3;
    input DIA2;
    input DIA1;
    input DIA0;
    input ADA13;
    input ADA12;
    input ADA11;
    input ADA10;
    input ADA9;
    input ADA8;
    input ADA7;
    input ADA6;
    input ADA5;
    input ADA4;
    input ADA3;
    input ADA2;
    input ADA1;
    input ADA0;
    input CEA;
    input OCEA;
    input CLKA;
    input WEA;
    input CSA2;
    input CSA1;
    input CSA0;
    input RSTA;
    input DIB17;
    input DIB16;
    input DIB15;
    input DIB14;
    input DIB13;
    input DIB12;
    input DIB11;
    input DIB10;
    input DIB9;
    input DIB8;
    input DIB7;
    input DIB6;
    input DIB5;
    input DIB4;
    input DIB3;
    input DIB2;
    input DIB1;
    input DIB0;
    input ADB13;
    input ADB12;
    input ADB11;
    input ADB10;
    input ADB9;
    input ADB8;
    input ADB7;
    input ADB6;
    input ADB5;
    input ADB4;
    input ADB3;
    input ADB2;
    input ADB1;
    input ADB0;
    input CEB;
    input OCEB;
    input CLKB;
    input WEB;
    input CSB2;
    input CSB1;
    input CSB0;
    input RSTB;
    output DOA17;
    output DOA16;
    output DOA15;
    output DOA14;
    output DOA13;
    output DOA12;
    output DOA11;
    output DOA10;
    output DOA9;
    output DOA8;
    output DOA7;
    output DOA6;
    output DOA5;
    output DOA4;
    output DOA3;
    output DOA2;
    output DOA1;
    output DOA0;
    output DOB17;
    output DOB16;
    output DOB15;
    output DOB14;
    output DOB13;
    output DOB12;
    output DOB11;
    output DOB10;
    output DOB9;
    output DOB8;
    output DOB7;
    output DOB6;
    output DOB5;
    output DOB4;
    output DOB3;
    output DOB2;
    output DOB1;
    output DOB0;
endmodule

(* blackbox *)
module PDPW16KD (...);
    parameter DATA_WIDTH_W = 36;
    parameter DATA_WIDTH_R = 36;
    parameter GSR = "ENABLED";
    parameter REGMODE = "NOREG";
    parameter RESETMODE = "SYNC";
    parameter ASYNC_RESET_RELEASE = "SYNC";
    parameter CSDECODE_W = "0b000";
    parameter CSDECODE_R = "0b000";
    parameter INITVAL_00 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_01 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_02 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_03 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_04 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_05 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_06 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_07 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_08 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_09 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_10 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_11 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_12 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_13 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_14 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_15 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_16 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_17 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_18 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_19 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_20 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_21 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_22 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_23 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_24 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_25 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_26 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_27 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_28 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_29 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_2A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_2B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_2C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_2D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_2E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_2F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_30 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_31 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_32 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_33 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_34 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_35 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_36 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_37 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_38 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_39 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_3A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_3B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_3C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_3D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_3E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_3F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INIT_DATA = "STATIC";
    input DI35;
    input DI34;
    input DI33;
    input DI32;
    input DI31;
    input DI30;
    input DI29;
    input DI28;
    input DI27;
    input DI26;
    input DI25;
    input DI24;
    input DI23;
    input DI22;
    input DI21;
    input DI20;
    input DI19;
    input DI18;
    input DI17;
    input DI16;
    input DI15;
    input DI14;
    input DI13;
    input DI12;
    input DI11;
    input DI10;
    input DI9;
    input DI8;
    input DI7;
    input DI6;
    input DI5;
    input DI4;
    input DI3;
    input DI2;
    input DI1;
    input DI0;
    input ADW8;
    input ADW7;
    input ADW6;
    input ADW5;
    input ADW4;
    input ADW3;
    input ADW2;
    input ADW1;
    input ADW0;
    input BE3;
    input BE2;
    input BE1;
    input BE0;
    input CEW;
    input CLKW;
    input CSW2;
    input CSW1;
    input CSW0;
    input ADR13;
    input ADR12;
    input ADR11;
    input ADR10;
    input ADR9;
    input ADR8;
    input ADR7;
    input ADR6;
    input ADR5;
    input ADR4;
    input ADR3;
    input ADR2;
    input ADR1;
    input ADR0;
    input CER;
    input OCER;
    input CLKR;
    input CSR2;
    input CSR1;
    input CSR0;
    input RST;
    output DO35;
    output DO34;
    output DO33;
    output DO32;
    output DO31;
    output DO30;
    output DO29;
    output DO28;
    output DO27;
    output DO26;
    output DO25;
    output DO24;
    output DO23;
    output DO22;
    output DO21;
    output DO20;
    output DO19;
    output DO18;
    output DO17;
    output DO16;
    output DO15;
    output DO14;
    output DO13;
    output DO12;
    output DO11;
    output DO10;
    output DO9;
    output DO8;
    output DO7;
    output DO6;
    output DO5;
    output DO4;
    output DO3;
    output DO2;
    output DO1;
    output DO0;
endmodule

(* blackbox *)
module MULT18X18D (...);
    parameter REG_INPUTA_CLK = "NONE";
    parameter REG_INPUTA_CE = "CE0";
    parameter REG_INPUTA_RST = "RST0";
    parameter REG_INPUTB_CLK = "NONE";
    parameter REG_INPUTB_CE = "CE0";
    parameter REG_INPUTB_RST = "RST0";
    parameter REG_INPUTC_CLK = "NONE";
    parameter REG_INPUTC_CE = "CE0";
    parameter REG_INPUTC_RST = "RST0";
    parameter REG_PIPELINE_CLK = "NONE";
    parameter REG_PIPELINE_CE = "CE0";
    parameter REG_PIPELINE_RST = "RST0";
    parameter REG_OUTPUT_CLK = "NONE";
    parameter REG_OUTPUT_CE = "CE0";
    parameter REG_OUTPUT_RST = "RST0";
    parameter CLK0_DIV = "ENABLED";
    parameter CLK1_DIV = "ENABLED";
    parameter CLK2_DIV = "ENABLED";
    parameter CLK3_DIV = "ENABLED";
    parameter HIGHSPEED_CLK = "NONE";
    parameter GSR = "ENABLED";
    parameter CAS_MATCH_REG = "FALSE";
    parameter SOURCEB_MODE = "B_SHIFT";
    parameter MULT_BYPASS = "DISABLED";
    parameter RESETMODE = "SYNC";
    input A17;
    input A16;
    input A15;
    input A14;
    input A13;
    input A12;
    input A11;
    input A10;
    input A9;
    input A8;
    input A7;
    input A6;
    input A5;
    input A4;
    input A3;
    input A2;
    input A1;
    input A0;
    input B17;
    input B16;
    input B15;
    input B14;
    input B13;
    input B12;
    input B11;
    input B10;
    input B9;
    input B8;
    input B7;
    input B6;
    input B5;
    input B4;
    input B3;
    input B2;
    input B1;
    input B0;
    input C17;
    input C16;
    input C15;
    input C14;
    input C13;
    input C12;
    input C11;
    input C10;
    input C9;
    input C8;
    input C7;
    input C6;
    input C5;
    input C4;
    input C3;
    input C2;
    input C1;
    input C0;
    input SIGNEDA;
    input SIGNEDB;
    input SOURCEA;
    input SOURCEB;
    input CLK3;
    input CLK2;
    input CLK1;
    input CLK0;
    input CE3;
    input CE2;
    input CE1;
    input CE0;
    input RST3;
    input RST2;
    input RST1;
    input RST0;
    input SRIA17;
    input SRIA16;
    input SRIA15;
    input SRIA14;
    input SRIA13;
    input SRIA12;
    input SRIA11;
    input SRIA10;
    input SRIA9;
    input SRIA8;
    input SRIA7;
    input SRIA6;
    input SRIA5;
    input SRIA4;
    input SRIA3;
    input SRIA2;
    input SRIA1;
    input SRIA0;
    input SRIB17;
    input SRIB16;
    input SRIB15;
    input SRIB14;
    input SRIB13;
    input SRIB12;
    input SRIB11;
    input SRIB10;
    input SRIB9;
    input SRIB8;
    input SRIB7;
    input SRIB6;
    input SRIB5;
    input SRIB4;
    input SRIB3;
    input SRIB2;
    input SRIB1;
    input SRIB0;
    output SROA17;
    output SROA16;
    output SROA15;
    output SROA14;
    output SROA13;
    output SROA12;
    output SROA11;
    output SROA10;
    output SROA9;
    output SROA8;
    output SROA7;
    output SROA6;
    output SROA5;
    output SROA4;
    output SROA3;
    output SROA2;
    output SROA1;
    output SROA0;
    output SROB17;
    output SROB16;
    output SROB15;
    output SROB14;
    output SROB13;
    output SROB12;
    output SROB11;
    output SROB10;
    output SROB9;
    output SROB8;
    output SROB7;
    output SROB6;
    output SROB5;
    output SROB4;
    output SROB3;
    output SROB2;
    output SROB1;
    output SROB0;
    output ROA17;
    output ROA16;
    output ROA15;
    output ROA14;
    output ROA13;
    output ROA12;
    output ROA11;
    output ROA10;
    output ROA9;
    output ROA8;
    output ROA7;
    output ROA6;
    output ROA5;
    output ROA4;
    output ROA3;
    output ROA2;
    output ROA1;
    output ROA0;
    output ROB17;
    output ROB16;
    output ROB15;
    output ROB14;
    output ROB13;
    output ROB12;
    output ROB11;
    output ROB10;
    output ROB9;
    output ROB8;
    output ROB7;
    output ROB6;
    output ROB5;
    output ROB4;
    output ROB3;
    output ROB2;
    output ROB1;
    output ROB0;
    output ROC17;
    output ROC16;
    output ROC15;
    output ROC14;
    output ROC13;
    output ROC12;
    output ROC11;
    output ROC10;
    output ROC9;
    output ROC8;
    output ROC7;
    output ROC6;
    output ROC5;
    output ROC4;
    output ROC3;
    output ROC2;
    output ROC1;
    output ROC0;
    output P35;
    output P34;
    output P33;
    output P32;
    output P31;
    output P30;
    output P29;
    output P28;
    output P27;
    output P26;
    output P25;
    output P24;
    output P23;
    output P22;
    output P21;
    output P20;
    output P19;
    output P18;
    output P17;
    output P16;
    output P15;
    output P14;
    output P13;
    output P12;
    output P11;
    output P10;
    output P9;
    output P8;
    output P7;
    output P6;
    output P5;
    output P4;
    output P3;
    output P2;
    output P1;
    output P0;
    output SIGNEDP;
endmodule

(* blackbox *)
module ALU54B (...);
    parameter REG_INPUTC0_CLK = "NONE";
    parameter REG_INPUTC0_CE = "CE0";
    parameter REG_INPUTC0_RST = "RST0";
    parameter REG_INPUTC1_CLK = "NONE";
    parameter REG_INPUTC1_CE = "CE0";
    parameter REG_INPUTC1_RST = "RST0";
    parameter REG_OPCODEOP0_0_CLK = "NONE";
    parameter REG_OPCODEOP0_0_CE = "CE0";
    parameter REG_OPCODEOP0_0_RST = "RST0";
    parameter REG_OPCODEOP1_0_CLK = "NONE";
    parameter REG_OPCODEOP0_1_CLK = "NONE";
    parameter REG_OPCODEOP0_1_CE = "CE0";
    parameter REG_OPCODEOP0_1_RST = "RST0";
    parameter REG_OPCODEOP1_1_CLK = "NONE";
    parameter REG_OPCODEIN_0_CLK = "NONE";
    parameter REG_OPCODEIN_0_CE = "CE0";
    parameter REG_OPCODEIN_0_RST = "RST0";
    parameter REG_OPCODEIN_1_CLK = "NONE";
    parameter REG_OPCODEIN_1_CE = "CE0";
    parameter REG_OPCODEIN_1_RST = "RST0";
    parameter REG_OUTPUT0_CLK = "NONE";
    parameter REG_OUTPUT0_CE = "CE0";
    parameter REG_OUTPUT0_RST = "RST0";
    parameter REG_OUTPUT1_CLK = "NONE";
    parameter REG_OUTPUT1_CE = "CE0";
    parameter REG_OUTPUT1_RST = "RST0";
    parameter REG_FLAG_CLK = "NONE";
    parameter REG_FLAG_CE = "CE0";
    parameter REG_FLAG_RST = "RST0";
    parameter MCPAT_SOURCE = "STATIC";
    parameter MASKPAT_SOURCE = "STATIC";
    parameter MASK01 = "0x00000000000000";
    parameter REG_INPUTCFB_CLK = "NONE";
    parameter REG_INPUTCFB_CE = "CE0";
    parameter REG_INPUTCFB_RST = "RST0";
    parameter CLK0_DIV = "ENABLED";
    parameter CLK1_DIV = "ENABLED";
    parameter CLK2_DIV = "ENABLED";
    parameter CLK3_DIV = "ENABLED";
    parameter MCPAT = "0x00000000000000";
    parameter MASKPAT = "0x00000000000000";
    parameter RNDPAT = "0x00000000000000";
    parameter GSR = "ENABLED";
    parameter RESETMODE = "SYNC";
    parameter MULT9_MODE = "DISABLED";
    parameter FORCE_ZERO_BARREL_SHIFT = "DISABLED";
    parameter LEGACY = "DISABLED";
    input CE3;
    input CE2;
    input CE1;
    input CE0;
    input CLK3;
    input CLK2;
    input CLK1;
    input CLK0;
    input RST3;
    input RST2;
    input RST1;
    input RST0;
    input SIGNEDIA;
    input SIGNEDIB;
    input SIGNEDCIN;
    input A35;
    input A34;
    input A33;
    input A32;
    input A31;
    input A30;
    input A29;
    input A28;
    input A27;
    input A26;
    input A25;
    input A24;
    input A23;
    input A22;
    input A21;
    input A20;
    input A19;
    input A18;
    input A17;
    input A16;
    input A15;
    input A14;
    input A13;
    input A12;
    input A11;
    input A10;
    input A9;
    input A8;
    input A7;
    input A6;
    input A5;
    input A4;
    input A3;
    input A2;
    input A1;
    input A0;
    input B35;
    input B34;
    input B33;
    input B32;
    input B31;
    input B30;
    input B29;
    input B28;
    input B27;
    input B26;
    input B25;
    input B24;
    input B23;
    input B22;
    input B21;
    input B20;
    input B19;
    input B18;
    input B17;
    input B16;
    input B15;
    input B14;
    input B13;
    input B12;
    input B11;
    input B10;
    input B9;
    input B8;
    input B7;
    input B6;
    input B5;
    input B4;
    input B3;
    input B2;
    input B1;
    input B0;
    input C53;
    input C52;
    input C51;
    input C50;
    input C49;
    input C48;
    input C47;
    input C46;
    input C45;
    input C44;
    input C43;
    input C42;
    input C41;
    input C40;
    input C39;
    input C38;
    input C37;
    input C36;
    input C35;
    input C34;
    input C33;
    input C32;
    input C31;
    input C30;
    input C29;
    input C28;
    input C27;
    input C26;
    input C25;
    input C24;
    input C23;
    input C22;
    input C21;
    input C20;
    input C19;
    input C18;
    input C17;
    input C16;
    input C15;
    input C14;
    input C13;
    input C12;
    input C11;
    input C10;
    input C9;
    input C8;
    input C7;
    input C6;
    input C5;
    input C4;
    input C3;
    input C2;
    input C1;
    input C0;
    input CFB53;
    input CFB52;
    input CFB51;
    input CFB50;
    input CFB49;
    input CFB48;
    input CFB47;
    input CFB46;
    input CFB45;
    input CFB44;
    input CFB43;
    input CFB42;
    input CFB41;
    input CFB40;
    input CFB39;
    input CFB38;
    input CFB37;
    input CFB36;
    input CFB35;
    input CFB34;
    input CFB33;
    input CFB32;
    input CFB31;
    input CFB30;
    input CFB29;
    input CFB28;
    input CFB27;
    input CFB26;
    input CFB25;
    input CFB24;
    input CFB23;
    input CFB22;
    input CFB21;
    input CFB20;
    input CFB19;
    input CFB18;
    input CFB17;
    input CFB16;
    input CFB15;
    input CFB14;
    input CFB13;
    input CFB12;
    input CFB11;
    input CFB10;
    input CFB9;
    input CFB8;
    input CFB7;
    input CFB6;
    input CFB5;
    input CFB4;
    input CFB3;
    input CFB2;
    input CFB1;
    input CFB0;
    input MA35;
    input MA34;
    input MA33;
    input MA32;
    input MA31;
    input MA30;
    input MA29;
    input MA28;
    input MA27;
    input MA26;
    input MA25;
    input MA24;
    input MA23;
    input MA22;
    input MA21;
    input MA20;
    input MA19;
    input MA18;
    input MA17;
    input MA16;
    input MA15;
    input MA14;
    input MA13;
    input MA12;
    input MA11;
    input MA10;
    input MA9;
    input MA8;
    input MA7;
    input MA6;
    input MA5;
    input MA4;
    input MA3;
    input MA2;
    input MA1;
    input MA0;
    input MB35;
    input MB34;
    input MB33;
    input MB32;
    input MB31;
    input MB30;
    input MB29;
    input MB28;
    input MB27;
    input MB26;
    input MB25;
    input MB24;
    input MB23;
    input MB22;
    input MB21;
    input MB20;
    input MB19;
    input MB18;
    input MB17;
    input MB16;
    input MB15;
    input MB14;
    input MB13;
    input MB12;
    input MB11;
    input MB10;
    input MB9;
    input MB8;
    input MB7;
    input MB6;
    input MB5;
    input MB4;
    input MB3;
    input MB2;
    input MB1;
    input MB0;
    input CIN53;
    input CIN52;
    input CIN51;
    input CIN50;
    input CIN49;
    input CIN48;
    input CIN47;
    input CIN46;
    input CIN45;
    input CIN44;
    input CIN43;
    input CIN42;
    input CIN41;
    input CIN40;
    input CIN39;
    input CIN38;
    input CIN37;
    input CIN36;
    input CIN35;
    input CIN34;
    input CIN33;
    input CIN32;
    input CIN31;
    input CIN30;
    input CIN29;
    input CIN28;
    input CIN27;
    input CIN26;
    input CIN25;
    input CIN24;
    input CIN23;
    input CIN22;
    input CIN21;
    input CIN20;
    input CIN19;
    input CIN18;
    input CIN17;
    input CIN16;
    input CIN15;
    input CIN14;
    input CIN13;
    input CIN12;
    input CIN11;
    input CIN10;
    input CIN9;
    input CIN8;
    input CIN7;
    input CIN6;
    input CIN5;
    input CIN4;
    input CIN3;
    input CIN2;
    input CIN1;
    input CIN0;
    input OP10;
    input OP9;
    input OP8;
    input OP7;
    input OP6;
    input OP5;
    input OP4;
    input OP3;
    input OP2;
    input OP1;
    input OP0;
    output R53;
    output R52;
    output R51;
    output R50;
    output R49;
    output R48;
    output R47;
    output R46;
    output R45;
    output R44;
    output R43;
    output R42;
    output R41;
    output R40;
    output R39;
    output R38;
    output R37;
    output R36;
    output R35;
    output R34;
    output R33;
    output R32;
    output R31;
    output R30;
    output R29;
    output R28;
    output R27;
    output R26;
    output R25;
    output R24;
    output R23;
    output R22;
    output R21;
    output R20;
    output R19;
    output R18;
    output R17;
    output R16;
    output R15;
    output R14;
    output R13;
    output R12;
    output R11;
    output R10;
    output R9;
    output R8;
    output R7;
    output R6;
    output R5;
    output R4;
    output R3;
    output R2;
    output R1;
    output R0;
    output CO53;
    output CO52;
    output CO51;
    output CO50;
    output CO49;
    output CO48;
    output CO47;
    output CO46;
    output CO45;
    output CO44;
    output CO43;
    output CO42;
    output CO41;
    output CO40;
    output CO39;
    output CO38;
    output CO37;
    output CO36;
    output CO35;
    output CO34;
    output CO33;
    output CO32;
    output CO31;
    output CO30;
    output CO29;
    output CO28;
    output CO27;
    output CO26;
    output CO25;
    output CO24;
    output CO23;
    output CO22;
    output CO21;
    output CO20;
    output CO19;
    output CO18;
    output CO17;
    output CO16;
    output CO15;
    output CO14;
    output CO13;
    output CO12;
    output CO11;
    output CO10;
    output CO9;
    output CO8;
    output CO7;
    output CO6;
    output CO5;
    output CO4;
    output CO3;
    output CO2;
    output CO1;
    output CO0;
    output EQZ;
    output EQZM;
    output EQOM;
    output EQPAT;
    output EQPATB;
    output OVER;
    output UNDER;
    output OVERUNDER;
    output SIGNEDR;
endmodule

(* blackbox *)
module CLKDIVF (...);
    parameter GSR = "DISABLED";
    parameter DIV = "2.0";
    input CLKI;
    input RST;
    input ALIGNWD;
    output CDIVX;
endmodule

(* blackbox *)
module PCSCLKDIV (...);
    parameter GSR = "DISABLED";
    input CLKI;
    input RST;
    input SEL2;
    input SEL1;
    input SEL0;
    output CDIV1;
    output CDIVX;
endmodule

(* blackbox *)
module DCSC (...);
    parameter DCSMODE = "POS";
    input CLK1;
    input CLK0;
    input SEL1;
    input SEL0;
    input MODESEL;
    output DCSOUT;
endmodule

(* blackbox *)
module DCCA (...);
    input CLKI;
    input CE;
    output CLKO;
endmodule

(* blackbox *)
module ECLKSYNCB (...);
    input ECLKI;
    input STOP;
    output ECLKO;
endmodule

(* blackbox *)
module ECLKBRIDGECS (...);
    input CLK0;
    input CLK1;
    input SEL;
    output ECSOUT;
endmodule

(* blackbox *)
module DELAYF (...);
    parameter DEL_MODE = "USER_DEFINED";
    parameter DEL_VALUE = 0;
    input A;
    input LOADN;
    input MOVE;
    input DIRECTION;
    output Z;
    output CFLAG;
endmodule

(* blackbox *)
module DELAYG (...);
    parameter DEL_MODE = "USER_DEFINED";
    parameter DEL_VALUE = 0;
    input A;
    output Z;
endmodule

(* blackbox *) (* keep *)
module USRMCLK (...);
    input USRMCLKI;
    input USRMCLKTS;
endmodule

(* blackbox *)
module DQSBUFM (...);
    parameter DQS_LI_DEL_VAL = 4;
    parameter DQS_LI_DEL_ADJ = "FACTORYONLY";
    parameter DQS_LO_DEL_VAL = 0;
    parameter DQS_LO_DEL_ADJ = "FACTORYONLY";
    parameter GSR = "ENABLED";
    input DQSI;
    input READ1;
    input READ0;
    input READCLKSEL2;
    input READCLKSEL1;
    input READCLKSEL0;
    input DDRDEL;
    input ECLK;
    input SCLK;
    input RST;
    input DYNDELAY7;
    input DYNDELAY6;
    input DYNDELAY5;
    input DYNDELAY4;
    input DYNDELAY3;
    input DYNDELAY2;
    input DYNDELAY1;
    input DYNDELAY0;
    input PAUSE;
    input RDLOADN;
    input RDMOVE;
    input RDDIRECTION;
    input WRLOADN;
    input WRMOVE;
    input WRDIRECTION;
    output DQSR90;
    output DQSW;
    output DQSW270;
    output RDPNTR2;
    output RDPNTR1;
    output RDPNTR0;
    output WRPNTR2;
    output WRPNTR1;
    output WRPNTR0;
    output DATAVALID;
    output BURSTDET;
    output RDCFLAG;
    output WRCFLAG;
endmodule

(* blackbox *)
module DDRDLLA (...);
    parameter FORCE_MAX_DELAY = "NO";
    parameter GSR = "ENABLED";
    input CLK;
    input RST;
    input UDDCNTLN;
    input FREEZE;
    output DDRDEL;
    output LOCK;
    output DCNTL7;
    output DCNTL6;
    output DCNTL5;
    output DCNTL4;
    output DCNTL3;
    output DCNTL2;
    output DCNTL1;
    output DCNTL0;
endmodule

(* blackbox *)
module DLLDELD (...);
    input A;
    input DDRDEL;
    input LOADN;
    input MOVE;
    input DIRECTION;
    output Z;
    output CFLAG;
endmodule

(* blackbox *)
module IDDRX1F (...);
    parameter GSR = "ENABLED";
    input D;
    input SCLK;
    input RST;
    output Q0;
    output Q1;
endmodule

(* blackbox *)
module IDDRX2F (...);
    parameter GSR = "ENABLED";
    input D;
    input SCLK;
    input ECLK;
    input RST;
    input ALIGNWD;
    output Q3;
    output Q2;
    output Q1;
    output Q0;
endmodule

(* blackbox *)
module IDDR71B (...);
    parameter GSR = "ENABLED";
    input D;
    input SCLK;
    input ECLK;
    input RST;
    input ALIGNWD;
    output Q6;
    output Q5;
    output Q4;
    output Q3;
    output Q2;
    output Q1;
    output Q0;
endmodule

(* blackbox *)
module IDDRX2DQA (...);
    parameter GSR = "ENABLED";
    input SCLK;
    input ECLK;
    input DQSR90;
    input D;
    input RST;
    input RDPNTR2;
    input RDPNTR1;
    input RDPNTR0;
    input WRPNTR2;
    input WRPNTR1;
    input WRPNTR0;
    output Q3;
    output Q2;
    output Q1;
    output Q0;
    output QWL;
endmodule

(* blackbox *)
module ODDRX1F (...);
    parameter GSR = "ENABLED";
    input SCLK;
    input RST;
    input D0;
    input D1;
    output Q;
endmodule

(* blackbox *)
module ODDRX2F (...);
    parameter GSR = "ENABLED";
    input SCLK;
    input ECLK;
    input RST;
    input D3;
    input D2;
    input D1;
    input D0;
    output Q;
endmodule

(* blackbox *)
module ODDR71B (...);
    parameter GSR = "ENABLED";
    input SCLK;
    input ECLK;
    input RST;
    input D6;
    input D5;
    input D4;
    input D3;
    input D2;
    input D1;
    input D0;
    output Q;
endmodule

(* blackbox *)
module OSHX2A (...);
    parameter GSR = "ENABLED";
    input D1;
    input D0;
    input SCLK;
    input ECLK;
    input RST;
    output Q;
endmodule

(* blackbox *)
module TSHX2DQA (...);
    parameter GSR = "ENABLED";
    parameter REGSET = "SET";
    input T1;
    input T0;
    input SCLK;
    input ECLK;
    input DQSW270;
    input RST;
    output Q;
endmodule

(* blackbox *)
module TSHX2DQSA (...);
    parameter GSR = "ENABLED";
    parameter REGSET = "SET";
    input T1;
    input T0;
    input SCLK;
    input ECLK;
    input DQSW;
    input RST;
    output Q;
endmodule

(* blackbox *)
module ODDRX2DQA (...);
    parameter GSR = "ENABLED";
    input D3;
    input D2;
    input D1;
    input D0;
    input DQSW270;
    input SCLK;
    input ECLK;
    input RST;
    output Q;
endmodule

(* blackbox *)
module ODDRX2DQSB (...);
    parameter GSR = "ENABLED";
    input D3;
    input D2;
    input D1;
    input D0;
    input SCLK;
    input ECLK;
    input DQSW;
    input RST;
    output Q;
endmodule

(* blackbox *)
module EHXPLLL (...);
    parameter CLKI_DIV = 1;
    parameter CLKFB_DIV = 1;
    parameter CLKOP_DIV = 8;
    parameter CLKOS_DIV = 8;
    parameter CLKOS2_DIV = 8;
    parameter CLKOS3_DIV = 8;
    parameter CLKOP_ENABLE = "ENABLED";
    parameter CLKOS_ENABLE = "DISABLED";
    parameter CLKOS2_ENABLE = "DISABLED";
    parameter CLKOS3_ENABLE = "DISABLED";
    parameter CLKOP_CPHASE = 0;
    parameter CLKOS_CPHASE = 0;
    parameter CLKOS2_CPHASE = 0;
    parameter CLKOS3_CPHASE = 0;
    parameter CLKOP_FPHASE = 0;
    parameter CLKOS_FPHASE = 0;
    parameter CLKOS2_FPHASE = 0;
    parameter CLKOS3_FPHASE = 0;
    parameter FEEDBK_PATH = "CLKOP";
    parameter CLKOP_TRIM_POL = "RISING";
    parameter CLKOP_TRIM_DELAY = 0;
    parameter CLKOS_TRIM_POL = "RISING";
    parameter CLKOS_TRIM_DELAY = 0;
    parameter OUTDIVIDER_MUXA = "DIVA";
    parameter OUTDIVIDER_MUXB = "DIVB";
    parameter OUTDIVIDER_MUXC = "DIVC";
    parameter OUTDIVIDER_MUXD = "DIVD";
    parameter PLL_LOCK_MODE = 0;
    parameter PLL_LOCK_DELAY = 200;
    parameter STDBY_ENABLE = "DISABLED";
    parameter REFIN_RESET = "DISABLED";
    parameter SYNC_ENABLE = "DISABLED";
    parameter INT_LOCK_STICKY = "ENABLED";
    parameter DPHASE_SOURCE = "DISABLED";
    parameter PLLRST_ENA = "DISABLED";
    parameter INTFB_WAKE = "DISABLED";
    input CLKI;
    input CLKFB;
    input PHASESEL1;
    input PHASESEL0;
    input PHASEDIR;
    input PHASESTEP;
    input PHASELOADREG;
    input STDBY;
    input PLLWAKESYNC;
    input RST;
    input ENCLKOP;
    input ENCLKOS;
    input ENCLKOS2;
    input ENCLKOS3;
    output CLKOP;
    output CLKOS;
    output CLKOS2;
    output CLKOS3;
    output LOCK;
    output INTLOCK;
    output REFCLK;
    output CLKINTFB;
endmodule

(* blackbox *)
module DTR (...);
    parameter DTR_TEMP = 25;
    input STARTPULSE;
    output DTROUT7;
    output DTROUT6;
    output DTROUT5;
    output DTROUT4;
    output DTROUT3;
    output DTROUT2;
    output DTROUT1;
    output DTROUT0;
endmodule

(* blackbox *)
module OSCG (...);
    parameter DIV = 128;
    output OSC;
endmodule

(* blackbox *)
module EXTREFB (...);
    parameter REFCK_PWDNB = "DONTCARE";
    parameter REFCK_RTERM = "DONTCARE";
    parameter REFCK_DCBIAS_EN = "DONTCARE";
    (* iopad_external_pin *)
    input REFCLKP;
    (* iopad_external_pin *)
    input REFCLKN;
    output REFCLKO;
endmodule

(* blackbox *) (* keep *)
module JTAGG (...);
    parameter ER1 = "ENABLED";
    parameter ER2 = "ENABLED";
    (* iopad_external_pin *)
    input TCK;
    (* iopad_external_pin *)
    input TMS;
    (* iopad_external_pin *)
    input TDI;
    input JTDO2;
    input JTDO1;
    (* iopad_external_pin *)
    output TDO;
    output JTDI;
    output JTCK;
    output JRTI2;
    output JRTI1;
    output JSHIFT;
    output JUPDATE;
    output JRSTN;
    output JCE2;
    output JCE1;
endmodule

(* blackbox *) (* keep *)
module DCUA (...);
    parameter D_MACROPDB = "DONTCARE";
    parameter D_IB_PWDNB = "DONTCARE";
    parameter D_XGE_MODE = "DONTCARE";
    parameter D_LOW_MARK = "DONTCARE";
    parameter D_HIGH_MARK = "DONTCARE";
    parameter D_BUS8BIT_SEL = "DONTCARE";
    parameter D_CDR_LOL_SET = "DONTCARE";
    parameter D_BITCLK_LOCAL_EN = "DONTCARE";
    parameter D_BITCLK_ND_EN = "DONTCARE";
    parameter D_BITCLK_FROM_ND_EN = "DONTCARE";
    parameter D_SYNC_LOCAL_EN = "DONTCARE";
    parameter D_SYNC_ND_EN = "DONTCARE";
    parameter CH0_UC_MODE = "DONTCARE";
    parameter CH1_UC_MODE = "DONTCARE";
    parameter CH0_PCIE_MODE = "DONTCARE";
    parameter CH1_PCIE_MODE = "DONTCARE";
    parameter CH0_RIO_MODE = "DONTCARE";
    parameter CH1_RIO_MODE = "DONTCARE";
    parameter CH0_WA_MODE = "DONTCARE";
    parameter CH1_WA_MODE = "DONTCARE";
    parameter CH0_INVERT_RX = "DONTCARE";
    parameter CH1_INVERT_RX = "DONTCARE";
    parameter CH0_INVERT_TX = "DONTCARE";
    parameter CH1_INVERT_TX = "DONTCARE";
    parameter CH0_PRBS_SELECTION = "DONTCARE";
    parameter CH1_PRBS_SELECTION = "DONTCARE";
    parameter CH0_GE_AN_ENABLE = "DONTCARE";
    parameter CH1_GE_AN_ENABLE = "DONTCARE";
    parameter CH0_PRBS_LOCK = "DONTCARE";
    parameter CH1_PRBS_LOCK = "DONTCARE";
    parameter CH0_PRBS_ENABLE = "DONTCARE";
    parameter CH1_PRBS_ENABLE = "DONTCARE";
    parameter CH0_ENABLE_CG_ALIGN = "DONTCARE";
    parameter CH1_ENABLE_CG_ALIGN = "DONTCARE";
    parameter CH0_TX_GEAR_MODE = "DONTCARE";
    parameter CH1_TX_GEAR_MODE = "DONTCARE";
    parameter CH0_RX_GEAR_MODE = "DONTCARE";
    parameter CH1_RX_GEAR_MODE = "DONTCARE";
    parameter CH0_PCS_DET_TIME_SEL = "DONTCARE";
    parameter CH1_PCS_DET_TIME_SEL = "DONTCARE";
    parameter CH0_PCIE_EI_EN = "DONTCARE";
    parameter CH1_PCIE_EI_EN = "DONTCARE";
    parameter CH0_TX_GEAR_BYPASS = "DONTCARE";
    parameter CH1_TX_GEAR_BYPASS = "DONTCARE";
    parameter CH0_ENC_BYPASS = "DONTCARE";
    parameter CH1_ENC_BYPASS = "DONTCARE";
    parameter CH0_SB_BYPASS = "DONTCARE";
    parameter CH1_SB_BYPASS = "DONTCARE";
    parameter CH0_RX_SB_BYPASS = "DONTCARE";
    parameter CH1_RX_SB_BYPASS = "DONTCARE";
    parameter CH0_WA_BYPASS = "DONTCARE";
    parameter CH1_WA_BYPASS = "DONTCARE";
    parameter CH0_DEC_BYPASS = "DONTCARE";
    parameter CH1_DEC_BYPASS = "DONTCARE";
    parameter CH0_CTC_BYPASS = "DONTCARE";
    parameter CH1_CTC_BYPASS = "DONTCARE";
    parameter CH0_RX_GEAR_BYPASS = "DONTCARE";
    parameter CH1_RX_GEAR_BYPASS = "DONTCARE";
    parameter CH0_LSM_DISABLE = "DONTCARE";
    parameter CH1_LSM_DISABLE = "DONTCARE";
    parameter CH0_MATCH_2_ENABLE = "DONTCARE";
    parameter CH1_MATCH_2_ENABLE = "DONTCARE";
    parameter CH0_MATCH_4_ENABLE = "DONTCARE";
    parameter CH1_MATCH_4_ENABLE = "DONTCARE";
    parameter CH0_MIN_IPG_CNT = "DONTCARE";
    parameter CH1_MIN_IPG_CNT = "DONTCARE";
    parameter CH0_CC_MATCH_1 = "DONTCARE";
    parameter CH1_CC_MATCH_1 = "DONTCARE";
    parameter CH0_CC_MATCH_2 = "DONTCARE";
    parameter CH1_CC_MATCH_2 = "DONTCARE";
    parameter CH0_CC_MATCH_3 = "DONTCARE";
    parameter CH1_CC_MATCH_3 = "DONTCARE";
    parameter CH0_CC_MATCH_4 = "DONTCARE";
    parameter CH1_CC_MATCH_4 = "DONTCARE";
    parameter CH0_UDF_COMMA_MASK = "DONTCARE";
    parameter CH1_UDF_COMMA_MASK = "DONTCARE";
    parameter CH0_UDF_COMMA_A = "DONTCARE";
    parameter CH1_UDF_COMMA_A = "DONTCARE";
    parameter CH0_UDF_COMMA_B = "DONTCARE";
    parameter CH1_UDF_COMMA_B = "DONTCARE";
    parameter CH0_RX_DCO_CK_DIV = "DONTCARE";
    parameter CH1_RX_DCO_CK_DIV = "DONTCARE";
    parameter CH0_RCV_DCC_EN = "DONTCARE";
    parameter CH1_RCV_DCC_EN = "DONTCARE";
    parameter CH0_REQ_LVL_SET = "DONTCARE";
    parameter CH1_REQ_LVL_SET = "DONTCARE";
    parameter CH0_REQ_EN = "DONTCARE";
    parameter CH1_REQ_EN = "DONTCARE";
    parameter CH0_RTERM_RX = "DONTCARE";
    parameter CH1_RTERM_RX = "DONTCARE";
    parameter CH0_PDEN_SEL = "DONTCARE";
    parameter CH1_PDEN_SEL = "DONTCARE";
    parameter CH0_LDR_RX2CORE_SEL = "DONTCARE";
    parameter CH1_LDR_RX2CORE_SEL = "DONTCARE";
    parameter CH0_LDR_CORE2TX_SEL = "DONTCARE";
    parameter CH1_LDR_CORE2TX_SEL = "DONTCARE";
    parameter CH0_TPWDNB = "DONTCARE";
    parameter CH1_TPWDNB = "DONTCARE";
    parameter CH0_RATE_MODE_TX = "DONTCARE";
    parameter CH1_RATE_MODE_TX = "DONTCARE";
    parameter CH0_RTERM_TX = "DONTCARE";
    parameter CH1_RTERM_TX = "DONTCARE";
    parameter CH0_TX_CM_SEL = "DONTCARE";
    parameter CH1_TX_CM_SEL = "DONTCARE";
    parameter CH0_TDRV_PRE_EN = "DONTCARE";
    parameter CH1_TDRV_PRE_EN = "DONTCARE";
    parameter CH0_TDRV_SLICE0_SEL = "DONTCARE";
    parameter CH1_TDRV_SLICE0_SEL = "DONTCARE";
    parameter CH0_TDRV_SLICE1_SEL = "DONTCARE";
    parameter CH1_TDRV_SLICE1_SEL = "DONTCARE";
    parameter CH0_TDRV_SLICE2_SEL = "DONTCARE";
    parameter CH1_TDRV_SLICE2_SEL = "DONTCARE";
    parameter CH0_TDRV_SLICE3_SEL = "DONTCARE";
    parameter CH1_TDRV_SLICE3_SEL = "DONTCARE";
    parameter CH0_TDRV_SLICE4_SEL = "DONTCARE";
    parameter CH1_TDRV_SLICE4_SEL = "DONTCARE";
    parameter CH0_TDRV_SLICE5_SEL = "DONTCARE";
    parameter CH1_TDRV_SLICE5_SEL = "DONTCARE";
    parameter CH0_TDRV_SLICE0_CUR = "DONTCARE";
    parameter CH1_TDRV_SLICE0_CUR = "DONTCARE";
    parameter CH0_TDRV_SLICE1_CUR = "DONTCARE";
    parameter CH1_TDRV_SLICE1_CUR = "DONTCARE";
    parameter CH0_TDRV_SLICE2_CUR = "DONTCARE";
    parameter CH1_TDRV_SLICE2_CUR = "DONTCARE";
    parameter CH0_TDRV_SLICE3_CUR = "DONTCARE";
    parameter CH1_TDRV_SLICE3_CUR = "DONTCARE";
    parameter CH0_TDRV_SLICE4_CUR = "DONTCARE";
    parameter CH1_TDRV_SLICE4_CUR = "DONTCARE";
    parameter CH0_TDRV_SLICE5_CUR = "DONTCARE";
    parameter CH1_TDRV_SLICE5_CUR = "DONTCARE";
    parameter CH0_TDRV_DAT_SEL = "DONTCARE";
    parameter CH1_TDRV_DAT_SEL = "DONTCARE";
    parameter CH0_TX_DIV11_SEL = "DONTCARE";
    parameter CH1_TX_DIV11_SEL = "DONTCARE";
    parameter CH0_RPWDNB = "DONTCARE";
    parameter CH1_RPWDNB = "DONTCARE";
    parameter CH0_RATE_MODE_RX = "DONTCARE";
    parameter CH1_RATE_MODE_RX = "DONTCARE";
    parameter CH0_RLOS_SEL = "DONTCARE";
    parameter CH1_RLOS_SEL = "DONTCARE";
    parameter CH0_RX_LOS_LVL = "DONTCARE";
    parameter CH1_RX_LOS_LVL = "DONTCARE";
    parameter CH0_RX_LOS_CEQ = "DONTCARE";
    parameter CH1_RX_LOS_CEQ = "DONTCARE";
    parameter CH0_RX_LOS_HYST_EN = "DONTCARE";
    parameter CH1_RX_LOS_HYST_EN = "DONTCARE";
    parameter CH0_RX_LOS_EN = "DONTCARE";
    parameter CH1_RX_LOS_EN = "DONTCARE";
    parameter CH0_RX_DIV11_SEL = "DONTCARE";
    parameter CH1_RX_DIV11_SEL = "DONTCARE";
    parameter CH0_SEL_SD_RX_CLK = "DONTCARE";
    parameter CH1_SEL_SD_RX_CLK = "DONTCARE";
    parameter CH0_FF_RX_H_CLK_EN = "DONTCARE";
    parameter CH1_FF_RX_H_CLK_EN = "DONTCARE";
    parameter CH0_FF_RX_F_CLK_DIS = "DONTCARE";
    parameter CH1_FF_RX_F_CLK_DIS = "DONTCARE";
    parameter CH0_FF_TX_H_CLK_EN = "DONTCARE";
    parameter CH1_FF_TX_H_CLK_EN = "DONTCARE";
    parameter CH0_FF_TX_F_CLK_DIS = "DONTCARE";
    parameter CH1_FF_TX_F_CLK_DIS = "DONTCARE";
    parameter CH0_RX_RATE_SEL = "DONTCARE";
    parameter CH1_RX_RATE_SEL = "DONTCARE";
    parameter CH0_TDRV_POST_EN = "DONTCARE";
    parameter CH1_TDRV_POST_EN = "DONTCARE";
    parameter CH0_TX_POST_SIGN = "DONTCARE";
    parameter CH1_TX_POST_SIGN = "DONTCARE";
    parameter CH0_TX_PRE_SIGN = "DONTCARE";
    parameter CH1_TX_PRE_SIGN = "DONTCARE";
    parameter CH0_RXTERM_CM = "DONTCARE";
    parameter CH1_RXTERM_CM = "DONTCARE";
    parameter CH0_RXIN_CM = "DONTCARE";
    parameter CH1_RXIN_CM = "DONTCARE";
    parameter CH0_LEQ_OFFSET_SEL = "DONTCARE";
    parameter CH1_LEQ_OFFSET_SEL = "DONTCARE";
    parameter CH0_LEQ_OFFSET_TRIM = "DONTCARE";
    parameter CH1_LEQ_OFFSET_TRIM = "DONTCARE";
    parameter D_TX_MAX_RATE = "DONTCARE";
    parameter CH0_CDR_MAX_RATE = "DONTCARE";
    parameter CH1_CDR_MAX_RATE = "DONTCARE";
    parameter CH0_TXAMPLITUDE = "DONTCARE";
    parameter CH1_TXAMPLITUDE = "DONTCARE";
    parameter CH0_TXDEPRE = "DONTCARE";
    parameter CH1_TXDEPRE = "DONTCARE";
    parameter CH0_TXDEPOST = "DONTCARE";
    parameter CH1_TXDEPOST = "DONTCARE";
    parameter CH0_PROTOCOL = "DONTCARE";
    parameter CH1_PROTOCOL = "DONTCARE";
    parameter D_ISETLOS = "DONTCARE";
    parameter D_SETIRPOLY_AUX = "DONTCARE";
    parameter D_SETICONST_AUX = "DONTCARE";
    parameter D_SETIRPOLY_CH = "DONTCARE";
    parameter D_SETICONST_CH = "DONTCARE";
    parameter D_REQ_ISET = "DONTCARE";
    parameter D_PD_ISET = "DONTCARE";
    parameter D_DCO_CALIB_TIME_SEL = "DONTCARE";
    parameter CH0_DCOCTLGI = "DONTCARE";
    parameter CH1_DCOCTLGI = "DONTCARE";
    parameter CH0_DCOATDDLY = "DONTCARE";
    parameter CH1_DCOATDDLY = "DONTCARE";
    parameter CH0_DCOATDCFG = "DONTCARE";
    parameter CH1_DCOATDCFG = "DONTCARE";
    parameter CH0_DCOBYPSATD = "DONTCARE";
    parameter CH1_DCOBYPSATD = "DONTCARE";
    parameter CH0_DCOSCALEI = "DONTCARE";
    parameter CH1_DCOSCALEI = "DONTCARE";
    parameter CH0_DCOITUNE4LSB = "DONTCARE";
    parameter CH1_DCOITUNE4LSB = "DONTCARE";
    parameter CH0_DCOIOSTUNE = "DONTCARE";
    parameter CH1_DCOIOSTUNE = "DONTCARE";
    parameter CH0_DCODISBDAVOID = "DONTCARE";
    parameter CH1_DCODISBDAVOID = "DONTCARE";
    parameter CH0_DCOCALDIV = "DONTCARE";
    parameter CH1_DCOCALDIV = "DONTCARE";
    parameter CH0_DCONUOFLSB = "DONTCARE";
    parameter CH1_DCONUOFLSB = "DONTCARE";
    parameter CH0_DCOIUPDNX2 = "DONTCARE";
    parameter CH1_DCOIUPDNX2 = "DONTCARE";
    parameter CH0_DCOSTEP = "DONTCARE";
    parameter CH1_DCOSTEP = "DONTCARE";
    parameter CH0_DCOSTARTVAL = "DONTCARE";
    parameter CH1_DCOSTARTVAL = "DONTCARE";
    parameter CH0_DCOFLTDAC = "DONTCARE";
    parameter CH1_DCOFLTDAC = "DONTCARE";
    parameter CH0_DCOITUNE = "DONTCARE";
    parameter CH1_DCOITUNE = "DONTCARE";
    parameter CH0_DCOFTNRG = "DONTCARE";
    parameter CH1_DCOFTNRG = "DONTCARE";
    parameter CH0_CDR_CNT4SEL = "DONTCARE";
    parameter CH1_CDR_CNT4SEL = "DONTCARE";
    parameter CH0_CDR_CNT8SEL = "DONTCARE";
    parameter CH1_CDR_CNT8SEL = "DONTCARE";
    parameter CH0_BAND_THRESHOLD = "DONTCARE";
    parameter CH1_BAND_THRESHOLD = "DONTCARE";
    parameter CH0_AUTO_FACQ_EN = "DONTCARE";
    parameter CH1_AUTO_FACQ_EN = "DONTCARE";
    parameter CH0_AUTO_CALIB_EN = "DONTCARE";
    parameter CH1_AUTO_CALIB_EN = "DONTCARE";
    parameter CH0_CALIB_CK_MODE = "DONTCARE";
    parameter CH1_CALIB_CK_MODE = "DONTCARE";
    parameter CH0_REG_BAND_OFFSET = "DONTCARE";
    parameter CH1_REG_BAND_OFFSET = "DONTCARE";
    parameter CH0_REG_BAND_SEL = "DONTCARE";
    parameter CH1_REG_BAND_SEL = "DONTCARE";
    parameter CH0_REG_IDAC_SEL = "DONTCARE";
    parameter CH1_REG_IDAC_SEL = "DONTCARE";
    parameter CH0_REG_IDAC_EN = "DONTCARE";
    parameter CH1_REG_IDAC_EN = "DONTCARE";
    parameter D_TXPLL_PWDNB = "DONTCARE";
    parameter D_SETPLLRC = "DONTCARE";
    parameter D_REFCK_MODE = "DONTCARE";
    parameter D_TX_VCO_CK_DIV = "DONTCARE";
    parameter D_PLL_LOL_SET = "DONTCARE";
    parameter D_RG_EN = "DONTCARE";
    parameter D_RG_SET = "DONTCARE";
    parameter D_CMUSETISCL4VCO = "DONTCARE";
    parameter D_CMUSETI4VCO = "DONTCARE";
    parameter D_CMUSETINITVCT = "DONTCARE";
    parameter D_CMUSETZGM = "DONTCARE";
    parameter D_CMUSETP2AGM = "DONTCARE";
    parameter D_CMUSETP1GM = "DONTCARE";
    parameter D_CMUSETI4CPZ = "DONTCARE";
    parameter D_CMUSETI4CPP = "DONTCARE";
    parameter D_CMUSETICP4Z = "DONTCARE";
    parameter D_CMUSETICP4P = "DONTCARE";
    parameter D_CMUSETBIASI = "DONTCARE";
    (* iopad_external_pin *)
    (* iopad_external_pin *)
    input CH0_HDINP;
    (* iopad_external_pin *)
    input CH1_HDINP;
    (* iopad_external_pin *)
    input CH0_HDINN;
    (* iopad_external_pin *)
    input CH1_HDINN;
    input D_TXBIT_CLKP_FROM_ND;
    input D_TXBIT_CLKN_FROM_ND;
    input D_SYNC_ND;
    input D_TXPLL_LOL_FROM_ND;
    input CH0_RX_REFCLK;
    input CH1_RX_REFCLK;
    input CH0_FF_RXI_CLK;
    input CH1_FF_RXI_CLK;
    input CH0_FF_TXI_CLK;
    input CH1_FF_TXI_CLK;
    input CH0_FF_EBRD_CLK;
    input CH1_FF_EBRD_CLK;
    input CH0_FF_TX_D_0;
    input CH1_FF_TX_D_0;
    input CH0_FF_TX_D_1;
    input CH1_FF_TX_D_1;
    input CH0_FF_TX_D_2;
    input CH1_FF_TX_D_2;
    input CH0_FF_TX_D_3;
    input CH1_FF_TX_D_3;
    input CH0_FF_TX_D_4;
    input CH1_FF_TX_D_4;
    input CH0_FF_TX_D_5;
    input CH1_FF_TX_D_5;
    input CH0_FF_TX_D_6;
    input CH1_FF_TX_D_6;
    input CH0_FF_TX_D_7;
    input CH1_FF_TX_D_7;
    input CH0_FF_TX_D_8;
    input CH1_FF_TX_D_8;
    input CH0_FF_TX_D_9;
    input CH1_FF_TX_D_9;
    input CH0_FF_TX_D_10;
    input CH1_FF_TX_D_10;
    input CH0_FF_TX_D_11;
    input CH1_FF_TX_D_11;
    input CH0_FF_TX_D_12;
    input CH1_FF_TX_D_12;
    input CH0_FF_TX_D_13;
    input CH1_FF_TX_D_13;
    input CH0_FF_TX_D_14;
    input CH1_FF_TX_D_14;
    input CH0_FF_TX_D_15;
    input CH1_FF_TX_D_15;
    input CH0_FF_TX_D_16;
    input CH1_FF_TX_D_16;
    input CH0_FF_TX_D_17;
    input CH1_FF_TX_D_17;
    input CH0_FF_TX_D_18;
    input CH1_FF_TX_D_18;
    input CH0_FF_TX_D_19;
    input CH1_FF_TX_D_19;
    input CH0_FF_TX_D_20;
    input CH1_FF_TX_D_20;
    input CH0_FF_TX_D_21;
    input CH1_FF_TX_D_21;
    input CH0_FF_TX_D_22;
    input CH1_FF_TX_D_22;
    input CH0_FF_TX_D_23;
    input CH1_FF_TX_D_23;
    input CH0_FFC_EI_EN;
    input CH1_FFC_EI_EN;
    input CH0_FFC_PCIE_DET_EN;
    input CH1_FFC_PCIE_DET_EN;
    input CH0_FFC_PCIE_CT;
    input CH1_FFC_PCIE_CT;
    input CH0_FFC_SB_INV_RX;
    input CH1_FFC_SB_INV_RX;
    input CH0_FFC_ENABLE_CGALIGN;
    input CH1_FFC_ENABLE_CGALIGN;
    input CH0_FFC_SIGNAL_DETECT;
    input CH1_FFC_SIGNAL_DETECT;
    input CH0_FFC_FB_LOOPBACK;
    input CH1_FFC_FB_LOOPBACK;
    input CH0_FFC_SB_PFIFO_LP;
    input CH1_FFC_SB_PFIFO_LP;
    input CH0_FFC_PFIFO_CLR;
    input CH1_FFC_PFIFO_CLR;
    input CH0_FFC_RATE_MODE_RX;
    input CH1_FFC_RATE_MODE_RX;
    input CH0_FFC_RATE_MODE_TX;
    input CH1_FFC_RATE_MODE_TX;
    input CH0_FFC_DIV11_MODE_RX;
    input CH1_FFC_DIV11_MODE_RX;
    input CH0_FFC_RX_GEAR_MODE;
    input CH1_FFC_RX_GEAR_MODE;
    input CH0_FFC_TX_GEAR_MODE;
    input CH1_FFC_TX_GEAR_MODE;
    input CH0_FFC_DIV11_MODE_TX;
    input CH1_FFC_DIV11_MODE_TX;
    input CH0_FFC_LDR_CORE2TX_EN;
    input CH1_FFC_LDR_CORE2TX_EN;
    input CH0_FFC_LANE_TX_RST;
    input CH1_FFC_LANE_TX_RST;
    input CH0_FFC_LANE_RX_RST;
    input CH1_FFC_LANE_RX_RST;
    input CH0_FFC_RRST;
    input CH1_FFC_RRST;
    input CH0_FFC_TXPWDNB;
    input CH1_FFC_TXPWDNB;
    input CH0_FFC_RXPWDNB;
    input CH1_FFC_RXPWDNB;
    input CH0_LDR_CORE2TX;
    input CH1_LDR_CORE2TX;
    input D_SCIWDATA0;
    input D_SCIWDATA1;
    input D_SCIWDATA2;
    input D_SCIWDATA3;
    input D_SCIWDATA4;
    input D_SCIWDATA5;
    input D_SCIWDATA6;
    input D_SCIWDATA7;
    input D_SCIADDR0;
    input D_SCIADDR1;
    input D_SCIADDR2;
    input D_SCIADDR3;
    input D_SCIADDR4;
    input D_SCIADDR5;
    input D_SCIENAUX;
    input D_SCISELAUX;
    input CH0_SCIEN;
    input CH1_SCIEN;
    input CH0_SCISEL;
    input CH1_SCISEL;
    input D_SCIRD;
    input D_SCIWSTN;
    input D_CYAWSTN;
    input D_FFC_SYNC_TOGGLE;
    input D_FFC_DUAL_RST;
    input D_FFC_MACRO_RST;
    input D_FFC_MACROPDB;
    input D_FFC_TRST;
    input CH0_FFC_CDR_EN_BITSLIP;
    input CH1_FFC_CDR_EN_BITSLIP;
    input D_SCAN_ENABLE;
    input D_SCAN_IN_0;
    input D_SCAN_IN_1;
    input D_SCAN_IN_2;
    input D_SCAN_IN_3;
    input D_SCAN_IN_4;
    input D_SCAN_IN_5;
    input D_SCAN_IN_6;
    input D_SCAN_IN_7;
    input D_SCAN_MODE;
    input D_SCAN_RESET;
    input D_CIN0;
    input D_CIN1;
    input D_CIN2;
    input D_CIN3;
    input D_CIN4;
    input D_CIN5;
    input D_CIN6;
    input D_CIN7;
    input D_CIN8;
    input D_CIN9;
    input D_CIN10;
    input D_CIN11;
    output CH0_HDOUTP;
    output CH1_HDOUTP;
    output CH0_HDOUTN;
    output CH1_HDOUTN;
    output D_TXBIT_CLKP_TO_ND;
    output D_TXBIT_CLKN_TO_ND;
    output D_SYNC_PULSE2ND;
    output D_TXPLL_LOL_TO_ND;
    output CH0_FF_RX_F_CLK;
    output CH1_FF_RX_F_CLK;
    output CH0_FF_RX_H_CLK;
    output CH1_FF_RX_H_CLK;
    output CH0_FF_TX_F_CLK;
    output CH1_FF_TX_F_CLK;
    output CH0_FF_TX_H_CLK;
    output CH1_FF_TX_H_CLK;
    output CH0_FF_RX_PCLK;
    output CH1_FF_RX_PCLK;
    output CH0_FF_TX_PCLK;
    output CH1_FF_TX_PCLK;
    output CH0_FF_RX_D_0;
    output CH1_FF_RX_D_0;
    output CH0_FF_RX_D_1;
    output CH1_FF_RX_D_1;
    output CH0_FF_RX_D_2;
    output CH1_FF_RX_D_2;
    output CH0_FF_RX_D_3;
    output CH1_FF_RX_D_3;
    output CH0_FF_RX_D_4;
    output CH1_FF_RX_D_4;
    output CH0_FF_RX_D_5;
    output CH1_FF_RX_D_5;
    output CH0_FF_RX_D_6;
    output CH1_FF_RX_D_6;
    output CH0_FF_RX_D_7;
    output CH1_FF_RX_D_7;
    output CH0_FF_RX_D_8;
    output CH1_FF_RX_D_8;
    output CH0_FF_RX_D_9;
    output CH1_FF_RX_D_9;
    output CH0_FF_RX_D_10;
    output CH1_FF_RX_D_10;
    output CH0_FF_RX_D_11;
    output CH1_FF_RX_D_11;
    output CH0_FF_RX_D_12;
    output CH1_FF_RX_D_12;
    output CH0_FF_RX_D_13;
    output CH1_FF_RX_D_13;
    output CH0_FF_RX_D_14;
    output CH1_FF_RX_D_14;
    output CH0_FF_RX_D_15;
    output CH1_FF_RX_D_15;
    output CH0_FF_RX_D_16;
    output CH1_FF_RX_D_16;
    output CH0_FF_RX_D_17;
    output CH1_FF_RX_D_17;
    output CH0_FF_RX_D_18;
    output CH1_FF_RX_D_18;
    output CH0_FF_RX_D_19;
    output CH1_FF_RX_D_19;
    output CH0_FF_RX_D_20;
    output CH1_FF_RX_D_20;
    output CH0_FF_RX_D_21;
    output CH1_FF_RX_D_21;
    output CH0_FF_RX_D_22;
    output CH1_FF_RX_D_22;
    output CH0_FF_RX_D_23;
    output CH1_FF_RX_D_23;
    output CH0_FFS_PCIE_DONE;
    output CH1_FFS_PCIE_DONE;
    output CH0_FFS_PCIE_CON;
    output CH1_FFS_PCIE_CON;
    output CH0_FFS_RLOS;
    output CH1_FFS_RLOS;
    output CH0_FFS_LS_SYNC_STATUS;
    output CH1_FFS_LS_SYNC_STATUS;
    output CH0_FFS_CC_UNDERRUN;
    output CH1_FFS_CC_UNDERRUN;
    output CH0_FFS_CC_OVERRUN;
    output CH1_FFS_CC_OVERRUN;
    output CH0_FFS_RXFBFIFO_ERROR;
    output CH1_FFS_RXFBFIFO_ERROR;
    output CH0_FFS_TXFBFIFO_ERROR;
    output CH1_FFS_TXFBFIFO_ERROR;
    output CH0_FFS_RLOL;
    output CH1_FFS_RLOL;
    output CH0_FFS_SKP_ADDED;
    output CH1_FFS_SKP_ADDED;
    output CH0_FFS_SKP_DELETED;
    output CH1_FFS_SKP_DELETED;
    output CH0_LDR_RX2CORE;
    output CH1_LDR_RX2CORE;
    output D_SCIRDATA0;
    output D_SCIRDATA1;
    output D_SCIRDATA2;
    output D_SCIRDATA3;
    output D_SCIRDATA4;
    output D_SCIRDATA5;
    output D_SCIRDATA6;
    output D_SCIRDATA7;
    output D_SCIINT;
    output D_SCAN_OUT_0;
    output D_SCAN_OUT_1;
    output D_SCAN_OUT_2;
    output D_SCAN_OUT_3;
    output D_SCAN_OUT_4;
    output D_SCAN_OUT_5;
    output D_SCAN_OUT_6;
    output D_SCAN_OUT_7;
    output D_COUT0;
    output D_COUT1;
    output D_COUT2;
    output D_COUT3;
    output D_COUT4;
    output D_COUT5;
    output D_COUT6;
    output D_COUT7;
    output D_COUT8;
    output D_COUT9;
    output D_COUT10;
    output D_COUT11;
    output D_COUT12;
    output D_COUT13;
    output D_COUT14;
    output D_COUT15;
    output D_COUT16;
    output D_COUT17;
    output D_COUT18;
    output D_COUT19;
    input D_REFCLKI;
    output D_FFS_PLOL;
endmodule

`,"cells_bb_xo2.v":`// Created by cells_xtra.py from Lattice models

(* blackbox *) (* keep *)
module GSR (...);
    input GSR;
endmodule

(* blackbox *) (* keep *)
module SGSR (...);
    input GSR;
    input CLK;
endmodule

(* blackbox *)
module DP8KC (...);
    parameter DATA_WIDTH_A = 9;
    parameter DATA_WIDTH_B = 9;
    parameter REGMODE_A = "NOREG";
    parameter REGMODE_B = "NOREG";
    parameter CSDECODE_A = "0b000";
    parameter CSDECODE_B = "0b000";
    parameter WRITEMODE_A = "NORMAL";
    parameter WRITEMODE_B = "NORMAL";
    parameter GSR = "ENABLED";
    parameter RESETMODE = "SYNC";
    parameter ASYNC_RESET_RELEASE = "SYNC";
    parameter INIT_DATA = "STATIC";
    parameter INITVAL_00 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_01 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_02 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_03 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_04 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_05 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_06 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_07 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_08 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_09 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_10 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_11 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_12 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_13 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_14 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_15 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_16 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_17 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_18 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_19 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    input DIA8;
    input DIA7;
    input DIA6;
    input DIA5;
    input DIA4;
    input DIA3;
    input DIA2;
    input DIA1;
    input DIA0;
    input ADA12;
    input ADA11;
    input ADA10;
    input ADA9;
    input ADA8;
    input ADA7;
    input ADA6;
    input ADA5;
    input ADA4;
    input ADA3;
    input ADA2;
    input ADA1;
    input ADA0;
    input CEA;
    input OCEA;
    input CLKA;
    input WEA;
    input CSA2;
    input CSA1;
    input CSA0;
    input RSTA;
    input DIB8;
    input DIB7;
    input DIB6;
    input DIB5;
    input DIB4;
    input DIB3;
    input DIB2;
    input DIB1;
    input DIB0;
    input ADB12;
    input ADB11;
    input ADB10;
    input ADB9;
    input ADB8;
    input ADB7;
    input ADB6;
    input ADB5;
    input ADB4;
    input ADB3;
    input ADB2;
    input ADB1;
    input ADB0;
    input CEB;
    input OCEB;
    input CLKB;
    input WEB;
    input CSB2;
    input CSB1;
    input CSB0;
    input RSTB;
    output DOA8;
    output DOA7;
    output DOA6;
    output DOA5;
    output DOA4;
    output DOA3;
    output DOA2;
    output DOA1;
    output DOA0;
    output DOB8;
    output DOB7;
    output DOB6;
    output DOB5;
    output DOB4;
    output DOB3;
    output DOB2;
    output DOB1;
    output DOB0;
endmodule

(* blackbox *)
module PDPW8KC (...);
    parameter DATA_WIDTH_W = 18;
    parameter DATA_WIDTH_R = 9;
    parameter REGMODE = "NOREG";
    parameter CSDECODE_W = "0b000";
    parameter CSDECODE_R = "0b000";
    parameter GSR = "ENABLED";
    parameter RESETMODE = "SYNC";
    parameter ASYNC_RESET_RELEASE = "SYNC";
    parameter INIT_DATA = "STATIC";
    parameter INITVAL_00 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_01 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_02 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_03 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_04 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_05 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_06 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_07 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_08 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_09 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_10 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_11 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_12 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_13 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_14 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_15 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_16 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_17 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_18 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_19 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    input DI17;
    input DI16;
    input DI15;
    input DI14;
    input DI13;
    input DI12;
    input DI11;
    input DI10;
    input DI9;
    input DI8;
    input DI7;
    input DI6;
    input DI5;
    input DI4;
    input DI3;
    input DI2;
    input DI1;
    input DI0;
    input ADW8;
    input ADW7;
    input ADW6;
    input ADW5;
    input ADW4;
    input ADW3;
    input ADW2;
    input ADW1;
    input ADW0;
    input BE1;
    input BE0;
    input CEW;
    input CLKW;
    input CSW2;
    input CSW1;
    input CSW0;
    input ADR12;
    input ADR11;
    input ADR10;
    input ADR9;
    input ADR8;
    input ADR7;
    input ADR6;
    input ADR5;
    input ADR4;
    input ADR3;
    input ADR2;
    input ADR1;
    input ADR0;
    input CER;
    input OCER;
    input CLKR;
    input CSR2;
    input CSR1;
    input CSR0;
    input RST;
    output DO17;
    output DO16;
    output DO15;
    output DO14;
    output DO13;
    output DO12;
    output DO11;
    output DO10;
    output DO9;
    output DO8;
    output DO7;
    output DO6;
    output DO5;
    output DO4;
    output DO3;
    output DO2;
    output DO1;
    output DO0;
endmodule

(* blackbox *)
module SP8KC (...);
    parameter DATA_WIDTH = 9;
    parameter REGMODE = "NOREG";
    parameter CSDECODE = "0b000";
    parameter WRITEMODE = "NORMAL";
    parameter GSR = "ENABLED";
    parameter RESETMODE = "SYNC";
    parameter ASYNC_RESET_RELEASE = "SYNC";
    parameter INIT_DATA = "STATIC";
    parameter INITVAL_00 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_01 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_02 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_03 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_04 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_05 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_06 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_07 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_08 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_09 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_10 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_11 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_12 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_13 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_14 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_15 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_16 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_17 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_18 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_19 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    input DI8;
    input DI7;
    input DI6;
    input DI5;
    input DI4;
    input DI3;
    input DI2;
    input DI1;
    input DI0;
    input AD12;
    input AD11;
    input AD10;
    input AD9;
    input AD8;
    input AD7;
    input AD6;
    input AD5;
    input AD4;
    input AD3;
    input AD2;
    input AD1;
    input AD0;
    input CE;
    input OCE;
    input CLK;
    input WE;
    input CS2;
    input CS1;
    input CS0;
    input RST;
    output DO8;
    output DO7;
    output DO6;
    output DO5;
    output DO4;
    output DO3;
    output DO2;
    output DO1;
    output DO0;
endmodule

(* blackbox *)
module FIFO8KB (...);
    parameter DATA_WIDTH_W = 18;
    parameter DATA_WIDTH_R = 18;
    parameter REGMODE = "NOREG";
    parameter RESETMODE = "ASYNC";
    parameter ASYNC_RESET_RELEASE = "SYNC";
    parameter CSDECODE_W = "0b00";
    parameter CSDECODE_R = "0b00";
    parameter AEPOINTER = "0b00000000000000";
    parameter AEPOINTER1 = "0b00000000000000";
    parameter AFPOINTER = "0b00000000000000";
    parameter AFPOINTER1 = "0b00000000000000";
    parameter FULLPOINTER = "0b00000000000000";
    parameter FULLPOINTER1 = "0b00000000000000";
    parameter GSR = "DISABLED";
    input DI0;
    input DI1;
    input DI2;
    input DI3;
    input DI4;
    input DI5;
    input DI6;
    input DI7;
    input DI8;
    input DI9;
    input DI10;
    input DI11;
    input DI12;
    input DI13;
    input DI14;
    input DI15;
    input DI16;
    input DI17;
    input CSW0;
    input CSW1;
    input CSR0;
    input CSR1;
    input WE;
    input RE;
    input ORE;
    input CLKW;
    input CLKR;
    input RST;
    input RPRST;
    input FULLI;
    input EMPTYI;
    output DO0;
    output DO1;
    output DO2;
    output DO3;
    output DO4;
    output DO5;
    output DO6;
    output DO7;
    output DO8;
    output DO9;
    output DO10;
    output DO11;
    output DO12;
    output DO13;
    output DO14;
    output DO15;
    output DO16;
    output DO17;
    output EF;
    output AEF;
    output AFF;
    output FF;
endmodule

(* blackbox *)
module CLKDIVC (...);
    parameter GSR = "DISABLED";
    parameter DIV = "2.0";
    input RST;
    input CLKI;
    input ALIGNWD;
    output CDIV1;
    output CDIVX;
endmodule

(* blackbox *)
module DCMA (...);
    input CLK0;
    input CLK1;
    input SEL;
    output DCMOUT;
endmodule

(* blackbox *)
module ECLKSYNCA (...);
    input ECLKI;
    input STOP;
    output ECLKO;
endmodule

(* blackbox *)
module ECLKBRIDGECS (...);
    input CLK0;
    input CLK1;
    input SEL;
    output ECSOUT;
endmodule

(* blackbox *)
module DCCA (...);
    input CLKI;
    input CE;
    output CLKO;
endmodule

(* blackbox *) (* keep *)
module START (...);
    input STARTCLK;
endmodule

(* blackbox *)
module EHXPLLJ (...);
    parameter CLKI_DIV = 1;
    parameter CLKFB_DIV = 1;
    parameter CLKOP_DIV = 8;
    parameter CLKOS_DIV = 8;
    parameter CLKOS2_DIV = 8;
    parameter CLKOS3_DIV = 8;
    parameter CLKOP_ENABLE = "ENABLED";
    parameter CLKOS_ENABLE = "ENABLED";
    parameter CLKOS2_ENABLE = "ENABLED";
    parameter CLKOS3_ENABLE = "ENABLED";
    parameter VCO_BYPASS_A0 = "DISABLED";
    parameter VCO_BYPASS_B0 = "DISABLED";
    parameter VCO_BYPASS_C0 = "DISABLED";
    parameter VCO_BYPASS_D0 = "DISABLED";
    parameter CLKOP_CPHASE = 0;
    parameter CLKOS_CPHASE = 0;
    parameter CLKOS2_CPHASE = 0;
    parameter CLKOS3_CPHASE = 0;
    parameter CLKOP_FPHASE = 0;
    parameter CLKOS_FPHASE = 0;
    parameter CLKOS2_FPHASE = 0;
    parameter CLKOS3_FPHASE = 0;
    parameter FEEDBK_PATH = "CLKOP";
    parameter FRACN_ENABLE = "DISABLED";
    parameter FRACN_DIV = 0;
    parameter CLKOP_TRIM_POL = "RISING";
    parameter CLKOP_TRIM_DELAY = 0;
    parameter CLKOS_TRIM_POL = "RISING";
    parameter CLKOS_TRIM_DELAY = 0;
    parameter PLL_USE_WB = "DISABLED";
    parameter PREDIVIDER_MUXA1 = 0;
    parameter PREDIVIDER_MUXB1 = 0;
    parameter PREDIVIDER_MUXC1 = 0;
    parameter PREDIVIDER_MUXD1 = 0;
    parameter OUTDIVIDER_MUXA2 = "DIVA";
    parameter OUTDIVIDER_MUXB2 = "DIVB";
    parameter OUTDIVIDER_MUXC2 = "DIVC";
    parameter OUTDIVIDER_MUXD2 = "DIVD";
    parameter PLL_LOCK_MODE = 0;
    parameter STDBY_ENABLE = "DISABLED";
    parameter DPHASE_SOURCE = "DISABLED";
    parameter PLLRST_ENA = "DISABLED";
    parameter MRST_ENA = "DISABLED";
    parameter DCRST_ENA = "DISABLED";
    parameter DDRST_ENA = "DISABLED";
    parameter INTFB_WAKE = "DISABLED";
    input CLKI;
    input CLKFB;
    input PHASESEL1;
    input PHASESEL0;
    input PHASEDIR;
    input PHASESTEP;
    input LOADREG;
    input STDBY;
    input PLLWAKESYNC;
    input RST;
    input RESETM;
    input RESETC;
    input RESETD;
    input ENCLKOP;
    input ENCLKOS;
    input ENCLKOS2;
    input ENCLKOS3;
    input PLLCLK;
    input PLLRST;
    input PLLSTB;
    input PLLWE;
    input PLLDATI7;
    input PLLDATI6;
    input PLLDATI5;
    input PLLDATI4;
    input PLLDATI3;
    input PLLDATI2;
    input PLLDATI1;
    input PLLDATI0;
    input PLLADDR4;
    input PLLADDR3;
    input PLLADDR2;
    input PLLADDR1;
    input PLLADDR0;
    output CLKOP;
    output CLKOS;
    output CLKOS2;
    output CLKOS3;
    output LOCK;
    output INTLOCK;
    output REFCLK;
    output PLLDATO7;
    output PLLDATO6;
    output PLLDATO5;
    output PLLDATO4;
    output PLLDATO3;
    output PLLDATO2;
    output PLLDATO1;
    output PLLDATO0;
    output PLLACK;
    output DPHSRC;
    output CLKINTFB;
endmodule

(* blackbox *)
module OSCH (...);
    parameter NOM_FREQ = "2.08";
    input STDBY;
    output OSC;
    output SEDSTDBY;
endmodule

(* blackbox *) (* keep *)
module TSALL (...);
    input TSALL;
endmodule

`,"cells_bb_xo3.v":`// Created by cells_xtra.py from Lattice models

(* blackbox *) (* keep *)
module GSR (...);
    input GSR;
endmodule

(* blackbox *) (* keep *)
module SGSR (...);
    input GSR;
    input CLK;
endmodule

(* blackbox *)
module DP8KC (...);
    parameter DATA_WIDTH_A = 9;
    parameter DATA_WIDTH_B = 9;
    parameter REGMODE_A = "NOREG";
    parameter REGMODE_B = "NOREG";
    parameter CSDECODE_A = "0b000";
    parameter CSDECODE_B = "0b000";
    parameter WRITEMODE_A = "NORMAL";
    parameter WRITEMODE_B = "NORMAL";
    parameter GSR = "ENABLED";
    parameter RESETMODE = "SYNC";
    parameter ASYNC_RESET_RELEASE = "SYNC";
    parameter INIT_DATA = "STATIC";
    parameter INITVAL_00 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_01 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_02 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_03 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_04 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_05 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_06 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_07 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_08 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_09 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_10 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_11 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_12 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_13 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_14 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_15 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_16 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_17 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_18 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_19 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    input DIA8;
    input DIA7;
    input DIA6;
    input DIA5;
    input DIA4;
    input DIA3;
    input DIA2;
    input DIA1;
    input DIA0;
    input ADA12;
    input ADA11;
    input ADA10;
    input ADA9;
    input ADA8;
    input ADA7;
    input ADA6;
    input ADA5;
    input ADA4;
    input ADA3;
    input ADA2;
    input ADA1;
    input ADA0;
    input CEA;
    input OCEA;
    input CLKA;
    input WEA;
    input CSA2;
    input CSA1;
    input CSA0;
    input RSTA;
    input DIB8;
    input DIB7;
    input DIB6;
    input DIB5;
    input DIB4;
    input DIB3;
    input DIB2;
    input DIB1;
    input DIB0;
    input ADB12;
    input ADB11;
    input ADB10;
    input ADB9;
    input ADB8;
    input ADB7;
    input ADB6;
    input ADB5;
    input ADB4;
    input ADB3;
    input ADB2;
    input ADB1;
    input ADB0;
    input CEB;
    input OCEB;
    input CLKB;
    input WEB;
    input CSB2;
    input CSB1;
    input CSB0;
    input RSTB;
    output DOA8;
    output DOA7;
    output DOA6;
    output DOA5;
    output DOA4;
    output DOA3;
    output DOA2;
    output DOA1;
    output DOA0;
    output DOB8;
    output DOB7;
    output DOB6;
    output DOB5;
    output DOB4;
    output DOB3;
    output DOB2;
    output DOB1;
    output DOB0;
endmodule

(* blackbox *)
module PDPW8KC (...);
    parameter DATA_WIDTH_W = 18;
    parameter DATA_WIDTH_R = 9;
    parameter REGMODE = "NOREG";
    parameter CSDECODE_W = "0b000";
    parameter CSDECODE_R = "0b000";
    parameter GSR = "ENABLED";
    parameter RESETMODE = "SYNC";
    parameter ASYNC_RESET_RELEASE = "SYNC";
    parameter INIT_DATA = "STATIC";
    parameter INITVAL_00 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_01 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_02 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_03 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_04 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_05 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_06 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_07 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_08 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_09 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_10 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_11 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_12 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_13 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_14 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_15 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_16 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_17 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_18 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_19 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    input DI17;
    input DI16;
    input DI15;
    input DI14;
    input DI13;
    input DI12;
    input DI11;
    input DI10;
    input DI9;
    input DI8;
    input DI7;
    input DI6;
    input DI5;
    input DI4;
    input DI3;
    input DI2;
    input DI1;
    input DI0;
    input ADW8;
    input ADW7;
    input ADW6;
    input ADW5;
    input ADW4;
    input ADW3;
    input ADW2;
    input ADW1;
    input ADW0;
    input BE1;
    input BE0;
    input CEW;
    input CLKW;
    input CSW2;
    input CSW1;
    input CSW0;
    input ADR12;
    input ADR11;
    input ADR10;
    input ADR9;
    input ADR8;
    input ADR7;
    input ADR6;
    input ADR5;
    input ADR4;
    input ADR3;
    input ADR2;
    input ADR1;
    input ADR0;
    input CER;
    input OCER;
    input CLKR;
    input CSR2;
    input CSR1;
    input CSR0;
    input RST;
    output DO17;
    output DO16;
    output DO15;
    output DO14;
    output DO13;
    output DO12;
    output DO11;
    output DO10;
    output DO9;
    output DO8;
    output DO7;
    output DO6;
    output DO5;
    output DO4;
    output DO3;
    output DO2;
    output DO1;
    output DO0;
endmodule

(* blackbox *)
module SP8KC (...);
    parameter DATA_WIDTH = 9;
    parameter REGMODE = "NOREG";
    parameter CSDECODE = "0b000";
    parameter WRITEMODE = "NORMAL";
    parameter GSR = "ENABLED";
    parameter RESETMODE = "SYNC";
    parameter ASYNC_RESET_RELEASE = "SYNC";
    parameter INIT_DATA = "STATIC";
    parameter INITVAL_00 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_01 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_02 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_03 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_04 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_05 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_06 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_07 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_08 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_09 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_10 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_11 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_12 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_13 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_14 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_15 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_16 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_17 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_18 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_19 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    input DI8;
    input DI7;
    input DI6;
    input DI5;
    input DI4;
    input DI3;
    input DI2;
    input DI1;
    input DI0;
    input AD12;
    input AD11;
    input AD10;
    input AD9;
    input AD8;
    input AD7;
    input AD6;
    input AD5;
    input AD4;
    input AD3;
    input AD2;
    input AD1;
    input AD0;
    input CE;
    input OCE;
    input CLK;
    input WE;
    input CS2;
    input CS1;
    input CS0;
    input RST;
    output DO8;
    output DO7;
    output DO6;
    output DO5;
    output DO4;
    output DO3;
    output DO2;
    output DO1;
    output DO0;
endmodule

(* blackbox *)
module FIFO8KB (...);
    parameter DATA_WIDTH_W = 18;
    parameter DATA_WIDTH_R = 18;
    parameter REGMODE = "NOREG";
    parameter RESETMODE = "ASYNC";
    parameter ASYNC_RESET_RELEASE = "SYNC";
    parameter CSDECODE_W = "0b00";
    parameter CSDECODE_R = "0b00";
    parameter AEPOINTER = "0b00000000000000";
    parameter AEPOINTER1 = "0b00000000000000";
    parameter AFPOINTER = "0b00000000000000";
    parameter AFPOINTER1 = "0b00000000000000";
    parameter FULLPOINTER = "0b00000000000000";
    parameter FULLPOINTER1 = "0b00000000000000";
    parameter GSR = "DISABLED";
    input DI0;
    input DI1;
    input DI2;
    input DI3;
    input DI4;
    input DI5;
    input DI6;
    input DI7;
    input DI8;
    input DI9;
    input DI10;
    input DI11;
    input DI12;
    input DI13;
    input DI14;
    input DI15;
    input DI16;
    input DI17;
    input CSW0;
    input CSW1;
    input CSR0;
    input CSR1;
    input WE;
    input RE;
    input ORE;
    input CLKW;
    input CLKR;
    input RST;
    input RPRST;
    input FULLI;
    input EMPTYI;
    output DO0;
    output DO1;
    output DO2;
    output DO3;
    output DO4;
    output DO5;
    output DO6;
    output DO7;
    output DO8;
    output DO9;
    output DO10;
    output DO11;
    output DO12;
    output DO13;
    output DO14;
    output DO15;
    output DO16;
    output DO17;
    output EF;
    output AEF;
    output AFF;
    output FF;
endmodule

(* blackbox *)
module CLKDIVC (...);
    parameter GSR = "DISABLED";
    parameter DIV = "2.0";
    input RST;
    input CLKI;
    input ALIGNWD;
    output CDIV1;
    output CDIVX;
endmodule

(* blackbox *)
module DCMA (...);
    input CLK0;
    input CLK1;
    input SEL;
    output DCMOUT;
endmodule

(* blackbox *)
module ECLKSYNCA (...);
    input ECLKI;
    input STOP;
    output ECLKO;
endmodule

(* blackbox *)
module ECLKBRIDGECS (...);
    input CLK0;
    input CLK1;
    input SEL;
    output ECSOUT;
endmodule

(* blackbox *)
module DCCA (...);
    input CLKI;
    input CE;
    output CLKO;
endmodule

(* blackbox *) (* keep *)
module START (...);
    input STARTCLK;
endmodule

(* blackbox *)
module EHXPLLJ (...);
    parameter CLKI_DIV = 1;
    parameter CLKFB_DIV = 1;
    parameter CLKOP_DIV = 8;
    parameter CLKOS_DIV = 8;
    parameter CLKOS2_DIV = 8;
    parameter CLKOS3_DIV = 8;
    parameter CLKOP_ENABLE = "ENABLED";
    parameter CLKOS_ENABLE = "ENABLED";
    parameter CLKOS2_ENABLE = "ENABLED";
    parameter CLKOS3_ENABLE = "ENABLED";
    parameter VCO_BYPASS_A0 = "DISABLED";
    parameter VCO_BYPASS_B0 = "DISABLED";
    parameter VCO_BYPASS_C0 = "DISABLED";
    parameter VCO_BYPASS_D0 = "DISABLED";
    parameter CLKOP_CPHASE = 0;
    parameter CLKOS_CPHASE = 0;
    parameter CLKOS2_CPHASE = 0;
    parameter CLKOS3_CPHASE = 0;
    parameter CLKOP_FPHASE = 0;
    parameter CLKOS_FPHASE = 0;
    parameter CLKOS2_FPHASE = 0;
    parameter CLKOS3_FPHASE = 0;
    parameter FEEDBK_PATH = "CLKOP";
    parameter FRACN_ENABLE = "DISABLED";
    parameter FRACN_DIV = 0;
    parameter CLKOP_TRIM_POL = "RISING";
    parameter CLKOP_TRIM_DELAY = 0;
    parameter CLKOS_TRIM_POL = "RISING";
    parameter CLKOS_TRIM_DELAY = 0;
    parameter PLL_USE_WB = "DISABLED";
    parameter PREDIVIDER_MUXA1 = 0;
    parameter PREDIVIDER_MUXB1 = 0;
    parameter PREDIVIDER_MUXC1 = 0;
    parameter PREDIVIDER_MUXD1 = 0;
    parameter OUTDIVIDER_MUXA2 = "DIVA";
    parameter OUTDIVIDER_MUXB2 = "DIVB";
    parameter OUTDIVIDER_MUXC2 = "DIVC";
    parameter OUTDIVIDER_MUXD2 = "DIVD";
    parameter PLL_LOCK_MODE = 0;
    parameter STDBY_ENABLE = "DISABLED";
    parameter DPHASE_SOURCE = "DISABLED";
    parameter PLLRST_ENA = "DISABLED";
    parameter MRST_ENA = "DISABLED";
    parameter DCRST_ENA = "DISABLED";
    parameter DDRST_ENA = "DISABLED";
    parameter INTFB_WAKE = "DISABLED";
    input CLKI;
    input CLKFB;
    input PHASESEL1;
    input PHASESEL0;
    input PHASEDIR;
    input PHASESTEP;
    input LOADREG;
    input STDBY;
    input PLLWAKESYNC;
    input RST;
    input RESETM;
    input RESETC;
    input RESETD;
    input ENCLKOP;
    input ENCLKOS;
    input ENCLKOS2;
    input ENCLKOS3;
    input PLLCLK;
    input PLLRST;
    input PLLSTB;
    input PLLWE;
    input PLLDATI7;
    input PLLDATI6;
    input PLLDATI5;
    input PLLDATI4;
    input PLLDATI3;
    input PLLDATI2;
    input PLLDATI1;
    input PLLDATI0;
    input PLLADDR4;
    input PLLADDR3;
    input PLLADDR2;
    input PLLADDR1;
    input PLLADDR0;
    output CLKOP;
    output CLKOS;
    output CLKOS2;
    output CLKOS3;
    output LOCK;
    output INTLOCK;
    output REFCLK;
    output PLLDATO7;
    output PLLDATO6;
    output PLLDATO5;
    output PLLDATO4;
    output PLLDATO3;
    output PLLDATO2;
    output PLLDATO1;
    output PLLDATO0;
    output PLLACK;
    output DPHSRC;
    output CLKINTFB;
endmodule

(* blackbox *)
module OSCH (...);
    parameter NOM_FREQ = "2.08";
    input STDBY;
    output OSC;
    output SEDSTDBY;
endmodule

(* blackbox *) (* keep *)
module TSALL (...);
    input TSALL;
endmodule

`,"cells_bb_xo3d.v":`// Created by cells_xtra.py from Lattice models

(* blackbox *) (* keep *)
module GSR (...);
    input GSR;
endmodule

(* blackbox *) (* keep *)
module SGSR (...);
    input GSR;
    input CLK;
endmodule

(* blackbox *)
module DP8KC (...);
    parameter DATA_WIDTH_A = 9;
    parameter DATA_WIDTH_B = 9;
    parameter REGMODE_A = "NOREG";
    parameter REGMODE_B = "NOREG";
    parameter CSDECODE_A = "0b000";
    parameter CSDECODE_B = "0b000";
    parameter WRITEMODE_A = "NORMAL";
    parameter WRITEMODE_B = "NORMAL";
    parameter GSR = "ENABLED";
    parameter RESETMODE = "SYNC";
    parameter ASYNC_RESET_RELEASE = "SYNC";
    parameter INIT_DATA = "STATIC";
    parameter INITVAL_00 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_01 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_02 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_03 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_04 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_05 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_06 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_07 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_08 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_09 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_10 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_11 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_12 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_13 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_14 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_15 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_16 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_17 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_18 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_19 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    input DIA8;
    input DIA7;
    input DIA6;
    input DIA5;
    input DIA4;
    input DIA3;
    input DIA2;
    input DIA1;
    input DIA0;
    input ADA12;
    input ADA11;
    input ADA10;
    input ADA9;
    input ADA8;
    input ADA7;
    input ADA6;
    input ADA5;
    input ADA4;
    input ADA3;
    input ADA2;
    input ADA1;
    input ADA0;
    input CEA;
    input OCEA;
    input CLKA;
    input WEA;
    input CSA2;
    input CSA1;
    input CSA0;
    input RSTA;
    input DIB8;
    input DIB7;
    input DIB6;
    input DIB5;
    input DIB4;
    input DIB3;
    input DIB2;
    input DIB1;
    input DIB0;
    input ADB12;
    input ADB11;
    input ADB10;
    input ADB9;
    input ADB8;
    input ADB7;
    input ADB6;
    input ADB5;
    input ADB4;
    input ADB3;
    input ADB2;
    input ADB1;
    input ADB0;
    input CEB;
    input OCEB;
    input CLKB;
    input WEB;
    input CSB2;
    input CSB1;
    input CSB0;
    input RSTB;
    output DOA8;
    output DOA7;
    output DOA6;
    output DOA5;
    output DOA4;
    output DOA3;
    output DOA2;
    output DOA1;
    output DOA0;
    output DOB8;
    output DOB7;
    output DOB6;
    output DOB5;
    output DOB4;
    output DOB3;
    output DOB2;
    output DOB1;
    output DOB0;
endmodule

(* blackbox *)
module PDPW8KC (...);
    parameter DATA_WIDTH_W = 18;
    parameter DATA_WIDTH_R = 9;
    parameter REGMODE = "NOREG";
    parameter CSDECODE_W = "0b000";
    parameter CSDECODE_R = "0b000";
    parameter GSR = "ENABLED";
    parameter RESETMODE = "SYNC";
    parameter ASYNC_RESET_RELEASE = "SYNC";
    parameter INIT_DATA = "STATIC";
    parameter INITVAL_00 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_01 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_02 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_03 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_04 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_05 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_06 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_07 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_08 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_09 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_10 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_11 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_12 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_13 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_14 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_15 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_16 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_17 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_18 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_19 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    input DI17;
    input DI16;
    input DI15;
    input DI14;
    input DI13;
    input DI12;
    input DI11;
    input DI10;
    input DI9;
    input DI8;
    input DI7;
    input DI6;
    input DI5;
    input DI4;
    input DI3;
    input DI2;
    input DI1;
    input DI0;
    input ADW8;
    input ADW7;
    input ADW6;
    input ADW5;
    input ADW4;
    input ADW3;
    input ADW2;
    input ADW1;
    input ADW0;
    input BE1;
    input BE0;
    input CEW;
    input CLKW;
    input CSW2;
    input CSW1;
    input CSW0;
    input ADR12;
    input ADR11;
    input ADR10;
    input ADR9;
    input ADR8;
    input ADR7;
    input ADR6;
    input ADR5;
    input ADR4;
    input ADR3;
    input ADR2;
    input ADR1;
    input ADR0;
    input CER;
    input OCER;
    input CLKR;
    input CSR2;
    input CSR1;
    input CSR0;
    input RST;
    output DO17;
    output DO16;
    output DO15;
    output DO14;
    output DO13;
    output DO12;
    output DO11;
    output DO10;
    output DO9;
    output DO8;
    output DO7;
    output DO6;
    output DO5;
    output DO4;
    output DO3;
    output DO2;
    output DO1;
    output DO0;
endmodule

(* blackbox *)
module SP8KC (...);
    parameter DATA_WIDTH = 9;
    parameter REGMODE = "NOREG";
    parameter CSDECODE = "0b000";
    parameter WRITEMODE = "NORMAL";
    parameter GSR = "ENABLED";
    parameter RESETMODE = "SYNC";
    parameter ASYNC_RESET_RELEASE = "SYNC";
    parameter INIT_DATA = "STATIC";
    parameter INITVAL_00 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_01 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_02 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_03 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_04 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_05 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_06 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_07 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_08 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_09 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_0F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_10 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_11 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_12 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_13 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_14 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_15 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_16 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_17 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_18 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_19 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    parameter INITVAL_1F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;
    input DI8;
    input DI7;
    input DI6;
    input DI5;
    input DI4;
    input DI3;
    input DI2;
    input DI1;
    input DI0;
    input AD12;
    input AD11;
    input AD10;
    input AD9;
    input AD8;
    input AD7;
    input AD6;
    input AD5;
    input AD4;
    input AD3;
    input AD2;
    input AD1;
    input AD0;
    input CE;
    input OCE;
    input CLK;
    input WE;
    input CS2;
    input CS1;
    input CS0;
    input RST;
    output DO8;
    output DO7;
    output DO6;
    output DO5;
    output DO4;
    output DO3;
    output DO2;
    output DO1;
    output DO0;
endmodule

(* blackbox *)
module FIFO8KB (...);
    parameter DATA_WIDTH_W = 18;
    parameter DATA_WIDTH_R = 18;
    parameter REGMODE = "NOREG";
    parameter RESETMODE = "ASYNC";
    parameter ASYNC_RESET_RELEASE = "SYNC";
    parameter CSDECODE_W = "0b00";
    parameter CSDECODE_R = "0b00";
    parameter AEPOINTER = "0b00000000000000";
    parameter AEPOINTER1 = "0b00000000000000";
    parameter AFPOINTER = "0b00000000000000";
    parameter AFPOINTER1 = "0b00000000000000";
    parameter FULLPOINTER = "0b00000000000000";
    parameter FULLPOINTER1 = "0b00000000000000";
    parameter GSR = "DISABLED";
    input DI0;
    input DI1;
    input DI2;
    input DI3;
    input DI4;
    input DI5;
    input DI6;
    input DI7;
    input DI8;
    input DI9;
    input DI10;
    input DI11;
    input DI12;
    input DI13;
    input DI14;
    input DI15;
    input DI16;
    input DI17;
    input CSW0;
    input CSW1;
    input CSR0;
    input CSR1;
    input WE;
    input RE;
    input ORE;
    input CLKW;
    input CLKR;
    input RST;
    input RPRST;
    input FULLI;
    input EMPTYI;
    output DO0;
    output DO1;
    output DO2;
    output DO3;
    output DO4;
    output DO5;
    output DO6;
    output DO7;
    output DO8;
    output DO9;
    output DO10;
    output DO11;
    output DO12;
    output DO13;
    output DO14;
    output DO15;
    output DO16;
    output DO17;
    output EF;
    output AEF;
    output AFF;
    output FF;
endmodule

(* blackbox *)
module CLKDIVC (...);
    parameter GSR = "DISABLED";
    parameter DIV = "2.0";
    input RST;
    input CLKI;
    input ALIGNWD;
    output CDIV1;
    output CDIVX;
endmodule

(* blackbox *)
module DCMA (...);
    input CLK0;
    input CLK1;
    input SEL;
    output DCMOUT;
endmodule

(* blackbox *)
module ECLKSYNCA (...);
    input ECLKI;
    input STOP;
    output ECLKO;
endmodule

(* blackbox *)
module ECLKBRIDGECS (...);
    input CLK0;
    input CLK1;
    input SEL;
    output ECSOUT;
endmodule

(* blackbox *)
module DCCA (...);
    input CLKI;
    input CE;
    output CLKO;
endmodule

(* blackbox *) (* keep *)
module START (...);
    input STARTCLK;
endmodule

(* blackbox *)
module EHXPLLJ (...);
    parameter CLKI_DIV = 1;
    parameter CLKFB_DIV = 1;
    parameter CLKOP_DIV = 8;
    parameter CLKOS_DIV = 8;
    parameter CLKOS2_DIV = 8;
    parameter CLKOS3_DIV = 8;
    parameter CLKOP_ENABLE = "ENABLED";
    parameter CLKOS_ENABLE = "ENABLED";
    parameter CLKOS2_ENABLE = "ENABLED";
    parameter CLKOS3_ENABLE = "ENABLED";
    parameter VCO_BYPASS_A0 = "DISABLED";
    parameter VCO_BYPASS_B0 = "DISABLED";
    parameter VCO_BYPASS_C0 = "DISABLED";
    parameter VCO_BYPASS_D0 = "DISABLED";
    parameter CLKOP_CPHASE = 0;
    parameter CLKOS_CPHASE = 0;
    parameter CLKOS2_CPHASE = 0;
    parameter CLKOS3_CPHASE = 0;
    parameter CLKOP_FPHASE = 0;
    parameter CLKOS_FPHASE = 0;
    parameter CLKOS2_FPHASE = 0;
    parameter CLKOS3_FPHASE = 0;
    parameter FEEDBK_PATH = "CLKOP";
    parameter FRACN_ENABLE = "DISABLED";
    parameter FRACN_DIV = 0;
    parameter CLKOP_TRIM_POL = "RISING";
    parameter CLKOP_TRIM_DELAY = 0;
    parameter CLKOS_TRIM_POL = "RISING";
    parameter CLKOS_TRIM_DELAY = 0;
    parameter PLL_USE_WB = "DISABLED";
    parameter PREDIVIDER_MUXA1 = 0;
    parameter PREDIVIDER_MUXB1 = 0;
    parameter PREDIVIDER_MUXC1 = 0;
    parameter PREDIVIDER_MUXD1 = 0;
    parameter OUTDIVIDER_MUXA2 = "DIVA";
    parameter OUTDIVIDER_MUXB2 = "DIVB";
    parameter OUTDIVIDER_MUXC2 = "DIVC";
    parameter OUTDIVIDER_MUXD2 = "DIVD";
    parameter PLL_LOCK_MODE = 0;
    parameter STDBY_ENABLE = "DISABLED";
    parameter DPHASE_SOURCE = "DISABLED";
    parameter PLLRST_ENA = "DISABLED";
    parameter MRST_ENA = "DISABLED";
    parameter DCRST_ENA = "DISABLED";
    parameter DDRST_ENA = "DISABLED";
    parameter INTFB_WAKE = "DISABLED";
    input CLKI;
    input CLKFB;
    input PHASESEL1;
    input PHASESEL0;
    input PHASEDIR;
    input PHASESTEP;
    input LOADREG;
    input STDBY;
    input PLLWAKESYNC;
    input RST;
    input RESETM;
    input RESETC;
    input RESETD;
    input ENCLKOP;
    input ENCLKOS;
    input ENCLKOS2;
    input ENCLKOS3;
    input PLLCLK;
    input PLLRST;
    input PLLSTB;
    input PLLWE;
    input PLLDATI7;
    input PLLDATI6;
    input PLLDATI5;
    input PLLDATI4;
    input PLLDATI3;
    input PLLDATI2;
    input PLLDATI1;
    input PLLDATI0;
    input PLLADDR4;
    input PLLADDR3;
    input PLLADDR2;
    input PLLADDR1;
    input PLLADDR0;
    output CLKOP;
    output CLKOS;
    output CLKOS2;
    output CLKOS3;
    output LOCK;
    output INTLOCK;
    output REFCLK;
    output PLLDATO7;
    output PLLDATO6;
    output PLLDATO5;
    output PLLDATO4;
    output PLLDATO3;
    output PLLDATO2;
    output PLLDATO1;
    output PLLDATO0;
    output PLLACK;
    output DPHSRC;
    output CLKINTFB;
endmodule

(* blackbox *)
module OSCJ (...);
    parameter NOM_FREQ = "2.08";
    input STDBY;
    output OSC;
    output SEDSTDBY;
    output OSCESB;
endmodule

(* blackbox *) (* keep *)
module TSALL (...);
    input TSALL;
endmodule

`,"cells_ff.vh":`// Diamond flip-flops
module FD1P3AX(input     D, SP, CK, output Q); parameter GSR = "ENABLED"; TRELLIS_FF #(.GSR(GSR), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("ASYNC"))        _TECHMAP_REPLACE_ (.CLK(CK), .LSR(|0), .CE(SP), .DI(D), .Q(Q)); endmodule
module FD1P3AY(input     D, SP, CK, output Q); parameter GSR = "ENABLED"; TRELLIS_FF #(.GSR(GSR), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"),   .SRMODE("ASYNC"))        _TECHMAP_REPLACE_ (.CLK(CK), .LSR(|0), .CE(SP), .DI(D), .Q(Q)); endmodule
module FD1P3BX(input PD, D, SP, CK, output Q); parameter GSR = "ENABLED"; TRELLIS_FF #(.GSR(GSR), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"),   .SRMODE("ASYNC"))        _TECHMAP_REPLACE_ (.CLK(CK), .LSR(PD), .CE(SP), .DI(D), .Q(Q)); endmodule
module FD1P3DX(input CD, D, SP, CK, output Q); parameter GSR = "ENABLED"; TRELLIS_FF #(.GSR(GSR), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("ASYNC"))        _TECHMAP_REPLACE_ (.CLK(CK), .LSR(CD), .CE(SP), .DI(D), .Q(Q)); endmodule
module FD1P3IX(input CD, D, SP, CK, output Q); parameter GSR = "ENABLED"; TRELLIS_FF #(.GSR(GSR), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("LSR_OVER_CE"))  _TECHMAP_REPLACE_ (.CLK(CK), .LSR(CD), .CE(SP), .DI(D), .Q(Q)); endmodule
module FD1P3JX(input PD, D, SP, CK, output Q); parameter GSR = "ENABLED"; TRELLIS_FF #(.GSR(GSR), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"),   .SRMODE("LSR_OVER_CE"))  _TECHMAP_REPLACE_ (.CLK(CK), .LSR(PD), .CE(SP), .DI(D), .Q(Q)); endmodule
module FD1S3AX(input     D,     CK, output Q); parameter GSR = "ENABLED"; TRELLIS_FF #(.GSR(GSR), .CEMUX("1"),  .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("ASYNC"))        _TECHMAP_REPLACE_ (.CLK(CK), .LSR(|0),          .DI(D), .Q(Q)); endmodule
module FD1S3AY(input     D,     CK, output Q); parameter GSR = "ENABLED"; TRELLIS_FF #(.GSR(GSR), .CEMUX("1"),  .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"),   .SRMODE("ASYNC"))        _TECHMAP_REPLACE_ (.CLK(CK), .LSR(|0),          .DI(D), .Q(Q)); endmodule
module FD1S3BX(input PD, D,     CK, output Q); parameter GSR = "ENABLED"; TRELLIS_FF #(.GSR(GSR), .CEMUX("1"),  .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"),   .SRMODE("ASYNC"))        _TECHMAP_REPLACE_ (.CLK(CK), .LSR(PD),          .DI(D), .Q(Q)); endmodule
module FD1S3DX(input CD, D,     CK, output Q); parameter GSR = "ENABLED"; TRELLIS_FF #(.GSR(GSR), .CEMUX("1"),  .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("ASYNC"))        _TECHMAP_REPLACE_ (.CLK(CK), .LSR(CD),          .DI(D), .Q(Q)); endmodule
module FD1S3IX(input CD, D,     CK, output Q); parameter GSR = "ENABLED"; TRELLIS_FF #(.GSR(GSR), .CEMUX("1"),  .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("LSR_OVER_CE"))  _TECHMAP_REPLACE_ (.CLK(CK), .LSR(CD),          .DI(D), .Q(Q)); endmodule
module FD1S3JX(input PD, D,     CK, output Q); parameter GSR = "ENABLED"; TRELLIS_FF #(.GSR(GSR), .CEMUX("1"),  .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"),   .SRMODE("LSR_OVER_CE"))  _TECHMAP_REPLACE_ (.CLK(CK), .LSR(PD),          .DI(D), .Q(Q)); endmodule

// TODO: Diamond latches
// module FL1P3AY(); endmodule
// module FL1P3AZ(); endmodule
// module FL1P3BX(); endmodule
// module FL1P3DX(); endmodule
// module FL1P3IY(); endmodule
// module FL1P3JY(); endmodule
// module FL1S3AX(); endmodule
// module FL1S3AY(); endmodule

// Diamond I/O registers
module IFS1P3BX(input PD, D, SP, SCLK, output Q); parameter GSR = "ENABLED"; (* syn_useioff, ioff_dir="input" *) TRELLIS_FF #(.GSR(GSR), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"),   .SRMODE("ASYNC"))       _TECHMAP_REPLACE_ (.CLK(SCLK), .LSR(PD), .CE(SP), .DI(D), .Q(Q)); endmodule
module IFS1P3DX(input CD, D, SP, SCLK, output Q); parameter GSR = "ENABLED"; (* syn_useioff, ioff_dir="input" *) TRELLIS_FF #(.GSR(GSR), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("ASYNC"))       _TECHMAP_REPLACE_ (.CLK(SCLK), .LSR(CD), .CE(SP), .DI(D), .Q(Q)); endmodule
module IFS1P3IX(input CD, D, SP, SCLK, output Q); parameter GSR = "ENABLED"; (* syn_useioff, ioff_dir="input" *) TRELLIS_FF #(.GSR(GSR), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("LSR_OVER_CE")) _TECHMAP_REPLACE_ (.CLK(SCLK), .LSR(CD), .CE(SP), .DI(D), .Q(Q)); endmodule
module IFS1P3JX(input PD, D, SP, SCLK, output Q); parameter GSR = "ENABLED"; (* syn_useioff, ioff_dir="input" *) TRELLIS_FF #(.GSR(GSR), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"),   .SRMODE("LSR_OVER_CE")) _TECHMAP_REPLACE_ (.CLK(SCLK), .LSR(PD), .CE(SP), .DI(D), .Q(Q)); endmodule

module OFS1P3BX(input PD, D, SP, SCLK, output Q); parameter GSR = "ENABLED"; (* syn_useioff, ioff_dir="output" *) TRELLIS_FF #(.GSR(GSR), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"),   .SRMODE("ASYNC"))       _TECHMAP_REPLACE_ (.CLK(SCLK), .LSR(PD), .CE(SP), .DI(D), .Q(Q)); endmodule
module OFS1P3DX(input CD, D, SP, SCLK, output Q); parameter GSR = "ENABLED"; (* syn_useioff, ioff_dir="output" *) TRELLIS_FF #(.GSR(GSR), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("ASYNC"))       _TECHMAP_REPLACE_ (.CLK(SCLK), .LSR(CD), .CE(SP), .DI(D), .Q(Q)); endmodule
module OFS1P3IX(input CD, D, SP, SCLK, output Q); parameter GSR = "ENABLED"; (* syn_useioff, ioff_dir="output" *) TRELLIS_FF #(.GSR(GSR), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("LSR_OVER_CE")) _TECHMAP_REPLACE_ (.CLK(SCLK), .LSR(CD), .CE(SP), .DI(D), .Q(Q)); endmodule
module OFS1P3JX(input PD, D, SP, SCLK, output Q); parameter GSR = "ENABLED"; (* syn_useioff, ioff_dir="output" *) TRELLIS_FF #(.GSR(GSR), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"),   .SRMODE("LSR_OVER_CE")) _TECHMAP_REPLACE_ (.CLK(SCLK), .LSR(PD), .CE(SP), .DI(D), .Q(Q)); endmodule

// TODO: Diamond I/O latches
// module IFS1S1B(input PD, D, SCLK, output Q); endmodule
// module IFS1S1D(input CD, D, SCLK, output Q); endmodule
// module IFS1S1I(input PD, D, SCLK, output Q); endmodule
// module IFS1S1J(input CD, D, SCLK, output Q); endmodule
`,"cells_io.vh":`// Diamond I/O buffers
module IB   ((* iopad_external_pin *) input I,     output O); (* PULLMODE="NONE" *) TRELLIS_IO #(.DIR("INPUT"))  _TECHMAP_REPLACE_ (.B(I), .O(O)); endmodule
module IBPU ((* iopad_external_pin *) input I,     output O); (* PULLMODE="UP"   *) TRELLIS_IO #(.DIR("INPUT"))  _TECHMAP_REPLACE_ (.B(I), .O(O)); endmodule
module IBPD ((* iopad_external_pin *) input I,     output O); (* PULLMODE="DOWN" *) TRELLIS_IO #(.DIR("INPUT"))  _TECHMAP_REPLACE_ (.B(I), .O(O)); endmodule
module OB   (input I,     (* iopad_external_pin *) output O); (* PULLMODE="NONE" *) TRELLIS_IO #(.DIR("OUTPUT")) _TECHMAP_REPLACE_ (.B(O), .I(I)); endmodule
module OBZ  (input I, T,  (* iopad_external_pin *) output O); (* PULLMODE="NONE" *) TRELLIS_IO #(.DIR("OUTPUT")) _TECHMAP_REPLACE_ (.B(O), .I(I), .T(T)); endmodule
module OBZPU(input I, T,  (* iopad_external_pin *) output O); (* PULLMODE="UP"   *) TRELLIS_IO #(.DIR("OUTPUT")) _TECHMAP_REPLACE_ (.B(O), .I(I), .T(T)); endmodule
module OBZPD(input I, T,  (* iopad_external_pin *) output O); (* PULLMODE="DOWN" *) TRELLIS_IO #(.DIR("OUTPUT")) _TECHMAP_REPLACE_ (.B(O), .I(I), .T(T)); endmodule
module OBCO (input I,     output OT, OC); OLVDS olvds (.A(I), .Z(OT), .ZN(OC)); endmodule
module BB   (input I, T,  output O, (* iopad_external_pin *) inout B); (* PULLMODE="NONE" *) TRELLIS_IO #(.DIR("BIDIR")) _TECHMAP_REPLACE_ (.B(B), .I(I), .O(O), .T(T)); endmodule
module BBPU (input I, T,  output O, (* iopad_external_pin *) inout B); (* PULLMODE="UP"   *) TRELLIS_IO #(.DIR("BIDIR")) _TECHMAP_REPLACE_ (.B(B), .I(I), .O(O), .T(T)); endmodule
module BBPD (input I, T,  output O, (* iopad_external_pin *) inout B); (* PULLMODE="DOWN" *) TRELLIS_IO #(.DIR("BIDIR")) _TECHMAP_REPLACE_ (.B(B), .I(I), .O(O), .T(T)); endmodule
module ILVDS(input A, AN, (* iopad_external_pin *) output Z    ); TRELLIS_IO #(.DIR("INPUT"))  _TECHMAP_REPLACE_ (.B(A), .O(Z)); endmodule
module OLVDS(input A,     (* iopad_external_pin *) output Z, output ZN); TRELLIS_IO #(.DIR("OUTPUT")) _TECHMAP_REPLACE_ (.B(Z), .I(A)); endmodule
`,"cells_map.v":`module  \\$_DFF_N_ (input D, C, output Q);
    parameter _TECHMAP_WIREINIT_Q_ = 1'bx;
    generate if (_TECHMAP_WIREINIT_Q_ === 1'b1)
        TRELLIS_FF #(.GSR("AUTO"), .CEMUX("1"), .CLKMUX("INV"), .LSRMUX("LSR"), .REGSET("SET"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(1'b0), .DI(D), .Q(Q));
    else
        TRELLIS_FF #(.GSR("AUTO"), .CEMUX("1"), .CLKMUX("INV"), .LSRMUX("LSR"), .REGSET("RESET"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(1'b0), .DI(D), .Q(Q));
    endgenerate
    wire _TECHMAP_REMOVEINIT_Q_ = 1'b1;
endmodule

module  \\$_DFF_P_ (input D, C, output Q);
    parameter _TECHMAP_WIREINIT_Q_ = 1'bx;
    generate if (_TECHMAP_WIREINIT_Q_ === 1'b1)
        TRELLIS_FF #(.GSR("AUTO"), .CEMUX("1"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(1'b0), .DI(D), .Q(Q));
    else
        TRELLIS_FF #(.GSR("AUTO"), .CEMUX("1"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(1'b0), .DI(D), .Q(Q));
    endgenerate
    wire _TECHMAP_REMOVEINIT_Q_ = 1'b1;
endmodule

module  \\$_DFFE_NN_ (input D, C, E, output Q);
    parameter _TECHMAP_WIREINIT_Q_ = 1'bx;
    generate if (_TECHMAP_WIREINIT_Q_ === 1'b1)
        TRELLIS_FF #(.GSR("AUTO"), .CEMUX("INV"), .CLKMUX("INV"), .LSRMUX("LSR"), .REGSET("SET"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(1'b0), .DI(D), .Q(Q));
    else
        TRELLIS_FF #(.GSR("AUTO"), .CEMUX("INV"), .CLKMUX("INV"), .LSRMUX("LSR"), .REGSET("RESET"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(1'b0), .DI(D), .Q(Q));
    endgenerate
    wire _TECHMAP_REMOVEINIT_Q_ = 1'b1;
endmodule

module  \\$_DFFE_PN_ (input D, C, E, output Q);
    parameter _TECHMAP_WIREINIT_Q_ = 1'bx;
    generate if (_TECHMAP_WIREINIT_Q_ === 1'b1)
        TRELLIS_FF #(.GSR("AUTO"), .CEMUX("INV"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(1'b0), .DI(D), .Q(Q));
    else
        TRELLIS_FF #(.GSR("AUTO"), .CEMUX("INV"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(1'b0), .DI(D), .Q(Q));
    endgenerate
    wire _TECHMAP_REMOVEINIT_Q_ = 1'b1;
endmodule

module  \\$_DFFE_NP_ (input D, C, E, output Q);
    parameter _TECHMAP_WIREINIT_Q_ = 1'bx;
    generate if (_TECHMAP_WIREINIT_Q_ === 1'b1)
        TRELLIS_FF #(.GSR("AUTO"), .CEMUX("CE"), .CLKMUX("INV"), .LSRMUX("LSR"), .REGSET("SET"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(1'b0), .DI(D), .Q(Q));
    else
        TRELLIS_FF #(.GSR("AUTO"), .CEMUX("CE"), .CLKMUX("INV"), .LSRMUX("LSR"), .REGSET("RESET"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(1'b0), .DI(D), .Q(Q));
    endgenerate
    wire _TECHMAP_REMOVEINIT_Q_ = 1'b1;
endmodule

module  \\$_DFFE_PP_ (input D, C, E, output Q);
    parameter _TECHMAP_WIREINIT_Q_ = 1'bx;
    generate if (_TECHMAP_WIREINIT_Q_ === 1'b1)
        TRELLIS_FF #(.GSR("AUTO"), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(1'b0), .DI(D), .Q(Q));
    else
        TRELLIS_FF #(.GSR("AUTO"), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(1'b0), .DI(D), .Q(Q));
    endgenerate
    wire _TECHMAP_REMOVEINIT_Q_ = 1'b1;
endmodule

module  \\$_DFF_NP0_ (input D, C, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("1"), .CLKMUX("INV"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("ASYNC"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_DFF_NP1_ (input D, C, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("1"), .CLKMUX("INV"), .LSRMUX("LSR"), .REGSET("SET"), .SRMODE("ASYNC"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_DFF_PP0_ (input D, C, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("1"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("ASYNC"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_DFF_PP1_ (input D, C, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("1"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"), .SRMODE("ASYNC"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule

module  \\$_SDFF_NP0_ (input D, C, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("1"), .CLKMUX("INV"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("LSR_OVER_CE"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_SDFF_NP1_ (input D, C, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("1"), .CLKMUX("INV"), .LSRMUX("LSR"), .REGSET("SET"), .SRMODE("LSR_OVER_CE"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_SDFF_PP0_ (input D, C, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("1"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("LSR_OVER_CE"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_SDFF_PP1_ (input D, C, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("1"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"), .SRMODE("LSR_OVER_CE"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule

module  \\$_DFFE_NP0P_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("CE"), .CLKMUX("INV"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("ASYNC"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_DFFE_NP1P_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("CE"), .CLKMUX("INV"), .LSRMUX("LSR"), .REGSET("SET"), .SRMODE("ASYNC"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_DFFE_PP0P_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("ASYNC"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_DFFE_PP1P_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"), .SRMODE("ASYNC"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule

module  \\$_DFFE_NP0N_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("INV"), .CLKMUX("INV"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("ASYNC"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_DFFE_NP1N_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("INV"), .CLKMUX("INV"), .LSRMUX("LSR"), .REGSET("SET"), .SRMODE("ASYNC"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_DFFE_PP0N_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("INV"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("ASYNC"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_DFFE_PP1N_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("INV"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"), .SRMODE("ASYNC"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule

module  \\$_SDFFE_NP0P_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("CE"), .CLKMUX("INV"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("LSR_OVER_CE"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_SDFFE_NP1P_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("CE"), .CLKMUX("INV"), .LSRMUX("LSR"), .REGSET("SET"), .SRMODE("LSR_OVER_CE"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_SDFFE_PP0P_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("LSR_OVER_CE"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_SDFFE_PP1P_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"), .SRMODE("LSR_OVER_CE"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule

module  \\$_SDFFE_NP0N_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("INV"), .CLKMUX("INV"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("LSR_OVER_CE"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_SDFFE_NP1N_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("INV"), .CLKMUX("INV"), .LSRMUX("LSR"), .REGSET("SET"), .SRMODE("LSR_OVER_CE"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_SDFFE_PP0N_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("INV"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("LSR_OVER_CE"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule
module  \\$_SDFFE_PP1N_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR("AUTO"), .CEMUX("INV"), .CLKMUX("CLK"), .LSRMUX("LSR"), .REGSET("SET"), .SRMODE("LSR_OVER_CE"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule

module \\$_ALDFF_NP_ (input C, L, AD, D, output Q); TRELLIS_FF #(.GSR("DISABLED"), .CEMUX("1"), .CLKMUX("INV"), .LSRMODE("PRLD"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("ASYNC"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(L), .DI(D), .M(AD), .Q(Q)); endmodule
module \\$_ALDFF_PP_ (input C, L, AD, D, output Q); TRELLIS_FF #(.GSR("DISABLED"), .CEMUX("1"), .CLKMUX("CLK"), .LSRMODE("PRLD"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("ASYNC"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(L), .DI(D), .M(AD), .Q(Q)); endmodule

module \\$_ALDFFE_NPN_ (input C, E, L, AD, D, output Q); TRELLIS_FF #(.GSR("DISABLED"), .CEMUX("INV"), .CLKMUX("INV"), .LSRMODE("PRLD"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("ASYNC"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(L), .DI(D), .M(AD), .Q(Q)); endmodule
module \\$_ALDFFE_NPP_ (input C, E, L, AD, D, output Q); TRELLIS_FF #(.GSR("DISABLED"), .CEMUX("CE"), .CLKMUX("INV"), .LSRMODE("PRLD"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("ASYNC"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(L), .DI(D), .M(AD), .Q(Q)); endmodule
module \\$_ALDFFE_PPN_ (input C, E, L, AD, D, output Q); TRELLIS_FF #(.GSR("DISABLED"), .CEMUX("INV"), .CLKMUX("CLK"), .LSRMODE("PRLD"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("ASYNC"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(L), .DI(D), .M(AD), .Q(Q)); endmodule
module \\$_ALDFFE_PPP_ (input C, E, L, AD, D, output Q); TRELLIS_FF #(.GSR("DISABLED"), .CEMUX("CE"), .CLKMUX("CLK"), .LSRMODE("PRLD"), .LSRMUX("LSR"), .REGSET("RESET"), .SRMODE("ASYNC"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(L), .DI(D), .M(AD), .Q(Q)); endmodule

\`include "cells_ff.vh"
\`include "cells_io.vh"

\`ifndef NO_LUT
module \\$lut (A, Y);
    parameter WIDTH = 0;
    parameter LUT = 0;

    (* force_downto *)
    input [WIDTH-1:0] A;
    output Y;

    generate
        if (WIDTH == 1) begin
            localparam [15:0] INIT = {{8{LUT[1]}}, {8{LUT[0]}}};
            LUT4 #(.INIT(INIT)) _TECHMAP_REPLACE_ (.Z(Y),
                .A(1'b0), .B(1'b0), .C(1'b0), .D(A[0]));
        end else
        if (WIDTH == 2) begin
            localparam [15:0] INIT = {{4{LUT[3]}}, {4{LUT[2]}}, {4{LUT[1]}}, {4{LUT[0]}}};
            LUT4 #(.INIT(INIT)) _TECHMAP_REPLACE_ (.Z(Y),
                .A(1'b0), .B(1'b0), .C(A[0]), .D(A[1]));
        end else
        if (WIDTH == 3) begin
            localparam [15:0] INIT = {{2{LUT[7]}}, {2{LUT[6]}}, {2{LUT[5]}}, {2{LUT[4]}}, {2{LUT[3]}}, {2{LUT[2]}}, {2{LUT[1]}}, {2{LUT[0]}}};
            LUT4 #(.INIT(INIT)) _TECHMAP_REPLACE_ (.Z(Y),
                .A(1'b0), .B(A[0]), .C(A[1]), .D(A[2]));
        end else
        if (WIDTH == 4) begin
            LUT4 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.Z(Y),
                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));
        \`ifndef NO_PFUMUX
        end else
        if (WIDTH == 5) begin
            wire f0, f1;
            LUT4 #(.INIT(LUT[15: 0])) lut0 (.Z(f0),
                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));
            LUT4 #(.INIT(LUT[31:16])) lut1 (.Z(f1),
                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));
            PFUMX mux5(.ALUT(f1), .BLUT(f0), .C0(A[4]), .Z(Y));
        end else
        if (WIDTH == 6) begin
            wire f0, f1, f2, f3, g0, g1;
            LUT4 #(.INIT(LUT[15: 0])) lut0 (.Z(f0),
                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));
            LUT4 #(.INIT(LUT[31:16])) lut1 (.Z(f1),
                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));

            LUT4 #(.INIT(LUT[47:32])) lut2 (.Z(f2),
                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));
            LUT4 #(.INIT(LUT[63:48])) lut3 (.Z(f3),
                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));

            PFUMX mux50(.ALUT(f1), .BLUT(f0), .C0(A[4]), .Z(g0));
            PFUMX mux51(.ALUT(f3), .BLUT(f2), .C0(A[4]), .Z(g1));
            L6MUX21 mux6 (.D0(g0), .D1(g1), .SD(A[5]), .Z(Y));
        end else
        if (WIDTH == 7) begin
            wire f0, f1, f2, f3, f4, f5, f6, f7, g0, g1, g2, g3, h0, h1;
            LUT4 #(.INIT(LUT[15: 0])) lut0 (.Z(f0),
                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));
            LUT4 #(.INIT(LUT[31:16])) lut1 (.Z(f1),
                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));

            LUT4 #(.INIT(LUT[47:32])) lut2 (.Z(f2),
                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));
            LUT4 #(.INIT(LUT[63:48])) lut3 (.Z(f3),
                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));

            LUT4 #(.INIT(LUT[79:64])) lut4 (.Z(f4),
                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));
            LUT4 #(.INIT(LUT[95:80])) lut5 (.Z(f5),
                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));

            LUT4 #(.INIT(LUT[111: 96])) lut6 (.Z(f6),
                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));
            LUT4 #(.INIT(LUT[127:112])) lut7 (.Z(f7),
                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));

            PFUMX mux50(.ALUT(f1), .BLUT(f0), .C0(A[4]), .Z(g0));
            PFUMX mux51(.ALUT(f3), .BLUT(f2), .C0(A[4]), .Z(g1));
            PFUMX mux52(.ALUT(f5), .BLUT(f4), .C0(A[4]), .Z(g2));
            PFUMX mux53(.ALUT(f7), .BLUT(f6), .C0(A[4]), .Z(g3));
            L6MUX21 mux60 (.D0(g0), .D1(g1), .SD(A[5]), .Z(h0));
            L6MUX21 mux61 (.D0(g2), .D1(g3), .SD(A[5]), .Z(h1));
            L6MUX21 mux7  (.D0(h0), .D1(h1), .SD(A[6]), .Z(Y));
        \`endif
        end else begin
            wire _TECHMAP_FAIL_ = 1;
        end
    endgenerate
endmodule
\`endif
`,"cells_sim_ecp5.v":`\`include "common_sim.vh"
\`include "ccu2c_sim.vh"

\`ifndef NO_INCLUDES

\`include "cells_ff.vh"
\`include "cells_io.vh"

\`endif
`,"cells_sim_xo2.v":`\`include "common_sim.vh"
\`include "ccu2d_sim.vh"

\`ifndef NO_INCLUDES

\`include "cells_ff.vh"
\`include "cells_io.vh"

\`endif
`,"cells_sim_xo3.v":`\`include "common_sim.vh"
\`include "ccu2d_sim.vh"

\`ifndef NO_INCLUDES

\`include "cells_ff.vh"
\`include "cells_io.vh"

\`endif
`,"cells_sim_xo3d.v":`\`include "common_sim.vh"
\`include "ccu2d_sim.vh"

\`ifndef NO_INCLUDES

\`include "cells_ff.vh"
\`include "cells_io.vh"

\`endif
`,"common_sim.vh":`// ---------------------------------------

(* abc9_lut=1, lib_whitebox *)
module LUT4(input A, B, C, D, output Z);
    parameter [15:0] INIT = 16'h0000;
    wire [7:0] s3 = D ?     INIT[15:8] :     INIT[7:0];
    wire [3:0] s2 = C ?       s3[ 7:4] :       s3[3:0];
    wire [1:0] s1 = B ?       s2[ 3:2] :       s2[1:0];
    assign Z =      A ?          s1[1] :         s1[0];
    specify
        (A => Z) = 141;
        (B => Z) = 275;
        (C => Z) = 379;
        (D => Z) = 379;
    endspecify
endmodule

// This is a placeholder for ABC9 to extract the area/delay
//   cost of 5-input LUTs and is not intended to be instantiated
// LUT5 = 2x LUT4 + PFUMX
(* abc9_lut=2 *)
module \\$__ABC9_LUT5 (input M0, D, C, B, A, output Z);
    specify
        (M0 => Z) = 151;
        (D => Z) = 239;
        (C => Z) = 373;
        (B => Z) = 477;
        (A => Z) = 477;
    endspecify
endmodule

// This is a placeholder for ABC9 to extract the area/delay
//   of 6-input LUTs and is not intended to be instantiated
// LUT6 = 2x LUT5 + MUX2
(* abc9_lut=4 *)
module \\$__ABC9_LUT6 (input M1, M0, D, C, B, A, output Z);
    specify
        (M1 => Z) = 148;
        (M0 => Z) = 292;
        (D => Z) = 380;
        (C => Z) = 514;
        (B => Z) = 618;
        (A => Z) = 618;
    endspecify
endmodule

// This is a placeholder for ABC9 to extract the area/delay
//   of 7-input LUTs and is not intended to be instantiated
// LUT7 = 2x LUT6 + MUX2
(* abc9_lut=8 *)
module \\$__ABC9_LUT7 (input M2, M1, M0, D, C, B, A, output Z);
    specify
        (M2 => Z) = 148;
        (M1 => Z) = 289;
        (M0 => Z) = 433;
        (D => Z) = 521;
        (C => Z) = 655;
        (B => Z) = 759;
        (A => Z) = 759;
    endspecify
endmodule

// ---------------------------------------
(* abc9_box, lib_whitebox *)
module L6MUX21 (input D0, D1, SD, output Z);
	assign Z = SD ? D1 : D0;
	specify
		(D0 => Z) = 140;
		(D1 => Z) = 141;
		(SD => Z) = 148;
	endspecify
endmodule

// ---------------------------------------

module TRELLIS_RAM16X2 (
	input DI0, DI1,
	input WAD0, WAD1, WAD2, WAD3,
	input WRE, WCK,
	input RAD0, RAD1, RAD2, RAD3,
	output DO0, DO1
);
	parameter WCKMUX = "WCK";
	parameter WREMUX = "WRE";
	parameter INITVAL_0 = 16'h0000;
	parameter INITVAL_1 = 16'h0000;

	reg [1:0] mem[15:0];

	integer i;
	initial begin
		for (i = 0; i < 16; i = i + 1)
			mem[i] <= {INITVAL_1[i], INITVAL_0[i]};
	end

	wire muxwck = (WCKMUX == "INV") ? ~WCK : WCK;

	reg muxwre;
	always @(*)
		case (WREMUX)
			"1": muxwre = 1'b1;
			"0": muxwre = 1'b0;
			"INV": muxwre = ~WRE;
			default: muxwre = WRE;
		endcase


	always @(posedge muxwck)
		if (muxwre)
			mem[{WAD3, WAD2, WAD1, WAD0}] <= {DI1, DI0};

	assign {DO1, DO0} = mem[{RAD3, RAD2, RAD1, RAD0}];
endmodule

// ---------------------------------------
(* abc9_box, lib_whitebox *)
module PFUMX (input ALUT, BLUT, C0, output Z);
	assign Z = C0 ? ALUT : BLUT;
	specify
		(ALUT => Z) = 98;
		(BLUT => Z) = 98;
		(C0 => Z) = 151;
	endspecify
endmodule

// ---------------------------------------
(* abc9_box, lib_whitebox *)
module TRELLIS_DPR16X4 (
	input  [3:0] DI,
	input  [3:0] WAD,
	input        WRE,
	input        WCK,
	input  [3:0] RAD,
	output [3:0] DO
);
	parameter WCKMUX = "WCK";
	parameter WREMUX = "WRE";
	parameter [63:0] INITVAL = 64'h0000000000000000;

	reg [3:0] mem[15:0];

	integer i;
	initial begin
		for (i = 0; i < 16; i = i + 1)
			mem[i] <= INITVAL[4*i +: 4];
	end

	wire muxwck = (WCKMUX == "INV") ? ~WCK : WCK;

	reg muxwre;
	always @(*)
		case (WREMUX)
			"1": muxwre = 1'b1;
			"0": muxwre = 1'b0;
			"INV": muxwre = ~WRE;
			default: muxwre = WRE;
		endcase

	always @(posedge muxwck)
		if (muxwre)
			mem[WAD] <= DI;

	assign DO = mem[RAD];

	specify
		// TODO
		(RAD *> DO) = 0;
	endspecify
endmodule

// ---------------------------------------

(* abc9_box, lib_whitebox *)
module DPR16X4C (
		input [3:0] DI,
		input WCK, WRE,
		input [3:0] RAD,
		input [3:0] WAD,
		output [3:0] DO
);
	// For legacy Lattice compatibility, INITIVAL is a hex
	// string rather than a numeric parameter
	parameter INITVAL = "0x0000000000000000";

	function [63:0] convert_initval;
		input [143:0] hex_initval;
		reg done;
		reg [63:0] temp;
		reg [7:0] char;
		integer i;
		begin
			done = 1'b0;
			temp = 0;
			for (i = 0; i < 16; i = i + 1) begin
				if (!done) begin
					char = hex_initval[8*i +: 8];
					if (char == "x") begin
						done = 1'b1;
					end else begin
						if (char >= "0" && char <= "9")
							temp[4*i +: 4] = char - "0";
						else if (char >= "A" && char <= "F")
							temp[4*i +: 4] = 10 + char - "A";
						else if (char >= "a" && char <= "f")
							temp[4*i +: 4] = 10 + char - "a";
					end
				end
			end
			convert_initval = temp;
		end
	endfunction

	localparam conv_initval = convert_initval(INITVAL);

	reg [3:0] ram[0:15];
	integer i;
	initial begin
		for (i = 0; i < 15; i = i + 1) begin
			ram[i] <= conv_initval[4*i +: 4];
		end
	end

	always @(posedge WCK)
		if (WRE)
			ram[WAD] <= DI;

	assign DO = ram[RAD];

	specify
		// TODO
		(RAD *> DO) = 0;
	endspecify
endmodule

// ---------------------------------------

(* lib_whitebox *)
module LUT2(input A, B, output Z);
    parameter [3:0] INIT = 4'h0;
    wire [1:0] s1 = B ?     INIT[ 3:2] :     INIT[1:0];
    assign Z =      A ?          s1[1] :         s1[0];
endmodule

// ---------------------------------------

\`ifdef YOSYS
(* abc9_flop=(SRMODE != "ASYNC"), abc9_box=(SRMODE == "ASYNC"), lib_whitebox *)
\`endif
module TRELLIS_FF(input CLK, LSR, CE, DI, M, output reg Q);
	parameter GSR = "ENABLED";
	parameter [127:0] CEMUX = "1";
	parameter CLKMUX = "CLK";
	parameter LSRMUX = "LSR";
	parameter SRMODE = "LSR_OVER_CE";
	parameter REGSET = "RESET";
	parameter [127:0] LSRMODE = "LSR";

	wire muxce;
	generate
		case (CEMUX)
			"1": assign muxce = 1'b1;
			"0": assign muxce = 1'b0;
			"INV": assign muxce = ~CE;
			default: assign muxce = CE;
		endcase
	endgenerate

	wire muxlsr = (LSRMUX == "INV") ? ~LSR : LSR;
	wire muxclk = (CLKMUX == "INV") ? ~CLK : CLK;
	wire srval;
	generate
		if (LSRMODE == "PRLD")
			assign srval = M;
		else
			assign srval = (REGSET == "SET") ? 1'b1 : 1'b0;
	endgenerate

	initial Q = srval;

	generate
		if (SRMODE == "ASYNC") begin
			always @(posedge muxclk, posedge muxlsr)
				if (muxlsr)
					Q <= srval;
				else if (muxce)
					Q <= DI;
		end else begin
			always @(posedge muxclk)
				if (muxlsr)
					Q <= srval;
				else if (muxce)
					Q <= DI;
		end
	endgenerate

	specify
		$setup(DI, negedge CLK &&& CLKMUX == "INV", 0);
		$setup(CE, negedge CLK &&& CLKMUX == "INV", 0);
		$setup(LSR, negedge CLK &&& CLKMUX == "INV", 0);
		$setup(DI, posedge CLK &&& CLKMUX != "INV", 0);
		$setup(CE, posedge CLK &&& CLKMUX != "INV", 0);
		$setup(LSR, posedge CLK &&& CLKMUX != "INV", 0);
\`ifndef YOSYS
		if (SRMODE == "ASYNC" && muxlsr && CLKMUX == "INV") (negedge CLK => (Q : srval)) = 0;
		if (SRMODE == "ASYNC" && muxlsr && CLKMUX != "INV") (posedge CLK => (Q : srval)) = 0;
\`else
		if (SRMODE == "ASYNC" && muxlsr) (LSR => Q) = 0; 	// Technically, this should be an edge sensitive path
									// but for facilitating a bypass box, let's pretend it's
									// a simple path
\`endif
		if (!muxlsr && muxce && CLKMUX == "INV") (negedge CLK => (Q : DI)) = 0;
		if (!muxlsr && muxce && CLKMUX != "INV") (posedge CLK => (Q : DI)) = 0;
	endspecify
endmodule

// ---------------------------------------
(* keep *)
module TRELLIS_IO(
	(* iopad_external_pin *)
	inout B,
	input I,
	input T,
	output O
);
	parameter DIR = "INPUT";
	reg T_pd;
	always @(*) if (T === 1'bz) T_pd <= 1'b0; else T_pd <= T;

	generate
		if (DIR == "INPUT") begin
			assign B = 1'bz;
			assign O = B;
		end else if (DIR == "OUTPUT") begin
			assign B = T_pd ? 1'bz : I;
			assign O = 1'bx;
		end else if (DIR == "BIDIR") begin
			assign B = T_pd ? 1'bz : I;
			assign O = B;
		end else begin
			ERROR_UNKNOWN_IO_MODE error();
		end
	endgenerate

endmodule

// ---------------------------------------

module INV(input A, output Z);
	assign Z = !A;
endmodule

// ---------------------------------------

module TRELLIS_COMB(
	input A, B, C, D, M,
	input FCI, F1, FXA, FXB,
	input WD,
	input WAD0, WAD1, WAD2, WAD3,
	input WRE, WCK,
	output F, FCO, OFX
);
	parameter MODE = "LOGIC";
	parameter INITVAL = 16'h0;
	parameter CCU2_INJECT1 = "NO";
	parameter WREMUX = "WRE";
	parameter IS_Z1 = 1'b0;

	generate
		if (MODE == "LOGIC") begin: mode_logic
			LUT4 #(.INIT(INITVAL)) lut4 (.A(A), .B(B), .C(C), .D(D), .Z(F));
		end else if (MODE == "CCU2") begin: mode_ccu2
			wire l4o, l2o;
			LUT4 #(.INIT(INITVAL)) lut4_0(.A(A), .B(B), .C(C), .D(D), .Z(l4o));
			LUT2 #(.INIT(INITVAL[3:0])) lut2_0(.A(A), .B(B), .Z(l2o));
			wire gated_cin_0 = (CCU2_INJECT1 == "YES") ? 1'b0 : FCI;
			assign F = l4o ^ gated_cin_0;
			wire gated_lut2_0 = (CCU2_INJECT1 == "YES") ? 1'b0 : l2o;
			wire FCO = (~l4o & gated_lut2_0) | (l4o & FCI);
		end else if (MODE == "DPRAM") begin: mode_dpram
			reg [15:0] ram = INITVAL;
			always @(posedge WCK)
				if (WRE)
					ram[{WAD3, WAD2, WAD1, WAD0}] <= WD;
			assign F = ram[{A, C, B, D}];
		end else begin
			$error("unsupported COMB mode %s", MODE);
		end

 		if (IS_Z1)
			L6MUX21 lutx_mux (.D0(FXA), .D1(FXB), .SD(M), .Z(OFX));
		else
			PFUMX lut5_mux (.ALUT(F1), .BLUT(F), .C0(M), .Z(OFX));
	endgenerate

endmodule

// Constants
module VLO(output Z);
	assign Z = 1'b0;
endmodule

module VHI(output Z);
	assign Z = 1'b1;
endmodule

\`ifndef NO_INCLUDES

\`include "cells_ff.vh"
\`include "cells_io.vh"

\`endif
`,"dsp_map_18x18.v":`module \\$__MUL18X18 (input [17:0] A, input [17:0] B, output [35:0] Y);

	parameter A_WIDTH = 18;
	parameter B_WIDTH = 18;
	parameter Y_WIDTH = 36;
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;

	MULT18X18D _TECHMAP_REPLACE_ (
		.A0(A[0]), .A1(A[1]), .A2(A[2]), .A3(A[3]), .A4(A[4]), .A5(A[5]), .A6(A[6]), .A7(A[7]), .A8(A[8]), .A9(A[9]), .A10(A[10]), .A11(A[11]), .A12(A[12]), .A13(A[13]), .A14(A[14]), .A15(A[15]), .A16(A[16]), .A17(A[17]),
		.B0(B[0]), .B1(B[1]), .B2(B[2]), .B3(B[3]), .B4(B[4]), .B5(B[5]), .B6(B[6]), .B7(B[7]), .B8(B[8]), .B9(B[9]), .B10(B[10]), .B11(B[11]), .B12(B[12]), .B13(B[13]), .B14(B[14]), .B15(B[15]), .B16(B[16]), .B17(B[17]),
		.C17(1'b0), .C16(1'b0), .C15(1'b0), .C14(1'b0), .C13(1'b0), .C12(1'b0), .C11(1'b0), .C10(1'b0), .C9(1'b0), .C8(1'b0), .C7(1'b0), .C6(1'b0), .C5(1'b0), .C4(1'b0), .C3(1'b0), .C2(1'b0), .C1(1'b0), .C0(1'b0),
		.SIGNEDA(A_SIGNED ? 1'b1 : 1'b0), .SIGNEDB(B_SIGNED ? 1'b1 : 1'b0), .SOURCEA(1'b0), .SOURCEB(1'b0),

		.P0(Y[0]), .P1(Y[1]), .P2(Y[2]), .P3(Y[3]), .P4(Y[4]), .P5(Y[5]), .P6(Y[6]), .P7(Y[7]), .P8(Y[8]), .P9(Y[9]), .P10(Y[10]), .P11(Y[11]), .P12(Y[12]), .P13(Y[13]), .P14(Y[14]), .P15(Y[15]), .P16(Y[16]), .P17(Y[17]), .P18(Y[18]), .P19(Y[19]), .P20(Y[20]), .P21(Y[21]), .P22(Y[22]), .P23(Y[23]), .P24(Y[24]), .P25(Y[25]), .P26(Y[26]), .P27(Y[27]), .P28(Y[28]), .P29(Y[29]), .P30(Y[30]), .P31(Y[31]), .P32(Y[32]), .P33(Y[33]), .P34(Y[34]), .P35(Y[35])
	);
endmodule
`,"latches_map.v":`module \\$_DLATCH_N_ (E, D, Q);
  wire [1023:0] _TECHMAP_DO_ = "simplemap; opt";
  input E, D;
  output Q = !E ? D : Q;
endmodule

module \\$_DLATCH_P_ (E, D, Q);
  wire [1023:0] _TECHMAP_DO_ = "simplemap; opt";
  input E, D;
  output Q = E ? D : Q;
endmodule
`,"lutrams.txt":`ram distributed $__TRELLIS_DPR16X4_ {
	abits 4;
	width 4;
	cost 4;
	init any;
	prune_rom;
	port sw "W" {
		clock anyedge;
	}
	port ar "R" {
	}
}
`,"lutrams_map.v":`module $__TRELLIS_DPR16X4_(...);

parameter INIT = 64'bx;
parameter PORT_W_CLK_POL = 1;

input PORT_W_CLK;
input [3:0] PORT_W_ADDR;
input [3:0] PORT_W_WR_DATA;
input PORT_W_WR_EN;

input [3:0] PORT_R_ADDR;
output [3:0] PORT_R_RD_DATA;

localparam WCKMUX = PORT_W_CLK_POL ? "WCK" : "INV";

TRELLIS_DPR16X4 #(
	.INITVAL(INIT),
	.WCKMUX(WCKMUX),
	.WREMUX("WRE")
) _TECHMAP_REPLACE_ (
	.RAD(PORT_R_ADDR),
	.DO(PORT_R_RD_DATA),

	.WAD(PORT_W_ADDR),
	.DI(PORT_W_WR_DATA),
	.WCK(PORT_W_CLK),
	.WRE(PORT_W_WR_EN)
);

endmodule
`},"mul2dsp.v":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *                2019  Eddie Hung    <eddie@fpgeh.com>
 *                2019  gatecat <gatecat@ds0.me>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 *  ---
 *
 *  Tech-mapping rules for decomposing arbitrarily-sized $mul cells
 *  into an equivalent collection of smaller \`DSP_NAME cells (with the 
 *  same interface as $mul) no larger than \`DSP_[AB]_MAXWIDTH, attached 
 *  to $shl and $add cells.
 *
 */

\`ifndef DSP_A_MAXWIDTH
$fatal(1, "Macro DSP_A_MAXWIDTH must be defined");
\`endif
\`ifndef DSP_B_MAXWIDTH
$fatal(1, "Macro DSP_B_MAXWIDTH must be defined");
\`endif
\`ifndef DSP_B_MAXWIDTH
$fatal(1, "Macro DSP_B_MAXWIDTH must be defined");
\`endif
\`ifndef DSP_A_MAXWIDTH_PARTIAL
\`define DSP_A_MAXWIDTH_PARTIAL \`DSP_A_MAXWIDTH
\`endif
\`ifndef DSP_B_MAXWIDTH_PARTIAL
\`define DSP_B_MAXWIDTH_PARTIAL \`DSP_B_MAXWIDTH
\`endif

\`ifndef DSP_NAME
$fatal(1, "Macro DSP_NAME must be defined");
\`endif

\`define MAX(a,b) (a > b ? a : b)
\`define MIN(a,b) (a < b ? a : b)

(* techmap_celltype = "$mul $__mul" *)
module _80_mul (A, B, Y);
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;
	parameter A_WIDTH = 1;
	parameter B_WIDTH = 1;
	parameter Y_WIDTH = 1;

	(* force_downto *)
	input [A_WIDTH-1:0] A;
	(* force_downto *)
	input [B_WIDTH-1:0] B;
	(* force_downto *)
	output [Y_WIDTH-1:0] Y;

	parameter _TECHMAP_CELLTYPE_ = "";

	generate
	if (0) begin end
\`ifdef DSP_A_MINWIDTH
	else if (A_WIDTH < \`DSP_A_MINWIDTH)
		wire _TECHMAP_FAIL_ = 1;
\`endif
\`ifdef DSP_B_MINWIDTH
	else if (B_WIDTH < \`DSP_B_MINWIDTH)
		wire _TECHMAP_FAIL_ = 1;
\`endif
\`ifdef DSP_Y_MINWIDTH
	else if (Y_WIDTH < \`DSP_Y_MINWIDTH)
		wire _TECHMAP_FAIL_ = 1;
\`endif
\`ifdef DSP_SIGNEDONLY
	else if (_TECHMAP_CELLTYPE_ == "$mul" && !A_SIGNED && !B_SIGNED)
		\\$mul #(
			.A_SIGNED(1),
			.B_SIGNED(1),
			.A_WIDTH(A_WIDTH + 1),
			.B_WIDTH(B_WIDTH + 1),
			.Y_WIDTH(Y_WIDTH)
		) _TECHMAP_REPLACE_ (
			.A({1'b0, A}),
			.B({1'b0, B}),
			.Y(Y)
		);
\`endif
	else if (_TECHMAP_CELLTYPE_ == "$mul" && A_WIDTH < B_WIDTH)
		\\$mul #(
			.A_SIGNED(B_SIGNED),
			.B_SIGNED(A_SIGNED),
			.A_WIDTH(B_WIDTH),
			.B_WIDTH(A_WIDTH),
			.Y_WIDTH(Y_WIDTH)
		) _TECHMAP_REPLACE_ (
			.A(B),
			.B(A),
			.Y(Y)
		);
	else begin
		wire [1023:0] _TECHMAP_DO_ = "proc; clean";

\`ifdef DSP_SIGNEDONLY
		localparam sign_headroom = 1;
\`else
		localparam sign_headroom = 0;
\`endif

		genvar i;
		if (A_WIDTH > \`DSP_A_MAXWIDTH) begin
			localparam n = (A_WIDTH-\`DSP_A_MAXWIDTH+\`DSP_A_MAXWIDTH_PARTIAL-sign_headroom-1) / (\`DSP_A_MAXWIDTH_PARTIAL-sign_headroom);
			localparam partial_Y_WIDTH = \`MIN(Y_WIDTH, B_WIDTH+\`DSP_A_MAXWIDTH_PARTIAL);
			localparam last_A_WIDTH = A_WIDTH-n*(\`DSP_A_MAXWIDTH_PARTIAL-sign_headroom);
			localparam last_Y_WIDTH = B_WIDTH+last_A_WIDTH;
			if (A_SIGNED && B_SIGNED) begin : blk
				(* force_downto *)
				wire signed [partial_Y_WIDTH-1:0] partial [n-1:0];
				(* force_downto *)
				wire signed [last_Y_WIDTH-1:0] last_partial;
				(* force_downto *)
				wire signed [Y_WIDTH-1:0] partial_sum [n:0];
			end
			else begin : blk
				(* force_downto *)
				wire [partial_Y_WIDTH-1:0] partial [n-1:0];
				(* force_downto *)
				wire [last_Y_WIDTH-1:0] last_partial;
				(* force_downto *)
				wire [Y_WIDTH-1:0] partial_sum [n:0];
			end

			for (i = 0; i < n; i=i+1) begin:sliceA
				\\$__mul #(
					.A_SIGNED(sign_headroom),
					.B_SIGNED(B_SIGNED),
					.A_WIDTH(\`DSP_A_MAXWIDTH_PARTIAL),
					.B_WIDTH(B_WIDTH),
					.Y_WIDTH(partial_Y_WIDTH)
				) mul (
					.A({{sign_headroom{1'b0}}, A[i*(\`DSP_A_MAXWIDTH_PARTIAL-sign_headroom) +: \`DSP_A_MAXWIDTH_PARTIAL-sign_headroom]}),
					.B(B),
					.Y(blk.partial[i])
				);
				// TODO: Currently a 'cascade' approach to summing the partial
				//       products is taken here, but a more efficient 'binary
				//       reduction' approach also exists...
				if (i == 0)
					assign blk.partial_sum[i] = blk.partial[i];
				else
					assign blk.partial_sum[i] = (blk.partial[i] << (* mul2dsp *) i*(\`DSP_A_MAXWIDTH_PARTIAL-sign_headroom)) + (* mul2dsp *) blk.partial_sum[i-1];
			end

			\\$__mul #(
				.A_SIGNED(A_SIGNED),
				.B_SIGNED(B_SIGNED),
				.A_WIDTH(last_A_WIDTH),
				.B_WIDTH(B_WIDTH),
				.Y_WIDTH(last_Y_WIDTH)
			) sliceA.last (
				.A(A[A_WIDTH-1 -: last_A_WIDTH]),
				.B(B),
				.Y(blk.last_partial)
			);
			assign blk.partial_sum[n] = (blk.last_partial << (* mul2dsp *) n*(\`DSP_A_MAXWIDTH_PARTIAL-sign_headroom)) + (* mul2dsp *) blk.partial_sum[n-1];
			assign Y = blk.partial_sum[n];
		end
		else if (B_WIDTH > \`DSP_B_MAXWIDTH) begin
			localparam n = (B_WIDTH-\`DSP_B_MAXWIDTH+\`DSP_B_MAXWIDTH_PARTIAL-sign_headroom-1) / (\`DSP_B_MAXWIDTH_PARTIAL-sign_headroom);
			localparam partial_Y_WIDTH = \`MIN(Y_WIDTH, A_WIDTH+\`DSP_B_MAXWIDTH_PARTIAL);
			localparam last_B_WIDTH = B_WIDTH-n*(\`DSP_B_MAXWIDTH_PARTIAL-sign_headroom);
			localparam last_Y_WIDTH = A_WIDTH+last_B_WIDTH;
			if (A_SIGNED && B_SIGNED) begin : blk
				(* force_downto *)
				wire signed [partial_Y_WIDTH-1:0] partial [n-1:0];
				(* force_downto *)
				wire signed [last_Y_WIDTH-1:0] last_partial;
				(* force_downto *)
				wire signed [Y_WIDTH-1:0] partial_sum [n:0];
			end
			else begin : blk
				(* force_downto *)
				wire [partial_Y_WIDTH-1:0] partial [n-1:0];
				(* force_downto *)
				wire [last_Y_WIDTH-1:0] last_partial;
				(* force_downto *)
				wire [Y_WIDTH-1:0] partial_sum [n:0];
			end

			for (i = 0; i < n; i=i+1) begin:sliceB
				\\$__mul #(
					.A_SIGNED(A_SIGNED),
					.B_SIGNED(sign_headroom),
					.A_WIDTH(A_WIDTH),
					.B_WIDTH(\`DSP_B_MAXWIDTH_PARTIAL),
					.Y_WIDTH(partial_Y_WIDTH)
				) mul (
					.A(A),
					.B({{sign_headroom{1'b0}}, B[i*(\`DSP_B_MAXWIDTH_PARTIAL-sign_headroom) +: \`DSP_B_MAXWIDTH_PARTIAL-sign_headroom]}),
					.Y(blk.partial[i])
				);
				// TODO: Currently a 'cascade' approach to summing the partial
				//       products is taken here, but a more efficient 'binary
				//       reduction' approach also exists...
				if (i == 0)
					assign blk.partial_sum[i] = blk.partial[i];
				else
					assign blk.partial_sum[i] = (blk.partial[i] << (* mul2dsp *) i*(\`DSP_B_MAXWIDTH_PARTIAL-sign_headroom)) + (* mul2dsp *) blk.partial_sum[i-1];
			end

			\\$__mul #(
				.A_SIGNED(A_SIGNED),
				.B_SIGNED(B_SIGNED),
				.A_WIDTH(A_WIDTH),
				.B_WIDTH(last_B_WIDTH),
				.Y_WIDTH(last_Y_WIDTH)
			) mul_sliceB_last (
				.A(A),
				.B(B[B_WIDTH-1 -: last_B_WIDTH]),
				.Y(blk.last_partial)
			);
			assign blk.partial_sum[n] = (blk.last_partial << (* mul2dsp *) n*(\`DSP_B_MAXWIDTH_PARTIAL-sign_headroom)) + (* mul2dsp *) blk.partial_sum[n-1];
			assign Y = blk.partial_sum[n];
		end
		else begin
			if (A_SIGNED) begin : blkA
				wire signed [\`DSP_A_MAXWIDTH-1:0] Aext = $signed(A);
			end
			else begin : blkA
				wire [\`DSP_A_MAXWIDTH-1:0] Aext = A;
			end
			if (B_SIGNED) begin : blkB
				wire signed [\`DSP_B_MAXWIDTH-1:0] Bext = $signed(B);
			end
			else begin : blkB
				wire [\`DSP_B_MAXWIDTH-1:0] Bext = B;
			end

			\`DSP_NAME #(
				.A_SIGNED(A_SIGNED),
				.B_SIGNED(B_SIGNED),
				.A_WIDTH(\`DSP_A_MAXWIDTH),
				.B_WIDTH(\`DSP_B_MAXWIDTH),
				.Y_WIDTH(\`MIN(Y_WIDTH,\`DSP_A_MAXWIDTH+\`DSP_B_MAXWIDTH)),
			) _TECHMAP_REPLACE_ (
				.A(blkA.Aext),
				.B(blkB.Bext),
				.Y(Y)
			);
		end
	end
	endgenerate
endmodule

(* techmap_celltype = "$mul $__mul" *)
module _90_soft_mul (A, B, Y);
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;
	parameter A_WIDTH = 1;
	parameter B_WIDTH = 1;
	parameter Y_WIDTH = 1;

	(* force_downto *)
	input [A_WIDTH-1:0] A;
	(* force_downto *)
	input [B_WIDTH-1:0] B;
	(* force_downto *)
	output [Y_WIDTH-1:0] Y;

	// Indirection necessary since mapping
	//   back to $mul will cause recursion
	generate
	if (A_SIGNED && !B_SIGNED)
		\\$__soft_mul #(
			.A_SIGNED(A_SIGNED),
			.B_SIGNED(1),
			.A_WIDTH(A_WIDTH),
			.B_WIDTH(B_WIDTH+1),
			.Y_WIDTH(Y_WIDTH)
		) _TECHMAP_REPLACE_ (
			.A(A),
			.B({1'b0,B}),
			.Y(Y)
		);
	else if (!A_SIGNED && B_SIGNED)
		\\$__soft_mul #(
			.A_SIGNED(1),
			.B_SIGNED(B_SIGNED),
			.A_WIDTH(A_WIDTH+1),
			.B_WIDTH(B_WIDTH),
			.Y_WIDTH(Y_WIDTH)
		) _TECHMAP_REPLACE_ (
			.A({1'b0,A}),
			.B(B),
			.Y(Y)
		);
	else
		\\$__soft_mul #(
			.A_SIGNED(A_SIGNED),
			.B_SIGNED(B_SIGNED),
			.A_WIDTH(A_WIDTH),
			.B_WIDTH(B_WIDTH),
			.Y_WIDTH(Y_WIDTH)
		) _TECHMAP_REPLACE_ (
			.A(A),
			.B(B),
			.Y(Y)
		);
	endgenerate
endmodule
`,nexus:{"arith_map.v":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *  Copyright (C) 2018  gatecat <gatecat@ds0.me>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

(* techmap_celltype = "$alu" *)
module _80_nexus_alu (A, B, CI, BI, X, Y, CO);
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;
	parameter A_WIDTH = 1;
	parameter B_WIDTH = 1;
	parameter Y_WIDTH = 1;

	(* force_downto *)
	input [A_WIDTH-1:0] A;
	(* force_downto *)
	input [B_WIDTH-1:0] B;
	(* force_downto *)
	output [Y_WIDTH-1:0] X, Y;

	input CI, BI;
	(* force_downto *)
	output [Y_WIDTH-1:0] CO;

	wire _TECHMAP_FAIL_ = Y_WIDTH <= 4;

	(* force_downto *)
	wire [Y_WIDTH-1:0] A_buf, B_buf;
	\\$pos #(.A_SIGNED(A_SIGNED), .A_WIDTH(A_WIDTH), .Y_WIDTH(Y_WIDTH)) A_conv (.A(A), .Y(A_buf));
	\\$pos #(.A_SIGNED(B_SIGNED), .A_WIDTH(B_WIDTH), .Y_WIDTH(Y_WIDTH)) B_conv (.A(B), .Y(B_buf));

	function integer round_up2;
		input integer N;
		begin
			round_up2 = ((N + 1) / 2) * 2;
		end
	endfunction

	localparam Y_WIDTH2 = round_up2(Y_WIDTH);

	(* force_downto *)
	wire [Y_WIDTH2-1:0] AA = A_buf;
	(* force_downto *)
	wire [Y_WIDTH2-1:0] BB = BI ? ~B_buf : B_buf;
	(* force_downto *)
	wire [Y_WIDTH2-1:0] BX = B_buf;
	(* force_downto *)
	wire [Y_WIDTH2+1:0] FCO, Y1;

	genvar i;

	// Carry feed-in
	CCU2 #(
		.INIT0("0xFFFF"),
		.INIT1("0x00AA"),
		.INJECT("NO")
	) ccu2c_i (
		.A0(1'b1), .B0(1'b1), .C0(1'b1), .D0(1'b1),
		.A1(CI), .B1(1'b1), .C1(1'b1), .D1(1'b1),
		.COUT(FCO[0])
	);

	generate for (i = 0; i < Y_WIDTH2; i = i + 2) begin:slice
		CCU2 #(
			.INIT0("0x96AA"),
			.INIT1("0x96AA"),
			.INJECT("NO")
		) ccu2c_i (
			.CIN(FCO[i]),
			.A0(AA[i]), .B0(BX[i]), .C0(BI), .D0(1'b1),
			.A1(AA[i+1]), .B1(BX[i+1]), .C1(BI), .D1(1'b1),
			.S0(Y[i]), .S1(Y1[i]),
			.COUT(FCO[i+2])
		);

		assign CO[i] = (AA[i] && BB[i]) || ((Y[i] ^ AA[i] ^ BB[i]) && (AA[i] || BB[i]));
		if (i+1 < Y_WIDTH) begin
			assign CO[i + 1] = (AA[i + 1] && BB[i + 1]) || ((Y[i + 1] ^ AA[i + 1] ^ BB[i + 1]) && (AA[i + 1] || BB[i + 1]));
			assign Y[i+1] = Y1[i];
		end
	end endgenerate

	assign X = AA ^ BB;
endmodule
`,"brams.txt":`ram block $__NX_DP16K_ {
	abits 14;
	widths 1 2 4 9 18 per_port;
	byte 9;
	cost 129;
	init no_undef;
	port srsw "A" "B" {
		clock posedge;
		clken;
		wrbe_separate;
		rdwr no_change;
		portoption "RESETMODE" "SYNC" {
			rdsrst zero gated_clken;
		}
		portoption "RESETMODE" "ASYNC" {
			rdarst zero;
		}
		rdinit zero;
	}
}

ram block $__NX_PDP16K_ {
	abits 14;
	widths 1 2 4 9 18 36 per_port;
	byte 9;
	option "SAME_CLOCK" 1 cost 128;
	option "SAME_CLOCK" 0 cost 129;
	init no_undef;
	port sr "R" {
		option "SAME_CLOCK" 1 clock posedge "C";
		option "SAME_CLOCK" 0 clock posedge;
		clken;
		portoption "RESETMODE" "SYNC" {
			rdsrst zero gated_clken;
		}
		portoption "RESETMODE" "ASYNC" {
			rdarst zero;
		}
		rdinit zero;
	}
	port sw "W" {
		option "SAME_CLOCK" 1 clock posedge "C";
		option "SAME_CLOCK" 0 clock posedge;
		clken;
		option "SAME_CLOCK" 1 wrtrans all old;
	}
}
`,"brams_map.v":`module $__NX_DP16K_ (...);

parameter INIT = 0;

parameter PORT_A_OPTION_RESETMODE = "SYNC";
parameter PORT_A_WIDTH = 18;
parameter PORT_A_WR_BE_WIDTH = 2;

input PORT_A_CLK;
input PORT_A_CLK_EN;
input PORT_A_WR_EN;
input PORT_A_RD_SRST;
input PORT_A_RD_ARST;
input [13:0] PORT_A_ADDR;
input [PORT_A_WR_BE_WIDTH-1:0] PORT_A_WR_BE;
input [PORT_A_WIDTH-1:0] PORT_A_WR_DATA;
output [PORT_A_WIDTH-1:0] PORT_A_RD_DATA;

parameter PORT_B_OPTION_RESETMODE = "SYNC";
parameter PORT_B_WIDTH = 18;
parameter PORT_B_WR_BE_WIDTH = 2;

input PORT_B_CLK;
input PORT_B_CLK_EN;
input PORT_B_WR_EN;
input PORT_B_RD_SRST;
input PORT_B_RD_ARST;
input [13:0] PORT_B_ADDR;
input [PORT_B_WR_BE_WIDTH-1:0] PORT_B_WR_BE;
input [PORT_B_WIDTH-1:0] PORT_B_WR_DATA;
output [PORT_B_WIDTH-1:0] PORT_B_RD_DATA;

function [319:0] init_slice;
	input integer idx;
	integer i;
	init_slice = 0;
	for (i = 0; i < 32; i = i + 1) begin
		init_slice[i*10+:9] = INIT[(idx * 32 + i) * 9+:9];
	end
endfunction

wire [17:0] DOA;
wire [17:0] DOB;
wire [17:0] DIA = PORT_A_WR_DATA;
wire [17:0] DIB = PORT_B_WR_DATA;
wire [13:0] ADA;
wire [13:0] ADB;

generate

case(PORT_A_WIDTH)
1: assign ADA = PORT_A_ADDR;
2: assign ADA = {PORT_A_ADDR[13:1], 1'b1};
4: assign ADA = {PORT_A_ADDR[13:2], 2'b11};
9: assign ADA = {PORT_A_ADDR[13:3], 3'b111};
18: assign ADA = {PORT_A_ADDR[13:4], 2'b11, PORT_A_WR_BE};
endcase

case(PORT_B_WIDTH)
1: assign ADB = PORT_B_ADDR;
2: assign ADB = {PORT_B_ADDR[13:1], 1'b1};
4: assign ADB = {PORT_B_ADDR[13:2], 2'b11};
9: assign ADB = {PORT_B_ADDR[13:3], 3'b111};
18: assign ADB = {PORT_B_ADDR[13:4], 2'b11, PORT_B_WR_BE};
endcase

endgenerate

assign PORT_A_RD_DATA = DOA;
assign PORT_B_RD_DATA = DOB;

DP16K #(
	.INITVAL_00($sformatf("0x%080x", init_slice('h00))),
	.INITVAL_01($sformatf("0x%080x", init_slice('h01))),
	.INITVAL_02($sformatf("0x%080x", init_slice('h02))),
	.INITVAL_03($sformatf("0x%080x", init_slice('h03))),
	.INITVAL_04($sformatf("0x%080x", init_slice('h04))),
	.INITVAL_05($sformatf("0x%080x", init_slice('h05))),
	.INITVAL_06($sformatf("0x%080x", init_slice('h06))),
	.INITVAL_07($sformatf("0x%080x", init_slice('h07))),
	.INITVAL_08($sformatf("0x%080x", init_slice('h08))),
	.INITVAL_09($sformatf("0x%080x", init_slice('h09))),
	.INITVAL_0A($sformatf("0x%080x", init_slice('h0a))),
	.INITVAL_0B($sformatf("0x%080x", init_slice('h0b))),
	.INITVAL_0C($sformatf("0x%080x", init_slice('h0c))),
	.INITVAL_0D($sformatf("0x%080x", init_slice('h0d))),
	.INITVAL_0E($sformatf("0x%080x", init_slice('h0e))),
	.INITVAL_0F($sformatf("0x%080x", init_slice('h0f))),
	.INITVAL_10($sformatf("0x%080x", init_slice('h10))),
	.INITVAL_11($sformatf("0x%080x", init_slice('h11))),
	.INITVAL_12($sformatf("0x%080x", init_slice('h12))),
	.INITVAL_13($sformatf("0x%080x", init_slice('h13))),
	.INITVAL_14($sformatf("0x%080x", init_slice('h14))),
	.INITVAL_15($sformatf("0x%080x", init_slice('h15))),
	.INITVAL_16($sformatf("0x%080x", init_slice('h16))),
	.INITVAL_17($sformatf("0x%080x", init_slice('h17))),
	.INITVAL_18($sformatf("0x%080x", init_slice('h18))),
	.INITVAL_19($sformatf("0x%080x", init_slice('h19))),
	.INITVAL_1A($sformatf("0x%080x", init_slice('h1a))),
	.INITVAL_1B($sformatf("0x%080x", init_slice('h1b))),
	.INITVAL_1C($sformatf("0x%080x", init_slice('h1c))),
	.INITVAL_1D($sformatf("0x%080x", init_slice('h1d))),
	.INITVAL_1E($sformatf("0x%080x", init_slice('h1e))),
	.INITVAL_1F($sformatf("0x%080x", init_slice('h1f))),
	.INITVAL_20($sformatf("0x%080x", init_slice('h20))),
	.INITVAL_21($sformatf("0x%080x", init_slice('h21))),
	.INITVAL_22($sformatf("0x%080x", init_slice('h22))),
	.INITVAL_23($sformatf("0x%080x", init_slice('h23))),
	.INITVAL_24($sformatf("0x%080x", init_slice('h24))),
	.INITVAL_25($sformatf("0x%080x", init_slice('h25))),
	.INITVAL_26($sformatf("0x%080x", init_slice('h26))),
	.INITVAL_27($sformatf("0x%080x", init_slice('h27))),
	.INITVAL_28($sformatf("0x%080x", init_slice('h28))),
	.INITVAL_29($sformatf("0x%080x", init_slice('h29))),
	.INITVAL_2A($sformatf("0x%080x", init_slice('h2a))),
	.INITVAL_2B($sformatf("0x%080x", init_slice('h2b))),
	.INITVAL_2C($sformatf("0x%080x", init_slice('h2c))),
	.INITVAL_2D($sformatf("0x%080x", init_slice('h2d))),
	.INITVAL_2E($sformatf("0x%080x", init_slice('h2e))),
	.INITVAL_2F($sformatf("0x%080x", init_slice('h2f))),
	.INITVAL_30($sformatf("0x%080x", init_slice('h30))),
	.INITVAL_31($sformatf("0x%080x", init_slice('h31))),
	.INITVAL_32($sformatf("0x%080x", init_slice('h32))),
	.INITVAL_33($sformatf("0x%080x", init_slice('h33))),
	.INITVAL_34($sformatf("0x%080x", init_slice('h34))),
	.INITVAL_35($sformatf("0x%080x", init_slice('h35))),
	.INITVAL_36($sformatf("0x%080x", init_slice('h36))),
	.INITVAL_37($sformatf("0x%080x", init_slice('h37))),
	.INITVAL_38($sformatf("0x%080x", init_slice('h38))),
	.INITVAL_39($sformatf("0x%080x", init_slice('h39))),
	.INITVAL_3A($sformatf("0x%080x", init_slice('h3a))),
	.INITVAL_3B($sformatf("0x%080x", init_slice('h3b))),
	.INITVAL_3C($sformatf("0x%080x", init_slice('h3c))),
	.INITVAL_3D($sformatf("0x%080x", init_slice('h3d))),
	.INITVAL_3E($sformatf("0x%080x", init_slice('h3e))),
	.INITVAL_3F($sformatf("0x%080x", init_slice('h3f))),
	.DATA_WIDTH_A($sformatf("X%0d", PORT_A_WIDTH)),
	.DATA_WIDTH_B($sformatf("X%0d", PORT_B_WIDTH)),
	.OUTREG_A("BYPASSED"),
	.OUTREG_B("BYPASSED"),
	.RESETMODE_A(PORT_A_OPTION_RESETMODE),
	.RESETMODE_B(PORT_B_OPTION_RESETMODE),
	.ASYNC_RST_RELEASE_A(PORT_A_OPTION_RESETMODE),
	.ASYNC_RST_RELEASE_B(PORT_B_OPTION_RESETMODE),
	.CSDECODE_A("111"),
	.CSDECODE_B("111"),
	.GSR("DISABLED"),
) _TECHMAP_REPLACE_ (
	.CLKA(PORT_A_CLK),
	.WEA(PORT_A_WIDTH == 18 ? PORT_A_WR_EN : (PORT_A_WR_EN | PORT_A_WR_BE[0])),
	.CEA(PORT_A_CLK_EN),
	.RSTA(PORT_A_OPTION_RESETMODE == "SYNC" ? PORT_A_RD_SRST : PORT_A_RD_ARST),
	.CSA(3'b111),
	.DIA(DIA),
	.DOA(DOA),
	.ADA(ADA),

	.CLKB(PORT_B_CLK),
	.WEB(PORT_B_WIDTH == 18 ? PORT_B_WR_EN : (PORT_B_WR_EN | PORT_B_WR_BE[0])),
	.CEB(PORT_B_CLK_EN),
	.RSTB(PORT_B_OPTION_RESETMODE == "SYNC" ? PORT_B_RD_SRST : PORT_B_RD_ARST),
	.CSB(3'b111),
	.ADB(ADB),
	.DIB(DIB),
	.DOB(DOB),
);

endmodule


module $__NX_PDP16K_ (...);

parameter INIT = 0;
parameter OPTION_SAME_CLOCK = 1;

parameter PORT_R_WIDTH = 36;
parameter PORT_R_OPTION_RESETMODE = "SYNC";

input CLK_C;

input PORT_R_CLK;
input PORT_R_CLK_EN;
input PORT_R_RD_SRST;
input PORT_R_RD_ARST;
input [13:0] PORT_R_ADDR;
output [PORT_R_WIDTH-1:0] PORT_R_RD_DATA;

parameter PORT_W_WIDTH = 36;
parameter PORT_W_WR_EN_WIDTH = 4;

input PORT_W_CLK;
input PORT_W_CLK_EN;
input [13:0] PORT_W_ADDR;
input [PORT_W_WR_EN_WIDTH-1:0] PORT_W_WR_EN;
input [PORT_W_WIDTH-1:0] PORT_W_WR_DATA;

function [319:0] init_slice;
	input integer idx;
	integer i;
	init_slice = 0;
	for (i = 0; i < 32; i = i + 1) begin
		init_slice[i*10+:9] = INIT[(idx * 32 + i) * 9+:9];
	end
endfunction

wire [35:0] DI = PORT_W_WR_DATA;
wire [35:0] DO;

assign PORT_R_RD_DATA = DO;

wire [13:0] ADW;
wire [13:0] ADR;

generate

case (PORT_W_WIDTH)
1: assign ADW = PORT_W_ADDR;
2: assign ADW = {PORT_W_ADDR[13:1], 1'b1};
4: assign ADW = {PORT_W_ADDR[13:2], 2'b11};
9: assign ADW = {PORT_W_ADDR[13:3], 3'b111};
18: assign ADW = {PORT_W_ADDR[13:4], 2'b11, PORT_W_WR_EN};
36: assign ADW = {PORT_W_ADDR[13:5], 1'b1, PORT_W_WR_EN};
endcase

case (PORT_R_WIDTH)
1: assign ADR = PORT_R_ADDR;
2: assign ADR = {PORT_R_ADDR[13:1], 1'b1};
4: assign ADR = {PORT_R_ADDR[13:2], 2'b11};
9: assign ADR = {PORT_R_ADDR[13:3], 3'b111};
18: assign ADR = {PORT_R_ADDR[13:4], 4'b1111};
36: assign ADR = {PORT_R_ADDR[13:5], 5'b11111};
endcase

if (OPTION_SAME_CLOCK) begin

PDPSC16K #(
	.INITVAL_00($sformatf("0x%080x", init_slice('h00))),
	.INITVAL_01($sformatf("0x%080x", init_slice('h01))),
	.INITVAL_02($sformatf("0x%080x", init_slice('h02))),
	.INITVAL_03($sformatf("0x%080x", init_slice('h03))),
	.INITVAL_04($sformatf("0x%080x", init_slice('h04))),
	.INITVAL_05($sformatf("0x%080x", init_slice('h05))),
	.INITVAL_06($sformatf("0x%080x", init_slice('h06))),
	.INITVAL_07($sformatf("0x%080x", init_slice('h07))),
	.INITVAL_08($sformatf("0x%080x", init_slice('h08))),
	.INITVAL_09($sformatf("0x%080x", init_slice('h09))),
	.INITVAL_0A($sformatf("0x%080x", init_slice('h0a))),
	.INITVAL_0B($sformatf("0x%080x", init_slice('h0b))),
	.INITVAL_0C($sformatf("0x%080x", init_slice('h0c))),
	.INITVAL_0D($sformatf("0x%080x", init_slice('h0d))),
	.INITVAL_0E($sformatf("0x%080x", init_slice('h0e))),
	.INITVAL_0F($sformatf("0x%080x", init_slice('h0f))),
	.INITVAL_10($sformatf("0x%080x", init_slice('h10))),
	.INITVAL_11($sformatf("0x%080x", init_slice('h11))),
	.INITVAL_12($sformatf("0x%080x", init_slice('h12))),
	.INITVAL_13($sformatf("0x%080x", init_slice('h13))),
	.INITVAL_14($sformatf("0x%080x", init_slice('h14))),
	.INITVAL_15($sformatf("0x%080x", init_slice('h15))),
	.INITVAL_16($sformatf("0x%080x", init_slice('h16))),
	.INITVAL_17($sformatf("0x%080x", init_slice('h17))),
	.INITVAL_18($sformatf("0x%080x", init_slice('h18))),
	.INITVAL_19($sformatf("0x%080x", init_slice('h19))),
	.INITVAL_1A($sformatf("0x%080x", init_slice('h1a))),
	.INITVAL_1B($sformatf("0x%080x", init_slice('h1b))),
	.INITVAL_1C($sformatf("0x%080x", init_slice('h1c))),
	.INITVAL_1D($sformatf("0x%080x", init_slice('h1d))),
	.INITVAL_1E($sformatf("0x%080x", init_slice('h1e))),
	.INITVAL_1F($sformatf("0x%080x", init_slice('h1f))),
	.INITVAL_20($sformatf("0x%080x", init_slice('h20))),
	.INITVAL_21($sformatf("0x%080x", init_slice('h21))),
	.INITVAL_22($sformatf("0x%080x", init_slice('h22))),
	.INITVAL_23($sformatf("0x%080x", init_slice('h23))),
	.INITVAL_24($sformatf("0x%080x", init_slice('h24))),
	.INITVAL_25($sformatf("0x%080x", init_slice('h25))),
	.INITVAL_26($sformatf("0x%080x", init_slice('h26))),
	.INITVAL_27($sformatf("0x%080x", init_slice('h27))),
	.INITVAL_28($sformatf("0x%080x", init_slice('h28))),
	.INITVAL_29($sformatf("0x%080x", init_slice('h29))),
	.INITVAL_2A($sformatf("0x%080x", init_slice('h2a))),
	.INITVAL_2B($sformatf("0x%080x", init_slice('h2b))),
	.INITVAL_2C($sformatf("0x%080x", init_slice('h2c))),
	.INITVAL_2D($sformatf("0x%080x", init_slice('h2d))),
	.INITVAL_2E($sformatf("0x%080x", init_slice('h2e))),
	.INITVAL_2F($sformatf("0x%080x", init_slice('h2f))),
	.INITVAL_30($sformatf("0x%080x", init_slice('h30))),
	.INITVAL_31($sformatf("0x%080x", init_slice('h31))),
	.INITVAL_32($sformatf("0x%080x", init_slice('h32))),
	.INITVAL_33($sformatf("0x%080x", init_slice('h33))),
	.INITVAL_34($sformatf("0x%080x", init_slice('h34))),
	.INITVAL_35($sformatf("0x%080x", init_slice('h35))),
	.INITVAL_36($sformatf("0x%080x", init_slice('h36))),
	.INITVAL_37($sformatf("0x%080x", init_slice('h37))),
	.INITVAL_38($sformatf("0x%080x", init_slice('h38))),
	.INITVAL_39($sformatf("0x%080x", init_slice('h39))),
	.INITVAL_3A($sformatf("0x%080x", init_slice('h3a))),
	.INITVAL_3B($sformatf("0x%080x", init_slice('h3b))),
	.INITVAL_3C($sformatf("0x%080x", init_slice('h3c))),
	.INITVAL_3D($sformatf("0x%080x", init_slice('h3d))),
	.INITVAL_3E($sformatf("0x%080x", init_slice('h3e))),
	.INITVAL_3F($sformatf("0x%080x", init_slice('h3f))),
	.DATA_WIDTH_W($sformatf("X%0d", PORT_W_WIDTH)),
	.DATA_WIDTH_R($sformatf("X%0d", PORT_R_WIDTH)),
	.OUTREG("BYPASSED"),
	.RESETMODE(PORT_R_OPTION_RESETMODE),
	.ASYNC_RST_RELEASE(PORT_R_OPTION_RESETMODE),
	.CSDECODE_W("111"),
	.CSDECODE_R("111"),
	.ECC("DISABLED"),
	.GSR("DISABLED"),
) _TECHMAP_REPLACE_ (
	.CLK(CLK_C),

	.CEW(PORT_W_CLK_EN & (|PORT_W_WR_EN)),
	.CSW(3'b111),
	.ADW(ADW),
	.DI(DI),

	.CER(PORT_R_CLK_EN),
	.RST(PORT_R_OPTION_RESETMODE == "SYNC" ? PORT_R_RD_SRST : PORT_R_RD_ARST),
	.CSR(3'b111),
	.ADR(ADR),
	.DO(DO),
);

end else begin

PDP16K #(
	.INITVAL_00($sformatf("0x%080x", init_slice('h00))),
	.INITVAL_01($sformatf("0x%080x", init_slice('h01))),
	.INITVAL_02($sformatf("0x%080x", init_slice('h02))),
	.INITVAL_03($sformatf("0x%080x", init_slice('h03))),
	.INITVAL_04($sformatf("0x%080x", init_slice('h04))),
	.INITVAL_05($sformatf("0x%080x", init_slice('h05))),
	.INITVAL_06($sformatf("0x%080x", init_slice('h06))),
	.INITVAL_07($sformatf("0x%080x", init_slice('h07))),
	.INITVAL_08($sformatf("0x%080x", init_slice('h08))),
	.INITVAL_09($sformatf("0x%080x", init_slice('h09))),
	.INITVAL_0A($sformatf("0x%080x", init_slice('h0a))),
	.INITVAL_0B($sformatf("0x%080x", init_slice('h0b))),
	.INITVAL_0C($sformatf("0x%080x", init_slice('h0c))),
	.INITVAL_0D($sformatf("0x%080x", init_slice('h0d))),
	.INITVAL_0E($sformatf("0x%080x", init_slice('h0e))),
	.INITVAL_0F($sformatf("0x%080x", init_slice('h0f))),
	.INITVAL_10($sformatf("0x%080x", init_slice('h10))),
	.INITVAL_11($sformatf("0x%080x", init_slice('h11))),
	.INITVAL_12($sformatf("0x%080x", init_slice('h12))),
	.INITVAL_13($sformatf("0x%080x", init_slice('h13))),
	.INITVAL_14($sformatf("0x%080x", init_slice('h14))),
	.INITVAL_15($sformatf("0x%080x", init_slice('h15))),
	.INITVAL_16($sformatf("0x%080x", init_slice('h16))),
	.INITVAL_17($sformatf("0x%080x", init_slice('h17))),
	.INITVAL_18($sformatf("0x%080x", init_slice('h18))),
	.INITVAL_19($sformatf("0x%080x", init_slice('h19))),
	.INITVAL_1A($sformatf("0x%080x", init_slice('h1a))),
	.INITVAL_1B($sformatf("0x%080x", init_slice('h1b))),
	.INITVAL_1C($sformatf("0x%080x", init_slice('h1c))),
	.INITVAL_1D($sformatf("0x%080x", init_slice('h1d))),
	.INITVAL_1E($sformatf("0x%080x", init_slice('h1e))),
	.INITVAL_1F($sformatf("0x%080x", init_slice('h1f))),
	.INITVAL_20($sformatf("0x%080x", init_slice('h20))),
	.INITVAL_21($sformatf("0x%080x", init_slice('h21))),
	.INITVAL_22($sformatf("0x%080x", init_slice('h22))),
	.INITVAL_23($sformatf("0x%080x", init_slice('h23))),
	.INITVAL_24($sformatf("0x%080x", init_slice('h24))),
	.INITVAL_25($sformatf("0x%080x", init_slice('h25))),
	.INITVAL_26($sformatf("0x%080x", init_slice('h26))),
	.INITVAL_27($sformatf("0x%080x", init_slice('h27))),
	.INITVAL_28($sformatf("0x%080x", init_slice('h28))),
	.INITVAL_29($sformatf("0x%080x", init_slice('h29))),
	.INITVAL_2A($sformatf("0x%080x", init_slice('h2a))),
	.INITVAL_2B($sformatf("0x%080x", init_slice('h2b))),
	.INITVAL_2C($sformatf("0x%080x", init_slice('h2c))),
	.INITVAL_2D($sformatf("0x%080x", init_slice('h2d))),
	.INITVAL_2E($sformatf("0x%080x", init_slice('h2e))),
	.INITVAL_2F($sformatf("0x%080x", init_slice('h2f))),
	.INITVAL_30($sformatf("0x%080x", init_slice('h30))),
	.INITVAL_31($sformatf("0x%080x", init_slice('h31))),
	.INITVAL_32($sformatf("0x%080x", init_slice('h32))),
	.INITVAL_33($sformatf("0x%080x", init_slice('h33))),
	.INITVAL_34($sformatf("0x%080x", init_slice('h34))),
	.INITVAL_35($sformatf("0x%080x", init_slice('h35))),
	.INITVAL_36($sformatf("0x%080x", init_slice('h36))),
	.INITVAL_37($sformatf("0x%080x", init_slice('h37))),
	.INITVAL_38($sformatf("0x%080x", init_slice('h38))),
	.INITVAL_39($sformatf("0x%080x", init_slice('h39))),
	.INITVAL_3A($sformatf("0x%080x", init_slice('h3a))),
	.INITVAL_3B($sformatf("0x%080x", init_slice('h3b))),
	.INITVAL_3C($sformatf("0x%080x", init_slice('h3c))),
	.INITVAL_3D($sformatf("0x%080x", init_slice('h3d))),
	.INITVAL_3E($sformatf("0x%080x", init_slice('h3e))),
	.INITVAL_3F($sformatf("0x%080x", init_slice('h3f))),
	.DATA_WIDTH_W($sformatf("X%0d", PORT_W_WIDTH)),
	.DATA_WIDTH_R($sformatf("X%0d", PORT_R_WIDTH)),
	.OUTREG("BYPASSED"),
	.RESETMODE(PORT_R_OPTION_RESETMODE),
	.ASYNC_RST_RELEASE(PORT_R_OPTION_RESETMODE),
	.CSDECODE_W("111"),
	.CSDECODE_R("111"),
	.ECC("DISABLED"),
	.GSR("DISABLED"),
) _TECHMAP_REPLACE_ (
	.CLKW(PORT_W_CLK),
	.CEW(PORT_W_CLK_EN & (|PORT_W_WR_EN)),
	.CSW(3'b111),
	.ADW(ADW),
	.DI(DI),

	.CLKR(PORT_R_CLK),
	.CER(PORT_R_CLK_EN),
	.RST(PORT_R_OPTION_RESETMODE == "SYNC" ? PORT_R_RD_SRST : PORT_R_RD_ARST),
	.CSR(3'b111),
	.ADR(ADR),
	.DO(DO),
);

end

endgenerate

endmodule
`,"cells_map.v":`// Flipflop intermediate map level
module \\$__FF_NOLSR (input D, C, E, output Q);
	parameter _TECHMAP_WIREINIT_Q_ = 1'bx;
	wire _TECHMAP_REMOVEINIT_Q_ = 1'b1;
	generate
		if (_TECHMAP_WIREINIT_Q_ === 1'b1)
			FD1P3JX #(.GSR("DISABLED")) _TECHMAP_REPLACE_ (.D(D), .CK(C), .SP(E), .PD(1'b0), .Q(Q));
		else
			FD1P3IX #(.GSR("DISABLED")) _TECHMAP_REPLACE_ (.D(D), .CK(C), .SP(E), .CD(1'b0), .Q(Q));
	endgenerate
endmodule

module \\$__FF_SYNCLSR (input D, C, E, R, output Q);
	parameter SR_VAL = 1'b0;
	parameter _TECHMAP_WIREINIT_Q_ = 1'bx;
	wire _TECHMAP_REMOVEINIT_Q_ = 1'b1;
	wire Ci, Ei, Ri, Rg, Dd;
	generate
		if (SR_VAL)
			FD1P3JX #(.GSR("DISABLED")) _TECHMAP_REPLACE_ (.D(D), .CK(C), .SP(E), .PD(R), .Q(Q));
		else
			FD1P3IX #(.GSR("DISABLED")) _TECHMAP_REPLACE_ (.D(D), .CK(C), .SP(E), .CD(R), .Q(Q));
	endgenerate
endmodule

module \\$__FF_ASYNCLSR (input D, C, E, R, output Q);
	parameter SR_VAL = 1'b0;
	parameter _TECHMAP_WIREINIT_Q_ = 1'bx;
	wire _TECHMAP_REMOVEINIT_Q_ = (_TECHMAP_WIREINIT_Q_ === 1'bx || _TECHMAP_WIREINIT_Q_ === SR_VAL);
	wire Ci, Ei, Ri, Rg, Dd;
	generate
		if (SR_VAL)
			FD1P3BX #(.GSR("DISABLED")) _TECHMAP_REPLACE_ (.D(D), .CK(C), .SP(E), .PD(R), .Q(Q));
		else
			FD1P3DX #(.GSR("DISABLED")) _TECHMAP_REPLACE_ (.D(D), .CK(C), .SP(E), .CD(R), .Q(Q));
	endgenerate
endmodule


module  \\$_DFF_P_ (input D, C, output Q); \\$__FF_NOLSR _TECHMAP_REPLACE_ (.D(D), .C(C), .E(1'b1), .Q(Q)); endmodule

module  \\$_DFFE_PP_ (input D, C, E, output Q); \\$__FF_NOLSR _TECHMAP_REPLACE_ (.D(D), .C(C), .E(E), .Q(Q)); endmodule

module  \\$_DFF_PP0_ (input D, C, R, output Q); \\$__FF_ASYNCLSR #(0)  _TECHMAP_REPLACE_ (.D(D), .C(C), .R(R), .E(1'b1), .Q(Q)); endmodule
module  \\$_DFF_PP1_ (input D, C, R, output Q); \\$__FF_ASYNCLSR #(1)  _TECHMAP_REPLACE_ (.D(D), .C(C), .R(R), .E(1'b1), .Q(Q)); endmodule

module  \\$_SDFF_PP0_ (input D, C, R, output Q); \\$__FF_SYNCLSR #(0)  _TECHMAP_REPLACE_ (.D(D), .C(C), .R(R), .E(1'b1), .Q(Q)); endmodule
module  \\$_SDFF_PP1_ (input D, C, R, output Q); \\$__FF_SYNCLSR #(1)  _TECHMAP_REPLACE_ (.D(D), .C(C), .R(R), .E(1'b1), .Q(Q)); endmodule

module  \\$_DFFE_PP0P_ (input D, C, E, R, output Q); \\$__FF_ASYNCLSR #(0)  _TECHMAP_REPLACE_ (.D(D), .C(C), .R(R), .E(E), .Q(Q)); endmodule
module  \\$_DFFE_PP1P_ (input D, C, E, R, output Q); \\$__FF_ASYNCLSR #(1)  _TECHMAP_REPLACE_ (.D(D), .C(C), .R(R), .E(E), .Q(Q)); endmodule

module  \\$_SDFFE_PP0P_ (input D, C, E, R, output Q); \\$__FF_SYNCLSR #(0)  _TECHMAP_REPLACE_ (.D(D), .C(C), .R(R), .E(E), .Q(Q)); endmodule
module  \\$_SDFFE_PP1P_ (input D, C, E, R, output Q); \\$__FF_SYNCLSR #(1)  _TECHMAP_REPLACE_ (.D(D), .C(C), .R(R), .E(E), .Q(Q)); endmodule

\`ifndef NO_LUT
module \\$lut (A, Y);
	parameter WIDTH = 0;
	parameter LUT = 0;

	input [WIDTH-1:0] A;
	output Y;

	generate
		if (WIDTH == 1) begin
			if (LUT == 2'b01)
				INV _TECHMAP_REPLACE_ (.A(A[0]), .Z(Y));
			else
				LUT4 #(.INIT($sformatf("0x%04x", {{8{LUT[1]}}, {8{LUT[0]}}}))) _TECHMAP_REPLACE_ (.Z(Y),
					.D(A[0]));
		end else
		if (WIDTH == 2) begin
			localparam [15:0] INIT = {{4{LUT[3]}}, {4{LUT[2]}}, {4{LUT[1]}}, {4{LUT[0]}}};
			LUT4 #(.INIT($sformatf("0x%04x",  INIT))) _TECHMAP_REPLACE_ (.Z(Y),
				.C(A[0]), .D(A[1]));
		end else
		if (WIDTH == 3) begin
			localparam [15:0] INIT = {{2{LUT[7]}}, {2{LUT[6]}}, {2{LUT[5]}}, {2{LUT[4]}}, {2{LUT[3]}}, {2{LUT[2]}}, {2{LUT[1]}}, {2{LUT[0]}}};
			LUT4 #(.INIT($sformatf("0x%04x", INIT))) _TECHMAP_REPLACE_ (.Z(Y),
				.B(A[0]), .C(A[1]), .D(A[2]));
		end else
		if (WIDTH == 4) begin
			LUT4 #(.INIT($sformatf("0x%04x", LUT))) _TECHMAP_REPLACE_ (.Z(Y),
				.A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));
		end else
		if (WIDTH == 5) begin
			WIDEFN9 #(
				.INIT0($sformatf("0x%04x", LUT[15:0 ])),
				.INIT1($sformatf("0x%04x", LUT[31:16])),
			) _TECHMAP_REPLACE_ (
				.A0(A[0]), .B0(A[1]), .C0(A[2]), .D0(A[3]),
				.A1(A[0]), .B1(A[1]), .C1(A[2]), .D1(A[3]),
				.SEL(A[4]), .Z(Y)
			);
		end
	endgenerate
endmodule
\`endif
`,"cells_sim.v":`(* abc9_lut=1, lib_whitebox *)
module LUT4(input A, B, C, D, output Z);
	parameter INIT = "0x0000";
\`include "parse_init.vh"
	localparam initp = parse_init(INIT);
	wire [7:0] s3 = D ?     initp[15:8] :    initp[7:0];
	wire [3:0] s2 = C ?       s3[ 7:4]  :       s3[3:0];
	wire [1:0] s1 = B ?       s2[ 3:2]  :       s2[1:0];
	assign Z =      A ?          s1[1]  :         s1[0];

	// Per-input delay differences are considered 'interconnect'
	// so not known yet
	specify
		(A => Z) = 233;
		(B => Z) = 233;
		(C => Z) = 233;
		(D => Z) = 233;
	endspecify

endmodule

// This is a placeholder for ABC9 to extract the area/delay
//   cost of 5-input LUTs and is not intended to be instantiated
(* abc9_lut=2 *)
module \\$__ABC9_LUT5 (input SEL, D, C, B, A, output Z);
	specify
		(SEL => Z) = 171;
		(D => Z) = 303;
		(C => Z) = 311;
		(B => Z) = 309;
		(A => Z) = 306;
	endspecify
endmodule

// Two LUT4s and MUX2
module WIDEFN9(input A0, B0, C0, D0, A1, B1, C1, D1, SEL, output Z);
	parameter INIT0 = "0x0000";
	parameter INIT1 = "0x0000";
	wire z0, z1;
	LUT4 #(.INIT(INIT0)) lut4_0 (.A(A0), .B(B0), .C(C0), .D(D0), .Z(z0));
	LUT4 #(.INIT(INIT1)) lut4_1 (.A(A1), .B(B1), .C(C1), .D(D1), .Z(z1));
	assign Z = SEL ? z1 : z0;
endmodule

(* abc9_box, lib_whitebox *)
module INV(input A, output Z);
	assign Z = !A;

	specify
		(A => Z) = 10;
	endspecify
endmodule

// Bidirectional IO buffer
module BB(input T, I, output O,
	(* iopad_external_pin *) inout B);
	assign B = T ? 1'bz : I;
	assign O = B;
endmodule

// Input buffer
module IB(
	(* iopad_external_pin *) input I,
	output O);
	assign O = I;
endmodule

// Output buffer
module OB(input I,
	(* iopad_external_pin *) output O);
	assign O = I;
endmodule

// Output buffer with tristate
module OBZ(input I, T,
	(* iopad_external_pin *) output O);
	assign O = T ? 1'bz : I;
endmodule

// Constants
module VLO(output Z);
	assign Z = 1'b0;
endmodule

module VHI(output Z);
	assign Z = 1'b1;
endmodule

// Vendor flipflops
// (all have active high clock, enable and set/reset - use INV to invert)

// Async preset
(* abc9_box, lib_whitebox *)
module FD1P3BX(input D, CK, SP, PD, output reg Q);
	parameter GSR = "DISABLED";
	initial Q = 1'b1;
	always @(posedge CK or posedge PD)
		if (PD)
			Q <= 1'b1;
		else if (SP)
			Q <= D;
	specify
		$setup(D, posedge CK, 0);
		$setup(SP, posedge CK, 212);
		$setup(PD, posedge CK, 224);
\`ifndef YOSYS
		if (PD) (posedge CLK => (Q : 1)) = 0;
\`else
		if (PD) (PD => Q) = 0; 	// Technically, this should be an edge sensitive path
								// but for facilitating a bypass box, let's pretend it's
								// a simple path
\`endif
		if (!PD && SP) (posedge CK => (Q : D)) = 336;
	endspecify
endmodule

// Async clear
(* abc9_box, lib_whitebox *)
module FD1P3DX(input D, CK, SP, CD, output reg Q);
	parameter GSR = "DISABLED";
	initial Q = 1'b0;
	always @(posedge CK or posedge CD)
		if (CD)
			Q <= 1'b0;
		else if (SP)
			Q <= D;
	specify
		$setup(D, posedge CK, 0);
		$setup(SP, posedge CK, 212);
		$setup(CD, posedge CK, 224);
\`ifndef YOSYS
		if (CD) (posedge CLK => (Q : 0)) = 0;
\`else
		if (CD) (CD => Q) = 0; 	// Technically, this should be an edge sensitive path
								// but for facilitating a bypass box, let's pretend it's
								// a simple path
\`endif
		if (!CD && SP) (posedge CK => (Q : D)) = 336;
	endspecify
endmodule

// Sync clear
(* abc9_flop, lib_whitebox *)
module FD1P3IX(input D, CK, SP, CD, output reg Q);
	parameter GSR = "DISABLED";
	initial Q = 1'b0;
	always @(posedge CK)
		if (CD)
			Q <= 1'b0;
		else if (SP)
			Q <= D;
	specify
		$setup(D, posedge CK, 0);
		$setup(SP, posedge CK, 212);
		$setup(CD, posedge CK, 224);
		if (!CD && SP) (posedge CK => (Q : D)) = 336;
	endspecify
endmodule

// Sync preset
(* abc9_flop, lib_whitebox *)
module FD1P3JX(input D, CK, SP, PD, output reg Q);
	parameter GSR = "DISABLED";
	initial Q = 1'b1;
	always @(posedge CK)
		if (PD)
			Q <= 1'b1;
		else if (SP)
			Q <= D;
	specify
		$setup(D, posedge CK, 0);
		$setup(SP, posedge CK, 212);
		$setup(PD, posedge CK, 224);
		if (!PD && SP) (posedge CK => (Q : D)) = 336;
	endspecify
endmodule

// LUT4 with LUT3 tap for CCU2 use only
(* lib_whitebox *)
module LUT4_3(input A, B, C, D, output Z, Z3);
	parameter INIT = "0x0000";
\`include "parse_init.vh"
	localparam initp = parse_init(INIT);
	wire [7:0] s3 = D ?     initp[15:8] :     initp[7:0];
	wire [3:0] s2 = C ?        s3[ 7:4] :        s3[3:0];
	wire [1:0] s1 = B ?        s2[ 3:2] :        s2[1:0];
	assign Z =      A ?           s1[1] :          s1[0];

	wire [3:0] s2_3 = C ?   initp[ 7:4] :     initp[3:0];
	wire [1:0] s1_3 = B ?    s2_3[ 3:2] :      s2_3[1:0];
	assign Z3 =       A ?       s1_3[1] :        s1_3[0];

endmodule

// Carry primitive (incoporating two LUTs)
(* abc9_box, lib_whitebox *)
module CCU2(
	(* abc9_carry *) input CIN,
	input A1, B1, C1, D1, A0, B0, C0, D0,
	output S1, S0,
	(* abc9_carry *) output COUT);
	parameter INJECT = "YES";
	parameter INIT0 = "0x0000";
	parameter INIT1 = "0x1111";

	localparam inject_p = (INJECT == "YES") ? 1'b1 : 1'b0;

	wire LUT3_0, LUT4_0, LUT3_1, LUT4_1, carry_0;
	LUT4_3 #(.INIT(INIT0)) lut0 (.A(A0), .B(B0), .C(C0), .D(D0), .Z(LUT4_0), .Z3(LUT3_0));
	LUT4_3 #(.INIT(INIT1)) lut1 (.A(A1), .B(B1), .C(C1), .D(D1), .Z(LUT4_1), .Z3(LUT3_1));

	assign S0 = LUT4_0 ^ (CIN & ~inject_p);
	assign carry_0 = LUT4_0 ? CIN : (LUT3_0 & ~inject_p);
	assign S1 = LUT4_1 ^ (carry_0 & ~inject_p);
	assign COUT = LUT4_1 ? carry_0 : (LUT3_1 & ~inject_p);

	specify
		(A0 => S0) = 233;
		(B0 => S0) = 233;
		(C0 => S0) = 233;
		(D0 => S0) = 233;
		(CIN => S0) = 228;
		(A0 => S1) = 481;
		(B0 => S1) = 481;
		(C0 => S1) = 481;
		(D0 => S1) = 481;
		(A1 => S1) = 233;
		(B1 => S1) = 233;
		(C1 => S1) = 233;
		(D1 => S1) = 233;
		(CIN => S1) = 307;
		(A0 => COUT) = 347;
		(B0 => COUT) = 347;
		(C0 => COUT) = 347;
		(D0 => COUT) = 347;
		(A1 => COUT) = 347;
		(B1 => COUT) = 347;
		(C1 => COUT) = 347;
		(D1 => COUT) = 347;
		(CIN => COUT) = 59;
	endspecify

endmodule

// Packed flipflop
module OXIDE_FF(input CLK, LSR, CE, DI, M, output reg Q);
	parameter GSR = "ENABLED";
	parameter [127:0] CEMUX = "1";
	parameter CLKMUX = "CLK";
	parameter LSRMUX = "LSR";
	parameter REGDDR = "DISABLED";
	parameter SRMODE = "LSR_OVER_CE";
	parameter REGSET = "RESET";
	parameter [127:0] LSRMODE = "LSR";

	wire muxce;
	generate
		case (CEMUX)
			"1": assign muxce = 1'b1;
			"0": assign muxce = 1'b0;
			"INV": assign muxce = ~CE;
			default: assign muxce = CE;
		endcase
	endgenerate

	wire muxlsr = (LSRMUX == "INV") ? ~LSR : LSR;
	wire muxclk = (CLKMUX == "INV") ? ~CLK : CLK;
	wire srval;
	generate
		if (LSRMODE == "PRLD")
			assign srval = M;
		else
			assign srval = (REGSET == "SET") ? 1'b1 : 1'b0;
	endgenerate

	initial Q = srval;

	generate
		if (REGDDR == "ENABLED") begin
			if (SRMODE == "ASYNC") begin
				always @(posedge muxclk, negedge muxclk, posedge muxlsr)
					if (muxlsr)
						Q <= srval;
					else if (muxce)
						Q <= DI;
			end else begin
				always @(posedge muxclk, negedge muxclk)
					if (muxlsr)
						Q <= srval;
					else if (muxce)
						Q <= DI;
			end
		end else begin
			if (SRMODE == "ASYNC") begin
				always @(posedge muxclk, posedge muxlsr)
					if (muxlsr)
						Q <= srval;
					else if (muxce)
						Q <= DI;
			end else begin
				always @(posedge muxclk)
					if (muxlsr)
						Q <= srval;
					else if (muxce)
						Q <= DI;
			end
		end
	endgenerate
endmodule

// Packed combinational logic (for post-pnr sim)
module OXIDE_COMB(
	input A, B, C, D, // LUT inputs
	input SEL, // mux select input
	input F1, // output from LUT 1 for mux
	input FCI, // carry input
	input WAD0, WAD1, WAD2, WAD3, // LUTRAM write address inputs
	input WD, // LUTRAM write data input
	input WCK, WRE, // LUTRAM write clock and enable
	output F, // LUT/carry output
	output OFX // mux output
);
	parameter MODE = "LOGIC"; // LOGIC, CCU2, DPRAM
	parameter [15:0] INIT = 16'h0000;
	parameter INJECT = "YES";

	localparam inject_p = (INJECT == "YES") ? 1'b1 : 1'b0;

	reg [15:0] lut = INIT;

	wire [7:0] s3 = D ?     INIT[15:8] :     INIT[7:0];
	wire [3:0] s2 = C ?       s3[ 7:4] :       s3[3:0];
	wire [1:0] s1 = B ?       s2[ 3:2] :       s2[1:0];
	wire Z =        A ?          s1[1] :         s1[0];

	wire [3:0] s2_3 = C ?   INIT[ 7:4] :     INIT[3:0];
	wire [1:0] s1_3 = B ?   s2_3[ 3:2] :     s2_3[1:0];
	wire Z3 =         A ?      s1_3[1] :       s1_3[0];

	generate
		if (MODE == "DPRAM") begin
			always @(posedge WCK)
				if (WRE)
					lut[{WAD3, WAD2, WAD1, WAD0}] <= WD;
		end
		if (MODE == "CCU2") begin
			assign F = Z ^ (FCI & ~inject_p);
			assign FCO = Z ? FCI : (Z3 & ~inject_p);
		end else begin
			assign F = Z;
		end
	endgenerate

	assign OFX = SEL ? F1 : F;

endmodule

// LUTRAM
module DPR16X4(
	input [3:0] RAD, DI, WAD,
	input WRE, WCK,
	output [3:0] DO
);
	parameter INITVAL = "0x0000000000000000";
\`include "parse_init.vh"
	localparam [63:0] parsed_init = parse_init_64(INITVAL);

	reg [3:0] mem[0:15];
	integer i;
	initial begin
		for (i = 0; i < 15; i++)
			mem[i] = parsed_init[i * 4 +: 4];
	end

	always @(posedge WCK)
		if (WRE)
			mem[WAD] <= DI;
	assign DO = mem[RAD];
endmodule

// Used for all the DSP models to reduce duplication
module OXIDE_DSP_REG #(
	parameter W = 18,
	parameter USED = "REGISTER",
	parameter RESETMODE = "SYNC"
) (
	input CLK, CE, RST,
	input [W-1:0] D,
	output reg [W-1:0] Q
);
	generate
		if (USED == "BYPASS")
			always @* Q = D;
		else if (USED == "REGISTER") begin
			initial Q = 0;
			if (RESETMODE == "ASYNC")
				always @(posedge CLK, posedge RST) begin
					if (RST)
						Q <= 0;
					else if (CE)
						Q <= D;
				end
			else if (RESETMODE == "SYNC")
				always @(posedge CLK) begin
					if (RST)
						Q <= 0;
					else if (CE)
						Q <= D;
				end
		end
	endgenerate
endmodule

module OXIDE_DSP_SIM #(
	// User facing parameters
	parameter REGINPUTA = "BYPASS",
	parameter REGINPUTB = "BYPASS",
	parameter REGINPUTC = "BYPASS",
	parameter REGADDSUB = "BYPASS",
	parameter REGLOADC = "BYPASS",
	parameter REGLOADC2 = "BYPASS",
	parameter REGCIN = "BYPASS",
	parameter REGPIPELINE = "BYPASS",
	parameter REGOUTPUT = "BYPASS",
	parameter GSR = "ENABLED",
	parameter RESETMODE = "SYNC",
	// Internally used parameters
	parameter A_WIDTH = 36,
	parameter B_WIDTH = 36,
	parameter C_WIDTH = 36,
	parameter Z_WIDTH = 72,
	parameter PREADD_USED = 0,
	parameter ADDSUB_USED = 0
) (
	input [A_WIDTH-1:0] A,
	input [B_WIDTH-1:0] B,
	input [C_WIDTH-1:0] C,
	input SIGNEDA,
	input SIGNEDB,
	input SIGNEDC,
	input CIN,
	input LOADC,
	input ADDSUB,
	input CLK,
	input CEA, CEB, CEC, CEPIPE, CECTRL, CECIN, CEOUT,
	input RSTA, RSTB, RSTC, RSTPIPE, RSTCTRL, RSTCIN, RSTOUT,
	output wire [Z_WIDTH-1:0] Z
);
	
	localparam M_WIDTH = (A_WIDTH+B_WIDTH);

	/******** REGISTERS ********/

	wire [M_WIDTH-1:0] pipe_d, pipe_q;
	wire [Z_WIDTH-1:0] z_d;

	wire [A_WIDTH-1:0] a_r;
	wire [B_WIDTH-1:0] b_r;
	wire [C_WIDTH-1:0] c_r, c_r2;
	wire asgd_r, bsgd_r, csgd_r, csgd_r2;

	wire addsub_r, addsub_r2, cin_r, cin_r2, sgd_r, sgd_r2;
	wire loadc_r, loadc_r2;

	OXIDE_DSP_REG #(A_WIDTH+1, REGINPUTA, RESETMODE) a_reg(CLK, CEA, RSTA, {SIGNEDA, A}, {asgd_r, a_r});
	OXIDE_DSP_REG #(B_WIDTH+1, REGINPUTB, RESETMODE) b_reg(CLK, CEB, RSTB, {SIGNEDB, B}, {bsgd_r, b_r});
	OXIDE_DSP_REG #(C_WIDTH+1, REGINPUTC, RESETMODE) c_reg(CLK, CEC, RSTC, {SIGNEDC, C}, {csgd_r, c_r});

	OXIDE_DSP_REG #(M_WIDTH, REGPIPELINE, RESETMODE) pipe_reg(CLK, CEPIPE, RSTPIPE, pipe_d, pipe_q);

	OXIDE_DSP_REG #(2, REGADDSUB, RESETMODE) addsub_reg(CLK, CECTRL, RSTCTRL, {SIGNEDA, ADDSUB}, {sgd_r, addsub_r});
	OXIDE_DSP_REG #(1, REGLOADC, RESETMODE) loadc_reg(CLK, CECTRL, RSTCTRL, LOADC, loadc_r);
	OXIDE_DSP_REG #(2, REGPIPELINE, RESETMODE) addsub2_reg(CLK, CECTRL, RSTCTRL, {sgd_r, addsub_r}, {sgd_r2, addsub_r2});
	OXIDE_DSP_REG #(1, REGLOADC2, RESETMODE) loadc2_reg(CLK, CECTRL, RSTCTRL, loadc_r, loadc_r2);

	OXIDE_DSP_REG #(1, REGCIN, RESETMODE) cin_reg(CLK, CECIN, RSTCIN, CIN, cin_r);
	OXIDE_DSP_REG #(1, REGPIPELINE, RESETMODE) cin2_reg(CLK, CECIN, RSTCIN, cin_r, cin_r2);

	OXIDE_DSP_REG #(C_WIDTH+1, REGPIPELINE, RESETMODE) c2_reg(CLK, CEC, RSTC, {csgd_r, c_r}, {csgd_r2, c_r2});

	OXIDE_DSP_REG #(Z_WIDTH, REGOUTPUT, RESETMODE) z_reg(CLK, CEOUT, RSTOUT, z_d, Z);

	/******** PREADDER ********/

	wire [B_WIDTH-1:0] mult_b;
	wire mult_b_sgd;

	generate
		if (PREADD_USED) begin
			assign mult_b = (b_r + c_r);
			assign mult_b_sgd = (bsgd_r | csgd_r);
		end else begin
			assign mult_b = b_r;
			assign mult_b_sgd = bsgd_r;
		end
	endgenerate

	/******** MULTIPLIER ********/

	// sign extend operands if needed
	wire [M_WIDTH-1:0] mult_a_ext = {{(M_WIDTH-A_WIDTH){asgd_r ? a_r[A_WIDTH-1] : 1'b0}}, a_r};
	wire [M_WIDTH-1:0] mult_b_ext = {{(M_WIDTH-B_WIDTH){mult_b_sgd ? mult_b[B_WIDTH-1] : 1'b0}}, mult_b};

	wire [M_WIDTH-1:0] mult_m = mult_a_ext * mult_b_ext;

	/******** ACCUMULATOR ********/

	wire [Z_WIDTH-1:0] m_ext;

	generate
		if (ADDSUB_USED) begin
			assign pipe_d = mult_m;
			assign m_ext = {{(Z_WIDTH-M_WIDTH){sgd_r2 ? pipe_q[M_WIDTH-1] : 1'b0}}, pipe_q};
			assign z_d = (loadc_r2 ? c_r2 : Z) + cin_r2 + (addsub_r2 ? -m_ext : m_ext);  
		end else begin
			assign z_d = mult_m;
		end
	endgenerate


endmodule

module MULT9X9 #(
	parameter REGINPUTA = "REGISTER",
	parameter REGINPUTB = "REGISTER",
	parameter REGOUTPUT = "REGISTER",
	parameter GSR = "ENABLED",
	parameter RESETMODE = "SYNC"
) (
	input [8:0] A,
	input [8:0] B,
	input CLK,
	input CEA,
	input RSTA,
	input CEB,
	input RSTB,
	input SIGNEDA,
	input SIGNEDB,
	input RSTOUT,
	input CEOUT,
	output [17:0] Z
);
	OXIDE_DSP_SIM #(
		.REGINPUTA(REGINPUTA),
		.REGINPUTB(REGINPUTB),
		.REGOUTPUT(REGOUTPUT),
		.GSR(GSR),
		.RESETMODE(RESETMODE),

		.A_WIDTH(9),
		.B_WIDTH(9),
		.Z_WIDTH(18),
		.PREADD_USED(0),
		.ADDSUB_USED(0)
	) dsp_i (
		.A(A), .B(B),
		.CLK(CLK),
		.CEA(CEA), .RSTA(RSTA),
		.CEB(CEB), .RSTB(RSTB),
		.SIGNEDA(SIGNEDA), .SIGNEDB(SIGNEDB),
		.RSTOUT(RSTOUT), .CEOUT(CEOUT),
		.Z(Z)
	);
endmodule

module MULT18X18 #(
	parameter REGINPUTA = "REGISTER",
	parameter REGINPUTB = "REGISTER",
	parameter REGOUTPUT = "REGISTER",
	parameter GSR = "ENABLED",
	parameter RESETMODE = "SYNC"
) (
	input [17:0] A,
	input [17:0] B,
	input CLK,
	input CEA,
	input RSTA,
	input CEB,
	input RSTB,
	input SIGNEDA,
	input SIGNEDB,
	input RSTOUT,
	input CEOUT,
	output [35:0] Z
);
	OXIDE_DSP_SIM #(
		.REGINPUTA(REGINPUTA),
		.REGINPUTB(REGINPUTB),
		.REGOUTPUT(REGOUTPUT),
		.GSR(GSR),
		.RESETMODE(RESETMODE),

		.A_WIDTH(18),
		.B_WIDTH(18),
		.Z_WIDTH(36),
		.PREADD_USED(0),
		.ADDSUB_USED(0)
	) dsp_i (
		.A(A), .B(B),
		.CLK(CLK),
		.CEA(CEA), .RSTA(RSTA),
		.CEB(CEB), .RSTB(RSTB),
		.SIGNEDA(SIGNEDA), .SIGNEDB(SIGNEDB),
		.RSTOUT(RSTOUT), .CEOUT(CEOUT),
		.Z(Z)
	);
endmodule

module MULT18X36 #(
	parameter REGINPUTA = "REGISTER",
	parameter REGINPUTB = "REGISTER",
	parameter REGOUTPUT = "REGISTER",
	parameter GSR = "ENABLED",
	parameter RESETMODE = "SYNC"
) (
	input [17:0] A,
	input [35:0] B,
	input CLK,
	input CEA,
	input RSTA,
	input CEB,
	input RSTB,
	input SIGNEDA,
	input SIGNEDB,
	input RSTOUT,
	input CEOUT,
	output [53:0] Z
);
	OXIDE_DSP_SIM #(
		.REGINPUTA(REGINPUTA),
		.REGINPUTB(REGINPUTB),
		.REGOUTPUT(REGOUTPUT),
		.GSR(GSR),
		.RESETMODE(RESETMODE),

		.A_WIDTH(18),
		.B_WIDTH(36),
		.Z_WIDTH(54),
		.PREADD_USED(0),
		.ADDSUB_USED(0)
	) dsp_i (
		.A(A), .B(B),
		.CLK(CLK),
		.CEA(CEA), .RSTA(RSTA),
		.CEB(CEB), .RSTB(RSTB),
		.SIGNEDA(SIGNEDA), .SIGNEDB(SIGNEDB),
		.RSTOUT(RSTOUT), .CEOUT(CEOUT),
		.Z(Z)
	);
endmodule

module MULT36X36 #(
	parameter REGINPUTA = "REGISTER",
	parameter REGINPUTB = "REGISTER",
	parameter REGOUTPUT = "REGISTER",
	parameter GSR = "ENABLED",
	parameter RESETMODE = "SYNC"
) (
	input [35:0] A,
	input [35:0] B,
	input CLK,
	input CEA,
	input RSTA,
	input CEB,
	input RSTB,
	input SIGNEDA,
	input SIGNEDB,
	input RSTOUT,
	input CEOUT,
	output [71:0] Z
);
	OXIDE_DSP_SIM #(
		.REGINPUTA(REGINPUTA),
		.REGINPUTB(REGINPUTB),
		.REGOUTPUT(REGOUTPUT),
		.GSR(GSR),
		.RESETMODE(RESETMODE),

		.A_WIDTH(36),
		.B_WIDTH(36),
		.Z_WIDTH(72),
		.PREADD_USED(0),
		.ADDSUB_USED(0)
	) dsp_i (
		.A(A), .B(B),
		.CLK(CLK),
		.CEA(CEA), .RSTA(RSTA),
		.CEB(CEB), .RSTB(RSTB),
		.SIGNEDA(SIGNEDA), .SIGNEDB(SIGNEDB),
		.RSTOUT(RSTOUT), .CEOUT(CEOUT),
		.Z(Z)
	);
endmodule


module MULTPREADD9X9 #(
	parameter REGINPUTA = "REGISTER",
	parameter REGINPUTB = "REGISTER",
	parameter REGINPUTC = "REGISTER",
	parameter REGOUTPUT = "REGISTER",
	parameter GSR = "ENABLED",
	parameter RESETMODE = "SYNC"
) (
	input [8:0] A,
	input [8:0] B,
	input [8:0] C,
	input CLK,
	input CEA,
	input RSTA,
	input CEB,
	input RSTB,
	input CEC,
	input RSTC,
	input SIGNEDA,
	input SIGNEDB,
	input SIGNEDC,
	input RSTOUT,
	input CEOUT,
	output [17:0] Z
);
	OXIDE_DSP_SIM #(
		.REGINPUTA(REGINPUTA),
		.REGINPUTB(REGINPUTB),
		.REGINPUTC(REGINPUTC),
		.REGOUTPUT(REGOUTPUT),
		.GSR(GSR),
		.RESETMODE(RESETMODE),

		.A_WIDTH(9),
		.B_WIDTH(9),
		.C_WIDTH(9),
		.Z_WIDTH(18),
		.PREADD_USED(1),
		.ADDSUB_USED(0)
	) dsp_i (
		.A(A), .B(B), .C(C),
		.CLK(CLK),
		.CEA(CEA), .RSTA(RSTA),
		.CEB(CEB), .RSTB(RSTB),
		.CEC(CEC), .RSTC(RSTC),
		.SIGNEDA(SIGNEDA), .SIGNEDB(SIGNEDB), .SIGNEDC(SIGNEDC),
		.RSTOUT(RSTOUT), .CEOUT(CEOUT),
		.Z(Z)
	);
endmodule


module MULTPREADD18X18 #(
	parameter REGINPUTA = "REGISTER",
	parameter REGINPUTB = "REGISTER",
	parameter REGINPUTC = "REGISTER",
	parameter REGOUTPUT = "REGISTER",
	parameter GSR = "ENABLED",
	parameter RESETMODE = "SYNC"
) (
	input [17:0] A,
	input [17:0] B,
	input [17:0] C,
	input CLK,
	input CEA,
	input RSTA,
	input CEB,
	input RSTB,
	input CEC,
	input RSTC,
	input SIGNEDA,
	input SIGNEDB,
	input SIGNEDC,
	input RSTOUT,
	input CEOUT,
	output [35:0] Z
);
	OXIDE_DSP_SIM #(
		.REGINPUTA(REGINPUTA),
		.REGINPUTB(REGINPUTB),
		.REGINPUTC(REGINPUTC),
		.REGOUTPUT(REGOUTPUT),
		.GSR(GSR),
		.RESETMODE(RESETMODE),

		.A_WIDTH(18),
		.B_WIDTH(18),
		.C_WIDTH(18),
		.Z_WIDTH(36),
		.PREADD_USED(1),
		.ADDSUB_USED(0)
	) dsp_i (
		.A(A), .B(B), .C(C),
		.CLK(CLK),
		.CEA(CEA), .RSTA(RSTA),
		.CEB(CEB), .RSTB(RSTB),
		.CEC(CEC), .RSTC(RSTC),
		.SIGNEDA(SIGNEDA), .SIGNEDB(SIGNEDB), .SIGNEDC(SIGNEDC),
		.RSTOUT(RSTOUT), .CEOUT(CEOUT),
		.Z(Z)
	);
endmodule


module MULTADDSUB18X18 #(
	parameter REGINPUTA = "REGISTER",
	parameter REGINPUTB = "REGISTER",
	parameter REGINPUTC = "REGISTER",
	parameter REGADDSUB = "REGISTER",
	parameter REGLOADC = "REGISTER",
	parameter REGLOADC2 = "REGISTER",
	parameter REGCIN = "REGISTER",
	parameter REGPIPELINE = "REGISTER",
	parameter REGOUTPUT = "REGISTER",
	parameter GSR = "ENABLED",
	parameter RESETMODE = "SYNC"
) (
	input [17:0] A,
	input [17:0] B,
	input [53:0] C,
    input CLK,
    input CEA,
    input RSTA,
    input CEB,
    input RSTB,
    input CEC,
    input RSTC,
    input SIGNED,
    input RSTPIPE,
    input CEPIPE,
    input RSTCTRL,
    input CECTRL,
    input RSTCIN,
    input CECIN,
    input LOADC,
    input ADDSUB,
    output [53:0] Z,
    input RSTOUT,
    input CEOUT,
    input CIN
);
	OXIDE_DSP_SIM #(
		.REGINPUTA(REGINPUTA),
		.REGINPUTB(REGINPUTB),
		.REGINPUTC(REGINPUTC),
		.REGADDSUB(REGADDSUB),
		.REGLOADC(REGLOADC),
		.REGLOADC2(REGLOADC2),
		.REGCIN(REGCIN),
		.REGPIPELINE(REGPIPELINE),
		.REGOUTPUT(REGOUTPUT),
		.GSR(GSR),
		.RESETMODE(RESETMODE),

		.A_WIDTH(18),
		.B_WIDTH(18),
		.C_WIDTH(54),
		.Z_WIDTH(54),
		.PREADD_USED(0),
		.ADDSUB_USED(1)
	) dsp_i (
		.A(A), .B(B), .C(C),
		.CLK(CLK),
		.CEA(CEA), .RSTA(RSTA),
		.CEB(CEB), .RSTB(RSTB),
		.CEC(CEC), .RSTC(RSTC),
		.CEPIPE(CEPIPE), .RSTPIPE(RSTPIPE),
		.CECTRL(CECTRL), .RSTCTRL(RSTCTRL),
		.CECIN(CECIN), .RSTCIN(RSTCIN),
		.CIN(CIN), .LOADC(LOADC), .ADDSUB(ADDSUB),
		.SIGNEDA(SIGNED), .SIGNEDB(SIGNED), .SIGNEDC(SIGNED),
		.RSTOUT(RSTOUT), .CEOUT(CEOUT),
		.Z(Z)
	);
endmodule


module MULTADDSUB36X36 #(
	parameter REGINPUTA = "REGISTER",
	parameter REGINPUTB = "REGISTER",
	parameter REGINPUTC = "REGISTER",
	parameter REGADDSUB = "REGISTER",
	parameter REGLOADC = "REGISTER",
	parameter REGLOADC2 = "REGISTER",
	parameter REGCIN = "REGISTER",
	parameter REGPIPELINE = "REGISTER",
	parameter REGOUTPUT = "REGISTER",
	parameter GSR = "ENABLED",
	parameter RESETMODE = "SYNC"
) (
	input [35:0] A,
	input [35:0] B,
	input [107:0] C,
    input CLK,
    input CEA,
    input RSTA,
    input CEB,
    input RSTB,
    input CEC,
    input RSTC,
    input SIGNED,
    input RSTPIPE,
    input CEPIPE,
    input RSTCTRL,
    input CECTRL,
    input RSTCIN,
    input CECIN,
    input LOADC,
    input ADDSUB,
    output [107:0] Z,
    input RSTOUT,
    input CEOUT,
    input CIN
);
	OXIDE_DSP_SIM #(
		.REGINPUTA(REGINPUTA),
		.REGINPUTB(REGINPUTB),
		.REGINPUTC(REGINPUTC),
		.REGADDSUB(REGADDSUB),
		.REGLOADC(REGLOADC),
		.REGLOADC2(REGLOADC2),
		.REGCIN(REGCIN),
		.REGPIPELINE(REGPIPELINE),
		.REGOUTPUT(REGOUTPUT),
		.GSR(GSR),
		.RESETMODE(RESETMODE),

		.A_WIDTH(36),
		.B_WIDTH(36),
		.C_WIDTH(108),
		.Z_WIDTH(108),
		.PREADD_USED(0),
		.ADDSUB_USED(1)
	) dsp_i (
		.A(A), .B(B), .C(C),
		.CLK(CLK),
		.CEA(CEA), .RSTA(RSTA),
		.CEB(CEB), .RSTB(RSTB),
		.CEC(CEC), .RSTC(RSTC),
		.CEPIPE(CEPIPE), .RSTPIPE(RSTPIPE),
		.CECTRL(CECTRL), .RSTCTRL(RSTCTRL),
		.CECIN(CECIN), .RSTCIN(RSTCIN),
		.CIN(CIN), .LOADC(LOADC), .ADDSUB(ADDSUB),
		.SIGNEDA(SIGNED), .SIGNEDB(SIGNED), .SIGNEDC(SIGNED),
		.RSTOUT(RSTOUT), .CEOUT(CEOUT),
		.Z(Z)
	);
endmodule

module MULTADDSUB9X9WIDE #(
	parameter REGINPUTAB0 = "REGISTER",
	parameter REGINPUTAB1 = "REGISTER",
	parameter REGINPUTAB2 = "REGISTER",
	parameter REGINPUTAB3 = "REGISTER",
	parameter REGINPUTC = "REGISTER",
	parameter REGADDSUB = "REGISTER",
	parameter REGLOADC = "REGISTER",
	parameter REGLOADC2 = "REGISTER",
	parameter REGPIPELINE = "REGISTER",
	parameter REGOUTPUT = "REGISTER",
	parameter GSR = "ENABLED",
	parameter RESETMODE = "SYNC"
) (
	input [8:0] A0, B0, A1, B1, A2, B2, A3, B3,
	input [53:0] C,
	input CLK,
	input CEA0A1, CEA2A3,
	input RSTA0A1, RSTA2A3,
	input CEB0B1, CEB2B3,
	input RSTB0B1, RSTB2B3,
	input CEC, RSTC,
	input CECTRL, RSTCTRL,
	input SIGNED,
	input RSTPIPE, CEPIPE,
	input RSTOUT, CEOUT,
	input LOADC,
	input [3:0] ADDSUB,
	output [53:0] Z
);
	wire [17:0] m0, m1, m2, m3;

	localparam M_WIDTH = 18;
	localparam Z_WIDTH = 54;

	MULT9X9 #(
		.REGINPUTA(REGINPUTAB0), .REGINPUTB(REGINPUTAB0), .REGOUTPUT(REGPIPELINE), .GSR(GSR), .RESETMODE(RESETMODE)
	) m9_0 (
		.A(A0), .B(B0), .SIGNEDA(SIGNED), .SIGNEDB(SIGNED),
		.CLK(CLK),
		.CEA(CEA0A1), .RSTA(RSTA0A1),
		.CEB(CEB0B1), .RSTB(RSTB0B1),
		.CEOUT(CEPIPE), .RSTOUT(RSTPIPE),
		.Z(m0)
	);
	MULT9X9 #(
		.REGINPUTA(REGINPUTAB1), .REGINPUTB(REGINPUTAB1), .REGOUTPUT(REGPIPELINE), .GSR(GSR), .RESETMODE(RESETMODE)
	) m9_1 (
		.A(A1), .B(B1), .SIGNEDA(SIGNED), .SIGNEDB(SIGNED),
		.CLK(CLK),
		.CEA(CEA0A1), .RSTA(RSTA0A1),
		.CEB(CEB0B1), .RSTB(RSTB0B1),
		.CEOUT(CEPIPE), .RSTOUT(RSTPIPE),
		.Z(m1)
	);
	MULT9X9 #(
		.REGINPUTA(REGINPUTAB2), .REGINPUTB(REGINPUTAB2), .REGOUTPUT(REGPIPELINE), .GSR(GSR), .RESETMODE(RESETMODE)
	) m9_2 (
		.A(A2), .B(B2), .SIGNEDA(SIGNED), .SIGNEDB(SIGNED),
		.CLK(CLK),
		.CEA(CEA2A3), .RSTA(RSTA2A3),
		.CEB(CEB2B3), .RSTB(RSTB2B3),
		.CEOUT(CEPIPE), .RSTOUT(RSTPIPE),
		.Z(m2)
	);
	MULT9X9 #(
		.REGINPUTA(REGINPUTAB3), .REGINPUTB(REGINPUTAB3), .REGOUTPUT(REGPIPELINE), .GSR(GSR), .RESETMODE(RESETMODE)
	) m9_3 (
		.A(A3), .B(B3), .SIGNEDA(SIGNED), .SIGNEDB(SIGNED),
		.CLK(CLK),
		.CEA(CEA2A3), .RSTA(RSTA2A3),
		.CEB(CEB2B3), .RSTB(RSTB2B3),
		.CEOUT(CEPIPE), .RSTOUT(RSTPIPE),
		.Z(m3)
	);

	wire [53:0] c_r, c_r2;
	wire [3:0] addsub_r, addsub_r2;
	wire sgd_r, sgd_r2, csgd_r, csgd_r2;
	wire loadc_r, loadc_r2;

	OXIDE_DSP_REG #(5, REGADDSUB, RESETMODE) addsub_reg(CLK, CECTRL, RSTCTRL, {SIGNED, ADDSUB}, {sgd_r, addsub_r});
	OXIDE_DSP_REG #(5, REGADDSUB, RESETMODE) addsub2_reg(CLK, CECTRL, RSTCTRL, {sgd_r, addsub_r}, {sgd_r2, addsub_r2});

	OXIDE_DSP_REG #(1, REGLOADC, RESETMODE) loadc_reg(CLK, CECTRL, RSTCTRL, LOADC, loadc_r);
	OXIDE_DSP_REG #(1, REGLOADC2, RESETMODE) loadc2_reg(CLK, CECTRL, RSTCTRL, loadc_r, loadc_r2);

	OXIDE_DSP_REG #(55, REGINPUTC, RESETMODE) c_reg(CLK, CEC, RSTC, {SIGNED, C}, {csgd_r, c_r});
	OXIDE_DSP_REG #(55, REGPIPELINE, RESETMODE) c2_reg(CLK, CEC, RSTC, {csgd_r, c_r}, {csgd_r2, c_r2});


	wire [18:0] m0_ext, m1_ext, m2_ext, m3_ext;

	assign m0_ext = {sgd_r2 ? m0[M_WIDTH-1] : 1'b0, m0};
	assign m1_ext = {sgd_r2 ? m1[M_WIDTH-1] : 1'b0, m1};
	assign m2_ext = {sgd_r2 ? m2[M_WIDTH-1] : 1'b0, m2};
	assign m3_ext = {sgd_r2 ? m3[M_WIDTH-1] : 1'b0, m3};

	wire [18:0] s0 = addsub_r2[2] ? (m0_ext - m1_ext) : (m0_ext + m1_ext);
	wire [18:0] s1 = addsub_r2[3] ? (m2_ext - m3_ext) : (m2_ext + m3_ext);

	wire [53:0] s0_ext = {{(54-19){sgd_r2 ? s0[18] : 1'b0}}, s0};
	wire [53:0] s1_ext = {{(54-19){sgd_r2 ? s1[18] : 1'b0}}, s1};

	wire [53:0] c_op = loadc_r2 ? c_r2 : Z;

	// The diagram in the docs is wrong! It is not two cascaded 2-input add/subs as shown,
	// but a three-input unit with negation controls on two inputs (i.e. addsub_r2[0]
	// negates s1 not (s1 +/- s0))
	wire [53:0] z_d =  c_op + (addsub_r2[0] ? -s1_ext : s1_ext) + (addsub_r2[1] ? -s0_ext : s0_ext);

	OXIDE_DSP_REG #(Z_WIDTH, REGOUTPUT, RESETMODE) z_reg(CLK, CEOUT, RSTOUT, z_d, Z);

endmodule
`,"cells_xtra.v":new URL("./cells_xtra-e485fadd.v?hash=e485fadd",import.meta.url),"dsp_map.v":`module \\$__NX_MUL36X36 (input [35:0] A, input [35:0] B, output [71:0] Y);

	parameter A_WIDTH = 36;
	parameter B_WIDTH = 36;
	parameter Y_WIDTH = 72;
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;

	MULT36X36 #(
		.REGINPUTA("BYPASS"),
		.REGINPUTB("BYPASS"),
		.REGOUTPUT("BYPASS")
	) _TECHMAP_REPLACE_ (
		.A(A), .B(B),
		.SIGNEDA(A_SIGNED ? 1'b1 : 1'b0),
		.SIGNEDB(B_SIGNED ? 1'b1 : 1'b0),
		.Z(Y)
	);
endmodule

module \\$__NX_MUL36X18 (input [35:0] A, input [17:0] B, output [53:0] Y);

	parameter A_WIDTH = 36;
	parameter B_WIDTH = 18;
	parameter Y_WIDTH = 54;
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;

	MULT18X36 #(
		.REGINPUTA("BYPASS"),
		.REGINPUTB("BYPASS"),
		.REGOUTPUT("BYPASS")
	) _TECHMAP_REPLACE_ (
		.A(B), .B(A),
		.SIGNEDA(B_SIGNED ? 1'b1 : 1'b0),
		.SIGNEDB(A_SIGNED ? 1'b1 : 1'b0),
		.Z(Y)
	);
endmodule

module \\$__NX_MUL18X18 (input [17:0] A, input [17:0] B, output [35:0] Y);

	parameter A_WIDTH = 18;
	parameter B_WIDTH = 18;
	parameter Y_WIDTH = 36;
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;

	MULT18X18 #(
		.REGINPUTA("BYPASS"),
		.REGINPUTB("BYPASS"),
		.REGOUTPUT("BYPASS")
	) _TECHMAP_REPLACE_ (
		.A(A), .B(B),
		.SIGNEDA(A_SIGNED ? 1'b1 : 1'b0),
		.SIGNEDB(B_SIGNED ? 1'b1 : 1'b0),
		.Z(Y)
	);
endmodule

module \\$__NX_MUL9X9 (input [8:0] A, input [8:0] B, output [17:0] Y);

	parameter A_WIDTH = 9;
	parameter B_WIDTH = 9;
	parameter Y_WIDTH = 18;
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;

	MULT9X9 #(
		.REGINPUTA("BYPASS"),
		.REGINPUTB("BYPASS"),
		.REGOUTPUT("BYPASS")
	) _TECHMAP_REPLACE_ (
		.A(A), .B(B),
		.SIGNEDA(A_SIGNED ? 1'b1 : 1'b0),
		.SIGNEDB(B_SIGNED ? 1'b1 : 1'b0),
		.Z(Y)
	);
endmodule
`,"latches_map.v":`module \\$_DLATCH_N_ (E, D, Q);
  wire [1023:0] _TECHMAP_DO_ = "simplemap; opt";
  input E, D;
  output Q = !E ? D : Q;
endmodule

module \\$_DLATCH_P_ (E, D, Q);
  wire [1023:0] _TECHMAP_DO_ = "simplemap; opt";
  input E, D;
  output Q = E ? D : Q;
endmodule
`,"lrams.txt":`ram huge $__NX_DPSC512K_ {
	abits 14;
	width 32;
	byte 8;
	cost 2048;
	init no_undef;
	port srsw "A" "B" {
		clock posedge "C";
		clken;
		wrbe_separate;
		rdwr no_change;
		option "RESETMODE" "SYNC" {
			rdsrst zero gated_clken;
		}
		option "RESETMODE" "ASYNC" {
			rdarst zero;
		}
		rdinit zero;
		wrtrans all old;
	}
}
`,"lrams_map.v":`module $__NX_DPSC512K_ (...);

parameter INIT = 0;
parameter OPTION_RESETMODE = "SYNC";

input CLK_C;

input PORT_A_CLK;
input PORT_A_CLK_EN;
input PORT_A_WR_EN;
input PORT_A_RD_SRST;
input PORT_A_RD_ARST;
input [13:0] PORT_A_ADDR;
input [3:0] PORT_A_WR_BE;
input [31:0] PORT_A_WR_DATA;
output [31:0] PORT_A_RD_DATA;

input PORT_B_CLK;
input PORT_B_CLK_EN;
input PORT_B_WR_EN;
input PORT_B_RD_SRST;
input PORT_B_RD_ARST;
input [13:0] PORT_B_ADDR;
input [3:0] PORT_B_WR_BE;
input [31:0] PORT_B_WR_DATA;
output [31:0] PORT_B_RD_DATA;

function [5119:0] init_slice;
	input integer idx;
	integer i, j;
	init_slice = 0;
	for (i = 0; i < 128; i = i + 1) begin
		init_slice[i*40+:32] = INIT[(idx * 128 + i) * 32+:32];
	end
endfunction

DPSC512K #(
	.INITVAL_00($sformatf("0x%01280x", init_slice('h00))),
	.INITVAL_01($sformatf("0x%01280x", init_slice('h01))),
	.INITVAL_02($sformatf("0x%01280x", init_slice('h02))),
	.INITVAL_03($sformatf("0x%01280x", init_slice('h03))),
	.INITVAL_04($sformatf("0x%01280x", init_slice('h04))),
	.INITVAL_05($sformatf("0x%01280x", init_slice('h05))),
	.INITVAL_06($sformatf("0x%01280x", init_slice('h06))),
	.INITVAL_07($sformatf("0x%01280x", init_slice('h07))),
	.INITVAL_08($sformatf("0x%01280x", init_slice('h08))),
	.INITVAL_09($sformatf("0x%01280x", init_slice('h09))),
	.INITVAL_0A($sformatf("0x%01280x", init_slice('h0a))),
	.INITVAL_0B($sformatf("0x%01280x", init_slice('h0b))),
	.INITVAL_0C($sformatf("0x%01280x", init_slice('h0c))),
	.INITVAL_0D($sformatf("0x%01280x", init_slice('h0d))),
	.INITVAL_0E($sformatf("0x%01280x", init_slice('h0e))),
	.INITVAL_0F($sformatf("0x%01280x", init_slice('h0f))),
	.INITVAL_10($sformatf("0x%01280x", init_slice('h10))),
	.INITVAL_11($sformatf("0x%01280x", init_slice('h11))),
	.INITVAL_12($sformatf("0x%01280x", init_slice('h12))),
	.INITVAL_13($sformatf("0x%01280x", init_slice('h13))),
	.INITVAL_14($sformatf("0x%01280x", init_slice('h14))),
	.INITVAL_15($sformatf("0x%01280x", init_slice('h15))),
	.INITVAL_16($sformatf("0x%01280x", init_slice('h16))),
	.INITVAL_17($sformatf("0x%01280x", init_slice('h17))),
	.INITVAL_18($sformatf("0x%01280x", init_slice('h18))),
	.INITVAL_19($sformatf("0x%01280x", init_slice('h19))),
	.INITVAL_1A($sformatf("0x%01280x", init_slice('h1a))),
	.INITVAL_1B($sformatf("0x%01280x", init_slice('h1b))),
	.INITVAL_1C($sformatf("0x%01280x", init_slice('h1c))),
	.INITVAL_1D($sformatf("0x%01280x", init_slice('h1d))),
	.INITVAL_1E($sformatf("0x%01280x", init_slice('h1e))),
	.INITVAL_1F($sformatf("0x%01280x", init_slice('h1f))),
	.INITVAL_20($sformatf("0x%01280x", init_slice('h20))),
	.INITVAL_21($sformatf("0x%01280x", init_slice('h21))),
	.INITVAL_22($sformatf("0x%01280x", init_slice('h22))),
	.INITVAL_23($sformatf("0x%01280x", init_slice('h23))),
	.INITVAL_24($sformatf("0x%01280x", init_slice('h24))),
	.INITVAL_25($sformatf("0x%01280x", init_slice('h25))),
	.INITVAL_26($sformatf("0x%01280x", init_slice('h26))),
	.INITVAL_27($sformatf("0x%01280x", init_slice('h27))),
	.INITVAL_28($sformatf("0x%01280x", init_slice('h28))),
	.INITVAL_29($sformatf("0x%01280x", init_slice('h29))),
	.INITVAL_2A($sformatf("0x%01280x", init_slice('h2a))),
	.INITVAL_2B($sformatf("0x%01280x", init_slice('h2b))),
	.INITVAL_2C($sformatf("0x%01280x", init_slice('h2c))),
	.INITVAL_2D($sformatf("0x%01280x", init_slice('h2d))),
	.INITVAL_2E($sformatf("0x%01280x", init_slice('h2e))),
	.INITVAL_2F($sformatf("0x%01280x", init_slice('h2f))),
	.INITVAL_30($sformatf("0x%01280x", init_slice('h30))),
	.INITVAL_31($sformatf("0x%01280x", init_slice('h31))),
	.INITVAL_32($sformatf("0x%01280x", init_slice('h32))),
	.INITVAL_33($sformatf("0x%01280x", init_slice('h33))),
	.INITVAL_34($sformatf("0x%01280x", init_slice('h34))),
	.INITVAL_35($sformatf("0x%01280x", init_slice('h35))),
	.INITVAL_36($sformatf("0x%01280x", init_slice('h36))),
	.INITVAL_37($sformatf("0x%01280x", init_slice('h37))),
	.INITVAL_38($sformatf("0x%01280x", init_slice('h38))),
	.INITVAL_39($sformatf("0x%01280x", init_slice('h39))),
	.INITVAL_3A($sformatf("0x%01280x", init_slice('h3a))),
	.INITVAL_3B($sformatf("0x%01280x", init_slice('h3b))),
	.INITVAL_3C($sformatf("0x%01280x", init_slice('h3c))),
	.INITVAL_3D($sformatf("0x%01280x", init_slice('h3d))),
	.INITVAL_3E($sformatf("0x%01280x", init_slice('h3e))),
	.INITVAL_3F($sformatf("0x%01280x", init_slice('h3f))),
	.INITVAL_40($sformatf("0x%01280x", init_slice('h40))),
	.INITVAL_41($sformatf("0x%01280x", init_slice('h41))),
	.INITVAL_42($sformatf("0x%01280x", init_slice('h42))),
	.INITVAL_43($sformatf("0x%01280x", init_slice('h43))),
	.INITVAL_44($sformatf("0x%01280x", init_slice('h44))),
	.INITVAL_45($sformatf("0x%01280x", init_slice('h45))),
	.INITVAL_46($sformatf("0x%01280x", init_slice('h46))),
	.INITVAL_47($sformatf("0x%01280x", init_slice('h47))),
	.INITVAL_48($sformatf("0x%01280x", init_slice('h48))),
	.INITVAL_49($sformatf("0x%01280x", init_slice('h49))),
	.INITVAL_4A($sformatf("0x%01280x", init_slice('h4a))),
	.INITVAL_4B($sformatf("0x%01280x", init_slice('h4b))),
	.INITVAL_4C($sformatf("0x%01280x", init_slice('h4c))),
	.INITVAL_4D($sformatf("0x%01280x", init_slice('h4d))),
	.INITVAL_4E($sformatf("0x%01280x", init_slice('h4e))),
	.INITVAL_4F($sformatf("0x%01280x", init_slice('h4f))),
	.INITVAL_50($sformatf("0x%01280x", init_slice('h50))),
	.INITVAL_51($sformatf("0x%01280x", init_slice('h51))),
	.INITVAL_52($sformatf("0x%01280x", init_slice('h52))),
	.INITVAL_53($sformatf("0x%01280x", init_slice('h53))),
	.INITVAL_54($sformatf("0x%01280x", init_slice('h54))),
	.INITVAL_55($sformatf("0x%01280x", init_slice('h55))),
	.INITVAL_56($sformatf("0x%01280x", init_slice('h56))),
	.INITVAL_57($sformatf("0x%01280x", init_slice('h57))),
	.INITVAL_58($sformatf("0x%01280x", init_slice('h58))),
	.INITVAL_59($sformatf("0x%01280x", init_slice('h59))),
	.INITVAL_5A($sformatf("0x%01280x", init_slice('h5a))),
	.INITVAL_5B($sformatf("0x%01280x", init_slice('h5b))),
	.INITVAL_5C($sformatf("0x%01280x", init_slice('h5c))),
	.INITVAL_5D($sformatf("0x%01280x", init_slice('h5d))),
	.INITVAL_5E($sformatf("0x%01280x", init_slice('h5e))),
	.INITVAL_5F($sformatf("0x%01280x", init_slice('h5f))),
	.INITVAL_60($sformatf("0x%01280x", init_slice('h60))),
	.INITVAL_61($sformatf("0x%01280x", init_slice('h61))),
	.INITVAL_62($sformatf("0x%01280x", init_slice('h62))),
	.INITVAL_63($sformatf("0x%01280x", init_slice('h63))),
	.INITVAL_64($sformatf("0x%01280x", init_slice('h64))),
	.INITVAL_65($sformatf("0x%01280x", init_slice('h65))),
	.INITVAL_66($sformatf("0x%01280x", init_slice('h66))),
	.INITVAL_67($sformatf("0x%01280x", init_slice('h67))),
	.INITVAL_68($sformatf("0x%01280x", init_slice('h68))),
	.INITVAL_69($sformatf("0x%01280x", init_slice('h69))),
	.INITVAL_6A($sformatf("0x%01280x", init_slice('h6a))),
	.INITVAL_6B($sformatf("0x%01280x", init_slice('h6b))),
	.INITVAL_6C($sformatf("0x%01280x", init_slice('h6c))),
	.INITVAL_6D($sformatf("0x%01280x", init_slice('h6d))),
	.INITVAL_6E($sformatf("0x%01280x", init_slice('h6e))),
	.INITVAL_6F($sformatf("0x%01280x", init_slice('h6f))),
	.INITVAL_70($sformatf("0x%01280x", init_slice('h70))),
	.INITVAL_71($sformatf("0x%01280x", init_slice('h71))),
	.INITVAL_72($sformatf("0x%01280x", init_slice('h72))),
	.INITVAL_73($sformatf("0x%01280x", init_slice('h73))),
	.INITVAL_74($sformatf("0x%01280x", init_slice('h74))),
	.INITVAL_75($sformatf("0x%01280x", init_slice('h75))),
	.INITVAL_76($sformatf("0x%01280x", init_slice('h76))),
	.INITVAL_77($sformatf("0x%01280x", init_slice('h77))),
	.INITVAL_78($sformatf("0x%01280x", init_slice('h78))),
	.INITVAL_79($sformatf("0x%01280x", init_slice('h79))),
	.INITVAL_7A($sformatf("0x%01280x", init_slice('h7a))),
	.INITVAL_7B($sformatf("0x%01280x", init_slice('h7b))),
	.INITVAL_7C($sformatf("0x%01280x", init_slice('h7c))),
	.INITVAL_7D($sformatf("0x%01280x", init_slice('h7d))),
	.INITVAL_7E($sformatf("0x%01280x", init_slice('h7e))),
	.INITVAL_7F($sformatf("0x%01280x", init_slice('h7f))),
	.OUTREG_A("NO_REG"),
	.OUTREG_B("NO_REG"),
	.ECC_BYTE_SEL("BYTE_EN"),
	.GSR("DISABLED"),
	.RESETMODE(OPTION_RESETMODE),
	.ASYNC_RESET_RELEASE(OPTION_RESETMODE),
) _TECHMAP_REPLACE_ (
	.CLK(CLK_C),

	.WEA(PORT_A_WR_EN),
	.CEA(PORT_A_CLK_EN),
	.RSTA(OPTION_RESETMODE == "SYNC" ? PORT_A_RD_SRST : PORT_A_RD_ARST),
	.CSA(1'b1),
	.ADA(PORT_A_ADDR),
	.BENA_N(~PORT_A_WR_BE),
	.DIA(PORT_A_WR_DATA),
	.DOA(PORT_A_RD_DATA),

	.WEB(PORT_B_WR_EN),
	.CEB(PORT_B_CLK_EN),
	.RSTB(OPTION_RESETMODE == "SYNC" ? PORT_B_RD_SRST : PORT_B_RD_ARST),
	.CSB(1'b1),
	.BENB_N(~PORT_B_WR_BE),
	.ADB(PORT_B_ADDR),
	.DIB(PORT_B_WR_DATA),
	.DOB(PORT_B_RD_DATA),
);

endmodule
`,"lutrams.txt":`ram distributed $__NEXUS_DPR16X4_ {
	abits 4;
	width 4;
	cost 4;
	init no_undef;
	prune_rom;
	port sw "W" {
		clock posedge;
	}
	port ar "R" {
	}
}
`,"lutrams_map.v":`module $__NEXUS_DPR16X4_ (...);
	parameter INIT = 64'b0;

	input PORT_W_CLK;
	input [3:0] PORT_W_ADDR;
	input [3:0] PORT_W_WR_DATA;
	input PORT_W_WR_EN;

	input [3:0] PORT_R_ADDR;
	output [3:0] PORT_R_RD_DATA;

	DPR16X4 #(
		.INITVAL($sformatf("0x%08x", INIT))
	) _TECHMAP_REPLACE_ (
		.RAD(PORT_R_ADDR),
		.DO(PORT_R_RD_DATA),

		.WAD(PORT_W_ADDR),
		.DI(PORT_W_WR_DATA),
		.WCK(PORT_W_CLK),
		.WRE(PORT_W_WR_EN)
	);
endmodule
`,"parse_init.vh":`function [15:0] parse_init;
	input [((2+(16/4))*8)-1:0] init;
	reg [7:0] c;
	integer i;
	begin
		for (i = 0; i < (16/4); i = i + 1) begin
			c = init[(i * 8) +: 8];
			if (c >= "0" && c <= "9")
				parse_init[(i * 4) +: 4] = (c - "0");
			else if (c >= "A" && c <= "F")
				parse_init[(i * 4) +: 4] = (c - "A") + 10;
			else if (c >= "a" && c <= "f")
				parse_init[(i * 4) +: 4] = (c - "a") + 10;
		end
	end
endfunction

function [63:0] parse_init_64;
	input [((2+(64/4))*8)-1:0] init;
	reg [7:0] c;
	integer i;
	begin
		for (i = 0; i < (64/4); i = i + 1) begin
			c = init[(i * 8) +: 8];
			if (c >= "0" && c <= "9")
				parse_init_64[(i * 4) +: 4] = (c - "0");
			else if (c >= "A" && c <= "F")
				parse_init_64[(i * 4) +: 4] = (c - "A") + 10;
			else if (c >= "a" && c <= "f")
				parse_init_64[(i * 4) +: 4] = (c - "a") + 10;
		end
	end
endfunction
`},"pmux2mux.v":`module \\$pmux (A, B, S, Y);

wire [1023:0] _TECHMAP_DO_ = "proc; clean";

parameter WIDTH = 1;
parameter S_WIDTH = 1;

input [WIDTH-1:0] A;
input [WIDTH*S_WIDTH-1:0] B;
input [S_WIDTH-1:0] S;
output reg [WIDTH-1:0] Y;

integer i;

always @* begin
	Y <= A;
	for (i = 0; i < S_WIDTH; i=i+1)
		if (S[i]) Y <= B[WIDTH*i +: WIDTH];
end

endmodule
`,python3:{"smtio.py":`#
# yosys -- Yosys Open SYnthesis Suite
#
# Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
#
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
#

import sys, re, os, signal, json
import subprocess
if os.name == "posix":
    import resource
from copy import copy
from select import select
from time import time
from queue import Queue, Empty
from threading import Thread


# This is needed so that the recursive SMT2 S-expression parser
# does not run out of stack frames when parsing large expressions
if os.name == "posix":
    smtio_reclimit = 64 * 1024
    if sys.getrecursionlimit() < smtio_reclimit:
        sys.setrecursionlimit(smtio_reclimit)

    current_rlimit_stack = resource.getrlimit(resource.RLIMIT_STACK)
    if current_rlimit_stack[0] != resource.RLIM_INFINITY:
        smtio_stacksize = 128 * 1024 * 1024
        if os.uname().sysname == "Darwin":
            # MacOS has rather conservative stack limits
            smtio_stacksize = 8 * 1024 * 1024
        if current_rlimit_stack[1] != resource.RLIM_INFINITY:
            smtio_stacksize = min(smtio_stacksize, current_rlimit_stack[1])
        if current_rlimit_stack[0] < smtio_stacksize:
            try:
                resource.setrlimit(resource.RLIMIT_STACK, (smtio_stacksize, current_rlimit_stack[1]))
            except ValueError:
                # couldn't get more stack, just run with what we have
                pass


# currently running solvers (so we can kill them)
running_solvers = dict()
forced_shutdown = False
solvers_index = 0

def force_shutdown(signum, frame):
    global forced_shutdown
    if not forced_shutdown:
        forced_shutdown = True
        if signum is not None:
            print("<%s>" % signal.Signals(signum).name)
        for p in running_solvers.values():
            # os.killpg(os.getpgid(p.pid), signal.SIGTERM)
            os.kill(p.pid, signal.SIGTERM)
    sys.exit(1)

if os.name == "posix":
    signal.signal(signal.SIGHUP, force_shutdown)
signal.signal(signal.SIGINT, force_shutdown)
signal.signal(signal.SIGTERM, force_shutdown)

def except_hook(exctype, value, traceback):
    if not forced_shutdown:
        sys.__excepthook__(exctype, value, traceback)
    force_shutdown(None, None)

sys.excepthook = except_hook


def recursion_helper(iteration, *request):
    stack = [iteration(*request)]

    while stack:
        top = stack.pop()
        try:
            request = next(top)
        except StopIteration:
            continue

        stack.append(top)
        stack.append(iteration(*request))


hex_dict = {
    "0": "0000", "1": "0001", "2": "0010", "3": "0011",
    "4": "0100", "5": "0101", "6": "0110", "7": "0111",
    "8": "1000", "9": "1001", "A": "1010", "B": "1011",
    "C": "1100", "D": "1101", "E": "1110", "F": "1111",
    "a": "1010", "b": "1011", "c": "1100", "d": "1101",
    "e": "1110", "f": "1111"
}


class SmtModInfo:
    def __init__(self):
        self.inputs = set()
        self.outputs = set()
        self.registers = set()
        self.memories = dict()
        self.wires = set()
        self.wsize = dict()
        self.clocks = dict()
        self.cells = dict()
        self.asserts = dict()
        self.assumes = dict()
        self.covers = dict()
        self.maximize = set()
        self.minimize = set()
        self.anyconsts = dict()
        self.anyseqs = dict()
        self.allconsts = dict()
        self.allseqs = dict()
        self.asize = dict()
        self.witness = []


class SmtIo:
    def __init__(self, opts=None):
        global solvers_index

        self.logic = None
        self.logic_qf = True
        self.logic_ax = True
        self.logic_uf = True
        self.logic_bv = True
        self.logic_dt = False
        self.forall = False
        self.timeout = 0
        self.produce_models = True
        self.recheck = False
        self.smt2cache = [list()]
        self.smt2_options = dict()
        self.smt2_assumptions = dict()
        self.p = None
        self.p_index = solvers_index
        solvers_index += 1

        if opts is not None:
            self.logic = opts.logic
            self.solver = opts.solver
            self.solver_opts = opts.solver_opts
            self.debug_print = opts.debug_print
            self.debug_file = opts.debug_file
            self.dummy_file = opts.dummy_file
            self.timeinfo = opts.timeinfo
            self.timeout = opts.timeout
            self.unroll = opts.unroll
            self.noincr = opts.noincr
            self.info_stmts = opts.info_stmts
            self.nocomments = opts.nocomments
            self.smt2_options.update(opts.smt2_options)

        else:
            self.solver = "yices"
            self.solver_opts = list()
            self.debug_print = False
            self.debug_file = None
            self.dummy_file = None
            self.timeinfo = os.name != "nt"
            self.timeout = 0
            self.unroll = False
            self.noincr = False
            self.info_stmts = list()
            self.nocomments = False

        self.start_time = time()

        self.modinfo = dict()
        self.curmod = None
        self.topmod = None
        self.setup_done = False

    def __del__(self):
        if self.p is not None and not forced_shutdown:
            os.killpg(os.getpgid(self.p.pid), signal.SIGTERM)
            if running_solvers is not None:
                del running_solvers[self.p_index]

    def setup(self):
        assert not self.setup_done

        if self.forall:
            self.unroll = False

        if self.solver == "yices":
            if self.forall:
                self.noincr = True

            if self.noincr:
                self.popen_vargs = ['yices-smt2'] + self.solver_opts
            else:
                self.popen_vargs = ['yices-smt2', '--incremental'] + self.solver_opts
            if self.timeout != 0:
                self.popen_vargs.append('-t')
                self.popen_vargs.append('%d' % self.timeout);

        if self.solver == "z3":
            self.popen_vargs = ['z3', '-smt2', '-in'] + self.solver_opts
            if self.timeout != 0:
                self.popen_vargs.append('-T:%d' % self.timeout);

        if self.solver in ["cvc4", "cvc5"]:
            self.recheck = True
            if self.noincr:
                self.popen_vargs = [self.solver, '--lang', 'smt2.6' if self.logic_dt else 'smt2'] + self.solver_opts
            else:
                self.popen_vargs = [self.solver, '--incremental', '--lang', 'smt2.6' if self.logic_dt else 'smt2'] + self.solver_opts
            if self.timeout != 0:
                self.popen_vargs.append('--tlimit=%d000' % self.timeout);

        if self.solver == "mathsat":
            self.popen_vargs = ['mathsat'] + self.solver_opts
            if self.timeout != 0:
                print('timeout option is not supported for mathsat.')
                sys.exit(1)

        if self.solver in ["boolector", "bitwuzla"]:
            if self.noincr:
                self.popen_vargs = [self.solver, '--smt2'] + self.solver_opts
            else:
                self.popen_vargs = [self.solver, '--smt2', '-i'] + self.solver_opts
            self.unroll = True
            if self.timeout != 0:
                print('timeout option is not supported for %s.' % self.solver)
                sys.exit(1)

        if self.solver == "abc":
            if len(self.solver_opts) > 0:
                self.popen_vargs = ['yosys-abc', '-S', '; '.join(self.solver_opts)]
            else:
                self.popen_vargs = ['yosys-abc', '-S', '%blast; &sweep -C 5000; &syn4; &cec -s -m -C 2000']
            self.logic_ax = False
            self.unroll = True
            self.noincr = True
            if self.timeout != 0:
                print('timeout option is not supported for abc.')
                sys.exit(1)

        if self.solver == "dummy":
            assert self.dummy_file is not None
            self.dummy_fd = open(self.dummy_file, "r")
        else:
            if self.dummy_file is not None:
                self.dummy_fd = open(self.dummy_file, "w")
            if not self.noincr:
                self.p_open()

        if self.unroll:
            assert not self.forall
            self.logic_uf = False
            self.unroll_idcnt = 0
            self.unroll_buffer = ""
            self.unroll_level = 0
            self.unroll_sorts = set()
            self.unroll_objs = set()
            self.unroll_decls = dict()
            self.unroll_cache = dict()
            self.unroll_stack = list()

        if self.logic is None:
            self.logic = ""
            if self.logic_qf: self.logic += "QF_"
            if self.logic_ax: self.logic += "A"
            if self.logic_uf: self.logic += "UF"
            if self.logic_bv: self.logic += "BV"
            if self.logic_dt: self.logic = "ALL"
            if self.solver == "yices" and self.forall: self.logic = "BV"

        self.setup_done = True

        for stmt in self.info_stmts:
            self.write(stmt)

        if self.produce_models:
            self.write("(set-option :produce-models true)")

        #See the SMT-LIB Standard, Section 4.1.7
        modestart_options = [":global-declarations", ":interactive-mode", ":produce-assertions", ":produce-assignments", ":produce-models", ":produce-proofs", ":produce-unsat-assumptions", ":produce-unsat-cores", ":random-seed"]
        for key, val in self.smt2_options.items():
            if key in modestart_options:
                self.write("(set-option {} {})".format(key, val))

        self.write("(set-logic %s)" % self.logic)

        if self.forall and self.solver == "yices":
            self.write("(set-option :yices-ef-max-iters 1000000000)")

        for key, val in self.smt2_options.items():
            if key not in modestart_options:
                self.write("(set-option {} {})".format(key, val))

    def timestamp(self):
        secs = int(time() - self.start_time)
        return "## %3d:%02d:%02d " % (secs // (60*60), (secs // 60) % 60, secs % 60)

    def replace_in_stmt(self, stmt, pat, repl):
        if stmt == pat:
            return repl

        if isinstance(stmt, list):
            return [self.replace_in_stmt(s, pat, repl) for s in stmt]

        return stmt

    def unroll_stmt(self, stmt):
        result = []
        recursion_helper(self._unroll_stmt_into, stmt, result)
        return result.pop()

    def _unroll_stmt_into(self, stmt, output, depth=128):
        if not isinstance(stmt, list):
            output.append(stmt)
            return

        new_stmt = []
        for s in stmt:
            if depth:
                yield from self._unroll_stmt_into(s, new_stmt, depth - 1)
            else:
                yield s, new_stmt
        stmt = new_stmt

        if len(stmt) >= 2 and not isinstance(stmt[0], list) and stmt[0] in self.unroll_decls:
            assert stmt[1] in self.unroll_objs

            key = tuple(stmt)
            if key not in self.unroll_cache:
                decl = copy(self.unroll_decls[key[0]])

                self.unroll_cache[key] = "|UNROLL#%d|" % self.unroll_idcnt
                decl[1] = self.unroll_cache[key]
                self.unroll_idcnt += 1

                if decl[0] == "declare-fun":
                    if isinstance(decl[3], list) or decl[3] not in self.unroll_sorts:
                        self.unroll_objs.add(decl[1])
                        decl[2] = list()
                    else:
                        self.unroll_objs.add(decl[1])
                        decl = list()

                elif decl[0] == "define-fun":
                    arg_index = 1
                    for arg_name, arg_sort in decl[2]:
                        decl[4] = self.replace_in_stmt(decl[4], arg_name, key[arg_index])
                        arg_index += 1
                    decl[2] = list()

                if len(decl) > 0:
                    tmp = []
                    if depth:
                        yield from self._unroll_stmt_into(decl, tmp, depth - 1)
                    else:
                        yield decl, tmp

                    decl = tmp.pop()
                    self.write(self.unparse(decl), unroll=False)

            output.append(self.unroll_cache[key])
            return

        output.append(stmt)

    def p_thread_main(self):
        while True:
            data = self.p.stdout.readline().decode("utf-8")
            if data == "": break
            self.p_queue.put(data)
        self.p_queue.put("")
        self.p_running = False

    def p_open(self):
        assert self.p is None
        try:
            self.p = subprocess.Popen(self.popen_vargs, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        except FileNotFoundError:
            print("%s SMT Solver '%s' not found in path." % (self.timestamp(), self.popen_vargs[0]), flush=True)
            sys.exit(1)
        running_solvers[self.p_index] = self.p
        self.p_running = True
        self.p_next = None
        self.p_queue = Queue()
        self.p_thread = Thread(target=self.p_thread_main)
        self.p_thread.start()

    def p_write(self, data, flush):
        assert self.p is not None
        self.p.stdin.write(bytes(data, "utf-8"))
        if flush: self.p.stdin.flush()

    def p_read(self):
        assert self.p is not None
        if self.p_next is not None:
            data = self.p_next
            self.p_next = None
            return data
        if not self.p_running:
            return ""
        return self.p_queue.get()

    def p_poll(self, timeout=0.1):
        assert self.p is not None
        assert self.p_running
        if self.p_next is not None:
            return False
        try:
            self.p_next = self.p_queue.get(True, timeout)
            return False
        except Empty:
            return True

    def p_close(self):
        assert self.p is not None
        self.p.stdin.close()
        self.p_thread.join()
        assert not self.p_running
        del running_solvers[self.p_index]
        self.p = None
        self.p_next = None
        self.p_queue = None
        self.p_thread = None

    def write(self, stmt, unroll=True):
        if stmt.startswith(";"):
            self.info(stmt)
            if not self.setup_done:
                self.info_stmts.append(stmt)
                return
        elif not self.setup_done:
            self.setup()

        stmt = stmt.strip()

        if self.nocomments or self.unroll:
            stmt = re.sub(r" *;.*", "", stmt)
            if stmt == "": return

        recheck = None

        if self.solver != "dummy":
            if self.noincr:
                # Don't close the solver yet, if we're just unrolling definitions
                # required for a (get-...) statement
                if self.p is not None and not stmt.startswith("(get-") and unroll:
                    self.p_close()

        if unroll and self.unroll:
            s = re.sub(r"\\|[^|]*\\|", "", stmt)
            self.unroll_level += s.count("(") - s.count(")")
            if self.unroll_level > 0:
                self.unroll_buffer += stmt
                self.unroll_buffer += " "
                return
            else:
                stmt = self.unroll_buffer + stmt
                self.unroll_buffer = ""

            s = self.parse(stmt)

            if self.recheck and s and s[0].startswith("get-"):
                recheck = self.unroll_idcnt

            if self.debug_print:
                print("-> %s" % s)

            if len(s) == 3 and s[0] == "declare-sort" and s[2] == "0":
                self.unroll_sorts.add(s[1])
                return

            elif len(s) == 4 and s[0] == "declare-fun" and s[2] == [] and s[3] in self.unroll_sorts:
                self.unroll_objs.add(s[1])
                return

            elif len(s) >= 4 and s[0] == "declare-fun":
                for arg_sort in s[2]:
                    if arg_sort in self.unroll_sorts:
                        self.unroll_decls[s[1]] = s
                        return

            elif len(s) >= 4 and s[0] == "define-fun":
                for arg_name, arg_sort in s[2]:
                    if arg_sort in self.unroll_sorts:
                        self.unroll_decls[s[1]] = s
                        return

            stmt = self.unparse(self.unroll_stmt(s))

            if recheck is not None and recheck != self.unroll_idcnt:
                self.check_sat(["sat"])

            if stmt == "(push 1)":
                self.unroll_stack.append((
                    copy(self.unroll_sorts),
                    copy(self.unroll_objs),
                    copy(self.unroll_decls),
                    copy(self.unroll_cache),
                ))

            if stmt == "(pop 1)":
                self.unroll_sorts, self.unroll_objs, self.unroll_decls, self.unroll_cache = self.unroll_stack.pop()

        if self.debug_print:
            print("> %s" % stmt)

        if self.debug_file:
            print(stmt, file=self.debug_file)
            self.debug_file.flush()

        if self.solver != "dummy":
            if self.noincr:
                if stmt == "(push 1)":
                    self.smt2cache.append(list())
                elif stmt == "(pop 1)":
                    self.smt2cache.pop()
                else:
                    if self.p is not None:
                        self.p_write(stmt + "\\n", True)
                    self.smt2cache[-1].append(stmt)
            else:
                self.p_write(stmt + "\\n", True)

    def info(self, stmt):
        if not stmt.startswith("; yosys-smt2-"):
            return

        fields = stmt.split()

        if fields[1] == "yosys-smt2-solver-option":
            self.smt2_options[fields[2]] = fields[3]

        if fields[1] == "yosys-smt2-nomem":
            if self.logic is None:
                self.logic_ax = False

        if fields[1] == "yosys-smt2-nobv":
            if self.logic is None:
                self.logic_bv = False

        if fields[1] == "yosys-smt2-stdt":
            if self.logic is None:
                self.logic_dt = True

        if fields[1] == "yosys-smt2-forall":
            if self.logic is None:
                self.logic_qf = False
            self.forall = True

        if fields[1] == "yosys-smt2-module":
            self.curmod = fields[2]
            self.modinfo[self.curmod] = SmtModInfo()

        if fields[1] == "yosys-smt2-cell":
            self.modinfo[self.curmod].cells[fields[3]] = fields[2]

        if fields[1] == "yosys-smt2-topmod":
            self.topmod = fields[2]

        if fields[1] == "yosys-smt2-input":
            self.modinfo[self.curmod].inputs.add(fields[2])
            self.modinfo[self.curmod].wsize[fields[2]] = int(fields[3])

        if fields[1] == "yosys-smt2-output":
            self.modinfo[self.curmod].outputs.add(fields[2])
            self.modinfo[self.curmod].wsize[fields[2]] = int(fields[3])

        if fields[1] == "yosys-smt2-register":
            self.modinfo[self.curmod].registers.add(fields[2])
            self.modinfo[self.curmod].wsize[fields[2]] = int(fields[3])

        if fields[1] == "yosys-smt2-memory":
            self.modinfo[self.curmod].memories[fields[2]] = (int(fields[3]), int(fields[4]), int(fields[5]), int(fields[6]), fields[7] == "async")

        if fields[1] == "yosys-smt2-wire":
            self.modinfo[self.curmod].wires.add(fields[2])
            self.modinfo[self.curmod].wsize[fields[2]] = int(fields[3])

        if fields[1] == "yosys-smt2-clock":
            for edge in fields[3:]:
                if fields[2] not in self.modinfo[self.curmod].clocks:
                    self.modinfo[self.curmod].clocks[fields[2]] = edge
                elif self.modinfo[self.curmod].clocks[fields[2]] != edge:
                    self.modinfo[self.curmod].clocks[fields[2]] = "event"

        if fields[1] == "yosys-smt2-assert":
            if len(fields) > 4:
                self.modinfo[self.curmod].asserts["%s_a %s" % (self.curmod, fields[2])] = f'{fields[4]} ({fields[3]})'
            else:
                self.modinfo[self.curmod].asserts["%s_a %s" % (self.curmod, fields[2])] = fields[3]

        if fields[1] == "yosys-smt2-cover":
            if len(fields) > 4:
                self.modinfo[self.curmod].covers["%s_c %s" % (self.curmod, fields[2])] = f'{fields[4]} ({fields[3]})'
            else:
                self.modinfo[self.curmod].covers["%s_c %s" % (self.curmod, fields[2])] = fields[3]

        if fields[1] == "yosys-smt2-assume":
            if len(fields) > 4:
                self.modinfo[self.curmod].assumes["%s_u %s" % (self.curmod, fields[2])] = f'{fields[4]} ({fields[3]})'
            else:
                self.modinfo[self.curmod].assumes["%s_u %s" % (self.curmod, fields[2])] = fields[3]

        if fields[1] == "yosys-smt2-maximize":
            self.modinfo[self.curmod].maximize.add(fields[2])

        if fields[1] == "yosys-smt2-minimize":
            self.modinfo[self.curmod].minimize.add(fields[2])

        if fields[1] == "yosys-smt2-anyconst":
            self.modinfo[self.curmod].anyconsts[fields[2]] = (fields[4], None if len(fields) <= 5 else fields[5])
            self.modinfo[self.curmod].asize[fields[2]] = int(fields[3])

        if fields[1] == "yosys-smt2-anyseq":
            self.modinfo[self.curmod].anyseqs[fields[2]] = (fields[4], None if len(fields) <= 5 else fields[5])
            self.modinfo[self.curmod].asize[fields[2]] = int(fields[3])

        if fields[1] == "yosys-smt2-allconst":
            self.modinfo[self.curmod].allconsts[fields[2]] = (fields[4], None if len(fields) <= 5 else fields[5])
            self.modinfo[self.curmod].asize[fields[2]] = int(fields[3])

        if fields[1] == "yosys-smt2-allseq":
            self.modinfo[self.curmod].allseqs[fields[2]] = (fields[4], None if len(fields) <= 5 else fields[5])
            self.modinfo[self.curmod].asize[fields[2]] = int(fields[3])

        if fields[1] == "yosys-smt2-witness":
            data = json.loads(stmt.split(None, 2)[2])
            if data.get("type") in ["cell", "mem", "posedge", "negedge", "input", "reg", "init", "seq", "blackbox"]:
                self.modinfo[self.curmod].witness.append(data)

    def hiernets(self, top, regs_only=False):
        def hiernets_worker(nets, mod, cursor):
            for netname in sorted(self.modinfo[mod].wsize.keys()):
                if not regs_only or netname in self.modinfo[mod].registers:
                    nets.append(cursor + [netname])
            for cellname, celltype in sorted(self.modinfo[mod].cells.items()):
                hiernets_worker(nets, celltype, cursor + [cellname])

        nets = list()
        hiernets_worker(nets, top, [])
        return nets

    def hieranyconsts(self, top):
        def worker(results, mod, cursor):
            for name, value in sorted(self.modinfo[mod].anyconsts.items()):
                width = self.modinfo[mod].asize[name]
                results.append((cursor, name, value[0], value[1], width))
            for cellname, celltype in sorted(self.modinfo[mod].cells.items()):
                worker(results, celltype, cursor + [cellname])

        results = list()
        worker(results, top, [])
        return results

    def hieranyseqs(self, top):
        def worker(results, mod, cursor):
            for name, value in sorted(self.modinfo[mod].anyseqs.items()):
                width = self.modinfo[mod].asize[name]
                results.append((cursor, name, value[0], value[1], width))
            for cellname, celltype in sorted(self.modinfo[mod].cells.items()):
                worker(results, celltype, cursor + [cellname])

        results = list()
        worker(results, top, [])
        return results

    def hierallconsts(self, top):
        def worker(results, mod, cursor):
            for name, value in sorted(self.modinfo[mod].allconsts.items()):
                width = self.modinfo[mod].asize[name]
                results.append((cursor, name, value[0], value[1], width))
            for cellname, celltype in sorted(self.modinfo[mod].cells.items()):
                worker(results, celltype, cursor + [cellname])

        results = list()
        worker(results, top, [])
        return results

    def hierallseqs(self, top):
        def worker(results, mod, cursor):
            for name, value in sorted(self.modinfo[mod].allseqs.items()):
                width = self.modinfo[mod].asize[name]
                results.append((cursor, name, value[0], value[1], width))
            for cellname, celltype in sorted(self.modinfo[mod].cells.items()):
                worker(results, celltype, cursor + [cellname])

        results = list()
        worker(results, top, [])
        return results

    def hiermems(self, top):
        def hiermems_worker(mems, mod, cursor):
            for memname in sorted(self.modinfo[mod].memories.keys()):
                mems.append(cursor + [memname])
            for cellname, celltype in sorted(self.modinfo[mod].cells.items()):
                hiermems_worker(mems, celltype, cursor + [cellname])

        mems = list()
        hiermems_worker(mems, top, [])
        return mems

    def hierwitness(self, top, allregs=False, blackbox=True):
        init_witnesses = []
        seq_witnesses = []
        clk_witnesses = []
        mem_witnesses = []

        def absolute(path, cursor, witness):
            return {
                **witness,
                "path": path + tuple(witness["path"]),
                "smtpath": cursor + [witness["smtname"]],
            }

        for witness in self.modinfo[top].witness:
            if witness["type"] == "input":
                seq_witnesses.append(absolute((), [], witness))
            if witness["type"] in ("posedge", "negedge"):
                clk_witnesses.append(absolute((), [], witness))

        init_types = ["init"]
        if allregs:
            init_types.append("reg")

        seq_types = ["seq"]
        if blackbox:
            seq_types.append("blackbox")

        def worker(mod, path, cursor):
            cell_paths = {}
            for witness in self.modinfo[mod].witness:
                if witness["type"] in init_types:
                    init_witnesses.append(absolute(path, cursor, witness))
                if witness["type"] in seq_types:
                    seq_witnesses.append(absolute(path, cursor, witness))
                if witness["type"] == "mem":
                    if allregs and not witness["rom"]:
                        width, size = witness["width"], witness["size"]
                        witness = {**witness, "uninitialized": [{"width": width * size, "offset": 0}]}
                    if not witness["uninitialized"]:
                        continue

                    mem_witnesses.append(absolute(path, cursor, witness))
                if witness["type"] == "cell":
                    cell_paths[witness["smtname"]] = tuple(witness["path"])

            for cellname, celltype in sorted(self.modinfo[mod].cells.items()):
                worker(celltype, path + cell_paths.get(cellname, ("?" + cellname,)), cursor + [cellname])

        worker(top, (), [])
        return init_witnesses, seq_witnesses, clk_witnesses, mem_witnesses

    def read(self):
        stmt = []
        count_brackets = 0

        while True:
            if self.solver == "dummy":
                line = self.dummy_fd.readline().strip()
            else:
                line = self.p_read().strip()
                if self.dummy_file is not None:
                    self.dummy_fd.write(line + "\\n")

            count_brackets += line.count("(")
            count_brackets -= line.count(")")
            stmt.append(line)

            if self.debug_print:
                print("< %s" % line)
            if count_brackets == 0:
                break
            if self.solver != "dummy" and self.p.poll():
                print("%s Solver terminated unexpectedly: %s" % (self.timestamp(), "".join(stmt)), flush=True)
                sys.exit(1)

        stmt = "".join(stmt)
        if stmt.startswith("(error"):
            print("%s Solver Error: %s" % (self.timestamp(), stmt), flush=True)
            if self.solver != "dummy":
                self.p_close()
            sys.exit(1)

        return stmt

    def check_sat(self, expected=["sat", "unsat", "unknown", "timeout", "interrupted"]):
        if self.smt2_assumptions:
            assume_exprs = " ".join(self.smt2_assumptions.values())
            check_stmt = f"(check-sat-assuming ({assume_exprs}))"
        else:
            check_stmt = "(check-sat)"
        if self.debug_print:
            print(f"> {check_stmt}")
        if self.debug_file and not self.nocomments:
            print("; running check-sat..", file=self.debug_file)
            self.debug_file.flush()

        if self.solver != "dummy":
            if self.noincr:
                if self.p is not None:
                    self.p_close()
                self.p_open()
                for cache_ctx in self.smt2cache:
                    for cache_stmt in cache_ctx:
                        self.p_write(cache_stmt + "\\n", False)

            self.p_write(f"{check_stmt}\\n", True)

            if self.timeinfo:
                i = 0
                s = r"/-\\|"

                count = 0
                num_bs = 0
                while self.p_poll():
                    count += 1

                    if count < 25:
                        continue

                    if count % 10 == 0 or count == 25:
                        secs = count // 10

                        if secs < 60:
                            m = "(%d seconds)" % secs
                        elif secs < 60*60:
                            m = "(%d seconds -- %d:%02d)" % (secs, secs // 60, secs % 60)
                        else:
                            m = "(%d seconds -- %d:%02d:%02d)" % (secs, secs // (60*60), (secs // 60) % 60, secs % 60)

                        print("%s %s %c" % ("\\b \\b" * num_bs, m, s[i]), end="", file=sys.stderr)
                        num_bs = len(m) + 3

                    else:
                        print("\\b" + s[i], end="", file=sys.stderr)

                    sys.stderr.flush()
                    i = (i + 1) % len(s)

                if num_bs != 0:
                    print("\\b \\b" * num_bs, end="", file=sys.stderr)
                    sys.stderr.flush()

            else:
                count = 0
                while self.p_poll(60):
                    count += 1
                    msg = None

                    if count == 1:
                        msg = "1 minute"

                    elif count in [5, 10, 15, 30]:
                        msg = "%d minutes" % count

                    elif count == 60:
                        msg = "1 hour"

                    elif count % 60 == 0:
                        msg = "%d hours" % (count // 60)

                    if msg is not None:
                        print("%s waiting for solver (%s)" % (self.timestamp(), msg), flush=True)

        if self.forall:
            result = self.read()
            while result not in ["sat", "unsat", "unknown", "timeout", "interrupted", ""]:
                print("%s %s: %s" % (self.timestamp(), self.solver, result))
                result = self.read()
        else:
            result = self.read()

        if self.debug_file:
            print("(set-info :status %s)" % result, file=self.debug_file)
            print(check_stmt, file=self.debug_file)
            self.debug_file.flush()

        if result not in expected:
            if result == "":
                print("%s Unexpected EOF response from solver." % (self.timestamp()), flush=True)
            else:
                print("%s Unexpected response from solver: %s" % (self.timestamp(), result), flush=True)
            if self.solver != "dummy":
                self.p_close()
            sys.exit(1)

        return result

    def parse(self, stmt):
        def worker(stmt, cursor=0):
            while stmt[cursor] in [" ", "\\t", "\\r", "\\n"]:
                cursor += 1

            if stmt[cursor] == '(':
                expr = []
                cursor += 1
                while stmt[cursor] != ')':
                    el, cursor = worker(stmt, cursor)
                    expr.append(el)
                return expr, cursor+1

            if stmt[cursor] == '|':
                expr = "|"
                cursor += 1
                while stmt[cursor] != '|':
                    expr += stmt[cursor]
                    cursor += 1
                expr += "|"
                return expr, cursor+1

            expr = ""
            while stmt[cursor] not in ["(", ")", "|", " ", "\\t", "\\r", "\\n"]:
                expr += stmt[cursor]
                cursor += 1
            return expr, cursor
        return worker(stmt)[0]

    def unparse(self, stmt):
        if isinstance(stmt, list):
            return "(" + " ".join([self.unparse(s) for s in stmt]) + ")"
        return stmt

    def bv2hex(self, v):
        h = ""
        v = self.bv2bin(v)
        while len(v) > 0:
            d = 0
            if len(v) > 0 and v[-1] == "1": d += 1
            if len(v) > 1 and v[-2] == "1": d += 2
            if len(v) > 2 and v[-3] == "1": d += 4
            if len(v) > 3 and v[-4] == "1": d += 8
            h = hex(d)[2:] + h
            if len(v) < 4: break
            v = v[:-4]
        return h

    def bv2bin(self, v):
        if type(v) is list and len(v) == 3 and v[0] == "_" and v[1].startswith("bv"):
            x, n = int(v[1][2:]), int(v[2])
            return "".join("1" if (x & (1 << i)) else "0" for i in range(n-1, -1, -1))
        if v == "true": return "1"
        if v == "false": return "0"
        if v.startswith("#b"):
            return v[2:]
        if v.startswith("#x"):
            return "".join(hex_dict.get(x) for x in v[2:])
        assert False

    def bv2int(self, v):
        return int(self.bv2bin(v), 2)

    def get_raw_unsat_assumptions(self):
        if not self.smt2_assumptions:
            return []
        self.write("(get-unsat-assumptions)")
        exprs = set(self.unparse(part) for part in self.parse(self.read()))
        unsat_assumptions = []
        for key, value in self.smt2_assumptions.items():
            # normalize expression
            value = self.unparse(self.parse(value))
            if value in exprs:
                exprs.remove(value)
                unsat_assumptions.append(key)
        return unsat_assumptions

    def get_unsat_assumptions(self, minimize=False):
        if not minimize:
            return self.get_raw_unsat_assumptions()
        orig_assumptions = self.smt2_assumptions

        self.smt2_assumptions = dict(orig_assumptions)

        required_assumptions = {}

        while True:
            candidate_assumptions = {}
            for key in self.get_raw_unsat_assumptions():
                if key not in required_assumptions:
                    candidate_assumptions[key] = self.smt2_assumptions[key]

            while candidate_assumptions:

                candidate_key, candidate_assume = candidate_assumptions.popitem()

                self.smt2_assumptions = {}
                for key, assume in candidate_assumptions.items():
                    self.smt2_assumptions[key] = assume
                for key, assume in required_assumptions.items():
                    self.smt2_assumptions[key] = assume
                result = self.check_sat()

                if result == 'unsat':
                    candidate_assumptions = None
                else:
                    required_assumptions[candidate_key] = candidate_assume

            if candidate_assumptions is not None:
                self.smt2_assumptions = orig_assumptions
                return list(required_assumptions)

    def get(self, expr):
        self.write("(get-value (%s))" % (expr))
        return self.parse(self.read())[0][1]

    def get_list(self, expr_list):
        if len(expr_list) == 0:
            return []
        self.write("(get-value (%s))" % " ".join(expr_list))
        return [n[1] for n in self.parse(self.read()) if n]

    def get_path(self, mod, path):
        assert mod in self.modinfo
        path = path.replace("\\\\", "/").split(".")

        for i in range(len(path)-1):
            first = ".".join(path[0:i+1])
            second = ".".join(path[i+1:])

            if first in self.modinfo[mod].cells:
                nextmod = self.modinfo[mod].cells[first]
                return [first] + self.get_path(nextmod, second)

        return [".".join(path)]

    def net_expr(self, mod, base, path):
        if len(path) == 0:
            return base

        if len(path) == 1:
            assert mod in self.modinfo
            if path[0] == "":
                return base
            if isinstance(path[0], int):
                return "(|%s#%d| %s)" % (mod, path[0], base)
            if path[0] in self.modinfo[mod].cells:
                return "(|%s_h %s| %s)" % (mod, path[0], base)
            if path[0] in self.modinfo[mod].wsize:
                return "(|%s_n %s| %s)" % (mod, path[0], base)
            if path[0] in self.modinfo[mod].memories:
                return "(|%s_m %s| %s)" % (mod, path[0], base)
            assert 0

        assert mod in self.modinfo
        assert path[0] in self.modinfo[mod].cells

        nextmod = self.modinfo[mod].cells[path[0]]
        nextbase = "(|%s_h %s| %s)" % (mod, path[0], base)
        return self.net_expr(nextmod, nextbase, path[1:])

    def witness_net_expr(self, mod, base, witness):
        net = self.net_expr(mod, base, witness["smtpath"])
        is_bool = self.net_width(mod, witness["smtpath"]) == 1
        if is_bool:
            assert witness["width"] == 1
            assert witness["smtoffset"] == 0
            return net
        return "((_ extract %d %d) %s)" % (witness["smtoffset"] + witness["width"] - 1, witness["smtoffset"], net)

    def net_width(self, mod, net_path):
        for i in range(len(net_path)-1):
            assert mod in self.modinfo
            assert net_path[i] in self.modinfo[mod].cells
            mod = self.modinfo[mod].cells[net_path[i]]

        assert mod in self.modinfo
        if isinstance(net_path[-1], int):
            return None
        assert net_path[-1] in self.modinfo[mod].wsize
        return self.modinfo[mod].wsize[net_path[-1]]

    def net_clock(self, mod, net_path):
        for i in range(len(net_path)-1):
            assert mod in self.modinfo
            assert net_path[i] in self.modinfo[mod].cells
            mod = self.modinfo[mod].cells[net_path[i]]

        assert mod in self.modinfo
        if net_path[-1] not in self.modinfo[mod].clocks:
            return None
        return self.modinfo[mod].clocks[net_path[-1]]

    def net_exists(self, mod, net_path):
        for i in range(len(net_path)-1):
            if mod not in self.modinfo: return False
            if net_path[i] not in self.modinfo[mod].cells: return False
            mod = self.modinfo[mod].cells[net_path[i]]

        if mod not in self.modinfo: return False
        if net_path[-1] not in self.modinfo[mod].wsize: return False
        return True

    def mem_exists(self, mod, mem_path):
        for i in range(len(mem_path)-1):
            if mod not in self.modinfo: return False
            if mem_path[i] not in self.modinfo[mod].cells: return False
            mod = self.modinfo[mod].cells[mem_path[i]]

        if mod not in self.modinfo: return False
        if mem_path[-1] not in self.modinfo[mod].memories: return False
        return True

    def mem_expr(self, mod, base, path, port=None, infomode=False):
        if len(path) == 1:
            assert mod in self.modinfo
            assert path[0] in self.modinfo[mod].memories
            if infomode:
                return self.modinfo[mod].memories[path[0]]
            return "(|%s_m%s %s| %s)" % (mod, "" if port is None else ":%s" % port, path[0], base)

        assert mod in self.modinfo
        assert path[0] in self.modinfo[mod].cells

        nextmod = self.modinfo[mod].cells[path[0]]
        nextbase = "(|%s_h %s| %s)" % (mod, path[0], base)
        return self.mem_expr(nextmod, nextbase, path[1:], port=port, infomode=infomode)

    def mem_info(self, mod, path):
        return self.mem_expr(mod, "", path, infomode=True)

    def get_net(self, mod_name, net_path, state_name):
        return self.get(self.net_expr(mod_name, state_name, net_path))

    def get_net_list(self, mod_name, net_path_list, state_name):
        return self.get_list([self.net_expr(mod_name, state_name, n) for n in net_path_list])

    def get_net_hex(self, mod_name, net_path, state_name):
        return self.bv2hex(self.get_net(mod_name, net_path, state_name))

    def get_net_hex_list(self, mod_name, net_path_list, state_name):
        return [self.bv2hex(v) for v in self.get_net_list(mod_name, net_path_list, state_name)]

    def get_net_bin(self, mod_name, net_path, state_name):
        return self.bv2bin(self.get_net(mod_name, net_path, state_name))

    def get_net_bin_list(self, mod_name, net_path_list, state_name):
        return [self.bv2bin(v) for v in self.get_net_list(mod_name, net_path_list, state_name)]

    def wait(self):
        if self.p is not None:
            self.p.wait()
            self.p_close()


class SmtOpts:
    def __init__(self):
        self.shortopts = "s:S:v"
        self.longopts = ["unroll", "noincr", "noprogress", "timeout=", "dump-smt2=", "logic=", "dummy=", "info=", "nocomments", "smt2-option="]
        self.solver = "yices"
        self.solver_opts = list()
        self.debug_print = False
        self.debug_file = None
        self.dummy_file = None
        self.unroll = False
        self.noincr = False
        self.timeinfo = os.name != "nt"
        self.timeout = 0
        self.logic = None
        self.info_stmts = list()
        self.nocomments = False
        self.smt2_options = {}

    def handle(self, o, a):
        if o == "-s":
            self.solver = a
        elif o == "-S":
            self.solver_opts.append(a)
        elif o == "--timeout":
            self.timeout = int(a)
        elif o == "-v":
            self.debug_print = True
        elif o == "--unroll":
            self.unroll = True
        elif o == "--noincr":
            self.noincr = True
        elif o == "--noprogress":
            self.timeinfo = False
        elif o == "--dump-smt2":
            self.debug_file = open(a, "w")
        elif o == "--logic":
            self.logic = a
        elif o == "--dummy":
            self.dummy_file = a
        elif o == "--info":
            self.info_stmts.append(a)
        elif o == "--nocomments":
            self.nocomments = True
        elif o == "--smt2-option":
            args = a.split('=', 1)
            if len(args) != 2:
                print("--smt2-option expects an <option>=<value> argument")
                sys.exit(1)
            option, value = args
            self.smt2_options[option] = value
        else:
            return False
        return True

    def helpmsg(self):
        return """
    -s <solver>
        set SMT solver: z3, yices, boolector, bitwuzla, cvc4, mathsat, dummy
        default: yices

    -S <opt>
        pass <opt> as command line argument to the solver

    --timeout <value>
        set the solver timeout to the specified value (in seconds).

    --logic <smt2_logic>
        use the specified SMT2 logic (e.g. QF_AUFBV)

    --dummy <filename>
        if solver is "dummy", read solver output from that file
        otherwise: write solver output to that file

    --smt2-option <option>=<value>
        enable an SMT-LIBv2 option.

    -v
        enable debug output

    --unroll
        unroll uninterpreted functions

    --noincr
        don't use incremental solving, instead restart solver for
        each (check-sat). This also avoids (push) and (pop).

    --noprogress
        disable timer display during solving
        (this option is set implicitly on Windows)

    --dump-smt2 <filename>
        write smt2 statements to file

    --info <smt2-info-stmt>
        include the specified smt2 info statement in the smt2 output

    --nocomments
        strip all comments from the generated smt2 code
"""


class MkVcd:
    def __init__(self, f):
        self.f = f
        self.t = -1
        self.nets = dict()
        self.clocks = dict()

    def add_net(self, path, width):
        path = tuple(path)
        assert self.t == -1
        key = "n%d" % len(self.nets)
        self.nets[path] = (key, width)

    def add_clock(self, path, edge):
        path = tuple(path)
        assert self.t == -1
        key = "n%d" % len(self.nets)
        self.nets[path] = (key, 1)
        self.clocks[path] = (key, edge)

    def set_net(self, path, bits):
        path = tuple(path)
        assert self.t >= 0
        assert path in self.nets
        if path not in self.clocks:
            print("b%s %s" % (bits, self.nets[path][0]), file=self.f)

    def escape_name(self, name):
        name = re.sub(r"\\[([0-9a-zA-Z_]*[a-zA-Z_][0-9a-zA-Z_]*)\\]", r"<\\1>", name)
        if re.match(r"[\\[\\]]", name) and name[0] != "\\\\":
            name = "\\\\" + name
        return name

    def set_time(self, t):
        assert t >= self.t
        if t != self.t:
            if self.t == -1:
                print("$version Generated by Yosys-SMTBMC $end", file=self.f)
                print("$timescale 1ns $end", file=self.f)
                print("$var integer 32 t smt_step $end", file=self.f)
                print("$var event 1 ! smt_clock $end", file=self.f)

                def vcdescape(n):
                    if n.startswith("$") or ":" in n:
                        return "\\\\" + n
                    return n

                scope = []
                for path in sorted(self.nets):
                    key, width = self.nets[path]

                    uipath = list(path)
                    if "." in uipath[-1] and not uipath[-1].startswith("$"):
                        uipath = uipath[0:-1] + uipath[-1].split(".")
                    for i in range(len(uipath)):
                        uipath[i] = re.sub(r"\\[([^\\]]*)\\]", r"<\\1>", uipath[i])

                    while uipath[:len(scope)] != scope:
                        print("$upscope $end", file=self.f)
                        scope = scope[:-1]

                    while uipath[:-1] != scope:
                        scopename = uipath[len(scope)]
                        print("$scope module %s $end" % vcdescape(scopename), file=self.f)
                        scope.append(uipath[len(scope)])

                    if path in self.clocks and self.clocks[path][1] == "event":
                        print("$var event 1 %s %s $end" % (key, vcdescape(uipath[-1])), file=self.f)
                    else:
                        print("$var wire %d %s %s $end" % (width, key, vcdescape(uipath[-1])), file=self.f)

                for i in range(len(scope)):
                    print("$upscope $end", file=self.f)

                print("$enddefinitions $end", file=self.f)

            self.t = t
            assert self.t >= 0

            if self.t > 0:
                print("#%d" % (10 * self.t - 5), file=self.f)
                for path in sorted(self.clocks.keys()):
                    if self.clocks[path][1] == "posedge":
                        print("b0 %s" % self.nets[path][0], file=self.f)
                    elif self.clocks[path][1] == "negedge":
                        print("b1 %s" % self.nets[path][0], file=self.f)

            print("#%d" % (10 * self.t), file=self.f)
            print("1!", file=self.f)
            print("b%s t" % format(self.t, "032b"), file=self.f)

            for path in sorted(self.clocks.keys()):
                if self.clocks[path][1] == "negedge":
                    print("b0 %s" % self.nets[path][0], file=self.f)
                else:
                    print("b1 %s" % self.nets[path][0], file=self.f)
`,"ywio.py":`#
# yosys -- Yosys Open SYnthesis Suite
#
# Copyright (C) 2022  Jannis Harder <jix@yosyshq.com> <me@jix.one>
#
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
#

import json, re

from functools import total_ordering


class PrettyJson:
    def __init__(self, f):
        self.f = f
        self.indent = 0
        self.state = ["value"]

    def line(self):
        indent = len(self.state) - bool(self.state and self.state[-1] == "value")
        print("\\n", end=" " * (2 * indent), file=self.f)

    def raw(self, str):
        print(end=str, file=self.f)

    def begin_object(self):
        self.begin_value()
        self.raw("{")
        self.state.append("object_first")

    def begin_array(self):
        self.begin_value()
        self.raw("[")
        self.state.append("array_first")

    def end_object(self):
        state = self.state.pop()
        if state == "object":
            self.line()
        else:
            assert state == "object_first"
        self.raw("}")
        self.end_value()

    def end_array(self):
        state = self.state.pop()
        if state == "array":
            self.line()
        else:
            assert state == "array_first"
        self.raw("]")
        self.end_value()

    def name(self, name):
        if self.state[-1] == "object_first":
            self.state[-1] = "object"
        else:
            self.raw(",")
        self.line()
        json.dump(str(name), self.f)
        self.raw(": ")
        self.state.append("value")

    def begin_value(self):
        if self.state[-1] == "array_first":
            self.line()
            self.state[-1] = "array"
        elif self.state[-1] == "array":
            self.raw(",")
            self.line()
        else:
            assert self.state.pop() == "value"

    def end_value(self):
        if not self.state:
            print(file=self.f, flush=True)

    def value(self, value):
        self.begin_value()
        json.dump(value, self.f)
        self.end_value()

    def entry(self, name, value):
        self.name(name)
        self.value(value)

    def object(self, entries=None):
        if isinstance(entries, dict):
            entries = dict.items()
        self.begin_object()
        for name, value in entries:
            self.entry(name, value)
        self.end_object()

    def array(self, values=None):
        self.begin_array()
        for value in values:
            self.value(value)
        self.end_array()


addr_re = re.compile(r'\\\\\\[[0-9]+\\]$')
public_name_re = re.compile(r"\\\\([a-zA-Z_][a-zA-Z0-9_]*(\\[[0-9]+\\])?|\\[[0-9]+\\])$")

def pretty_name(id):
    if public_name_re.match(id):
        return id.lstrip("\\\\")
    else:
        return id

def pretty_path(path):
    out = ""
    for name in path:
        name = pretty_name(name)
        if name.startswith("["):
            out += name
            continue
        if out:
            out += "."
        if name.startswith("\\\\") or name.startswith("$"):
            out += name + " "
        else:
            out += name

    return out

@total_ordering
class WitnessSig:
    def __init__(self, path, offset, width=1, init_only=False):
        path = tuple(path)
        self.path, self.width, self.offset, self.init_only = path, width, offset, init_only

        self.memory_path = None
        self.memory_addr = None

        sort_path = path
        sort_id = -1
        if path and addr_re.match(path[-1]):
            self.memory_path = sort_path = path[:-1]
            self.memory_addr = sort_id = int(path[-1][2:-1])

        self.sort_key = (init_only, sort_path, sort_id, offset, width)

    def bits(self):
        return ((self.path, i) for i in range(self.offset, self.offset + self.width))

    def rev_bits(self):
        return ((self.path, i) for i in reversed(range(self.offset, self.offset + self.width)))

    def pretty(self):
        if self.width > 1:
            last_offset = self.offset + self.width - 1
            return f"{pretty_path(self.path)}[{last_offset}:{self.offset}]"
        else:
            return f"{pretty_path(self.path)}[{self.offset}]"

    def __eq__(self, other):
        return self.sort_key == other.sort_key

    def __hash__(self):
        return hash(self.sort_key)

    def __lt__(self, other):
        return self.sort_key < other.sort_key


def coalesce_signals(signals, bits=None):
    if bits is None:
        bits = {}
    for sig in signals:
        for bit in sig.bits():
            if sig.init_only:
                bits.setdefault(bit, False)
            else:
                bits[bit] = True

    active = None

    out = []

    for bit, not_init in sorted(bits.items()):
        if active:
            if active[0] == bit[0] and active[2] == bit[1] and active[3] == not_init:
                active[2] += 1
            else:
                out.append(WitnessSig(active[0], active[1], active[2] - active[1], not active[3]))
                active = None

        if active is None:
            active = [bit[0], bit[1], bit[1] + 1, not_init]

    if active:
        out.append(WitnessSig(active[0], active[1], active[2] - active[1], not active[3]))

    return sorted(out)


class WitnessSigMap:
    def __init__(self, signals=[]):
        self.signals = []

        self.id_to_bit = []
        self.bit_to_id = {}
        self.bit_to_sig = {}

        for sig in signals:
            self.add_signal(sig)

    def add_signal(self, sig):
        self.signals.append(sig)
        for bit in sig.bits():
            self.add_bit(bit)
            self.bit_to_sig[bit] = sig

    def add_bit(self, bit, id=None):
        if id is None:
            id = len(self.id_to_bit)
            self.id_to_bit.append(bit)
        else:
            if len(self.id_to_bit) <= id:
                self.id_to_bit += [None] * (id - len(self.id_to_bit) + 1)
            self.id_to_bit[id] = bit
        self.bit_to_id[bit] = id


class WitnessValues:
    def __init__(self):
        self.values = {}

    def __setitem__(self, key, value):
        if isinstance(key, tuple) and len(key) == 2:
            if value != "?":
                assert isinstance(value, str)
                assert len(value) == 1
                self.values[key] = value
        else:
            assert isinstance(key, WitnessSig)
            assert key.width == len(value)
            if isinstance(value, str):
                value = reversed(value)
            for bit, bit_value in zip(key.bits(), value):
                if bit_value != "?":
                    self.values[bit] = bit_value

    def __getitem__(self, key):
        if isinstance(key, tuple) and len(key) == 2:
            return self.values.get(key, "?")
        else:
            assert isinstance(key, WitnessSig)
            return "".join([self.values.get(bit, "?") for bit in key.rev_bits()])

    def pack_present(self, sigmap):
        missing = []

        max_id = max((sigmap.bit_to_id.get(bit, -1) for bit in self.values), default=-1)

        vector = ["?"] * (max_id + 1)
        for bit, bit_value in self.values.items():
            id = sigmap.bit_to_id.get(bit, - 1)
            if id < 0:
                missing.append(bit)
            else:
                vector[max_id - sigmap.bit_to_id[bit]] = bit_value

        return "".join(vector), missing

    def pack(self, sigmap):
        packed, missing = self.pack_present(sigmap)
        if missing:
            raise RuntimeError(f"Cannot pack bits {missing!r}")
        return packed

    def unpack(self, sigmap, bits):
        for i, bit_value in enumerate(reversed(bits)):
            if bit_value != "?":
                self.values[sigmap.id_to_bit[i]] = bit_value

    def present_signals(self, sigmap):
        signals = set(sigmap.bit_to_sig.get(bit) for bit in self.values)
        missing_signals = None in signals
        if missing_signals:
            signals.discard(None)

        return sorted(signals), missing_signals

    def __add__(self, other: "WitnessValues"):
        new = WitnessValues()
        new += self
        new += other
        return new

    def __iadd__(self, other: "WitnessValues"):
        for key, value in other.values.items():
            self.values.setdefault(key, value)
        return self

class WriteWitness:
    def __init__(self, f, generator):
        self.out = PrettyJson(f)
        self.t = 0
        self.header_written = False
        self.clocks = []
        self.signals = []

        self.out.begin_object()
        self.out.entry("format", "Yosys Witness Trace")
        self.out.entry("generator", generator)

    def add_clock(self, path, offset, edge):
        assert not self.header_written
        self.clocks.append({
            "path": path,
            "edge": edge,
            "offset": offset,
        })

    def add_sig(self, path, offset, width=1, init_only=False):
        assert not self.header_written
        sig = WitnessSig(path, offset, width, init_only)
        self.signals.append(sig)
        return sig

    def write_header(self):
        assert not self.header_written
        self.header_written = True
        self.out.name("clocks")
        self.out.array(self.clocks)

        self.signals = coalesce_signals(self.signals)
        self.sigmap = WitnessSigMap(self.signals)

        self.out.name("signals")
        self.out.array({
            "path": sig.path,
            "width": sig.width,
            "offset": sig.offset,
            "init_only": sig.init_only,
        } for sig in self.signals)

        self.out.name("steps")
        self.out.begin_array()

    def step(self, values, skip_x=False):
        if not self.header_written:
            self.write_header()

        packed = values.pack(self.sigmap)
        if skip_x:
            packed = packed.replace('x', '?')
        self.out.value({"bits": packed})

        self.t += 1

    def end_trace(self):
        if not self.header_written:
            self.write_header()
        self.out.end_array()
        self.out.end_object()


class ReadWitness:
    def __init__(self, f):
        data = json.load(f)
        if not isinstance(data, dict):
            data = {}

        data_format = data.get("format", "Unknown Format")

        if data_format != "Yosys Witness Trace":
            raise ValueError(f"unsupported format {data_format!r}")

        self.clocks = data["clocks"]
        for clock in self.clocks:
            clock["path"] = tuple(clock["path"])

        self.signals = [
            WitnessSig(sig["path"], sig["offset"], sig["width"], sig["init_only"])
            for sig in data["signals"]
        ]

        self.sigmap = WitnessSigMap(self.signals)

        self.bits = [step["bits"] for step in data["steps"]]

    def skip_x(self):
        self.bits = [step.replace('x', '?') for step in self.bits]

    def init_step(self):
        return self.step(0)
    
    def non_init_bits(self):
        if len(self) > 1:
            return len(self.bits[1])
        else:
            return sum([sig.width for sig in self.signals if not sig.init_only])
    
    def first_step(self):
        values = WitnessValues()
        # may have issues when non_init_bits is 0
        values.unpack(WitnessSigMap([sig for sig in self.signals if not sig.init_only]), self.bits[0][-self.non_init_bits():])
        return values

    def step(self, t):
        values = WitnessValues()
        values.unpack(self.sigmap, self.bits[t])
        return values

    def steps(self, start=0):
        for i in range(start, len(self.bits)):
            yield i, self.step(i)

    def append_steps(self, t):
        if not t:
            pass
        elif t < 0:
            self.bits = self.bits[:t]
        else:
            self.bits.extend(["0"*self.non_init_bits()]*t)

    def __len__(self):
        return len(self.bits)
`},quicklogic:{common:{"cells_sim.v":`module inv (
  output Q,
  input A
);
  assign Q = A ? 0 : 1;
endmodule

module buff (
  output Q,
  input A
);
  assign Q = A;
endmodule

module logic_0 (
  output A
);
  assign A = 0;
endmodule

module logic_1 (
  output A
);
  assign A = 1;
endmodule

module gclkbuff (
  input A,
  output Z
);
  specify
    (A => Z) = 0;
  endspecify

  assign Z = A;
endmodule
`},pp3:{"abc9_map.v":`// This file exists to map purely-synchronous flops to ABC9 flops, while 
// mapping flops with asynchronous-set/clear as boxes, this is because ABC9 
// doesn't support asynchronous-set/clear flops in sequential synthesis.

module dffepc (
  output Q,
  input D,
  input CLK,
  input EN,
  input CLR,
  input PRE
);

parameter INIT = 1'b0;

parameter _TECHMAP_CONSTMSK_CLR_ = 1'b0;
parameter _TECHMAP_CONSTMSK_PRE_ = 1'b0;
parameter _TECHMAP_CONSTVAL_CLR_ = 1'b0;
parameter _TECHMAP_CONSTVAL_PRE_ = 1'b0;

if (_TECHMAP_CONSTMSK_CLR_ != 1'b0 && _TECHMAP_CONSTMSK_PRE_ != 1'b0 && _TECHMAP_CONSTVAL_CLR_ == 1'b0 && _TECHMAP_CONSTVAL_PRE_ == 1'b0)
    $__PP3_DFFEPC_SYNCONLY _TECHMAP_REPLACE_ (.Q(Q), .D(D), .CLK(CLK), .EN(EN));
else
    wire _TECHMAP_FAIL_ = 1;

endmodule
`,"abc9_model.v":`(* abc9_flop, lib_whitebox *)
module $__PP3_DFFEPC_SYNCONLY (
  output Q,
  input D,
  input CLK,
  input EN,
);

  dffepc ff (.Q(Q), .D(D), .CLK(CLK), .EN(EN), .PRE(1'b0), .CLR(1'b0));

endmodule
`,"abc9_unmap.v":`module $__PP3_DFFEPC_SYNCONLY (
  output Q,
  input D,
  input CLK,
  input EN,
);

// For some reason ABC9 adds init attributes to wires even though they were removed before mapping.
// As a workaround, remove any init attributes that get reintroduced.
wire _TECHMAP_REMOVEINIT_Q_ = 1;

dffepc _TECHMAP_REPLACE_ (.Q(Q), .D(D), .CLK(CLK), .EN(EN), .PRE(1'b0), .CLR(1'b0));

endmodule
`,"cells_map.v":`module \\$_MUX8_ (
  A, B, C, D, E, F, G, H, S, T, U, Y
);
  input A, B, C, D, E, F, G, H, S, T, U;
  output Y;
  mux8x0 _TECHMAP_REPLACE_ (
    .A(A),
    .B(B),
    .C(C),
    .D(D),
    .E(E),
    .F(F),
    .G(G),
    .H(H),
    .S0(S),
    .S1(T),
    .S2(U),
    .Q(Y)
  );
endmodule

module \\$_MUX4_ (
  A, B, C, D, S, T, U, Y
);
  input A, B, C, D, S, T, U;
  output Y;
  mux4x0 _TECHMAP_REPLACE_ (
    .A(A),
    .B(B),
    .C(C),
    .D(D),
    .S0(S),
    .S1(T),
    .Q(Y)
  );
endmodule
`,"cells_sim.v":`module inpad (
  output Q,
  (* iopad_external_pin *)
  input P
);
  specify
    (P => Q) = 0;
  endspecify
  assign Q = P;
endmodule

module outpad (
  (* iopad_external_pin *)
  output P,
  input A
);
  specify
    (A => P) = 0;
  endspecify
  assign P = A;
endmodule

module ckpad (
  output Q,
  (* iopad_external_pin *)
  input P
);
  specify
    (P => Q) = 0;
  endspecify
  assign Q = P;
endmodule

module bipad (
  input A,
  input EN,
  output Q,
  (* iopad_external_pin *)
  inout P
);
  assign Q = P;
  assign P = EN ? A : 1'bz;
endmodule

module dff (
  output reg Q,
  input D,
  (* clkbuf_sink *)
  input CLK
);
  parameter [0:0] INIT = 1'b0;
  initial Q = INIT;
  always @(posedge CLK) Q <= D;
endmodule

module dffc (
  output reg Q,
  input D,
  (* clkbuf_sink *)
  input CLK,
  (* clkbuf_sink *)
  input CLR
);
  parameter [0:0] INIT = 1'b0;
  initial Q = INIT;

  always @(posedge CLK or posedge CLR)
    if (CLR) Q <= 1'b0;
    else Q <= D;
endmodule

module dffp (
  output reg Q,
  input D,
  (* clkbuf_sink *)
  input CLK,
  (* clkbuf_sink *)
  input PRE
);
  parameter [0:0] INIT = 1'b0;
  initial Q = INIT;

  always @(posedge CLK or posedge PRE)
    if (PRE) Q <= 1'b1;
    else Q <= D;
endmodule

module dffpc (
  output reg Q,
  input D,
  (* clkbuf_sink *)
  input CLK,
  (* clkbuf_sink *)
  input CLR,
  (* clkbuf_sink *)
  input PRE
);
  parameter [0:0] INIT = 1'b0;
  initial Q = INIT;

  always @(posedge CLK or posedge CLR or posedge PRE)
    if (CLR) Q <= 1'b0;
    else if (PRE) Q <= 1'b1;
    else Q <= D;
endmodule

module dffe (
  output reg Q,
  input D,
  (* clkbuf_sink *)
  input CLK,
  input EN
);
  parameter [0:0] INIT = 1'b0;
  initial Q = INIT;
  always @(posedge CLK) if (EN) Q <= D;
endmodule

module dffec (
  output reg Q,
  input D,
  (* clkbuf_sink *)
  input CLK,
  input EN,
  (* clkbuf_sink *)
  input CLR
);
  parameter [0:0] INIT = 1'b0;
  initial Q = INIT;

  always @(posedge CLK or posedge CLR)
    if (CLR) Q <= 1'b0;
    else if (EN) Q <= D;
endmodule

(* lib_whitebox *)
module dffepc (
  output reg Q,
  input D,
  (* clkbuf_sink *)
  input CLK,
  input EN,
  (* clkbuf_sink *)
  input CLR,
  (* clkbuf_sink *)
  input PRE
);
  parameter [0:0] INIT = 1'b0;

  specify
    if (EN) (posedge CLK => (Q : D)) = 1701; // QCK -> QZ
    if (CLR) (CLR => Q) = 967; // QRT -> QZ
    if (PRE) (PRE => Q) = 1252; // QST -> QZ
    $setup(D, posedge CLK, 216); // QCK -> QDS
    $setup(EN, posedge CLK, 590); // QCK -> QEN
  endspecify

  initial Q = INIT;
  always @(posedge CLK or posedge CLR or posedge PRE)
    if (CLR) Q <= 1'b0;
    else if (PRE) Q <= 1'b1;
    else if (EN) Q <= D;
endmodule

//                  FZ       FS F2 (F1 TO 0)
(* abc9_box, lib_whitebox *)
module AND2I0 (
  output Q,
  input A, B
);
  specify
    (A => Q) = 698; // FS -> FZ
    (B => Q) = 639; // F2 -> FZ
  endspecify

  assign Q = A ? B : 0;
endmodule

(* abc9_box, lib_whitebox *)
module mux2x0 (
  output Q,
  input S, A, B
);
  specify
    (S => Q) = 698; // FS -> FZ
    (A => Q) = 639; // F1 -> FZ
    (B => Q) = 639; // F2 -> FZ
  endspecify

  assign Q = S ? B : A;
endmodule

(* abc9_box, lib_whitebox *)
module mux2x1 (
  output Q,
  input S, A, B
);
  specify
    (S => Q) = 698; // FS -> FZ
    (A => Q) = 639; // F1 -> FZ
    (B => Q) = 639; // F2 -> FZ
  endspecify

  assign Q = S ? B : A;
endmodule

(* abc9_box, lib_whitebox *)
module mux4x0 (
  output Q,
  input S0, S1, A, B, C, D
);
  specify
    (S0 => Q) = 1251; // TAB -> TZ
    (S1 => Q) = 1406; // TSL -> TZ
    (A => Q) = 1699;  // TA1 -> TZ
    (B => Q) = 1687;  // TA2 -> TZ
    (C => Q) = 1669;  // TB1 -> TZ
    (D => Q) = 1679;  // TB2 -> TZ
  endspecify

  assign Q = S1 ? (S0 ? D : C) : (S0 ? B : A);
endmodule

// S0 BSL TSL
// S1 BAB TAB
// S2 TBS
// A TA1
// B TA2
// C TB1
// D TB2
// E BA1
// F BA2
// G BB1
// H BB2
// Q CZ
(* abc9_box, lib_whitebox *)
module mux8x0 (
  output Q,
  input S0, S1, S2, A, B, C, D, E, F, G, H
);
  specify
    (S0 => Q) = 1593; // ('TSL', 'BSL') -> CZ
    (S1 => Q) = 1437; // ('TAB', 'BAB') -> CZ
    (S2 => Q) = 995; // TBS -> CZ
    (A => Q) = 1887; // TA1 -> CZ
    (B => Q) = 1873; // TA2 -> CZ
    (C => Q) = 1856; // TB1 -> CZ
    (D => Q) = 1860; // TB2 -> CZ
    (E => Q) = 1714; // BA1 -> CZ
    (F => Q) = 1773; // BA2 -> CZ
    (G => Q) = 1749; // BB1 -> CZ
    (H => Q) = 1723; // BB2 -> CZ
  endspecify

  assign Q = S2 ? (S1 ? (S0 ? H : G) : (S0 ? F : E)) : (S1 ? (S0 ? D : C) : (S0 ? B : A));
endmodule

(* blackbox *)
(* keep *)
module qlal4s3b_cell_macro (
  input WB_CLK,
  input WBs_ACK,
  input [31:0] WBs_RD_DAT,
  output [3:0] WBs_BYTE_STB,
  output WBs_CYC,
  output WBs_WE,
  output WBs_RD,
  output WBs_STB,
  output [16:0] WBs_ADR,
  input [3:0] SDMA_Req,
  input [3:0] SDMA_Sreq,
  output [3:0] SDMA_Done,
  output [3:0] SDMA_Active,
  input [3:0] FB_msg_out,
  input [7:0] FB_Int_Clr,
  output FB_Start,
  input FB_Busy,
  output WB_RST,
  output Sys_PKfb_Rst,
  output Clk16,
  output Clk16_Rst,
  output Clk21,
  output Clk21_Rst,
  output Sys_Pclk,
  output Sys_Pclk_Rst,
  input Sys_PKfb_Clk,
  input [31:0] FB_PKfbData,
  output [31:0] WBs_WR_DAT,
  input [3:0] FB_PKfbPush,
  input FB_PKfbSOF,
  input FB_PKfbEOF,
  output [7:0] Sensor_Int,
  output FB_PKfbOverflow,
  output [23:0] TimeStamp,
  input Sys_PSel,
  input [15:0] SPIm_Paddr,
  input SPIm_PEnable,
  input SPIm_PWrite,
  input [31:0] SPIm_PWdata,
  output SPIm_PReady,
  output SPIm_PSlvErr,
  output [31:0] SPIm_Prdata,
  input [15:0] Device_ID,
  input [13:0] FBIO_In_En,
  input [13:0] FBIO_Out,
  input [13:0] FBIO_Out_En,
  output [13:0] FBIO_In,
  inout [13:0] SFBIO,
  input Device_ID_6S,
  input Device_ID_4S,
  input SPIm_PWdata_26S,
  input SPIm_PWdata_24S,
  input SPIm_PWdata_14S,
  input SPIm_PWdata_11S,
  input SPIm_PWdata_0S,
  input SPIm_Paddr_8S,
  input SPIm_Paddr_6S,
  input FB_PKfbPush_1S,
  input FB_PKfbData_31S,
  input FB_PKfbData_21S,
  input FB_PKfbData_19S,
  input FB_PKfbData_9S,
  input FB_PKfbData_6S,
  input Sys_PKfb_ClkS,
  input FB_BusyS,
  input WB_CLKS
);

endmodule

(* abc9_lut=1, lib_whitebox *)
module LUT1 (
  output O,
  input I0
);
  parameter [1:0] INIT = 0;
  parameter EQN = "(I0)";

  // These timings are for PolarPro 3E; other families will need updating.
  specify
    (I0 => O) = 698; // FS -> FZ
  endspecify

  assign O = I0 ? INIT[1] : INIT[0];
endmodule

//               TZ        TSL TAB
(* abc9_lut=2, lib_whitebox *)
module LUT2 (
  output O,
  input I0, I1
);
  parameter [3:0] INIT = 4'h0;
  parameter EQN = "(I0)";

  // These timings are for PolarPro 3E; other families will need updating.
  specify
    (I0 => O) = 1251; // TAB -> TZ
    (I1 => O) = 1406; // TSL -> TZ
  endspecify

  wire [1:0] s1 = I1 ? INIT[3:2] : INIT[1:0];
  assign O = I0 ? s1[1] : s1[0];
endmodule

(* abc9_lut=2, lib_whitebox *)
module LUT3 (
  output O,
  input I0, I1, I2
);
  parameter [7:0] INIT = 8'h0;
  parameter EQN = "(I0)";

  // These timings are for PolarPro 3E; other families will need updating.
  specify
    (I0 => O) = 1251; // TAB -> TZ
    (I1 => O) = 1406; // TSL -> TZ
    (I2 => O) = 1699; // ('TA1', 'TA2', 'TB1', 'TB2') -> TZ
  endspecify

  wire [3:0] s2 = I2 ? INIT[7:4] : INIT[3:0];
  wire [1:0] s1 = I1 ? s2[3:2] : s2[1:0];
  assign O = I0 ? s1[1] : s1[0];
endmodule

(* abc9_lut=4, lib_whitebox *)
module LUT4 (
  output O,
  input I0, I1, I2, I3
);
  parameter [15:0] INIT = 16'h0;
  parameter EQN = "(I0)";

  // These timings are for PolarPro 3E; other families will need updating.
  specify
    (I0 => O) = 995;  // TBS -> CZ
    (I1 => O) = 1437; // ('TAB', 'BAB') -> CZ
    (I2 => O) = 1593; // ('TSL', 'BSL') -> CZ
    (I3 => O) = 1887; // ('TA1', 'TA2', 'TB1', 'TB2', 'BA1', 'BA2', 'BB1', 'BB2') -> CZ
  endspecify

  wire [7:0] s3 = I3 ? INIT[15:8] : INIT[7:0];
  wire [3:0] s2 = I2 ? s3[7:4] : s3[3:0];
  wire [1:0] s1 = I1 ? s2[3:2] : s2[1:0];
  assign O = I0 ? s1[1] : s1[0];
endmodule
`,"ffs_map.v":`module \\$_DFFSRE_PPPP_ (input C, S, R, E, D, output Q);
  wire _TECHMAP_REMOVEINIT_Q_ = 1;
  dffepc #(.INIT(1'b0)) _TECHMAP_REPLACE_ (.CLK(C), .PRE(S), .CLR(R), .EN(E), .D(D), .Q(Q));
endmodule
`,"latches_map.v":`module \\$_DLATCH_P_ (E, D, Q);
  wire [1023:0] _TECHMAP_DO_ = "simplemap; opt";
  input E, D;
  output Q = E ? D : Q;
endmodule

module \\$_DLATCH_N_ (E, D, Q);
  wire [1023:0] _TECHMAP_DO_ = "simplemap; opt";
  input E, D;
  output Q = !E ? D : Q;
endmodule
`,"lut_map.v":`module \\$lut (
  A, Y
);
  parameter WIDTH = 0;
  parameter LUT = 0;

  input [WIDTH-1:0] A;
  output Y;

  generate
    if (WIDTH == 1) begin
      LUT1 #(
        .EQN(""),
        .INIT(LUT)
      ) _TECHMAP_REPLACE_ (
        .O(Y),
        .I0(A[0])
      );
    end else if (WIDTH == 2) begin
      LUT2 #(
        .EQN(""),
        .INIT(LUT)
      ) _TECHMAP_REPLACE_ (
        .O(Y),
        .I0(A[0]),
        .I1(A[1])
      );
    end else if (WIDTH == 3) begin
      LUT3 #(
        .EQN(""),
        .INIT(LUT)
      ) _TECHMAP_REPLACE_ (
        .O(Y),
        .I0(A[0]),
        .I1(A[1]),
        .I2(A[2])
      );
    end else if (WIDTH == 4) begin
      LUT4 #(
        .EQN(""),
        .INIT(LUT)
      ) _TECHMAP_REPLACE_ (
        .O(Y),
        .I0(A[0]),
        .I1(A[1]),
        .I2(A[2]),
        .I3(A[3])
      );
    end else begin
      wire _TECHMAP_FAIL_ = 1;
    end
  endgenerate
endmodule
`},qlf_k6n10f:{"TDP18K_FIFO.v":`// Copyright 2020-2022 F4PGA Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: Apache-2.0

\`default_nettype wire
module TDP18K_FIFO (
	RMODE_A_i,
	RMODE_B_i,
	WMODE_A_i,
	WMODE_B_i,
	WEN_A_i,
	WEN_B_i,
	REN_A_i,
	REN_B_i,
	CLK_A_i,
	CLK_B_i,
	BE_A_i,
	BE_B_i,
	ADDR_A_i,
	ADDR_B_i,
	WDATA_A_i,
	WDATA_B_i,
	RDATA_A_o,
	RDATA_B_o,
	EMPTY_o,
	EPO_o,
	EWM_o,
	UNDERRUN_o,
	FULL_o,
	FMO_o,
	FWM_o,
	OVERRUN_o,
	FLUSH_ni,
	FMODE_i,
);
	parameter SYNC_FIFO_i = 1'b0;
	parameter POWERDN_i = 1'b0;
	parameter SLEEP_i = 1'b0;
	parameter PROTECT_i = 1'b0;
	parameter UPAF_i = 11'b0;
	parameter UPAE_i = 11'b0;
	parameter [18*1024-1:0] INIT_i = 18431'bx;

	input wire [2:0] RMODE_A_i;
	input wire [2:0] RMODE_B_i;
	input wire [2:0] WMODE_A_i;
	input wire [2:0] WMODE_B_i;
	input wire WEN_A_i;
	input wire WEN_B_i;
	input wire REN_A_i;
	input wire REN_B_i;
	(* clkbuf_sink *)
	input wire CLK_A_i;
	(* clkbuf_sink *)
	input wire CLK_B_i;
	input wire [1:0] BE_A_i;
	input wire [1:0] BE_B_i;
	input wire [13:0] ADDR_A_i;
	input wire [13:0] ADDR_B_i;
	input wire [17:0] WDATA_A_i;
	input wire [17:0] WDATA_B_i;
	output reg [17:0] RDATA_A_o;
	output reg [17:0] RDATA_B_o;
	output wire EMPTY_o;
	output wire EPO_o;
	output wire EWM_o;
	output wire UNDERRUN_o;
	output wire FULL_o;
	output wire FMO_o;
	output wire FWM_o;
	output wire OVERRUN_o;
	input wire FLUSH_ni;
	input wire FMODE_i;
	reg [17:0] wmsk_a;
	reg [17:0] wmsk_b;
	wire [8:0] addr_a;
	wire [8:0] addr_b;
	reg [4:0] addr_a_d;
	reg [4:0] addr_b_d;
	wire [17:0] ram_rdata_a;
	wire [17:0] ram_rdata_b;
	reg [17:0] aligned_wdata_a;
	reg [17:0] aligned_wdata_b;
	wire ren_o;
	wire [10:0] ff_raddr;
	wire [10:0] ff_waddr;
	wire [13:0] ram_addr_a;
	wire [13:0] ram_addr_b;
	wire [3:0] ram_waddr_a;
	wire [3:0] ram_waddr_b;
	wire initn;
	wire smux_rclk;
	wire smux_wclk;
	wire real_fmode;
	wire [3:0] raw_fflags;
	reg [1:0] fifo_rmode;
	reg [1:0] fifo_wmode;
	wire smux_clk_a;
	wire smux_clk_b;
	wire ram_ren_a;
	wire ram_ren_b;
	wire ram_wen_a;
	wire ram_wen_b;
	wire cen_a;
	wire cen_b;
	wire cen_a_n;
	wire cen_b_n;
	wire ram_wen_a_n;
	wire ram_wen_b_n;
	localparam MODE_9 = 3'b001;
	always @(*) begin
		fifo_rmode = (RMODE_B_i == MODE_9 ? 2'b10 : 2'b01);
		fifo_wmode = (WMODE_A_i == MODE_9 ? 2'b10 : 2'b01);
	end
	assign smux_clk_a = CLK_A_i;
	assign smux_clk_b = CLK_B_i;
	assign real_fmode = FMODE_i;
	assign ram_ren_b = real_fmode ? ren_o : REN_B_i;
	assign ram_wen_a = FMODE_i ? ~FULL_o & WEN_A_i : WEN_A_i;
	assign ram_ren_a = FMODE_i ? 0 : REN_A_i;
	assign ram_wen_b = FMODE_i ? 1'b0 : WEN_B_i;
	assign cen_b = ram_ren_b | ram_wen_b;
	assign cen_a = ram_ren_a | ram_wen_a;
	assign ram_waddr_b = real_fmode ? {ff_raddr[0], 3'b000} : ADDR_B_i[3:0];
	assign ram_waddr_a = real_fmode ? {ff_waddr[0], 3'b000} : ADDR_A_i[3:0];
	assign ram_addr_b = real_fmode ? {ff_raddr[10:0], 3'h0} : {ADDR_B_i[13:4], addr_b_d[3:0]};
	assign ram_addr_a = real_fmode ? {ff_waddr[10:0], 3'h0} : {ADDR_A_i[13:4], addr_a_d[3:0]};
	always @(posedge CLK_A_i) addr_a_d[3:0] <= ADDR_A_i[3:0];
	always @(posedge CLK_B_i) addr_b_d[3:0] <= ADDR_B_i[3:0];
	assign cen_a_n = ~cen_a;
	assign ram_wen_a_n = ~ram_wen_a;
	assign cen_b_n = ~cen_b;
	assign ram_wen_b_n = ~ram_wen_b;

	sram1024x18 #(
		.init(INIT_i)
	) uram(
		.clk_a(smux_clk_a),
		.cen_a(cen_a_n),
		.wen_a(ram_wen_a_n),
		.addr_a(ram_addr_a[13:4]),
		.wmsk_a(wmsk_a),
		.wdata_a(aligned_wdata_a),
		.rdata_a(ram_rdata_a),
		.clk_b(smux_clk_b),
		.cen_b(cen_b_n),
		.wen_b(ram_wen_b_n),
		.addr_b(ram_addr_b[13:4]),
		.wmsk_b(wmsk_b),
		.wdata_b(aligned_wdata_b),
		.rdata_b(ram_rdata_b)
	);
	fifo_ctl #(
		.ADDR_WIDTH(11),
		.FIFO_WIDTH(2),
		.DEPTH(6)
	) fifo_ctl(
		.rclk(smux_clk_b),
		.rst_R_n(FLUSH_ni),
		.wclk(smux_clk_a),
		.rst_W_n(FLUSH_ni),
		.ren(REN_B_i),
		.wen(ram_wen_a),
		.sync(SYNC_FIFO_i),
		.rmode(fifo_rmode),
		.wmode(fifo_wmode),
		.ren_o(ren_o),
		.fflags({FULL_o, FMO_o, FWM_o, OVERRUN_o, EMPTY_o, EPO_o, EWM_o, UNDERRUN_o}),
		.raddr(ff_raddr),
		.waddr(ff_waddr),
		.upaf(UPAF_i),
		.upae(UPAE_i)
	);
	localparam MODE_1 = 3'b101;
	localparam MODE_18 = 3'b010;
	localparam MODE_2 = 3'b110;
	localparam MODE_4 = 3'b100;
	always @(*) begin : WDATA_MODE_SEL
		if (ram_wen_a == 1) begin
			case (WMODE_A_i)
				MODE_18: begin
					aligned_wdata_a = WDATA_A_i;
					{wmsk_a[17], wmsk_a[15:8]} = (FMODE_i ? 9'h000 : (BE_A_i[1] ? 9'h000 : 9'h1ff));
					{wmsk_a[16], wmsk_a[7:0]} = (FMODE_i ? 9'h000 : (BE_A_i[0] ? 9'h000 : 9'h1ff));
				end
				MODE_9: begin
					aligned_wdata_a = {{2 {WDATA_A_i[16]}}, {2 {WDATA_A_i[7:0]}}};
					{wmsk_a[17], wmsk_a[15:8]} = (ram_waddr_a[3] ? 9'h000 : 9'h1ff);
					{wmsk_a[16], wmsk_a[7:0]} = (ram_waddr_a[3] ? 9'h1ff : 9'h000);
				end
				MODE_4: begin
					aligned_wdata_a = {2'b00, {4 {WDATA_A_i[3:0]}}};
					wmsk_a[17:16] = 2'b00;
					wmsk_a[15:12] = (ram_waddr_a[3:2] == 2'b11 ? 4'h0 : 4'hf);
					wmsk_a[11:8] = (ram_waddr_a[3:2] == 2'b10 ? 4'h0 : 4'hf);
					wmsk_a[7:4] = (ram_waddr_a[3:2] == 2'b01 ? 4'h0 : 4'hf);
					wmsk_a[3:0] = (ram_waddr_a[3:2] == 2'b00 ? 4'h0 : 4'hf);
				end
				MODE_2: begin
					aligned_wdata_a = {2'b00, {8 {WDATA_A_i[1:0]}}};
					wmsk_a[17:16] = 2'b00;
					wmsk_a[15:14] = (ram_waddr_a[3:1] == 3'b111 ? 2'h0 : 2'h3);
					wmsk_a[13:12] = (ram_waddr_a[3:1] == 3'b110 ? 2'h0 : 2'h3);
					wmsk_a[11:10] = (ram_waddr_a[3:1] == 3'b101 ? 2'h0 : 2'h3);
					wmsk_a[9:8] = (ram_waddr_a[3:1] == 3'b100 ? 2'h0 : 2'h3);
					wmsk_a[7:6] = (ram_waddr_a[3:1] == 3'b011 ? 2'h0 : 2'h3);
					wmsk_a[5:4] = (ram_waddr_a[3:1] == 3'b010 ? 2'h0 : 2'h3);
					wmsk_a[3:2] = (ram_waddr_a[3:1] == 3'b001 ? 2'h0 : 2'h3);
					wmsk_a[1:0] = (ram_waddr_a[3:1] == 3'b000 ? 2'h0 : 2'h3);
				end
				MODE_1: begin
					aligned_wdata_a = {2'b00, {16 {WDATA_A_i[0]}}};
					wmsk_a = 18'h0ffff;
					wmsk_a[{1'b0, ram_waddr_a[3:0]}] = 0;
				end
				default: wmsk_a = 18'h3ffff;
			endcase
		end
		else begin
			aligned_wdata_a = 18'h00000;
			wmsk_a = 18'h3ffff;
		end
		if (ram_wen_b == 1)
			case (WMODE_B_i)
				MODE_18: begin
					aligned_wdata_b = WDATA_B_i;
					{wmsk_b[17], wmsk_b[15:8]} = (BE_B_i[1] ? 9'h000 : 9'h1ff);
					{wmsk_b[16], wmsk_b[7:0]} = (BE_B_i[0] ? 9'h000 : 9'h1ff);
				end
				MODE_9: begin
					aligned_wdata_b = {{2 {WDATA_B_i[16]}}, {2 {WDATA_B_i[7:0]}}};
					{wmsk_b[17], wmsk_b[15:8]} = (ram_waddr_b[3] ? 9'h000 : 9'h1ff);
					{wmsk_b[16], wmsk_b[7:0]} = (ram_waddr_b[3] ? 9'h1ff : 9'h000);
				end
				MODE_4: begin
					aligned_wdata_b = {2'b00, {4 {WDATA_B_i[3:0]}}};
					wmsk_b[17:16] = 2'b00;
					wmsk_b[15:12] = (ram_waddr_b[3:2] == 2'b11 ? 4'h0 : 4'hf);
					wmsk_b[11:8] = (ram_waddr_b[3:2] == 2'b10 ? 4'h0 : 4'hf);
					wmsk_b[7:4] = (ram_waddr_b[3:2] == 2'b01 ? 4'h0 : 4'hf);
					wmsk_b[3:0] = (ram_waddr_b[3:2] == 2'b00 ? 4'h0 : 4'hf);
				end
				MODE_2: begin
					aligned_wdata_b = {2'b00, {8 {WDATA_B_i[1:0]}}};
					wmsk_b[17:16] = 2'b00;
					wmsk_b[15:14] = (ram_waddr_b[3:1] == 3'b111 ? 2'h0 : 2'h3);
					wmsk_b[13:12] = (ram_waddr_b[3:1] == 3'b110 ? 2'h0 : 2'h3);
					wmsk_b[11:10] = (ram_waddr_b[3:1] == 3'b101 ? 2'h0 : 2'h3);
					wmsk_b[9:8] = (ram_waddr_b[3:1] == 3'b100 ? 2'h0 : 2'h3);
					wmsk_b[7:6] = (ram_waddr_b[3:1] == 3'b011 ? 2'h0 : 2'h3);
					wmsk_b[5:4] = (ram_waddr_b[3:1] == 3'b010 ? 2'h0 : 2'h3);
					wmsk_b[3:2] = (ram_waddr_b[3:1] == 3'b001 ? 2'h0 : 2'h3);
					wmsk_b[1:0] = (ram_waddr_b[3:1] == 3'b000 ? 2'h0 : 2'h3);
				end
				MODE_1: begin
					aligned_wdata_b = {2'b00, {16 {WDATA_B_i[0]}}};
					wmsk_b = 18'h0ffff;
					wmsk_b[{1'b0, ram_waddr_b[3:0]}] = 0;
				end
				default: wmsk_b = 18'h3ffff;
			endcase
		else begin
			aligned_wdata_b = 18'b000000000000000000;
			wmsk_b = 18'h3ffff;
		end
	end
	always @(*) begin : RDATA_A_MODE_SEL
		case (RMODE_A_i)
			default: RDATA_A_o = 18'h00000;
			MODE_18: RDATA_A_o = ram_rdata_a;
			MODE_9: begin
				{RDATA_A_o[17], RDATA_A_o[15:8]} = 9'h000;
				{RDATA_A_o[16], RDATA_A_o[7:0]} = (ram_addr_a[3] ? {ram_rdata_a[17], ram_rdata_a[15:8]} : {ram_rdata_a[16], ram_rdata_a[7:0]});
			end
			MODE_4: begin
				RDATA_A_o[17:4] = 14'h0000;
				case (ram_addr_a[3:2])
					3: RDATA_A_o[3:0] = ram_rdata_a[15:12];
					2: RDATA_A_o[3:0] = ram_rdata_a[11:8];
					1: RDATA_A_o[3:0] = ram_rdata_a[7:4];
					0: RDATA_A_o[3:0] = ram_rdata_a[3:0];
				endcase
			end
			MODE_2: begin
				RDATA_A_o[17:2] = 16'h0000;
				case (ram_addr_a[3:1])
					7: RDATA_A_o[1:0] = ram_rdata_a[15:14];
					6: RDATA_A_o[1:0] = ram_rdata_a[13:12];
					5: RDATA_A_o[1:0] = ram_rdata_a[11:10];
					4: RDATA_A_o[1:0] = ram_rdata_a[9:8];
					3: RDATA_A_o[1:0] = ram_rdata_a[7:6];
					2: RDATA_A_o[1:0] = ram_rdata_a[5:4];
					1: RDATA_A_o[1:0] = ram_rdata_a[3:2];
					0: RDATA_A_o[1:0] = ram_rdata_a[1:0];
				endcase
			end
			MODE_1: begin
				RDATA_A_o[17:1] = 17'h00000;
				RDATA_A_o[0] = ram_rdata_a[ram_addr_a[3:0]];
			end
		endcase
	end
	always @(*)
		case (RMODE_B_i)
			default: RDATA_B_o = 18'h15566;
			MODE_18: RDATA_B_o = ram_rdata_b;
			MODE_9: begin
				{RDATA_B_o[17], RDATA_B_o[15:8]} = 9'b000000000;
				{RDATA_B_o[16], RDATA_B_o[7:0]} = (ram_addr_b[3] ? {ram_rdata_b[17], ram_rdata_b[15:8]} : {ram_rdata_b[16], ram_rdata_b[7:0]});
			end
			MODE_4:
				case (ram_addr_b[3:2])
					3: RDATA_B_o[3:0] = ram_rdata_b[15:12];
					2: RDATA_B_o[3:0] = ram_rdata_b[11:8];
					1: RDATA_B_o[3:0] = ram_rdata_b[7:4];
					0: RDATA_B_o[3:0] = ram_rdata_b[3:0];
				endcase
			MODE_2:
				case (ram_addr_b[3:1])
					7: RDATA_B_o[1:0] = ram_rdata_b[15:14];
					6: RDATA_B_o[1:0] = ram_rdata_b[13:12];
					5: RDATA_B_o[1:0] = ram_rdata_b[11:10];
					4: RDATA_B_o[1:0] = ram_rdata_b[9:8];
					3: RDATA_B_o[1:0] = ram_rdata_b[7:6];
					2: RDATA_B_o[1:0] = ram_rdata_b[5:4];
					1: RDATA_B_o[1:0] = ram_rdata_b[3:2];
					0: RDATA_B_o[1:0] = ram_rdata_b[1:0];
				endcase
			MODE_1: RDATA_B_o[0] = ram_rdata_b[{1'b0, ram_addr_b[3:0]}];
		endcase
endmodule
\`default_nettype none
`,"arith_map.v":`// Copyright 2020-2022 F4PGA Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: Apache-2.0
(* techmap_celltype = "$alu" *)
module _80_quicklogic_alu (A, B, CI, BI, X, Y, CO);
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;
	parameter A_WIDTH = 2;
	parameter B_WIDTH = 2;
	parameter Y_WIDTH = 2;
	parameter _TECHMAP_CONSTVAL_CI_ = 0;
	parameter _TECHMAP_CONSTMSK_CI_ = 0;

	(* force_downto *)
	input [A_WIDTH-1:0] A;
	(* force_downto *)
	input [B_WIDTH-1:0] B;
	(* force_downto *)
	output [Y_WIDTH-1:0] X, Y;

	input CI, BI;
	(* force_downto *)
	output [Y_WIDTH-1:0] CO;


	wire _TECHMAP_FAIL_ = Y_WIDTH <= 2;

	(* force_downto *)
	wire [Y_WIDTH-1:0] A_buf, B_buf;
	\\$pos #(.A_SIGNED(A_SIGNED), .A_WIDTH(A_WIDTH), .Y_WIDTH(Y_WIDTH)) A_conv (.A(A), .Y(A_buf));
	\\$pos #(.A_SIGNED(B_SIGNED), .A_WIDTH(B_WIDTH), .Y_WIDTH(Y_WIDTH)) B_conv (.A(B), .Y(B_buf));

	(* force_downto *)
	wire [Y_WIDTH-1:0] AA = A_buf;
	(* force_downto *)
	wire [Y_WIDTH-1:0] BB = BI ? ~B_buf : B_buf;

	genvar i;
	wire co;

	(* force_downto *)
	//wire [Y_WIDTH-1:0] C = {CO, CI};
	wire [Y_WIDTH:0] C;
	(* force_downto *)
	wire [Y_WIDTH-1:0] S  = {AA ^ BB};
	assign CO[Y_WIDTH-1:0] = C[Y_WIDTH:1];
		//assign CO[Y_WIDTH-1] = co;

	generate
		adder_carry intermediate_adder (
			.cin     ( ),
			.cout    (C[0]),
			.p       (1'b0),
			.g       (CI),
			.sumout  ()
		);
	endgenerate
	genvar i;
	generate if (Y_WIDTH > 2) begin
	  for (i = 0; i < Y_WIDTH-2; i = i + 1) begin:slice
		adder_carry  my_adder (
			.cin     (C[i]),
			.g       (AA[i]),
			.p       (S[i]),
			.cout    (C[i+1]),
			.sumout  (Y[i])
		);
		  end
	end endgenerate
	generate
		adder_carry final_adder (
			.cin     (C[Y_WIDTH-2]),
			.cout    (),
			.p       (1'b0),
			.g       (1'b0),
			.sumout  (co)
		);
	endgenerate

	assign Y[Y_WIDTH-2] = S[Y_WIDTH-2] ^ co;
	assign C[Y_WIDTH-1] = S[Y_WIDTH-2] ? co : AA[Y_WIDTH-2];
	assign Y[Y_WIDTH-1] = S[Y_WIDTH-1] ^ C[Y_WIDTH-1];
	assign C[Y_WIDTH] = S[Y_WIDTH-1] ? C[Y_WIDTH-1] : AA[Y_WIDTH-1];

	assign X = S;
endmodule

`,"bram_types_sim.v":new URL("./bram_types_sim-8db658f0.v?hash=8db658f0",import.meta.url),"brams_map.v":`// Copyright 2020-2022 F4PGA Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: Apache-2.0

module RAM_36K_BLK (
		WEN_i,
		REN_i,
		WR_CLK_i,
		RD_CLK_i,
		WR_BE_i,
		WR_ADDR_i,
		RD_ADDR_i,
		WDATA_i,
		RDATA_o
);

parameter WR_ADDR_WIDTH = 10;
parameter RD_ADDR_WIDTH = 10;
parameter WR_DATA_WIDTH = 36;
parameter RD_DATA_WIDTH = 36;
parameter BE_WIDTH = 4;

parameter INIT = 0;

input wire WEN_i;
input wire REN_i;
input wire WR_CLK_i;
input wire RD_CLK_i;
input wire [BE_WIDTH-1:0] WR_BE_i;
input wire [WR_ADDR_WIDTH-1 :0] WR_ADDR_i;
input wire [RD_ADDR_WIDTH-1 :0] RD_ADDR_i;
input wire [WR_DATA_WIDTH-1 :0] WDATA_i;
output wire [RD_DATA_WIDTH-1 :0] RDATA_o;

// Fixed mode settings
localparam [ 0:0] SYNC_FIFO1_i  = 1'd0;
localparam [ 0:0] FMODE1_i      = 1'd0;
localparam [ 0:0] POWERDN1_i    = 1'd0;
localparam [ 0:0] SLEEP1_i      = 1'd0;
localparam [ 0:0] PROTECT1_i    = 1'd0;
localparam [11:0] UPAE1_i       = 12'd10;
localparam [11:0] UPAF1_i       = 12'd10;

localparam [ 0:0] SYNC_FIFO2_i  = 1'd0;
localparam [ 0:0] FMODE2_i      = 1'd0;
localparam [ 0:0] POWERDN2_i    = 1'd0;
localparam [ 0:0] SLEEP2_i      = 1'd0;
localparam [ 0:0] PROTECT2_i    = 1'd0;
localparam [10:0] UPAE2_i       = 11'd10;
localparam [10:0] UPAF2_i       = 11'd10;

// Width mode function
function [2:0] mode;
input integer width;
case (width)
1: mode = 3'b101;
2: mode = 3'b110;
4: mode = 3'b100;
8,9: mode = 3'b001;
16, 18: mode = 3'b010;
32, 36: mode = 3'b011;
default: mode = 3'b000;
endcase
endfunction

function integer rwmode;
input integer rwwidth;
case (rwwidth)
1: rwmode = 1;
2: rwmode = 2;
4: rwmode = 4;
8,9: rwmode = 9;
16, 18: rwmode = 18;
32, 36: rwmode = 36;
default: rwmode = 36;
endcase
endfunction

wire REN_A1_i;
wire REN_A2_i;

wire REN_B1_i;
wire REN_B2_i;

wire WEN_A1_i;
wire WEN_A2_i;

wire WEN_B1_i;
wire WEN_B2_i;

wire [1:0] BE_A1_i;
wire [1:0] BE_A2_i;

wire [1:0] BE_B1_i;
wire [1:0] BE_B2_i;

wire [14:0] ADDR_A1_i;
wire [13:0] ADDR_A2_i;

wire [14:0] ADDR_B1_i;
wire [13:0] ADDR_B2_i;

wire [17:0] WDATA_A1_i;
wire [17:0] WDATA_A2_i;

wire [17:0] WDATA_B1_i;
wire [17:0] WDATA_B2_i;

wire [17:0] RDATA_A1_o;
wire [17:0] RDATA_A2_o;

wire [17:0] RDATA_B1_o;
wire [17:0] RDATA_B2_o;

wire [3:0] WR_BE;

wire [35:0] PORT_B_RDATA;
wire [35:0] PORT_A_WDATA;

wire [14:0] WR_ADDR_INT;
wire [14:0] RD_ADDR_INT;

wire [14:0] PORT_A_ADDR;
wire [14:0] PORT_B_ADDR;

wire PORT_A_CLK;
wire PORT_B_CLK;

// Set port width mode (In non-split mode A2/B2 is not active. Set same values anyway to match previous behavior.)
localparam [ 2:0] RMODE_A1_i    = mode(WR_DATA_WIDTH);
localparam [ 2:0] WMODE_A1_i    = mode(WR_DATA_WIDTH);
localparam [ 2:0] RMODE_A2_i    = mode(WR_DATA_WIDTH);
localparam [ 2:0] WMODE_A2_i    = mode(WR_DATA_WIDTH);

localparam [ 2:0] RMODE_B1_i    = mode(RD_DATA_WIDTH);
localparam [ 2:0] WMODE_B1_i    = mode(RD_DATA_WIDTH);
localparam [ 2:0] RMODE_B2_i    = mode(RD_DATA_WIDTH);
localparam [ 2:0] WMODE_B2_i    = mode(RD_DATA_WIDTH);

localparam PORT_A_WRWIDTH = rwmode(WR_DATA_WIDTH);
localparam PORT_B_WRWIDTH = rwmode(RD_DATA_WIDTH);

assign PORT_A_CLK = WR_CLK_i;
assign PORT_B_CLK = RD_CLK_i;

generate
	if (WR_ADDR_WIDTH == 15) begin
		assign WR_ADDR_INT = WR_ADDR_i;
	end else begin
		assign WR_ADDR_INT[14:WR_ADDR_WIDTH] = 0;
		assign WR_ADDR_INT[WR_ADDR_WIDTH-1:0] = WR_ADDR_i;
	end
endgenerate

case (WR_DATA_WIDTH)
	1: begin
		assign PORT_A_ADDR = WR_ADDR_INT;
	end
	2: begin
		assign PORT_A_ADDR = WR_ADDR_INT << 1;
	end
	4: begin
		assign PORT_A_ADDR = WR_ADDR_INT << 2;
	end
	8, 9: begin
		assign PORT_A_ADDR = WR_ADDR_INT << 3;
	end
	16, 18: begin
		assign PORT_A_ADDR = WR_ADDR_INT << 4;
	end
	32, 36: begin
		assign PORT_A_ADDR = WR_ADDR_INT << 5;
	end
	default: begin
		assign PORT_A_ADDR = WR_ADDR_INT;
	end
endcase

generate
	if (RD_ADDR_WIDTH == 15) begin
		assign RD_ADDR_INT = RD_ADDR_i;
	end else begin
		assign RD_ADDR_INT[14:RD_ADDR_WIDTH] = 0;
		assign RD_ADDR_INT[RD_ADDR_WIDTH-1:0] = RD_ADDR_i;
	end
endgenerate

case (RD_DATA_WIDTH)
	1: begin
		assign PORT_B_ADDR = RD_ADDR_INT;
	end
	2: begin
		assign PORT_B_ADDR = RD_ADDR_INT << 1;
	end
	4: begin
		assign PORT_B_ADDR = RD_ADDR_INT << 2;
	end
	8, 9: begin
		assign PORT_B_ADDR = RD_ADDR_INT << 3;
	end
	16, 18: begin
		assign PORT_B_ADDR = RD_ADDR_INT << 4;
	end
	32, 36: begin
		assign PORT_B_ADDR = RD_ADDR_INT << 5;
	end
	default: begin
		assign PORT_B_ADDR = RD_ADDR_INT;
	end
endcase

case (BE_WIDTH)
	4: begin
		assign WR_BE = WR_BE_i[BE_WIDTH-1 :0];
	end
	default: begin
		assign WR_BE[3:BE_WIDTH] = 0;
		assign WR_BE[BE_WIDTH-1 :0] = WR_BE_i[BE_WIDTH-1 :0];
	end
endcase

assign REN_A1_i = 1'b0;
assign WEN_A1_i = WEN_i;
assign {BE_A2_i, BE_A1_i} = WR_BE;

assign REN_B1_i = REN_i;
assign WEN_B1_i = 1'b0;
assign {BE_B2_i, BE_B1_i} = 4'h0;

generate
	if (WR_DATA_WIDTH == 36) begin
		assign PORT_A_WDATA[WR_DATA_WIDTH-1:0] = WDATA_i[WR_DATA_WIDTH-1:0];
	end else if (WR_DATA_WIDTH > 18 && WR_DATA_WIDTH < 36) begin
		assign PORT_A_WDATA[WR_DATA_WIDTH+1:18]  = WDATA_i[WR_DATA_WIDTH-1:16];
		assign PORT_A_WDATA[17:0] = {2'b00,WDATA_i[15:0]};
	end else if (WR_DATA_WIDTH == 9) begin
		assign PORT_A_WDATA = {19'h0, WDATA_i[8], 8'h0, WDATA_i[7:0]};
	end else begin
		assign PORT_A_WDATA[35:WR_DATA_WIDTH] = 0;
		assign PORT_A_WDATA[WR_DATA_WIDTH-1:0] = WDATA_i[WR_DATA_WIDTH-1:0];
	end
endgenerate

assign WDATA_A1_i = PORT_A_WDATA[17:0];
assign WDATA_A2_i = PORT_A_WDATA[35:18];

assign WDATA_B1_i = 18'h0;
assign WDATA_B2_i = 18'h0;

generate
	if (RD_DATA_WIDTH == 36) begin
		assign PORT_B_RDATA = {RDATA_B2_o, RDATA_B1_o};
	end else if (RD_DATA_WIDTH > 18 && RD_DATA_WIDTH < 36) begin
		assign PORT_B_RDATA  = {2'b00,RDATA_B2_o[17:0],RDATA_B1_o[15:0]};
	end else if (RD_DATA_WIDTH == 9) begin
		assign PORT_B_RDATA = { 27'h0, RDATA_B1_o[16], RDATA_B1_o[7:0]};
	end else begin
		assign PORT_B_RDATA = {18'h0, RDATA_B1_o};
	end
endgenerate

assign RDATA_o = PORT_B_RDATA[RD_DATA_WIDTH-1:0];

defparam _TECHMAP_REPLACE_.MODE_BITS = { 1'b0,
	UPAF2_i, UPAE2_i, PROTECT2_i, SLEEP2_i, POWERDN2_i, FMODE2_i, WMODE_B2_i, WMODE_A2_i, RMODE_B2_i, RMODE_A2_i, SYNC_FIFO2_i,
	UPAF1_i, UPAE1_i, PROTECT1_i, SLEEP1_i, POWERDN1_i, FMODE1_i, WMODE_B1_i, WMODE_A1_i, RMODE_B1_i, RMODE_A1_i, SYNC_FIFO1_i
};


(* is_inferred = 0 *)
(* is_split = 0 *)
(* is_fifo = 0 *)
(* port_a_dwidth = PORT_A_WRWIDTH *)
(* port_b_dwidth = PORT_B_WRWIDTH *)
TDP36K _TECHMAP_REPLACE_ (
	.RESET_ni(1'b1),

	.CLK_A1_i(PORT_A_CLK),
	.ADDR_A1_i(PORT_A_ADDR),
	.WEN_A1_i(WEN_A1_i),
	.BE_A1_i(BE_A1_i),
	.WDATA_A1_i(WDATA_A1_i),
	.REN_A1_i(REN_A1_i),
	.RDATA_A1_o(RDATA_A1_o),

	.CLK_A2_i(PORT_A_CLK),
	.ADDR_A2_i(PORT_A_ADDR[13:0]),
	.WEN_A2_i(WEN_A1_i),
	.BE_A2_i(BE_A2_i),
	.WDATA_A2_i(WDATA_A2_i),
	.REN_A2_i(REN_A1_i),
	.RDATA_A2_o(RDATA_A2_o),

	.CLK_B1_i(PORT_B_CLK),
	.ADDR_B1_i(PORT_B_ADDR),
	.WEN_B1_i(WEN_B1_i),
	.BE_B1_i(BE_B1_i),
	.WDATA_B1_i(WDATA_B1_i),
	.REN_B1_i(REN_B1_i),
	.RDATA_B1_o(RDATA_B1_o),

	.CLK_B2_i(PORT_B_CLK),
	.ADDR_B2_i(PORT_B_ADDR[13:0]),
	.WEN_B2_i(WEN_B1_i),
	.BE_B2_i(BE_B2_i),
	.WDATA_B2_i(WDATA_B2_i),
	.REN_B2_i(REN_B1_i),
	.RDATA_B2_o(RDATA_B2_o),

	.FLUSH1_i(1'b0),
	.FLUSH2_i(1'b0)
);

endmodule

module RAM_18K_BLK (
		WEN_i,
		REN_i,
		WR_CLK_i,
		RD_CLK_i,
		WR_BE_i,
		WR_ADDR_i,
		RD_ADDR_i,
		WDATA_i,
		RDATA_o
);

parameter WR_ADDR_WIDTH = 10;
parameter RD_ADDR_WIDTH = 10;
parameter WR_DATA_WIDTH = 18;
parameter RD_DATA_WIDTH = 18;
parameter BE_WIDTH = 2;

input wire WEN_i;
input wire REN_i;
input wire WR_CLK_i;
input wire RD_CLK_i;
input wire [BE_WIDTH-1:0] WR_BE_i;
input wire [WR_ADDR_WIDTH-1 :0] WR_ADDR_i;
input wire [RD_ADDR_WIDTH-1 :0] RD_ADDR_i;
input wire [WR_DATA_WIDTH-1 :0] WDATA_i;
output wire [RD_DATA_WIDTH-1 :0] RDATA_o;

	(* is_inferred = 0 *)
	(* is_split = 0 *)
	(* is_fifo = 0 *)
	BRAM2x18_SP  #(
			.WR1_ADDR_WIDTH(WR_ADDR_WIDTH),
			.RD1_ADDR_WIDTH(RD_ADDR_WIDTH),
			.WR1_DATA_WIDTH(WR_DATA_WIDTH),
			.RD1_DATA_WIDTH(RD_DATA_WIDTH),
			.BE1_WIDTH(BE_WIDTH),
			.WR2_ADDR_WIDTH(),
			.RD2_ADDR_WIDTH(),
			.WR2_DATA_WIDTH(),
			.RD2_DATA_WIDTH(),
			.BE2_WIDTH()
			 ) U1
			(
			.RESET_ni(1'b1),

			.WEN1_i(WEN_i),
			.REN1_i(REN_i),
			.WR1_CLK_i(WR_CLK_i),
			.RD1_CLK_i(RD_CLK_i),
			.WR1_BE_i(WR_BE_i),
			.WR1_ADDR_i(WR_ADDR_i),
			.RD1_ADDR_i(RD_ADDR_i),
			.WDATA1_i(WDATA_i),
			.RDATA1_o(RDATA_o),

			.WEN2_i(1'b0),
			.REN2_i(1'b0),
			.WR2_CLK_i(1'b0),
			.RD2_CLK_i(1'b0),
			.WR2_BE_i(2'b00),
			.WR2_ADDR_i(14'h0),
			.RD2_ADDR_i(14'h0),
			.WDATA2_i(18'h0),
			.RDATA2_o()
			);

endmodule

module RAM_18K_X2_BLK (
		RESET_ni,

		WEN1_i,
		REN1_i,
		WR1_CLK_i,
		RD1_CLK_i,
		WR1_BE_i,
		WR1_ADDR_i,
		RD1_ADDR_i,
		WDATA1_i,
		RDATA1_o,

		WEN2_i,
		REN2_i,
		WR2_CLK_i,
		RD2_CLK_i,
		WR2_BE_i,
		WR2_ADDR_i,
		RD2_ADDR_i,
		WDATA2_i,
		RDATA2_o
);

parameter WR1_ADDR_WIDTH = 10;
parameter RD1_ADDR_WIDTH = 10;
parameter WR1_DATA_WIDTH = 18;
parameter RD1_DATA_WIDTH = 18;
parameter BE1_WIDTH = 2;

parameter WR2_ADDR_WIDTH = 10;
parameter RD2_ADDR_WIDTH = 10;
parameter WR2_DATA_WIDTH = 18;
parameter RD2_DATA_WIDTH = 18;
parameter BE2_WIDTH = 2;

input wire RESET_ni;

input wire WEN1_i;
input wire REN1_i;
input wire WR1_CLK_i;
input wire RD1_CLK_i;
input wire [BE1_WIDTH-1:0] WR1_BE_i;
input wire [WR1_ADDR_WIDTH-1 :0] WR1_ADDR_i;
input wire [RD1_ADDR_WIDTH-1 :0] RD1_ADDR_i;
input wire [WR1_DATA_WIDTH-1 :0] WDATA1_i;
output wire [RD1_DATA_WIDTH-1 :0] RDATA1_o;

input wire WEN2_i;
input wire REN2_i;
input wire WR2_CLK_i;
input wire RD2_CLK_i;
input wire [BE2_WIDTH-1:0] WR2_BE_i;
input wire [WR2_ADDR_WIDTH-1 :0] WR2_ADDR_i;
input wire [RD2_ADDR_WIDTH-1 :0] RD2_ADDR_i;
input wire [WR2_DATA_WIDTH-1 :0] WDATA2_i;
output wire [RD2_DATA_WIDTH-1 :0] RDATA2_o;

// Fixed mode settings
localparam [ 0:0] SYNC_FIFO1_i  = 1'd0;
localparam [ 0:0] FMODE1_i      = 1'd0;
localparam [ 0:0] POWERDN1_i    = 1'd0;
localparam [ 0:0] SLEEP1_i      = 1'd0;
localparam [ 0:0] PROTECT1_i    = 1'd0;
localparam [11:0] UPAE1_i       = 12'd10;
localparam [11:0] UPAF1_i       = 12'd10;

localparam [ 0:0] SYNC_FIFO2_i  = 1'd0;
localparam [ 0:0] FMODE2_i      = 1'd0;
localparam [ 0:0] POWERDN2_i    = 1'd0;
localparam [ 0:0] SLEEP2_i      = 1'd0;
localparam [ 0:0] PROTECT2_i    = 1'd0;
localparam [10:0] UPAE2_i       = 11'd10;
localparam [10:0] UPAF2_i       = 11'd10;

// Width mode function
function [2:0] mode;
input integer width;
case (width)
1: mode = 3'b101;
2: mode = 3'b110;
4: mode = 3'b100;
8,9: mode = 3'b001;
16, 18: mode = 3'b010;
32, 36: mode = 3'b011;
default: mode = 3'b000;
endcase
endfunction

function integer rwmode;
input integer rwwidth;
case (rwwidth)
1: rwmode = 1;
2: rwmode = 2;
4: rwmode = 4;
8,9: rwmode = 9;
16, 18: rwmode = 18;
default: rwmode = 18;
endcase
endfunction

wire REN_A1_i;
wire REN_A2_i;

wire REN_B1_i;
wire REN_B2_i;

wire WEN_A1_i;
wire WEN_A2_i;

wire WEN_B1_i;
wire WEN_B2_i;

wire [1:0] BE_A1_i;
wire [1:0] BE_A2_i;

wire [1:0] BE_B1_i;
wire [1:0] BE_B2_i;

wire [14:0] ADDR_A1_i;
wire [13:0] ADDR_A2_i;

wire [14:0] ADDR_B1_i;
wire [13:0] ADDR_B2_i;

wire [17:0] WDATA_A1_i;
wire [17:0] WDATA_A2_i;

wire [17:0] WDATA_B1_i;
wire [17:0] WDATA_B2_i;

wire [17:0] RDATA_A1_o;
wire [17:0] RDATA_A2_o;

wire [17:0] RDATA_B1_o;
wire [17:0] RDATA_B2_o;

wire [1:0] WR1_BE;
wire [1:0] WR2_BE;

wire [17:0] PORT_B1_RDATA;
wire [17:0] PORT_A1_WDATA;

wire [17:0] PORT_B2_RDATA;
wire [17:0] PORT_A2_WDATA;

wire [13:0] WR1_ADDR_INT;
wire [13:0] RD1_ADDR_INT;

wire [13:0] WR2_ADDR_INT;
wire [13:0] RD2_ADDR_INT;

wire [13:0] PORT_A1_ADDR;
wire [13:0] PORT_B1_ADDR;

wire [13:0] PORT_A2_ADDR;
wire [13:0] PORT_B2_ADDR;


// Set port width mode (In non-split mode A2/B2 is not active. Set same values anyway to match previous behavior.)
localparam [ 2:0] RMODE_A1_i    = mode(WR1_DATA_WIDTH);
localparam [ 2:0] WMODE_A1_i    = mode(WR1_DATA_WIDTH);
localparam [ 2:0] RMODE_A2_i    = mode(WR2_DATA_WIDTH);
localparam [ 2:0] WMODE_A2_i    = mode(WR2_DATA_WIDTH);

localparam [ 2:0] RMODE_B1_i    = mode(RD1_DATA_WIDTH);
localparam [ 2:0] WMODE_B1_i    = mode(RD1_DATA_WIDTH);
localparam [ 2:0] RMODE_B2_i    = mode(RD2_DATA_WIDTH);
localparam [ 2:0] WMODE_B2_i    = mode(RD2_DATA_WIDTH);

localparam PORT_A1_WRWIDTH = rwmode(WR1_DATA_WIDTH);
localparam PORT_B1_WRWIDTH = rwmode(RD1_DATA_WIDTH);
localparam PORT_A2_WRWIDTH = rwmode(WR2_DATA_WIDTH);
localparam PORT_B2_WRWIDTH = rwmode(RD2_DATA_WIDTH);

generate
	if (WR1_ADDR_WIDTH == 14) begin
		assign WR1_ADDR_INT = WR1_ADDR_i;
	end else begin
		assign WR1_ADDR_INT[13:WR1_ADDR_WIDTH] = 0;
		assign WR1_ADDR_INT[WR1_ADDR_WIDTH-1:0] = WR1_ADDR_i;
	end
endgenerate

case (WR1_DATA_WIDTH)
	1: begin
		assign PORT_A1_ADDR = WR1_ADDR_INT;
	end
	2: begin
		assign PORT_A1_ADDR = WR1_ADDR_INT << 1;
	end
	4: begin
		assign PORT_A1_ADDR = WR1_ADDR_INT << 2;
	end
	8, 9: begin
		assign PORT_A1_ADDR = WR1_ADDR_INT << 3;
	end
	16, 18: begin
		assign PORT_A1_ADDR = WR1_ADDR_INT << 4;
	end
	default: begin
		assign PORT_A1_ADDR = WR1_ADDR_INT;
	end
endcase

generate
	if (RD1_ADDR_WIDTH == 14) begin
		assign RD1_ADDR_INT = RD1_ADDR_i;
	end else begin
		assign RD1_ADDR_INT[13:RD1_ADDR_WIDTH] = 0;
		assign RD1_ADDR_INT[RD1_ADDR_WIDTH-1:0] = RD1_ADDR_i;
	end
endgenerate

case (RD1_DATA_WIDTH)
	1: begin
		assign PORT_B1_ADDR = RD1_ADDR_INT;
	end
	2: begin
		assign PORT_B1_ADDR = RD1_ADDR_INT << 1;
	end
	4: begin
		assign PORT_B1_ADDR = RD1_ADDR_INT << 2;
	end
	8, 9: begin
		assign PORT_B1_ADDR = RD1_ADDR_INT << 3;
	end
	16, 18: begin
		assign PORT_B1_ADDR = RD1_ADDR_INT << 4;
	end
	default: begin
		assign PORT_B1_ADDR = RD1_ADDR_INT;
	end
endcase

generate
	if (WR2_ADDR_WIDTH == 14) begin
		assign WR2_ADDR_INT = WR2_ADDR_i;
	end else begin
		assign WR2_ADDR_INT[13:WR2_ADDR_WIDTH] = 0;
		assign WR2_ADDR_INT[WR2_ADDR_WIDTH-1:0] = WR2_ADDR_i;
	end
endgenerate

case (WR2_DATA_WIDTH)
	1: begin
		assign PORT_A2_ADDR = WR2_ADDR_INT;
	end
	2: begin
		assign PORT_A2_ADDR = WR2_ADDR_INT << 1;
	end
	4: begin
		assign PORT_A2_ADDR = WR2_ADDR_INT << 2;
	end
	8, 9: begin
		assign PORT_A2_ADDR = WR2_ADDR_INT << 3;
	end
	16, 18: begin
		assign PORT_A2_ADDR = WR2_ADDR_INT << 4;
	end
	default: begin
		assign PORT_A2_ADDR = WR2_ADDR_INT;
	end
endcase

generate
	if (RD2_ADDR_WIDTH == 14) begin
		assign RD2_ADDR_INT = RD2_ADDR_i;
	end else begin
		assign RD2_ADDR_INT[13:RD2_ADDR_WIDTH] = 0;
		assign RD2_ADDR_INT[RD2_ADDR_WIDTH-1:0] = RD2_ADDR_i;
	end
endgenerate

case (RD2_DATA_WIDTH)
	1: begin
		assign PORT_B2_ADDR = RD2_ADDR_INT;
	end
	2: begin
		assign PORT_B2_ADDR = RD2_ADDR_INT << 1;
	end
	4: begin
		assign PORT_B2_ADDR = RD2_ADDR_INT << 2;
	end
	8, 9: begin
		assign PORT_B2_ADDR = RD2_ADDR_INT << 3;
	end
	16, 18: begin
		assign PORT_B2_ADDR = RD2_ADDR_INT << 4;
	end
	default: begin
		assign PORT_B2_ADDR = RD2_ADDR_INT;
	end
endcase

case (BE1_WIDTH)
	2: begin
		assign WR1_BE = WR1_BE_i[BE1_WIDTH-1 :0];
	end
	default: begin
		assign WR1_BE[1:BE1_WIDTH] = 0;
		assign WR1_BE[BE1_WIDTH-1 :0] = WR1_BE_i[BE1_WIDTH-1 :0];
	end
endcase

case (BE2_WIDTH)
	2: begin
		assign WR2_BE = WR2_BE_i[BE2_WIDTH-1 :0];
	end
	default: begin
		assign WR2_BE[1:BE2_WIDTH] = 0;
		assign WR2_BE[BE2_WIDTH-1 :0] = WR2_BE_i[BE2_WIDTH-1 :0];
	end
endcase

assign REN_A1_i = 1'b0;
assign WEN_A1_i = WEN1_i;
assign BE_A1_i = WR1_BE;
assign REN_A2_i = 1'b0;
assign WEN_A2_i = WEN2_i;
assign BE_A2_i = WR2_BE;

assign REN_B1_i = REN1_i;
assign WEN_B1_i = 1'b0;
assign BE_B1_i = 4'h0;
assign REN_B2_i = REN2_i;
assign WEN_B2_i = 1'b0;
assign BE_B2_i = 4'h0;

generate
	if (WR1_DATA_WIDTH == 18) begin
		assign PORT_A1_WDATA[WR1_DATA_WIDTH-1:0] = WDATA1_i[WR1_DATA_WIDTH-1:0];
	end else if (WR1_DATA_WIDTH == 9) begin
		assign PORT_A1_WDATA = {1'b0, WDATA1_i[8], 8'h0, WDATA1_i[7:0]};
	end else begin
		assign PORT_A1_WDATA[17:WR1_DATA_WIDTH] = 0;
		assign PORT_A1_WDATA[WR1_DATA_WIDTH-1:0] = WDATA1_i[WR1_DATA_WIDTH-1:0];
	end
endgenerate

assign WDATA_A1_i = PORT_A1_WDATA[17:0];
assign WDATA_B1_i = 18'h0;

generate
	if (RD1_DATA_WIDTH == 9) begin
		assign PORT_B1_RDATA = { 9'h0, RDATA_B1_o[16], RDATA_B1_o[7:0]};
	end else begin
		assign PORT_B1_RDATA = RDATA_B1_o;
	end
endgenerate

assign RDATA1_o = PORT_B1_RDATA[RD1_DATA_WIDTH-1:0];

generate
	if (WR2_DATA_WIDTH == 18) begin
		assign PORT_A2_WDATA[WR2_DATA_WIDTH-1:0] = WDATA2_i[WR2_DATA_WIDTH-1:0];
	end else if (WR2_DATA_WIDTH == 9) begin
		assign PORT_A2_WDATA = {1'b0, WDATA2_i[8], 8'h0, WDATA2_i[7:0]};
	end else begin
		assign PORT_A2_WDATA[17:WR2_DATA_WIDTH] = 0;
		assign PORT_A2_WDATA[WR2_DATA_WIDTH-1:0] = WDATA2_i[WR2_DATA_WIDTH-1:0];
	end
endgenerate

assign WDATA_A2_i = PORT_A2_WDATA[17:0];
assign WDATA_B2_i = 18'h0;

generate
	if (RD2_DATA_WIDTH == 9) begin
		assign PORT_B2_RDATA = { 9'h0, RDATA_B2_o[16], RDATA_B2_o[7:0]};
	end else begin
		assign PORT_B2_RDATA = RDATA_B2_o;
	end
endgenerate

assign RDATA2_o = PORT_B2_RDATA[RD2_DATA_WIDTH-1:0];

defparam _TECHMAP_REPLACE_.MODE_BITS = { 1'b1,
	UPAF2_i, UPAE2_i, PROTECT2_i, SLEEP2_i, POWERDN2_i, FMODE2_i, WMODE_B2_i, WMODE_A2_i, RMODE_B2_i, RMODE_A2_i, SYNC_FIFO2_i,
	UPAF1_i, UPAE1_i, PROTECT1_i, SLEEP1_i, POWERDN1_i, FMODE1_i, WMODE_B1_i, WMODE_A1_i, RMODE_B1_i, RMODE_A1_i, SYNC_FIFO1_i
};

(* is_inferred = 0 *)
(* is_split = 1 *)
(* is_fifo = 0 *)
(* port_a1_dwidth = PORT_A1_WRWIDTH *)
(* port_a2_dwidth = PORT_A2_WRWIDTH *)
(* port_b1_dwidth = PORT_B1_WRWIDTH *)
(* port_b2_dwidth = PORT_B2_WRWIDTH *)
TDP36K _TECHMAP_REPLACE_ (
	.RESET_ni(1'b1),

	.CLK_A1_i(WR1_CLK_i),
	.ADDR_A1_i({1'b0,PORT_A1_ADDR}),
	.WEN_A1_i(WEN_A1_i),
	.BE_A1_i(BE_A1_i),
	.WDATA_A1_i(WDATA_A1_i),
	.REN_A1_i(REN_A1_i),
	.RDATA_A1_o(RDATA_A1_o),

	.CLK_A2_i(WR2_CLK_i),
	.ADDR_A2_i(PORT_A2_ADDR),
	.WEN_A2_i(WEN_A2_i),
	.BE_A2_i(BE_A2_i),
	.WDATA_A2_i(WDATA_A2_i),
	.REN_A2_i(REN_A2_i),
	.RDATA_A2_o(RDATA_A2_o),

	.CLK_B1_i(RD1_CLK_i),
	.ADDR_B1_i({1'b0,PORT_B1_ADDR}),
	.WEN_B1_i(WEN_B1_i),
	.BE_B1_i(BE_B1_i),
	.WDATA_B1_i(WDATA_B1_i),
	.REN_B1_i(REN_B1_i),
	.RDATA_B1_o(RDATA_B1_o),

	.CLK_B2_i(RD2_CLK_i),
	.ADDR_B2_i(PORT_B2_ADDR),
	.WEN_B2_i(WEN_B2_i),
	.BE_B2_i(BE_B2_i),
	.WDATA_B2_i(WDATA_B2_i),
	.REN_B2_i(REN_B2_i),
	.RDATA_B2_o(RDATA_B2_o),

	.FLUSH1_i(1'b0),
	.FLUSH2_i(1'b0)
);

endmodule

module DPRAM_36K_BLK (
		PORT_A_CLK_i,
		PORT_A_WEN_i,
		PORT_A_WR_BE_i,
		PORT_A_REN_i,
		PORT_A_ADDR_i,
		PORT_A_WR_DATA_i,
		PORT_A_RD_DATA_o,

		PORT_B_CLK_i,
		PORT_B_WEN_i,
		PORT_B_WR_BE_i,
		PORT_B_REN_i,
		PORT_B_ADDR_i,
		PORT_B_WR_DATA_i,
		PORT_B_RD_DATA_o
);

parameter PORT_A_AWIDTH = 10;
parameter PORT_A_DWIDTH = 36;
parameter PORT_A_WR_BE_WIDTH = 4;

parameter PORT_B_AWIDTH = 10;
parameter PORT_B_DWIDTH = 36;
parameter PORT_B_WR_BE_WIDTH = 4;

input PORT_A_CLK_i;
input [PORT_A_AWIDTH-1:0] PORT_A_ADDR_i;
input [PORT_A_DWIDTH-1:0] PORT_A_WR_DATA_i;
input PORT_A_WEN_i;
input [PORT_A_WR_BE_WIDTH-1:0] PORT_A_WR_BE_i;
input PORT_A_REN_i;
output [PORT_A_DWIDTH-1:0] PORT_A_RD_DATA_o;

input PORT_B_CLK_i;
input [PORT_B_AWIDTH-1:0] PORT_B_ADDR_i;
input [PORT_B_DWIDTH-1:0] PORT_B_WR_DATA_i;
input PORT_B_WEN_i;
input [PORT_B_WR_BE_WIDTH-1:0] PORT_B_WR_BE_i;
input PORT_B_REN_i;
output [PORT_B_DWIDTH-1:0] PORT_B_RD_DATA_o;


// Fixed mode settings
localparam [ 0:0] SYNC_FIFO1_i  = 1'd0;
localparam [ 0:0] FMODE1_i      = 1'd0;
localparam [ 0:0] POWERDN1_i    = 1'd0;
localparam [ 0:0] SLEEP1_i      = 1'd0;
localparam [ 0:0] PROTECT1_i    = 1'd0;
localparam [11:0] UPAE1_i       = 12'd10;
localparam [11:0] UPAF1_i       = 12'd10;

localparam [ 0:0] SYNC_FIFO2_i  = 1'd0;
localparam [ 0:0] FMODE2_i      = 1'd0;
localparam [ 0:0] POWERDN2_i    = 1'd0;
localparam [ 0:0] SLEEP2_i      = 1'd0;
localparam [ 0:0] PROTECT2_i    = 1'd0;
localparam [10:0] UPAE2_i       = 11'd10;
localparam [10:0] UPAF2_i       = 11'd10;

// Width mode function
function [2:0] mode;
input integer width;
case (width)
1: mode = 3'b101;
2: mode = 3'b110;
4: mode = 3'b100;
8,9: mode = 3'b001;
16, 18: mode = 3'b010;
32, 36: mode = 3'b011;
default: mode = 3'b000;
endcase
endfunction

function integer rwmode;
input integer rwwidth;
case (rwwidth)
1: rwmode = 1;
2: rwmode = 2;
4: rwmode = 4;
8,9: rwmode = 9;
16, 18: rwmode = 18;
32, 36: rwmode = 36;
default: rwmode = 36;
endcase
endfunction

wire REN_A1_i;
wire REN_A2_i;

wire REN_B1_i;
wire REN_B2_i;

wire WEN_A1_i;
wire WEN_A2_i;

wire WEN_B1_i;
wire WEN_B2_i;

wire [1:0] BE_A1_i;
wire [1:0] BE_A2_i;

wire [1:0] BE_B1_i;
wire [1:0] BE_B2_i;

wire [14:0] ADDR_A1_i;
wire [13:0] ADDR_A2_i;

wire [14:0] ADDR_B1_i;
wire [13:0] ADDR_B2_i;

wire [17:0] WDATA_A1_i;
wire [17:0] WDATA_A2_i;

wire [17:0] WDATA_B1_i;
wire [17:0] WDATA_B2_i;

wire [17:0] RDATA_A1_o;
wire [17:0] RDATA_A2_o;

wire [17:0] RDATA_B1_o;
wire [17:0] RDATA_B2_o;

wire [3:0] PORT_A_WR_BE;
wire [3:0] PORT_B_WR_BE;

wire [35:0] PORT_B_WDATA;
wire [35:0] PORT_B_RDATA;
wire [35:0] PORT_A_WDATA;
wire [35:0] PORT_A_RDATA;

wire [14:0] PORT_A_ADDR_INT;
wire [14:0] PORT_B_ADDR_INT;

wire [14:0] PORT_A_ADDR;
wire [14:0] PORT_B_ADDR;

wire PORT_A_CLK;
wire PORT_B_CLK;

// Set port width mode (In non-split mode A2/B2 is not active. Set same values anyway to match previous behavior.)
localparam [ 2:0] RMODE_A1_i    = mode(PORT_A_DWIDTH);
localparam [ 2:0] WMODE_A1_i    = mode(PORT_A_DWIDTH);
localparam [ 2:0] RMODE_A2_i    = mode(PORT_A_DWIDTH);
localparam [ 2:0] WMODE_A2_i    = mode(PORT_A_DWIDTH);

localparam [ 2:0] RMODE_B1_i    = mode(PORT_B_DWIDTH);
localparam [ 2:0] WMODE_B1_i    = mode(PORT_B_DWIDTH);
localparam [ 2:0] RMODE_B2_i    = mode(PORT_B_DWIDTH);
localparam [ 2:0] WMODE_B2_i    = mode(PORT_B_DWIDTH);

localparam PORT_A_WRWIDTH = rwmode(PORT_A_DWIDTH);
localparam PORT_B_WRWIDTH = rwmode(PORT_B_DWIDTH);

assign PORT_A_CLK = PORT_A_CLK_i;
assign PORT_B_CLK = PORT_B_CLK_i;

generate
	if (PORT_A_AWIDTH == 15) begin
		assign PORT_A_ADDR_INT = PORT_A_ADDR_i;
	end else begin
		assign PORT_A_ADDR_INT[14:PORT_A_AWIDTH] = 0;
		assign PORT_A_ADDR_INT[PORT_A_AWIDTH-1:0] = PORT_A_ADDR_i;
	end
endgenerate

case (PORT_A_DWIDTH)
	1: begin
		assign PORT_A_ADDR = PORT_A_ADDR_INT;
	end
	2: begin
		assign PORT_A_ADDR = PORT_A_ADDR_INT << 1;
	end
	4: begin
		assign PORT_A_ADDR = PORT_A_ADDR_INT << 2;
	end
	8, 9: begin
		assign PORT_A_ADDR = PORT_A_ADDR_INT << 3;
	end
	16, 18: begin
		assign PORT_A_ADDR = PORT_A_ADDR_INT << 4;
	end
	32, 36: begin
		assign PORT_A_ADDR = PORT_A_ADDR_INT << 5;
	end
	default: begin
		assign PORT_A_ADDR = PORT_A_ADDR_INT;
	end
endcase

generate
	if (PORT_B_AWIDTH == 15) begin
		assign PORT_B_ADDR_INT = PORT_B_ADDR_i;
	end else begin
		assign PORT_B_ADDR_INT[14:PORT_B_AWIDTH] = 0;
		assign PORT_B_ADDR_INT[PORT_B_AWIDTH-1:0] = PORT_B_ADDR_i;
	end
endgenerate

case (PORT_B_DWIDTH)
	1: begin
		assign PORT_B_ADDR = PORT_B_ADDR_INT;
	end
	2: begin
		assign PORT_B_ADDR = PORT_B_ADDR_INT << 1;
	end
	4: begin
		assign PORT_B_ADDR = PORT_B_ADDR_INT << 2;
	end
	8, 9: begin
		assign PORT_B_ADDR = PORT_B_ADDR_INT << 3;
	end
	16, 18: begin
		assign PORT_B_ADDR = PORT_B_ADDR_INT << 4;
	end
	32, 36: begin
		assign PORT_B_ADDR = PORT_B_ADDR_INT << 5;
	end
	default: begin
		assign PORT_B_ADDR = PORT_B_ADDR_INT;
	end
endcase

case (PORT_A_WR_BE_WIDTH)
	4: begin
		assign PORT_A_WR_BE = PORT_A_WR_BE_i[PORT_A_WR_BE_WIDTH-1 :0];
	end
	default: begin
		assign PORT_A_WR_BE[3:PORT_A_WR_BE_WIDTH] = 0;
		assign PORT_A_WR_BE[PORT_A_WR_BE_WIDTH-1 :0] = PORT_A_WR_BE_i[PORT_A_WR_BE_WIDTH-1 :0];
	end
endcase

case (PORT_B_WR_BE_WIDTH)
	4: begin
		assign PORT_B_WR_BE = PORT_B_WR_BE_i[PORT_B_WR_BE_WIDTH-1 :0];
	end
	default: begin
		assign PORT_B_WR_BE[3:PORT_B_WR_BE_WIDTH] = 0;
		assign PORT_B_WR_BE[PORT_B_WR_BE_WIDTH-1 :0] = PORT_B_WR_BE_i[PORT_B_WR_BE_WIDTH-1 :0];
	end
endcase

assign REN_A1_i = PORT_A_REN_i;
assign WEN_A1_i = PORT_A_WEN_i;
assign {BE_A2_i, BE_A1_i} = PORT_A_WR_BE;

assign REN_B1_i = PORT_B_REN_i;
assign WEN_B1_i = PORT_B_WEN_i;
assign {BE_B2_i, BE_B1_i} = PORT_B_WR_BE;

generate
	if (PORT_A_DWIDTH == 36) begin
		assign PORT_A_WDATA[PORT_A_DWIDTH-1:0] = PORT_A_WR_DATA_i[PORT_A_DWIDTH-1:0];
	end else if (PORT_A_DWIDTH > 18 && PORT_A_DWIDTH < 36) begin
		assign PORT_A_WDATA[PORT_A_DWIDTH+1:18]  = PORT_A_WR_DATA_i[PORT_A_DWIDTH-1:16];
		assign PORT_A_WDATA[17:0] = {2'b00,PORT_A_WR_DATA_i[15:0]};
	end else if (PORT_A_DWIDTH == 9) begin
		assign PORT_A_WDATA = {19'h0, PORT_A_WR_DATA_i[8], 8'h0, PORT_A_WR_DATA_i[7:0]};
	end else begin
		assign PORT_A_WDATA[35:PORT_A_DWIDTH] = 0;
		assign PORT_A_WDATA[PORT_A_DWIDTH-1:0] = PORT_A_WR_DATA_i[PORT_A_DWIDTH-1:0];
	end
endgenerate

assign WDATA_A1_i = PORT_A_WDATA[17:0];
assign WDATA_A2_i = PORT_A_WDATA[35:18];

generate
	if (PORT_A_DWIDTH == 36) begin
		assign PORT_A_RDATA = {RDATA_A2_o, RDATA_A1_o};
	end else if (PORT_A_DWIDTH > 18 && PORT_A_DWIDTH < 36) begin
		assign PORT_A_RDATA  = {2'b00,RDATA_A2_o[17:0],RDATA_A1_o[15:0]};
	end else if (PORT_A_DWIDTH == 9) begin
		assign PORT_A_RDATA = { 27'h0, RDATA_A1_o[16], RDATA_A1_o[7:0]};
	end else begin
		assign PORT_A_RDATA = {18'h0, RDATA_A1_o};
	end
endgenerate

assign PORT_A_RD_DATA_o = PORT_A_RDATA[PORT_A_DWIDTH-1:0];

generate
	if (PORT_B_DWIDTH == 36) begin
		assign PORT_B_WDATA[PORT_B_DWIDTH-1:0] = PORT_B_WR_DATA_i[PORT_B_DWIDTH-1:0];
	end else if (PORT_B_DWIDTH > 18 && PORT_B_DWIDTH < 36) begin
		assign PORT_B_WDATA[PORT_B_DWIDTH+1:18]  = PORT_B_WR_DATA_i[PORT_B_DWIDTH-1:16];
		assign PORT_B_WDATA[17:0] = {2'b00,PORT_B_WR_DATA_i[15:0]};
	end else if (PORT_B_DWIDTH == 9) begin
		assign PORT_B_WDATA = {19'h0, PORT_B_WR_DATA_i[8], 8'h0, PORT_B_WR_DATA_i[7:0]};
	end else begin
		assign PORT_B_WDATA[35:PORT_B_DWIDTH] = 0;
		assign PORT_B_WDATA[PORT_B_DWIDTH-1:0] = PORT_B_WR_DATA_i[PORT_B_DWIDTH-1:0];
	end
endgenerate

assign WDATA_B1_i = PORT_B_WDATA[17:0];
assign WDATA_B2_i = PORT_B_WDATA[35:18];

generate
	if (PORT_B_DWIDTH == 36) begin
		assign PORT_B_RDATA = {RDATA_B2_o, RDATA_B1_o};
	end else if (PORT_B_DWIDTH > 18 && PORT_B_DWIDTH < 36) begin
		assign PORT_B_RDATA  = {2'b00,RDATA_B2_o[17:0],RDATA_B1_o[15:0]};
	end else if (PORT_B_DWIDTH == 9) begin
		assign PORT_B_RDATA = { 27'h0, RDATA_B1_o[16], RDATA_B1_o[7:0]};
	end else begin
		assign PORT_B_RDATA = {18'h0, RDATA_B1_o};
	end
endgenerate

assign PORT_B_RD_DATA_o = PORT_B_RDATA[PORT_B_DWIDTH-1:0];

defparam _TECHMAP_REPLACE_.MODE_BITS = { 1'b0,
	UPAF2_i, UPAE2_i, PROTECT2_i, SLEEP2_i, POWERDN2_i, FMODE2_i, WMODE_B2_i, WMODE_A2_i, RMODE_B2_i, RMODE_A2_i, SYNC_FIFO2_i,
	UPAF1_i, UPAE1_i, PROTECT1_i, SLEEP1_i, POWERDN1_i, FMODE1_i, WMODE_B1_i, WMODE_A1_i, RMODE_B1_i, RMODE_A1_i, SYNC_FIFO1_i
};

(* is_inferred = 0 *)
(* is_split = 0 *)
(* is_fifo = 0 *)
(* port_a_dwidth = PORT_A_WRWIDTH *)
(* port_b_dwidth = PORT_B_WRWIDTH *)
TDP36K _TECHMAP_REPLACE_ (
	.RESET_ni(1'b1),

	.CLK_A1_i(PORT_A_CLK),
	.ADDR_A1_i(PORT_A_ADDR),
	.WEN_A1_i(WEN_A1_i),
	.BE_A1_i(BE_A1_i),
	.WDATA_A1_i(WDATA_A1_i),
	.REN_A1_i(REN_A1_i),
	.RDATA_A1_o(RDATA_A1_o),

	.CLK_A2_i(PORT_A_CLK),
	.ADDR_A2_i(PORT_A_ADDR[13:0]),
	.WEN_A2_i(WEN_A1_i),
	.BE_A2_i(BE_A2_i),
	.WDATA_A2_i(WDATA_A2_i),
	.REN_A2_i(REN_A1_i),
	.RDATA_A2_o(RDATA_A2_o),

	.CLK_B1_i(PORT_B_CLK),
	.ADDR_B1_i(PORT_B_ADDR),
	.WEN_B1_i(WEN_B1_i),
	.BE_B1_i(BE_B1_i),
	.WDATA_B1_i(WDATA_B1_i),
	.REN_B1_i(REN_B1_i),
	.RDATA_B1_o(RDATA_B1_o),

	.CLK_B2_i(PORT_B_CLK),
	.ADDR_B2_i(PORT_B_ADDR[13:0]),
	.WEN_B2_i(WEN_B1_i),
	.BE_B2_i(BE_B2_i),
	.WDATA_B2_i(WDATA_B2_i),
	.REN_B2_i(REN_B1_i),
	.RDATA_B2_o(RDATA_B2_o),

	.FLUSH1_i(1'b0),
	.FLUSH2_i(1'b0)
);

endmodule

module DPRAM_18K_BLK (
		PORT_A_CLK_i,
		PORT_A_WEN_i,
		PORT_A_WR_BE_i,
		PORT_A_REN_i,
		PORT_A_ADDR_i,
		PORT_A_WR_DATA_i,
		PORT_A_RD_DATA_o,

		PORT_B_CLK_i,
		PORT_B_WEN_i,
		PORT_B_WR_BE_i,
		PORT_B_REN_i,
		PORT_B_ADDR_i,
		PORT_B_WR_DATA_i,
		PORT_B_RD_DATA_o
);

parameter PORT_A_AWIDTH = 10;
parameter PORT_A_DWIDTH = 36;
parameter PORT_A_WR_BE_WIDTH = 4;

parameter PORT_B_AWIDTH = 10;
parameter PORT_B_DWIDTH = 36;
parameter PORT_B_WR_BE_WIDTH = 4;

input PORT_A_CLK_i;
input [PORT_A_AWIDTH-1:0] PORT_A_ADDR_i;
input [PORT_A_DWIDTH-1:0] PORT_A_WR_DATA_i;
input PORT_A_WEN_i;
input [PORT_A_WR_BE_WIDTH-1:0] PORT_A_WR_BE_i;
input PORT_A_REN_i;
output [PORT_A_DWIDTH-1:0] PORT_A_RD_DATA_o;

input PORT_B_CLK_i;
input [PORT_B_AWIDTH-1:0] PORT_B_ADDR_i;
input [PORT_B_DWIDTH-1:0] PORT_B_WR_DATA_i;
input PORT_B_WEN_i;
input [PORT_B_WR_BE_WIDTH-1:0] PORT_B_WR_BE_i;
input PORT_B_REN_i;
output [PORT_B_DWIDTH-1:0] PORT_B_RD_DATA_o;


(* is_inferred = 0 *)
(* is_split = 0 *)
(* is_fifo = 0 *)
BRAM2x18_dP #(
	.PORT_A1_AWIDTH(PORT_A_AWIDTH),
	.PORT_A1_DWIDTH(PORT_A_DWIDTH),
	.PORT_A1_WR_BE_WIDTH(PORT_A_WR_BE_WIDTH),
	.PORT_B1_AWIDTH(PORT_B_AWIDTH),
	.PORT_B1_DWIDTH(PORT_B_DWIDTH),
	.PORT_B1_WR_BE_WIDTH(PORT_B_WR_BE_WIDTH),
	.PORT_A2_AWIDTH(),
	.PORT_A2_DWIDTH(),
	.PORT_A2_WR_BE_WIDTH(),
	.PORT_B2_AWIDTH(),
	.PORT_B2_DWIDTH(),
	.PORT_B2_WR_BE_WIDTH()
) U1 (
		.PORT_A1_CLK_i(PORT_A_CLK_i),
		.PORT_A1_WEN_i(PORT_A_WEN_i),
		.PORT_A1_WR_BE_i(PORT_A_WR_BE_i),
		.PORT_A1_REN_i(PORT_A_REN_i),
		.PORT_A1_ADDR_i(PORT_A_ADDR_i),
		.PORT_A1_WR_DATA_i(PORT_A_WR_DATA_i),
		.PORT_A1_RD_DATA_o(PORT_A_RD_DATA_o),

		.PORT_B1_CLK_i(PORT_B_CLK_i),
		.PORT_B1_WEN_i(PORT_B_WEN_i),
		.PORT_B1_WR_BE_i(PORT_B_WR_BE_i),
		.PORT_B1_REN_i(PORT_B_REN_i),
		.PORT_B1_ADDR_i(PORT_B_ADDR_i),
		.PORT_B1_WR_DATA_i(PORT_B_WR_DATA_i),
		.PORT_B1_RD_DATA_o(PORT_B_RD_DATA_o),

		.PORT_A2_CLK_i(1'b0),
		.PORT_A2_WEN_i(1'b0),
		.PORT_A2_WR_BE_i(2'b00),
		.PORT_A2_REN_i(1'b0),
		.PORT_A2_ADDR_i(14'h0),
		.PORT_A2_WR_DATA_i(18'h0),
		.PORT_A2_RD_DATA_o(),

		.PORT_B2_CLK_i(1'b0),
		.PORT_B2_WEN_i(1'b0),
		.PORT_B2_WR_BE_i(2'b00),
		.PORT_B2_REN_i(1'b0),
		.PORT_B2_ADDR_i(14'h0),
		.PORT_B2_WR_DATA_i(18'h0),
		.PORT_B2_RD_DATA_o()
);

endmodule


module DPRAM_18K_X2_BLK (
		PORT_A1_CLK_i,
		PORT_A1_WEN_i,
		PORT_A1_WR_BE_i,
		PORT_A1_REN_i,
		PORT_A1_ADDR_i,
		PORT_A1_WR_DATA_i,
		PORT_A1_RD_DATA_o,

		PORT_B1_CLK_i,
		PORT_B1_WEN_i,
		PORT_B1_WR_BE_i,
		PORT_B1_REN_i,
		PORT_B1_ADDR_i,
		PORT_B1_WR_DATA_i,
		PORT_B1_RD_DATA_o,

		PORT_A2_CLK_i,
		PORT_A2_WEN_i,
		PORT_A2_WR_BE_i,
		PORT_A2_REN_i,
		PORT_A2_ADDR_i,
		PORT_A2_WR_DATA_i,
		PORT_A2_RD_DATA_o,

		PORT_B2_CLK_i,
		PORT_B2_WEN_i,
		PORT_B2_WR_BE_i,
		PORT_B2_REN_i,
		PORT_B2_ADDR_i,
		PORT_B2_WR_DATA_i,
		PORT_B2_RD_DATA_o
);

parameter PORT_A1_AWIDTH = 10;
parameter PORT_A1_DWIDTH = 18;
parameter PORT_A1_WR_BE_WIDTH = 2;

parameter PORT_B1_AWIDTH = 10;
parameter PORT_B1_DWIDTH = 18;
parameter PORT_B1_WR_BE_WIDTH = 2;

parameter PORT_A2_AWIDTH = 10;
parameter PORT_A2_DWIDTH = 18;
parameter PORT_A2_WR_BE_WIDTH = 2;

parameter PORT_B2_AWIDTH = 10;
parameter PORT_B2_DWIDTH = 18;
parameter PORT_B2_WR_BE_WIDTH = 2;


input PORT_A1_CLK_i;
input [PORT_A1_AWIDTH-1:0] PORT_A1_ADDR_i;
input [PORT_A1_DWIDTH-1:0] PORT_A1_WR_DATA_i;
input PORT_A1_WEN_i;
input [PORT_A1_WR_BE_WIDTH-1:0] PORT_A1_WR_BE_i;
input PORT_A1_REN_i;
output [PORT_A1_DWIDTH-1:0] PORT_A1_RD_DATA_o;

input PORT_B1_CLK_i;
input [PORT_B1_AWIDTH-1:0] PORT_B1_ADDR_i;
input [PORT_B1_DWIDTH-1:0] PORT_B1_WR_DATA_i;
input PORT_B1_WEN_i;
input [PORT_B1_WR_BE_WIDTH-1:0] PORT_B1_WR_BE_i;
input PORT_B1_REN_i;
output [PORT_B1_DWIDTH-1:0] PORT_B1_RD_DATA_o;

input PORT_A2_CLK_i;
input [PORT_A2_AWIDTH-1:0] PORT_A2_ADDR_i;
input [PORT_A2_DWIDTH-1:0] PORT_A2_WR_DATA_i;
input PORT_A2_WEN_i;
input [PORT_A2_WR_BE_WIDTH-1:0] PORT_A2_WR_BE_i;
input PORT_A2_REN_i;
output [PORT_A2_DWIDTH-1:0] PORT_A2_RD_DATA_o;

input PORT_B2_CLK_i;
input [PORT_B2_AWIDTH-1:0] PORT_B2_ADDR_i;
input [PORT_B2_DWIDTH-1:0] PORT_B2_WR_DATA_i;
input PORT_B2_WEN_i;
input [PORT_B2_WR_BE_WIDTH-1:0] PORT_B2_WR_BE_i;
input PORT_B2_REN_i;
output [PORT_B2_DWIDTH-1:0] PORT_B2_RD_DATA_o;


// Fixed mode settings
localparam [ 0:0] SYNC_FIFO1_i  = 1'd0;
localparam [ 0:0] FMODE1_i      = 1'd0;
localparam [ 0:0] POWERDN1_i    = 1'd0;
localparam [ 0:0] SLEEP1_i      = 1'd0;
localparam [ 0:0] PROTECT1_i    = 1'd0;
localparam [11:0] UPAE1_i       = 12'd10;
localparam [11:0] UPAF1_i       = 12'd10;

localparam [ 0:0] SYNC_FIFO2_i  = 1'd0;
localparam [ 0:0] FMODE2_i      = 1'd0;
localparam [ 0:0] POWERDN2_i    = 1'd0;
localparam [ 0:0] SLEEP2_i      = 1'd0;
localparam [ 0:0] PROTECT2_i    = 1'd0;
localparam [10:0] UPAE2_i       = 11'd10;
localparam [10:0] UPAF2_i       = 11'd10;

// Width mode function
function [2:0] mode;
input integer width;
case (width)
1: mode = 3'b101;
2: mode = 3'b110;
4: mode = 3'b100;
8,9: mode = 3'b001;
16, 18: mode = 3'b010;
32, 36: mode = 3'b011;
default: mode = 3'b000;
endcase
endfunction

function integer rwmode;
input integer rwwidth;
case (rwwidth)
1: rwmode = 1;
2: rwmode = 2;
4: rwmode = 4;
8,9: rwmode = 9;
16, 18: rwmode = 18;
default: rwmode = 18;
endcase
endfunction

wire REN_A1_i;
wire REN_A2_i;

wire REN_B1_i;
wire REN_B2_i;

wire WEN_A1_i;
wire WEN_A2_i;

wire WEN_B1_i;
wire WEN_B2_i;

wire [1:0] BE_A1_i;
wire [1:0] BE_A2_i;

wire [1:0] BE_B1_i;
wire [1:0] BE_B2_i;

wire [14:0] ADDR_A1_i;
wire [13:0] ADDR_A2_i;

wire [14:0] ADDR_B1_i;
wire [13:0] ADDR_B2_i;

wire [17:0] WDATA_A1_i;
wire [17:0] WDATA_A2_i;

wire [17:0] WDATA_B1_i;
wire [17:0] WDATA_B2_i;

wire [17:0] RDATA_A1_o;
wire [17:0] RDATA_A2_o;

wire [17:0] RDATA_B1_o;
wire [17:0] RDATA_B2_o;

wire [1:0] PORT_A1_WR_BE;
wire [1:0] PORT_B1_WR_BE;

wire [1:0] PORT_A2_WR_BE;
wire [1:0] PORT_B2_WR_BE;

wire [17:0] PORT_B1_WDATA;
wire [17:0] PORT_B1_RDATA;
wire [17:0] PORT_A1_WDATA;
wire [17:0] PORT_A1_RDATA;

wire [17:0] PORT_B2_WDATA;
wire [17:0] PORT_B2_RDATA;
wire [17:0] PORT_A2_WDATA;
wire [17:0] PORT_A2_RDATA;

wire [13:0] PORT_A1_ADDR_INT;
wire [13:0] PORT_B1_ADDR_INT;

wire [13:0] PORT_A2_ADDR_INT;
wire [13:0] PORT_B2_ADDR_INT;

wire [13:0] PORT_A1_ADDR;
wire [13:0] PORT_B1_ADDR;

wire [13:0] PORT_A2_ADDR;
wire [13:0] PORT_B2_ADDR;

wire PORT_A1_CLK;
wire PORT_B1_CLK;

wire PORT_A2_CLK;
wire PORT_B2_CLK;

// Set port width mode (In non-split mode A2/B2 is not active. Set same values anyway to match previous behavior.)
localparam [ 2:0] RMODE_A1_i    = mode(PORT_A1_DWIDTH);
localparam [ 2:0] WMODE_A1_i    = mode(PORT_A1_DWIDTH);
localparam [ 2:0] RMODE_A2_i    = mode(PORT_A2_DWIDTH);
localparam [ 2:0] WMODE_A2_i    = mode(PORT_A2_DWIDTH);

localparam [ 2:0] RMODE_B1_i    = mode(PORT_B1_DWIDTH);
localparam [ 2:0] WMODE_B1_i    = mode(PORT_B1_DWIDTH);
localparam [ 2:0] RMODE_B2_i    = mode(PORT_B2_DWIDTH);
localparam [ 2:0] WMODE_B2_i    = mode(PORT_B2_DWIDTH);

localparam PORT_A1_WRWIDTH = rwmode(PORT_A1_DWIDTH);
localparam PORT_B1_WRWIDTH = rwmode(PORT_B1_DWIDTH);
localparam PORT_A2_WRWIDTH = rwmode(PORT_A2_DWIDTH);
localparam PORT_B2_WRWIDTH = rwmode(PORT_B2_DWIDTH);

assign PORT_A1_CLK = PORT_A1_CLK_i;
assign PORT_B1_CLK = PORT_B1_CLK_i;

assign PORT_A2_CLK = PORT_A2_CLK_i;
assign PORT_B2_CLK = PORT_B2_CLK_i;

generate
	if (PORT_A1_AWIDTH == 14) begin
		assign PORT_A1_ADDR_INT = PORT_A1_ADDR_i;
	end else begin
		assign PORT_A1_ADDR_INT[13:PORT_A1_AWIDTH] = 0;
		assign PORT_A1_ADDR_INT[PORT_A1_AWIDTH-1:0] = PORT_A1_ADDR_i;
	end
endgenerate

case (PORT_A1_DWIDTH)
	1: begin
		assign PORT_A1_ADDR = PORT_A1_ADDR_INT;
	end
	2: begin
		assign PORT_A1_ADDR = PORT_A1_ADDR_INT << 1;
	end
	4: begin
		assign PORT_A1_ADDR = PORT_A1_ADDR_INT << 2;
	end
	8, 9: begin
		assign PORT_A1_ADDR = PORT_A1_ADDR_INT << 3;
	end
	16, 18: begin
		assign PORT_A1_ADDR = PORT_A1_ADDR_INT << 4;
	end
	default: begin
		assign PORT_A1_ADDR = PORT_A1_ADDR_INT;
	end
endcase

generate
	if (PORT_B1_AWIDTH == 14) begin
		assign PORT_B1_ADDR_INT = PORT_B1_ADDR_i;
	end else begin
		assign PORT_B1_ADDR_INT[13:PORT_B1_AWIDTH] = 0;
		assign PORT_B1_ADDR_INT[PORT_B1_AWIDTH-1:0] = PORT_B1_ADDR_i;
	end
endgenerate

case (PORT_B1_DWIDTH)
	1: begin
		assign PORT_B1_ADDR = PORT_B1_ADDR_INT;
	end
	2: begin
		assign PORT_B1_ADDR = PORT_B1_ADDR_INT << 1;
	end
	4: begin
		assign PORT_B1_ADDR = PORT_B1_ADDR_INT << 2;
	end
	8, 9: begin
		assign PORT_B1_ADDR = PORT_B1_ADDR_INT << 3;
	end
	16, 18: begin
		assign PORT_B1_ADDR = PORT_B1_ADDR_INT << 4;
	end
	default: begin
		assign PORT_B1_ADDR = PORT_B1_ADDR_INT;
	end
endcase

generate
	if (PORT_A2_AWIDTH == 14) begin
		assign PORT_A2_ADDR_INT = PORT_A2_ADDR_i;
	end else begin
		assign PORT_A2_ADDR_INT[13:PORT_A2_AWIDTH] = 0;
		assign PORT_A2_ADDR_INT[PORT_A2_AWIDTH-1:0] = PORT_A2_ADDR_i;
	end
endgenerate

case (PORT_A2_DWIDTH)
	1: begin
		assign PORT_A2_ADDR = PORT_A2_ADDR_INT;
	end
	2: begin
		assign PORT_A2_ADDR = PORT_A2_ADDR_INT << 1;
	end
	4: begin
		assign PORT_A2_ADDR = PORT_A2_ADDR_INT << 2;
	end
	8, 9: begin
		assign PORT_A2_ADDR = PORT_A2_ADDR_INT << 3;
	end
	16, 18: begin
		assign PORT_A2_ADDR = PORT_A2_ADDR_INT << 4;
	end
	default: begin
		assign PORT_A2_ADDR = PORT_A2_ADDR_INT;
	end
endcase

generate
	if (PORT_B2_AWIDTH == 14) begin
		assign PORT_B2_ADDR_INT = PORT_B2_ADDR_i;
	end else begin
		assign PORT_B2_ADDR_INT[13:PORT_B2_AWIDTH] = 0;
		assign PORT_B2_ADDR_INT[PORT_B2_AWIDTH-1:0] = PORT_B2_ADDR_i;
	end
endgenerate

case (PORT_B2_DWIDTH)
	1: begin
		assign PORT_B2_ADDR = PORT_B2_ADDR_INT;
	end
	2: begin
		assign PORT_B2_ADDR = PORT_B2_ADDR_INT << 1;
	end
	4: begin
		assign PORT_B2_ADDR = PORT_B2_ADDR_INT << 2;
	end
	8, 9: begin
		assign PORT_B2_ADDR = PORT_B2_ADDR_INT << 3;
	end
	16, 18: begin
		assign PORT_B2_ADDR = PORT_B2_ADDR_INT << 4;
	end
	default: begin
		assign PORT_B2_ADDR = PORT_B2_ADDR_INT;
	end
endcase

case (PORT_A1_WR_BE_WIDTH)
	2: begin
		assign PORT_A1_WR_BE = PORT_A1_WR_BE_i[PORT_A1_WR_BE_WIDTH-1 :0];
	end
	default: begin
		assign PORT_A1_WR_BE[1:PORT_A1_WR_BE_WIDTH] = 0;
		assign PORT_A1_WR_BE[PORT_A1_WR_BE_WIDTH-1 :0] = PORT_A1_WR_BE_i[PORT_A1_WR_BE_WIDTH-1 :0];
	end
endcase

case (PORT_B1_WR_BE_WIDTH)
	2: begin
		assign PORT_B1_WR_BE = PORT_B1_WR_BE_i[PORT_B1_WR_BE_WIDTH-1 :0];
	end
	default: begin
		assign PORT_B1_WR_BE[1:PORT_B1_WR_BE_WIDTH] = 0;
		assign PORT_B1_WR_BE[PORT_B1_WR_BE_WIDTH-1 :0] = PORT_B1_WR_BE_i[PORT_B1_WR_BE_WIDTH-1 :0];
	end
endcase

case (PORT_A2_WR_BE_WIDTH)
	2: begin
		assign PORT_A2_WR_BE = PORT_A2_WR_BE_i[PORT_A2_WR_BE_WIDTH-1 :0];
	end
	default: begin
		assign PORT_A2_WR_BE[1:PORT_A2_WR_BE_WIDTH] = 0;
		assign PORT_A2_WR_BE[PORT_A2_WR_BE_WIDTH-1 :0] = PORT_A2_WR_BE_i[PORT_A2_WR_BE_WIDTH-1 :0];
	end
endcase

case (PORT_B2_WR_BE_WIDTH)
	2: begin
		assign PORT_B2_WR_BE = PORT_B2_WR_BE_i[PORT_B2_WR_BE_WIDTH-1 :0];
	end
	default: begin
		assign PORT_B2_WR_BE[1:PORT_B2_WR_BE_WIDTH] = 0;
		assign PORT_B2_WR_BE[PORT_B2_WR_BE_WIDTH-1 :0] = PORT_B2_WR_BE_i[PORT_B2_WR_BE_WIDTH-1 :0];
	end
endcase

assign REN_A1_i = PORT_A1_REN_i;
assign WEN_A1_i = PORT_A1_WEN_i;
assign BE_A1_i  = PORT_A1_WR_BE;

assign REN_A2_i = PORT_A2_REN_i;
assign WEN_A2_i = PORT_A2_WEN_i;
assign BE_A2_i  = PORT_A2_WR_BE;

assign REN_B1_i = PORT_B1_REN_i;
assign WEN_B1_i = PORT_B1_WEN_i;
assign BE_B1_i  = PORT_B1_WR_BE;

assign REN_B2_i = PORT_B2_REN_i;
assign WEN_B2_i = PORT_B2_WEN_i;
assign BE_B2_i  = PORT_B2_WR_BE;

generate
	if (PORT_A1_DWIDTH == 18) begin
		assign PORT_A1_WDATA[PORT_A1_DWIDTH-1:0] = PORT_A1_WR_DATA_i[PORT_A1_DWIDTH-1:0];
	end else if (PORT_A1_DWIDTH == 9) begin
		assign PORT_A1_WDATA = {1'b0, PORT_A1_WR_DATA_i[8], 8'h0, PORT_A1_WR_DATA_i[7:0]};
	end else begin
		assign PORT_A1_WDATA[17:PORT_A1_DWIDTH] = 0;
		assign PORT_A1_WDATA[PORT_A1_DWIDTH-1:0] = PORT_A1_WR_DATA_i[PORT_A1_DWIDTH-1:0];
	end
endgenerate

assign WDATA_A1_i = PORT_A1_WDATA;

generate
	if (PORT_A2_DWIDTH == 18) begin
		assign PORT_A2_WDATA[PORT_A2_DWIDTH-1:0] = PORT_A2_WR_DATA_i[PORT_A2_DWIDTH-1:0];
	end else if (PORT_A2_DWIDTH == 9) begin
		assign PORT_A2_WDATA = {1'b0, PORT_A2_WR_DATA_i[8], 8'h0, PORT_A2_WR_DATA_i[7:0]};
	end else begin
		assign PORT_A2_WDATA[17:PORT_A2_DWIDTH] = 0;
		assign PORT_A2_WDATA[PORT_A2_DWIDTH-1:0] = PORT_A2_WR_DATA_i[PORT_A2_DWIDTH-1:0];
	end
endgenerate

assign WDATA_A2_i = PORT_A2_WDATA;

generate
	if (PORT_A1_DWIDTH == 9) begin
		assign PORT_A1_RDATA = { 9'h0, RDATA_A1_o[16], RDATA_A1_o[7:0]};
	end else begin
		assign PORT_A1_RDATA = RDATA_A1_o;
	end
endgenerate

assign PORT_A1_RD_DATA_o = PORT_A1_RDATA[PORT_A1_DWIDTH-1:0];

generate
	if (PORT_A2_DWIDTH == 9) begin
		assign PORT_A2_RDATA = { 9'h0, RDATA_A2_o[16], RDATA_A2_o[7:0]};
	end else begin
		assign PORT_A2_RDATA = RDATA_A2_o;
	end
endgenerate

assign PORT_A2_RD_DATA_o = PORT_A2_RDATA[PORT_A2_DWIDTH-1:0];

generate
	if (PORT_B1_DWIDTH == 18) begin
		assign PORT_B1_WDATA[PORT_B1_DWIDTH-1:0] = PORT_B1_WR_DATA_i[PORT_B1_DWIDTH-1:0];
	end else if (PORT_B1_DWIDTH == 9) begin
		assign PORT_B1_WDATA = {1'b0, PORT_B1_WR_DATA_i[8], 8'h0, PORT_B1_WR_DATA_i[7:0]};
	end else begin
		assign PORT_B1_WDATA[17:PORT_B1_DWIDTH] = 0;
		assign PORT_B1_WDATA[PORT_B1_DWIDTH-1:0] = PORT_B1_WR_DATA_i[PORT_B1_DWIDTH-1:0];
	end
endgenerate

assign WDATA_B1_i = PORT_B1_WDATA;

generate
	if (PORT_B2_DWIDTH == 18) begin
		assign PORT_B2_WDATA[PORT_B2_DWIDTH-1:0] = PORT_B2_WR_DATA_i[PORT_B2_DWIDTH-1:0];
	end else if (PORT_B2_DWIDTH == 9) begin
		assign PORT_B2_WDATA = {1'b0, PORT_B2_WR_DATA_i[8], 8'h0, PORT_B2_WR_DATA_i[7:0]};
	end else begin
		assign PORT_B2_WDATA[17:PORT_B2_DWIDTH] = 0;
		assign PORT_B2_WDATA[PORT_B2_DWIDTH-1:0] = PORT_B2_WR_DATA_i[PORT_B2_DWIDTH-1:0];
	end
endgenerate

assign WDATA_B2_i = PORT_B2_WDATA;

generate
	if (PORT_B1_DWIDTH == 9) begin
		assign PORT_B1_RDATA = { 9'h0, RDATA_B1_o[16], RDATA_B1_o[7:0]};
	end else begin
		assign PORT_B1_RDATA = RDATA_B1_o;
	end
endgenerate

assign PORT_B1_RD_DATA_o = PORT_B1_RDATA[PORT_B1_DWIDTH-1:0];

generate
	if (PORT_B2_DWIDTH == 9) begin
		assign PORT_B2_RDATA = { 9'h0, RDATA_B2_o[16], RDATA_B2_o[7:0]};
	end else begin
		assign PORT_B2_RDATA = RDATA_B2_o;
	end
endgenerate

assign PORT_B2_RD_DATA_o = PORT_B2_RDATA[PORT_B2_DWIDTH-1:0];

defparam _TECHMAP_REPLACE_.MODE_BITS = { 1'b1,
	UPAF2_i, UPAE2_i, PROTECT2_i, SLEEP2_i, POWERDN2_i, FMODE2_i, WMODE_B2_i, WMODE_A2_i, RMODE_B2_i, RMODE_A2_i, SYNC_FIFO2_i,
	UPAF1_i, UPAE1_i, PROTECT1_i, SLEEP1_i, POWERDN1_i, FMODE1_i, WMODE_B1_i, WMODE_A1_i, RMODE_B1_i, RMODE_A1_i, SYNC_FIFO1_i
};

(* is_inferred = 0 *)
(* is_split = 1 *)
(* is_fifo = 0 *)
(* port_a1_dwidth = PORT_A1_WRWIDTH *)
(* port_a2_dwidth = PORT_A2_WRWIDTH *)
(* port_b1_dwidth = PORT_B1_WRWIDTH *)
(* port_b2_dwidth = PORT_B2_WRWIDTH *)
TDP36K _TECHMAP_REPLACE_ (
	.RESET_ni(1'b1),

	.CLK_A1_i(PORT_A1_CLK),
	.ADDR_A1_i({1'b0,PORT_A1_ADDR}),
	.WEN_A1_i(WEN_A1_i),
	.BE_A1_i(BE_A1_i),
	.WDATA_A1_i(WDATA_A1_i),
	.REN_A1_i(REN_A1_i),
	.RDATA_A1_o(RDATA_A1_o),

	.CLK_A2_i(PORT_A2_CLK),
	.ADDR_A2_i(PORT_A2_ADDR),
	.WEN_A2_i(WEN_A2_i),
	.BE_A2_i(BE_A2_i),
	.WDATA_A2_i(WDATA_A2_i),
	.REN_A2_i(REN_A2_i),
	.RDATA_A2_o(RDATA_A2_o),

	.CLK_B1_i(PORT_B1_CLK),
	.ADDR_B1_i({1'b0,PORT_B1_ADDR}),
	.WEN_B1_i(WEN_B1_i),
	.BE_B1_i(BE_B1_i),
	.WDATA_B1_i(WDATA_B1_i),
	.REN_B1_i(REN_B1_i),
	.RDATA_B1_o(RDATA_B1_o),

	.CLK_B2_i(PORT_B2_CLK),
	.ADDR_B2_i(PORT_B2_ADDR),
	.WEN_B2_i(WEN_B2_i),
	.BE_B2_i(BE_B2_i),
	.WDATA_B2_i(WDATA_B2_i),
	.REN_B2_i(REN_B2_i),
	.RDATA_B2_o(RDATA_B2_o),

	.FLUSH1_i(1'b0),
	.FLUSH2_i(1'b0)
);

endmodule

module SFIFO_36K_BLK (
		DIN,
		PUSH,
		POP,
		CLK,
		Async_Flush,
		Overrun_Error,
		Full_Watermark,
		Almost_Full,
		Full,
		Underrun_Error,
		Empty_Watermark,
		Almost_Empty,
		Empty,
		DOUT
);

	parameter WR_DATA_WIDTH = 36;
	parameter RD_DATA_WIDTH = 36;
	parameter UPAE_DBITS = 12'd10;
	parameter UPAF_DBITS = 12'd10;

	input wire CLK;
	input wire PUSH, POP;
	input wire [WR_DATA_WIDTH-1:0] DIN;
	input wire Async_Flush;
	output wire [RD_DATA_WIDTH-1:0] DOUT;
	output wire Almost_Full, Almost_Empty;
	output wire Full, Empty;
	output wire Full_Watermark, Empty_Watermark;
	output wire Overrun_Error, Underrun_Error;

	// Fixed mode settings
	localparam [ 0:0] SYNC_FIFO1_i  = 1'd1;
	localparam [ 0:0] FMODE1_i      = 1'd1;
	localparam [ 0:0] POWERDN1_i    = 1'd0;
	localparam [ 0:0] SLEEP1_i      = 1'd0;
	localparam [ 0:0] PROTECT1_i    = 1'd0;
	localparam [11:0] UPAE1_i       = UPAE_DBITS;
	localparam [11:0] UPAF1_i       = UPAF_DBITS;

	localparam [ 0:0] SYNC_FIFO2_i  = 1'd0;
	localparam [ 0:0] FMODE2_i      = 1'd0;
	localparam [ 0:0] POWERDN2_i    = 1'd0;
	localparam [ 0:0] SLEEP2_i      = 1'd0;
	localparam [ 0:0] PROTECT2_i    = 1'd0;
	localparam [10:0] UPAE2_i       = 11'd10;
	localparam [10:0] UPAF2_i       = 11'd10;

	// Width mode function
	function [2:0] mode;
	input integer width;
	case (width)
	1: mode = 3'b101;
	2: mode = 3'b110;
	4: mode = 3'b100;
	8,9: mode = 3'b001;
	16, 18: mode = 3'b010;
	32, 36: mode = 3'b011;
	default: mode = 3'b000;
	endcase
	endfunction

	function integer rwmode;
	input integer rwwidth;
	case (rwwidth)
	1: rwmode = 1;
	2: rwmode = 2;
	4: rwmode = 4;
	8,9: rwmode = 9;
	16, 18: rwmode = 18;
	32, 36: rwmode = 36;
	default: rwmode = 36;
	endcase
	endfunction

	wire [35:0] in_reg;
	wire [35:0] out_reg;
	wire [17:0] fifo_flags;

	wire [35:0] RD_DATA_INT;

	wire Push_Clk, Pop_Clk;

	assign Push_Clk = CLK;
	assign Pop_Clk = CLK;

	assign Overrun_Error = fifo_flags[0];
	assign Full_Watermark = fifo_flags[1];
	assign Almost_Full = fifo_flags[2];
	assign Full = fifo_flags[3];
	assign Underrun_Error = fifo_flags[4];
	assign Empty_Watermark = fifo_flags[5];
	assign Almost_Empty = fifo_flags[6];
	assign Empty = fifo_flags[7];

	localparam [ 2:0] RMODE_A1_i    = mode(WR_DATA_WIDTH);
	localparam [ 2:0] WMODE_A1_i    = mode(WR_DATA_WIDTH);
	localparam [ 2:0] RMODE_A2_i    = mode(WR_DATA_WIDTH);
	localparam [ 2:0] WMODE_A2_i    = mode(WR_DATA_WIDTH);

	localparam [ 2:0] RMODE_B1_i    = mode(RD_DATA_WIDTH);
	localparam [ 2:0] WMODE_B1_i    = mode(RD_DATA_WIDTH);
	localparam [ 2:0] RMODE_B2_i    = mode(RD_DATA_WIDTH);
	localparam [ 2:0] WMODE_B2_i    = mode(RD_DATA_WIDTH);

	localparam PORT_A_WRWIDTH = rwmode(WR_DATA_WIDTH);
	localparam PORT_B_WRWIDTH = rwmode(RD_DATA_WIDTH);

	generate
		if (WR_DATA_WIDTH == 36) begin
			assign in_reg[WR_DATA_WIDTH-1:0] = DIN[WR_DATA_WIDTH-1:0];
		end else if (WR_DATA_WIDTH > 18 && WR_DATA_WIDTH < 36) begin
			assign in_reg[WR_DATA_WIDTH+1:18] = DIN[WR_DATA_WIDTH-1:16];
			assign in_reg[17:0] = {2'b00,DIN[15:0]};
		end else if (WR_DATA_WIDTH == 9) begin
			assign in_reg[35:0] = {19'h0, DIN[8], 8'h0, DIN[7:0]};
		end else begin
			assign in_reg[35:WR_DATA_WIDTH]  = 0;
			assign in_reg[WR_DATA_WIDTH-1:0] = DIN[WR_DATA_WIDTH-1:0];
		end
	endgenerate

	generate
		if (RD_DATA_WIDTH == 36) begin
			assign RD_DATA_INT = out_reg;
		end else if (RD_DATA_WIDTH > 18 && RD_DATA_WIDTH < 36) begin
			assign RD_DATA_INT  = {2'b00,out_reg[35:18],out_reg[15:0]};
		end else if (RD_DATA_WIDTH == 9) begin
			assign RD_DATA_INT = { 27'h0, out_reg[16], out_reg[7:0]};
		end else begin
			assign RD_DATA_INT = {18'h0, out_reg[17:0]};
		end
	endgenerate

	assign DOUT[RD_DATA_WIDTH-1 : 0] = RD_DATA_INT[RD_DATA_WIDTH-1 : 0];

	defparam _TECHMAP_REPLACE_.MODE_BITS = { 1'b0,
	UPAF2_i, UPAE2_i, PROTECT2_i, SLEEP2_i, POWERDN2_i, FMODE2_i, WMODE_B2_i, WMODE_A2_i, RMODE_B2_i, RMODE_A2_i, SYNC_FIFO2_i,
	UPAF1_i, UPAE1_i, PROTECT1_i, SLEEP1_i, POWERDN1_i, FMODE1_i, WMODE_B1_i, WMODE_A1_i, RMODE_B1_i, RMODE_A1_i, SYNC_FIFO1_i
	};

	(* is_fifo = 1 *)
	(* sync_fifo = 1 *)
	(* is_inferred = 0 *)
	(* is_split = 0 *)
	(* port_a_dwidth = PORT_A_WRWIDTH *)
	(* port_b_dwidth = PORT_B_WRWIDTH *)
	 TDP36K _TECHMAP_REPLACE_ (
		.RESET_ni(1'b1),
		.WDATA_A1_i(in_reg[17:0]),
		.WDATA_A2_i(in_reg[35:18]),
		.RDATA_A1_o(fifo_flags),
		.RDATA_A2_o(),
		.ADDR_A1_i(14'h0),
		.ADDR_A2_i(14'h0),
		.CLK_A1_i(Push_Clk),
		.CLK_A2_i(1'b0),
		.REN_A1_i(1'b1),
		.REN_A2_i(1'b0),
		.WEN_A1_i(PUSH),
		.WEN_A2_i(1'b0),
		.BE_A1_i(2'b11),
		.BE_A2_i(2'b11),

		.WDATA_B1_i(18'h0),
		.WDATA_B2_i(18'h0),
		.RDATA_B1_o(out_reg[17:0]),
		.RDATA_B2_o(out_reg[35:18]),
		.ADDR_B1_i(14'h0),
		.ADDR_B2_i(14'h0),
		.CLK_B1_i(Pop_Clk),
		.CLK_B2_i(1'b0),
		.REN_B1_i(POP),
		.REN_B2_i(1'b0),
		.WEN_B1_i(1'b0),
		.WEN_B2_i(1'b0),
		.BE_B1_i(2'b11),
		.BE_B2_i(2'b11),

		.FLUSH1_i(Async_Flush),
		.FLUSH2_i(1'b0)
	);



endmodule

module AFIFO_36K_BLK (
		DIN,
		PUSH,
		POP,
		Push_Clk,
		Pop_Clk,
		Async_Flush,
		Overrun_Error,
		Full_Watermark,
		Almost_Full,
		Full,
		Underrun_Error,
		Empty_Watermark,
		Almost_Empty,
		Empty,
		DOUT
);

	parameter WR_DATA_WIDTH = 36;
	parameter RD_DATA_WIDTH = 36;
	parameter UPAE_DBITS = 12'd10;
	parameter UPAF_DBITS = 12'd10;

	input wire Push_Clk, Pop_Clk;
	input wire PUSH, POP;
	input wire [WR_DATA_WIDTH-1:0] DIN;
	input wire Async_Flush;
	output wire [RD_DATA_WIDTH-1:0] DOUT;
	output wire Almost_Full, Almost_Empty;
	output wire Full, Empty;
	output wire Full_Watermark, Empty_Watermark;
	output wire Overrun_Error, Underrun_Error;

	// Fixed mode settings
	localparam [ 0:0] SYNC_FIFO1_i  = 1'd0;
	localparam [ 0:0] FMODE1_i      = 1'd1;
	localparam [ 0:0] POWERDN1_i    = 1'd0;
	localparam [ 0:0] SLEEP1_i      = 1'd0;
	localparam [ 0:0] PROTECT1_i    = 1'd0;
	localparam [11:0] UPAE1_i       = UPAE_DBITS;
	localparam [11:0] UPAF1_i       = UPAF_DBITS;

	localparam [ 0:0] SYNC_FIFO2_i  = 1'd0;
	localparam [ 0:0] FMODE2_i      = 1'd0;
	localparam [ 0:0] POWERDN2_i    = 1'd0;
	localparam [ 0:0] SLEEP2_i      = 1'd0;
	localparam [ 0:0] PROTECT2_i    = 1'd0;
	localparam [10:0] UPAE2_i       = 11'd10;
	localparam [10:0] UPAF2_i       = 11'd10;

	// Width mode function
	function [2:0] mode;
	input integer width;
	case (width)
	1: mode = 3'b101;
	2: mode = 3'b110;
	4: mode = 3'b100;
	8,9: mode = 3'b001;
	16, 18: mode = 3'b010;
	32, 36: mode = 3'b011;
	default: mode = 3'b000;
	endcase
	endfunction

	function integer rwmode;
	input integer rwwidth;
	case (rwwidth)
	1: rwmode = 1;
	2: rwmode = 2;
	4: rwmode = 4;
	8,9: rwmode = 9;
	16, 18: rwmode = 18;
	32, 36: rwmode = 36;
	default: rwmode = 36;
	endcase
	endfunction

	wire [35:0] in_reg;
	wire [35:0] out_reg;
	wire [17:0] fifo_flags;

	wire [35:0] RD_DATA_INT;
	wire [35:WR_DATA_WIDTH] WR_DATA_CMPL;

	assign Overrun_Error = fifo_flags[0];
	assign Full_Watermark = fifo_flags[1];
	assign Almost_Full = fifo_flags[2];
	assign Full = fifo_flags[3];
	assign Underrun_Error = fifo_flags[4];
	assign Empty_Watermark = fifo_flags[5];
	assign Almost_Empty = fifo_flags[6];
	assign Empty = fifo_flags[7];

	localparam [ 2:0] RMODE_A1_i    = mode(WR_DATA_WIDTH);
	localparam [ 2:0] WMODE_A1_i    = mode(WR_DATA_WIDTH);
	localparam [ 2:0] RMODE_A2_i    = mode(WR_DATA_WIDTH);
	localparam [ 2:0] WMODE_A2_i    = mode(WR_DATA_WIDTH);

	localparam [ 2:0] RMODE_B1_i    = mode(RD_DATA_WIDTH);
	localparam [ 2:0] WMODE_B1_i    = mode(RD_DATA_WIDTH);
	localparam [ 2:0] RMODE_B2_i    = mode(RD_DATA_WIDTH);
	localparam [ 2:0] WMODE_B2_i    = mode(RD_DATA_WIDTH);

	localparam PORT_A_WRWIDTH = rwmode(WR_DATA_WIDTH);
	localparam PORT_B_WRWIDTH = rwmode(RD_DATA_WIDTH);

	generate
		if (WR_DATA_WIDTH == 36) begin
			assign in_reg[WR_DATA_WIDTH-1:0] = DIN[WR_DATA_WIDTH-1:0];
		end else if (WR_DATA_WIDTH > 18 && WR_DATA_WIDTH < 36) begin
			assign in_reg[WR_DATA_WIDTH+1:18] = DIN[WR_DATA_WIDTH-1:16];
			assign in_reg[17:0] = {2'b00,DIN[15:0]};
		end else if (WR_DATA_WIDTH == 9) begin
			assign in_reg[35:0] = {19'h0, DIN[8], 8'h0, DIN[7:0]};
		end else begin
			assign in_reg[35:WR_DATA_WIDTH]  = 0;
			assign in_reg[WR_DATA_WIDTH-1:0] = DIN[WR_DATA_WIDTH-1:0];
		end
	endgenerate

	generate
		if (RD_DATA_WIDTH == 36) begin
			assign RD_DATA_INT = out_reg;
		end else if (RD_DATA_WIDTH > 18 && RD_DATA_WIDTH < 36) begin
			assign RD_DATA_INT  = {2'b00,out_reg[35:18],out_reg[15:0]};
		end else if (RD_DATA_WIDTH == 9) begin
			assign RD_DATA_INT = { 27'h0, out_reg[16], out_reg[7:0]};
		end else begin
			assign RD_DATA_INT = {18'h0, out_reg[17:0]};
		end
	endgenerate

	assign DOUT[RD_DATA_WIDTH-1 : 0] = RD_DATA_INT[RD_DATA_WIDTH-1 : 0];

	defparam _TECHMAP_REPLACE_.MODE_BITS = { 1'b0,
	UPAF2_i, UPAE2_i, PROTECT2_i, SLEEP2_i, POWERDN2_i, FMODE2_i, WMODE_B2_i, WMODE_A2_i, RMODE_B2_i, RMODE_A2_i, SYNC_FIFO2_i,
	UPAF1_i, UPAE1_i, PROTECT1_i, SLEEP1_i, POWERDN1_i, FMODE1_i, WMODE_B1_i, WMODE_A1_i, RMODE_B1_i, RMODE_A1_i, SYNC_FIFO1_i
	};

	(* is_fifo = 1 *)
	(* sync_fifo = 0 *)
	(* is_inferred = 0 *)
	(* is_split = 0 *)
	(* port_a_dwidth = PORT_A_WRWIDTH *)
	(* port_b_dwidth = PORT_B_WRWIDTH *)
 	TDP36K _TECHMAP_REPLACE_ (
		.RESET_ni(1'b1),
		.WDATA_A1_i(in_reg[17:0]),
		.WDATA_A2_i(in_reg[35:18]),
		.RDATA_A1_o(fifo_flags),
		.RDATA_A2_o(),
		.ADDR_A1_i(14'h0),
		.ADDR_A2_i(14'h0),
		.CLK_A1_i(Push_Clk),
		.CLK_A2_i(1'b0),
		.REN_A1_i(1'b1),
		.REN_A2_i(1'b0),
		.WEN_A1_i(PUSH),
		.WEN_A2_i(1'b0),
		.BE_A1_i(2'b11),
		.BE_A2_i(2'b11),

		.WDATA_B1_i(18'h0),
		.WDATA_B2_i(18'h0),
		.RDATA_B1_o(out_reg[17:0]),
		.RDATA_B2_o(out_reg[35:18]),
		.ADDR_B1_i(14'h0),
		.ADDR_B2_i(14'h0),
		.CLK_B1_i(Pop_Clk),
		.CLK_B2_i(1'b0),
		.REN_B1_i(POP),
		.REN_B2_i(1'b0),
		.WEN_B1_i(1'b0),
		.WEN_B2_i(1'b0),
		.BE_B1_i(2'b11),
		.BE_B2_i(2'b11),

		.FLUSH1_i(Async_Flush),
		.FLUSH2_i(1'b0)
	);



endmodule

module SFIFO_18K_BLK (
		DIN,
		PUSH,
		POP,
		CLK,
		Async_Flush,
		Overrun_Error,
		Full_Watermark,
		Almost_Full,
		Full,
		Underrun_Error,
		Empty_Watermark,
		Almost_Empty,
		Empty,
		DOUT
);

	parameter WR_DATA_WIDTH = 18;
	parameter RD_DATA_WIDTH = 18;
	parameter UPAE_DBITS = 11'd10;
	parameter UPAF_DBITS = 11'd10;

	input wire CLK;
	input wire PUSH, POP;
	input wire [WR_DATA_WIDTH-1:0] DIN;
	input wire Async_Flush;
	output wire [RD_DATA_WIDTH-1:0] DOUT;
	output wire Almost_Full, Almost_Empty;
	output wire Full, Empty;
	output wire Full_Watermark, Empty_Watermark;
	output wire Overrun_Error, Underrun_Error;

 	BRAM2x18_SFIFO  #(
			.WR1_DATA_WIDTH(WR_DATA_WIDTH),
			.RD1_DATA_WIDTH(RD_DATA_WIDTH),
			.UPAE_DBITS1(UPAE_DBITS),
			.UPAF_DBITS1(UPAF_DBITS),
			.WR2_DATA_WIDTH(),
			.RD2_DATA_WIDTH(),
			.UPAE_DBITS2(),
			.UPAF_DBITS2()
			 ) U1
			(
			.DIN1(DIN),
			.PUSH1(PUSH),
			.POP1(POP),
			.CLK1(CLK),
			.Async_Flush1(Async_Flush),
			.Overrun_Error1(Overrun_Error),
			.Full_Watermark1(Full_Watermark),
			.Almost_Full1(Almost_Full),
			.Full1(Full),
			.Underrun_Error1(Underrun_Error),
			.Empty_Watermark1(Empty_Watermark),
			.Almost_Empty1(Almost_Empty),
			.Empty1(Empty),
			.DOUT1(DOUT),

			.DIN2(18'h0),
			.PUSH2(1'b0),
			.POP2(1'b0),
			.CLK2(1'b0),
			.Async_Flush2(1'b0),
			.Overrun_Error2(),
			.Full_Watermark2(),
			.Almost_Full2(),
			.Full2(),
			.Underrun_Error2(),
			.Empty_Watermark2(),
			.Almost_Empty2(),
			.Empty2(),
			.DOUT2()
	);

endmodule

module SFIFO_18K_X2_BLK (
		DIN1,
		PUSH1,
		POP1,
		CLK1,
		Async_Flush1,
		Overrun_Error1,
		Full_Watermark1,
		Almost_Full1,
		Full1,
		Underrun_Error1,
		Empty_Watermark1,
		Almost_Empty1,
		Empty1,
		DOUT1,

		DIN2,
		PUSH2,
		POP2,
		CLK2,
		Async_Flush2,
		Overrun_Error2,
		Full_Watermark2,
		Almost_Full2,
		Full2,
		Underrun_Error2,
		Empty_Watermark2,
		Almost_Empty2,
		Empty2,
		DOUT2
);

	parameter WR1_DATA_WIDTH = 18;
	parameter RD1_DATA_WIDTH = 18;

	parameter WR2_DATA_WIDTH = 18;
	parameter RD2_DATA_WIDTH = 18;

	parameter UPAE_DBITS1 = 12'd10;
	parameter UPAF_DBITS1 = 12'd10;

	parameter UPAE_DBITS2 = 11'd10;
	parameter UPAF_DBITS2 = 11'd10;

	input CLK1;
	input PUSH1, POP1;
	input [WR1_DATA_WIDTH-1:0] DIN1;
	input Async_Flush1;
	output [RD1_DATA_WIDTH-1:0] DOUT1;
	output Almost_Full1, Almost_Empty1;
	output Full1, Empty1;
	output Full_Watermark1, Empty_Watermark1;
	output Overrun_Error1, Underrun_Error1;

	input CLK2;
	input PUSH2, POP2;
	input [WR2_DATA_WIDTH-1:0] DIN2;
	input Async_Flush2;
	output [RD2_DATA_WIDTH-1:0] DOUT2;
	output Almost_Full2, Almost_Empty2;
	output Full2, Empty2;
	output Full_Watermark2, Empty_Watermark2;
	output Overrun_Error2, Underrun_Error2;

	// Fixed mode settings
	localparam [ 0:0] SYNC_FIFO1_i  = 1'd1;
	localparam [ 0:0] FMODE1_i      = 1'd1;
	localparam [ 0:0] POWERDN1_i    = 1'd0;
	localparam [ 0:0] SLEEP1_i      = 1'd0;
	localparam [ 0:0] PROTECT1_i    = 1'd0;
	localparam [11:0] UPAE1_i       = UPAE_DBITS1;
	localparam [11:0] UPAF1_i       = UPAF_DBITS1;

	localparam [ 0:0] SYNC_FIFO2_i  = 1'd1;
	localparam [ 0:0] FMODE2_i      = 1'd1;
	localparam [ 0:0] POWERDN2_i    = 1'd0;
	localparam [ 0:0] SLEEP2_i      = 1'd0;
	localparam [ 0:0] PROTECT2_i    = 1'd0;
	localparam [10:0] UPAE2_i       = UPAE_DBITS2;
	localparam [10:0] UPAF2_i       = UPAF_DBITS2;

	// Width mode function
	function [2:0] mode;
	input integer width;
	case (width)
	1: mode = 3'b101;
	2: mode = 3'b110;
	4: mode = 3'b100;
	8,9: mode = 3'b001;
	16, 18: mode = 3'b010;
	32, 36: mode = 3'b011;
	default: mode = 3'b000;
	endcase
	endfunction

	function integer rwmode;
	input integer rwwidth;
	case (rwwidth)
	1: rwmode = 1;
	2: rwmode = 2;
	4: rwmode = 4;
	8,9: rwmode = 9;
	16, 18: rwmode = 18;
	default: rwmode = 18;
	endcase
	endfunction

	wire [17:0] in_reg1;
	wire [17:0] out_reg1;
	wire [17:0] fifo1_flags;

	wire [17:0] in_reg2;
	wire [17:0] out_reg2;
	wire [17:0] fifo2_flags;

	wire Push_Clk1, Pop_Clk1;
	wire Push_Clk2, Pop_Clk2;
	assign Push_Clk1 = CLK1;
	assign Pop_Clk1 = CLK1;
	assign Push_Clk2 = CLK2;
	assign Pop_Clk2 = CLK2;

	assign Overrun_Error1 = fifo1_flags[0];
	assign Full_Watermark1 = fifo1_flags[1];
	assign Almost_Full1 = fifo1_flags[2];
	assign Full1 = fifo1_flags[3];
	assign Underrun_Error1 = fifo1_flags[4];
	assign Empty_Watermark1 = fifo1_flags[5];
	assign Almost_Empty1 = fifo1_flags[6];
	assign Empty1 = fifo1_flags[7];

	assign Overrun_Error2 = fifo2_flags[0];
	assign Full_Watermark2 = fifo2_flags[1];
	assign Almost_Full2 = fifo2_flags[2];
	assign Full2 = fifo2_flags[3];
	assign Underrun_Error2 = fifo2_flags[4];
	assign Empty_Watermark2 = fifo2_flags[5];
	assign Almost_Empty2 = fifo2_flags[6];
	assign Empty2 = fifo2_flags[7];

	localparam [ 2:0] RMODE_A1_i    = mode(WR1_DATA_WIDTH);
	localparam [ 2:0] WMODE_A1_i    = mode(WR1_DATA_WIDTH);
	localparam [ 2:0] RMODE_A2_i    = mode(WR2_DATA_WIDTH);
	localparam [ 2:0] WMODE_A2_i    = mode(WR2_DATA_WIDTH);

	localparam [ 2:0] RMODE_B1_i    = mode(RD1_DATA_WIDTH);
	localparam [ 2:0] WMODE_B1_i    = mode(RD1_DATA_WIDTH);
	localparam [ 2:0] RMODE_B2_i    = mode(RD2_DATA_WIDTH);
	localparam [ 2:0] WMODE_B2_i    = mode(RD2_DATA_WIDTH);

	localparam PORT_A1_WRWIDTH = rwmode(WR1_DATA_WIDTH);
	localparam PORT_B1_WRWIDTH = rwmode(RD1_DATA_WIDTH);
	localparam PORT_A2_WRWIDTH = rwmode(WR2_DATA_WIDTH);
	localparam PORT_B2_WRWIDTH = rwmode(RD2_DATA_WIDTH);

	generate
		if (WR1_DATA_WIDTH == 18) begin
			assign in_reg1[17:0] = DIN1[17:0];
		end else if (WR1_DATA_WIDTH == 9) begin
			assign in_reg1[17:0] = {1'b0, DIN1[8], 8'h0, DIN1[7:0]};
		end else begin
			assign in_reg1[17:WR1_DATA_WIDTH]  = 0;
			assign in_reg1[WR1_DATA_WIDTH-1:0] = DIN1[WR1_DATA_WIDTH-1:0];
		end
	endgenerate

	generate
		if (RD1_DATA_WIDTH == 9) begin
			assign DOUT1[RD1_DATA_WIDTH-1:0] = {out_reg1[16], out_reg1[7:0]};
		end else begin
			assign DOUT1[RD1_DATA_WIDTH-1:0] = out_reg1[RD1_DATA_WIDTH-1:0];
		end
	endgenerate

	generate
		if (WR2_DATA_WIDTH == 18) begin
			assign in_reg2[17:0] = DIN2[17:0];
		end else if (WR2_DATA_WIDTH == 9) begin
			assign in_reg2[17:0] = {1'b0, DIN2[8], 8'h0, DIN2[7:0]};
		end else begin
			assign in_reg2[17:WR2_DATA_WIDTH]  = 0;
			assign in_reg2[WR2_DATA_WIDTH-1:0] = DIN2[WR2_DATA_WIDTH-1:0];
		end
	endgenerate

	generate
		if (RD2_DATA_WIDTH == 9) begin
			assign DOUT2[RD2_DATA_WIDTH-1:0] = {out_reg2[16], out_reg2[7:0]};
		end else begin
			assign DOUT2[RD2_DATA_WIDTH-1:0] = out_reg2[RD2_DATA_WIDTH-1:0];
		end
	endgenerate

	defparam _TECHMAP_REPLACE_.MODE_BITS = { 1'b1,
	UPAF2_i, UPAE2_i, PROTECT2_i, SLEEP2_i, POWERDN2_i, FMODE2_i, WMODE_B2_i, WMODE_A2_i, RMODE_B2_i, RMODE_A2_i, SYNC_FIFO2_i,
	UPAF1_i, UPAE1_i, PROTECT1_i, SLEEP1_i, POWERDN1_i, FMODE1_i, WMODE_B1_i, WMODE_A1_i, RMODE_B1_i, RMODE_A1_i, SYNC_FIFO1_i
	};

	(* is_fifo = 1 *)
	(* sync_fifo = 1 *)
	(* is_split = 1 *)
	(* is_inferred = 0 *)
	(* port_a1_dwidth = PORT_A1_WRWIDTH *)
	(* port_a2_dwidth = PORT_A2_WRWIDTH *)
	(* port_b1_dwidth = PORT_B1_WRWIDTH *)
	(* port_b2_dwidth = PORT_B2_WRWIDTH *)
 	TDP36K _TECHMAP_REPLACE_ (
		.RESET_ni(1'b1),
		.WDATA_A1_i(in_reg1[17:0]),
		.WDATA_A2_i(in_reg2[17:0]),
		.RDATA_A1_o(fifo1_flags),
		.RDATA_A2_o(fifo2_flags),
		.ADDR_A1_i(14'h0),
		.ADDR_A2_i(14'h0),
		.CLK_A1_i(Push_Clk1),
		.CLK_A2_i(Push_Clk2),
		.REN_A1_i(1'b1),
		.REN_A2_i(1'b1),
		.WEN_A1_i(PUSH1),
		.WEN_A2_i(PUSH2),
		.BE_A1_i(2'b11),
		.BE_A2_i(2'b11),

		.WDATA_B1_i(18'h0),
		.WDATA_B2_i(18'h0),
		.RDATA_B1_o(out_reg1[17:0]),
		.RDATA_B2_o(out_reg2[17:0]),
		.ADDR_B1_i(14'h0),
		.ADDR_B2_i(14'h0),
		.CLK_B1_i(Pop_Clk1),
		.CLK_B2_i(Pop_Clk2),
		.REN_B1_i(POP1),
		.REN_B2_i(POP2),
		.WEN_B1_i(1'b0),
		.WEN_B2_i(1'b0),
		.BE_B1_i(2'b11),
		.BE_B2_i(2'b11),

		.FLUSH1_i(Async_Flush1),
		.FLUSH2_i(Async_Flush2)
	);

endmodule

module AFIFO_18K_BLK (
		DIN,
		PUSH,
		POP,
		Push_Clk,
		Pop_Clk,
		Async_Flush,
		Overrun_Error,
		Full_Watermark,
		Almost_Full,
		Full,
		Underrun_Error,
		Empty_Watermark,
		Almost_Empty,
		Empty,
		DOUT
);

	parameter WR_DATA_WIDTH = 18;
	parameter RD_DATA_WIDTH = 18;
	parameter UPAE_DBITS = 11'd10;
	parameter UPAF_DBITS = 11'd10;

	input wire Push_Clk, Pop_Clk;
	input wire PUSH, POP;
	input wire [WR_DATA_WIDTH-1:0] DIN;
	input wire Async_Flush;
	output wire [RD_DATA_WIDTH-1:0] DOUT;
	output wire Almost_Full, Almost_Empty;
	output wire Full, Empty;
	output wire Full_Watermark, Empty_Watermark;
	output wire Overrun_Error, Underrun_Error;

 	BRAM2x18_AFIFO  #(
			.WR1_DATA_WIDTH(WR_DATA_WIDTH),
			.RD1_DATA_WIDTH(RD_DATA_WIDTH),
			.UPAE_DBITS1(UPAE_DBITS),
			.UPAF_DBITS1(UPAF_DBITS),
			.WR2_DATA_WIDTH(),
			.RD2_DATA_WIDTH(),
			.UPAE_DBITS2(),
			.UPAF_DBITS2()
			 ) U1
			(
			.DIN1(DIN),
			.PUSH1(PUSH),
			.POP1(POP),
			.Push_Clk1(Push_Clk),
			.Pop_Clk1(Pop_Clk),
			.Async_Flush1(Async_Flush),
			.Overrun_Error1(Overrun_Error),
			.Full_Watermark1(Full_Watermark),
			.Almost_Full1(Almost_Full),
			.Full1(Full),
			.Underrun_Error1(Underrun_Error),
			.Empty_Watermark1(Empty_Watermark),
			.Almost_Empty1(Almost_Empty),
			.Empty1(Empty),
			.DOUT1(DOUT),

			.DIN2(18'h0),
			.PUSH2(1'b0),
			.POP2(1'b0),
			.Push_Clk2(1'b0),
			.Pop_Clk2(1'b0),
			.Async_Flush2(1'b0),
			.Overrun_Error2(),
			.Full_Watermark2(),
			.Almost_Full2(),
			.Full2(),
			.Underrun_Error2(),
			.Empty_Watermark2(),
			.Almost_Empty2(),
			.Empty2(),
			.DOUT2()
	);

endmodule

module AFIFO_18K_X2_BLK (
		DIN1,
		PUSH1,
		POP1,
		Push_Clk1,
	Pop_Clk1,
		Async_Flush1,
		Overrun_Error1,
		Full_Watermark1,
		Almost_Full1,
		Full1,
		Underrun_Error1,
		Empty_Watermark1,
		Almost_Empty1,
		Empty1,
		DOUT1,

		DIN2,
		PUSH2,
		POP2,
		Push_Clk2,
	Pop_Clk2,
		Async_Flush2,
		Overrun_Error2,
		Full_Watermark2,
		Almost_Full2,
		Full2,
		Underrun_Error2,
		Empty_Watermark2,
		Almost_Empty2,
		Empty2,
		DOUT2
);

	parameter WR1_DATA_WIDTH = 18;
	parameter RD1_DATA_WIDTH = 18;

	parameter WR2_DATA_WIDTH = 18;
	parameter RD2_DATA_WIDTH = 18;

	parameter UPAE_DBITS1 = 12'd10;
	parameter UPAF_DBITS1 = 12'd10;

	parameter UPAE_DBITS2 = 11'd10;
	parameter UPAF_DBITS2 = 11'd10;

	input Push_Clk1, Pop_Clk1;
	input PUSH1, POP1;
	input [WR1_DATA_WIDTH-1:0] DIN1;
	input Async_Flush1;
	output [RD1_DATA_WIDTH-1:0] DOUT1;
	output Almost_Full1, Almost_Empty1;
	output Full1, Empty1;
	output Full_Watermark1, Empty_Watermark1;
	output Overrun_Error1, Underrun_Error1;

	input Push_Clk2, Pop_Clk2;
	input PUSH2, POP2;
	input [WR2_DATA_WIDTH-1:0] DIN2;
	input Async_Flush2;
	output [RD2_DATA_WIDTH-1:0] DOUT2;
	output Almost_Full2, Almost_Empty2;
	output Full2, Empty2;
	output Full_Watermark2, Empty_Watermark2;
	output Overrun_Error2, Underrun_Error2;

	// Fixed mode settings
	localparam [ 0:0] SYNC_FIFO1_i  = 1'd0;
	localparam [ 0:0] FMODE1_i      = 1'd1;
	localparam [ 0:0] POWERDN1_i    = 1'd0;
	localparam [ 0:0] SLEEP1_i      = 1'd0;
	localparam [ 0:0] PROTECT1_i    = 1'd0;
	localparam [11:0] UPAE1_i       = UPAE_DBITS1;
	localparam [11:0] UPAF1_i       = UPAF_DBITS1;

	localparam [ 0:0] SYNC_FIFO2_i  = 1'd0;
	localparam [ 0:0] FMODE2_i      = 1'd1;
	localparam [ 0:0] POWERDN2_i    = 1'd0;
	localparam [ 0:0] SLEEP2_i      = 1'd0;
	localparam [ 0:0] PROTECT2_i    = 1'd0;
	localparam [10:0] UPAE2_i       = UPAE_DBITS2;
	localparam [10:0] UPAF2_i       = UPAF_DBITS2;

	// Width mode function
	function [2:0] mode;
	input integer width;
	case (width)
	1: mode = 3'b101;
	2: mode = 3'b110;
	4: mode = 3'b100;
	8,9: mode = 3'b001;
	16, 18: mode = 3'b010;
	32, 36: mode = 3'b011;
	default: mode = 3'b000;
	endcase
	endfunction

	function integer rwmode;
	input integer rwwidth;
	case (rwwidth)
	1: rwmode = 1;
	2: rwmode = 2;
	4: rwmode = 4;
	8,9: rwmode = 9;
	16, 18: rwmode = 18;
	default: rwmode = 18;
	endcase
	endfunction

	wire [17:0] in_reg1;
	wire [17:0] out_reg1;
	wire [17:0] fifo1_flags;

	wire [17:0] in_reg2;
	wire [17:0] out_reg2;
	wire [17:0] fifo2_flags;

	wire Push_Clk1, Pop_Clk1;
	wire Push_Clk2, Pop_Clk2;

	assign Overrun_Error1 = fifo1_flags[0];
	assign Full_Watermark1 = fifo1_flags[1];
	assign Almost_Full1 = fifo1_flags[2];
	assign Full1 = fifo1_flags[3];
	assign Underrun_Error1 = fifo1_flags[4];
	assign Empty_Watermark1 = fifo1_flags[5];
	assign Almost_Empty1 = fifo1_flags[6];
	assign Empty1 = fifo1_flags[7];

	assign Overrun_Error2 = fifo2_flags[0];
	assign Full_Watermark2 = fifo2_flags[1];
	assign Almost_Full2 = fifo2_flags[2];
	assign Full2 = fifo2_flags[3];
	assign Underrun_Error2 = fifo2_flags[4];
	assign Empty_Watermark2 = fifo2_flags[5];
	assign Almost_Empty2 = fifo2_flags[6];
	assign Empty2 = fifo2_flags[7];

	localparam [ 2:0] RMODE_A1_i    = mode(WR1_DATA_WIDTH);
	localparam [ 2:0] WMODE_A1_i    = mode(WR1_DATA_WIDTH);
	localparam [ 2:0] RMODE_A2_i    = mode(WR2_DATA_WIDTH);
	localparam [ 2:0] WMODE_A2_i    = mode(WR2_DATA_WIDTH);

	localparam [ 2:0] RMODE_B1_i    = mode(RD1_DATA_WIDTH);
	localparam [ 2:0] WMODE_B1_i    = mode(RD1_DATA_WIDTH);
	localparam [ 2:0] RMODE_B2_i    = mode(RD2_DATA_WIDTH);
	localparam [ 2:0] WMODE_B2_i    = mode(RD2_DATA_WIDTH);

	localparam PORT_A1_WRWIDTH = rwmode(WR1_DATA_WIDTH);
	localparam PORT_B1_WRWIDTH = rwmode(RD1_DATA_WIDTH);
	localparam PORT_A2_WRWIDTH = rwmode(WR2_DATA_WIDTH);
	localparam PORT_B2_WRWIDTH = rwmode(RD2_DATA_WIDTH);

	generate
		if (WR1_DATA_WIDTH == 18) begin
			assign in_reg1[17:0] = DIN1[17:0];
		end else if (WR1_DATA_WIDTH == 9) begin
			assign in_reg1[17:0] = {1'b0, DIN1[8], 8'h0, DIN1[7:0]};
		end else begin
			assign in_reg1[17:WR1_DATA_WIDTH]  = 0;
			assign in_reg1[WR1_DATA_WIDTH-1:0] = DIN1[WR1_DATA_WIDTH-1:0];
		end
	endgenerate

	generate
		if (RD1_DATA_WIDTH == 9) begin
			assign DOUT1[RD1_DATA_WIDTH-1:0] = {out_reg1[16], out_reg1[7:0]};
		end else begin
			assign DOUT1[RD1_DATA_WIDTH-1:0] = out_reg1[RD1_DATA_WIDTH-1:0];
		end
	endgenerate

	generate
		if (WR2_DATA_WIDTH == 18) begin
			assign in_reg2[17:0] = DIN2[17:0];
		end else if (WR2_DATA_WIDTH == 9) begin
			assign in_reg2[17:0] = {1'b0, DIN2[8], 8'h0, DIN2[7:0]};
		end else begin
			assign in_reg2[17:WR2_DATA_WIDTH]  = 0;
			assign in_reg2[WR2_DATA_WIDTH-1:0] = DIN2[WR2_DATA_WIDTH-1:0];
		end
	endgenerate

	generate
		if (RD2_DATA_WIDTH == 9) begin
			assign DOUT2[RD2_DATA_WIDTH-1:0] = {out_reg2[16], out_reg2[7:0]};
		end else begin
			assign DOUT2[RD2_DATA_WIDTH-1:0] = out_reg2[RD2_DATA_WIDTH-1:0];
		end
	endgenerate

	defparam _TECHMAP_REPLACE_.MODE_BITS = { 1'b1,
	UPAF2_i, UPAE2_i, PROTECT2_i, SLEEP2_i, POWERDN2_i, FMODE2_i, WMODE_B2_i, WMODE_A2_i, RMODE_B2_i, RMODE_A2_i, SYNC_FIFO2_i,
	UPAF1_i, UPAE1_i, PROTECT1_i, SLEEP1_i, POWERDN1_i, FMODE1_i, WMODE_B1_i, WMODE_A1_i, RMODE_B1_i, RMODE_A1_i, SYNC_FIFO1_i
	};

	(* is_fifo = 1 *)
	(* sync_fifo = 0 *)
	(* is_split = 1 *)
	(* is_inferred = 0 *)
	(* port_a1_dwidth = PORT_A1_WRWIDTH *)
	(* port_a2_dwidth = PORT_A2_WRWIDTH *)
	(* port_b1_dwidth = PORT_B1_WRWIDTH *)
	(* port_b2_dwidth = PORT_B2_WRWIDTH *)
 	TDP36K _TECHMAP_REPLACE_ (
		.RESET_ni(1'b1),
		.WDATA_A1_i(in_reg1[17:0]),
		.WDATA_A2_i(in_reg2[17:0]),
		.RDATA_A1_o(fifo1_flags),
		.RDATA_A2_o(fifo2_flags),
		.ADDR_A1_i(14'h0),
		.ADDR_A2_i(14'h0),
		.CLK_A1_i(Push_Clk1),
		.CLK_A2_i(Push_Clk2),
		.REN_A1_i(1'b1),
		.REN_A2_i(1'b1),
		.WEN_A1_i(PUSH1),
		.WEN_A2_i(PUSH2),
		.BE_A1_i(2'b11),
		.BE_A2_i(2'b11),

		.WDATA_B1_i(18'h0),
		.WDATA_B2_i(18'h0),
		.RDATA_B1_o(out_reg1[17:0]),
		.RDATA_B2_o(out_reg2[17:0]),
		.ADDR_B1_i(14'h0),
		.ADDR_B2_i(14'h0),
		.CLK_B1_i(Pop_Clk1),
		.CLK_B2_i(Pop_Clk2),
		.REN_B1_i(POP1),
		.REN_B2_i(POP2),
		.WEN_B1_i(1'b0),
		.WEN_B2_i(1'b0),
		.BE_B1_i(2'b11),
		.BE_B2_i(2'b11),

		.FLUSH1_i(Async_Flush1),
		.FLUSH2_i(Async_Flush2)
	);

endmodule

module BRAM2x18_SP (
		RESET_ni,

		WEN1_i,
		REN1_i,
		WR1_CLK_i,
		RD1_CLK_i,
		WR1_BE_i,
		WR1_ADDR_i,
		RD1_ADDR_i,
		WDATA1_i,
		RDATA1_o,

		WEN2_i,
		REN2_i,
		WR2_CLK_i,
		RD2_CLK_i,
		WR2_BE_i,
		WR2_ADDR_i,
		RD2_ADDR_i,
		WDATA2_i,
		RDATA2_o
);

parameter WR1_ADDR_WIDTH = 10;
parameter RD1_ADDR_WIDTH = 10;
parameter WR1_DATA_WIDTH = 18;
parameter RD1_DATA_WIDTH = 18;
parameter BE1_WIDTH = 2;

parameter WR2_ADDR_WIDTH = 10;
parameter RD2_ADDR_WIDTH = 10;
parameter WR2_DATA_WIDTH = 18;
parameter RD2_DATA_WIDTH = 18;
parameter BE2_WIDTH = 2;

input wire RESET_ni;

input wire WEN1_i;
input wire REN1_i;
input wire WR1_CLK_i;
input wire RD1_CLK_i;
input wire [BE1_WIDTH-1:0] WR1_BE_i;
input wire [WR1_ADDR_WIDTH-1 :0] WR1_ADDR_i;
input wire [RD1_ADDR_WIDTH-1 :0] RD1_ADDR_i;
input wire [WR1_DATA_WIDTH-1 :0] WDATA1_i;
output wire [RD1_DATA_WIDTH-1 :0] RDATA1_o;

input wire WEN2_i;
input wire REN2_i;
input wire WR2_CLK_i;
input wire RD2_CLK_i;
input wire [BE2_WIDTH-1:0] WR2_BE_i;
input wire [WR2_ADDR_WIDTH-1 :0] WR2_ADDR_i;
input wire [RD2_ADDR_WIDTH-1 :0] RD2_ADDR_i;
input wire [WR2_DATA_WIDTH-1 :0] WDATA2_i;
output wire [RD2_DATA_WIDTH-1 :0] RDATA2_o;

// Fixed mode settings
localparam [ 0:0] SYNC_FIFO1_i  = 1'd0;
localparam [ 0:0] FMODE1_i      = 1'd0;
localparam [ 0:0] POWERDN1_i    = 1'd0;
localparam [ 0:0] SLEEP1_i      = 1'd0;
localparam [ 0:0] PROTECT1_i    = 1'd0;
localparam [11:0] UPAE1_i       = 12'd10;
localparam [11:0] UPAF1_i       = 12'd10;

localparam [ 0:0] SYNC_FIFO2_i  = 1'd0;
localparam [ 0:0] FMODE2_i      = 1'd0;
localparam [ 0:0] POWERDN2_i    = 1'd0;
localparam [ 0:0] SLEEP2_i      = 1'd0;
localparam [ 0:0] PROTECT2_i    = 1'd0;
localparam [10:0] UPAE2_i       = 11'd10;
localparam [10:0] UPAF2_i       = 11'd10;

// Width mode function
function [2:0] mode;
input integer width;
case (width)
1: mode = 3'b101;
2: mode = 3'b110;
4: mode = 3'b100;
8,9: mode = 3'b001;
16, 18: mode = 3'b010;
32, 36: mode = 3'b011;
default: mode = 3'b000;
endcase
endfunction

function integer rwmode;
input integer rwwidth;
case (rwwidth)
1: rwmode = 1;
2: rwmode = 2;
4: rwmode = 4;
8,9: rwmode = 9;
16, 18: rwmode = 18;
default: rwmode = 18;
endcase
endfunction

wire REN_A1_i;
wire REN_A2_i;

wire REN_B1_i;
wire REN_B2_i;

wire WEN_A1_i;
wire WEN_A2_i;

wire WEN_B1_i;
wire WEN_B2_i;

wire [1:0] BE_A1_i;
wire [1:0] BE_A2_i;

wire [1:0] BE_B1_i;
wire [1:0] BE_B2_i;

wire [14:0] ADDR_A1_i;
wire [13:0] ADDR_A2_i;

wire [14:0] ADDR_B1_i;
wire [13:0] ADDR_B2_i;

wire [17:0] WDATA_A1_i;
wire [17:0] WDATA_A2_i;

wire [17:0] WDATA_B1_i;
wire [17:0] WDATA_B2_i;

wire [17:0] RDATA_A1_o;
wire [17:0] RDATA_A2_o;

wire [17:0] RDATA_B1_o;
wire [17:0] RDATA_B2_o;

wire [1:0] WR1_BE;
wire [1:0] WR2_BE;

wire [17:0] PORT_B1_RDATA;
wire [17:0] PORT_A1_WDATA;

wire [17:0] PORT_B2_RDATA;
wire [17:0] PORT_A2_WDATA;

wire [13:0] WR1_ADDR_INT;
wire [13:0] RD1_ADDR_INT;

wire [13:0] WR2_ADDR_INT;
wire [13:0] RD2_ADDR_INT;

wire [13:0] PORT_A1_ADDR;
wire [13:0] PORT_B1_ADDR;

wire [13:0] PORT_A2_ADDR;
wire [13:0] PORT_B2_ADDR;


// Set port width mode (In non-split mode A2/B2 is not active. Set same values anyway to match previous behavior.)
localparam [ 2:0] RMODE_A1_i    = mode(WR1_DATA_WIDTH);
localparam [ 2:0] WMODE_A1_i    = mode(WR1_DATA_WIDTH);
localparam [ 2:0] RMODE_A2_i    = mode(WR2_DATA_WIDTH);
localparam [ 2:0] WMODE_A2_i    = mode(WR2_DATA_WIDTH);

localparam [ 2:0] RMODE_B1_i    = mode(RD1_DATA_WIDTH);
localparam [ 2:0] WMODE_B1_i    = mode(RD1_DATA_WIDTH);
localparam [ 2:0] RMODE_B2_i    = mode(RD2_DATA_WIDTH);
localparam [ 2:0] WMODE_B2_i    = mode(RD2_DATA_WIDTH);

localparam PORT_A1_WRWIDTH = rwmode(WR1_DATA_WIDTH);
localparam PORT_B1_WRWIDTH = rwmode(RD1_DATA_WIDTH);
localparam PORT_A2_WRWIDTH = rwmode(WR2_DATA_WIDTH);
localparam PORT_B2_WRWIDTH = rwmode(RD2_DATA_WIDTH);

generate
	if (WR1_ADDR_WIDTH == 14) begin
		assign WR1_ADDR_INT = WR1_ADDR_i;
	end else begin
		assign WR1_ADDR_INT[13:WR1_ADDR_WIDTH] = 0;
		assign WR1_ADDR_INT[WR1_ADDR_WIDTH-1:0] = WR1_ADDR_i;
	end
endgenerate

case (WR1_DATA_WIDTH)
	1: begin
		assign PORT_A1_ADDR = WR1_ADDR_INT;
	end
	2: begin
		assign PORT_A1_ADDR = WR1_ADDR_INT << 1;
	end
	4: begin
		assign PORT_A1_ADDR = WR1_ADDR_INT << 2;
	end
	8, 9: begin
		assign PORT_A1_ADDR = WR1_ADDR_INT << 3;
	end
	16, 18: begin
		assign PORT_A1_ADDR = WR1_ADDR_INT << 4;
	end
	default: begin
		assign PORT_A1_ADDR = WR1_ADDR_INT;
	end
endcase

generate
	if (RD1_ADDR_WIDTH == 14) begin
		assign RD1_ADDR_INT = RD1_ADDR_i;
	end else begin
		assign RD1_ADDR_INT[13:RD1_ADDR_WIDTH] = 0;
		assign RD1_ADDR_INT[RD1_ADDR_WIDTH-1:0] = RD1_ADDR_i;
	end
endgenerate

case (RD1_DATA_WIDTH)
	1: begin
		assign PORT_B1_ADDR = RD1_ADDR_INT;
	end
	2: begin
		assign PORT_B1_ADDR = RD1_ADDR_INT << 1;
	end
	4: begin
		assign PORT_B1_ADDR = RD1_ADDR_INT << 2;
	end
	8, 9: begin
		assign PORT_B1_ADDR = RD1_ADDR_INT << 3;
	end
	16, 18: begin
		assign PORT_B1_ADDR = RD1_ADDR_INT << 4;
	end
	default: begin
		assign PORT_B1_ADDR = RD1_ADDR_INT;
	end
endcase

generate
	if (WR2_ADDR_WIDTH == 14) begin
		assign WR2_ADDR_INT = WR2_ADDR_i;
	end else begin
		assign WR2_ADDR_INT[13:WR2_ADDR_WIDTH] = 0;
		assign WR2_ADDR_INT[WR2_ADDR_WIDTH-1:0] = WR2_ADDR_i;
	end
endgenerate

case (WR2_DATA_WIDTH)
	1: begin
		assign PORT_A2_ADDR = WR2_ADDR_INT;
	end
	2: begin
		assign PORT_A2_ADDR = WR2_ADDR_INT << 1;
	end
	4: begin
		assign PORT_A2_ADDR = WR2_ADDR_INT << 2;
	end
	8, 9: begin
		assign PORT_A2_ADDR = WR2_ADDR_INT << 3;
	end
	16, 18: begin
		assign PORT_A2_ADDR = WR2_ADDR_INT << 4;
	end
	default: begin
		assign PORT_A2_ADDR = WR2_ADDR_INT;
	end
endcase

generate
	if (RD2_ADDR_WIDTH == 14) begin
		assign RD2_ADDR_INT = RD2_ADDR_i;
	end else begin
		assign RD2_ADDR_INT[13:RD2_ADDR_WIDTH] = 0;
		assign RD2_ADDR_INT[RD2_ADDR_WIDTH-1:0] = RD2_ADDR_i;
	end
endgenerate

case (RD2_DATA_WIDTH)
	1: begin
		assign PORT_B2_ADDR = RD2_ADDR_INT;
	end
	2: begin
		assign PORT_B2_ADDR = RD2_ADDR_INT << 1;
	end
	4: begin
		assign PORT_B2_ADDR = RD2_ADDR_INT << 2;
	end
	8, 9: begin
		assign PORT_B2_ADDR = RD2_ADDR_INT << 3;
	end
	16, 18: begin
		assign PORT_B2_ADDR = RD2_ADDR_INT << 4;
	end
	default: begin
		assign PORT_B2_ADDR = RD2_ADDR_INT;
	end
endcase

case (BE1_WIDTH)
	2: begin
		assign WR1_BE = WR1_BE_i[BE1_WIDTH-1 :0];
	end
	default: begin
		assign WR1_BE[1:BE1_WIDTH] = 0;
		assign WR1_BE[BE1_WIDTH-1 :0] = WR1_BE_i[BE1_WIDTH-1 :0];
	end
endcase

case (BE2_WIDTH)
	2: begin
		assign WR2_BE = WR2_BE_i[BE2_WIDTH-1 :0];
	end
	default: begin
		assign WR2_BE[1:BE2_WIDTH] = 0;
		assign WR2_BE[BE2_WIDTH-1 :0] = WR2_BE_i[BE2_WIDTH-1 :0];
	end
endcase

assign REN_A1_i = 1'b0;
assign WEN_A1_i = WEN1_i;
assign BE_A1_i = WR1_BE;
assign REN_A2_i = 1'b0;
assign WEN_A2_i = WEN2_i;
assign BE_A2_i = WR2_BE;

assign REN_B1_i = REN1_i;
assign WEN_B1_i = 1'b0;
assign BE_B1_i = 4'h0;
assign REN_B2_i = REN2_i;
assign WEN_B2_i = 1'b0;
assign BE_B2_i = 4'h0;

generate
	if (WR1_DATA_WIDTH == 18) begin
		assign PORT_A1_WDATA[WR1_DATA_WIDTH-1:0] = WDATA1_i[WR1_DATA_WIDTH-1:0];
	end else if (WR1_DATA_WIDTH == 9) begin
		assign PORT_A1_WDATA = {1'b0, WDATA1_i[8], 8'h0, WDATA1_i[7:0]};
	end else begin
		assign PORT_A1_WDATA[17:WR1_DATA_WIDTH] = 0;
		assign PORT_A1_WDATA[WR1_DATA_WIDTH-1:0] = WDATA1_i[WR1_DATA_WIDTH-1:0];
	end
endgenerate

assign WDATA_A1_i = PORT_A1_WDATA[17:0];
assign WDATA_B1_i = 18'h0;

generate
	if (RD1_DATA_WIDTH == 9) begin
		assign PORT_B1_RDATA = { 9'h0, RDATA_B1_o[16], RDATA_B1_o[7:0]};
	end else begin
		assign PORT_B1_RDATA = RDATA_B1_o;
	end
endgenerate

assign RDATA1_o = PORT_B1_RDATA[RD1_DATA_WIDTH-1:0];

generate
	if (WR2_DATA_WIDTH == 18) begin
		assign PORT_A2_WDATA[WR2_DATA_WIDTH-1:0] = WDATA2_i[WR2_DATA_WIDTH-1:0];
	end else if (WR2_DATA_WIDTH == 9) begin
		assign PORT_A2_WDATA = {1'b0, WDATA2_i[8], 8'h0, WDATA2_i[7:0]};
	end else begin
		assign PORT_A2_WDATA[17:WR2_DATA_WIDTH] = 0;
		assign PORT_A2_WDATA[WR2_DATA_WIDTH-1:0] = WDATA2_i[WR2_DATA_WIDTH-1:0];
	end
endgenerate

assign WDATA_A2_i = PORT_A2_WDATA[17:0];
assign WDATA_B2_i = 18'h0;

generate
	if (RD2_DATA_WIDTH == 9) begin
		assign PORT_B2_RDATA = { 9'h0, RDATA_B2_o[16], RDATA_B2_o[7:0]};
	end else begin
		assign PORT_B2_RDATA = RDATA_B2_o;
	end
endgenerate

assign RDATA2_o = PORT_B2_RDATA[RD2_DATA_WIDTH-1:0];

defparam _TECHMAP_REPLACE_.MODE_BITS = { 1'b1,
	UPAF2_i, UPAE2_i, PROTECT2_i, SLEEP2_i, POWERDN2_i, FMODE2_i, WMODE_B2_i, WMODE_A2_i, RMODE_B2_i, RMODE_A2_i, SYNC_FIFO2_i,
	UPAF1_i, UPAE1_i, PROTECT1_i, SLEEP1_i, POWERDN1_i, FMODE1_i, WMODE_B1_i, WMODE_A1_i, RMODE_B1_i, RMODE_A1_i, SYNC_FIFO1_i
};

(* is_inferred = 0 *)
(* is_split = 0 *)
(* is_fifo = 0 *)
(* port_a_dwidth = PORT_A1_WRWIDTH *)
(* port_b_dwidth = PORT_B1_WRWIDTH *)
TDP36K _TECHMAP_REPLACE_ (
	.RESET_ni(1'b1),

	.CLK_A1_i(WR1_CLK_i),
	.ADDR_A1_i({1'b0,PORT_A1_ADDR}),
	.WEN_A1_i(WEN_A1_i),
	.BE_A1_i(BE_A1_i),
	.WDATA_A1_i(WDATA_A1_i),
	.REN_A1_i(REN_A1_i),
	.RDATA_A1_o(RDATA_A1_o),

	.CLK_A2_i(WR2_CLK_i),
	.ADDR_A2_i(PORT_A2_ADDR),
	.WEN_A2_i(WEN_A2_i),
	.BE_A2_i(BE_A2_i),
	.WDATA_A2_i(WDATA_A2_i),
	.REN_A2_i(REN_A2_i),
	.RDATA_A2_o(RDATA_A2_o),

	.CLK_B1_i(RD1_CLK_i),
	.ADDR_B1_i({1'b0,PORT_B1_ADDR}),
	.WEN_B1_i(WEN_B1_i),
	.BE_B1_i(BE_B1_i),
	.WDATA_B1_i(WDATA_B1_i),
	.REN_B1_i(REN_B1_i),
	.RDATA_B1_o(RDATA_B1_o),

	.CLK_B2_i(RD2_CLK_i),
	.ADDR_B2_i(PORT_B2_ADDR),
	.WEN_B2_i(WEN_B2_i),
	.BE_B2_i(BE_B2_i),
	.WDATA_B2_i(WDATA_B2_i),
	.REN_B2_i(REN_B2_i),
	.RDATA_B2_o(RDATA_B2_o),

	.FLUSH1_i(1'b0),
	.FLUSH2_i(1'b0)
);

endmodule

module BRAM2x18_dP (
		PORT_A1_CLK_i,
		PORT_A1_WEN_i,
		PORT_A1_WR_BE_i,
		PORT_A1_REN_i,
		PORT_A1_ADDR_i,
		PORT_A1_WR_DATA_i,
		PORT_A1_RD_DATA_o,

		PORT_B1_CLK_i,
		PORT_B1_WEN_i,
		PORT_B1_WR_BE_i,
		PORT_B1_REN_i,
		PORT_B1_ADDR_i,
		PORT_B1_WR_DATA_i,
		PORT_B1_RD_DATA_o,

		PORT_A2_CLK_i,
		PORT_A2_WEN_i,
		PORT_A2_WR_BE_i,
		PORT_A2_REN_i,
		PORT_A2_ADDR_i,
		PORT_A2_WR_DATA_i,
		PORT_A2_RD_DATA_o,

		PORT_B2_CLK_i,
		PORT_B2_WEN_i,
		PORT_B2_WR_BE_i,
		PORT_B2_REN_i,
		PORT_B2_ADDR_i,
		PORT_B2_WR_DATA_i,
		PORT_B2_RD_DATA_o
);

parameter PORT_A1_AWIDTH = 10;
parameter PORT_A1_DWIDTH = 18;
parameter PORT_A1_WR_BE_WIDTH = 2;

parameter PORT_B1_AWIDTH = 10;
parameter PORT_B1_DWIDTH = 18;
parameter PORT_B1_WR_BE_WIDTH = 2;

parameter PORT_A2_AWIDTH = 10;
parameter PORT_A2_DWIDTH = 18;
parameter PORT_A2_WR_BE_WIDTH = 2;

parameter PORT_B2_AWIDTH = 10;
parameter PORT_B2_DWIDTH = 18;
parameter PORT_B2_WR_BE_WIDTH = 2;

input PORT_A1_CLK_i;
input [PORT_A1_AWIDTH-1:0] PORT_A1_ADDR_i;
input [PORT_A1_DWIDTH-1:0] PORT_A1_WR_DATA_i;
input PORT_A1_WEN_i;
input [PORT_A1_WR_BE_WIDTH-1:0] PORT_A1_WR_BE_i;
input PORT_A1_REN_i;
output [PORT_A1_DWIDTH-1:0] PORT_A1_RD_DATA_o;

input PORT_B1_CLK_i;
input [PORT_B1_AWIDTH-1:0] PORT_B1_ADDR_i;
input [PORT_B1_DWIDTH-1:0] PORT_B1_WR_DATA_i;
input PORT_B1_WEN_i;
input [PORT_B1_WR_BE_WIDTH-1:0] PORT_B1_WR_BE_i;
input PORT_B1_REN_i;
output [PORT_B1_DWIDTH-1:0] PORT_B1_RD_DATA_o;

input PORT_A2_CLK_i;
input [PORT_A2_AWIDTH-1:0] PORT_A2_ADDR_i;
input [PORT_A2_DWIDTH-1:0] PORT_A2_WR_DATA_i;
input PORT_A2_WEN_i;
input [PORT_A2_WR_BE_WIDTH-1:0] PORT_A2_WR_BE_i;
input PORT_A2_REN_i;
output [PORT_A2_DWIDTH-1:0] PORT_A2_RD_DATA_o;

input PORT_B2_CLK_i;
input [PORT_B2_AWIDTH-1:0] PORT_B2_ADDR_i;
input [PORT_B2_DWIDTH-1:0] PORT_B2_WR_DATA_i;
input PORT_B2_WEN_i;
input [PORT_B2_WR_BE_WIDTH-1:0] PORT_B2_WR_BE_i;
input PORT_B2_REN_i;
output [PORT_B2_DWIDTH-1:0] PORT_B2_RD_DATA_o;


// Fixed mode settings
localparam [ 0:0] SYNC_FIFO1_i  = 1'd0;
localparam [ 0:0] FMODE1_i      = 1'd0;
localparam [ 0:0] POWERDN1_i    = 1'd0;
localparam [ 0:0] SLEEP1_i      = 1'd0;
localparam [ 0:0] PROTECT1_i    = 1'd0;
localparam [11:0] UPAE1_i       = 12'd10;
localparam [11:0] UPAF1_i       = 12'd10;

localparam [ 0:0] SYNC_FIFO2_i  = 1'd0;
localparam [ 0:0] FMODE2_i      = 1'd0;
localparam [ 0:0] POWERDN2_i    = 1'd0;
localparam [ 0:0] SLEEP2_i      = 1'd0;
localparam [ 0:0] PROTECT2_i    = 1'd0;
localparam [10:0] UPAE2_i       = 11'd10;
localparam [10:0] UPAF2_i       = 11'd10;

// Width mode function
function [2:0] mode;
input integer width;
case (width)
1: mode = 3'b101;
2: mode = 3'b110;
4: mode = 3'b100;
8,9: mode = 3'b001;
16, 18: mode = 3'b010;
32, 36: mode = 3'b011;
default: mode = 3'b000;
endcase
endfunction

function integer rwmode;
input integer rwwidth;
case (rwwidth)
1: rwmode = 1;
2: rwmode = 2;
4: rwmode = 4;
8,9: rwmode = 9;
16, 18: rwmode = 18;
default: rwmode = 18;
endcase
endfunction

wire REN_A1_i;
wire REN_A2_i;

wire REN_B1_i;
wire REN_B2_i;

wire WEN_A1_i;
wire WEN_A2_i;

wire WEN_B1_i;
wire WEN_B2_i;

wire [1:0] BE_A1_i;
wire [1:0] BE_A2_i;

wire [1:0] BE_B1_i;
wire [1:0] BE_B2_i;

wire [14:0] ADDR_A1_i;
wire [13:0] ADDR_A2_i;

wire [14:0] ADDR_B1_i;
wire [13:0] ADDR_B2_i;

wire [17:0] WDATA_A1_i;
wire [17:0] WDATA_A2_i;

wire [17:0] WDATA_B1_i;
wire [17:0] WDATA_B2_i;

wire [17:0] RDATA_A1_o;
wire [17:0] RDATA_A2_o;

wire [17:0] RDATA_B1_o;
wire [17:0] RDATA_B2_o;

wire [1:0] PORT_A1_WR_BE;
wire [1:0] PORT_B1_WR_BE;

wire [1:0] PORT_A2_WR_BE;
wire [1:0] PORT_B2_WR_BE;

wire [17:0] PORT_B1_WDATA;
wire [17:0] PORT_B1_RDATA;
wire [17:0] PORT_A1_WDATA;
wire [17:0] PORT_A1_RDATA;

wire [17:0] PORT_B2_WDATA;
wire [17:0] PORT_B2_RDATA;
wire [17:0] PORT_A2_WDATA;
wire [17:0] PORT_A2_RDATA;

wire [13:0] PORT_A1_ADDR_INT;
wire [13:0] PORT_B1_ADDR_INT;

wire [13:0] PORT_A2_ADDR_INT;
wire [13:0] PORT_B2_ADDR_INT;

wire [13:0] PORT_A1_ADDR;
wire [13:0] PORT_B1_ADDR;

wire [13:0] PORT_A2_ADDR;
wire [13:0] PORT_B2_ADDR;

wire PORT_A1_CLK;
wire PORT_B1_CLK;

wire PORT_A2_CLK;
wire PORT_B2_CLK;

// Set port width mode (In non-split mode A2/B2 is not active. Set same values anyway to match previous behavior.)
localparam [ 2:0] RMODE_A1_i    = mode(PORT_A1_DWIDTH);
localparam [ 2:0] WMODE_A1_i    = mode(PORT_A1_DWIDTH);
localparam [ 2:0] RMODE_A2_i    = mode(PORT_A2_DWIDTH);
localparam [ 2:0] WMODE_A2_i    = mode(PORT_A2_DWIDTH);

localparam [ 2:0] RMODE_B1_i    = mode(PORT_B1_DWIDTH);
localparam [ 2:0] WMODE_B1_i    = mode(PORT_B1_DWIDTH);
localparam [ 2:0] RMODE_B2_i    = mode(PORT_B2_DWIDTH);
localparam [ 2:0] WMODE_B2_i    = mode(PORT_B2_DWIDTH);

localparam PORT_A1_WRWIDTH = rwmode(PORT_A1_DWIDTH);
localparam PORT_B1_WRWIDTH = rwmode(PORT_B1_DWIDTH);
localparam PORT_A2_WRWIDTH = rwmode(PORT_A2_DWIDTH);
localparam PORT_B2_WRWIDTH = rwmode(PORT_B2_DWIDTH);

assign PORT_A1_CLK = PORT_A1_CLK_i;
assign PORT_B1_CLK = PORT_B1_CLK_i;

assign PORT_A2_CLK = PORT_A2_CLK_i;
assign PORT_B2_CLK = PORT_B2_CLK_i;

generate
	if (PORT_A1_AWIDTH == 14) begin
		assign PORT_A1_ADDR_INT = PORT_A1_ADDR_i;
	end else begin
		assign PORT_A1_ADDR_INT[13:PORT_A1_AWIDTH] = 0;
		assign PORT_A1_ADDR_INT[PORT_A1_AWIDTH-1:0] = PORT_A1_ADDR_i;
	end
endgenerate

case (PORT_A1_DWIDTH)
	1: begin
		assign PORT_A1_ADDR = PORT_A1_ADDR_INT;
	end
	2: begin
		assign PORT_A1_ADDR = PORT_A1_ADDR_INT << 1;
	end
	4: begin
		assign PORT_A1_ADDR = PORT_A1_ADDR_INT << 2;
	end
	8, 9: begin
		assign PORT_A1_ADDR = PORT_A1_ADDR_INT << 3;
	end
	16, 18: begin
		assign PORT_A1_ADDR = PORT_A1_ADDR_INT << 4;
	end
	default: begin
		assign PORT_A1_ADDR = PORT_A1_ADDR_INT;
	end
endcase

generate
	if (PORT_B1_AWIDTH == 14) begin
		assign PORT_B1_ADDR_INT = PORT_B1_ADDR_i;
	end else begin
		assign PORT_B1_ADDR_INT[13:PORT_B1_AWIDTH] = 0;
		assign PORT_B1_ADDR_INT[PORT_B1_AWIDTH-1:0] = PORT_B1_ADDR_i;
	end
endgenerate

case (PORT_B1_DWIDTH)
	1: begin
		assign PORT_B1_ADDR = PORT_B1_ADDR_INT;
	end
	2: begin
		assign PORT_B1_ADDR = PORT_B1_ADDR_INT << 1;
	end
	4: begin
		assign PORT_B1_ADDR = PORT_B1_ADDR_INT << 2;
	end
	8, 9: begin
		assign PORT_B1_ADDR = PORT_B1_ADDR_INT << 3;
	end
	16, 18: begin
		assign PORT_B1_ADDR = PORT_B1_ADDR_INT << 4;
	end
	default: begin
		assign PORT_B1_ADDR = PORT_B1_ADDR_INT;
	end
endcase

generate
	if (PORT_A2_AWIDTH == 14) begin
		assign PORT_A2_ADDR_INT = PORT_A2_ADDR_i;
	end else begin
		assign PORT_A2_ADDR_INT[13:PORT_A2_AWIDTH] = 0;
		assign PORT_A2_ADDR_INT[PORT_A2_AWIDTH-1:0] = PORT_A2_ADDR_i;
	end
endgenerate

case (PORT_A2_DWIDTH)
	1: begin
		assign PORT_A2_ADDR = PORT_A2_ADDR_INT;
	end
	2: begin
		assign PORT_A2_ADDR = PORT_A2_ADDR_INT << 1;
	end
	4: begin
		assign PORT_A2_ADDR = PORT_A2_ADDR_INT << 2;
	end
	8, 9: begin
		assign PORT_A2_ADDR = PORT_A2_ADDR_INT << 3;
	end
	16, 18: begin
		assign PORT_A2_ADDR = PORT_A2_ADDR_INT << 4;
	end
	default: begin
		assign PORT_A2_ADDR = PORT_A2_ADDR_INT;
	end
endcase

generate
	if (PORT_B2_AWIDTH == 14) begin
		assign PORT_B2_ADDR_INT = PORT_B2_ADDR_i;
	end else begin
		assign PORT_B2_ADDR_INT[13:PORT_B2_AWIDTH] = 0;
		assign PORT_B2_ADDR_INT[PORT_B2_AWIDTH-1:0] = PORT_B2_ADDR_i;
	end
endgenerate

case (PORT_B2_DWIDTH)
	1: begin
		assign PORT_B2_ADDR = PORT_B2_ADDR_INT;
	end
	2: begin
		assign PORT_B2_ADDR = PORT_B2_ADDR_INT << 1;
	end
	4: begin
		assign PORT_B2_ADDR = PORT_B2_ADDR_INT << 2;
	end
	8, 9: begin
		assign PORT_B2_ADDR = PORT_B2_ADDR_INT << 3;
	end
	16, 18: begin
		assign PORT_B2_ADDR = PORT_B2_ADDR_INT << 4;
	end
	default: begin
		assign PORT_B2_ADDR = PORT_B2_ADDR_INT;
	end
endcase

case (PORT_A1_WR_BE_WIDTH)
	2: begin
		assign PORT_A1_WR_BE = PORT_A1_WR_BE_i[PORT_A1_WR_BE_WIDTH-1 :0];
	end
	default: begin
		assign PORT_A1_WR_BE[1:PORT_A1_WR_BE_WIDTH] = 0;
		assign PORT_A1_WR_BE[PORT_A1_WR_BE_WIDTH-1 :0] = PORT_A1_WR_BE_i[PORT_A1_WR_BE_WIDTH-1 :0];
	end
endcase

case (PORT_B1_WR_BE_WIDTH)
	2: begin
		assign PORT_B1_WR_BE = PORT_B1_WR_BE_i[PORT_B1_WR_BE_WIDTH-1 :0];
	end
	default: begin
		assign PORT_B1_WR_BE[1:PORT_B1_WR_BE_WIDTH] = 0;
		assign PORT_B1_WR_BE[PORT_B1_WR_BE_WIDTH-1 :0] = PORT_B1_WR_BE_i[PORT_B1_WR_BE_WIDTH-1 :0];
	end
endcase

case (PORT_A2_WR_BE_WIDTH)
	2: begin
		assign PORT_A2_WR_BE = PORT_A2_WR_BE_i[PORT_A2_WR_BE_WIDTH-1 :0];
	end
	default: begin
		assign PORT_A2_WR_BE[1:PORT_A2_WR_BE_WIDTH] = 0;
		assign PORT_A2_WR_BE[PORT_A2_WR_BE_WIDTH-1 :0] = PORT_A2_WR_BE_i[PORT_A2_WR_BE_WIDTH-1 :0];
	end
endcase

case (PORT_B2_WR_BE_WIDTH)
	2: begin
		assign PORT_B2_WR_BE = PORT_B2_WR_BE_i[PORT_B2_WR_BE_WIDTH-1 :0];
	end
	default: begin
		assign PORT_B2_WR_BE[1:PORT_B2_WR_BE_WIDTH] = 0;
		assign PORT_B2_WR_BE[PORT_B2_WR_BE_WIDTH-1 :0] = PORT_B2_WR_BE_i[PORT_B2_WR_BE_WIDTH-1 :0];
	end
endcase

assign REN_A1_i = PORT_A1_REN_i;
assign WEN_A1_i = PORT_A1_WEN_i;
assign BE_A1_i  = PORT_A1_WR_BE;

assign REN_A2_i = PORT_A2_REN_i;
assign WEN_A2_i = PORT_A2_WEN_i;
assign BE_A2_i  = PORT_A2_WR_BE;

assign REN_B1_i = PORT_B1_REN_i;
assign WEN_B1_i = PORT_B1_WEN_i;
assign BE_B1_i  = PORT_B1_WR_BE;

assign REN_B2_i = PORT_B2_REN_i;
assign WEN_B2_i = PORT_B2_WEN_i;
assign BE_B2_i  = PORT_B2_WR_BE;

generate
	if (PORT_A1_DWIDTH == 18) begin
		assign PORT_A1_WDATA[PORT_A1_DWIDTH-1:0] = PORT_A1_WR_DATA_i[PORT_A1_DWIDTH-1:0];
	end else if (PORT_A1_DWIDTH == 9) begin
		assign PORT_A1_WDATA = {1'b0, PORT_A1_WR_DATA_i[8], 8'h0, PORT_A1_WR_DATA_i[7:0]};
	end else begin
		assign PORT_A1_WDATA[17:PORT_A1_DWIDTH] = 0;
		assign PORT_A1_WDATA[PORT_A1_DWIDTH-1:0] = PORT_A1_WR_DATA_i[PORT_A1_DWIDTH-1:0];
	end
endgenerate

assign WDATA_A1_i = PORT_A1_WDATA;

generate
	if (PORT_A2_DWIDTH == 18) begin
		assign PORT_A2_WDATA[PORT_A2_DWIDTH-1:0] = PORT_A2_WR_DATA_i[PORT_A2_DWIDTH-1:0];
	end else if (PORT_A2_DWIDTH == 9) begin
		assign PORT_A2_WDATA = {1'b0, PORT_A2_WR_DATA_i[8], 8'h0, PORT_A2_WR_DATA_i[7:0]};
	end else begin
		assign PORT_A2_WDATA[17:PORT_A2_DWIDTH] = 0;
		assign PORT_A2_WDATA[PORT_A2_DWIDTH-1:0] = PORT_A2_WR_DATA_i[PORT_A2_DWIDTH-1:0];
	end
endgenerate

assign WDATA_A2_i = PORT_A2_WDATA;

generate
	if (PORT_A1_DWIDTH == 9) begin
		assign PORT_A1_RDATA = { 9'h0, RDATA_A1_o[16], RDATA_A1_o[7:0]};
	end else begin
		assign PORT_A1_RDATA = RDATA_A1_o;
	end
endgenerate

assign PORT_A1_RD_DATA_o = PORT_A1_RDATA[PORT_A1_DWIDTH-1:0];

generate
	if (PORT_A2_DWIDTH == 9) begin
		assign PORT_A2_RDATA = { 9'h0, RDATA_A2_o[16], RDATA_A2_o[7:0]};
	end else begin
		assign PORT_A2_RDATA = RDATA_A2_o;
	end
endgenerate

assign PORT_A2_RD_DATA_o = PORT_A2_RDATA[PORT_A2_DWIDTH-1:0];

generate
	if (PORT_B1_DWIDTH == 18) begin
		assign PORT_B1_WDATA[PORT_B1_DWIDTH-1:0] = PORT_B1_WR_DATA_i[PORT_B1_DWIDTH-1:0];
	end else if (PORT_B1_DWIDTH == 9) begin
		assign PORT_B1_WDATA = {1'b0, PORT_B1_WR_DATA_i[8], 8'h0, PORT_B1_WR_DATA_i[7:0]};
	end else begin
		assign PORT_B1_WDATA[17:PORT_B1_DWIDTH] = 0;
		assign PORT_B1_WDATA[PORT_B1_DWIDTH-1:0] = PORT_B1_WR_DATA_i[PORT_B1_DWIDTH-1:0];
	end
endgenerate

assign WDATA_B1_i = PORT_B1_WDATA;

generate
	if (PORT_B2_DWIDTH == 18) begin
		assign PORT_B2_WDATA[PORT_B2_DWIDTH-1:0] = PORT_B2_WR_DATA_i[PORT_B2_DWIDTH-1:0];
	end else if (PORT_B2_DWIDTH == 9) begin
		assign PORT_B2_WDATA = {1'b0, PORT_B2_WR_DATA_i[8], 8'h0, PORT_B2_WR_DATA_i[7:0]};
	end else begin
		assign PORT_B2_WDATA[17:PORT_B2_DWIDTH] = 0;
		assign PORT_B2_WDATA[PORT_B2_DWIDTH-1:0] = PORT_B2_WR_DATA_i[PORT_B2_DWIDTH-1:0];
	end
endgenerate

assign WDATA_B2_i = PORT_B2_WDATA;

generate
	if (PORT_B1_DWIDTH == 9) begin
		assign PORT_B1_RDATA = { 9'h0, RDATA_B1_o[16], RDATA_B1_o[7:0]};
	end else begin
		assign PORT_B1_RDATA = RDATA_B1_o;
	end
endgenerate

assign PORT_B1_RD_DATA_o = PORT_B1_RDATA[PORT_B1_DWIDTH-1:0];

generate
	if (PORT_B2_DWIDTH == 9) begin
		assign PORT_B2_RDATA = { 9'h0, RDATA_B2_o[16], RDATA_B2_o[7:0]};
	end else begin
		assign PORT_B2_RDATA = RDATA_B2_o;
	end
endgenerate

assign PORT_B2_RD_DATA_o = PORT_B2_RDATA[PORT_B2_DWIDTH-1:0];

defparam _TECHMAP_REPLACE_.MODE_BITS = { 1'b1,
	UPAF2_i, UPAE2_i, PROTECT2_i, SLEEP2_i, POWERDN2_i, FMODE2_i, WMODE_B2_i, WMODE_A2_i, RMODE_B2_i, RMODE_A2_i, SYNC_FIFO2_i,
	UPAF1_i, UPAE1_i, PROTECT1_i, SLEEP1_i, POWERDN1_i, FMODE1_i, WMODE_B1_i, WMODE_A1_i, RMODE_B1_i, RMODE_A1_i, SYNC_FIFO1_i
};

(* is_inferred = 0 *)
(* is_split = 0 *)
(* is_fifo = 0 *)
(* port_a_dwidth = PORT_A1_WRWIDTH *)
(* port_b_dwidth = PORT_B1_WRWIDTH *)
TDP36K _TECHMAP_REPLACE_ (
	.RESET_ni(1'b1),

	.CLK_A1_i(PORT_A1_CLK),
	.ADDR_A1_i({1'b0,PORT_A1_ADDR}),
	.WEN_A1_i(WEN_A1_i),
	.BE_A1_i(BE_A1_i),
	.WDATA_A1_i(WDATA_A1_i),
	.REN_A1_i(REN_A1_i),
	.RDATA_A1_o(RDATA_A1_o),

	.CLK_A2_i(PORT_A2_CLK),
	.ADDR_A2_i(PORT_A2_ADDR),
	.WEN_A2_i(WEN_A2_i),
	.BE_A2_i(BE_A2_i),
	.WDATA_A2_i(WDATA_A2_i),
	.REN_A2_i(REN_A2_i),
	.RDATA_A2_o(RDATA_A2_o),

	.CLK_B1_i(PORT_B1_CLK),
	.ADDR_B1_i({1'b0,PORT_B1_ADDR}),
	.WEN_B1_i(WEN_B1_i),
	.BE_B1_i(BE_B1_i),
	.WDATA_B1_i(WDATA_B1_i),
	.REN_B1_i(REN_B1_i),
	.RDATA_B1_o(RDATA_B1_o),

	.CLK_B2_i(PORT_B2_CLK),
	.ADDR_B2_i(PORT_B2_ADDR),
	.WEN_B2_i(WEN_B2_i),
	.BE_B2_i(BE_B2_i),
	.WDATA_B2_i(WDATA_B2_i),
	.REN_B2_i(REN_B2_i),
	.RDATA_B2_o(RDATA_B2_o),

	.FLUSH1_i(1'b0),
	.FLUSH2_i(1'b0)
);

endmodule


module BRAM2x18_SFIFO (
		DIN1,
		PUSH1,
		POP1,
		CLK1,
		Async_Flush1,
		Overrun_Error1,
		Full_Watermark1,
		Almost_Full1,
		Full1,
		Underrun_Error1,
		Empty_Watermark1,
		Almost_Empty1,
		Empty1,
		DOUT1,

		DIN2,
		PUSH2,
		POP2,
		CLK2,
		Async_Flush2,
		Overrun_Error2,
		Full_Watermark2,
		Almost_Full2,
		Full2,
		Underrun_Error2,
		Empty_Watermark2,
		Almost_Empty2,
		Empty2,
		DOUT2
);

	parameter WR1_DATA_WIDTH = 18;
	parameter RD1_DATA_WIDTH = 18;

	parameter WR2_DATA_WIDTH = 18;
	parameter RD2_DATA_WIDTH = 18;

	parameter UPAE_DBITS1 = 12'd10;
	parameter UPAF_DBITS1 = 12'd10;

	parameter UPAE_DBITS2 = 11'd10;
	parameter UPAF_DBITS2 = 11'd10;

	input CLK1;
	input PUSH1, POP1;
	input [WR1_DATA_WIDTH-1:0] DIN1;
	input Async_Flush1;
	output [RD1_DATA_WIDTH-1:0] DOUT1;
	output Almost_Full1, Almost_Empty1;
	output Full1, Empty1;
	output Full_Watermark1, Empty_Watermark1;
	output Overrun_Error1, Underrun_Error1;

	input CLK2;
	input PUSH2, POP2;
	input [WR2_DATA_WIDTH-1:0] DIN2;
	input Async_Flush2;
	output [RD2_DATA_WIDTH-1:0] DOUT2;
	output Almost_Full2, Almost_Empty2;
	output Full2, Empty2;
	output Full_Watermark2, Empty_Watermark2;
	output Overrun_Error2, Underrun_Error2;

	// Fixed mode settings
	localparam [ 0:0] SYNC_FIFO1_i  = 1'd1;
	localparam [ 0:0] FMODE1_i      = 1'd1;
	localparam [ 0:0] POWERDN1_i    = 1'd0;
	localparam [ 0:0] SLEEP1_i      = 1'd0;
	localparam [ 0:0] PROTECT1_i    = 1'd0;
	localparam [11:0] UPAE1_i       = UPAE_DBITS1;
	localparam [11:0] UPAF1_i       = UPAF_DBITS1;

	localparam [ 0:0] SYNC_FIFO2_i  = 1'd1;
	localparam [ 0:0] FMODE2_i      = 1'd1;
	localparam [ 0:0] POWERDN2_i    = 1'd0;
	localparam [ 0:0] SLEEP2_i      = 1'd0;
	localparam [ 0:0] PROTECT2_i    = 1'd0;
	localparam [10:0] UPAE2_i       = UPAE_DBITS2;
	localparam [10:0] UPAF2_i       = UPAF_DBITS2;

	// Width mode function
	function [2:0] mode;
	input integer width;
	case (width)
	1: mode = 3'b101;
	2: mode = 3'b110;
	4: mode = 3'b100;
	8,9: mode = 3'b001;
	16, 18: mode = 3'b010;
	32, 36: mode = 3'b011;
	default: mode = 3'b000;
	endcase
	endfunction

	function integer rwmode;
	input integer rwwidth;
	case (rwwidth)
	1: rwmode = 1;
	2: rwmode = 2;
	4: rwmode = 4;
	8,9: rwmode = 9;
	16, 18: rwmode = 18;
	default: rwmode = 18;
	endcase
	endfunction

	wire [17:0] in_reg1;
	wire [17:0] out_reg1;
	wire [17:0] fifo1_flags;

	wire [17:0] in_reg2;
	wire [17:0] out_reg2;
	wire [17:0] fifo2_flags;

	wire Push_Clk1, Pop_Clk1;
	wire Push_Clk2, Pop_Clk2;
	assign Push_Clk1 = CLK1;
	assign Pop_Clk1 = CLK1;
	assign Push_Clk2 = CLK2;
	assign Pop_Clk2 = CLK2;

	assign Overrun_Error1 = fifo1_flags[0];
	assign Full_Watermark1 = fifo1_flags[1];
	assign Almost_Full1 = fifo1_flags[2];
	assign Full1 = fifo1_flags[3];
	assign Underrun_Error1 = fifo1_flags[4];
	assign Empty_Watermark1 = fifo1_flags[5];
	assign Almost_Empty1 = fifo1_flags[6];
	assign Empty1 = fifo1_flags[7];

	assign Overrun_Error2 = fifo2_flags[0];
	assign Full_Watermark2 = fifo2_flags[1];
	assign Almost_Full2 = fifo2_flags[2];
	assign Full2 = fifo2_flags[3];
	assign Underrun_Error2 = fifo2_flags[4];
	assign Empty_Watermark2 = fifo2_flags[5];
	assign Almost_Empty2 = fifo2_flags[6];
	assign Empty2 = fifo2_flags[7];

	localparam [ 2:0] RMODE_A1_i    = mode(WR1_DATA_WIDTH);
	localparam [ 2:0] WMODE_A1_i    = mode(WR1_DATA_WIDTH);
	localparam [ 2:0] RMODE_A2_i    = mode(WR2_DATA_WIDTH);
	localparam [ 2:0] WMODE_A2_i    = mode(WR2_DATA_WIDTH);

	localparam [ 2:0] RMODE_B1_i    = mode(RD1_DATA_WIDTH);
	localparam [ 2:0] WMODE_B1_i    = mode(RD1_DATA_WIDTH);
	localparam [ 2:0] RMODE_B2_i    = mode(RD2_DATA_WIDTH);
	localparam [ 2:0] WMODE_B2_i    = mode(RD2_DATA_WIDTH);

	localparam PORT_A1_WRWIDTH = rwmode(WR1_DATA_WIDTH);
	localparam PORT_B1_WRWIDTH = rwmode(RD1_DATA_WIDTH);
	localparam PORT_A2_WRWIDTH = rwmode(WR2_DATA_WIDTH);
	localparam PORT_B2_WRWIDTH = rwmode(RD2_DATA_WIDTH);

	generate
		if (WR1_DATA_WIDTH == 18) begin
			assign in_reg1[17:0] = DIN1[17:0];
		end else if (WR1_DATA_WIDTH == 9) begin
			assign in_reg1[17:0] = {1'b0, DIN1[8], 8'h0, DIN1[7:0]};
		end else begin
			assign in_reg1[17:WR1_DATA_WIDTH]  = 0;
			assign in_reg1[WR1_DATA_WIDTH-1:0] = DIN1[WR1_DATA_WIDTH-1:0];
		end
	endgenerate

	generate
		if (RD1_DATA_WIDTH == 9) begin
			assign DOUT1[RD1_DATA_WIDTH-1:0] = {out_reg1[16], out_reg1[7:0]};
		end else begin
			assign DOUT1[RD1_DATA_WIDTH-1:0] = out_reg1[RD1_DATA_WIDTH-1:0];
		end
	endgenerate

	generate
		if (WR2_DATA_WIDTH == 18) begin
			assign in_reg2[17:0] = DIN2[17:0];
		end else if (WR2_DATA_WIDTH == 9) begin
			assign in_reg2[17:0] = {1'b0, DIN2[8], 8'h0, DIN2[7:0]};
		end else begin
			assign in_reg2[17:WR2_DATA_WIDTH]  = 0;
			assign in_reg2[WR2_DATA_WIDTH-1:0] = DIN2[WR2_DATA_WIDTH-1:0];
		end
	endgenerate

	generate
		if (RD2_DATA_WIDTH == 9) begin
			assign DOUT2[RD2_DATA_WIDTH-1:0] = {out_reg2[16], out_reg2[7:0]};
		end else begin
			assign DOUT2[RD2_DATA_WIDTH-1:0] = out_reg2[RD2_DATA_WIDTH-1:0];
		end
	endgenerate

	defparam _TECHMAP_REPLACE_.MODE_BITS = { 1'b1,
	UPAF2_i, UPAE2_i, PROTECT2_i, SLEEP2_i, POWERDN2_i, FMODE2_i, WMODE_B2_i, WMODE_A2_i, RMODE_B2_i, RMODE_A2_i, SYNC_FIFO2_i,
	UPAF1_i, UPAE1_i, PROTECT1_i, SLEEP1_i, POWERDN1_i, FMODE1_i, WMODE_B1_i, WMODE_A1_i, RMODE_B1_i, RMODE_A1_i, SYNC_FIFO1_i
	};

	(* is_fifo = 1 *)
	(* sync_fifo = 1 *)
	(* is_split = 0 *)
	(* is_inferred = 0 *)
	(* port_a_dwidth = PORT_A1_WRWIDTH *)
	(* port_b_dwidth = PORT_B1_WRWIDTH *)
 	TDP36K _TECHMAP_REPLACE_ (
		.RESET_ni(1'b1),
		.WDATA_A1_i(in_reg1[17:0]),
		.WDATA_A2_i(in_reg2[17:0]),
		.RDATA_A1_o(fifo1_flags),
		.RDATA_A2_o(fifo2_flags),
		.ADDR_A1_i(14'h0),
		.ADDR_A2_i(14'h0),
		.CLK_A1_i(Push_Clk1),
		.CLK_A2_i(Push_Clk2),
		.REN_A1_i(1'b1),
		.REN_A2_i(1'b1),
		.WEN_A1_i(PUSH1),
		.WEN_A2_i(PUSH2),
		.BE_A1_i(2'b11),
		.BE_A2_i(2'b11),

		.WDATA_B1_i(18'h0),
		.WDATA_B2_i(18'h0),
		.RDATA_B1_o(out_reg1[17:0]),
		.RDATA_B2_o(out_reg2[17:0]),
		.ADDR_B1_i(14'h0),
		.ADDR_B2_i(14'h0),
		.CLK_B1_i(Pop_Clk1),
		.CLK_B2_i(Pop_Clk2),
		.REN_B1_i(POP1),
		.REN_B2_i(POP2),
		.WEN_B1_i(1'b0),
		.WEN_B2_i(1'b0),
		.BE_B1_i(2'b11),
		.BE_B2_i(2'b11),

		.FLUSH1_i(Async_Flush1),
		.FLUSH2_i(Async_Flush2)
	);

endmodule


module BRAM2x18_AFIFO (
		DIN1,
		PUSH1,
		POP1,
		Push_Clk1,
	Pop_Clk1,
		Async_Flush1,
		Overrun_Error1,
		Full_Watermark1,
		Almost_Full1,
		Full1,
		Underrun_Error1,
		Empty_Watermark1,
		Almost_Empty1,
		Empty1,
		DOUT1,

		DIN2,
		PUSH2,
		POP2,
		Push_Clk2,
	Pop_Clk2,
		Async_Flush2,
		Overrun_Error2,
		Full_Watermark2,
		Almost_Full2,
		Full2,
		Underrun_Error2,
		Empty_Watermark2,
		Almost_Empty2,
		Empty2,
		DOUT2
);

	parameter WR1_DATA_WIDTH = 18;
	parameter RD1_DATA_WIDTH = 18;

	parameter WR2_DATA_WIDTH = 18;
	parameter RD2_DATA_WIDTH = 18;

	parameter UPAE_DBITS1 = 12'd10;
	parameter UPAF_DBITS1 = 12'd10;

	parameter UPAE_DBITS2 = 11'd10;
	parameter UPAF_DBITS2 = 11'd10;

	input Push_Clk1, Pop_Clk1;
	input PUSH1, POP1;
	input [WR1_DATA_WIDTH-1:0] DIN1;
	input Async_Flush1;
	output [RD1_DATA_WIDTH-1:0] DOUT1;
	output Almost_Full1, Almost_Empty1;
	output Full1, Empty1;
	output Full_Watermark1, Empty_Watermark1;
	output Overrun_Error1, Underrun_Error1;

	input Push_Clk2, Pop_Clk2;
	input PUSH2, POP2;
	input [WR2_DATA_WIDTH-1:0] DIN2;
	input Async_Flush2;
	output [RD2_DATA_WIDTH-1:0] DOUT2;
	output Almost_Full2, Almost_Empty2;
	output Full2, Empty2;
	output Full_Watermark2, Empty_Watermark2;
	output Overrun_Error2, Underrun_Error2;

	// Fixed mode settings
	localparam [ 0:0] SYNC_FIFO1_i  = 1'd0;
	localparam [ 0:0] FMODE1_i      = 1'd1;
	localparam [ 0:0] POWERDN1_i    = 1'd0;
	localparam [ 0:0] SLEEP1_i      = 1'd0;
	localparam [ 0:0] PROTECT1_i    = 1'd0;
	localparam [11:0] UPAE1_i       = UPAE_DBITS1;
	localparam [11:0] UPAF1_i       = UPAF_DBITS1;

	localparam [ 0:0] SYNC_FIFO2_i  = 1'd0;
	localparam [ 0:0] FMODE2_i      = 1'd1;
	localparam [ 0:0] POWERDN2_i    = 1'd0;
	localparam [ 0:0] SLEEP2_i      = 1'd0;
	localparam [ 0:0] PROTECT2_i    = 1'd0;
	localparam [10:0] UPAE2_i       = UPAE_DBITS2;
	localparam [10:0] UPAF2_i       = UPAF_DBITS2;

	// Width mode function
	function [2:0] mode;
	input integer width;
	case (width)
	1: mode = 3'b101;
	2: mode = 3'b110;
	4: mode = 3'b100;
	8,9: mode = 3'b001;
	16, 18: mode = 3'b010;
	32, 36: mode = 3'b011;
	default: mode = 3'b000;
	endcase
	endfunction

	function integer rwmode;
	input integer rwwidth;
	case (rwwidth)
	1: rwmode = 1;
	2: rwmode = 2;
	4: rwmode = 4;
	8,9: rwmode = 9;
	16, 18: rwmode = 18;
	default: rwmode = 18;
	endcase
	endfunction

	wire [17:0] in_reg1;
	wire [17:0] out_reg1;
	wire [17:0] fifo1_flags;

	wire [17:0] in_reg2;
	wire [17:0] out_reg2;
	wire [17:0] fifo2_flags;

	wire Push_Clk1, Pop_Clk1;
	wire Push_Clk2, Pop_Clk2;

	assign Overrun_Error1 = fifo1_flags[0];
	assign Full_Watermark1 = fifo1_flags[1];
	assign Almost_Full1 = fifo1_flags[2];
	assign Full1 = fifo1_flags[3];
	assign Underrun_Error1 = fifo1_flags[4];
	assign Empty_Watermark1 = fifo1_flags[5];
	assign Almost_Empty1 = fifo1_flags[6];
	assign Empty1 = fifo1_flags[7];

	assign Overrun_Error2 = fifo2_flags[0];
	assign Full_Watermark2 = fifo2_flags[1];
	assign Almost_Full2 = fifo2_flags[2];
	assign Full2 = fifo2_flags[3];
	assign Underrun_Error2 = fifo2_flags[4];
	assign Empty_Watermark2 = fifo2_flags[5];
	assign Almost_Empty2 = fifo2_flags[6];
	assign Empty2 = fifo2_flags[7];

	localparam [ 2:0] RMODE_A1_i    = mode(WR1_DATA_WIDTH);
	localparam [ 2:0] WMODE_A1_i    = mode(WR1_DATA_WIDTH);
	localparam [ 2:0] RMODE_A2_i    = mode(WR2_DATA_WIDTH);
	localparam [ 2:0] WMODE_A2_i    = mode(WR2_DATA_WIDTH);

	localparam [ 2:0] RMODE_B1_i    = mode(RD1_DATA_WIDTH);
	localparam [ 2:0] WMODE_B1_i    = mode(RD1_DATA_WIDTH);
	localparam [ 2:0] RMODE_B2_i    = mode(RD2_DATA_WIDTH);
	localparam [ 2:0] WMODE_B2_i    = mode(RD2_DATA_WIDTH);

	localparam PORT_A1_WRWIDTH = rwmode(WR1_DATA_WIDTH);
	localparam PORT_B1_WRWIDTH = rwmode(RD1_DATA_WIDTH);
	localparam PORT_A2_WRWIDTH = rwmode(WR2_DATA_WIDTH);
	localparam PORT_B2_WRWIDTH = rwmode(RD2_DATA_WIDTH);

	generate
		if (WR1_DATA_WIDTH == 18) begin
			assign in_reg1[17:0] = DIN1[17:0];
		end else if (WR1_DATA_WIDTH == 9) begin
			assign in_reg1[17:0] = {1'b0, DIN1[8], 8'h0, DIN1[7:0]};
		end else begin
			assign in_reg1[17:WR1_DATA_WIDTH]  = 0;
			assign in_reg1[WR1_DATA_WIDTH-1:0] = DIN1[WR1_DATA_WIDTH-1:0];
		end
	endgenerate

	generate
		if (RD1_DATA_WIDTH == 9) begin
			assign DOUT1[RD1_DATA_WIDTH-1:0] = {out_reg1[16], out_reg1[7:0]};
		end else begin
			assign DOUT1[RD1_DATA_WIDTH-1:0] = out_reg1[RD1_DATA_WIDTH-1:0];
		end
	endgenerate

	generate
		if (WR2_DATA_WIDTH == 18) begin
			assign in_reg2[17:0] = DIN2[17:0];
		end else if (WR2_DATA_WIDTH == 9) begin
			assign in_reg2[17:0] = {1'b0, DIN2[8], 8'h0, DIN2[7:0]};
		end else begin
			assign in_reg2[17:WR2_DATA_WIDTH]  = 0;
			assign in_reg2[WR2_DATA_WIDTH-1:0] = DIN2[WR2_DATA_WIDTH-1:0];
		end
	endgenerate

	generate
		if (RD2_DATA_WIDTH == 9) begin
			assign DOUT2[RD2_DATA_WIDTH-1:0] = {out_reg2[16], out_reg2[7:0]};
		end else begin
			assign DOUT2[RD2_DATA_WIDTH-1:0] = out_reg2[RD2_DATA_WIDTH-1:0];
		end
	endgenerate

	defparam _TECHMAP_REPLACE_.MODE_BITS = { 1'b1,
	UPAF2_i, UPAE2_i, PROTECT2_i, SLEEP2_i, POWERDN2_i, FMODE2_i, WMODE_B2_i, WMODE_A2_i, RMODE_B2_i, RMODE_A2_i, SYNC_FIFO2_i,
	UPAF1_i, UPAE1_i, PROTECT1_i, SLEEP1_i, POWERDN1_i, FMODE1_i, WMODE_B1_i, WMODE_A1_i, RMODE_B1_i, RMODE_A1_i, SYNC_FIFO1_i
	};

	(* is_fifo = 1 *)
	(* sync_fifo = 0 *)
	(* is_split = 0 *)
	(* is_inferred = 0 *)
	(* port_a_dwidth = PORT_A1_WRWIDTH *)
	(* port_b_dwidth = PORT_B1_WRWIDTH *)
 	TDP36K _TECHMAP_REPLACE_ (
		.RESET_ni(1'b1),
		.WDATA_A1_i(in_reg1[17:0]),
		.WDATA_A2_i(in_reg2[17:0]),
		.RDATA_A1_o(fifo1_flags),
		.RDATA_A2_o(fifo2_flags),
		.ADDR_A1_i(14'h0),
		.ADDR_A2_i(14'h0),
		.CLK_A1_i(Push_Clk1),
		.CLK_A2_i(Push_Clk2),
		.REN_A1_i(1'b1),
		.REN_A2_i(1'b1),
		.WEN_A1_i(PUSH1),
		.WEN_A2_i(PUSH2),
		.BE_A1_i(2'b11),
		.BE_A2_i(2'b11),

		.WDATA_B1_i(18'h0),
		.WDATA_B2_i(18'h0),
		.RDATA_B1_o(out_reg1[17:0]),
		.RDATA_B2_o(out_reg2[17:0]),
		.ADDR_B1_i(14'h0),
		.ADDR_B2_i(14'h0),
		.CLK_B1_i(Pop_Clk1),
		.CLK_B2_i(Pop_Clk2),
		.REN_B1_i(POP1),
		.REN_B2_i(POP2),
		.WEN_B1_i(1'b0),
		.WEN_B2_i(1'b0),
		.BE_B1_i(2'b11),
		.BE_B2_i(2'b11),

		.FLUSH1_i(Async_Flush1),
		.FLUSH2_i(Async_Flush2)
	);

endmodule`,"brams_sim.v":new URL("./brams_sim-bdd23f4c.v?hash=bdd23f4c",import.meta.url),"cells_sim.v":`// Copyright 2020-2022 F4PGA Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: Apache-2.0

\`timescale 1ps/1ps

\`default_nettype none
(* abc9_lut=1 *)
module LUT1(output wire O, input wire I0);
	parameter [1:0] INIT = 0;
	assign O = I0 ? INIT[1] : INIT[0];
	specify
		(I0 => O) = 74;
	endspecify
endmodule

(* abc9_lut=2 *)
module LUT2(output wire O, input wire I0, I1);
	parameter [3:0] INIT = 0;
	wire [ 1: 0] s1 = I1 ? INIT[ 3: 2] : INIT[ 1: 0];
	assign O = I0 ? s1[1] : s1[0];
	specify
		(I0 => O) = 116;
		(I1 => O) = 74;
	endspecify
endmodule

(* abc9_lut=3 *)
module LUT3(output wire O, input wire I0, I1, I2);
	parameter [7:0] INIT = 0;
	wire [ 3: 0] s2 = I2 ? INIT[ 7: 4] : INIT[ 3: 0];
	wire [ 1: 0] s1 = I1 ?   s2[ 3: 2] :   s2[ 1: 0];
	assign O = I0 ? s1[1] : s1[0];
	specify
		(I0 => O) = 162;
		(I1 => O) = 116;
		(I2 => O) = 174;
	endspecify
endmodule

(* abc9_lut=3 *)
module LUT4(output wire O, input wire I0, I1, I2, I3);
	parameter [15:0] INIT = 0;
	wire [ 7: 0] s3 = I3 ? INIT[15: 8] : INIT[ 7: 0];
	wire [ 3: 0] s2 = I2 ?   s3[ 7: 4] :   s3[ 3: 0];
	wire [ 1: 0] s1 = I1 ?   s2[ 3: 2] :   s2[ 1: 0];
	assign O = I0 ? s1[1] : s1[0];
	specify
		(I0 => O) = 201;
		(I1 => O) = 162;
		(I2 => O) = 116;
		(I3 => O) = 74;
	endspecify
endmodule

(* abc9_lut=3 *)
module LUT5(output wire O, input wire I0, I1, I2, I3, I4);
	parameter [31:0] INIT = 0;
	wire [15: 0] s4 = I4 ? INIT[31:16] : INIT[15: 0];
	wire [ 7: 0] s3 = I3 ?   s4[15: 8] :   s4[ 7: 0];
	wire [ 3: 0] s2 = I2 ?   s3[ 7: 4] :   s3[ 3: 0];
	wire [ 1: 0] s1 = I1 ?   s2[ 3: 2] :   s2[ 1: 0];
	assign O = I0 ? s1[1] : s1[0];
	specify
		(I0 => O) = 228;
		(I1 => O) = 189;
		(I2 => O) = 143;
		(I3 => O) = 100;
		(I4 => O) = 55;
	endspecify
endmodule

(* abc9_lut=5 *)
module LUT6(output wire O, input wire I0, I1, I2, I3, I4, I5);
	parameter [63:0] INIT = 0;
	wire [31: 0] s5 = I5 ? INIT[63:32] : INIT[31: 0];
	wire [15: 0] s4 = I4 ?   s5[31:16] :   s5[15: 0];
	wire [ 7: 0] s3 = I3 ?   s4[15: 8] :   s4[ 7: 0];
	wire [ 3: 0] s2 = I2 ?   s3[ 7: 4] :   s3[ 3: 0];
	wire [ 1: 0] s1 = I1 ?   s2[ 3: 2] :   s2[ 1: 0];
	assign O = I0 ? s1[1] : s1[0];
	specify
		(I0 => O) = 251;
		(I1 => O) = 212;
		(I2 => O) = 166;
		(I3 => O) = 123;
		(I4 => O) = 77;
		(I5 => O) = 43;
	endspecify
endmodule

(* abc9_flop, lib_whitebox *)
module sh_dff(
		output reg Q,
		input wire D,
		(* clkbuf_sink *)
		input wire C
);

		initial Q = 1'b0;
		always @(posedge C)
				Q <= D;

		specify
			(posedge C => (Q +: D)) = 0;
			$setuphold(posedge C, D, 0, 0);
		endspecify

endmodule

(* abc9_box, lib_whitebox *)
(* keep *)
module adder_carry(
		output wire sumout,
		(* abc9_carry *)
		output wire cout,
		input wire p,
		input wire g,
		(* abc9_carry *)
		input wire cin
);
		assign sumout = p ^ cin;
		assign cout = p ? cin : g;

		specify
				(p => sumout) = 35;
				(g => sumout) = 35;
				(cin => sumout) = 40;
				(p => cout) = 67;
				(g => cout) = 65;
				(cin => cout) = 69;
		endspecify

endmodule

(* abc9_flop, lib_whitebox *)
module dff(
		output reg Q,
		input wire D,
		(* clkbuf_sink *)
		input wire C
);
		initial Q = 1'b0;

		always @(posedge C)
			Q <= D;

		specify
			(posedge C=>(Q+:D)) = 285;
			$setuphold(posedge C, D, 56, 0);
		endspecify

endmodule

(* abc9_flop, lib_whitebox *)
module dffn(
		output reg Q,
		input wire D,
		(* clkbuf_sink *)
		input wire C
);
		initial Q = 1'b0;

		always @(negedge C)
			Q <= D;

		specify
			(negedge C=>(Q+:D)) = 285;
			$setuphold(negedge C, D, 56, 0);
		endspecify

endmodule

(* abc9_flop, lib_whitebox *)
module dffsre(
		output reg Q,
		input wire D,
		(* clkbuf_sink *)
		input wire C,
		input wire E,
		input wire R,
		input wire S
);
		initial Q = 1'b0;

		always @(posedge C or negedge S or negedge R)
			if (!R)
				Q <= 1'b0;
			else if (!S)
				Q <= 1'b1;
			else if (E)
				Q <= D;

		specify
			(posedge C => (Q +: D)) = 280;
			(R => Q) = 0;
			(S => Q) = 0;
			$setuphold(posedge C, D, 56, 0);
			$setuphold(posedge C, E, 32, 0);
			$setuphold(posedge C, R, 0, 0);
			$setuphold(posedge C, S, 0, 0);
			$recrem(posedge R, posedge C, 0, 0);
			$recrem(posedge S, posedge C, 0, 0);
		endspecify

endmodule

(* abc9_flop, lib_whitebox *)
module dffnsre(
		output reg Q,
		input wire D,
		(* clkbuf_sink *)
		input wire C,
		input wire E,
		input wire R,
		input wire S
);
		initial Q = 1'b0;

		always @(negedge C or negedge S or negedge R)
			if (!R)
				Q <= 1'b0;
			else if (!S)
				Q <= 1'b1;
			else if (E)
				Q <= D;

		specify
			(negedge C => (Q +: D)) = 280;
			(R => Q) = 0;
			(S => Q) = 0;
			$setuphold(negedge C, D, 56, 0);
			$setuphold(negedge C, E, 32, 0);
			$setuphold(negedge C, R, 0, 0);
			$setuphold(negedge C, S, 0, 0);
			$recrem(posedge R, negedge C, 0, 0);
			$recrem(posedge S, negedge C, 0, 0);
		endspecify

endmodule

(* abc9_flop, lib_whitebox *)
module sdffsre(
		output reg Q,
		input wire D,
		(* clkbuf_sink *)
		input wire C,
		input wire E,
		input wire R,
		input wire S
);
		initial Q = 1'b0;

		always @(posedge C)
			if (!R)
				Q <= 1'b0;
			else if (!S)
				Q <= 1'b1;
			else if (E)
				Q <= D;

		specify
				(posedge C => (Q +: D)) = 280;
				$setuphold(posedge C, D, 56, 0);
				$setuphold(posedge C, R, 32, 0);
				$setuphold(posedge C, S, 0, 0);
				$setuphold(posedge C, E, 0, 0);
		endspecify

endmodule

(* abc9_flop, lib_whitebox *)
module sdffnsre(
		output reg Q,
		input wire D,
		(* clkbuf_sink *)
		input wire C,
		input wire E,
		input wire R,
		input wire S
);
		initial Q = 1'b0;

		always @(negedge C)
			if (!R)
				Q <= 1'b0;
			else if (!S)
				Q <= 1'b1;
			else if (E)
				Q <= D;

		specify
				(negedge C => (Q +: D)) = 280;
				$setuphold(negedge C, D, 56, 0);
				$setuphold(negedge C, R, 32, 0);
				$setuphold(negedge C, S, 0, 0);
				$setuphold(negedge C, E, 0, 0);
		endspecify

endmodule

(* abc9_flop, lib_whitebox *)
module latchsre (
		output reg Q,
		input wire S,
		input wire R,
		input wire D,
		input wire G,
		input wire E
);
		initial Q = 1'b0;

		always @*
			begin
				if (!R)
					Q <= 1'b0;
				else if (!S)
					Q <= 1'b1;
				else if (E && G)
					Q <= D;
			end

		specify
			(posedge G => (Q +: D)) = 0;
			$setuphold(posedge G, D, 0, 0);
			$setuphold(posedge G, E, 0, 0);
			$setuphold(posedge G, R, 0, 0);
			$setuphold(posedge G, S, 0, 0);
		endspecify

endmodule

(* abc9_flop, lib_whitebox *)
module latchnsre (
		output reg Q,
		input wire S,
		input wire R,
		input wire D,
		input wire G,
		input wire E
);
		initial Q = 1'b0;

		always @*
			begin
				if (!R)
					Q <= 1'b0;
				else if (!S)
					Q <= 1'b1;
				else if (E && !G)
					Q <= D;
			end

		specify
			(negedge G => (Q +: D)) = 0;
			$setuphold(negedge G, D, 0, 0);
			$setuphold(negedge G, E, 0, 0);
			$setuphold(negedge G, R, 0, 0);
			$setuphold(negedge G, S, 0, 0);
		endspecify

endmodule

`,"dsp_final_map.v":`// Copyright 2020-2022 F4PGA Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: Apache-2.0

module dsp_t1_20x18x64_cfg_ports (
    input  [19:0] a_i,
    input  [17:0] b_i,
    input  [ 5:0] acc_fir_i,
    output [37:0] z_o,
    output [17:0] dly_b_o,

    input         clock_i,
    input         reset_i,

    input  [2:0]  feedback_i,
    input         load_acc_i,
    input         unsigned_a_i,
    input         unsigned_b_i,

    input  [2:0]  output_select_i,
    input         saturate_enable_i,
    input  [5:0]  shift_right_i,
    input         round_i,
    input         subtract_i,
    input         register_inputs_i
);

    parameter [19:0] COEFF_0 = 20'd0;
    parameter [19:0] COEFF_1 = 20'd0;
    parameter [19:0] COEFF_2 = 20'd0;
    parameter [19:0] COEFF_3 = 20'd0;

    QL_DSP2 # (
        .MODE_BITS          ({COEFF_3, COEFF_2, COEFF_1, COEFF_0})
    ) _TECHMAP_REPLACE_ (
        .a                  (a_i),
        .b                  (b_i),
        .acc_fir            (acc_fir_i),
        .z                  (z_o),
        .dly_b              (dly_b_o),

        .clk                (clock_i),
        .reset              (reset_i),

        .feedback           (feedback_i),
        .load_acc           (load_acc_i),
        .unsigned_a         (unsigned_a_i),
        .unsigned_b         (unsigned_b_i),

        .f_mode             (1'b0), // No fracturation
        .output_select      (output_select_i),
        .saturate_enable    (saturate_enable_i),
        .shift_right        (shift_right_i),
        .round              (round_i),
        .subtract           (subtract_i),
        .register_inputs    (register_inputs_i)
    );

endmodule

module dsp_t1_10x9x32_cfg_ports (
    input  [ 9:0] a_i,
    input  [ 8:0] b_i,
    input  [ 5:0] acc_fir_i,
    output [18:0] z_o,
    output [ 8:0] dly_b_o,

    (* clkbuf_sink *)
    input         clock_i,
    input         reset_i,

    input  [2:0]  feedback_i,
    input         load_acc_i,
    input         unsigned_a_i,
    input         unsigned_b_i,

    input  [2:0]  output_select_i,
    input         saturate_enable_i,
    input  [5:0]  shift_right_i,
    input         round_i,
    input         subtract_i,
    input         register_inputs_i
);

    parameter [9:0] COEFF_0 = 10'd0;
    parameter [9:0] COEFF_1 = 10'd0;
    parameter [9:0] COEFF_2 = 10'd0;
    parameter [9:0] COEFF_3 = 10'd0;

    wire [37:0] z;
    wire [17:0] dly_b;

    QL_DSP2 # (
        .MODE_BITS          ({10'd0, COEFF_3,
                              10'd0, COEFF_2,
                              10'd0, COEFF_1,
                              10'd0, COEFF_0})
    ) _TECHMAP_REPLACE_ (
        .a                  ({10'd0, a_i}),
        .b                  ({ 9'd0, b_i}),
        .acc_fir            (acc_fir_i),
        .z                  (z),
        .dly_b              (dly_b),

        .clk                (clock_i),
        .reset              (reset_i),

        .feedback           (feedback_i),
        .load_acc           (load_acc_i),
        .unsigned_a         (unsigned_a_i),
        .unsigned_b         (unsigned_b_i),

        .f_mode             (1'b1), // Enable fractuation, Use the lower half
        .output_select      (output_select_i),
        .saturate_enable    (saturate_enable_i),
        .shift_right        (shift_right_i),
        .round              (round_i),
        .subtract           (subtract_i),
        .register_inputs    (register_inputs_i)
    );

    assign z_o = z[18:0];
    assign dly_b_o = dly_b_o[8:0];

endmodule

module dsp_t1_20x18x64_cfg_params (
    input  [19:0] a_i,
    input  [17:0] b_i,
    input  [ 5:0] acc_fir_i,
    output [37:0] z_o,
    output [17:0] dly_b_o,

    input         clock_i,
    input         reset_i,

    input  [2:0]  feedback_i,
    input         load_acc_i,
    input         unsigned_a_i,
    input         unsigned_b_i,
    input         subtract_i
);

    parameter [19:0] COEFF_0 = 20'd0;
    parameter [19:0] COEFF_1 = 20'd0;
    parameter [19:0] COEFF_2 = 20'd0;
    parameter [19:0] COEFF_3 = 20'd0;

    parameter [2:0] OUTPUT_SELECT   = 3'd0;
    parameter [0:0] SATURATE_ENABLE = 1'd0;
    parameter [5:0] SHIFT_RIGHT     = 6'd0;
    parameter [0:0] ROUND           = 1'd0;
    parameter [0:0] REGISTER_INPUTS = 1'd0;

    QL_DSP3 # (
        .MODE_BITS ({
            REGISTER_INPUTS,
            ROUND,
            SHIFT_RIGHT,
            SATURATE_ENABLE,
            OUTPUT_SELECT,
            1'b0, // Not fractured
            COEFF_3,
            COEFF_2,
            COEFF_1,
            COEFF_0
        })
    ) _TECHMAP_REPLACE_ (
        .a                  (a_i),
        .b                  (b_i),
        .acc_fir            (acc_fir_i),
        .z                  (z_o),
        .dly_b              (dly_b_o),

        .clk                (clock_i),
        .reset              (reset_i),

        .feedback           (feedback_i),
        .load_acc           (load_acc_i),
        .unsigned_a         (unsigned_a_i),
        .unsigned_b         (unsigned_b_i),
        .subtract           (subtract_i)
    );

endmodule

module dsp_t1_10x9x32_cfg_params (
    input  [ 9:0] a_i,
    input  [ 8:0] b_i,
    input  [ 5:0] acc_fir_i,
    output [18:0] z_o,
    output [ 8:0] dly_b_o,

    (* clkbuf_sink *)
    input         clock_i,
    input         reset_i,

    input  [2:0]  feedback_i,
    input         load_acc_i,
    input         unsigned_a_i,
    input         unsigned_b_i,
    input         subtract_i
);

    parameter [9:0] COEFF_0 = 10'd0;
    parameter [9:0] COEFF_1 = 10'd0;
    parameter [9:0] COEFF_2 = 10'd0;
    parameter [9:0] COEFF_3 = 10'd0;

    parameter [2:0] OUTPUT_SELECT   = 3'd0;
    parameter [0:0] SATURATE_ENABLE = 1'd0;
    parameter [5:0] SHIFT_RIGHT     = 6'd0;
    parameter [0:0] ROUND           = 1'd0;
    parameter [0:0] REGISTER_INPUTS = 1'd0;

    wire [37:0] z;
    wire [17:0] dly_b;

    QL_DSP3 # (
        .MODE_BITS  ({
            REGISTER_INPUTS,
            ROUND,
            SHIFT_RIGHT,
            SATURATE_ENABLE,
            OUTPUT_SELECT,
            1'b1, // Fractured
            10'd0, COEFF_3,
            10'd0, COEFF_2,
            10'd0, COEFF_1,
            10'd0, COEFF_0
        })
    ) _TECHMAP_REPLACE_ (
        .a                  ({10'd0, a_i}),
        .b                  ({ 9'd0, b_i}),
        .acc_fir            (acc_fir_i),
        .z                  (z),
        .dly_b              (dly_b),

        .clk                (clock_i),
        .reset              (reset_i),

        .feedback           (feedback_i),
        .load_acc           (load_acc_i),
        .unsigned_a         (unsigned_a_i),
        .unsigned_b         (unsigned_b_i),
        .subtract           (subtract_i)
    );

    assign z_o = z[18:0];
    assign dly_b_o = dly_b_o[8:0];

endmodule

`,"dsp_map.v":`// Copyright 2020-2022 F4PGA Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: Apache-2.0

module \\$__QL_MUL20X18 (input [19:0] A, input [17:0] B, output [37:0] Y);
    parameter A_SIGNED = 0;
    parameter B_SIGNED = 0;
    parameter A_WIDTH = 0;
    parameter B_WIDTH = 0;
    parameter Y_WIDTH = 0;

    wire [19:0] a;
    wire [17:0] b;
    wire [37:0] z;

    assign a = (A_WIDTH == 20) ? A :
               (A_SIGNED) ? {{(20 - A_WIDTH){A[A_WIDTH-1]}}, A} :
                            {{(20 - A_WIDTH){1'b0}},         A};

    assign b = (B_WIDTH == 18) ? B :
               (B_SIGNED) ? {{(18 - B_WIDTH){B[B_WIDTH-1]}}, B} :
                            {{(18 - B_WIDTH){1'b0}},         B};

    (* is_inferred=1 *)
    dsp_t1_20x18x64_cfg_ports _TECHMAP_REPLACE_ (
        .a_i                (a),
        .b_i                (b),
        .acc_fir_i          (6'd0),
        .z_o                (z),

        .feedback_i         (3'd0),
        .load_acc_i         (1'b0),
        .unsigned_a_i       (!A_SIGNED),
        .unsigned_b_i       (!B_SIGNED),

        .output_select_i    (3'd0),
        .saturate_enable_i  (1'b0),
        .shift_right_i      (6'd0),
        .round_i            (1'b0),
        .subtract_i         (1'b0),
        .register_inputs_i  (1'b0)
    );

    assign Y = z;

endmodule

module \\$__QL_MUL10X9 (input [9:0] A, input [8:0] B, output [18:0] Y);
    parameter A_SIGNED = 0;
    parameter B_SIGNED = 0;
    parameter A_WIDTH = 0;
    parameter B_WIDTH = 0;
    parameter Y_WIDTH = 0;

    wire [ 9:0] a;
    wire [ 8:0] b;
    wire [18:0] z;

    assign a = (A_WIDTH == 10) ? A :
               (A_SIGNED) ? {{(10 - A_WIDTH){A[A_WIDTH-1]}}, A} :
                            {{(10 - A_WIDTH){1'b0}},         A};

    assign b = (B_WIDTH ==  9) ? B :
               (B_SIGNED) ? {{( 9 - B_WIDTH){B[B_WIDTH-1]}}, B} :
                            {{( 9 - B_WIDTH){1'b0}},         B};

    (* is_inferred=1 *)
    dsp_t1_10x9x32_cfg_ports _TECHMAP_REPLACE_ (
        .a_i                (a),
        .b_i                (b),
        .acc_fir_i          (6'd0),
        .z_o                (z),

        .feedback_i         (3'd0),
        .load_acc_i         (1'b0),
        .unsigned_a_i       (!A_SIGNED),
        .unsigned_b_i       (!B_SIGNED),

        .output_select_i    (3'd0),
        .saturate_enable_i  (1'b0),
        .shift_right_i      (6'd0),
        .round_i            (1'b0),
        .subtract_i         (1'b0),
        .register_inputs_i  (1'b0)
    );


    assign Y = z;

endmodule
`,"dsp_sim.v":`// Copyright 2020-2022 F4PGA Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: Apache-2.0

\`timescale 1ps/1ps

\`default_nettype none

(* blackbox *)
module QL_DSP1 (
	input wire [19:0] a,
	input wire [17:0] b,
	(* clkbuf_sink *)
	input wire clk0,
	(* clkbuf_sink *)
	input wire clk1,
	input wire [ 1:0] feedback0,
	input wire [ 1:0] feedback1,
	input wire        load_acc0,
	input wire        load_acc1,
	input wire        reset0,
	input wire        reset1,
	output reg [37:0] z
);
	parameter MODE_BITS = 27'b00000000000000000000000000;
endmodule  /* QL_DSP1 */



// ---------------------------------------- //
// ----- DSP cells simulation modules ----- //
// --------- Control bits in ports -------- //
// ---------------------------------------- //

module QL_DSP2 ( // TODO: Name subject to change
	input  wire [19:0] a,
	input  wire [17:0] b,
	input  wire [ 5:0] acc_fir,
	output wire [37:0] z,
	output wire [17:0] dly_b,

	(* clkbuf_sink *)
	input  wire       clk,
	input  wire       reset,

	input  wire [2:0] feedback,
	input  wire       load_acc,
	input  wire       unsigned_a,
	input  wire       unsigned_b,

	input  wire       f_mode,
	input  wire [2:0] output_select,
	input  wire       saturate_enable,
	input  wire [5:0] shift_right,
	input  wire       round,
	input  wire       subtract,
	input  wire       register_inputs
);

	parameter [79:0] MODE_BITS = 80'd0;

	localparam [19:0] COEFF_0 = MODE_BITS[19:0];
	localparam [19:0] COEFF_1 = MODE_BITS[39:20];
	localparam [19:0] COEFF_2 = MODE_BITS[59:40];
	localparam [19:0] COEFF_3 = MODE_BITS[79:60];

	localparam NBITS_ACC = 64;
	localparam NBITS_A = 20;
	localparam NBITS_B = 18;
	localparam NBITS_Z = 38;

	wire [NBITS_Z-1:0] dsp_full_z;
	wire [(NBITS_Z/2)-1:0] dsp_frac0_z;
	wire [(NBITS_Z/2)-1:0] dsp_frac1_z;

	wire [NBITS_B-1:0] dsp_full_dly_b;
	wire [(NBITS_B/2)-1:0] dsp_frac0_dly_b;
	wire [(NBITS_B/2)-1:0] dsp_frac1_dly_b;

	assign z = f_mode ? {dsp_frac1_z, dsp_frac0_z} : dsp_full_z;
	assign dly_b = f_mode ? {dsp_frac1_dly_b, dsp_frac0_dly_b} : dsp_full_dly_b;

	// Output used when fmode == 1
		dsp_t1_sim_cfg_ports #(
		.NBITS_A(NBITS_A/2),
			.NBITS_B(NBITS_B/2),
			.NBITS_ACC(NBITS_ACC/2),
			.NBITS_Z(NBITS_Z/2)
		) dsp_frac0 (
			.a_i(a[(NBITS_A/2)-1:0]),
			.b_i(b[(NBITS_B/2)-1:0]),
			.z_o(dsp_frac0_z),
			.dly_b_o(dsp_frac0_dly_b),

			.acc_fir_i(acc_fir),
			.feedback_i(feedback),
			.load_acc_i(load_acc),

			.unsigned_a_i(unsigned_a),
			.unsigned_b_i(unsigned_b),

			.clock_i(clk),
			.s_reset(reset),

			.saturate_enable_i(saturate_enable),
			.output_select_i(output_select),
			.round_i(round),
			.shift_right_i(shift_right),
			.subtract_i(subtract),
			.register_inputs_i(register_inputs),
			.coef_0_i(COEFF_0[(NBITS_A/2)-1:0]),
			.coef_1_i(COEFF_1[(NBITS_A/2)-1:0]),
			.coef_2_i(COEFF_2[(NBITS_A/2)-1:0]),
			.coef_3_i(COEFF_3[(NBITS_A/2)-1:0])
		);

	// Output used when fmode == 1
		dsp_t1_sim_cfg_ports #(
		.NBITS_A(NBITS_A/2),
			.NBITS_B(NBITS_B/2),
			.NBITS_ACC(NBITS_ACC/2),
			.NBITS_Z(NBITS_Z/2)
		) dsp_frac1 (
			.a_i(a[NBITS_A-1:NBITS_A/2]),
			.b_i(b[NBITS_B-1:NBITS_B/2]),
			.z_o(dsp_frac1_z),
			.dly_b_o(dsp_frac1_dly_b),

			.acc_fir_i(acc_fir),
			.feedback_i(feedback),
			.load_acc_i(load_acc),

			.unsigned_a_i(unsigned_a),
			.unsigned_b_i(unsigned_b),

			.clock_i(clk),
			.s_reset(reset),

			.saturate_enable_i(saturate_enable),
			.output_select_i(output_select),
			.round_i(round),
			.shift_right_i(shift_right),
			.subtract_i(subtract),
			.register_inputs_i(register_inputs),
			.coef_0_i(COEFF_0[NBITS_A-1:NBITS_A/2]),
			.coef_1_i(COEFF_1[NBITS_A-1:NBITS_A/2]),
			.coef_2_i(COEFF_2[NBITS_A-1:NBITS_A/2]),
			.coef_3_i(COEFF_3[NBITS_A-1:NBITS_A/2])
		);

	// Output used when fmode == 0
		dsp_t1_sim_cfg_ports #(
			.NBITS_A(NBITS_A),
			.NBITS_B(NBITS_B),
			.NBITS_ACC(NBITS_ACC),
			.NBITS_Z(NBITS_Z)
		) dsp_full (
			.a_i(a),
			.b_i(b),
			.z_o(dsp_full_z),
			.dly_b_o(dsp_full_dly_b),

			.acc_fir_i(acc_fir),
			.feedback_i(feedback),
			.load_acc_i(load_acc),

			.unsigned_a_i(unsigned_a),
			.unsigned_b_i(unsigned_b),

			.clock_i(clk),
			.s_reset(reset),

			.saturate_enable_i(saturate_enable),
			.output_select_i(output_select),
			.round_i(round),
			.shift_right_i(shift_right),
			.subtract_i(subtract),
			.register_inputs_i(register_inputs),
			.coef_0_i(COEFF_0),
			.coef_1_i(COEFF_1),
			.coef_2_i(COEFF_2),
			.coef_3_i(COEFF_3)
		);
endmodule

module QL_DSP2_MULT ( // TODO: Name subject to change
	input  wire [19:0] a,
	input  wire [17:0] b,
	output wire [37:0] z,

	input  wire       reset,

	input  wire [2:0] feedback,
	input  wire       unsigned_a,
	input  wire       unsigned_b,

	input  wire       f_mode,
	input  wire [2:0] output_select,
	input  wire       register_inputs
);

	parameter [79:0] MODE_BITS = 80'd0;

	localparam [19:0] COEFF_0 = MODE_BITS[19:0];
	localparam [19:0] COEFF_1 = MODE_BITS[39:20];
	localparam [19:0] COEFF_2 = MODE_BITS[59:40];
	localparam [19:0] COEFF_3 = MODE_BITS[79:60];

	QL_DSP2 #(
		.MODE_BITS({COEFF_3, COEFF_2, COEFF_1, COEFF_0})
	) dsp (
		.a(a),
		.b(b),
		.acc_fir(6'b0),
		.z(z),
		.dly_b(),

		.clk(1'b0),
		.reset(reset),

		.f_mode(f_mode),

		.feedback(feedback),
		.load_acc(1'b0),

		.unsigned_a(unsigned_a),
		.unsigned_b(unsigned_b),

		.output_select(output_select),      // unregistered output: a * b (0)
		.saturate_enable(1'b0),
		.shift_right(6'b0),
		.round(1'b0),
		.subtract(1'b0),
		.register_inputs(register_inputs)   // unregistered inputs
	);

\`ifdef SDF_SIM
	specify
		(a[0] => z[0]) = 0;
		(a[1] => z[0]) = 0;
		(a[2] => z[0]) = 0;
		(a[3] => z[0]) = 0;
		(a[4] => z[0]) = 0;
		(a[5] => z[0]) = 0;
		(a[6] => z[0]) = 0;
		(a[7] => z[0]) = 0;
		(a[8] => z[0]) = 0;
		(a[9] => z[0]) = 0;
		(a[10] => z[0]) = 0;
		(a[11] => z[0]) = 0;
		(a[12] => z[0]) = 0;
		(a[13] => z[0]) = 0;
		(a[14] => z[0]) = 0;
		(a[15] => z[0]) = 0;
		(a[16] => z[0]) = 0;
		(a[17] => z[0]) = 0;
		(a[18] => z[0]) = 0;
		(a[19] => z[0]) = 0;
		(b[0] => z[0]) = 0;
		(b[1] => z[0]) = 0;
		(b[2] => z[0]) = 0;
		(b[3] => z[0]) = 0;
		(b[4] => z[0]) = 0;
		(b[5] => z[0]) = 0;
		(b[6] => z[0]) = 0;
		(b[7] => z[0]) = 0;
		(b[8] => z[0]) = 0;
		(b[9] => z[0]) = 0;
		(b[10] => z[0]) = 0;
		(b[11] => z[0]) = 0;
		(b[12] => z[0]) = 0;
		(b[13] => z[0]) = 0;
		(b[14] => z[0]) = 0;
		(b[15] => z[0]) = 0;
		(b[16] => z[0]) = 0;
		(b[17] => z[0]) = 0;
		(a[0] => z[1]) = 0;
		(a[1] => z[1]) = 0;
		(a[2] => z[1]) = 0;
		(a[3] => z[1]) = 0;
		(a[4] => z[1]) = 0;
		(a[5] => z[1]) = 0;
		(a[6] => z[1]) = 0;
		(a[7] => z[1]) = 0;
		(a[8] => z[1]) = 0;
		(a[9] => z[1]) = 0;
		(a[10] => z[1]) = 0;
		(a[11] => z[1]) = 0;
		(a[12] => z[1]) = 0;
		(a[13] => z[1]) = 0;
		(a[14] => z[1]) = 0;
		(a[15] => z[1]) = 0;
		(a[16] => z[1]) = 0;
		(a[17] => z[1]) = 0;
		(a[18] => z[1]) = 0;
		(a[19] => z[1]) = 0;
		(b[0] => z[1]) = 0;
		(b[1] => z[1]) = 0;
		(b[2] => z[1]) = 0;
		(b[3] => z[1]) = 0;
		(b[4] => z[1]) = 0;
		(b[5] => z[1]) = 0;
		(b[6] => z[1]) = 0;
		(b[7] => z[1]) = 0;
		(b[8] => z[1]) = 0;
		(b[9] => z[1]) = 0;
		(b[10] => z[1]) = 0;
		(b[11] => z[1]) = 0;
		(b[12] => z[1]) = 0;
		(b[13] => z[1]) = 0;
		(b[14] => z[1]) = 0;
		(b[15] => z[1]) = 0;
		(b[16] => z[1]) = 0;
		(b[17] => z[1]) = 0;
		(a[0] => z[2]) = 0;
		(a[1] => z[2]) = 0;
		(a[2] => z[2]) = 0;
		(a[3] => z[2]) = 0;
		(a[4] => z[2]) = 0;
		(a[5] => z[2]) = 0;
		(a[6] => z[2]) = 0;
		(a[7] => z[2]) = 0;
		(a[8] => z[2]) = 0;
		(a[9] => z[2]) = 0;
		(a[10] => z[2]) = 0;
		(a[11] => z[2]) = 0;
		(a[12] => z[2]) = 0;
		(a[13] => z[2]) = 0;
		(a[14] => z[2]) = 0;
		(a[15] => z[2]) = 0;
		(a[16] => z[2]) = 0;
		(a[17] => z[2]) = 0;
		(a[18] => z[2]) = 0;
		(a[19] => z[2]) = 0;
		(b[0] => z[2]) = 0;
		(b[1] => z[2]) = 0;
		(b[2] => z[2]) = 0;
		(b[3] => z[2]) = 0;
		(b[4] => z[2]) = 0;
		(b[5] => z[2]) = 0;
		(b[6] => z[2]) = 0;
		(b[7] => z[2]) = 0;
		(b[8] => z[2]) = 0;
		(b[9] => z[2]) = 0;
		(b[10] => z[2]) = 0;
		(b[11] => z[2]) = 0;
		(b[12] => z[2]) = 0;
		(b[13] => z[2]) = 0;
		(b[14] => z[2]) = 0;
		(b[15] => z[2]) = 0;
		(b[16] => z[2]) = 0;
		(b[17] => z[2]) = 0;
		(a[0] => z[3]) = 0;
		(a[1] => z[3]) = 0;
		(a[2] => z[3]) = 0;
		(a[3] => z[3]) = 0;
		(a[4] => z[3]) = 0;
		(a[5] => z[3]) = 0;
		(a[6] => z[3]) = 0;
		(a[7] => z[3]) = 0;
		(a[8] => z[3]) = 0;
		(a[9] => z[3]) = 0;
		(a[10] => z[3]) = 0;
		(a[11] => z[3]) = 0;
		(a[12] => z[3]) = 0;
		(a[13] => z[3]) = 0;
		(a[14] => z[3]) = 0;
		(a[15] => z[3]) = 0;
		(a[16] => z[3]) = 0;
		(a[17] => z[3]) = 0;
		(a[18] => z[3]) = 0;
		(a[19] => z[3]) = 0;
		(b[0] => z[3]) = 0;
		(b[1] => z[3]) = 0;
		(b[2] => z[3]) = 0;
		(b[3] => z[3]) = 0;
		(b[4] => z[3]) = 0;
		(b[5] => z[3]) = 0;
		(b[6] => z[3]) = 0;
		(b[7] => z[3]) = 0;
		(b[8] => z[3]) = 0;
		(b[9] => z[3]) = 0;
		(b[10] => z[3]) = 0;
		(b[11] => z[3]) = 0;
		(b[12] => z[3]) = 0;
		(b[13] => z[3]) = 0;
		(b[14] => z[3]) = 0;
		(b[15] => z[3]) = 0;
		(b[16] => z[3]) = 0;
		(b[17] => z[3]) = 0;
		(a[0] => z[4]) = 0;
		(a[1] => z[4]) = 0;
		(a[2] => z[4]) = 0;
		(a[3] => z[4]) = 0;
		(a[4] => z[4]) = 0;
		(a[5] => z[4]) = 0;
		(a[6] => z[4]) = 0;
		(a[7] => z[4]) = 0;
		(a[8] => z[4]) = 0;
		(a[9] => z[4]) = 0;
		(a[10] => z[4]) = 0;
		(a[11] => z[4]) = 0;
		(a[12] => z[4]) = 0;
		(a[13] => z[4]) = 0;
		(a[14] => z[4]) = 0;
		(a[15] => z[4]) = 0;
		(a[16] => z[4]) = 0;
		(a[17] => z[4]) = 0;
		(a[18] => z[4]) = 0;
		(a[19] => z[4]) = 0;
		(b[0] => z[4]) = 0;
		(b[1] => z[4]) = 0;
		(b[2] => z[4]) = 0;
		(b[3] => z[4]) = 0;
		(b[4] => z[4]) = 0;
		(b[5] => z[4]) = 0;
		(b[6] => z[4]) = 0;
		(b[7] => z[4]) = 0;
		(b[8] => z[4]) = 0;
		(b[9] => z[4]) = 0;
		(b[10] => z[4]) = 0;
		(b[11] => z[4]) = 0;
		(b[12] => z[4]) = 0;
		(b[13] => z[4]) = 0;
		(b[14] => z[4]) = 0;
		(b[15] => z[4]) = 0;
		(b[16] => z[4]) = 0;
		(b[17] => z[4]) = 0;
		(a[0] => z[5]) = 0;
		(a[1] => z[5]) = 0;
		(a[2] => z[5]) = 0;
		(a[3] => z[5]) = 0;
		(a[4] => z[5]) = 0;
		(a[5] => z[5]) = 0;
		(a[6] => z[5]) = 0;
		(a[7] => z[5]) = 0;
		(a[8] => z[5]) = 0;
		(a[9] => z[5]) = 0;
		(a[10] => z[5]) = 0;
		(a[11] => z[5]) = 0;
		(a[12] => z[5]) = 0;
		(a[13] => z[5]) = 0;
		(a[14] => z[5]) = 0;
		(a[15] => z[5]) = 0;
		(a[16] => z[5]) = 0;
		(a[17] => z[5]) = 0;
		(a[18] => z[5]) = 0;
		(a[19] => z[5]) = 0;
		(b[0] => z[5]) = 0;
		(b[1] => z[5]) = 0;
		(b[2] => z[5]) = 0;
		(b[3] => z[5]) = 0;
		(b[4] => z[5]) = 0;
		(b[5] => z[5]) = 0;
		(b[6] => z[5]) = 0;
		(b[7] => z[5]) = 0;
		(b[8] => z[5]) = 0;
		(b[9] => z[5]) = 0;
		(b[10] => z[5]) = 0;
		(b[11] => z[5]) = 0;
		(b[12] => z[5]) = 0;
		(b[13] => z[5]) = 0;
		(b[14] => z[5]) = 0;
		(b[15] => z[5]) = 0;
		(b[16] => z[5]) = 0;
		(b[17] => z[5]) = 0;
		(a[0] => z[6]) = 0;
		(a[1] => z[6]) = 0;
		(a[2] => z[6]) = 0;
		(a[3] => z[6]) = 0;
		(a[4] => z[6]) = 0;
		(a[5] => z[6]) = 0;
		(a[6] => z[6]) = 0;
		(a[7] => z[6]) = 0;
		(a[8] => z[6]) = 0;
		(a[9] => z[6]) = 0;
		(a[10] => z[6]) = 0;
		(a[11] => z[6]) = 0;
		(a[12] => z[6]) = 0;
		(a[13] => z[6]) = 0;
		(a[14] => z[6]) = 0;
		(a[15] => z[6]) = 0;
		(a[16] => z[6]) = 0;
		(a[17] => z[6]) = 0;
		(a[18] => z[6]) = 0;
		(a[19] => z[6]) = 0;
		(b[0] => z[6]) = 0;
		(b[1] => z[6]) = 0;
		(b[2] => z[6]) = 0;
		(b[3] => z[6]) = 0;
		(b[4] => z[6]) = 0;
		(b[5] => z[6]) = 0;
		(b[6] => z[6]) = 0;
		(b[7] => z[6]) = 0;
		(b[8] => z[6]) = 0;
		(b[9] => z[6]) = 0;
		(b[10] => z[6]) = 0;
		(b[11] => z[6]) = 0;
		(b[12] => z[6]) = 0;
		(b[13] => z[6]) = 0;
		(b[14] => z[6]) = 0;
		(b[15] => z[6]) = 0;
		(b[16] => z[6]) = 0;
		(b[17] => z[6]) = 0;
		(a[0] => z[7]) = 0;
		(a[1] => z[7]) = 0;
		(a[2] => z[7]) = 0;
		(a[3] => z[7]) = 0;
		(a[4] => z[7]) = 0;
		(a[5] => z[7]) = 0;
		(a[6] => z[7]) = 0;
		(a[7] => z[7]) = 0;
		(a[8] => z[7]) = 0;
		(a[9] => z[7]) = 0;
		(a[10] => z[7]) = 0;
		(a[11] => z[7]) = 0;
		(a[12] => z[7]) = 0;
		(a[13] => z[7]) = 0;
		(a[14] => z[7]) = 0;
		(a[15] => z[7]) = 0;
		(a[16] => z[7]) = 0;
		(a[17] => z[7]) = 0;
		(a[18] => z[7]) = 0;
		(a[19] => z[7]) = 0;
		(b[0] => z[7]) = 0;
		(b[1] => z[7]) = 0;
		(b[2] => z[7]) = 0;
		(b[3] => z[7]) = 0;
		(b[4] => z[7]) = 0;
		(b[5] => z[7]) = 0;
		(b[6] => z[7]) = 0;
		(b[7] => z[7]) = 0;
		(b[8] => z[7]) = 0;
		(b[9] => z[7]) = 0;
		(b[10] => z[7]) = 0;
		(b[11] => z[7]) = 0;
		(b[12] => z[7]) = 0;
		(b[13] => z[7]) = 0;
		(b[14] => z[7]) = 0;
		(b[15] => z[7]) = 0;
		(b[16] => z[7]) = 0;
		(b[17] => z[7]) = 0;
		(a[0] => z[8]) = 0;
		(a[1] => z[8]) = 0;
		(a[2] => z[8]) = 0;
		(a[3] => z[8]) = 0;
		(a[4] => z[8]) = 0;
		(a[5] => z[8]) = 0;
		(a[6] => z[8]) = 0;
		(a[7] => z[8]) = 0;
		(a[8] => z[8]) = 0;
		(a[9] => z[8]) = 0;
		(a[10] => z[8]) = 0;
		(a[11] => z[8]) = 0;
		(a[12] => z[8]) = 0;
		(a[13] => z[8]) = 0;
		(a[14] => z[8]) = 0;
		(a[15] => z[8]) = 0;
		(a[16] => z[8]) = 0;
		(a[17] => z[8]) = 0;
		(a[18] => z[8]) = 0;
		(a[19] => z[8]) = 0;
		(b[0] => z[8]) = 0;
		(b[1] => z[8]) = 0;
		(b[2] => z[8]) = 0;
		(b[3] => z[8]) = 0;
		(b[4] => z[8]) = 0;
		(b[5] => z[8]) = 0;
		(b[6] => z[8]) = 0;
		(b[7] => z[8]) = 0;
		(b[8] => z[8]) = 0;
		(b[9] => z[8]) = 0;
		(b[10] => z[8]) = 0;
		(b[11] => z[8]) = 0;
		(b[12] => z[8]) = 0;
		(b[13] => z[8]) = 0;
		(b[14] => z[8]) = 0;
		(b[15] => z[8]) = 0;
		(b[16] => z[8]) = 0;
		(b[17] => z[8]) = 0;
		(a[0] => z[9]) = 0;
		(a[1] => z[9]) = 0;
		(a[2] => z[9]) = 0;
		(a[3] => z[9]) = 0;
		(a[4] => z[9]) = 0;
		(a[5] => z[9]) = 0;
		(a[6] => z[9]) = 0;
		(a[7] => z[9]) = 0;
		(a[8] => z[9]) = 0;
		(a[9] => z[9]) = 0;
		(a[10] => z[9]) = 0;
		(a[11] => z[9]) = 0;
		(a[12] => z[9]) = 0;
		(a[13] => z[9]) = 0;
		(a[14] => z[9]) = 0;
		(a[15] => z[9]) = 0;
		(a[16] => z[9]) = 0;
		(a[17] => z[9]) = 0;
		(a[18] => z[9]) = 0;
		(a[19] => z[9]) = 0;
		(b[0] => z[9]) = 0;
		(b[1] => z[9]) = 0;
		(b[2] => z[9]) = 0;
		(b[3] => z[9]) = 0;
		(b[4] => z[9]) = 0;
		(b[5] => z[9]) = 0;
		(b[6] => z[9]) = 0;
		(b[7] => z[9]) = 0;
		(b[8] => z[9]) = 0;
		(b[9] => z[9]) = 0;
		(b[10] => z[9]) = 0;
		(b[11] => z[9]) = 0;
		(b[12] => z[9]) = 0;
		(b[13] => z[9]) = 0;
		(b[14] => z[9]) = 0;
		(b[15] => z[9]) = 0;
		(b[16] => z[9]) = 0;
		(b[17] => z[9]) = 0;
		(a[0] => z[10]) = 0;
		(a[1] => z[10]) = 0;
		(a[2] => z[10]) = 0;
		(a[3] => z[10]) = 0;
		(a[4] => z[10]) = 0;
		(a[5] => z[10]) = 0;
		(a[6] => z[10]) = 0;
		(a[7] => z[10]) = 0;
		(a[8] => z[10]) = 0;
		(a[9] => z[10]) = 0;
		(a[10] => z[10]) = 0;
		(a[11] => z[10]) = 0;
		(a[12] => z[10]) = 0;
		(a[13] => z[10]) = 0;
		(a[14] => z[10]) = 0;
		(a[15] => z[10]) = 0;
		(a[16] => z[10]) = 0;
		(a[17] => z[10]) = 0;
		(a[18] => z[10]) = 0;
		(a[19] => z[10]) = 0;
		(b[0] => z[10]) = 0;
		(b[1] => z[10]) = 0;
		(b[2] => z[10]) = 0;
		(b[3] => z[10]) = 0;
		(b[4] => z[10]) = 0;
		(b[5] => z[10]) = 0;
		(b[6] => z[10]) = 0;
		(b[7] => z[10]) = 0;
		(b[8] => z[10]) = 0;
		(b[9] => z[10]) = 0;
		(b[10] => z[10]) = 0;
		(b[11] => z[10]) = 0;
		(b[12] => z[10]) = 0;
		(b[13] => z[10]) = 0;
		(b[14] => z[10]) = 0;
		(b[15] => z[10]) = 0;
		(b[16] => z[10]) = 0;
		(b[17] => z[10]) = 0;
		(a[0] => z[11]) = 0;
		(a[1] => z[11]) = 0;
		(a[2] => z[11]) = 0;
		(a[3] => z[11]) = 0;
		(a[4] => z[11]) = 0;
		(a[5] => z[11]) = 0;
		(a[6] => z[11]) = 0;
		(a[7] => z[11]) = 0;
		(a[8] => z[11]) = 0;
		(a[9] => z[11]) = 0;
		(a[10] => z[11]) = 0;
		(a[11] => z[11]) = 0;
		(a[12] => z[11]) = 0;
		(a[13] => z[11]) = 0;
		(a[14] => z[11]) = 0;
		(a[15] => z[11]) = 0;
		(a[16] => z[11]) = 0;
		(a[17] => z[11]) = 0;
		(a[18] => z[11]) = 0;
		(a[19] => z[11]) = 0;
		(b[0] => z[11]) = 0;
		(b[1] => z[11]) = 0;
		(b[2] => z[11]) = 0;
		(b[3] => z[11]) = 0;
		(b[4] => z[11]) = 0;
		(b[5] => z[11]) = 0;
		(b[6] => z[11]) = 0;
		(b[7] => z[11]) = 0;
		(b[8] => z[11]) = 0;
		(b[9] => z[11]) = 0;
		(b[10] => z[11]) = 0;
		(b[11] => z[11]) = 0;
		(b[12] => z[11]) = 0;
		(b[13] => z[11]) = 0;
		(b[14] => z[11]) = 0;
		(b[15] => z[11]) = 0;
		(b[16] => z[11]) = 0;
		(b[17] => z[11]) = 0;
		(a[0] => z[12]) = 0;
		(a[1] => z[12]) = 0;
		(a[2] => z[12]) = 0;
		(a[3] => z[12]) = 0;
		(a[4] => z[12]) = 0;
		(a[5] => z[12]) = 0;
		(a[6] => z[12]) = 0;
		(a[7] => z[12]) = 0;
		(a[8] => z[12]) = 0;
		(a[9] => z[12]) = 0;
		(a[10] => z[12]) = 0;
		(a[11] => z[12]) = 0;
		(a[12] => z[12]) = 0;
		(a[13] => z[12]) = 0;
		(a[14] => z[12]) = 0;
		(a[15] => z[12]) = 0;
		(a[16] => z[12]) = 0;
		(a[17] => z[12]) = 0;
		(a[18] => z[12]) = 0;
		(a[19] => z[12]) = 0;
		(b[0] => z[12]) = 0;
		(b[1] => z[12]) = 0;
		(b[2] => z[12]) = 0;
		(b[3] => z[12]) = 0;
		(b[4] => z[12]) = 0;
		(b[5] => z[12]) = 0;
		(b[6] => z[12]) = 0;
		(b[7] => z[12]) = 0;
		(b[8] => z[12]) = 0;
		(b[9] => z[12]) = 0;
		(b[10] => z[12]) = 0;
		(b[11] => z[12]) = 0;
		(b[12] => z[12]) = 0;
		(b[13] => z[12]) = 0;
		(b[14] => z[12]) = 0;
		(b[15] => z[12]) = 0;
		(b[16] => z[12]) = 0;
		(b[17] => z[12]) = 0;
		(a[0] => z[13]) = 0;
		(a[1] => z[13]) = 0;
		(a[2] => z[13]) = 0;
		(a[3] => z[13]) = 0;
		(a[4] => z[13]) = 0;
		(a[5] => z[13]) = 0;
		(a[6] => z[13]) = 0;
		(a[7] => z[13]) = 0;
		(a[8] => z[13]) = 0;
		(a[9] => z[13]) = 0;
		(a[10] => z[13]) = 0;
		(a[11] => z[13]) = 0;
		(a[12] => z[13]) = 0;
		(a[13] => z[13]) = 0;
		(a[14] => z[13]) = 0;
		(a[15] => z[13]) = 0;
		(a[16] => z[13]) = 0;
		(a[17] => z[13]) = 0;
		(a[18] => z[13]) = 0;
		(a[19] => z[13]) = 0;
		(b[0] => z[13]) = 0;
		(b[1] => z[13]) = 0;
		(b[2] => z[13]) = 0;
		(b[3] => z[13]) = 0;
		(b[4] => z[13]) = 0;
		(b[5] => z[13]) = 0;
		(b[6] => z[13]) = 0;
		(b[7] => z[13]) = 0;
		(b[8] => z[13]) = 0;
		(b[9] => z[13]) = 0;
		(b[10] => z[13]) = 0;
		(b[11] => z[13]) = 0;
		(b[12] => z[13]) = 0;
		(b[13] => z[13]) = 0;
		(b[14] => z[13]) = 0;
		(b[15] => z[13]) = 0;
		(b[16] => z[13]) = 0;
		(b[17] => z[13]) = 0;
		(a[0] => z[14]) = 0;
		(a[1] => z[14]) = 0;
		(a[2] => z[14]) = 0;
		(a[3] => z[14]) = 0;
		(a[4] => z[14]) = 0;
		(a[5] => z[14]) = 0;
		(a[6] => z[14]) = 0;
		(a[7] => z[14]) = 0;
		(a[8] => z[14]) = 0;
		(a[9] => z[14]) = 0;
		(a[10] => z[14]) = 0;
		(a[11] => z[14]) = 0;
		(a[12] => z[14]) = 0;
		(a[13] => z[14]) = 0;
		(a[14] => z[14]) = 0;
		(a[15] => z[14]) = 0;
		(a[16] => z[14]) = 0;
		(a[17] => z[14]) = 0;
		(a[18] => z[14]) = 0;
		(a[19] => z[14]) = 0;
		(b[0] => z[14]) = 0;
		(b[1] => z[14]) = 0;
		(b[2] => z[14]) = 0;
		(b[3] => z[14]) = 0;
		(b[4] => z[14]) = 0;
		(b[5] => z[14]) = 0;
		(b[6] => z[14]) = 0;
		(b[7] => z[14]) = 0;
		(b[8] => z[14]) = 0;
		(b[9] => z[14]) = 0;
		(b[10] => z[14]) = 0;
		(b[11] => z[14]) = 0;
		(b[12] => z[14]) = 0;
		(b[13] => z[14]) = 0;
		(b[14] => z[14]) = 0;
		(b[15] => z[14]) = 0;
		(b[16] => z[14]) = 0;
		(b[17] => z[14]) = 0;
		(a[0] => z[15]) = 0;
		(a[1] => z[15]) = 0;
		(a[2] => z[15]) = 0;
		(a[3] => z[15]) = 0;
		(a[4] => z[15]) = 0;
		(a[5] => z[15]) = 0;
		(a[6] => z[15]) = 0;
		(a[7] => z[15]) = 0;
		(a[8] => z[15]) = 0;
		(a[9] => z[15]) = 0;
		(a[10] => z[15]) = 0;
		(a[11] => z[15]) = 0;
		(a[12] => z[15]) = 0;
		(a[13] => z[15]) = 0;
		(a[14] => z[15]) = 0;
		(a[15] => z[15]) = 0;
		(a[16] => z[15]) = 0;
		(a[17] => z[15]) = 0;
		(a[18] => z[15]) = 0;
		(a[19] => z[15]) = 0;
		(b[0] => z[15]) = 0;
		(b[1] => z[15]) = 0;
		(b[2] => z[15]) = 0;
		(b[3] => z[15]) = 0;
		(b[4] => z[15]) = 0;
		(b[5] => z[15]) = 0;
		(b[6] => z[15]) = 0;
		(b[7] => z[15]) = 0;
		(b[8] => z[15]) = 0;
		(b[9] => z[15]) = 0;
		(b[10] => z[15]) = 0;
		(b[11] => z[15]) = 0;
		(b[12] => z[15]) = 0;
		(b[13] => z[15]) = 0;
		(b[14] => z[15]) = 0;
		(b[15] => z[15]) = 0;
		(b[16] => z[15]) = 0;
		(b[17] => z[15]) = 0;
		(a[0] => z[16]) = 0;
		(a[1] => z[16]) = 0;
		(a[2] => z[16]) = 0;
		(a[3] => z[16]) = 0;
		(a[4] => z[16]) = 0;
		(a[5] => z[16]) = 0;
		(a[6] => z[16]) = 0;
		(a[7] => z[16]) = 0;
		(a[8] => z[16]) = 0;
		(a[9] => z[16]) = 0;
		(a[10] => z[16]) = 0;
		(a[11] => z[16]) = 0;
		(a[12] => z[16]) = 0;
		(a[13] => z[16]) = 0;
		(a[14] => z[16]) = 0;
		(a[15] => z[16]) = 0;
		(a[16] => z[16]) = 0;
		(a[17] => z[16]) = 0;
		(a[18] => z[16]) = 0;
		(a[19] => z[16]) = 0;
		(b[0] => z[16]) = 0;
		(b[1] => z[16]) = 0;
		(b[2] => z[16]) = 0;
		(b[3] => z[16]) = 0;
		(b[4] => z[16]) = 0;
		(b[5] => z[16]) = 0;
		(b[6] => z[16]) = 0;
		(b[7] => z[16]) = 0;
		(b[8] => z[16]) = 0;
		(b[9] => z[16]) = 0;
		(b[10] => z[16]) = 0;
		(b[11] => z[16]) = 0;
		(b[12] => z[16]) = 0;
		(b[13] => z[16]) = 0;
		(b[14] => z[16]) = 0;
		(b[15] => z[16]) = 0;
		(b[16] => z[16]) = 0;
		(b[17] => z[16]) = 0;
		(a[0] => z[17]) = 0;
		(a[1] => z[17]) = 0;
		(a[2] => z[17]) = 0;
		(a[3] => z[17]) = 0;
		(a[4] => z[17]) = 0;
		(a[5] => z[17]) = 0;
		(a[6] => z[17]) = 0;
		(a[7] => z[17]) = 0;
		(a[8] => z[17]) = 0;
		(a[9] => z[17]) = 0;
		(a[10] => z[17]) = 0;
		(a[11] => z[17]) = 0;
		(a[12] => z[17]) = 0;
		(a[13] => z[17]) = 0;
		(a[14] => z[17]) = 0;
		(a[15] => z[17]) = 0;
		(a[16] => z[17]) = 0;
		(a[17] => z[17]) = 0;
		(a[18] => z[17]) = 0;
		(a[19] => z[17]) = 0;
		(b[0] => z[17]) = 0;
		(b[1] => z[17]) = 0;
		(b[2] => z[17]) = 0;
		(b[3] => z[17]) = 0;
		(b[4] => z[17]) = 0;
		(b[5] => z[17]) = 0;
		(b[6] => z[17]) = 0;
		(b[7] => z[17]) = 0;
		(b[8] => z[17]) = 0;
		(b[9] => z[17]) = 0;
		(b[10] => z[17]) = 0;
		(b[11] => z[17]) = 0;
		(b[12] => z[17]) = 0;
		(b[13] => z[17]) = 0;
		(b[14] => z[17]) = 0;
		(b[15] => z[17]) = 0;
		(b[16] => z[17]) = 0;
		(b[17] => z[17]) = 0;
		(a[0] => z[18]) = 0;
		(a[1] => z[18]) = 0;
		(a[2] => z[18]) = 0;
		(a[3] => z[18]) = 0;
		(a[4] => z[18]) = 0;
		(a[5] => z[18]) = 0;
		(a[6] => z[18]) = 0;
		(a[7] => z[18]) = 0;
		(a[8] => z[18]) = 0;
		(a[9] => z[18]) = 0;
		(a[10] => z[18]) = 0;
		(a[11] => z[18]) = 0;
		(a[12] => z[18]) = 0;
		(a[13] => z[18]) = 0;
		(a[14] => z[18]) = 0;
		(a[15] => z[18]) = 0;
		(a[16] => z[18]) = 0;
		(a[17] => z[18]) = 0;
		(a[18] => z[18]) = 0;
		(a[19] => z[18]) = 0;
		(b[0] => z[18]) = 0;
		(b[1] => z[18]) = 0;
		(b[2] => z[18]) = 0;
		(b[3] => z[18]) = 0;
		(b[4] => z[18]) = 0;
		(b[5] => z[18]) = 0;
		(b[6] => z[18]) = 0;
		(b[7] => z[18]) = 0;
		(b[8] => z[18]) = 0;
		(b[9] => z[18]) = 0;
		(b[10] => z[18]) = 0;
		(b[11] => z[18]) = 0;
		(b[12] => z[18]) = 0;
		(b[13] => z[18]) = 0;
		(b[14] => z[18]) = 0;
		(b[15] => z[18]) = 0;
		(b[16] => z[18]) = 0;
		(b[17] => z[18]) = 0;
		(a[0] => z[19]) = 0;
		(a[1] => z[19]) = 0;
		(a[2] => z[19]) = 0;
		(a[3] => z[19]) = 0;
		(a[4] => z[19]) = 0;
		(a[5] => z[19]) = 0;
		(a[6] => z[19]) = 0;
		(a[7] => z[19]) = 0;
		(a[8] => z[19]) = 0;
		(a[9] => z[19]) = 0;
		(a[10] => z[19]) = 0;
		(a[11] => z[19]) = 0;
		(a[12] => z[19]) = 0;
		(a[13] => z[19]) = 0;
		(a[14] => z[19]) = 0;
		(a[15] => z[19]) = 0;
		(a[16] => z[19]) = 0;
		(a[17] => z[19]) = 0;
		(a[18] => z[19]) = 0;
		(a[19] => z[19]) = 0;
		(b[0] => z[19]) = 0;
		(b[1] => z[19]) = 0;
		(b[2] => z[19]) = 0;
		(b[3] => z[19]) = 0;
		(b[4] => z[19]) = 0;
		(b[5] => z[19]) = 0;
		(b[6] => z[19]) = 0;
		(b[7] => z[19]) = 0;
		(b[8] => z[19]) = 0;
		(b[9] => z[19]) = 0;
		(b[10] => z[19]) = 0;
		(b[11] => z[19]) = 0;
		(b[12] => z[19]) = 0;
		(b[13] => z[19]) = 0;
		(b[14] => z[19]) = 0;
		(b[15] => z[19]) = 0;
		(b[16] => z[19]) = 0;
		(b[17] => z[19]) = 0;
		(a[0] => z[20]) = 0;
		(a[1] => z[20]) = 0;
		(a[2] => z[20]) = 0;
		(a[3] => z[20]) = 0;
		(a[4] => z[20]) = 0;
		(a[5] => z[20]) = 0;
		(a[6] => z[20]) = 0;
		(a[7] => z[20]) = 0;
		(a[8] => z[20]) = 0;
		(a[9] => z[20]) = 0;
		(a[10] => z[20]) = 0;
		(a[11] => z[20]) = 0;
		(a[12] => z[20]) = 0;
		(a[13] => z[20]) = 0;
		(a[14] => z[20]) = 0;
		(a[15] => z[20]) = 0;
		(a[16] => z[20]) = 0;
		(a[17] => z[20]) = 0;
		(a[18] => z[20]) = 0;
		(a[19] => z[20]) = 0;
		(b[0] => z[20]) = 0;
		(b[1] => z[20]) = 0;
		(b[2] => z[20]) = 0;
		(b[3] => z[20]) = 0;
		(b[4] => z[20]) = 0;
		(b[5] => z[20]) = 0;
		(b[6] => z[20]) = 0;
		(b[7] => z[20]) = 0;
		(b[8] => z[20]) = 0;
		(b[9] => z[20]) = 0;
		(b[10] => z[20]) = 0;
		(b[11] => z[20]) = 0;
		(b[12] => z[20]) = 0;
		(b[13] => z[20]) = 0;
		(b[14] => z[20]) = 0;
		(b[15] => z[20]) = 0;
		(b[16] => z[20]) = 0;
		(b[17] => z[20]) = 0;
		(a[0] => z[21]) = 0;
		(a[1] => z[21]) = 0;
		(a[2] => z[21]) = 0;
		(a[3] => z[21]) = 0;
		(a[4] => z[21]) = 0;
		(a[5] => z[21]) = 0;
		(a[6] => z[21]) = 0;
		(a[7] => z[21]) = 0;
		(a[8] => z[21]) = 0;
		(a[9] => z[21]) = 0;
		(a[10] => z[21]) = 0;
		(a[11] => z[21]) = 0;
		(a[12] => z[21]) = 0;
		(a[13] => z[21]) = 0;
		(a[14] => z[21]) = 0;
		(a[15] => z[21]) = 0;
		(a[16] => z[21]) = 0;
		(a[17] => z[21]) = 0;
		(a[18] => z[21]) = 0;
		(a[19] => z[21]) = 0;
		(b[0] => z[21]) = 0;
		(b[1] => z[21]) = 0;
		(b[2] => z[21]) = 0;
		(b[3] => z[21]) = 0;
		(b[4] => z[21]) = 0;
		(b[5] => z[21]) = 0;
		(b[6] => z[21]) = 0;
		(b[7] => z[21]) = 0;
		(b[8] => z[21]) = 0;
		(b[9] => z[21]) = 0;
		(b[10] => z[21]) = 0;
		(b[11] => z[21]) = 0;
		(b[12] => z[21]) = 0;
		(b[13] => z[21]) = 0;
		(b[14] => z[21]) = 0;
		(b[15] => z[21]) = 0;
		(b[16] => z[21]) = 0;
		(b[17] => z[21]) = 0;
		(a[0] => z[22]) = 0;
		(a[1] => z[22]) = 0;
		(a[2] => z[22]) = 0;
		(a[3] => z[22]) = 0;
		(a[4] => z[22]) = 0;
		(a[5] => z[22]) = 0;
		(a[6] => z[22]) = 0;
		(a[7] => z[22]) = 0;
		(a[8] => z[22]) = 0;
		(a[9] => z[22]) = 0;
		(a[10] => z[22]) = 0;
		(a[11] => z[22]) = 0;
		(a[12] => z[22]) = 0;
		(a[13] => z[22]) = 0;
		(a[14] => z[22]) = 0;
		(a[15] => z[22]) = 0;
		(a[16] => z[22]) = 0;
		(a[17] => z[22]) = 0;
		(a[18] => z[22]) = 0;
		(a[19] => z[22]) = 0;
		(b[0] => z[22]) = 0;
		(b[1] => z[22]) = 0;
		(b[2] => z[22]) = 0;
		(b[3] => z[22]) = 0;
		(b[4] => z[22]) = 0;
		(b[5] => z[22]) = 0;
		(b[6] => z[22]) = 0;
		(b[7] => z[22]) = 0;
		(b[8] => z[22]) = 0;
		(b[9] => z[22]) = 0;
		(b[10] => z[22]) = 0;
		(b[11] => z[22]) = 0;
		(b[12] => z[22]) = 0;
		(b[13] => z[22]) = 0;
		(b[14] => z[22]) = 0;
		(b[15] => z[22]) = 0;
		(b[16] => z[22]) = 0;
		(b[17] => z[22]) = 0;
		(a[0] => z[23]) = 0;
		(a[1] => z[23]) = 0;
		(a[2] => z[23]) = 0;
		(a[3] => z[23]) = 0;
		(a[4] => z[23]) = 0;
		(a[5] => z[23]) = 0;
		(a[6] => z[23]) = 0;
		(a[7] => z[23]) = 0;
		(a[8] => z[23]) = 0;
		(a[9] => z[23]) = 0;
		(a[10] => z[23]) = 0;
		(a[11] => z[23]) = 0;
		(a[12] => z[23]) = 0;
		(a[13] => z[23]) = 0;
		(a[14] => z[23]) = 0;
		(a[15] => z[23]) = 0;
		(a[16] => z[23]) = 0;
		(a[17] => z[23]) = 0;
		(a[18] => z[23]) = 0;
		(a[19] => z[23]) = 0;
		(b[0] => z[23]) = 0;
		(b[1] => z[23]) = 0;
		(b[2] => z[23]) = 0;
		(b[3] => z[23]) = 0;
		(b[4] => z[23]) = 0;
		(b[5] => z[23]) = 0;
		(b[6] => z[23]) = 0;
		(b[7] => z[23]) = 0;
		(b[8] => z[23]) = 0;
		(b[9] => z[23]) = 0;
		(b[10] => z[23]) = 0;
		(b[11] => z[23]) = 0;
		(b[12] => z[23]) = 0;
		(b[13] => z[23]) = 0;
		(b[14] => z[23]) = 0;
		(b[15] => z[23]) = 0;
		(b[16] => z[23]) = 0;
		(b[17] => z[23]) = 0;
		(a[0] => z[24]) = 0;
		(a[1] => z[24]) = 0;
		(a[2] => z[24]) = 0;
		(a[3] => z[24]) = 0;
		(a[4] => z[24]) = 0;
		(a[5] => z[24]) = 0;
		(a[6] => z[24]) = 0;
		(a[7] => z[24]) = 0;
		(a[8] => z[24]) = 0;
		(a[9] => z[24]) = 0;
		(a[10] => z[24]) = 0;
		(a[11] => z[24]) = 0;
		(a[12] => z[24]) = 0;
		(a[13] => z[24]) = 0;
		(a[14] => z[24]) = 0;
		(a[15] => z[24]) = 0;
		(a[16] => z[24]) = 0;
		(a[17] => z[24]) = 0;
		(a[18] => z[24]) = 0;
		(a[19] => z[24]) = 0;
		(b[0] => z[24]) = 0;
		(b[1] => z[24]) = 0;
		(b[2] => z[24]) = 0;
		(b[3] => z[24]) = 0;
		(b[4] => z[24]) = 0;
		(b[5] => z[24]) = 0;
		(b[6] => z[24]) = 0;
		(b[7] => z[24]) = 0;
		(b[8] => z[24]) = 0;
		(b[9] => z[24]) = 0;
		(b[10] => z[24]) = 0;
		(b[11] => z[24]) = 0;
		(b[12] => z[24]) = 0;
		(b[13] => z[24]) = 0;
		(b[14] => z[24]) = 0;
		(b[15] => z[24]) = 0;
		(b[16] => z[24]) = 0;
		(b[17] => z[24]) = 0;
		(a[0] => z[25]) = 0;
		(a[1] => z[25]) = 0;
		(a[2] => z[25]) = 0;
		(a[3] => z[25]) = 0;
		(a[4] => z[25]) = 0;
		(a[5] => z[25]) = 0;
		(a[6] => z[25]) = 0;
		(a[7] => z[25]) = 0;
		(a[8] => z[25]) = 0;
		(a[9] => z[25]) = 0;
		(a[10] => z[25]) = 0;
		(a[11] => z[25]) = 0;
		(a[12] => z[25]) = 0;
		(a[13] => z[25]) = 0;
		(a[14] => z[25]) = 0;
		(a[15] => z[25]) = 0;
		(a[16] => z[25]) = 0;
		(a[17] => z[25]) = 0;
		(a[18] => z[25]) = 0;
		(a[19] => z[25]) = 0;
		(b[0] => z[25]) = 0;
		(b[1] => z[25]) = 0;
		(b[2] => z[25]) = 0;
		(b[3] => z[25]) = 0;
		(b[4] => z[25]) = 0;
		(b[5] => z[25]) = 0;
		(b[6] => z[25]) = 0;
		(b[7] => z[25]) = 0;
		(b[8] => z[25]) = 0;
		(b[9] => z[25]) = 0;
		(b[10] => z[25]) = 0;
		(b[11] => z[25]) = 0;
		(b[12] => z[25]) = 0;
		(b[13] => z[25]) = 0;
		(b[14] => z[25]) = 0;
		(b[15] => z[25]) = 0;
		(b[16] => z[25]) = 0;
		(b[17] => z[25]) = 0;
		(a[0] => z[26]) = 0;
		(a[1] => z[26]) = 0;
		(a[2] => z[26]) = 0;
		(a[3] => z[26]) = 0;
		(a[4] => z[26]) = 0;
		(a[5] => z[26]) = 0;
		(a[6] => z[26]) = 0;
		(a[7] => z[26]) = 0;
		(a[8] => z[26]) = 0;
		(a[9] => z[26]) = 0;
		(a[10] => z[26]) = 0;
		(a[11] => z[26]) = 0;
		(a[12] => z[26]) = 0;
		(a[13] => z[26]) = 0;
		(a[14] => z[26]) = 0;
		(a[15] => z[26]) = 0;
		(a[16] => z[26]) = 0;
		(a[17] => z[26]) = 0;
		(a[18] => z[26]) = 0;
		(a[19] => z[26]) = 0;
		(b[0] => z[26]) = 0;
		(b[1] => z[26]) = 0;
		(b[2] => z[26]) = 0;
		(b[3] => z[26]) = 0;
		(b[4] => z[26]) = 0;
		(b[5] => z[26]) = 0;
		(b[6] => z[26]) = 0;
		(b[7] => z[26]) = 0;
		(b[8] => z[26]) = 0;
		(b[9] => z[26]) = 0;
		(b[10] => z[26]) = 0;
		(b[11] => z[26]) = 0;
		(b[12] => z[26]) = 0;
		(b[13] => z[26]) = 0;
		(b[14] => z[26]) = 0;
		(b[15] => z[26]) = 0;
		(b[16] => z[26]) = 0;
		(b[17] => z[26]) = 0;
		(a[0] => z[27]) = 0;
		(a[1] => z[27]) = 0;
		(a[2] => z[27]) = 0;
		(a[3] => z[27]) = 0;
		(a[4] => z[27]) = 0;
		(a[5] => z[27]) = 0;
		(a[6] => z[27]) = 0;
		(a[7] => z[27]) = 0;
		(a[8] => z[27]) = 0;
		(a[9] => z[27]) = 0;
		(a[10] => z[27]) = 0;
		(a[11] => z[27]) = 0;
		(a[12] => z[27]) = 0;
		(a[13] => z[27]) = 0;
		(a[14] => z[27]) = 0;
		(a[15] => z[27]) = 0;
		(a[16] => z[27]) = 0;
		(a[17] => z[27]) = 0;
		(a[18] => z[27]) = 0;
		(a[19] => z[27]) = 0;
		(b[0] => z[27]) = 0;
		(b[1] => z[27]) = 0;
		(b[2] => z[27]) = 0;
		(b[3] => z[27]) = 0;
		(b[4] => z[27]) = 0;
		(b[5] => z[27]) = 0;
		(b[6] => z[27]) = 0;
		(b[7] => z[27]) = 0;
		(b[8] => z[27]) = 0;
		(b[9] => z[27]) = 0;
		(b[10] => z[27]) = 0;
		(b[11] => z[27]) = 0;
		(b[12] => z[27]) = 0;
		(b[13] => z[27]) = 0;
		(b[14] => z[27]) = 0;
		(b[15] => z[27]) = 0;
		(b[16] => z[27]) = 0;
		(b[17] => z[27]) = 0;
		(a[0] => z[28]) = 0;
		(a[1] => z[28]) = 0;
		(a[2] => z[28]) = 0;
		(a[3] => z[28]) = 0;
		(a[4] => z[28]) = 0;
		(a[5] => z[28]) = 0;
		(a[6] => z[28]) = 0;
		(a[7] => z[28]) = 0;
		(a[8] => z[28]) = 0;
		(a[9] => z[28]) = 0;
		(a[10] => z[28]) = 0;
		(a[11] => z[28]) = 0;
		(a[12] => z[28]) = 0;
		(a[13] => z[28]) = 0;
		(a[14] => z[28]) = 0;
		(a[15] => z[28]) = 0;
		(a[16] => z[28]) = 0;
		(a[17] => z[28]) = 0;
		(a[18] => z[28]) = 0;
		(a[19] => z[28]) = 0;
		(b[0] => z[28]) = 0;
		(b[1] => z[28]) = 0;
		(b[2] => z[28]) = 0;
		(b[3] => z[28]) = 0;
		(b[4] => z[28]) = 0;
		(b[5] => z[28]) = 0;
		(b[6] => z[28]) = 0;
		(b[7] => z[28]) = 0;
		(b[8] => z[28]) = 0;
		(b[9] => z[28]) = 0;
		(b[10] => z[28]) = 0;
		(b[11] => z[28]) = 0;
		(b[12] => z[28]) = 0;
		(b[13] => z[28]) = 0;
		(b[14] => z[28]) = 0;
		(b[15] => z[28]) = 0;
		(b[16] => z[28]) = 0;
		(b[17] => z[28]) = 0;
		(a[0] => z[29]) = 0;
		(a[1] => z[29]) = 0;
		(a[2] => z[29]) = 0;
		(a[3] => z[29]) = 0;
		(a[4] => z[29]) = 0;
		(a[5] => z[29]) = 0;
		(a[6] => z[29]) = 0;
		(a[7] => z[29]) = 0;
		(a[8] => z[29]) = 0;
		(a[9] => z[29]) = 0;
		(a[10] => z[29]) = 0;
		(a[11] => z[29]) = 0;
		(a[12] => z[29]) = 0;
		(a[13] => z[29]) = 0;
		(a[14] => z[29]) = 0;
		(a[15] => z[29]) = 0;
		(a[16] => z[29]) = 0;
		(a[17] => z[29]) = 0;
		(a[18] => z[29]) = 0;
		(a[19] => z[29]) = 0;
		(b[0] => z[29]) = 0;
		(b[1] => z[29]) = 0;
		(b[2] => z[29]) = 0;
		(b[3] => z[29]) = 0;
		(b[4] => z[29]) = 0;
		(b[5] => z[29]) = 0;
		(b[6] => z[29]) = 0;
		(b[7] => z[29]) = 0;
		(b[8] => z[29]) = 0;
		(b[9] => z[29]) = 0;
		(b[10] => z[29]) = 0;
		(b[11] => z[29]) = 0;
		(b[12] => z[29]) = 0;
		(b[13] => z[29]) = 0;
		(b[14] => z[29]) = 0;
		(b[15] => z[29]) = 0;
		(b[16] => z[29]) = 0;
		(b[17] => z[29]) = 0;
		(a[0] => z[30]) = 0;
		(a[1] => z[30]) = 0;
		(a[2] => z[30]) = 0;
		(a[3] => z[30]) = 0;
		(a[4] => z[30]) = 0;
		(a[5] => z[30]) = 0;
		(a[6] => z[30]) = 0;
		(a[7] => z[30]) = 0;
		(a[8] => z[30]) = 0;
		(a[9] => z[30]) = 0;
		(a[10] => z[30]) = 0;
		(a[11] => z[30]) = 0;
		(a[12] => z[30]) = 0;
		(a[13] => z[30]) = 0;
		(a[14] => z[30]) = 0;
		(a[15] => z[30]) = 0;
		(a[16] => z[30]) = 0;
		(a[17] => z[30]) = 0;
		(a[18] => z[30]) = 0;
		(a[19] => z[30]) = 0;
		(b[0] => z[30]) = 0;
		(b[1] => z[30]) = 0;
		(b[2] => z[30]) = 0;
		(b[3] => z[30]) = 0;
		(b[4] => z[30]) = 0;
		(b[5] => z[30]) = 0;
		(b[6] => z[30]) = 0;
		(b[7] => z[30]) = 0;
		(b[8] => z[30]) = 0;
		(b[9] => z[30]) = 0;
		(b[10] => z[30]) = 0;
		(b[11] => z[30]) = 0;
		(b[12] => z[30]) = 0;
		(b[13] => z[30]) = 0;
		(b[14] => z[30]) = 0;
		(b[15] => z[30]) = 0;
		(b[16] => z[30]) = 0;
		(b[17] => z[30]) = 0;
		(a[0] => z[31]) = 0;
		(a[1] => z[31]) = 0;
		(a[2] => z[31]) = 0;
		(a[3] => z[31]) = 0;
		(a[4] => z[31]) = 0;
		(a[5] => z[31]) = 0;
		(a[6] => z[31]) = 0;
		(a[7] => z[31]) = 0;
		(a[8] => z[31]) = 0;
		(a[9] => z[31]) = 0;
		(a[10] => z[31]) = 0;
		(a[11] => z[31]) = 0;
		(a[12] => z[31]) = 0;
		(a[13] => z[31]) = 0;
		(a[14] => z[31]) = 0;
		(a[15] => z[31]) = 0;
		(a[16] => z[31]) = 0;
		(a[17] => z[31]) = 0;
		(a[18] => z[31]) = 0;
		(a[19] => z[31]) = 0;
		(b[0] => z[31]) = 0;
		(b[1] => z[31]) = 0;
		(b[2] => z[31]) = 0;
		(b[3] => z[31]) = 0;
		(b[4] => z[31]) = 0;
		(b[5] => z[31]) = 0;
		(b[6] => z[31]) = 0;
		(b[7] => z[31]) = 0;
		(b[8] => z[31]) = 0;
		(b[9] => z[31]) = 0;
		(b[10] => z[31]) = 0;
		(b[11] => z[31]) = 0;
		(b[12] => z[31]) = 0;
		(b[13] => z[31]) = 0;
		(b[14] => z[31]) = 0;
		(b[15] => z[31]) = 0;
		(b[16] => z[31]) = 0;
		(b[17] => z[31]) = 0;
		(a[0] => z[32]) = 0;
		(a[1] => z[32]) = 0;
		(a[2] => z[32]) = 0;
		(a[3] => z[32]) = 0;
		(a[4] => z[32]) = 0;
		(a[5] => z[32]) = 0;
		(a[6] => z[32]) = 0;
		(a[7] => z[32]) = 0;
		(a[8] => z[32]) = 0;
		(a[9] => z[32]) = 0;
		(a[10] => z[32]) = 0;
		(a[11] => z[32]) = 0;
		(a[12] => z[32]) = 0;
		(a[13] => z[32]) = 0;
		(a[14] => z[32]) = 0;
		(a[15] => z[32]) = 0;
		(a[16] => z[32]) = 0;
		(a[17] => z[32]) = 0;
		(a[18] => z[32]) = 0;
		(a[19] => z[32]) = 0;
		(b[0] => z[32]) = 0;
		(b[1] => z[32]) = 0;
		(b[2] => z[32]) = 0;
		(b[3] => z[32]) = 0;
		(b[4] => z[32]) = 0;
		(b[5] => z[32]) = 0;
		(b[6] => z[32]) = 0;
		(b[7] => z[32]) = 0;
		(b[8] => z[32]) = 0;
		(b[9] => z[32]) = 0;
		(b[10] => z[32]) = 0;
		(b[11] => z[32]) = 0;
		(b[12] => z[32]) = 0;
		(b[13] => z[32]) = 0;
		(b[14] => z[32]) = 0;
		(b[15] => z[32]) = 0;
		(b[16] => z[32]) = 0;
		(b[17] => z[32]) = 0;
		(a[0] => z[33]) = 0;
		(a[1] => z[33]) = 0;
		(a[2] => z[33]) = 0;
		(a[3] => z[33]) = 0;
		(a[4] => z[33]) = 0;
		(a[5] => z[33]) = 0;
		(a[6] => z[33]) = 0;
		(a[7] => z[33]) = 0;
		(a[8] => z[33]) = 0;
		(a[9] => z[33]) = 0;
		(a[10] => z[33]) = 0;
		(a[11] => z[33]) = 0;
		(a[12] => z[33]) = 0;
		(a[13] => z[33]) = 0;
		(a[14] => z[33]) = 0;
		(a[15] => z[33]) = 0;
		(a[16] => z[33]) = 0;
		(a[17] => z[33]) = 0;
		(a[18] => z[33]) = 0;
		(a[19] => z[33]) = 0;
		(b[0] => z[33]) = 0;
		(b[1] => z[33]) = 0;
		(b[2] => z[33]) = 0;
		(b[3] => z[33]) = 0;
		(b[4] => z[33]) = 0;
		(b[5] => z[33]) = 0;
		(b[6] => z[33]) = 0;
		(b[7] => z[33]) = 0;
		(b[8] => z[33]) = 0;
		(b[9] => z[33]) = 0;
		(b[10] => z[33]) = 0;
		(b[11] => z[33]) = 0;
		(b[12] => z[33]) = 0;
		(b[13] => z[33]) = 0;
		(b[14] => z[33]) = 0;
		(b[15] => z[33]) = 0;
		(b[16] => z[33]) = 0;
		(b[17] => z[33]) = 0;
		(a[0] => z[34]) = 0;
		(a[1] => z[34]) = 0;
		(a[2] => z[34]) = 0;
		(a[3] => z[34]) = 0;
		(a[4] => z[34]) = 0;
		(a[5] => z[34]) = 0;
		(a[6] => z[34]) = 0;
		(a[7] => z[34]) = 0;
		(a[8] => z[34]) = 0;
		(a[9] => z[34]) = 0;
		(a[10] => z[34]) = 0;
		(a[11] => z[34]) = 0;
		(a[12] => z[34]) = 0;
		(a[13] => z[34]) = 0;
		(a[14] => z[34]) = 0;
		(a[15] => z[34]) = 0;
		(a[16] => z[34]) = 0;
		(a[17] => z[34]) = 0;
		(a[18] => z[34]) = 0;
		(a[19] => z[34]) = 0;
		(b[0] => z[34]) = 0;
		(b[1] => z[34]) = 0;
		(b[2] => z[34]) = 0;
		(b[3] => z[34]) = 0;
		(b[4] => z[34]) = 0;
		(b[5] => z[34]) = 0;
		(b[6] => z[34]) = 0;
		(b[7] => z[34]) = 0;
		(b[8] => z[34]) = 0;
		(b[9] => z[34]) = 0;
		(b[10] => z[34]) = 0;
		(b[11] => z[34]) = 0;
		(b[12] => z[34]) = 0;
		(b[13] => z[34]) = 0;
		(b[14] => z[34]) = 0;
		(b[15] => z[34]) = 0;
		(b[16] => z[34]) = 0;
		(b[17] => z[34]) = 0;
		(a[0] => z[35]) = 0;
		(a[1] => z[35]) = 0;
		(a[2] => z[35]) = 0;
		(a[3] => z[35]) = 0;
		(a[4] => z[35]) = 0;
		(a[5] => z[35]) = 0;
		(a[6] => z[35]) = 0;
		(a[7] => z[35]) = 0;
		(a[8] => z[35]) = 0;
		(a[9] => z[35]) = 0;
		(a[10] => z[35]) = 0;
		(a[11] => z[35]) = 0;
		(a[12] => z[35]) = 0;
		(a[13] => z[35]) = 0;
		(a[14] => z[35]) = 0;
		(a[15] => z[35]) = 0;
		(a[16] => z[35]) = 0;
		(a[17] => z[35]) = 0;
		(a[18] => z[35]) = 0;
		(a[19] => z[35]) = 0;
		(b[0] => z[35]) = 0;
		(b[1] => z[35]) = 0;
		(b[2] => z[35]) = 0;
		(b[3] => z[35]) = 0;
		(b[4] => z[35]) = 0;
		(b[5] => z[35]) = 0;
		(b[6] => z[35]) = 0;
		(b[7] => z[35]) = 0;
		(b[8] => z[35]) = 0;
		(b[9] => z[35]) = 0;
		(b[10] => z[35]) = 0;
		(b[11] => z[35]) = 0;
		(b[12] => z[35]) = 0;
		(b[13] => z[35]) = 0;
		(b[14] => z[35]) = 0;
		(b[15] => z[35]) = 0;
		(b[16] => z[35]) = 0;
		(b[17] => z[35]) = 0;
		(a[0] => z[36]) = 0;
		(a[1] => z[36]) = 0;
		(a[2] => z[36]) = 0;
		(a[3] => z[36]) = 0;
		(a[4] => z[36]) = 0;
		(a[5] => z[36]) = 0;
		(a[6] => z[36]) = 0;
		(a[7] => z[36]) = 0;
		(a[8] => z[36]) = 0;
		(a[9] => z[36]) = 0;
		(a[10] => z[36]) = 0;
		(a[11] => z[36]) = 0;
		(a[12] => z[36]) = 0;
		(a[13] => z[36]) = 0;
		(a[14] => z[36]) = 0;
		(a[15] => z[36]) = 0;
		(a[16] => z[36]) = 0;
		(a[17] => z[36]) = 0;
		(a[18] => z[36]) = 0;
		(a[19] => z[36]) = 0;
		(b[0] => z[36]) = 0;
		(b[1] => z[36]) = 0;
		(b[2] => z[36]) = 0;
		(b[3] => z[36]) = 0;
		(b[4] => z[36]) = 0;
		(b[5] => z[36]) = 0;
		(b[6] => z[36]) = 0;
		(b[7] => z[36]) = 0;
		(b[8] => z[36]) = 0;
		(b[9] => z[36]) = 0;
		(b[10] => z[36]) = 0;
		(b[11] => z[36]) = 0;
		(b[12] => z[36]) = 0;
		(b[13] => z[36]) = 0;
		(b[14] => z[36]) = 0;
		(b[15] => z[36]) = 0;
		(b[16] => z[36]) = 0;
		(b[17] => z[36]) = 0;
		(a[0] => z[37]) = 0;
		(a[1] => z[37]) = 0;
		(a[2] => z[37]) = 0;
		(a[3] => z[37]) = 0;
		(a[4] => z[37]) = 0;
		(a[5] => z[37]) = 0;
		(a[6] => z[37]) = 0;
		(a[7] => z[37]) = 0;
		(a[8] => z[37]) = 0;
		(a[9] => z[37]) = 0;
		(a[10] => z[37]) = 0;
		(a[11] => z[37]) = 0;
		(a[12] => z[37]) = 0;
		(a[13] => z[37]) = 0;
		(a[14] => z[37]) = 0;
		(a[15] => z[37]) = 0;
		(a[16] => z[37]) = 0;
		(a[17] => z[37]) = 0;
		(a[18] => z[37]) = 0;
		(a[19] => z[37]) = 0;
		(b[0] => z[37]) = 0;
		(b[1] => z[37]) = 0;
		(b[2] => z[37]) = 0;
		(b[3] => z[37]) = 0;
		(b[4] => z[37]) = 0;
		(b[5] => z[37]) = 0;
		(b[6] => z[37]) = 0;
		(b[7] => z[37]) = 0;
		(b[8] => z[37]) = 0;
		(b[9] => z[37]) = 0;
		(b[10] => z[37]) = 0;
		(b[11] => z[37]) = 0;
		(b[12] => z[37]) = 0;
		(b[13] => z[37]) = 0;
		(b[14] => z[37]) = 0;
		(b[15] => z[37]) = 0;
		(b[16] => z[37]) = 0;
		(b[17] => z[37]) = 0;
	endspecify
\`endif

endmodule

module QL_DSP2_MULT_REGIN ( // TODO: Name subject to change
	input  wire [19:0] a,
	input  wire [17:0] b,
	output wire [37:0] z,

	(* clkbuf_sink *)
	input  wire       clk,
	input  wire       reset,

	input  wire [2:0] feedback,
	input  wire       unsigned_a,
	input  wire       unsigned_b,

	input  wire       f_mode,
	input  wire [2:0] output_select,
	input  wire       register_inputs
);

	parameter [79:0] MODE_BITS = 80'd0;

	localparam [19:0] COEFF_0 = MODE_BITS[19:0];
	localparam [19:0] COEFF_1 = MODE_BITS[39:20];
	localparam [19:0] COEFF_2 = MODE_BITS[59:40];
	localparam [19:0] COEFF_3 = MODE_BITS[79:60];

	QL_DSP2 #(
		.MODE_BITS({COEFF_3, COEFF_2, COEFF_1, COEFF_0})
	) dsp (
		.a(a),
		.b(b),
		.acc_fir(6'b0),
		.z(z),
		.dly_b(),

		.f_mode(f_mode),

		.feedback(feedback),
		.load_acc(1'b0),

		.unsigned_a(unsigned_a),
		.unsigned_b(unsigned_b),

		.clk(clk),
		.reset(reset),

		.output_select(output_select),      // unregistered output: a * b (0)
		.saturate_enable(1'b0),
		.shift_right(6'b0),
		.round(1'b0),
		.subtract(1'b0),
		.register_inputs(register_inputs)   // registered inputs
	);

\`ifdef SDF_SIM
	specify
		(posedge clk => (z +: a)) = 0;
		(posedge clk => (z +: b)) = 0;
		$setuphold(posedge clk, a, 0, 0);
		$setuphold(posedge clk, b, 0, 0);
		$setuphold(posedge clk, feedback, 0, 0);
	endspecify
\`endif

endmodule

module QL_DSP2_MULT_REGOUT ( // TODO: Name subject to change
	input  wire [19:0] a,
	input  wire [17:0] b,
	output wire [37:0] z,

	(* clkbuf_sink *)
	input  wire       clk,
	input  wire       reset,

	input  wire [2:0] feedback,
	input  wire       unsigned_a,
	input  wire       unsigned_b,
	input  wire       f_mode,
	input  wire [2:0] output_select,
	input  wire       register_inputs
);

	parameter [79:0] MODE_BITS = 80'd0;

	localparam [19:0] COEFF_0 = MODE_BITS[19:0];
	localparam [19:0] COEFF_1 = MODE_BITS[39:20];
	localparam [19:0] COEFF_2 = MODE_BITS[59:40];
	localparam [19:0] COEFF_3 = MODE_BITS[79:60];

	QL_DSP2 #(
		.MODE_BITS({COEFF_3, COEFF_2, COEFF_1, COEFF_0})
	) dsp (
		.a(a),
		.b(b),
		.acc_fir(6'b0),
		.z(z),
		.dly_b(),

		.f_mode(f_mode),

		.feedback(feedback),
		.load_acc(1'b0),

		.unsigned_a(unsigned_a),
		.unsigned_b(unsigned_b),

		.clk(clk),
		.reset(reset),

		.output_select(output_select),      // registered output: a * b (4)
		.saturate_enable(1'b0),
		.shift_right(6'b0),
		.round(1'b0),
		.subtract(1'b0),
		.register_inputs(register_inputs)   // unregistered inputs
	);

\`ifdef SDF_SIM
	specify
		(posedge clk => (z +: a)) = 0;
		(posedge clk => (z +: b)) = 0;
		$setuphold(posedge clk, a, 0, 0);
		$setuphold(posedge clk, b, 0, 0);
		$setuphold(posedge clk, feedback, 0, 0);
	endspecify
\`endif

endmodule

module QL_DSP2_MULT_REGIN_REGOUT ( // TODO: Name subject to change
	input  wire [19:0] a,
	input  wire [17:0] b,
	output wire [37:0] z,

	(* clkbuf_sink *)
	input  wire       clk,
	input  wire       reset,

	input  wire [2:0] feedback,
	input  wire       unsigned_a,
	input  wire       unsigned_b,
	input  wire       f_mode,
	input  wire [2:0] output_select,
	input  wire       register_inputs
);

	parameter [79:0] MODE_BITS = 80'd0;

	localparam [19:0] COEFF_0 = MODE_BITS[19:0];
	localparam [19:0] COEFF_1 = MODE_BITS[39:20];
	localparam [19:0] COEFF_2 = MODE_BITS[59:40];
	localparam [19:0] COEFF_3 = MODE_BITS[79:60];

	QL_DSP2 #(
		.MODE_BITS({COEFF_3, COEFF_2, COEFF_1, COEFF_0})
	) dsp (
		.a(a),
		.b(b),
		.acc_fir(6'b0),
		.z(z),
		.dly_b(),

		.f_mode(f_mode),

		.feedback(feedback),
		.load_acc(1'b0),

		.unsigned_a(unsigned_a),
		.unsigned_b(unsigned_b),

		.clk(clk),
		.reset(reset),

		.output_select(output_select),      // registered output: a * b (4)
		.saturate_enable(1'b0),
		.shift_right(6'b0),
		.round(1'b0),
		.subtract(1'b0),
		.register_inputs(register_inputs)   // registered inputs
	);

\`ifdef SDF_SIM
	specify
		(posedge clk => (z +: a)) = 0;
		(posedge clk => (z +: b)) = 0;
		$setuphold(posedge clk, a, 0, 0);
		$setuphold(posedge clk, b, 0, 0);
		$setuphold(posedge clk, feedback, 0, 0);
	endspecify
\`endif

endmodule

module QL_DSP2_MULTADD (
	input  wire [19:0] a,
	input  wire [17:0] b,
	output wire [37:0] z,

	input  wire        reset,

	input  wire [ 2:0] feedback,
	input  wire [ 5:0] acc_fir,
	input  wire        load_acc,
	input  wire        unsigned_a,
	input  wire        unsigned_b,

	input  wire        f_mode,
	input  wire [ 2:0] output_select,
	input  wire        saturate_enable,
	input  wire [ 5:0] shift_right,
	input  wire        round,
	input  wire        subtract,
	input  wire        register_inputs
);

	parameter [79:0] MODE_BITS = 80'd0;

	localparam [19:0] COEFF_0 = MODE_BITS[19:0];
	localparam [19:0] COEFF_1 = MODE_BITS[39:20];
	localparam [19:0] COEFF_2 = MODE_BITS[59:40];
	localparam [19:0] COEFF_3 = MODE_BITS[79:60];

	QL_DSP2 #(
		.MODE_BITS({COEFF_3, COEFF_2, COEFF_1, COEFF_0})
	) dsp (
		.a(a),
		.b(b),
		.dly_b(),
		.z(z),

		.f_mode(f_mode),

		.feedback(feedback),
		.acc_fir(acc_fir),
		.load_acc(load_acc),

		.unsigned_a(unsigned_a),
		.unsigned_b(unsigned_b),

		//.clk(1'b0),
		.reset(reset),

		.output_select(output_select),      // unregistered output: ACCin (2, 3)
		.saturate_enable(saturate_enable),
		.shift_right(shift_right),
		.round(round),
		.subtract(subtract),
		.register_inputs(register_inputs)   // unregistered inputs
	);

\`ifdef SDF_SIM
	specify
		(a[0] => z[0]) = 0;
		(a[1] => z[0]) = 0;
		(a[2] => z[0]) = 0;
		(a[3] => z[0]) = 0;
		(a[4] => z[0]) = 0;
		(a[5] => z[0]) = 0;
		(a[6] => z[0]) = 0;
		(a[7] => z[0]) = 0;
		(a[8] => z[0]) = 0;
		(a[9] => z[0]) = 0;
		(a[10] => z[0]) = 0;
		(a[11] => z[0]) = 0;
		(a[12] => z[0]) = 0;
		(a[13] => z[0]) = 0;
		(a[14] => z[0]) = 0;
		(a[15] => z[0]) = 0;
		(a[16] => z[0]) = 0;
		(a[17] => z[0]) = 0;
		(a[18] => z[0]) = 0;
		(a[19] => z[0]) = 0;
		(b[0] => z[0]) = 0;
		(b[1] => z[0]) = 0;
		(b[2] => z[0]) = 0;
		(b[3] => z[0]) = 0;
		(b[4] => z[0]) = 0;
		(b[5] => z[0]) = 0;
		(b[6] => z[0]) = 0;
		(b[7] => z[0]) = 0;
		(b[8] => z[0]) = 0;
		(b[9] => z[0]) = 0;
		(b[10] => z[0]) = 0;
		(b[11] => z[0]) = 0;
		(b[12] => z[0]) = 0;
		(b[13] => z[0]) = 0;
		(b[14] => z[0]) = 0;
		(b[15] => z[0]) = 0;
		(b[16] => z[0]) = 0;
		(b[17] => z[0]) = 0;
		(a[0] => z[1]) = 0;
		(a[1] => z[1]) = 0;
		(a[2] => z[1]) = 0;
		(a[3] => z[1]) = 0;
		(a[4] => z[1]) = 0;
		(a[5] => z[1]) = 0;
		(a[6] => z[1]) = 0;
		(a[7] => z[1]) = 0;
		(a[8] => z[1]) = 0;
		(a[9] => z[1]) = 0;
		(a[10] => z[1]) = 0;
		(a[11] => z[1]) = 0;
		(a[12] => z[1]) = 0;
		(a[13] => z[1]) = 0;
		(a[14] => z[1]) = 0;
		(a[15] => z[1]) = 0;
		(a[16] => z[1]) = 0;
		(a[17] => z[1]) = 0;
		(a[18] => z[1]) = 0;
		(a[19] => z[1]) = 0;
		(b[0] => z[1]) = 0;
		(b[1] => z[1]) = 0;
		(b[2] => z[1]) = 0;
		(b[3] => z[1]) = 0;
		(b[4] => z[1]) = 0;
		(b[5] => z[1]) = 0;
		(b[6] => z[1]) = 0;
		(b[7] => z[1]) = 0;
		(b[8] => z[1]) = 0;
		(b[9] => z[1]) = 0;
		(b[10] => z[1]) = 0;
		(b[11] => z[1]) = 0;
		(b[12] => z[1]) = 0;
		(b[13] => z[1]) = 0;
		(b[14] => z[1]) = 0;
		(b[15] => z[1]) = 0;
		(b[16] => z[1]) = 0;
		(b[17] => z[1]) = 0;
		(a[0] => z[2]) = 0;
		(a[1] => z[2]) = 0;
		(a[2] => z[2]) = 0;
		(a[3] => z[2]) = 0;
		(a[4] => z[2]) = 0;
		(a[5] => z[2]) = 0;
		(a[6] => z[2]) = 0;
		(a[7] => z[2]) = 0;
		(a[8] => z[2]) = 0;
		(a[9] => z[2]) = 0;
		(a[10] => z[2]) = 0;
		(a[11] => z[2]) = 0;
		(a[12] => z[2]) = 0;
		(a[13] => z[2]) = 0;
		(a[14] => z[2]) = 0;
		(a[15] => z[2]) = 0;
		(a[16] => z[2]) = 0;
		(a[17] => z[2]) = 0;
		(a[18] => z[2]) = 0;
		(a[19] => z[2]) = 0;
		(b[0] => z[2]) = 0;
		(b[1] => z[2]) = 0;
		(b[2] => z[2]) = 0;
		(b[3] => z[2]) = 0;
		(b[4] => z[2]) = 0;
		(b[5] => z[2]) = 0;
		(b[6] => z[2]) = 0;
		(b[7] => z[2]) = 0;
		(b[8] => z[2]) = 0;
		(b[9] => z[2]) = 0;
		(b[10] => z[2]) = 0;
		(b[11] => z[2]) = 0;
		(b[12] => z[2]) = 0;
		(b[13] => z[2]) = 0;
		(b[14] => z[2]) = 0;
		(b[15] => z[2]) = 0;
		(b[16] => z[2]) = 0;
		(b[17] => z[2]) = 0;
		(a[0] => z[3]) = 0;
		(a[1] => z[3]) = 0;
		(a[2] => z[3]) = 0;
		(a[3] => z[3]) = 0;
		(a[4] => z[3]) = 0;
		(a[5] => z[3]) = 0;
		(a[6] => z[3]) = 0;
		(a[7] => z[3]) = 0;
		(a[8] => z[3]) = 0;
		(a[9] => z[3]) = 0;
		(a[10] => z[3]) = 0;
		(a[11] => z[3]) = 0;
		(a[12] => z[3]) = 0;
		(a[13] => z[3]) = 0;
		(a[14] => z[3]) = 0;
		(a[15] => z[3]) = 0;
		(a[16] => z[3]) = 0;
		(a[17] => z[3]) = 0;
		(a[18] => z[3]) = 0;
		(a[19] => z[3]) = 0;
		(b[0] => z[3]) = 0;
		(b[1] => z[3]) = 0;
		(b[2] => z[3]) = 0;
		(b[3] => z[3]) = 0;
		(b[4] => z[3]) = 0;
		(b[5] => z[3]) = 0;
		(b[6] => z[3]) = 0;
		(b[7] => z[3]) = 0;
		(b[8] => z[3]) = 0;
		(b[9] => z[3]) = 0;
		(b[10] => z[3]) = 0;
		(b[11] => z[3]) = 0;
		(b[12] => z[3]) = 0;
		(b[13] => z[3]) = 0;
		(b[14] => z[3]) = 0;
		(b[15] => z[3]) = 0;
		(b[16] => z[3]) = 0;
		(b[17] => z[3]) = 0;
		(a[0] => z[4]) = 0;
		(a[1] => z[4]) = 0;
		(a[2] => z[4]) = 0;
		(a[3] => z[4]) = 0;
		(a[4] => z[4]) = 0;
		(a[5] => z[4]) = 0;
		(a[6] => z[4]) = 0;
		(a[7] => z[4]) = 0;
		(a[8] => z[4]) = 0;
		(a[9] => z[4]) = 0;
		(a[10] => z[4]) = 0;
		(a[11] => z[4]) = 0;
		(a[12] => z[4]) = 0;
		(a[13] => z[4]) = 0;
		(a[14] => z[4]) = 0;
		(a[15] => z[4]) = 0;
		(a[16] => z[4]) = 0;
		(a[17] => z[4]) = 0;
		(a[18] => z[4]) = 0;
		(a[19] => z[4]) = 0;
		(b[0] => z[4]) = 0;
		(b[1] => z[4]) = 0;
		(b[2] => z[4]) = 0;
		(b[3] => z[4]) = 0;
		(b[4] => z[4]) = 0;
		(b[5] => z[4]) = 0;
		(b[6] => z[4]) = 0;
		(b[7] => z[4]) = 0;
		(b[8] => z[4]) = 0;
		(b[9] => z[4]) = 0;
		(b[10] => z[4]) = 0;
		(b[11] => z[4]) = 0;
		(b[12] => z[4]) = 0;
		(b[13] => z[4]) = 0;
		(b[14] => z[4]) = 0;
		(b[15] => z[4]) = 0;
		(b[16] => z[4]) = 0;
		(b[17] => z[4]) = 0;
		(a[0] => z[5]) = 0;
		(a[1] => z[5]) = 0;
		(a[2] => z[5]) = 0;
		(a[3] => z[5]) = 0;
		(a[4] => z[5]) = 0;
		(a[5] => z[5]) = 0;
		(a[6] => z[5]) = 0;
		(a[7] => z[5]) = 0;
		(a[8] => z[5]) = 0;
		(a[9] => z[5]) = 0;
		(a[10] => z[5]) = 0;
		(a[11] => z[5]) = 0;
		(a[12] => z[5]) = 0;
		(a[13] => z[5]) = 0;
		(a[14] => z[5]) = 0;
		(a[15] => z[5]) = 0;
		(a[16] => z[5]) = 0;
		(a[17] => z[5]) = 0;
		(a[18] => z[5]) = 0;
		(a[19] => z[5]) = 0;
		(b[0] => z[5]) = 0;
		(b[1] => z[5]) = 0;
		(b[2] => z[5]) = 0;
		(b[3] => z[5]) = 0;
		(b[4] => z[5]) = 0;
		(b[5] => z[5]) = 0;
		(b[6] => z[5]) = 0;
		(b[7] => z[5]) = 0;
		(b[8] => z[5]) = 0;
		(b[9] => z[5]) = 0;
		(b[10] => z[5]) = 0;
		(b[11] => z[5]) = 0;
		(b[12] => z[5]) = 0;
		(b[13] => z[5]) = 0;
		(b[14] => z[5]) = 0;
		(b[15] => z[5]) = 0;
		(b[16] => z[5]) = 0;
		(b[17] => z[5]) = 0;
		(a[0] => z[6]) = 0;
		(a[1] => z[6]) = 0;
		(a[2] => z[6]) = 0;
		(a[3] => z[6]) = 0;
		(a[4] => z[6]) = 0;
		(a[5] => z[6]) = 0;
		(a[6] => z[6]) = 0;
		(a[7] => z[6]) = 0;
		(a[8] => z[6]) = 0;
		(a[9] => z[6]) = 0;
		(a[10] => z[6]) = 0;
		(a[11] => z[6]) = 0;
		(a[12] => z[6]) = 0;
		(a[13] => z[6]) = 0;
		(a[14] => z[6]) = 0;
		(a[15] => z[6]) = 0;
		(a[16] => z[6]) = 0;
		(a[17] => z[6]) = 0;
		(a[18] => z[6]) = 0;
		(a[19] => z[6]) = 0;
		(b[0] => z[6]) = 0;
		(b[1] => z[6]) = 0;
		(b[2] => z[6]) = 0;
		(b[3] => z[6]) = 0;
		(b[4] => z[6]) = 0;
		(b[5] => z[6]) = 0;
		(b[6] => z[6]) = 0;
		(b[7] => z[6]) = 0;
		(b[8] => z[6]) = 0;
		(b[9] => z[6]) = 0;
		(b[10] => z[6]) = 0;
		(b[11] => z[6]) = 0;
		(b[12] => z[6]) = 0;
		(b[13] => z[6]) = 0;
		(b[14] => z[6]) = 0;
		(b[15] => z[6]) = 0;
		(b[16] => z[6]) = 0;
		(b[17] => z[6]) = 0;
		(a[0] => z[7]) = 0;
		(a[1] => z[7]) = 0;
		(a[2] => z[7]) = 0;
		(a[3] => z[7]) = 0;
		(a[4] => z[7]) = 0;
		(a[5] => z[7]) = 0;
		(a[6] => z[7]) = 0;
		(a[7] => z[7]) = 0;
		(a[8] => z[7]) = 0;
		(a[9] => z[7]) = 0;
		(a[10] => z[7]) = 0;
		(a[11] => z[7]) = 0;
		(a[12] => z[7]) = 0;
		(a[13] => z[7]) = 0;
		(a[14] => z[7]) = 0;
		(a[15] => z[7]) = 0;
		(a[16] => z[7]) = 0;
		(a[17] => z[7]) = 0;
		(a[18] => z[7]) = 0;
		(a[19] => z[7]) = 0;
		(b[0] => z[7]) = 0;
		(b[1] => z[7]) = 0;
		(b[2] => z[7]) = 0;
		(b[3] => z[7]) = 0;
		(b[4] => z[7]) = 0;
		(b[5] => z[7]) = 0;
		(b[6] => z[7]) = 0;
		(b[7] => z[7]) = 0;
		(b[8] => z[7]) = 0;
		(b[9] => z[7]) = 0;
		(b[10] => z[7]) = 0;
		(b[11] => z[7]) = 0;
		(b[12] => z[7]) = 0;
		(b[13] => z[7]) = 0;
		(b[14] => z[7]) = 0;
		(b[15] => z[7]) = 0;
		(b[16] => z[7]) = 0;
		(b[17] => z[7]) = 0;
		(a[0] => z[8]) = 0;
		(a[1] => z[8]) = 0;
		(a[2] => z[8]) = 0;
		(a[3] => z[8]) = 0;
		(a[4] => z[8]) = 0;
		(a[5] => z[8]) = 0;
		(a[6] => z[8]) = 0;
		(a[7] => z[8]) = 0;
		(a[8] => z[8]) = 0;
		(a[9] => z[8]) = 0;
		(a[10] => z[8]) = 0;
		(a[11] => z[8]) = 0;
		(a[12] => z[8]) = 0;
		(a[13] => z[8]) = 0;
		(a[14] => z[8]) = 0;
		(a[15] => z[8]) = 0;
		(a[16] => z[8]) = 0;
		(a[17] => z[8]) = 0;
		(a[18] => z[8]) = 0;
		(a[19] => z[8]) = 0;
		(b[0] => z[8]) = 0;
		(b[1] => z[8]) = 0;
		(b[2] => z[8]) = 0;
		(b[3] => z[8]) = 0;
		(b[4] => z[8]) = 0;
		(b[5] => z[8]) = 0;
		(b[6] => z[8]) = 0;
		(b[7] => z[8]) = 0;
		(b[8] => z[8]) = 0;
		(b[9] => z[8]) = 0;
		(b[10] => z[8]) = 0;
		(b[11] => z[8]) = 0;
		(b[12] => z[8]) = 0;
		(b[13] => z[8]) = 0;
		(b[14] => z[8]) = 0;
		(b[15] => z[8]) = 0;
		(b[16] => z[8]) = 0;
		(b[17] => z[8]) = 0;
		(a[0] => z[9]) = 0;
		(a[1] => z[9]) = 0;
		(a[2] => z[9]) = 0;
		(a[3] => z[9]) = 0;
		(a[4] => z[9]) = 0;
		(a[5] => z[9]) = 0;
		(a[6] => z[9]) = 0;
		(a[7] => z[9]) = 0;
		(a[8] => z[9]) = 0;
		(a[9] => z[9]) = 0;
		(a[10] => z[9]) = 0;
		(a[11] => z[9]) = 0;
		(a[12] => z[9]) = 0;
		(a[13] => z[9]) = 0;
		(a[14] => z[9]) = 0;
		(a[15] => z[9]) = 0;
		(a[16] => z[9]) = 0;
		(a[17] => z[9]) = 0;
		(a[18] => z[9]) = 0;
		(a[19] => z[9]) = 0;
		(b[0] => z[9]) = 0;
		(b[1] => z[9]) = 0;
		(b[2] => z[9]) = 0;
		(b[3] => z[9]) = 0;
		(b[4] => z[9]) = 0;
		(b[5] => z[9]) = 0;
		(b[6] => z[9]) = 0;
		(b[7] => z[9]) = 0;
		(b[8] => z[9]) = 0;
		(b[9] => z[9]) = 0;
		(b[10] => z[9]) = 0;
		(b[11] => z[9]) = 0;
		(b[12] => z[9]) = 0;
		(b[13] => z[9]) = 0;
		(b[14] => z[9]) = 0;
		(b[15] => z[9]) = 0;
		(b[16] => z[9]) = 0;
		(b[17] => z[9]) = 0;
		(a[0] => z[10]) = 0;
		(a[1] => z[10]) = 0;
		(a[2] => z[10]) = 0;
		(a[3] => z[10]) = 0;
		(a[4] => z[10]) = 0;
		(a[5] => z[10]) = 0;
		(a[6] => z[10]) = 0;
		(a[7] => z[10]) = 0;
		(a[8] => z[10]) = 0;
		(a[9] => z[10]) = 0;
		(a[10] => z[10]) = 0;
		(a[11] => z[10]) = 0;
		(a[12] => z[10]) = 0;
		(a[13] => z[10]) = 0;
		(a[14] => z[10]) = 0;
		(a[15] => z[10]) = 0;
		(a[16] => z[10]) = 0;
		(a[17] => z[10]) = 0;
		(a[18] => z[10]) = 0;
		(a[19] => z[10]) = 0;
		(b[0] => z[10]) = 0;
		(b[1] => z[10]) = 0;
		(b[2] => z[10]) = 0;
		(b[3] => z[10]) = 0;
		(b[4] => z[10]) = 0;
		(b[5] => z[10]) = 0;
		(b[6] => z[10]) = 0;
		(b[7] => z[10]) = 0;
		(b[8] => z[10]) = 0;
		(b[9] => z[10]) = 0;
		(b[10] => z[10]) = 0;
		(b[11] => z[10]) = 0;
		(b[12] => z[10]) = 0;
		(b[13] => z[10]) = 0;
		(b[14] => z[10]) = 0;
		(b[15] => z[10]) = 0;
		(b[16] => z[10]) = 0;
		(b[17] => z[10]) = 0;
		(a[0] => z[11]) = 0;
		(a[1] => z[11]) = 0;
		(a[2] => z[11]) = 0;
		(a[3] => z[11]) = 0;
		(a[4] => z[11]) = 0;
		(a[5] => z[11]) = 0;
		(a[6] => z[11]) = 0;
		(a[7] => z[11]) = 0;
		(a[8] => z[11]) = 0;
		(a[9] => z[11]) = 0;
		(a[10] => z[11]) = 0;
		(a[11] => z[11]) = 0;
		(a[12] => z[11]) = 0;
		(a[13] => z[11]) = 0;
		(a[14] => z[11]) = 0;
		(a[15] => z[11]) = 0;
		(a[16] => z[11]) = 0;
		(a[17] => z[11]) = 0;
		(a[18] => z[11]) = 0;
		(a[19] => z[11]) = 0;
		(b[0] => z[11]) = 0;
		(b[1] => z[11]) = 0;
		(b[2] => z[11]) = 0;
		(b[3] => z[11]) = 0;
		(b[4] => z[11]) = 0;
		(b[5] => z[11]) = 0;
		(b[6] => z[11]) = 0;
		(b[7] => z[11]) = 0;
		(b[8] => z[11]) = 0;
		(b[9] => z[11]) = 0;
		(b[10] => z[11]) = 0;
		(b[11] => z[11]) = 0;
		(b[12] => z[11]) = 0;
		(b[13] => z[11]) = 0;
		(b[14] => z[11]) = 0;
		(b[15] => z[11]) = 0;
		(b[16] => z[11]) = 0;
		(b[17] => z[11]) = 0;
		(a[0] => z[12]) = 0;
		(a[1] => z[12]) = 0;
		(a[2] => z[12]) = 0;
		(a[3] => z[12]) = 0;
		(a[4] => z[12]) = 0;
		(a[5] => z[12]) = 0;
		(a[6] => z[12]) = 0;
		(a[7] => z[12]) = 0;
		(a[8] => z[12]) = 0;
		(a[9] => z[12]) = 0;
		(a[10] => z[12]) = 0;
		(a[11] => z[12]) = 0;
		(a[12] => z[12]) = 0;
		(a[13] => z[12]) = 0;
		(a[14] => z[12]) = 0;
		(a[15] => z[12]) = 0;
		(a[16] => z[12]) = 0;
		(a[17] => z[12]) = 0;
		(a[18] => z[12]) = 0;
		(a[19] => z[12]) = 0;
		(b[0] => z[12]) = 0;
		(b[1] => z[12]) = 0;
		(b[2] => z[12]) = 0;
		(b[3] => z[12]) = 0;
		(b[4] => z[12]) = 0;
		(b[5] => z[12]) = 0;
		(b[6] => z[12]) = 0;
		(b[7] => z[12]) = 0;
		(b[8] => z[12]) = 0;
		(b[9] => z[12]) = 0;
		(b[10] => z[12]) = 0;
		(b[11] => z[12]) = 0;
		(b[12] => z[12]) = 0;
		(b[13] => z[12]) = 0;
		(b[14] => z[12]) = 0;
		(b[15] => z[12]) = 0;
		(b[16] => z[12]) = 0;
		(b[17] => z[12]) = 0;
		(a[0] => z[13]) = 0;
		(a[1] => z[13]) = 0;
		(a[2] => z[13]) = 0;
		(a[3] => z[13]) = 0;
		(a[4] => z[13]) = 0;
		(a[5] => z[13]) = 0;
		(a[6] => z[13]) = 0;
		(a[7] => z[13]) = 0;
		(a[8] => z[13]) = 0;
		(a[9] => z[13]) = 0;
		(a[10] => z[13]) = 0;
		(a[11] => z[13]) = 0;
		(a[12] => z[13]) = 0;
		(a[13] => z[13]) = 0;
		(a[14] => z[13]) = 0;
		(a[15] => z[13]) = 0;
		(a[16] => z[13]) = 0;
		(a[17] => z[13]) = 0;
		(a[18] => z[13]) = 0;
		(a[19] => z[13]) = 0;
		(b[0] => z[13]) = 0;
		(b[1] => z[13]) = 0;
		(b[2] => z[13]) = 0;
		(b[3] => z[13]) = 0;
		(b[4] => z[13]) = 0;
		(b[5] => z[13]) = 0;
		(b[6] => z[13]) = 0;
		(b[7] => z[13]) = 0;
		(b[8] => z[13]) = 0;
		(b[9] => z[13]) = 0;
		(b[10] => z[13]) = 0;
		(b[11] => z[13]) = 0;
		(b[12] => z[13]) = 0;
		(b[13] => z[13]) = 0;
		(b[14] => z[13]) = 0;
		(b[15] => z[13]) = 0;
		(b[16] => z[13]) = 0;
		(b[17] => z[13]) = 0;
		(a[0] => z[14]) = 0;
		(a[1] => z[14]) = 0;
		(a[2] => z[14]) = 0;
		(a[3] => z[14]) = 0;
		(a[4] => z[14]) = 0;
		(a[5] => z[14]) = 0;
		(a[6] => z[14]) = 0;
		(a[7] => z[14]) = 0;
		(a[8] => z[14]) = 0;
		(a[9] => z[14]) = 0;
		(a[10] => z[14]) = 0;
		(a[11] => z[14]) = 0;
		(a[12] => z[14]) = 0;
		(a[13] => z[14]) = 0;
		(a[14] => z[14]) = 0;
		(a[15] => z[14]) = 0;
		(a[16] => z[14]) = 0;
		(a[17] => z[14]) = 0;
		(a[18] => z[14]) = 0;
		(a[19] => z[14]) = 0;
		(b[0] => z[14]) = 0;
		(b[1] => z[14]) = 0;
		(b[2] => z[14]) = 0;
		(b[3] => z[14]) = 0;
		(b[4] => z[14]) = 0;
		(b[5] => z[14]) = 0;
		(b[6] => z[14]) = 0;
		(b[7] => z[14]) = 0;
		(b[8] => z[14]) = 0;
		(b[9] => z[14]) = 0;
		(b[10] => z[14]) = 0;
		(b[11] => z[14]) = 0;
		(b[12] => z[14]) = 0;
		(b[13] => z[14]) = 0;
		(b[14] => z[14]) = 0;
		(b[15] => z[14]) = 0;
		(b[16] => z[14]) = 0;
		(b[17] => z[14]) = 0;
		(a[0] => z[15]) = 0;
		(a[1] => z[15]) = 0;
		(a[2] => z[15]) = 0;
		(a[3] => z[15]) = 0;
		(a[4] => z[15]) = 0;
		(a[5] => z[15]) = 0;
		(a[6] => z[15]) = 0;
		(a[7] => z[15]) = 0;
		(a[8] => z[15]) = 0;
		(a[9] => z[15]) = 0;
		(a[10] => z[15]) = 0;
		(a[11] => z[15]) = 0;
		(a[12] => z[15]) = 0;
		(a[13] => z[15]) = 0;
		(a[14] => z[15]) = 0;
		(a[15] => z[15]) = 0;
		(a[16] => z[15]) = 0;
		(a[17] => z[15]) = 0;
		(a[18] => z[15]) = 0;
		(a[19] => z[15]) = 0;
		(b[0] => z[15]) = 0;
		(b[1] => z[15]) = 0;
		(b[2] => z[15]) = 0;
		(b[3] => z[15]) = 0;
		(b[4] => z[15]) = 0;
		(b[5] => z[15]) = 0;
		(b[6] => z[15]) = 0;
		(b[7] => z[15]) = 0;
		(b[8] => z[15]) = 0;
		(b[9] => z[15]) = 0;
		(b[10] => z[15]) = 0;
		(b[11] => z[15]) = 0;
		(b[12] => z[15]) = 0;
		(b[13] => z[15]) = 0;
		(b[14] => z[15]) = 0;
		(b[15] => z[15]) = 0;
		(b[16] => z[15]) = 0;
		(b[17] => z[15]) = 0;
		(a[0] => z[16]) = 0;
		(a[1] => z[16]) = 0;
		(a[2] => z[16]) = 0;
		(a[3] => z[16]) = 0;
		(a[4] => z[16]) = 0;
		(a[5] => z[16]) = 0;
		(a[6] => z[16]) = 0;
		(a[7] => z[16]) = 0;
		(a[8] => z[16]) = 0;
		(a[9] => z[16]) = 0;
		(a[10] => z[16]) = 0;
		(a[11] => z[16]) = 0;
		(a[12] => z[16]) = 0;
		(a[13] => z[16]) = 0;
		(a[14] => z[16]) = 0;
		(a[15] => z[16]) = 0;
		(a[16] => z[16]) = 0;
		(a[17] => z[16]) = 0;
		(a[18] => z[16]) = 0;
		(a[19] => z[16]) = 0;
		(b[0] => z[16]) = 0;
		(b[1] => z[16]) = 0;
		(b[2] => z[16]) = 0;
		(b[3] => z[16]) = 0;
		(b[4] => z[16]) = 0;
		(b[5] => z[16]) = 0;
		(b[6] => z[16]) = 0;
		(b[7] => z[16]) = 0;
		(b[8] => z[16]) = 0;
		(b[9] => z[16]) = 0;
		(b[10] => z[16]) = 0;
		(b[11] => z[16]) = 0;
		(b[12] => z[16]) = 0;
		(b[13] => z[16]) = 0;
		(b[14] => z[16]) = 0;
		(b[15] => z[16]) = 0;
		(b[16] => z[16]) = 0;
		(b[17] => z[16]) = 0;
		(a[0] => z[17]) = 0;
		(a[1] => z[17]) = 0;
		(a[2] => z[17]) = 0;
		(a[3] => z[17]) = 0;
		(a[4] => z[17]) = 0;
		(a[5] => z[17]) = 0;
		(a[6] => z[17]) = 0;
		(a[7] => z[17]) = 0;
		(a[8] => z[17]) = 0;
		(a[9] => z[17]) = 0;
		(a[10] => z[17]) = 0;
		(a[11] => z[17]) = 0;
		(a[12] => z[17]) = 0;
		(a[13] => z[17]) = 0;
		(a[14] => z[17]) = 0;
		(a[15] => z[17]) = 0;
		(a[16] => z[17]) = 0;
		(a[17] => z[17]) = 0;
		(a[18] => z[17]) = 0;
		(a[19] => z[17]) = 0;
		(b[0] => z[17]) = 0;
		(b[1] => z[17]) = 0;
		(b[2] => z[17]) = 0;
		(b[3] => z[17]) = 0;
		(b[4] => z[17]) = 0;
		(b[5] => z[17]) = 0;
		(b[6] => z[17]) = 0;
		(b[7] => z[17]) = 0;
		(b[8] => z[17]) = 0;
		(b[9] => z[17]) = 0;
		(b[10] => z[17]) = 0;
		(b[11] => z[17]) = 0;
		(b[12] => z[17]) = 0;
		(b[13] => z[17]) = 0;
		(b[14] => z[17]) = 0;
		(b[15] => z[17]) = 0;
		(b[16] => z[17]) = 0;
		(b[17] => z[17]) = 0;
		(a[0] => z[18]) = 0;
		(a[1] => z[18]) = 0;
		(a[2] => z[18]) = 0;
		(a[3] => z[18]) = 0;
		(a[4] => z[18]) = 0;
		(a[5] => z[18]) = 0;
		(a[6] => z[18]) = 0;
		(a[7] => z[18]) = 0;
		(a[8] => z[18]) = 0;
		(a[9] => z[18]) = 0;
		(a[10] => z[18]) = 0;
		(a[11] => z[18]) = 0;
		(a[12] => z[18]) = 0;
		(a[13] => z[18]) = 0;
		(a[14] => z[18]) = 0;
		(a[15] => z[18]) = 0;
		(a[16] => z[18]) = 0;
		(a[17] => z[18]) = 0;
		(a[18] => z[18]) = 0;
		(a[19] => z[18]) = 0;
		(b[0] => z[18]) = 0;
		(b[1] => z[18]) = 0;
		(b[2] => z[18]) = 0;
		(b[3] => z[18]) = 0;
		(b[4] => z[18]) = 0;
		(b[5] => z[18]) = 0;
		(b[6] => z[18]) = 0;
		(b[7] => z[18]) = 0;
		(b[8] => z[18]) = 0;
		(b[9] => z[18]) = 0;
		(b[10] => z[18]) = 0;
		(b[11] => z[18]) = 0;
		(b[12] => z[18]) = 0;
		(b[13] => z[18]) = 0;
		(b[14] => z[18]) = 0;
		(b[15] => z[18]) = 0;
		(b[16] => z[18]) = 0;
		(b[17] => z[18]) = 0;
		(a[0] => z[19]) = 0;
		(a[1] => z[19]) = 0;
		(a[2] => z[19]) = 0;
		(a[3] => z[19]) = 0;
		(a[4] => z[19]) = 0;
		(a[5] => z[19]) = 0;
		(a[6] => z[19]) = 0;
		(a[7] => z[19]) = 0;
		(a[8] => z[19]) = 0;
		(a[9] => z[19]) = 0;
		(a[10] => z[19]) = 0;
		(a[11] => z[19]) = 0;
		(a[12] => z[19]) = 0;
		(a[13] => z[19]) = 0;
		(a[14] => z[19]) = 0;
		(a[15] => z[19]) = 0;
		(a[16] => z[19]) = 0;
		(a[17] => z[19]) = 0;
		(a[18] => z[19]) = 0;
		(a[19] => z[19]) = 0;
		(b[0] => z[19]) = 0;
		(b[1] => z[19]) = 0;
		(b[2] => z[19]) = 0;
		(b[3] => z[19]) = 0;
		(b[4] => z[19]) = 0;
		(b[5] => z[19]) = 0;
		(b[6] => z[19]) = 0;
		(b[7] => z[19]) = 0;
		(b[8] => z[19]) = 0;
		(b[9] => z[19]) = 0;
		(b[10] => z[19]) = 0;
		(b[11] => z[19]) = 0;
		(b[12] => z[19]) = 0;
		(b[13] => z[19]) = 0;
		(b[14] => z[19]) = 0;
		(b[15] => z[19]) = 0;
		(b[16] => z[19]) = 0;
		(b[17] => z[19]) = 0;
		(a[0] => z[20]) = 0;
		(a[1] => z[20]) = 0;
		(a[2] => z[20]) = 0;
		(a[3] => z[20]) = 0;
		(a[4] => z[20]) = 0;
		(a[5] => z[20]) = 0;
		(a[6] => z[20]) = 0;
		(a[7] => z[20]) = 0;
		(a[8] => z[20]) = 0;
		(a[9] => z[20]) = 0;
		(a[10] => z[20]) = 0;
		(a[11] => z[20]) = 0;
		(a[12] => z[20]) = 0;
		(a[13] => z[20]) = 0;
		(a[14] => z[20]) = 0;
		(a[15] => z[20]) = 0;
		(a[16] => z[20]) = 0;
		(a[17] => z[20]) = 0;
		(a[18] => z[20]) = 0;
		(a[19] => z[20]) = 0;
		(b[0] => z[20]) = 0;
		(b[1] => z[20]) = 0;
		(b[2] => z[20]) = 0;
		(b[3] => z[20]) = 0;
		(b[4] => z[20]) = 0;
		(b[5] => z[20]) = 0;
		(b[6] => z[20]) = 0;
		(b[7] => z[20]) = 0;
		(b[8] => z[20]) = 0;
		(b[9] => z[20]) = 0;
		(b[10] => z[20]) = 0;
		(b[11] => z[20]) = 0;
		(b[12] => z[20]) = 0;
		(b[13] => z[20]) = 0;
		(b[14] => z[20]) = 0;
		(b[15] => z[20]) = 0;
		(b[16] => z[20]) = 0;
		(b[17] => z[20]) = 0;
		(a[0] => z[21]) = 0;
		(a[1] => z[21]) = 0;
		(a[2] => z[21]) = 0;
		(a[3] => z[21]) = 0;
		(a[4] => z[21]) = 0;
		(a[5] => z[21]) = 0;
		(a[6] => z[21]) = 0;
		(a[7] => z[21]) = 0;
		(a[8] => z[21]) = 0;
		(a[9] => z[21]) = 0;
		(a[10] => z[21]) = 0;
		(a[11] => z[21]) = 0;
		(a[12] => z[21]) = 0;
		(a[13] => z[21]) = 0;
		(a[14] => z[21]) = 0;
		(a[15] => z[21]) = 0;
		(a[16] => z[21]) = 0;
		(a[17] => z[21]) = 0;
		(a[18] => z[21]) = 0;
		(a[19] => z[21]) = 0;
		(b[0] => z[21]) = 0;
		(b[1] => z[21]) = 0;
		(b[2] => z[21]) = 0;
		(b[3] => z[21]) = 0;
		(b[4] => z[21]) = 0;
		(b[5] => z[21]) = 0;
		(b[6] => z[21]) = 0;
		(b[7] => z[21]) = 0;
		(b[8] => z[21]) = 0;
		(b[9] => z[21]) = 0;
		(b[10] => z[21]) = 0;
		(b[11] => z[21]) = 0;
		(b[12] => z[21]) = 0;
		(b[13] => z[21]) = 0;
		(b[14] => z[21]) = 0;
		(b[15] => z[21]) = 0;
		(b[16] => z[21]) = 0;
		(b[17] => z[21]) = 0;
		(a[0] => z[22]) = 0;
		(a[1] => z[22]) = 0;
		(a[2] => z[22]) = 0;
		(a[3] => z[22]) = 0;
		(a[4] => z[22]) = 0;
		(a[5] => z[22]) = 0;
		(a[6] => z[22]) = 0;
		(a[7] => z[22]) = 0;
		(a[8] => z[22]) = 0;
		(a[9] => z[22]) = 0;
		(a[10] => z[22]) = 0;
		(a[11] => z[22]) = 0;
		(a[12] => z[22]) = 0;
		(a[13] => z[22]) = 0;
		(a[14] => z[22]) = 0;
		(a[15] => z[22]) = 0;
		(a[16] => z[22]) = 0;
		(a[17] => z[22]) = 0;
		(a[18] => z[22]) = 0;
		(a[19] => z[22]) = 0;
		(b[0] => z[22]) = 0;
		(b[1] => z[22]) = 0;
		(b[2] => z[22]) = 0;
		(b[3] => z[22]) = 0;
		(b[4] => z[22]) = 0;
		(b[5] => z[22]) = 0;
		(b[6] => z[22]) = 0;
		(b[7] => z[22]) = 0;
		(b[8] => z[22]) = 0;
		(b[9] => z[22]) = 0;
		(b[10] => z[22]) = 0;
		(b[11] => z[22]) = 0;
		(b[12] => z[22]) = 0;
		(b[13] => z[22]) = 0;
		(b[14] => z[22]) = 0;
		(b[15] => z[22]) = 0;
		(b[16] => z[22]) = 0;
		(b[17] => z[22]) = 0;
		(a[0] => z[23]) = 0;
		(a[1] => z[23]) = 0;
		(a[2] => z[23]) = 0;
		(a[3] => z[23]) = 0;
		(a[4] => z[23]) = 0;
		(a[5] => z[23]) = 0;
		(a[6] => z[23]) = 0;
		(a[7] => z[23]) = 0;
		(a[8] => z[23]) = 0;
		(a[9] => z[23]) = 0;
		(a[10] => z[23]) = 0;
		(a[11] => z[23]) = 0;
		(a[12] => z[23]) = 0;
		(a[13] => z[23]) = 0;
		(a[14] => z[23]) = 0;
		(a[15] => z[23]) = 0;
		(a[16] => z[23]) = 0;
		(a[17] => z[23]) = 0;
		(a[18] => z[23]) = 0;
		(a[19] => z[23]) = 0;
		(b[0] => z[23]) = 0;
		(b[1] => z[23]) = 0;
		(b[2] => z[23]) = 0;
		(b[3] => z[23]) = 0;
		(b[4] => z[23]) = 0;
		(b[5] => z[23]) = 0;
		(b[6] => z[23]) = 0;
		(b[7] => z[23]) = 0;
		(b[8] => z[23]) = 0;
		(b[9] => z[23]) = 0;
		(b[10] => z[23]) = 0;
		(b[11] => z[23]) = 0;
		(b[12] => z[23]) = 0;
		(b[13] => z[23]) = 0;
		(b[14] => z[23]) = 0;
		(b[15] => z[23]) = 0;
		(b[16] => z[23]) = 0;
		(b[17] => z[23]) = 0;
		(a[0] => z[24]) = 0;
		(a[1] => z[24]) = 0;
		(a[2] => z[24]) = 0;
		(a[3] => z[24]) = 0;
		(a[4] => z[24]) = 0;
		(a[5] => z[24]) = 0;
		(a[6] => z[24]) = 0;
		(a[7] => z[24]) = 0;
		(a[8] => z[24]) = 0;
		(a[9] => z[24]) = 0;
		(a[10] => z[24]) = 0;
		(a[11] => z[24]) = 0;
		(a[12] => z[24]) = 0;
		(a[13] => z[24]) = 0;
		(a[14] => z[24]) = 0;
		(a[15] => z[24]) = 0;
		(a[16] => z[24]) = 0;
		(a[17] => z[24]) = 0;
		(a[18] => z[24]) = 0;
		(a[19] => z[24]) = 0;
		(b[0] => z[24]) = 0;
		(b[1] => z[24]) = 0;
		(b[2] => z[24]) = 0;
		(b[3] => z[24]) = 0;
		(b[4] => z[24]) = 0;
		(b[5] => z[24]) = 0;
		(b[6] => z[24]) = 0;
		(b[7] => z[24]) = 0;
		(b[8] => z[24]) = 0;
		(b[9] => z[24]) = 0;
		(b[10] => z[24]) = 0;
		(b[11] => z[24]) = 0;
		(b[12] => z[24]) = 0;
		(b[13] => z[24]) = 0;
		(b[14] => z[24]) = 0;
		(b[15] => z[24]) = 0;
		(b[16] => z[24]) = 0;
		(b[17] => z[24]) = 0;
		(a[0] => z[25]) = 0;
		(a[1] => z[25]) = 0;
		(a[2] => z[25]) = 0;
		(a[3] => z[25]) = 0;
		(a[4] => z[25]) = 0;
		(a[5] => z[25]) = 0;
		(a[6] => z[25]) = 0;
		(a[7] => z[25]) = 0;
		(a[8] => z[25]) = 0;
		(a[9] => z[25]) = 0;
		(a[10] => z[25]) = 0;
		(a[11] => z[25]) = 0;
		(a[12] => z[25]) = 0;
		(a[13] => z[25]) = 0;
		(a[14] => z[25]) = 0;
		(a[15] => z[25]) = 0;
		(a[16] => z[25]) = 0;
		(a[17] => z[25]) = 0;
		(a[18] => z[25]) = 0;
		(a[19] => z[25]) = 0;
		(b[0] => z[25]) = 0;
		(b[1] => z[25]) = 0;
		(b[2] => z[25]) = 0;
		(b[3] => z[25]) = 0;
		(b[4] => z[25]) = 0;
		(b[5] => z[25]) = 0;
		(b[6] => z[25]) = 0;
		(b[7] => z[25]) = 0;
		(b[8] => z[25]) = 0;
		(b[9] => z[25]) = 0;
		(b[10] => z[25]) = 0;
		(b[11] => z[25]) = 0;
		(b[12] => z[25]) = 0;
		(b[13] => z[25]) = 0;
		(b[14] => z[25]) = 0;
		(b[15] => z[25]) = 0;
		(b[16] => z[25]) = 0;
		(b[17] => z[25]) = 0;
		(a[0] => z[26]) = 0;
		(a[1] => z[26]) = 0;
		(a[2] => z[26]) = 0;
		(a[3] => z[26]) = 0;
		(a[4] => z[26]) = 0;
		(a[5] => z[26]) = 0;
		(a[6] => z[26]) = 0;
		(a[7] => z[26]) = 0;
		(a[8] => z[26]) = 0;
		(a[9] => z[26]) = 0;
		(a[10] => z[26]) = 0;
		(a[11] => z[26]) = 0;
		(a[12] => z[26]) = 0;
		(a[13] => z[26]) = 0;
		(a[14] => z[26]) = 0;
		(a[15] => z[26]) = 0;
		(a[16] => z[26]) = 0;
		(a[17] => z[26]) = 0;
		(a[18] => z[26]) = 0;
		(a[19] => z[26]) = 0;
		(b[0] => z[26]) = 0;
		(b[1] => z[26]) = 0;
		(b[2] => z[26]) = 0;
		(b[3] => z[26]) = 0;
		(b[4] => z[26]) = 0;
		(b[5] => z[26]) = 0;
		(b[6] => z[26]) = 0;
		(b[7] => z[26]) = 0;
		(b[8] => z[26]) = 0;
		(b[9] => z[26]) = 0;
		(b[10] => z[26]) = 0;
		(b[11] => z[26]) = 0;
		(b[12] => z[26]) = 0;
		(b[13] => z[26]) = 0;
		(b[14] => z[26]) = 0;
		(b[15] => z[26]) = 0;
		(b[16] => z[26]) = 0;
		(b[17] => z[26]) = 0;
		(a[0] => z[27]) = 0;
		(a[1] => z[27]) = 0;
		(a[2] => z[27]) = 0;
		(a[3] => z[27]) = 0;
		(a[4] => z[27]) = 0;
		(a[5] => z[27]) = 0;
		(a[6] => z[27]) = 0;
		(a[7] => z[27]) = 0;
		(a[8] => z[27]) = 0;
		(a[9] => z[27]) = 0;
		(a[10] => z[27]) = 0;
		(a[11] => z[27]) = 0;
		(a[12] => z[27]) = 0;
		(a[13] => z[27]) = 0;
		(a[14] => z[27]) = 0;
		(a[15] => z[27]) = 0;
		(a[16] => z[27]) = 0;
		(a[17] => z[27]) = 0;
		(a[18] => z[27]) = 0;
		(a[19] => z[27]) = 0;
		(b[0] => z[27]) = 0;
		(b[1] => z[27]) = 0;
		(b[2] => z[27]) = 0;
		(b[3] => z[27]) = 0;
		(b[4] => z[27]) = 0;
		(b[5] => z[27]) = 0;
		(b[6] => z[27]) = 0;
		(b[7] => z[27]) = 0;
		(b[8] => z[27]) = 0;
		(b[9] => z[27]) = 0;
		(b[10] => z[27]) = 0;
		(b[11] => z[27]) = 0;
		(b[12] => z[27]) = 0;
		(b[13] => z[27]) = 0;
		(b[14] => z[27]) = 0;
		(b[15] => z[27]) = 0;
		(b[16] => z[27]) = 0;
		(b[17] => z[27]) = 0;
		(a[0] => z[28]) = 0;
		(a[1] => z[28]) = 0;
		(a[2] => z[28]) = 0;
		(a[3] => z[28]) = 0;
		(a[4] => z[28]) = 0;
		(a[5] => z[28]) = 0;
		(a[6] => z[28]) = 0;
		(a[7] => z[28]) = 0;
		(a[8] => z[28]) = 0;
		(a[9] => z[28]) = 0;
		(a[10] => z[28]) = 0;
		(a[11] => z[28]) = 0;
		(a[12] => z[28]) = 0;
		(a[13] => z[28]) = 0;
		(a[14] => z[28]) = 0;
		(a[15] => z[28]) = 0;
		(a[16] => z[28]) = 0;
		(a[17] => z[28]) = 0;
		(a[18] => z[28]) = 0;
		(a[19] => z[28]) = 0;
		(b[0] => z[28]) = 0;
		(b[1] => z[28]) = 0;
		(b[2] => z[28]) = 0;
		(b[3] => z[28]) = 0;
		(b[4] => z[28]) = 0;
		(b[5] => z[28]) = 0;
		(b[6] => z[28]) = 0;
		(b[7] => z[28]) = 0;
		(b[8] => z[28]) = 0;
		(b[9] => z[28]) = 0;
		(b[10] => z[28]) = 0;
		(b[11] => z[28]) = 0;
		(b[12] => z[28]) = 0;
		(b[13] => z[28]) = 0;
		(b[14] => z[28]) = 0;
		(b[15] => z[28]) = 0;
		(b[16] => z[28]) = 0;
		(b[17] => z[28]) = 0;
		(a[0] => z[29]) = 0;
		(a[1] => z[29]) = 0;
		(a[2] => z[29]) = 0;
		(a[3] => z[29]) = 0;
		(a[4] => z[29]) = 0;
		(a[5] => z[29]) = 0;
		(a[6] => z[29]) = 0;
		(a[7] => z[29]) = 0;
		(a[8] => z[29]) = 0;
		(a[9] => z[29]) = 0;
		(a[10] => z[29]) = 0;
		(a[11] => z[29]) = 0;
		(a[12] => z[29]) = 0;
		(a[13] => z[29]) = 0;
		(a[14] => z[29]) = 0;
		(a[15] => z[29]) = 0;
		(a[16] => z[29]) = 0;
		(a[17] => z[29]) = 0;
		(a[18] => z[29]) = 0;
		(a[19] => z[29]) = 0;
		(b[0] => z[29]) = 0;
		(b[1] => z[29]) = 0;
		(b[2] => z[29]) = 0;
		(b[3] => z[29]) = 0;
		(b[4] => z[29]) = 0;
		(b[5] => z[29]) = 0;
		(b[6] => z[29]) = 0;
		(b[7] => z[29]) = 0;
		(b[8] => z[29]) = 0;
		(b[9] => z[29]) = 0;
		(b[10] => z[29]) = 0;
		(b[11] => z[29]) = 0;
		(b[12] => z[29]) = 0;
		(b[13] => z[29]) = 0;
		(b[14] => z[29]) = 0;
		(b[15] => z[29]) = 0;
		(b[16] => z[29]) = 0;
		(b[17] => z[29]) = 0;
		(a[0] => z[30]) = 0;
		(a[1] => z[30]) = 0;
		(a[2] => z[30]) = 0;
		(a[3] => z[30]) = 0;
		(a[4] => z[30]) = 0;
		(a[5] => z[30]) = 0;
		(a[6] => z[30]) = 0;
		(a[7] => z[30]) = 0;
		(a[8] => z[30]) = 0;
		(a[9] => z[30]) = 0;
		(a[10] => z[30]) = 0;
		(a[11] => z[30]) = 0;
		(a[12] => z[30]) = 0;
		(a[13] => z[30]) = 0;
		(a[14] => z[30]) = 0;
		(a[15] => z[30]) = 0;
		(a[16] => z[30]) = 0;
		(a[17] => z[30]) = 0;
		(a[18] => z[30]) = 0;
		(a[19] => z[30]) = 0;
		(b[0] => z[30]) = 0;
		(b[1] => z[30]) = 0;
		(b[2] => z[30]) = 0;
		(b[3] => z[30]) = 0;
		(b[4] => z[30]) = 0;
		(b[5] => z[30]) = 0;
		(b[6] => z[30]) = 0;
		(b[7] => z[30]) = 0;
		(b[8] => z[30]) = 0;
		(b[9] => z[30]) = 0;
		(b[10] => z[30]) = 0;
		(b[11] => z[30]) = 0;
		(b[12] => z[30]) = 0;
		(b[13] => z[30]) = 0;
		(b[14] => z[30]) = 0;
		(b[15] => z[30]) = 0;
		(b[16] => z[30]) = 0;
		(b[17] => z[30]) = 0;
		(a[0] => z[31]) = 0;
		(a[1] => z[31]) = 0;
		(a[2] => z[31]) = 0;
		(a[3] => z[31]) = 0;
		(a[4] => z[31]) = 0;
		(a[5] => z[31]) = 0;
		(a[6] => z[31]) = 0;
		(a[7] => z[31]) = 0;
		(a[8] => z[31]) = 0;
		(a[9] => z[31]) = 0;
		(a[10] => z[31]) = 0;
		(a[11] => z[31]) = 0;
		(a[12] => z[31]) = 0;
		(a[13] => z[31]) = 0;
		(a[14] => z[31]) = 0;
		(a[15] => z[31]) = 0;
		(a[16] => z[31]) = 0;
		(a[17] => z[31]) = 0;
		(a[18] => z[31]) = 0;
		(a[19] => z[31]) = 0;
		(b[0] => z[31]) = 0;
		(b[1] => z[31]) = 0;
		(b[2] => z[31]) = 0;
		(b[3] => z[31]) = 0;
		(b[4] => z[31]) = 0;
		(b[5] => z[31]) = 0;
		(b[6] => z[31]) = 0;
		(b[7] => z[31]) = 0;
		(b[8] => z[31]) = 0;
		(b[9] => z[31]) = 0;
		(b[10] => z[31]) = 0;
		(b[11] => z[31]) = 0;
		(b[12] => z[31]) = 0;
		(b[13] => z[31]) = 0;
		(b[14] => z[31]) = 0;
		(b[15] => z[31]) = 0;
		(b[16] => z[31]) = 0;
		(b[17] => z[31]) = 0;
		(a[0] => z[32]) = 0;
		(a[1] => z[32]) = 0;
		(a[2] => z[32]) = 0;
		(a[3] => z[32]) = 0;
		(a[4] => z[32]) = 0;
		(a[5] => z[32]) = 0;
		(a[6] => z[32]) = 0;
		(a[7] => z[32]) = 0;
		(a[8] => z[32]) = 0;
		(a[9] => z[32]) = 0;
		(a[10] => z[32]) = 0;
		(a[11] => z[32]) = 0;
		(a[12] => z[32]) = 0;
		(a[13] => z[32]) = 0;
		(a[14] => z[32]) = 0;
		(a[15] => z[32]) = 0;
		(a[16] => z[32]) = 0;
		(a[17] => z[32]) = 0;
		(a[18] => z[32]) = 0;
		(a[19] => z[32]) = 0;
		(b[0] => z[32]) = 0;
		(b[1] => z[32]) = 0;
		(b[2] => z[32]) = 0;
		(b[3] => z[32]) = 0;
		(b[4] => z[32]) = 0;
		(b[5] => z[32]) = 0;
		(b[6] => z[32]) = 0;
		(b[7] => z[32]) = 0;
		(b[8] => z[32]) = 0;
		(b[9] => z[32]) = 0;
		(b[10] => z[32]) = 0;
		(b[11] => z[32]) = 0;
		(b[12] => z[32]) = 0;
		(b[13] => z[32]) = 0;
		(b[14] => z[32]) = 0;
		(b[15] => z[32]) = 0;
		(b[16] => z[32]) = 0;
		(b[17] => z[32]) = 0;
		(a[0] => z[33]) = 0;
		(a[1] => z[33]) = 0;
		(a[2] => z[33]) = 0;
		(a[3] => z[33]) = 0;
		(a[4] => z[33]) = 0;
		(a[5] => z[33]) = 0;
		(a[6] => z[33]) = 0;
		(a[7] => z[33]) = 0;
		(a[8] => z[33]) = 0;
		(a[9] => z[33]) = 0;
		(a[10] => z[33]) = 0;
		(a[11] => z[33]) = 0;
		(a[12] => z[33]) = 0;
		(a[13] => z[33]) = 0;
		(a[14] => z[33]) = 0;
		(a[15] => z[33]) = 0;
		(a[16] => z[33]) = 0;
		(a[17] => z[33]) = 0;
		(a[18] => z[33]) = 0;
		(a[19] => z[33]) = 0;
		(b[0] => z[33]) = 0;
		(b[1] => z[33]) = 0;
		(b[2] => z[33]) = 0;
		(b[3] => z[33]) = 0;
		(b[4] => z[33]) = 0;
		(b[5] => z[33]) = 0;
		(b[6] => z[33]) = 0;
		(b[7] => z[33]) = 0;
		(b[8] => z[33]) = 0;
		(b[9] => z[33]) = 0;
		(b[10] => z[33]) = 0;
		(b[11] => z[33]) = 0;
		(b[12] => z[33]) = 0;
		(b[13] => z[33]) = 0;
		(b[14] => z[33]) = 0;
		(b[15] => z[33]) = 0;
		(b[16] => z[33]) = 0;
		(b[17] => z[33]) = 0;
		(a[0] => z[34]) = 0;
		(a[1] => z[34]) = 0;
		(a[2] => z[34]) = 0;
		(a[3] => z[34]) = 0;
		(a[4] => z[34]) = 0;
		(a[5] => z[34]) = 0;
		(a[6] => z[34]) = 0;
		(a[7] => z[34]) = 0;
		(a[8] => z[34]) = 0;
		(a[9] => z[34]) = 0;
		(a[10] => z[34]) = 0;
		(a[11] => z[34]) = 0;
		(a[12] => z[34]) = 0;
		(a[13] => z[34]) = 0;
		(a[14] => z[34]) = 0;
		(a[15] => z[34]) = 0;
		(a[16] => z[34]) = 0;
		(a[17] => z[34]) = 0;
		(a[18] => z[34]) = 0;
		(a[19] => z[34]) = 0;
		(b[0] => z[34]) = 0;
		(b[1] => z[34]) = 0;
		(b[2] => z[34]) = 0;
		(b[3] => z[34]) = 0;
		(b[4] => z[34]) = 0;
		(b[5] => z[34]) = 0;
		(b[6] => z[34]) = 0;
		(b[7] => z[34]) = 0;
		(b[8] => z[34]) = 0;
		(b[9] => z[34]) = 0;
		(b[10] => z[34]) = 0;
		(b[11] => z[34]) = 0;
		(b[12] => z[34]) = 0;
		(b[13] => z[34]) = 0;
		(b[14] => z[34]) = 0;
		(b[15] => z[34]) = 0;
		(b[16] => z[34]) = 0;
		(b[17] => z[34]) = 0;
		(a[0] => z[35]) = 0;
		(a[1] => z[35]) = 0;
		(a[2] => z[35]) = 0;
		(a[3] => z[35]) = 0;
		(a[4] => z[35]) = 0;
		(a[5] => z[35]) = 0;
		(a[6] => z[35]) = 0;
		(a[7] => z[35]) = 0;
		(a[8] => z[35]) = 0;
		(a[9] => z[35]) = 0;
		(a[10] => z[35]) = 0;
		(a[11] => z[35]) = 0;
		(a[12] => z[35]) = 0;
		(a[13] => z[35]) = 0;
		(a[14] => z[35]) = 0;
		(a[15] => z[35]) = 0;
		(a[16] => z[35]) = 0;
		(a[17] => z[35]) = 0;
		(a[18] => z[35]) = 0;
		(a[19] => z[35]) = 0;
		(b[0] => z[35]) = 0;
		(b[1] => z[35]) = 0;
		(b[2] => z[35]) = 0;
		(b[3] => z[35]) = 0;
		(b[4] => z[35]) = 0;
		(b[5] => z[35]) = 0;
		(b[6] => z[35]) = 0;
		(b[7] => z[35]) = 0;
		(b[8] => z[35]) = 0;
		(b[9] => z[35]) = 0;
		(b[10] => z[35]) = 0;
		(b[11] => z[35]) = 0;
		(b[12] => z[35]) = 0;
		(b[13] => z[35]) = 0;
		(b[14] => z[35]) = 0;
		(b[15] => z[35]) = 0;
		(b[16] => z[35]) = 0;
		(b[17] => z[35]) = 0;
		(a[0] => z[36]) = 0;
		(a[1] => z[36]) = 0;
		(a[2] => z[36]) = 0;
		(a[3] => z[36]) = 0;
		(a[4] => z[36]) = 0;
		(a[5] => z[36]) = 0;
		(a[6] => z[36]) = 0;
		(a[7] => z[36]) = 0;
		(a[8] => z[36]) = 0;
		(a[9] => z[36]) = 0;
		(a[10] => z[36]) = 0;
		(a[11] => z[36]) = 0;
		(a[12] => z[36]) = 0;
		(a[13] => z[36]) = 0;
		(a[14] => z[36]) = 0;
		(a[15] => z[36]) = 0;
		(a[16] => z[36]) = 0;
		(a[17] => z[36]) = 0;
		(a[18] => z[36]) = 0;
		(a[19] => z[36]) = 0;
		(b[0] => z[36]) = 0;
		(b[1] => z[36]) = 0;
		(b[2] => z[36]) = 0;
		(b[3] => z[36]) = 0;
		(b[4] => z[36]) = 0;
		(b[5] => z[36]) = 0;
		(b[6] => z[36]) = 0;
		(b[7] => z[36]) = 0;
		(b[8] => z[36]) = 0;
		(b[9] => z[36]) = 0;
		(b[10] => z[36]) = 0;
		(b[11] => z[36]) = 0;
		(b[12] => z[36]) = 0;
		(b[13] => z[36]) = 0;
		(b[14] => z[36]) = 0;
		(b[15] => z[36]) = 0;
		(b[16] => z[36]) = 0;
		(b[17] => z[36]) = 0;
		(a[0] => z[37]) = 0;
		(a[1] => z[37]) = 0;
		(a[2] => z[37]) = 0;
		(a[3] => z[37]) = 0;
		(a[4] => z[37]) = 0;
		(a[5] => z[37]) = 0;
		(a[6] => z[37]) = 0;
		(a[7] => z[37]) = 0;
		(a[8] => z[37]) = 0;
		(a[9] => z[37]) = 0;
		(a[10] => z[37]) = 0;
		(a[11] => z[37]) = 0;
		(a[12] => z[37]) = 0;
		(a[13] => z[37]) = 0;
		(a[14] => z[37]) = 0;
		(a[15] => z[37]) = 0;
		(a[16] => z[37]) = 0;
		(a[17] => z[37]) = 0;
		(a[18] => z[37]) = 0;
		(a[19] => z[37]) = 0;
		(b[0] => z[37]) = 0;
		(b[1] => z[37]) = 0;
		(b[2] => z[37]) = 0;
		(b[3] => z[37]) = 0;
		(b[4] => z[37]) = 0;
		(b[5] => z[37]) = 0;
		(b[6] => z[37]) = 0;
		(b[7] => z[37]) = 0;
		(b[8] => z[37]) = 0;
		(b[9] => z[37]) = 0;
		(b[10] => z[37]) = 0;
		(b[11] => z[37]) = 0;
		(b[12] => z[37]) = 0;
		(b[13] => z[37]) = 0;
		(b[14] => z[37]) = 0;
		(b[15] => z[37]) = 0;
		(b[16] => z[37]) = 0;
		(b[17] => z[37]) = 0;
		(subtract => z[0]) = 0;
		(subtract => z[1]) = 0;
		(subtract => z[2]) = 0;
		(subtract => z[3]) = 0;
		(subtract => z[4]) = 0;
		(subtract => z[5]) = 0;
		(subtract => z[6]) = 0;
		(subtract => z[7]) = 0;
		(subtract => z[8]) = 0;
		(subtract => z[9]) = 0;
		(subtract => z[10]) = 0;
		(subtract => z[11]) = 0;
		(subtract => z[12]) = 0;
		(subtract => z[13]) = 0;
		(subtract => z[14]) = 0;
		(subtract => z[15]) = 0;
		(subtract => z[16]) = 0;
		(subtract => z[17]) = 0;
		(subtract => z[18]) = 0;
		(subtract => z[19]) = 0;
		(subtract => z[20]) = 0;
		(subtract => z[21]) = 0;
		(subtract => z[22]) = 0;
		(subtract => z[23]) = 0;
		(subtract => z[24]) = 0;
		(subtract => z[25]) = 0;
		(subtract => z[26]) = 0;
		(subtract => z[27]) = 0;
		(subtract => z[28]) = 0;
		(subtract => z[29]) = 0;
		(subtract => z[30]) = 0;
		(subtract => z[31]) = 0;
		(subtract => z[32]) = 0;
		(subtract => z[33]) = 0;
		(subtract => z[34]) = 0;
		(subtract => z[35]) = 0;
		(subtract => z[36]) = 0;
		(subtract => z[37]) = 0;
		(acc_fir[0] => z[0]) = 0;
		(acc_fir[1] => z[0]) = 0;
		(acc_fir[2] => z[0]) = 0;
		(acc_fir[3] => z[0]) = 0;
		(acc_fir[4] => z[0]) = 0;
		(acc_fir[5] => z[0]) = 0;
		(acc_fir[0] => z[1]) = 0;
		(acc_fir[1] => z[1]) = 0;
		(acc_fir[2] => z[1]) = 0;
		(acc_fir[3] => z[1]) = 0;
		(acc_fir[4] => z[1]) = 0;
		(acc_fir[5] => z[1]) = 0;
		(acc_fir[0] => z[2]) = 0;
		(acc_fir[1] => z[2]) = 0;
		(acc_fir[2] => z[2]) = 0;
		(acc_fir[3] => z[2]) = 0;
		(acc_fir[4] => z[2]) = 0;
		(acc_fir[5] => z[2]) = 0;
		(acc_fir[0] => z[3]) = 0;
		(acc_fir[1] => z[3]) = 0;
		(acc_fir[2] => z[3]) = 0;
		(acc_fir[3] => z[3]) = 0;
		(acc_fir[4] => z[3]) = 0;
		(acc_fir[5] => z[3]) = 0;
		(acc_fir[0] => z[4]) = 0;
		(acc_fir[1] => z[4]) = 0;
		(acc_fir[2] => z[4]) = 0;
		(acc_fir[3] => z[4]) = 0;
		(acc_fir[4] => z[4]) = 0;
		(acc_fir[5] => z[4]) = 0;
		(acc_fir[0] => z[5]) = 0;
		(acc_fir[1] => z[5]) = 0;
		(acc_fir[2] => z[5]) = 0;
		(acc_fir[3] => z[5]) = 0;
		(acc_fir[4] => z[5]) = 0;
		(acc_fir[5] => z[5]) = 0;
		(acc_fir[0] => z[6]) = 0;
		(acc_fir[1] => z[6]) = 0;
		(acc_fir[2] => z[6]) = 0;
		(acc_fir[3] => z[6]) = 0;
		(acc_fir[4] => z[6]) = 0;
		(acc_fir[5] => z[6]) = 0;
		(acc_fir[0] => z[7]) = 0;
		(acc_fir[1] => z[7]) = 0;
		(acc_fir[2] => z[7]) = 0;
		(acc_fir[3] => z[7]) = 0;
		(acc_fir[4] => z[7]) = 0;
		(acc_fir[5] => z[7]) = 0;
		(acc_fir[0] => z[8]) = 0;
		(acc_fir[1] => z[8]) = 0;
		(acc_fir[2] => z[8]) = 0;
		(acc_fir[3] => z[8]) = 0;
		(acc_fir[4] => z[8]) = 0;
		(acc_fir[5] => z[8]) = 0;
		(acc_fir[0] => z[9]) = 0;
		(acc_fir[1] => z[9]) = 0;
		(acc_fir[2] => z[9]) = 0;
		(acc_fir[3] => z[9]) = 0;
		(acc_fir[4] => z[9]) = 0;
		(acc_fir[5] => z[9]) = 0;
		(acc_fir[0] => z[10]) = 0;
		(acc_fir[1] => z[10]) = 0;
		(acc_fir[2] => z[10]) = 0;
		(acc_fir[3] => z[10]) = 0;
		(acc_fir[4] => z[10]) = 0;
		(acc_fir[5] => z[10]) = 0;
		(acc_fir[0] => z[11]) = 0;
		(acc_fir[1] => z[11]) = 0;
		(acc_fir[2] => z[11]) = 0;
		(acc_fir[3] => z[11]) = 0;
		(acc_fir[4] => z[11]) = 0;
		(acc_fir[5] => z[11]) = 0;
		(acc_fir[0] => z[12]) = 0;
		(acc_fir[1] => z[12]) = 0;
		(acc_fir[2] => z[12]) = 0;
		(acc_fir[3] => z[12]) = 0;
		(acc_fir[4] => z[12]) = 0;
		(acc_fir[5] => z[12]) = 0;
		(acc_fir[0] => z[13]) = 0;
		(acc_fir[1] => z[13]) = 0;
		(acc_fir[2] => z[13]) = 0;
		(acc_fir[3] => z[13]) = 0;
		(acc_fir[4] => z[13]) = 0;
		(acc_fir[5] => z[13]) = 0;
		(acc_fir[0] => z[14]) = 0;
		(acc_fir[1] => z[14]) = 0;
		(acc_fir[2] => z[14]) = 0;
		(acc_fir[3] => z[14]) = 0;
		(acc_fir[4] => z[14]) = 0;
		(acc_fir[5] => z[14]) = 0;
		(acc_fir[0] => z[15]) = 0;
		(acc_fir[1] => z[15]) = 0;
		(acc_fir[2] => z[15]) = 0;
		(acc_fir[3] => z[15]) = 0;
		(acc_fir[4] => z[15]) = 0;
		(acc_fir[5] => z[15]) = 0;
		(acc_fir[0] => z[16]) = 0;
		(acc_fir[1] => z[16]) = 0;
		(acc_fir[2] => z[16]) = 0;
		(acc_fir[3] => z[16]) = 0;
		(acc_fir[4] => z[16]) = 0;
		(acc_fir[5] => z[16]) = 0;
		(acc_fir[0] => z[17]) = 0;
		(acc_fir[1] => z[17]) = 0;
		(acc_fir[2] => z[17]) = 0;
		(acc_fir[3] => z[17]) = 0;
		(acc_fir[4] => z[17]) = 0;
		(acc_fir[5] => z[17]) = 0;
		(acc_fir[0] => z[18]) = 0;
		(acc_fir[1] => z[18]) = 0;
		(acc_fir[2] => z[18]) = 0;
		(acc_fir[3] => z[18]) = 0;
		(acc_fir[4] => z[18]) = 0;
		(acc_fir[5] => z[18]) = 0;
		(acc_fir[0] => z[19]) = 0;
		(acc_fir[1] => z[19]) = 0;
		(acc_fir[2] => z[19]) = 0;
		(acc_fir[3] => z[19]) = 0;
		(acc_fir[4] => z[19]) = 0;
		(acc_fir[5] => z[19]) = 0;
		(acc_fir[0] => z[20]) = 0;
		(acc_fir[1] => z[20]) = 0;
		(acc_fir[2] => z[20]) = 0;
		(acc_fir[3] => z[20]) = 0;
		(acc_fir[4] => z[20]) = 0;
		(acc_fir[5] => z[20]) = 0;
		(acc_fir[0] => z[21]) = 0;
		(acc_fir[1] => z[21]) = 0;
		(acc_fir[2] => z[21]) = 0;
		(acc_fir[3] => z[21]) = 0;
		(acc_fir[4] => z[21]) = 0;
		(acc_fir[5] => z[21]) = 0;
		(acc_fir[0] => z[22]) = 0;
		(acc_fir[1] => z[22]) = 0;
		(acc_fir[2] => z[22]) = 0;
		(acc_fir[3] => z[22]) = 0;
		(acc_fir[4] => z[22]) = 0;
		(acc_fir[5] => z[22]) = 0;
		(acc_fir[0] => z[23]) = 0;
		(acc_fir[1] => z[23]) = 0;
		(acc_fir[2] => z[23]) = 0;
		(acc_fir[3] => z[23]) = 0;
		(acc_fir[4] => z[23]) = 0;
		(acc_fir[5] => z[23]) = 0;
		(acc_fir[0] => z[24]) = 0;
		(acc_fir[1] => z[24]) = 0;
		(acc_fir[2] => z[24]) = 0;
		(acc_fir[3] => z[24]) = 0;
		(acc_fir[4] => z[24]) = 0;
		(acc_fir[5] => z[24]) = 0;
		(acc_fir[0] => z[25]) = 0;
		(acc_fir[1] => z[25]) = 0;
		(acc_fir[2] => z[25]) = 0;
		(acc_fir[3] => z[25]) = 0;
		(acc_fir[4] => z[25]) = 0;
		(acc_fir[5] => z[25]) = 0;
		(acc_fir[0] => z[26]) = 0;
		(acc_fir[1] => z[26]) = 0;
		(acc_fir[2] => z[26]) = 0;
		(acc_fir[3] => z[26]) = 0;
		(acc_fir[4] => z[26]) = 0;
		(acc_fir[5] => z[26]) = 0;
		(acc_fir[0] => z[27]) = 0;
		(acc_fir[1] => z[27]) = 0;
		(acc_fir[2] => z[27]) = 0;
		(acc_fir[3] => z[27]) = 0;
		(acc_fir[4] => z[27]) = 0;
		(acc_fir[5] => z[27]) = 0;
		(acc_fir[0] => z[28]) = 0;
		(acc_fir[1] => z[28]) = 0;
		(acc_fir[2] => z[28]) = 0;
		(acc_fir[3] => z[28]) = 0;
		(acc_fir[4] => z[28]) = 0;
		(acc_fir[5] => z[28]) = 0;
		(acc_fir[0] => z[29]) = 0;
		(acc_fir[1] => z[29]) = 0;
		(acc_fir[2] => z[29]) = 0;
		(acc_fir[3] => z[29]) = 0;
		(acc_fir[4] => z[29]) = 0;
		(acc_fir[5] => z[29]) = 0;
		(acc_fir[0] => z[30]) = 0;
		(acc_fir[1] => z[30]) = 0;
		(acc_fir[2] => z[30]) = 0;
		(acc_fir[3] => z[30]) = 0;
		(acc_fir[4] => z[30]) = 0;
		(acc_fir[5] => z[30]) = 0;
		(acc_fir[0] => z[31]) = 0;
		(acc_fir[1] => z[31]) = 0;
		(acc_fir[2] => z[31]) = 0;
		(acc_fir[3] => z[31]) = 0;
		(acc_fir[4] => z[31]) = 0;
		(acc_fir[5] => z[31]) = 0;
		(acc_fir[0] => z[32]) = 0;
		(acc_fir[1] => z[32]) = 0;
		(acc_fir[2] => z[32]) = 0;
		(acc_fir[3] => z[32]) = 0;
		(acc_fir[4] => z[32]) = 0;
		(acc_fir[5] => z[32]) = 0;
		(acc_fir[0] => z[33]) = 0;
		(acc_fir[1] => z[33]) = 0;
		(acc_fir[2] => z[33]) = 0;
		(acc_fir[3] => z[33]) = 0;
		(acc_fir[4] => z[33]) = 0;
		(acc_fir[5] => z[33]) = 0;
		(acc_fir[0] => z[34]) = 0;
		(acc_fir[1] => z[34]) = 0;
		(acc_fir[2] => z[34]) = 0;
		(acc_fir[3] => z[34]) = 0;
		(acc_fir[4] => z[34]) = 0;
		(acc_fir[5] => z[34]) = 0;
		(acc_fir[0] => z[35]) = 0;
		(acc_fir[1] => z[35]) = 0;
		(acc_fir[2] => z[35]) = 0;
		(acc_fir[3] => z[35]) = 0;
		(acc_fir[4] => z[35]) = 0;
		(acc_fir[5] => z[35]) = 0;
		(acc_fir[0] => z[36]) = 0;
		(acc_fir[1] => z[36]) = 0;
		(acc_fir[2] => z[36]) = 0;
		(acc_fir[3] => z[36]) = 0;
		(acc_fir[4] => z[36]) = 0;
		(acc_fir[5] => z[36]) = 0;
		(acc_fir[0] => z[37]) = 0;
		(acc_fir[1] => z[37]) = 0;
		(acc_fir[2] => z[37]) = 0;
		(acc_fir[3] => z[37]) = 0;
		(acc_fir[4] => z[37]) = 0;
		(acc_fir[5] => z[37]) = 0;
	endspecify
\`endif

endmodule

module QL_DSP2_MULTADD_REGIN (
	input  wire [19:0] a,
	input  wire [17:0] b,
	output wire [37:0] z,

	(* clkbuf_sink *)
	input  wire        clk,
	input  wire        reset,

	input  wire [ 2:0] feedback,
	input  wire [ 5:0] acc_fir,
	input  wire        load_acc,
	input  wire        unsigned_a,
	input  wire        unsigned_b,

	input  wire        f_mode,
	input  wire [ 2:0] output_select,
	input  wire        saturate_enable,
	input  wire [ 5:0] shift_right,
	input  wire        round,
	input  wire        subtract,
	input  wire        register_inputs
);

	parameter [79:0] MODE_BITS = 80'd0;

	localparam [19:0] COEFF_0 = MODE_BITS[19:0];
	localparam [19:0] COEFF_1 = MODE_BITS[39:20];
	localparam [19:0] COEFF_2 = MODE_BITS[59:40];
	localparam [19:0] COEFF_3 = MODE_BITS[79:60];

	QL_DSP2 #(
		.MODE_BITS({COEFF_3, COEFF_2, COEFF_1, COEFF_0})
	) dsp (
		.a(a),
		.b(b),
		.dly_b(),
		.z(z),

		.f_mode(f_mode),

		.feedback(feedback),
		.acc_fir(acc_fir),
		.load_acc(load_acc),

		.unsigned_a(unsigned_a),
		.unsigned_b(unsigned_b),

		.clk(clk),
		.reset(reset),

		.output_select(output_select),      // unregistered output: ACCin (2, 3)
		.saturate_enable(saturate_enable),
		.shift_right(shift_right),
		.round(round),
		.subtract(subtract),
		.register_inputs(register_inputs)   // registered inputs
	);

\`ifdef SDF_SIM
	specify
		(posedge clk => (z +: a)) = 0;
		(posedge clk => (z +: b)) = 0;
		$setuphold(posedge clk, a, 0, 0);
		$setuphold(posedge clk, b, 0, 0);
		$setuphold(posedge clk, feedback, 0, 0);
		$setuphold(posedge clk, load_acc, 0, 0);
		$setuphold(posedge clk, subtract, 0, 0);
		$setuphold(posedge clk, acc_fir, 0, 0);
	endspecify
\`endif

endmodule

module QL_DSP2_MULTADD_REGOUT (
	input  wire [19:0] a,
	input  wire [17:0] b,
	output wire [37:0] z,

	(* clkbuf_sink *)
	input  wire        clk,
	input  wire        reset,

	input  wire [ 2:0] feedback,
	input  wire [ 5:0] acc_fir,
	input  wire        load_acc,
	input  wire        unsigned_a,
	input  wire        unsigned_b,

	input  wire        f_mode,
	input  wire [ 2:0] output_select,
	input  wire        saturate_enable,
	input  wire [ 5:0] shift_right,
	input  wire        round,
	input  wire        subtract,
	input  wire        register_inputs
);

	parameter [79:0] MODE_BITS = 80'd0;

	localparam [19:0] COEFF_0 = MODE_BITS[19:0];
	localparam [19:0] COEFF_1 = MODE_BITS[39:20];
	localparam [19:0] COEFF_2 = MODE_BITS[59:40];
	localparam [19:0] COEFF_3 = MODE_BITS[79:60];

	QL_DSP2 #(
		.MODE_BITS({COEFF_3, COEFF_2, COEFF_1, COEFF_0})
	) dsp (
		.a(a),
		.b(b),
		.dly_b(),
		.z(z),

		.f_mode(f_mode),

		.feedback(feedback),
		.acc_fir(acc_fir),
		.load_acc(load_acc),

		.unsigned_a(unsigned_a),
		.unsigned_b(unsigned_b),

		.clk(clk),
		.reset(reset),

		.output_select(output_select),      // registered output: ACCin (6, 7)
		.saturate_enable(saturate_enable),
		.shift_right(shift_right),
		.round(round),
		.subtract(subtract),
		.register_inputs(register_inputs)   // unregistered inputs
	);

\`ifdef SDF_SIM
	specify
		(posedge clk => (z +: a)) = 0;
		(posedge clk => (z +: b)) = 0;
		$setuphold(posedge clk, a, 0, 0);
		$setuphold(posedge clk, b, 0, 0);
		$setuphold(posedge clk, feedback, 0, 0);
		$setuphold(posedge clk, load_acc, 0, 0);
		$setuphold(posedge clk, subtract, 0, 0);
		$setuphold(posedge clk, acc_fir, 0, 0);
	endspecify
\`endif

endmodule

module QL_DSP2_MULTADD_REGIN_REGOUT (
	input  wire [19:0] a,
	input  wire [17:0] b,
	output wire [37:0] z,

	(* clkbuf_sink *)
	input  wire        clk,
	input  wire        reset,

	input  wire [ 2:0] feedback,
	input  wire [ 5:0] acc_fir,
	input  wire        load_acc,
	input  wire        unsigned_a,
	input  wire        unsigned_b,

	input  wire        f_mode,
	input  wire [ 2:0] output_select,
	input  wire        saturate_enable,
	input  wire [ 5:0] shift_right,
	input  wire        round,
	input  wire        subtract,
	input  wire        register_inputs
);

	parameter [79:0] MODE_BITS = 80'd0;

	localparam [19:0] COEFF_0 = MODE_BITS[19:0];
	localparam [19:0] COEFF_1 = MODE_BITS[39:20];
	localparam [19:0] COEFF_2 = MODE_BITS[59:40];
	localparam [19:0] COEFF_3 = MODE_BITS[79:60];

	QL_DSP2 #(
		.MODE_BITS({COEFF_3, COEFF_2, COEFF_1, COEFF_0})
	) dsp (
		.a(a),
		.b(b),
		.dly_b(),
		.z(z),

		.f_mode(f_mode),

		.feedback(feedback),
		.acc_fir(acc_fir),
		.load_acc(load_acc),

		.unsigned_a(unsigned_a),
		.unsigned_b(unsigned_b),

		.clk(clk),
		.reset(reset),

		.output_select(output_select),      // registered output: ACCin (6, 7)
		.saturate_enable(saturate_enable),
		.shift_right(shift_right),
		.round(round),
		.subtract(subtract),
		.register_inputs(register_inputs)   // registered inputs
	);

\`ifdef SDF_SIM
	specify
		(posedge clk => (z +: a)) = 0;
		(posedge clk => (z +: b)) = 0;
		$setuphold(posedge clk, a, 0, 0);
		$setuphold(posedge clk, b, 0, 0);
		$setuphold(posedge clk, feedback, 0, 0);
		$setuphold(posedge clk, load_acc, 0, 0);
		$setuphold(posedge clk, subtract, 0, 0);
		$setuphold(posedge clk, acc_fir, 0, 0);
	endspecify
\`endif

endmodule

module QL_DSP2_MULTACC (
	input  wire [19:0] a,
	input  wire [17:0] b,
	output wire [37:0] z,

	(* clkbuf_sink *)
	input  wire        clk,
	input  wire        reset,

	input  wire        load_acc,
	input  wire [ 2:0] feedback,
	input  wire        unsigned_a,
	input  wire        unsigned_b,

	input  wire        f_mode,
	input  wire [ 2:0] output_select,
	input  wire        saturate_enable,
	input  wire [ 5:0] shift_right,
	input  wire        round,
	input  wire        subtract,
	input  wire        register_inputs
);

	parameter [79:0] MODE_BITS = 80'd0;

	localparam [19:0] COEFF_0 = MODE_BITS[19:0];
	localparam [19:0] COEFF_1 = MODE_BITS[39:20];
	localparam [19:0] COEFF_2 = MODE_BITS[59:40];
	localparam [19:0] COEFF_3 = MODE_BITS[79:60];

	QL_DSP2 #(
		.MODE_BITS({COEFF_3, COEFF_2, COEFF_1, COEFF_0})
	) dsp (
		.a(a),
		.b(b),
		.acc_fir(6'b0),
		.z(z),
		.dly_b(),

		.f_mode(f_mode),

		.feedback(feedback),
		.load_acc(load_acc),

		.unsigned_a(unsigned_a),
		.unsigned_b(unsigned_b),

		.clk(clk),
		.reset(reset),

		.output_select(output_select),      // unregistered output: ACCout (1)
		.saturate_enable(saturate_enable),
		.shift_right(shift_right),
		.round(round),
		.subtract(subtract),
		.register_inputs(register_inputs)   // unregistered inputs
	);

\`ifdef SDF_SIM
	specify
		(posedge clk => (z +: a)) = 0;
		(posedge clk => (z +: b)) = 0;
		$setuphold(posedge clk, a, 0, 0);
		$setuphold(posedge clk, b, 0, 0);
		$setuphold(posedge clk, feedback, 0, 0);
		$setuphold(posedge clk, load_acc, 0, 0);
		$setuphold(posedge clk, subtract, 0, 0);
	endspecify
\`endif

endmodule

module QL_DSP2_MULTACC_REGIN (
	input  wire [19:0] a,
	input  wire [17:0] b,
	output wire [37:0] z,

	(* clkbuf_sink *)
	input  wire        clk,
	input  wire        reset,

	input  wire [ 2:0] feedback,
	input  wire        load_acc,
	input  wire        unsigned_a,
	input  wire        unsigned_b,

	input  wire        f_mode,
	input  wire [ 2:0] output_select,
	input  wire        saturate_enable,
	input  wire [ 5:0] shift_right,
	input  wire        round,
	input  wire        subtract,
	input  wire        register_inputs
);

	parameter [79:0] MODE_BITS = 80'd0;

	localparam [19:0] COEFF_0 = MODE_BITS[19:0];
	localparam [19:0] COEFF_1 = MODE_BITS[39:20];
	localparam [19:0] COEFF_2 = MODE_BITS[59:40];
	localparam [19:0] COEFF_3 = MODE_BITS[79:60];

	QL_DSP2 #(
		.MODE_BITS({COEFF_3, COEFF_2, COEFF_1, COEFF_0})
	) dsp (
		.a(a),
		.b(b),
		.acc_fir(6'b0),
		.z(z),
		.dly_b(),

		.f_mode(f_mode),

		.feedback(feedback),
		.load_acc(load_acc),

		.unsigned_a(unsigned_a),
		.unsigned_b(unsigned_b),

		.clk(clk),
		.reset(reset),

		.output_select(output_select),      // unregistered output: ACCout (1)
		.saturate_enable(saturate_enable),
		.shift_right(shift_right),
		.round(round),
		.subtract(subtract),
		.register_inputs(register_inputs)   // registered inputs
	);

\`ifdef SDF_SIM
	specify
		(posedge clk => (z +: a)) = 0;
		(posedge clk => (z +: b)) = 0;
		$setuphold(posedge clk, a, 0, 0);
		$setuphold(posedge clk, b, 0, 0);
		$setuphold(posedge clk, feedback, 0, 0);
		$setuphold(posedge clk, load_acc, 0, 0);
		$setuphold(posedge clk, subtract, 0, 0);
	endspecify
\`endif

endmodule

module QL_DSP2_MULTACC_REGOUT (
	input  wire [19:0] a,
	input  wire [17:0] b,
	output wire [37:0] z,

	(* clkbuf_sink *)
	input  wire        clk,
	input  wire        reset,

	input  wire [ 2:0] feedback,
	input  wire        load_acc,
	input  wire        unsigned_a,
	input  wire        unsigned_b,

	input  wire        f_mode,
	input  wire [ 2:0] output_select,
	input  wire        saturate_enable,
	input  wire [ 5:0] shift_right,
	input  wire        round,
	input  wire        subtract,
	input  wire        register_inputs
);

	parameter [79:0] MODE_BITS = 80'd0;

	localparam [19:0] COEFF_0 = MODE_BITS[19:0];
	localparam [19:0] COEFF_1 = MODE_BITS[39:20];
	localparam [19:0] COEFF_2 = MODE_BITS[59:40];
	localparam [19:0] COEFF_3 = MODE_BITS[79:60];

	QL_DSP2 #(
		.MODE_BITS({COEFF_3, COEFF_2, COEFF_1, COEFF_0})
	) dsp (
		.a(a),
		.b(b),
		.acc_fir(6'b0),
		.z(z),
		.dly_b(),

		.f_mode(f_mode),

		.feedback(feedback),
		.load_acc(load_acc),

		.unsigned_a(unsigned_a),
		.unsigned_b(unsigned_b),

		.clk(clk),
		.reset(reset),

		.output_select(output_select),      // registered output: ACCout (5)
		.saturate_enable(saturate_enable),
		.shift_right(shift_right),
		.round(round),
		.subtract(subtract),
		.register_inputs(register_inputs)   // unregistered inputs
	);

\`ifdef SDF_SIM
	specify
		(posedge clk => (z +: a)) = 0;
		(posedge clk => (z +: b)) = 0;
		$setuphold(posedge clk, a, 0, 0);
		$setuphold(posedge clk, b, 0, 0);
		$setuphold(posedge clk, feedback, 0, 0);
		$setuphold(posedge clk, load_acc, 0, 0);
		$setuphold(posedge clk, subtract, 0, 0);
	endspecify
\`endif

endmodule

module QL_DSP2_MULTACC_REGIN_REGOUT (
	input  wire [19:0] a,
	input  wire [17:0] b,
	output wire [37:0] z,

	(* clkbuf_sink *)
	input  wire        clk,
	input  wire        reset,

	input  wire [ 2:0] feedback,
	input  wire        load_acc,
	input  wire        unsigned_a,
	input  wire        unsigned_b,

	input  wire        f_mode,
	input  wire [ 2:0] output_select,
	input  wire        saturate_enable,
	input  wire [ 5:0] shift_right,
	input  wire        round,
	input  wire        subtract,
	input  wire        register_inputs
);

	parameter [79:0] MODE_BITS = 80'd0;

	localparam [19:0] COEFF_0 = MODE_BITS[19:0];
	localparam [19:0] COEFF_1 = MODE_BITS[39:20];
	localparam [19:0] COEFF_2 = MODE_BITS[59:40];
	localparam [19:0] COEFF_3 = MODE_BITS[79:60];

	QL_DSP2 #(
		.MODE_BITS({COEFF_3, COEFF_2, COEFF_1, COEFF_0})
	) dsp (
		.a(a),
		.b(b),
		.acc_fir(6'b0),
		.z(z),
		.dly_b(),

		.f_mode(f_mode),

		.feedback(feedback),
		.load_acc(load_acc),

		.unsigned_a(unsigned_a),
		.unsigned_b(unsigned_b),

		.clk(clk),
		.reset(reset),

		.output_select(output_select),      // registered output: ACCout (5)
		.saturate_enable(saturate_enable),
		.shift_right(shift_right),
		.round(round),
		.subtract(subtract),
		.register_inputs(register_inputs)   // registered inputs
	);

\`ifdef SDF_SIM
	specify
		(posedge clk => (z +: a)) = 0;
		(posedge clk => (z +: b)) = 0;
		$setuphold(posedge clk, a, 0, 0);
		$setuphold(posedge clk, b, 0, 0);
		$setuphold(posedge clk, feedback, 0, 0);
		$setuphold(posedge clk, load_acc, 0, 0);
		$setuphold(posedge clk, subtract, 0, 0);
	endspecify
\`endif

endmodule

module dsp_t1_20x18x64_cfg_ports (
	input  wire [19:0] a_i,
	input  wire [17:0] b_i,
	input  wire [ 5:0] acc_fir_i,
	output wire [37:0] z_o,
	output wire [17:0] dly_b_o,

	(* clkbuf_sink *)
	input  wire        clock_i,
	input  wire        reset_i,

	input  wire [ 2:0] feedback_i,
	input  wire        load_acc_i,
	input  wire        unsigned_a_i,
	input  wire        unsigned_b_i,

	input  wire [ 2:0] output_select_i,
	input  wire        saturate_enable_i,
	input  wire [ 5:0] shift_right_i,
	input  wire        round_i,
	input  wire        subtract_i,
	input  wire        register_inputs_i
);

	parameter [19:0] COEFF_0 = 20'd0;
	parameter [19:0] COEFF_1 = 20'd0;
	parameter [19:0] COEFF_2 = 20'd0;
	parameter [19:0] COEFF_3 = 20'd0;

	QL_DSP2 #(
		.MODE_BITS({COEFF_3, COEFF_2, COEFF_1, COEFF_0})
	) dsp (
		.a(a_i),
		.b(b_i),
		.z(z_o),
		.dly_b(dly_b_o),

		.f_mode(1'b0),  // 20x18x64 DSP

		.acc_fir(acc_fir_i),
		.feedback(feedback_i),
		.load_acc(load_acc_i),

		.unsigned_a(unsigned_a_i),
		.unsigned_b(unsigned_b_i),

		.clk(clock_i),
		.reset(reset_i),

		.saturate_enable(saturate_enable_i),
		.output_select(output_select_i),
		.round(round_i),
		.shift_right(shift_right_i),
		.subtract(subtract_i),
		.register_inputs(register_inputs_i)
	);
endmodule

module dsp_t1_10x9x32_cfg_ports (
	input  wire [ 9:0] a_i,
	input  wire [ 8:0] b_i,
	input  wire [ 5:0] acc_fir_i,
	output wire [18:0] z_o,
	output wire [ 8:0] dly_b_o,

	(* clkbuf_sink *)
	input  wire        clock_i,
	input  wire        reset_i,

	input  wire [ 2:0] feedback_i,
	input  wire        load_acc_i,
	input  wire        unsigned_a_i,
	input  wire        unsigned_b_i,

	input  wire [ 2:0] output_select_i,
	input  wire        saturate_enable_i,
	input  wire [ 5:0] shift_right_i,
	input  wire        round_i,
	input  wire        subtract_i,
	input  wire        register_inputs_i
);

	parameter [9:0] COEFF_0 = 10'd0;
	parameter [9:0] COEFF_1 = 10'd0;
	parameter [9:0] COEFF_2 = 10'd0;
	parameter [9:0] COEFF_3 = 10'd0;

	wire [18:0] z_rem;
	wire [8:0] dly_b_rem;

	QL_DSP2 #(
		.MODE_BITS({10'd0, COEFF_3,
					10'd0, COEFF_2,
					10'd0, COEFF_1,
					10'd0, COEFF_0})
	) dsp (
		.a({10'd0, a_i}),
		.b({9'd0, b_i}),
		.z({z_rem, z_o}),
		.dly_b({dly_b_rem, dly_b_o}),

		.f_mode(1'b1),  // 10x9x32 DSP

		.acc_fir(acc_fir_i),
		.feedback(feedback_i),
		.load_acc(load_acc_i),

		.unsigned_a(unsigned_a_i),
		.unsigned_b(unsigned_b_i),

		.clk(clock_i),
		.reset(reset_i),

		.saturate_enable(saturate_enable_i),
		.output_select(output_select_i),
		.round(round_i),
		.shift_right(shift_right_i),
		.subtract(subtract_i),
		.register_inputs(register_inputs_i)
	);
endmodule

module dsp_t1_sim_cfg_ports # (
	parameter NBITS_ACC  = 64,
	parameter NBITS_A    = 20,
	parameter NBITS_B    = 18,
	parameter NBITS_Z    = 38
)(
	input  wire [NBITS_A-1:0] a_i,
	input  wire [NBITS_B-1:0] b_i,
	output wire [NBITS_Z-1:0] z_o,
	output reg  [NBITS_B-1:0] dly_b_o,

	input  wire [5:0]         acc_fir_i,
	input  wire [2:0]         feedback_i,
	input  wire               load_acc_i,

	input  wire               unsigned_a_i,
	input  wire               unsigned_b_i,

	input  wire               clock_i,
	input  wire               s_reset,

	input  wire               saturate_enable_i,
	input  wire [2:0]         output_select_i,
	input  wire               round_i,
	input  wire [5:0]         shift_right_i,
	input  wire               subtract_i,
	input  wire               register_inputs_i,
	input  wire [NBITS_A-1:0] coef_0_i,
	input  wire [NBITS_A-1:0] coef_1_i,
	input  wire [NBITS_A-1:0] coef_2_i,
	input  wire [NBITS_A-1:0] coef_3_i
);

// FIXME: The version of Icarus Verilog from Conda seems not to recognize the
// $error macro. Disable this sanity check for now because of that.


	// Input registers
	reg  [NBITS_A-1:0]  r_a;
	reg  [NBITS_B-1:0]  r_b;
	reg  [5:0]          r_acc_fir;
	reg                 r_unsigned_a;
	reg                 r_unsigned_b;
	reg                 r_load_acc;
	reg  [2:0]          r_feedback;
	reg  [5:0]          r_shift_d1;
	reg  [5:0]          r_shift_d2;
	reg         r_subtract;
	reg         r_sat;
	reg         r_rnd;
	reg [NBITS_ACC-1:0] acc;

	initial begin
		r_a          <= 0;
		r_b          <= 0;

		r_acc_fir    <= 0;
		r_unsigned_a <= 0;
		r_unsigned_b <= 0;
		r_feedback   <= 0;
		r_shift_d1   <= 0;
		r_shift_d2   <= 0;
		r_subtract   <= 0;
		r_load_acc   <= 0;
		r_sat        <= 0;
		r_rnd        <= 0;
	end

	always @(posedge clock_i or posedge s_reset) begin
		if (s_reset) begin

			r_a <= 'h0;
			r_b <= 'h0;

			r_acc_fir    <= 0;
			r_unsigned_a <= 0;
			r_unsigned_b <= 0;
			r_feedback   <= 0;
			r_shift_d1   <= 0;
			r_shift_d2   <= 0;
			r_subtract   <= 0;
			r_load_acc   <= 0;
			r_sat    <= 0;
			r_rnd    <= 0;

		end else begin

			r_a <= a_i;
			r_b <= b_i;

			r_acc_fir    <= acc_fir_i;
			r_unsigned_a <= unsigned_a_i;
			r_unsigned_b <= unsigned_b_i;
			r_feedback   <= feedback_i;
			r_shift_d1   <= shift_right_i;
			r_shift_d2   <= r_shift_d1;
			r_subtract   <= subtract_i;
			r_load_acc   <= load_acc_i;
			r_sat    <= r_sat;
			r_rnd    <= r_rnd;

		end
	end

	// Registered / non-registered input path select
	wire [NBITS_A-1:0]  a = register_inputs_i ? r_a : a_i;
	wire [NBITS_B-1:0]  b = register_inputs_i ? r_b : b_i;

	wire [5:0] acc_fir = register_inputs_i ? r_acc_fir : acc_fir_i;
	wire       unsigned_a = register_inputs_i ? r_unsigned_a : unsigned_a_i;
	wire       unsigned_b = register_inputs_i ? r_unsigned_b : unsigned_b_i;
	wire [2:0] feedback   = register_inputs_i ? r_feedback   : feedback_i;
	wire       load_acc   = register_inputs_i ? r_load_acc   : load_acc_i;
	wire       subtract   = register_inputs_i ? r_subtract   : subtract_i;
	wire       sat    = register_inputs_i ? r_sat : saturate_enable_i;
	wire       rnd    = register_inputs_i ? r_rnd : round_i;

	// Shift right control
	wire [5:0] shift_d1 = register_inputs_i ? r_shift_d1 : shift_right_i;
	wire [5:0] shift_d2 = output_select_i[1] ? shift_d1 : r_shift_d2;

	// Multiplier
	wire unsigned_mode = unsigned_a & unsigned_b;
	wire [NBITS_A-1:0] mult_a;
	assign mult_a = (feedback == 3'h0) ?   a :
					(feedback == 3'h1) ?   a :
					(feedback == 3'h2) ?   a :
					(feedback == 3'h3) ?   acc[NBITS_A-1:0] :
					(feedback == 3'h4) ?   coef_0_i :
					(feedback == 3'h5) ?   coef_1_i :
					(feedback == 3'h6) ?   coef_2_i :
					   coef_3_i;    // if feedback == 3'h7

	wire [NBITS_B-1:0] mult_b = (feedback == 2'h2) ? {NBITS_B{1'b0}}  : b;

	wire [NBITS_A-1:0] mult_sgn_a = mult_a[NBITS_A-1];
	wire [NBITS_A-1:0] mult_mag_a = (mult_sgn_a && !unsigned_a) ? (~mult_a + 1) : mult_a;
	wire [NBITS_B-1:0] mult_sgn_b = mult_b[NBITS_B-1];
	wire [NBITS_B-1:0] mult_mag_b = (mult_sgn_b && !unsigned_b) ? (~mult_b + 1) : mult_b;

	wire [NBITS_A+NBITS_B-1:0] mult_mag = mult_mag_a * mult_mag_b;
	wire mult_sgn = (mult_sgn_a && !unsigned_a) ^ (mult_sgn_b && !unsigned_b);

	wire [NBITS_A+NBITS_B-1:0] mult = (unsigned_a && unsigned_b) ?
		(mult_a * mult_b) : (mult_sgn ? (~mult_mag + 1) : mult_mag);

	// Sign extension
	wire [NBITS_ACC-1:0] mult_xtnd = unsigned_mode ?
		{{(NBITS_ACC-NBITS_A-NBITS_B){1'b0}},                    mult[NBITS_A+NBITS_B-1:0]} :
		{{(NBITS_ACC-NBITS_A-NBITS_B){mult[NBITS_A+NBITS_B-1]}}, mult[NBITS_A+NBITS_B-1:0]};

	// Adder
	wire [NBITS_ACC-1:0] acc_fir_int = unsigned_a ? {{(NBITS_ACC-NBITS_A){1'b0}},         a} :
													{{(NBITS_ACC-NBITS_A){a[NBITS_A-1]}}, a} ;

	wire [NBITS_ACC-1:0] add_a = (subtract) ? (~mult_xtnd + 1) : mult_xtnd;
	wire [NBITS_ACC-1:0] add_b = (feedback_i == 3'h0) ? acc :
								 (feedback_i == 3'h1) ? {{NBITS_ACC}{1'b0}} : (acc_fir_int << acc_fir);

	wire [NBITS_ACC-1:0] add_o = add_a + add_b;

	// Accumulator
	initial acc <= 0;

	always @(posedge clock_i or posedge s_reset)
		if (s_reset) acc <= 'h0;
		else begin
			if (load_acc)
				acc <= add_o;
			else
				acc <= acc;
		end

	// Adder/accumulator output selection
	wire [NBITS_ACC-1:0] acc_out = (output_select_i[1]) ? add_o : acc;

	// Round, shift, saturate
	wire [NBITS_ACC-1:0] acc_rnd = (rnd && (shift_right_i != 0)) ? (acc_out + ({{(NBITS_ACC-1){1'b0}}, 1'b1} << (shift_right_i - 1))) :
																	acc_out;

	wire [NBITS_ACC-1:0] acc_shr = (unsigned_mode) ? (acc_rnd  >> shift_right_i) :
													 (acc_rnd >>> shift_right_i);

	wire [NBITS_ACC-1:0] acc_sat_u = (acc_shr[NBITS_ACC-1:NBITS_Z] != 0) ? {{(NBITS_ACC-NBITS_Z){1'b0}},{NBITS_Z{1'b1}}} :
																		   {{(NBITS_ACC-NBITS_Z){1'b0}},{acc_shr[NBITS_Z-1:0]}};

	wire [NBITS_ACC-1:0] acc_sat_s = ((|acc_shr[NBITS_ACC-1:NBITS_Z-1] == 1'b0) ||
									  (&acc_shr[NBITS_ACC-1:NBITS_Z-1] == 1'b1)) ? {{(NBITS_ACC-NBITS_Z){1'b0}},{acc_shr[NBITS_Z-1:0]}} :
																				   {{(NBITS_ACC-NBITS_Z){1'b0}},{acc_shr[NBITS_ACC-1],{NBITS_Z-1{~acc_shr[NBITS_ACC-1]}}}};

	wire [NBITS_ACC-1:0] acc_sat = (sat) ? ((unsigned_mode) ? acc_sat_u : acc_sat_s) : acc_shr;

	// Output signals
	wire [NBITS_Z-1:0]  z0;
	reg  [NBITS_Z-1:0]  z1;
	wire [NBITS_Z-1:0]  z2;

	assign z0 = mult_xtnd[NBITS_Z-1:0];
	assign z2 = acc_sat[NBITS_Z-1:0];

	initial z1 <= 0;

	always @(posedge clock_i or posedge s_reset)
		if (s_reset)
			z1 <= 0;
		else begin
			z1 <= (output_select_i == 3'b100) ? z0 : z2;
		end

	// Output mux
	assign z_o = (output_select_i == 3'h0) ?   z0 :
				 (output_select_i == 3'h1) ?   z2 :
				 (output_select_i == 3'h2) ?   z2 :
				 (output_select_i == 3'h3) ?   z2 :
				 (output_select_i == 3'h4) ?   z1 :
				 (output_select_i == 3'h5) ?   z1 :
				 (output_select_i == 3'h6) ?   z1 :
						   z1;  // if output_select_i == 3'h7

	// B input delayed passthrough
	initial dly_b_o <= 0;

	always @(posedge clock_i or posedge s_reset)
		if (s_reset)
			dly_b_o <= 0;
		else
			dly_b_o <= b_i;

endmodule
`,"ffs_map.v":`// Copyright 2020-2022 F4PGA Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: Apache-2.0

// DFF, asynchronous set/reset, enable
module \\$_DFFSRE_PNNP_ (C, S, R, E, D, Q);
	input  C;
	input  S;
	input  R;
	input  E;
	input  D;
	output Q;
	dffsre _TECHMAP_REPLACE_ (.Q(Q), .D(D), .C(C), .E(E), .R(R), .S(S));
endmodule

module \\$_DFFSRE_NNNP_ (C, S, R, E, D, Q);
	input  C;
	input  S;
	input  R;
	input  E;
	input  D;
	output Q;
	dffnsre _TECHMAP_REPLACE_ (.Q(Q), .D(D), .C(C), .E(E), .R(R), .S(S));
endmodule

// DFF, synchronous set or reset, enable
module \\$_SDFFE_PN0P_ (D, C, R, E, Q);
	input  D;
	input  C;
	input  R;
	input  E;
	output Q;
	sdffsre _TECHMAP_REPLACE_ (.Q(Q), .D(D), .C(C), .E(E), .R(R), .S(1'b1));
endmodule

module \\$_SDFFE_PN1P_ (D, C, R, E, Q);
	input  D;
	input  C;
	input  R;
	input  E;
	output Q;
	sdffsre _TECHMAP_REPLACE_ (.Q(Q), .D(D), .C(C), .E(E), .R(1'b1), .S(R));
endmodule

module \\$_SDFFE_NN0P_ (D, C, R, E, Q);
	input  D;
	input  C;
	input  R;
	input  E;
	output Q;
	sdffnsre _TECHMAP_REPLACE_ (.Q(Q), .D(D), .C(C), .E(E), .R(R), .S(1'b1));
endmodule

module \\$_SDFFE_NN1P_ (D, C, R, E, Q);
	input  D;
	input  C;
	input  R;
	input  E;
	output Q;
	sdffnsre _TECHMAP_REPLACE_ (.Q(Q), .D(D), .C(C), .E(E), .R(1'b1), .S(R));
endmodule

// Latch, no set/reset, no enable
module  \\$_DLATCH_P_ (input E, D, output Q);
	latchsre  _TECHMAP_REPLACE_ (.D(D), .Q(Q), .E(1'b1), .G(E), .R(1'b1), .S(1'b1));
endmodule

module  \\$_DLATCH_N_ (input E, D, output Q);
	latchnsre _TECHMAP_REPLACE_ (.D(D), .Q(Q), .E(1'b1), .G(E), .R(1'b1), .S(1'b1));
endmodule

// Latch with async set and reset and enable
module  \\$_DLATCHSR_PPP_ (input E, S, R, D, output Q);
	latchsre  _TECHMAP_REPLACE_ (.D(D), .Q(Q), .E(1'b1), .G(E),  .R(!R), .S(!S));
endmodule

module  \\$_DLATCHSR_NPP_ (input E, S, R, D, output Q);
	latchnsre _TECHMAP_REPLACE_ (.D(D), .Q(Q), .E(1'b1), .G(E),  .R(!R), .S(!S));
endmodule

module \\$__SHREG_DFF_P_ (D, Q, C);
	input  D;
	input  C;
	output Q;

	parameter DEPTH = 2;

	reg [DEPTH-2:0] q;

	genvar i;
	generate for (i = 0; i < DEPTH; i = i + 1) begin: slice

		// First in chain
		generate if (i == 0) begin
				 sh_dff #() shreg_beg (
					.Q(q[i]),
					.D(D),
					.C(C)
				);
		end endgenerate
		// Middle in chain
		generate if (i > 0 && i != DEPTH-1) begin
				 sh_dff #() shreg_mid (
					.Q(q[i]),
					.D(q[i-1]),
					.C(C)
				);
		end endgenerate
		// Last in chain
		generate if (i == DEPTH-1) begin
				 sh_dff #() shreg_end (
					.Q(Q),
					.D(q[i-1]),
					.C(C)
				);
		end endgenerate
   end: slice
   endgenerate

endmodule

`,"libmap_brams.txt":`ram block $__QLF_TDP36K {
	init any;
	byte 9;
	option "SPLIT" 0 {
		abits 15;
		widths 1 2 4 9 18 36 per_port;
	}
	option "SPLIT" 1 {
		abits 14;
		widths 1 2 4 9 18 per_port;
	}
	cost 65;
	port srsw "A" "B" {
		width tied;
		clock posedge;
		# wen causes read even when ren is low
		# map clken = wen || ren
		clken;
		wrbe_separate;
		rdwr old;
	}
}
`,"libmap_brams_map.v":`// Copyright 2020-2022 F4PGA Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: Apache-2.0

module \\$__QLF_TDP36K (PORT_A_CLK, PORT_A_ADDR, PORT_A_WR_DATA, PORT_A_WR_EN, PORT_A_WR_BE, PORT_A_CLK_EN, PORT_A_RD_DATA,
					   PORT_B_CLK, PORT_B_ADDR, PORT_B_WR_DATA, PORT_B_WR_EN, PORT_B_WR_BE, PORT_B_CLK_EN, PORT_B_RD_DATA);  

parameter INIT = 0;

parameter OPTION_SPLIT = 0;

parameter PORT_A_WIDTH = 1;
parameter PORT_A_WR_BE_WIDTH = 1;

parameter PORT_B_WIDTH = 1;
parameter PORT_B_WR_BE_WIDTH = 1;

input PORT_A_CLK;
input [14:0] PORT_A_ADDR;
input [PORT_A_WIDTH-1:0] PORT_A_WR_DATA;
input PORT_A_WR_EN;
input [PORT_A_WR_BE_WIDTH-1:0] PORT_A_WR_BE;
input PORT_A_CLK_EN;
output [PORT_A_WIDTH-1:0] PORT_A_RD_DATA;

input PORT_B_CLK;
input [14:0] PORT_B_ADDR;
input [PORT_B_WIDTH-1:0] PORT_B_WR_DATA;
input PORT_B_WR_EN;
input [PORT_B_WR_BE_WIDTH-1:0] PORT_B_WR_BE;
input PORT_B_CLK_EN;
output [PORT_B_WIDTH-1:0] PORT_B_RD_DATA;


// Fixed mode settings
localparam [ 0:0] SYNC_FIFO1_i  = 1'd0;
localparam [ 0:0] FMODE1_i      = 1'd0;
localparam [ 0:0] POWERDN1_i    = 1'd0;
localparam [ 0:0] SLEEP1_i      = 1'd0;
localparam [ 0:0] PROTECT1_i    = 1'd0;
localparam [11:0] UPAE1_i       = 12'd10;
localparam [11:0] UPAF1_i       = 12'd10;

localparam [ 0:0] SYNC_FIFO2_i  = 1'd0;
localparam [ 0:0] FMODE2_i      = 1'd0;
localparam [ 0:0] POWERDN2_i    = 1'd0;
localparam [ 0:0] SLEEP2_i      = 1'd0;
localparam [ 0:0] PROTECT2_i    = 1'd0;
localparam [10:0] UPAE2_i       = 11'd10;
localparam [10:0] UPAF2_i       = 11'd10;

// Width mode function
function [2:0] mode;
input integer width;
case (width)
1: mode = 3'b101;
2: mode = 3'b110;
4: mode = 3'b100;
8,9: mode = 3'b001;
16, 18: mode = 3'b010;
32, 36: mode = 3'b011;
default: mode = 3'b000;
endcase
endfunction

function [36863:0] pack_init;
	integer i;
	reg [35:0] ri;
	for (i = 0; i < (OPTION_SPLIT ? 512 : 1024); i = i + 1) begin
		ri = INIT[i*36 +: 36];
		pack_init[i*36 +: 36] = {ri[35], ri[26], ri[34:27], ri[25:18],
								 ri[17], ri[8], ri[16:9], ri[7:0]};
	end
	if (OPTION_SPLIT)
		pack_init[36863:18432] = 18432'bx;
endfunction

wire REN_A1_i;
wire REN_A2_i;

wire REN_B1_i;
wire REN_B2_i;

wire WEN_A1_i;
wire WEN_A2_i;

wire WEN_B1_i;
wire WEN_B2_i;

wire [1:0] BE_A1_i;
wire [1:0] BE_A2_i;

wire [1:0] BE_B1_i;
wire [1:0] BE_B2_i;

wire [14:0] ADDR_A1_i;
wire [13:0] ADDR_A2_i;

wire [14:0] ADDR_B1_i;
wire [13:0] ADDR_B2_i;

wire [17:0] WDATA_A1_i;
wire [17:0] WDATA_A2_i;

wire [17:0] WDATA_B1_i;
wire [17:0] WDATA_B2_i;

wire [17:0] RDATA_A1_o;
wire [17:0] RDATA_A2_o;

wire [17:0] RDATA_B1_o;
wire [17:0] RDATA_B2_o;


// Set port width mode (In non-split mode A2/B2 is not active. Set same values anyway to match previous behavior.)
localparam [ 2:0] RMODE_A1_i    = mode(PORT_A_WIDTH);
localparam [ 2:0] WMODE_A1_i    = mode(PORT_A_WIDTH);
localparam [ 2:0] RMODE_A2_i    = mode(PORT_A_WIDTH);
localparam [ 2:0] WMODE_A2_i    = mode(PORT_A_WIDTH);

localparam [ 2:0] RMODE_B1_i    = mode(PORT_B_WIDTH);
localparam [ 2:0] WMODE_B1_i    = mode(PORT_B_WIDTH);
localparam [ 2:0] RMODE_B2_i    = mode(PORT_B_WIDTH);
localparam [ 2:0] WMODE_B2_i    = mode(PORT_B_WIDTH);

assign REN_A1_i = PORT_A_CLK_EN;
assign WEN_A1_i = PORT_A_CLK_EN & PORT_A_WR_EN;
assign {BE_A2_i, BE_A1_i} = PORT_A_WR_BE;

assign REN_B1_i = PORT_B_CLK_EN;
assign WEN_B1_i = PORT_B_CLK_EN & PORT_B_WR_EN;
assign {BE_B2_i, BE_B1_i} = PORT_B_WR_BE;

case (PORT_A_WIDTH)
9: assign { WDATA_A1_i[16], WDATA_A1_i[7:0] } = PORT_A_WR_DATA;
18: assign { WDATA_A1_i[17], WDATA_A1_i[15:8], WDATA_A1_i[16], WDATA_A1_i[7:0] } = PORT_A_WR_DATA;
36: assign { WDATA_A2_i[17], WDATA_A2_i[15:8], WDATA_A2_i[16], WDATA_A2_i[7:0], WDATA_A1_i[17], WDATA_A1_i[15:8], WDATA_A1_i[16], WDATA_A1_i[7:0]} = PORT_A_WR_DATA;
default: assign WDATA_A1_i = PORT_A_WR_DATA; // 1,2,4
endcase

case (PORT_B_WIDTH)
9: assign { WDATA_B1_i[16], WDATA_B1_i[7:0] } = PORT_B_WR_DATA;
18: assign { WDATA_B1_i[17], WDATA_B1_i[15:8], WDATA_B1_i[16], WDATA_B1_i[7:0] } = PORT_B_WR_DATA;
36: assign { WDATA_B2_i[17], WDATA_B2_i[15:8], WDATA_B2_i[16], WDATA_B2_i[7:0], WDATA_B1_i[17], WDATA_B1_i[15:8], WDATA_B1_i[16], WDATA_B1_i[7:0]} = PORT_B_WR_DATA;
default: assign WDATA_B1_i = PORT_B_WR_DATA; // 1,2,4
endcase

case (PORT_A_WIDTH)
9: assign PORT_A_RD_DATA = { RDATA_A1_o[16], RDATA_A1_o[7:0] };
18: assign PORT_A_RD_DATA = { RDATA_A1_o[17], RDATA_A1_o[15:8], RDATA_A1_o[16], RDATA_A1_o[7:0] };
36: assign PORT_A_RD_DATA = { RDATA_A2_o[17], RDATA_A2_o[15:8], RDATA_A2_o[16], RDATA_A2_o[7:0], RDATA_A1_o[17], RDATA_A1_o[15:8], RDATA_A1_o[16], RDATA_A1_o[7:0]};
default: assign PORT_A_RD_DATA = RDATA_A1_o; // 1,2,4
endcase

case (PORT_B_WIDTH)
9: assign PORT_B_RD_DATA = { RDATA_B1_o[16], RDATA_B1_o[7:0] };
18: assign PORT_B_RD_DATA = { RDATA_B1_o[17], RDATA_B1_o[15:8], RDATA_B1_o[16], RDATA_B1_o[7:0] };
36: assign PORT_B_RD_DATA = { RDATA_B2_o[17], RDATA_B2_o[15:8], RDATA_B2_o[16], RDATA_B2_o[7:0], RDATA_B1_o[17], RDATA_B1_o[15:8], RDATA_B1_o[16], RDATA_B1_o[7:0]};
default: assign PORT_B_RD_DATA = RDATA_B1_o; // 1,2,4
endcase

defparam _TECHMAP_REPLACE_.MODE_BITS = { 1'b0,
	UPAF2_i, UPAE2_i, PROTECT2_i, SLEEP2_i, POWERDN2_i, FMODE2_i, WMODE_B2_i, WMODE_A2_i, RMODE_B2_i, RMODE_A2_i, SYNC_FIFO2_i,
	UPAF1_i, UPAE1_i, PROTECT1_i, SLEEP1_i, POWERDN1_i, FMODE1_i, WMODE_B1_i, WMODE_A1_i, RMODE_B1_i, RMODE_A1_i, SYNC_FIFO1_i
};

(* is_inferred = 1 *)
(* is_split = 0 *)
(* was_split_candidate = OPTION_SPLIT *)
(* port_a_width = PORT_A_WIDTH *)
(* port_b_width = PORT_B_WIDTH *)
TDP36K #(
	.RAM_INIT(pack_init()),
) _TECHMAP_REPLACE_ (
	.RESET_ni(1'b1),

	.CLK_A1_i(PORT_A_CLK),
	.ADDR_A1_i(PORT_A_ADDR),
	.WEN_A1_i(WEN_A1_i),
	.BE_A1_i(BE_A1_i),
	.WDATA_A1_i(WDATA_A1_i),
	.REN_A1_i(REN_A1_i),
	.RDATA_A1_o(RDATA_A1_o),

	.CLK_A2_i(PORT_A_CLK),
	.ADDR_A2_i(PORT_A_ADDR[13:0]),
	.WEN_A2_i(WEN_A1_i),
	.BE_A2_i(BE_A2_i),
	.WDATA_A2_i(WDATA_A2_i),
	.REN_A2_i(REN_A1_i),
	.RDATA_A2_o(RDATA_A2_o),

	.CLK_B1_i(PORT_B_CLK),
	.ADDR_B1_i(PORT_B_ADDR),
	.WEN_B1_i(WEN_B1_i),
	.BE_B1_i(BE_B1_i),
	.WDATA_B1_i(WDATA_B1_i),
	.REN_B1_i(REN_B1_i),
	.RDATA_B1_o(RDATA_B1_o),

	.CLK_B2_i(PORT_B_CLK),
	.ADDR_B2_i(PORT_B_ADDR[13:0]),
	.WEN_B2_i(WEN_B1_i),
	.BE_B2_i(BE_B2_i),
	.WDATA_B2_i(WDATA_B2_i),
	.REN_B2_i(REN_B1_i),
	.RDATA_B2_o(RDATA_B2_o),

	.FLUSH1_i(1'b0),
	.FLUSH2_i(1'b0)
);

endmodule


module \\$__QLF_TDP36K_MERGED (...);

parameter INIT1 = 0;

parameter PORT_A1_WIDTH = 1;
parameter PORT_B1_WIDTH = 1;

parameter PORT_A1_WR_BE_WIDTH = 1;
parameter PORT_B1_WR_BE_WIDTH = 1;

input PORT_A1_CLK;
input [14:0] PORT_A1_ADDR;
input [PORT_A1_WIDTH-1:0] PORT_A1_WR_DATA;
input PORT_A1_WR_EN;
input [PORT_A1_WR_BE_WIDTH-1:0] PORT_A1_WR_BE;
input PORT_A1_CLK_EN;
output [PORT_A1_WIDTH-1:0] PORT_A1_RD_DATA;

input PORT_B1_CLK;
input [14:0] PORT_B1_ADDR;
input [PORT_B1_WIDTH-1:0] PORT_B1_WR_DATA;
input PORT_B1_WR_EN;
input [PORT_B1_WR_BE_WIDTH-1:0] PORT_B1_WR_BE;
input PORT_B1_CLK_EN;
output [PORT_B1_WIDTH-1:0] PORT_B1_RD_DATA;

parameter INIT2 = 0;

parameter PORT_A2_WIDTH = 1;
parameter PORT_B2_WIDTH = 1;
parameter PORT_A2_WR_BE_WIDTH = 1;
parameter PORT_B2_WR_BE_WIDTH = 1;

input PORT_A2_CLK;
input [14:0] PORT_A2_ADDR;
input [PORT_A2_WIDTH-1:0] PORT_A2_WR_DATA;
input PORT_A2_WR_EN;
input [PORT_A2_WR_BE_WIDTH-1:0] PORT_A2_WR_BE;
input PORT_A2_CLK_EN;
output [PORT_A2_WIDTH-1:0] PORT_A2_RD_DATA;

input PORT_B2_CLK;
input [14:0] PORT_B2_ADDR;
input [PORT_B2_WIDTH-1:0] PORT_B2_WR_DATA;
input PORT_B2_WR_EN;
input [PORT_B2_WR_BE_WIDTH-1:0] PORT_B2_WR_BE;
input PORT_B2_CLK_EN;
output [PORT_B2_WIDTH-1:0] PORT_B2_RD_DATA;


// Fixed mode settings
localparam [ 0:0] SYNC_FIFO1_i  = 1'd0;
localparam [ 0:0] FMODE1_i      = 1'd0;
localparam [ 0:0] POWERDN1_i    = 1'd0;
localparam [ 0:0] SLEEP1_i      = 1'd0;
localparam [ 0:0] PROTECT1_i    = 1'd0;
localparam [11:0] UPAE1_i       = 12'd10;
localparam [11:0] UPAF1_i       = 12'd10;

localparam [ 0:0] SYNC_FIFO2_i  = 1'd0;
localparam [ 0:0] FMODE2_i      = 1'd0;
localparam [ 0:0] POWERDN2_i    = 1'd0;
localparam [ 0:0] SLEEP2_i      = 1'd0;
localparam [ 0:0] PROTECT2_i    = 1'd0;
localparam [10:0] UPAE2_i       = 11'd10;
localparam [10:0] UPAF2_i       = 11'd10;

// Width mode function
function [2:0] mode;
input integer width;
case (width)
1: mode = 3'b101;
2: mode = 3'b110;
4: mode = 3'b100;
8,9: mode = 3'b001;
16, 18: mode = 3'b010;
default: mode = 3'b000;
endcase
endfunction

function [36863:0] pack_init;
	integer i;
	reg [35:0] ri;
	for (i = 0; i < 1024; i = i + 1) begin
		ri = {INIT2[i*18 +: 18], INIT1[i*18 +: 18]};
		pack_init[i*36 +: 36] = {ri[35], ri[26], ri[34:27], ri[25:18], ri[17], ri[8], ri[16:9], ri[7:0]};
	end
endfunction

wire REN_A1_i;
wire REN_A2_i;

wire REN_B1_i;
wire REN_B2_i;

wire WEN_A1_i;
wire WEN_A2_i;

wire WEN_B1_i;
wire WEN_B2_i;

wire [1:0] BE_A1_i;
wire [1:0] BE_A2_i;

wire [1:0] BE_B1_i;
wire [1:0] BE_B2_i;

wire [14:0] ADDR_A1_i;
wire [13:0] ADDR_A2_i;

wire [14:0] ADDR_B1_i;
wire [13:0] ADDR_B2_i;

wire [17:0] WDATA_A1_i;
wire [17:0] WDATA_A2_i;

wire [17:0] WDATA_B1_i;
wire [17:0] WDATA_B2_i;

wire [17:0] RDATA_A1_o;
wire [17:0] RDATA_A2_o;

wire [17:0] RDATA_B1_o;
wire [17:0] RDATA_B2_o;


// Set port width mode (In non-split mode A2/B2 is not active. Set same values anyway to match previous behavior.)
localparam [ 2:0] RMODE_A1_i    = mode(PORT_A1_WIDTH);
localparam [ 2:0] WMODE_A1_i    = mode(PORT_A1_WIDTH);
localparam [ 2:0] RMODE_B1_i    = mode(PORT_B1_WIDTH);
localparam [ 2:0] WMODE_B1_i    = mode(PORT_B1_WIDTH);

localparam [ 2:0] RMODE_A2_i    = mode(PORT_A2_WIDTH);
localparam [ 2:0] WMODE_A2_i    = mode(PORT_A2_WIDTH);
localparam [ 2:0] RMODE_B2_i    = mode(PORT_B2_WIDTH);
localparam [ 2:0] WMODE_B2_i    = mode(PORT_B2_WIDTH);

assign REN_A1_i = PORT_A1_CLK_EN;
assign WEN_A1_i = PORT_A1_CLK_EN & PORT_A1_WR_EN;
assign BE_A1_i = PORT_A1_WR_BE;

assign REN_B1_i = PORT_B1_CLK_EN;
assign WEN_B1_i = PORT_B1_CLK_EN & PORT_B1_WR_EN;
assign BE_B1_i = PORT_B1_WR_BE;

assign REN_A2_i = PORT_A2_CLK_EN;
assign WEN_A2_i = PORT_A2_CLK_EN & PORT_A2_WR_EN;
assign BE_A2_i = PORT_A2_WR_BE;

assign REN_B2_i = PORT_B2_CLK_EN;
assign WEN_B2_i = PORT_B2_CLK_EN & PORT_B2_WR_EN;
assign BE_B2_i = PORT_B2_WR_BE;

assign ADDR_A1_i = PORT_A1_ADDR;
assign ADDR_B1_i = PORT_B1_ADDR;
assign ADDR_A2_i = PORT_A2_ADDR;
assign ADDR_B2_i = PORT_B2_ADDR;

case (PORT_A1_WIDTH)
9: assign { WDATA_A1_i[16], WDATA_A1_i[7:0] } = PORT_A1_WR_DATA;
18: assign { WDATA_A1_i[17], WDATA_A1_i[15:8], WDATA_A1_i[16], WDATA_A1_i[7:0] } = PORT_A1_WR_DATA;
default: assign WDATA_A1_i = PORT_A1_WR_DATA; // 1,2,4,8,16
endcase

case (PORT_B1_WIDTH)
9: assign { WDATA_B1_i[16], WDATA_B1_i[7:0] } = PORT_B1_WR_DATA;
18: assign { WDATA_B1_i[17], WDATA_B1_i[15:8], WDATA_B1_i[16], WDATA_B1_i[7:0] } = PORT_B1_WR_DATA;
default: assign WDATA_B1_i = PORT_B1_WR_DATA; // 1,2,4,8,16
endcase

case (PORT_A1_WIDTH)
9: assign PORT_A1_RD_DATA = { RDATA_A1_o[16], RDATA_A1_o[7:0] };
18: assign PORT_A1_RD_DATA = { RDATA_A1_o[17], RDATA_A1_o[15:8], RDATA_A1_o[16], RDATA_A1_o[7:0] };
default: assign PORT_A1_RD_DATA = RDATA_A1_o; // 1,2,4,8,16
endcase

case (PORT_B1_WIDTH)
9: assign PORT_B1_RD_DATA = { RDATA_B1_o[16], RDATA_B1_o[7:0] };
18: assign PORT_B1_RD_DATA = { RDATA_B1_o[17], RDATA_B1_o[15:8], RDATA_B1_o[16], RDATA_B1_o[7:0] };
default: assign PORT_B1_RD_DATA = RDATA_B1_o; // 1,2,4,8,16
endcase

case (PORT_A2_WIDTH)
9: assign { WDATA_A2_i[16], WDATA_A2_i[7:0] } = PORT_A2_WR_DATA;
18: assign { WDATA_A2_i[17], WDATA_A2_i[15:8], WDATA_A2_i[16], WDATA_A2_i[7:0] } = PORT_A2_WR_DATA;
default: assign WDATA_A2_i = PORT_A2_WR_DATA; // 1,2,4,8,16
endcase

case (PORT_B2_WIDTH)
9: assign { WDATA_B2_i[16], WDATA_B2_i[7:0] } = PORT_B2_WR_DATA;
18: assign { WDATA_B2_i[17], WDATA_B2_i[15:8], WDATA_B2_i[16], WDATA_B2_i[7:0] } = PORT_B2_WR_DATA;
default: assign WDATA_B2_i = PORT_B2_WR_DATA; // 1,2,4,8,16
endcase

case (PORT_A2_WIDTH)
9: assign PORT_A2_RD_DATA = { RDATA_A2_o[16], RDATA_A2_o[7:0] };
18: assign PORT_A2_RD_DATA = { RDATA_A2_o[17], RDATA_A2_o[15:8], RDATA_A2_o[16], RDATA_A2_o[7:0] };
default: assign PORT_A2_RD_DATA = RDATA_A2_o; // 1,2,4,8,16
endcase

case (PORT_B2_WIDTH)
9: assign PORT_B2_RD_DATA = { RDATA_B2_o[16], RDATA_B2_o[7:0] };
18: assign PORT_B2_RD_DATA = { RDATA_B2_o[17], RDATA_B2_o[15:8], RDATA_B2_o[16], RDATA_B2_o[7:0] };
default: assign PORT_B2_RD_DATA = RDATA_B2_o; // 1,2,4,8,16
endcase

defparam _TECHMAP_REPLACE_.MODE_BITS = {1'b1,
			UPAF2_i, UPAE2_i, PROTECT2_i, SLEEP2_i, POWERDN2_i, FMODE2_i, WMODE_B2_i, WMODE_A2_i, RMODE_B2_i, RMODE_A2_i, SYNC_FIFO2_i,
			UPAF1_i, UPAE1_i, PROTECT1_i, SLEEP1_i, POWERDN1_i, FMODE1_i, WMODE_B1_i, WMODE_A1_i, RMODE_B1_i, RMODE_A1_i, SYNC_FIFO1_i
		};

(* is_inferred = 1 *)
(* is_split = 1 *)
(* port_a1_width = PORT_A1_WIDTH *)
(* port_a2_width = PORT_A2_WIDTH *)
(* port_b1_width = PORT_B1_WIDTH *)
(* port_b2_width = PORT_B2_WIDTH *)
TDP36K #(
	.RAM_INIT(pack_init()),
) _TECHMAP_REPLACE_ (
	.RESET_ni(1'b1),
	.WDATA_A1_i(WDATA_A1_i),
	.WDATA_A2_i(WDATA_A2_i),
	.RDATA_A1_o(RDATA_A1_o),
	.RDATA_A2_o(RDATA_A2_o),
	.ADDR_A1_i(ADDR_A1_i),
	.ADDR_A2_i(ADDR_A2_i),
	.CLK_A1_i(PORT_A1_CLK),
	.CLK_A2_i(PORT_A2_CLK),
	.REN_A1_i(REN_A1_i),
	.REN_A2_i(REN_A2_i),
	.WEN_A1_i(WEN_A1_i),
	.WEN_A2_i(WEN_A2_i),
	.BE_A1_i(BE_A1_i),
	.BE_A2_i(BE_A2_i),

	.WDATA_B1_i(WDATA_B1_i),
	.WDATA_B2_i(WDATA_B2_i),
	.RDATA_B1_o(RDATA_B1_o),
	.RDATA_B2_o(RDATA_B2_o),
	.ADDR_B1_i(ADDR_B1_i),
	.ADDR_B2_i(ADDR_B2_i),
	.CLK_B1_i(PORT_B1_CLK),
	.CLK_B2_i(PORT_B2_CLK),
	.REN_B1_i(REN_B1_i),
	.REN_B2_i(REN_B2_i),
	.WEN_B1_i(WEN_B1_i),
	.WEN_B2_i(WEN_B2_i),
	.BE_B1_i(BE_B1_i),
	.BE_B2_i(BE_B2_i),

	.FLUSH1_i(1'b0),
	.FLUSH2_i(1'b0)
);

endmodule`,"sram1024x18_mem.v":`\`default_nettype none
module sram1024x18 (
	clk_a,
	cen_a,
	wen_a,
	addr_a,
	wmsk_a,
	wdata_a,
	rdata_a,
	clk_b,
	cen_b,
	wen_b,
	addr_b,
	wmsk_b,
	wdata_b,
	rdata_b
);
	parameter [1024*18-1:0] init = 18431'bx;
	(* clkbuf_sink *)
	input wire clk_a;
	input wire cen_a;
	input wire wen_a;
	input wire [9:0] addr_a;
	input wire [17:0] wmsk_a;
	input wire [17:0] wdata_a;
	output reg [17:0] rdata_a;
	(* clkbuf_sink *)
	input wire clk_b;
	input wire cen_b;
	input wire wen_b;
	input wire [9:0] addr_b;
	input wire [17:0] wmsk_b;
	input wire [17:0] wdata_b;
	output reg [17:0] rdata_b;
	reg [17:0] ram [1023:0];
	integer i;
	initial begin
		for (i = 0; i < 1024; i = i + 1) begin
			ram[i] = init[18*i +: 18];
		end
	end

	always @(posedge clk_a) begin
		if (!cen_a) begin
	 		if (!wen_a)
				for (i = 0; i < 18; i++) begin
					if (!wmsk_a[i]) ram[addr_a][i] <= wdata_a[i];
				end
			rdata_a <= ram[addr_a];
		end
	end

	always @(posedge clk_b) begin
		if (!cen_b) begin
	 		if (!wen_b)
				for (i = 0; i < 18; i++) begin
					if (!wmsk_b[i]) ram[addr_b][i] <= wdata_b[i];
				end
			rdata_b <= ram[addr_b];
		end
	end

endmodule

`,"ufifo_ctl.v":`// Copyright 2020-2022 F4PGA Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: Apache-2.0

\`default_nettype wire
module fifo_ctl (
	raddr,
	waddr,
	fflags,
	ren_o,
	sync,
	rmode,
	wmode,
	rclk,
	rst_R_n,
	wclk,
	rst_W_n,
	ren,
	wen,
	upaf,
	upae
);
	parameter ADDR_WIDTH = 11;
	parameter FIFO_WIDTH = 3'd2;
	parameter DEPTH = 6;
	output wire [ADDR_WIDTH - 1:0] raddr;
	output wire [ADDR_WIDTH - 1:0] waddr;
	output wire [7:0] fflags;
	output wire ren_o;
	input wire sync;
	input wire [1:0] rmode;
	input wire [1:0] wmode;
	(* clkbuf_sink *)
	input wire rclk;
	input wire rst_R_n;
	(* clkbuf_sink *)
	input wire wclk;
	input wire rst_W_n;
	input wire ren;
	input wire wen;
	input wire [ADDR_WIDTH - 1:0] upaf;
	input wire [ADDR_WIDTH - 1:0] upae;
	localparam ADDR_PLUS_ONE = ADDR_WIDTH + 1;
	reg [ADDR_WIDTH:0] pushtopop1;
	reg [ADDR_WIDTH:0] pushtopop2;
	reg [ADDR_WIDTH:0] poptopush1;
	reg [ADDR_WIDTH:0] poptopush2;
	wire [ADDR_WIDTH:0] pushtopop0;
	wire [ADDR_WIDTH:0] poptopush0;
	wire [ADDR_WIDTH:0] smux_poptopush;
	wire [ADDR_WIDTH:0] smux_pushtopop;
	assign smux_poptopush = (sync ? poptopush0 : poptopush2);
	assign smux_pushtopop = (sync ? pushtopop0 : pushtopop2);
	always @(posedge rclk or negedge rst_R_n)
		if (~rst_R_n) begin
			pushtopop1 <= 'h0;
			pushtopop2 <= 'h0;
		end
		else begin
			pushtopop1 = pushtopop0;
			pushtopop2 = pushtopop1;
		end
	always @(posedge wclk or negedge rst_W_n)
		if (~rst_W_n) begin
			poptopush1 <= 'h0;
			poptopush2 <= 'h0;
		end
		else begin
			poptopush1 <= poptopush0;
			poptopush2 <= poptopush1;
		end
	fifo_push #(
		.ADDR_WIDTH(ADDR_WIDTH),
		.DEPTH(DEPTH)
	) u_fifo_push(
		.wclk(wclk),
		.wen(wen),
		.rst_n(rst_W_n),
		.rmode(rmode),
		.wmode(wmode),
		.gcout(pushtopop0),
		.gcin(smux_poptopush),
		.ff_waddr(waddr),
		.pushflags(fflags[7:4]),
		.upaf(upaf)
	);
	fifo_pop #(
		.ADDR_WIDTH(ADDR_WIDTH),
		.FIFO_WIDTH(FIFO_WIDTH),
		.DEPTH(DEPTH)
	) u_fifo_pop(
		.rclk(rclk),
		.ren_in(ren),
		.rst_n(rst_R_n),
		.rmode(rmode),
		.wmode(wmode),
		.ren_o(ren_o),
		.gcout(poptopush0),
		.gcin(smux_pushtopop),
		.out_raddr(raddr),
		.popflags(fflags[3:0]),
		.upae(upae)
	);
endmodule
module fifo_push (
	pushflags,
	gcout,
	ff_waddr,
	rst_n,
	wclk,
	wen,
	rmode,
	wmode,
	gcin,
	upaf
);
	parameter ADDR_WIDTH = 11;
	parameter DEPTH = 6;
	output wire [3:0] pushflags;
	output wire [ADDR_WIDTH:0] gcout;
	output wire [ADDR_WIDTH - 1:0] ff_waddr;
	input rst_n;
	(* clkbuf_sink *)
	input wclk;
	input wen;
	input [1:0] rmode;
	input [1:0] wmode;
	input [ADDR_WIDTH:0] gcin;
	input [ADDR_WIDTH - 1:0] upaf;
	localparam ADDR_PLUS_ONE = ADDR_WIDTH + 1;
	reg full_next;
	reg full;
	reg paf_next;
	reg paf;
	reg fmo;
	reg fmo_next;
	reg overflow;
	reg p1;
	reg p2;
	reg f1;
	reg f2;
	reg q1;
	reg q2;
	reg [1:0] gmode;
	reg [ADDR_WIDTH:0] waddr;
	reg [ADDR_WIDTH:0] raddr;
	reg [ADDR_WIDTH:0] gcout_reg;
	reg [ADDR_WIDTH:0] gcout_next;
	reg [ADDR_WIDTH:0] raddr_next;
	reg [ADDR_WIDTH - 1:0] paf_thresh;
	wire overflow_next;
	wire [ADDR_WIDTH:0] waddr_next;
	wire [ADDR_WIDTH:0] gc8out_next;
	wire [ADDR_WIDTH - 1:0] gc16out_next;
	wire [ADDR_WIDTH - 2:0] gc32out_next;
	wire [ADDR_WIDTH:0] tmp;
	wire [ADDR_WIDTH:0] next_count;
	wire [ADDR_WIDTH:0] count;
	wire [ADDR_WIDTH:0] fbytes;
	genvar i;
	assign next_count = fbytes - (waddr_next >= raddr_next ? waddr_next - raddr_next : (~raddr_next + waddr_next) + 1);
	assign count = fbytes - (waddr >= raddr ? waddr - raddr : (~raddr + waddr) + 1);
	assign fbytes = 1 << (DEPTH + 5);
	always @(*) begin
		paf_thresh = wmode[1] ? upaf : (wmode[0] ? upaf << 1 : upaf << 2);
	end
	always @(*)
		case (wmode)
			2'h0, 2'h1, 2'h2: begin
				full_next = (wen ? f1 : f2);
				fmo_next = (wen ? p1 : p2);
				paf_next = (wen ? q1 : q2);
			end
			default: begin
				full_next = 1'b0;
				fmo_next = 1'b0;
				paf_next = 1'b0;
			end
		endcase
	always @(*) begin : PUSH_FULL_FLAGS
		f1 = 1'b0;
		f2 = 1'b0;
		p1 = 1'b0;
		p2 = 1'b0;
		q1 = next_count < {1'b0, paf_thresh};
		q2 = count < {1'b0, paf_thresh};
		case (wmode)
			2'h0:
				case (DEPTH)
					3'h6: begin
						f1 = {~waddr_next[11], waddr_next[10:2]} == raddr_next[11:2];
						f2 = {~waddr[11], waddr[10:2]} == raddr_next[11:2];
						p1 = ((waddr_next[10:2] + 1) & 9'h1ff) == raddr_next[10:2];
						p2 = ((waddr[10:2] + 1) & 9'h1ff) == raddr_next[10:2];
					end
					3'h5: begin
						f1 = {~waddr_next[10], waddr_next[9:2]} == raddr_next[10:2];
						f2 = {~waddr[10], waddr[9:2]} == raddr_next[10:2];
						p1 = ((waddr_next[9:2] + 1) & 8'hff) == raddr_next[9:2];
						p2 = ((waddr[9:2] + 1) & 8'hff) == raddr_next[9:2];
					end
					3'h4: begin
						f1 = {~waddr_next[9], waddr_next[8:2]} == raddr_next[9:2];
						f2 = {~waddr[9], waddr[8:2]} == raddr_next[9:2];
						p1 = ((waddr_next[8:2] + 1) & 7'h7f) == raddr_next[8:2];
						p2 = ((waddr[8:2] + 1) & 7'h7f) == raddr_next[8:2];
					end
					3'h3: begin
						f1 = {~waddr_next[8], waddr_next[7:2]} == raddr_next[8:2];
						f2 = {~waddr[8], waddr[7:2]} == raddr_next[8:2];
						p1 = ((waddr_next[7:2] + 1) & 6'h3f) == raddr_next[7:2];
						p2 = ((waddr[7:2] + 1) & 6'h3f) == raddr_next[7:2];
					end
					3'h2: begin
						f1 = {~waddr_next[7], waddr_next[6:2]} == raddr_next[7:2];
						f2 = {~waddr[7], waddr[6:2]} == raddr_next[7:2];
						p1 = ((waddr_next[6:2] + 1) & 5'h1f) == raddr_next[6:2];
						p2 = ((waddr[6:2] + 1) & 5'h1f) == raddr_next[6:2];
					end
					3'h1: begin
						f1 = {~waddr_next[6], waddr_next[5:2]} == raddr_next[6:2];
						f2 = {~waddr[6], waddr[5:2]} == raddr_next[6:2];
						p1 = ((waddr_next[5:2] + 1) & 4'hf) == raddr_next[5:2];
						p2 = ((waddr[5:2] + 1) & 4'hf) == raddr_next[5:2];
					end
					3'h0: begin
						f1 = {~waddr_next[5], waddr_next[4:2]} == raddr_next[5:2];
						f2 = {~waddr[5], waddr[4:2]} == raddr_next[5:2];
						p1 = ((waddr_next[4:2] + 1) & 3'h7) == raddr_next[4:2];
						p2 = ((waddr[4:2] + 1) & 3'h7) == raddr_next[4:2];
					end
					3'h7: begin
						f1 = {~waddr_next[ADDR_WIDTH], waddr_next[ADDR_WIDTH - 1:2]} == raddr_next[ADDR_WIDTH:2];
						f2 = {~waddr[ADDR_WIDTH], waddr[ADDR_WIDTH - 1:2]} == raddr_next[ADDR_WIDTH:2];
						p1 = ((waddr_next[ADDR_WIDTH - 1:2] + 1) & {ADDR_WIDTH - 2 {1'b1}}) == raddr_next[ADDR_WIDTH - 1:2];
						p2 = ((waddr[ADDR_WIDTH - 1:2] + 1) & {ADDR_WIDTH - 2 {1'b1}}) == raddr_next[ADDR_WIDTH - 1:2];
					end
				endcase
			2'h1:
				case (DEPTH)
					3'h6: begin
						f1 = {~waddr_next[11], waddr_next[10:1]} == raddr_next[11:1];
						f2 = {~waddr[11], waddr[10:1]} == raddr_next[11:1];
						p1 = ((waddr_next[10:1] + 1) & 10'h3ff) == raddr_next[10:1];
						p2 = ((waddr[10:1] + 1) & 10'h3ff) == raddr_next[10:1];
					end
					3'h5: begin
						f1 = {~waddr_next[10], waddr_next[9:1]} == raddr_next[10:1];
						f2 = {~waddr[10], waddr[9:1]} == raddr_next[10:1];
						p1 = ((waddr_next[9:1] + 1) & 9'h1ff) == raddr_next[9:1];
						p2 = ((waddr[9:1] + 1) & 9'h1ff) == raddr_next[9:1];
					end
					3'h4: begin
						f1 = {~waddr_next[9], waddr_next[8:1]} == raddr_next[9:1];
						f2 = {~waddr[9], waddr[8:1]} == raddr_next[9:1];
						p1 = ((waddr_next[8:1] + 1) & 8'hff) == raddr_next[8:1];
						p2 = ((waddr[8:1] + 1) & 8'hff) == raddr_next[8:1];
					end
					3'h3: begin
						f1 = {~waddr_next[8], waddr_next[7:1]} == raddr_next[8:1];
						f2 = {~waddr[8], waddr[7:1]} == raddr_next[8:1];
						p1 = ((waddr_next[7:1] + 1) & 7'h7f) == raddr_next[7:1];
						p2 = ((waddr[7:1] + 1) & 7'h7f) == raddr_next[7:1];
					end
					3'h2: begin
						f1 = {~waddr_next[7], waddr_next[6:1]} == raddr_next[7:1];
						f2 = {~waddr[7], waddr[6:1]} == raddr_next[7:1];
						p1 = ((waddr_next[6:1] + 1) & 6'h3f) == raddr_next[6:1];
						p2 = ((waddr[6:1] + 1) & 6'h3f) == raddr_next[6:1];
					end
					3'h1: begin
						f1 = {~waddr_next[6], waddr_next[5:1]} == raddr_next[6:1];
						f2 = {~waddr[6], waddr[5:1]} == raddr_next[6:1];
						p1 = ((waddr_next[5:1] + 1) & 5'h1f) == raddr_next[5:1];
						p2 = ((waddr[5:1] + 1) & 5'h1f) == raddr_next[5:1];
					end
					3'h0: begin
						f1 = {~waddr_next[5], waddr_next[4:1]} == raddr_next[5:1];
						f2 = {~waddr[5], waddr[4:1]} == raddr_next[5:1];
						p1 = ((waddr_next[4:1] + 1) & 4'hf) == raddr_next[4:1];
						p2 = ((waddr[4:1] + 1) & 4'hf) == raddr_next[4:1];
					end
					3'h7: begin
						f1 = {~waddr_next[ADDR_WIDTH], waddr_next[ADDR_WIDTH - 1:1]} == raddr_next[ADDR_WIDTH:1];
						f2 = {~waddr[ADDR_WIDTH], waddr[ADDR_WIDTH - 1:1]} == raddr_next[ADDR_WIDTH:1];
						p1 = ((waddr_next[ADDR_WIDTH - 1:1] + 1) & {ADDR_WIDTH - 1 {1'b1}}) == raddr_next[ADDR_WIDTH - 1:1];
						p2 = ((waddr[ADDR_WIDTH - 1:1] + 1) & {ADDR_WIDTH - 1 {1'b1}}) == raddr_next[ADDR_WIDTH - 1:1];
					end
				endcase
			2'h2:
				case (DEPTH)
					3'h6: begin
						f1 = {~waddr_next[11], waddr_next[10:0]} == raddr_next[11:0];
						f2 = {~waddr[11], waddr[10:0]} == raddr_next[11:0];
						p1 = ((waddr_next[10:0] + 1) & 11'h7ff) == raddr_next[10:0];
						p2 = ((waddr[10:0] + 1) & 11'h7ff) == raddr_next[10:0];
					end
					3'h5: begin
						f1 = {~waddr_next[10], waddr_next[9:0]} == raddr_next[10:0];
						f2 = {~waddr[10], waddr[9:0]} == raddr_next[10:0];
						p1 = ((waddr_next[9:0] + 1) & 10'h3ff) == raddr_next[9:0];
						p2 = ((waddr[9:0] + 1) & 10'h3ff) == raddr_next[9:0];
					end
					3'h4: begin
						f1 = {~waddr_next[9], waddr_next[8:0]} == raddr_next[9:0];
						f2 = {~waddr[9], waddr[8:0]} == raddr_next[9:0];
						p1 = ((waddr_next[8:0] + 1) & 9'h1ff) == raddr_next[8:0];
						p2 = ((waddr[8:0] + 1) & 9'h1ff) == raddr_next[8:0];
					end
					3'h3: begin
						f1 = {~waddr_next[8], waddr_next[7:0]} == raddr_next[8:0];
						f2 = {~waddr[8], waddr[7:0]} == raddr_next[8:0];
						p1 = ((waddr_next[7:0] + 1) & 8'hff) == raddr_next[7:0];
						p2 = ((waddr[7:0] + 1) & 8'hff) == raddr_next[7:0];
					end
					3'h2: begin
						f1 = {~waddr_next[7], waddr_next[6:0]} == raddr_next[7:0];
						f2 = {~waddr[7], waddr[6:0]} == raddr_next[7:0];
						p1 = ((waddr_next[6:0] + 1) & 7'h7f) == raddr_next[6:0];
						p2 = ((waddr[6:0] + 1) & 7'h7f) == raddr_next[6:0];
					end
					3'h1: begin
						f1 = {~waddr_next[6], waddr_next[5:0]} == raddr_next[6:0];
						f2 = {~waddr[6], waddr[5:0]} == raddr_next[6:0];
						p1 = ((waddr_next[5:0] + 1) & 6'h3f) == raddr_next[5:0];
						p2 = ((waddr[5:0] + 1) & 6'h3f) == raddr_next[5:0];
					end
					3'h0: begin
						f1 = {~waddr_next[5], waddr_next[4:0]} == raddr_next[5:0];
						f2 = {~waddr[5], waddr[4:0]} == raddr_next[5:0];
						p1 = ((waddr_next[4:0] + 1) & 5'h1f) == raddr_next[4:0];
						p2 = ((waddr[4:0] + 1) & 5'h1f) == raddr_next[4:0];
					end
					3'h7: begin
						f1 = {~waddr_next[ADDR_WIDTH], waddr_next[ADDR_WIDTH - 1:0]} == raddr_next[ADDR_WIDTH:0];
						f2 = {~waddr[ADDR_WIDTH], waddr[ADDR_WIDTH - 1:0]} == raddr_next[ADDR_WIDTH:0];
						p1 = ((waddr_next[ADDR_WIDTH - 1:0] + 1) & {ADDR_WIDTH {1'b1}}) == raddr_next[ADDR_WIDTH - 1:0];
						p2 = ((waddr[ADDR_WIDTH - 1:0] + 1) & {ADDR_WIDTH {1'b1}}) == raddr_next[ADDR_WIDTH - 1:0];
					end
				endcase
			2'h3: begin
				f1 = 1'b0;
				f2 = 1'b0;
				p1 = 1'b0;
				p2 = 1'b0;
			end
		endcase
	end
	always @(*)
		case (wmode)
			2'h0: gmode = 2'h0;
			2'h1: gmode = (rmode == 2'h0 ? 2'h0 : 2'h1);
			2'h2: gmode = (rmode == 2'h2 ? 2'h2 : rmode);
			2'h3: gmode = 2'h3;
		endcase
	assign gc8out_next = (waddr_next >> 1) ^ waddr_next;
	assign gc16out_next = (waddr_next >> 2) ^ (waddr_next >> 1);
	assign gc32out_next = (waddr_next >> 3) ^ (waddr_next >> 2);
	always @(*)
		if (wen)
			case (gmode)
				2'h2: gcout_next = gc8out_next;
				2'h1: gcout_next = {1'b0, gc16out_next};
				2'h0: gcout_next = {2'b00, gc32out_next};
				default: gcout_next = {ADDR_PLUS_ONE {1'b0}};
			endcase
		else
			gcout_next = {ADDR_PLUS_ONE {1'b0}};
	always @(posedge wclk or negedge rst_n)
		if (~rst_n) begin
			full <= 1'b0;
			fmo <= 1'b0;
			paf <= 1'b0;
			raddr <= {ADDR_PLUS_ONE {1'b0}};
		end
		else begin
			full <= full_next;
			fmo <= fmo_next;
			paf <= paf_next;
			case (gmode)
				0: raddr <= raddr_next & {{ADDR_WIDTH - 1 {1'b1}}, 2'b00};
				1: raddr <= raddr_next & {{ADDR_WIDTH {1'b1}}, 1'b0};
				2: raddr <= raddr_next & {ADDR_WIDTH + 1 {1'b1}};
				3: raddr <= 12'h000;
			endcase
		end
	assign overflow_next = full & wen;
	always @(posedge wclk or negedge rst_n)
		if (~rst_n)
			overflow <= 1'b0;
		else if (wen == 1'b1)
			overflow <= overflow_next;
	always @(posedge wclk or negedge rst_n)
		if (~rst_n) begin
			waddr <= {ADDR_WIDTH + 1 {1'b0}};
			gcout_reg <= {ADDR_WIDTH + 1 {1'b0}};
		end
		else if (wen == 1'b1) begin
			waddr <= waddr_next;
			gcout_reg <= gcout_next;
		end
	assign gcout = gcout_reg;
	generate
		for (i = 0; i < (ADDR_WIDTH + 1); i = i + 1) begin : genblk1
			assign tmp[i] = ^(gcin >> i);
		end
	endgenerate
	always @(*)
		case (gmode)
			2'h0: raddr_next = {tmp[ADDR_WIDTH - 2:0], 2'b00} & {{ADDR_WIDTH - 1 {1'b1}}, 2'b00};
			2'h1: raddr_next = {tmp[ADDR_WIDTH - 1:0], 1'b0} & {{ADDR_WIDTH {1'b1}}, 1'b0};
			2'h2: raddr_next = {tmp[ADDR_WIDTH:0]} & {ADDR_WIDTH + 1 {1'b1}};
			default: raddr_next = {ADDR_WIDTH + 1 {1'b0}};
		endcase
	assign ff_waddr = waddr[ADDR_WIDTH - 1:0];
	assign pushflags = {full, fmo, paf, overflow};
	assign waddr_next = waddr + (wmode == 2'h0 ? 'h4 : (wmode == 2'h1 ? 'h2 : 'h1));
endmodule
module fifo_pop (
	ren_o,
	popflags,
	out_raddr,
	gcout,
	rst_n,
	rclk,
	ren_in,
	rmode,
	wmode,
	gcin,
	upae
);
	parameter ADDR_WIDTH = 11;
	parameter FIFO_WIDTH = 3'd2;
	parameter DEPTH = 6;
	output wire ren_o;
	output wire [3:0] popflags;
	output reg [ADDR_WIDTH - 1:0] out_raddr;
	output wire [ADDR_WIDTH:0] gcout;
	input rst_n;
	(* clkbuf_sink *)
	input rclk;
	input ren_in;
	input [1:0] rmode;
	input [1:0] wmode;
	input [ADDR_WIDTH:0] gcin;
	input [ADDR_WIDTH - 1:0] upae;
	localparam ADDR_PLUS_ONE = ADDR_WIDTH + 1;
	reg empty;
	reg epo;
	reg pae;
	reg underflow;
	reg e1;
	reg e2;
	reg o1;
	reg o2;
	reg q1;
	reg q2;
	reg [1:0] bwl_sel;
	reg [1:0] gmode;
	reg [ADDR_WIDTH - 1:0] ff_raddr;
	reg [ADDR_WIDTH:0] waddr;
	reg [ADDR_WIDTH:0] raddr;
	reg [ADDR_WIDTH:0] gcout_reg;
	reg [ADDR_WIDTH:0] gcout_next;
	reg [ADDR_WIDTH:0] waddr_next;
	reg [ADDR_WIDTH - 1:0] pae_thresh;
	wire ren_out;
	wire empty_next;
	wire pae_next;
	wire epo_next;
	wire [ADDR_WIDTH - 2:0] gc32out_next;
	wire [ADDR_WIDTH - 1:0] gc16out_next;
	wire [ADDR_WIDTH:0] gc8out_next;
	wire [ADDR_WIDTH:0] raddr_next;
	wire [ADDR_WIDTH - 1:0] ff_raddr_next;
	wire [ADDR_WIDTH:0] tmp;
	wire [ADDR_PLUS_ONE:0] next_count;
	wire [ADDR_PLUS_ONE:0] count;
	wire [ADDR_PLUS_ONE:0] fbytes;
	genvar i;
	assign next_count = waddr - raddr_next;
	assign count = waddr - raddr;
	assign fbytes = 1 << (DEPTH + 5);
	always @(*) pae_thresh = rmode[1] ? upae : (rmode[0] ? upae << 1 : upae << 2);
	assign ren_out = (empty ? 1'b1 : ren_in);
	always @(*)
		case (rmode)
			2'h0: gmode = 2'h0;
			2'h1: gmode = (wmode == 2'h0 ? 2'h0 : 2'h1);
			2'h2: gmode = (wmode == 2'h2 ? 2'h2 : wmode);
			2'h3: gmode = 2'h3;
		endcase
	always @(*) begin
		e1 = 1'b0;
		e2 = 1'b0;
		o1 = 1'b0;
		o2 = 1'b0;
		q1 = next_count < {1'b0, pae_thresh};
		q2 = count < {1'b0, pae_thresh};
		case (rmode)
			2'h0: begin
				e1 = raddr_next[ADDR_WIDTH:2] == waddr_next[ADDR_WIDTH:2];
				e2 = raddr[ADDR_WIDTH:2] == waddr_next[ADDR_WIDTH:2];
				o1 = (raddr_next[ADDR_WIDTH:2] + 1) == waddr_next[ADDR_WIDTH:2];
				o2 = (raddr[ADDR_WIDTH:2] + 1) == waddr_next[ADDR_WIDTH:2];
			end
			2'h1: begin
				e1 = raddr_next[ADDR_WIDTH:1] == waddr_next[ADDR_WIDTH:1];
				e2 = raddr[ADDR_WIDTH:1] == waddr_next[ADDR_WIDTH:1];
				o1 = (raddr_next[ADDR_WIDTH:1] + 1) == waddr_next[ADDR_WIDTH:1];
				o2 = (raddr[ADDR_WIDTH:1] + 1) == waddr_next[ADDR_WIDTH:1];
			end
			2'h2: begin
				e1 = raddr_next[ADDR_WIDTH:0] == waddr_next[ADDR_WIDTH:0];
				e2 = raddr[ADDR_WIDTH:0] == waddr_next[ADDR_WIDTH:0];
				o1 = (raddr_next[ADDR_WIDTH:0] + 1) == waddr_next[ADDR_WIDTH:0];
				o2 = (raddr[ADDR_WIDTH:0] + 1) == waddr_next[11:0];
			end
			2'h3: begin
				e1 = 1'b0;
				e2 = 1'b0;
				o1 = 1'b0;
				o2 = 1'b0;
			end
		endcase
	end
	assign empty_next = (ren_in & !empty ? e1 : e2);
	assign epo_next = (ren_in & !empty ? o1 : o2);
	assign pae_next = (ren_in & !empty ? q1 : q2);
	always @(posedge rclk or negedge rst_n)
		if (~rst_n) begin
			empty <= 1'b1;
			pae <= 1'b1;
			epo <= 1'b0;
		end
		else begin
			empty <= empty_next;
			pae <= pae_next;
			epo <= epo_next;
		end
	assign gc8out_next = (raddr_next >> 1) ^ raddr_next;
	assign gc16out_next = (raddr_next >> 2) ^ (raddr_next >> 1);
	assign gc32out_next = (raddr_next >> 3) ^ (raddr_next >> 2);
	always @(*)
		if (ren_in)
			case (gmode)
				2'h2: gcout_next = gc8out_next;
				2'h1: gcout_next = {1'b0, gc16out_next};
				2'h0: gcout_next = {2'b00, gc32out_next};
				default: gcout_next = 'h0;
			endcase
		else
			gcout_next = 'h0;
	always @(posedge rclk or negedge rst_n)
		if (~rst_n)
			waddr <= 12'h000;
		else
			waddr <= waddr_next;
	always @(posedge rclk or negedge rst_n)
		if (~rst_n) begin
			underflow <= 1'b0;
			bwl_sel <= 2'h0;
			gcout_reg <= 12'h000;
		end
		else if (ren_in) begin
			underflow <= empty;
			if (!empty) begin
				bwl_sel <= raddr_next[1:0];
				gcout_reg <= gcout_next;
			end
		end
	generate
		for (i = 0; i < (ADDR_WIDTH + 1); i = i + 1) begin : genblk1
			assign tmp[i] = ^(gcin >> i);
		end
	endgenerate
	always @(*)
		case (gmode)
			2'h0: waddr_next = {tmp[ADDR_WIDTH - 2:0], 2'b00} & {{ADDR_WIDTH - 1 {1'b1}}, 2'b00};
			2'h1: waddr_next = {tmp[ADDR_WIDTH - 1:0], 1'b0} & {{ADDR_WIDTH {1'b1}}, 1'b0};
			2'h2: waddr_next = {tmp[ADDR_WIDTH:0]} & {ADDR_PLUS_ONE {1'b1}};
			default: waddr_next = {ADDR_PLUS_ONE {1'b0}};
		endcase
	assign ff_raddr_next = ff_raddr + (rmode == 2'h0 ? 'h4 : (rmode == 2'h1 ? 'h2 : 'h1));
	assign raddr_next = raddr + (rmode == 2'h0 ? 'h4 : (rmode == 2'h1 ? 'h2 : 'h1));
	always @(posedge rclk or negedge rst_n)
		if (~rst_n)
			ff_raddr <= 1'sb0;
		else if (empty & ~empty_next)
			ff_raddr <= raddr_next[ADDR_WIDTH - 1:0];
		else if ((ren_in & !empty) & ~empty_next)
			ff_raddr <= ff_raddr_next;
	always @(posedge rclk or negedge rst_n)
		if (~rst_n)
			raddr <= 12'h000;
		else if (ren_in & !empty)
			raddr <= raddr_next;
	always @(*)
		case (FIFO_WIDTH)
			3'h2: out_raddr = {ff_raddr[ADDR_WIDTH - 1:1], bwl_sel[0]};
			3'h4: out_raddr = {ff_raddr[ADDR_WIDTH - 1:2], bwl_sel};
			default: out_raddr = ff_raddr[ADDR_WIDTH - 1:0];
		endcase
	assign ren_o = ren_out;
	assign gcout = gcout_reg;
	assign popflags = {empty, epo, pae, underflow};
endmodule
\`default_nettype none
`}},sf2:{"arith_map.v":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

(* techmap_celltype = "$alu" *)
module \\$__SF2_ALU (A, B, CI, BI, X, Y, CO);
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;
	parameter A_WIDTH = 1;
	parameter B_WIDTH = 1;
	parameter Y_WIDTH = 1;

	(* force_downto *)
	input [A_WIDTH-1:0] A;
	(* force_downto *)
	input [B_WIDTH-1:0] B;
	(* force_downto *)
	output [Y_WIDTH-1:0] X, Y;

	input CI, BI;
	(* force_downto *)
	output [Y_WIDTH-1:0] CO;

	wire _TECHMAP_FAIL_ = Y_WIDTH <= 2;

	(* force_downto *)
	wire [Y_WIDTH-1:0] AA, BB;
	\\$pos #(.A_SIGNED(A_SIGNED), .A_WIDTH(A_WIDTH), .Y_WIDTH(Y_WIDTH)) A_conv (.A(A), .Y(AA));
	\\$pos #(.A_SIGNED(B_SIGNED), .A_WIDTH(B_WIDTH), .Y_WIDTH(Y_WIDTH)) B_conv (.A(B), .Y(BB));

	(* force_downto *)
	wire [Y_WIDTH-1:0] C = {CO, CI};

	genvar i;
	generate for (i = 0; i < Y_WIDTH; i = i + 1) begin:slice
		ARI1 #(
			// G = F1 = A[i] & (B[i]^BI)
			// Y = F0 = A[i]^B[i]^BI
			// P = Y
			//		 ADCB
			.INIT(20'b 01_11_0010_1000_1001_0110)
		) carry (
			.A(1'b0),
			.B(AA[i]),
			.C(BB[i]),
			.D(BI),
			.FCI(C[i]),
			.Y(X[i]),
			.S(Y[i]),
			.FCO(CO[i])
		);
	end endgenerate
endmodule

`,"cells_map.v":`module \\$_DFFE_PN0P_ (input D, C, R, E, output Q);
  SLE _TECHMAP_REPLACE_ (.D(D), .CLK(C), .EN(E), .ALn(R), .ADn(1'b1), .SLn(1'b1), .SD(1'b0), .LAT(1'b0), .Q(Q));
endmodule

module \\$_DFFE_PN1P_ (input D, C, R, E, output Q);
  SLE _TECHMAP_REPLACE_ (.D(D), .CLK(C), .EN(E), .ALn(R), .ADn(1'b0), .SLn(1'b1), .SD(1'b0), .LAT(1'b0), .Q(Q));
endmodule

module \\$_SDFFCE_PN0P_ (input D, C, R, E, output Q);
  SLE _TECHMAP_REPLACE_ (.D(D), .CLK(C), .EN(E), .ALn(1'b1), .ADn(1'b0), .SLn(R), .SD(1'b0), .LAT(1'b0), .Q(Q));
endmodule

module \\$_SDFFCE_PN1P_ (input D, C, R, E, output Q);
  SLE _TECHMAP_REPLACE_ (.D(D), .CLK(C), .EN(E), .ALn(1'b1), .ADn(1'b0), .SLn(R), .SD(1'b1), .LAT(1'b0), .Q(Q));
endmodule

module \\$_DLATCH_PN0_ (input D, R, E, output Q);
  SLE _TECHMAP_REPLACE_ (.D(D), .CLK(E), .EN(1'b1), .ALn(R), .ADn(1'b1), .SLn(1'b1), .SD(1'b0), .LAT(1'b1), .Q(Q));
endmodule

module \\$_DLATCH_PN1_ (input D, R, E, output Q);
  SLE _TECHMAP_REPLACE_ (.D(D), .CLK(E), .EN(1'b1), .ALn(R), .ADn(1'b0), .SLn(1'b1), .SD(1'b0), .LAT(1'b1), .Q(Q));
endmodule

\`ifndef NO_LUT
module \\$lut (A, Y);
  parameter WIDTH = 0;
  parameter LUT = 0;

  (* force_downto *)
  input [WIDTH-1:0] A;
  output Y;

  generate
    if (WIDTH == 1) begin
      CFG1 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.Y(Y), .A(A[0]));
    end else
    if (WIDTH == 2) begin
      CFG2 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.Y(Y), .A(A[0]), .B(A[1]));
    end else
    if (WIDTH == 3) begin
      CFG3 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.Y(Y), .A(A[0]), .B(A[1]), .C(A[2]));
    end else
    if (WIDTH == 4) begin
      CFG4 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.Y(Y), .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));
    end else begin
      wire _TECHMAP_FAIL_ = 1;
    end
  endgenerate
endmodule
\`endif
`,"cells_sim.v":`// https://coredocs.s3.amazonaws.com/Libero/12_0_0/Tool/sf2_mlg.pdf

module AND2 (
	input A, B,
	output Y
);
	assign Y = A & B;
endmodule

module AND3 (
	input A, B, C,
	output Y
);
	assign Y = A & B & C;
endmodule

module AND4 (
	input A, B, C, D,
	output Y
);
	assign Y = A & B & C & D;
endmodule

module CFG1 (
	output Y,
	input A
);
	parameter [1:0] INIT = 2'h0;
	assign Y = INIT >> A;
endmodule

module CFG2 (
	output Y,
	input A,
	input B
);
	parameter [3:0] INIT = 4'h0;
	assign Y = INIT >> {B, A};
endmodule

module CFG3 (
	output Y,
	input A,
	input B,
	input C
);
	parameter [7:0] INIT = 8'h0;
	assign Y = INIT >> {C, B, A};
endmodule

module CFG4 (
	output Y,
	input A,
	input B,
	input C,
	input D
);
	parameter [15:0] INIT = 16'h0;
	assign Y = INIT >> {D, C, B, A};
endmodule

module BUFF (
	input A,
	output Y
);
	assign Y = A;
endmodule

module BUFD (
	input A,
	output Y
);
	assign Y = A;
endmodule

module CLKINT (
	input A,
	(* clkbuf_driver *)
	output Y
);
	assign Y = A;
endmodule

module CLKINT_PRESERVE (
	input A,
	(* clkbuf_driver *)
	output Y
);
	assign Y = A;
endmodule

module GCLKINT (
	input A, EN,
	(* clkbuf_driver *)
	output Y
);
	assign Y = A & EN;
endmodule

module RCLKINT (
	input A,
	(* clkbuf_driver *)
	output Y
);
	assign Y = A;
endmodule

module RGCLKINT (
	input A, EN,
	(* clkbuf_driver *)
	output Y
);
	assign Y = A & EN;
endmodule

module SLE (
	output Q,
	input ADn,
	input ALn,
	(* clkbuf_sink *)
	input CLK,
	input D,
	input LAT,
	input SD,
	input EN,
	input SLn
);
	reg q_latch, q_ff;

	always @(posedge CLK, negedge ALn) begin
		if (!ALn) begin
			q_ff <= !ADn;
		end else if (EN) begin
			if (!SLn)
				q_ff <= SD;
			else
				q_ff <= D;
		end
	end

	always @* begin
		if (!ALn) begin
			q_latch <= !ADn;
		end else if (CLK && EN) begin
			if (!SLn)
				q_ff <= SD;
			else
				q_ff <= D;
		end
	end

	assign Q = LAT ? q_latch : q_ff;
endmodule

module ARI1 (
	input A, B, C, D, FCI,
	output Y, S, FCO
);
	parameter [19:0] INIT = 20'h0;
	wire [2:0] Fsel = {D, C, B};
	wire F0 = INIT[Fsel];
	wire F1 = INIT[8 + Fsel];
	wire Yout = A ? F1 : F0;
	assign Y = Yout;
	assign S = FCI ^ Yout;
	wire G = INIT[16] ? (INIT[17] ? F1 : F0) : INIT[17];
	wire P = INIT[19] ? 1'b1 : (INIT[18] ? Yout : 1'b0);
	assign FCO = P ? FCI : G;
endmodule

// module FCEND_BUFF
// module FCINIT_BUFF
// module FLASH_FREEZE
// module OSCILLATOR
// module SYSCTRL_RESET_STATUS
// module LIVE_PROBE_FB

(* blackbox *)
module GCLKBUF (
	(* iopad_external_pin *)
	input PAD,
	input EN,
	(* clkbuf_driver *)
	output Y
);
endmodule

(* blackbox *)
module GCLKBUF_DIFF (
	(* iopad_external_pin *)
	input PADP,
	(* iopad_external_pin *)
	input PADN,
	input EN,
	(* clkbuf_driver *)
	output Y
);
endmodule

(* blackbox *)
module GCLKBIBUF (
	input D,
	input E,
	input EN,
	(* iopad_external_pin *)
	inout PAD,
	(* clkbuf_driver *)
	output Y
);
endmodule

// module DFN1
// module DFN1C0
// module DFN1E1
// module DFN1E1C0
// module DFN1E1P0
// module DFN1P0
// module DLN1
// module DLN1C0
// module DLN1P0

module INV (
	input A,
	output Y
);
	assign Y = !A;
endmodule

module INVD (
	input A,
	output Y
);
	assign Y = !A;
endmodule

module MX2 (
	input A, B, S,
	output Y
);
	assign Y = S ? B : A;
endmodule

module MX4 (
	input D0, D1, D2, D3, S0, S1,
	output Y
);
	assign Y = S1 ? (S0 ? D3 : D2) : (S0 ? D1 : D0);
endmodule

module NAND2 (
	input A, B,
	output Y
);
	assign Y = !(A & B);
endmodule

module NAND3 (
	input A, B, C,
	output Y
);
	assign Y = !(A & B & C);
endmodule

module NAND4 (
	input A, B, C, D,
	output Y
);
	assign Y = !(A & B & C & D);
endmodule

module NOR2 (
	input A, B,
	output Y
);
	assign Y = !(A | B);
endmodule

module NOR3 (
	input A, B, C,
	output Y
);
	assign Y = !(A | B | C);
endmodule

module NOR4 (
	input A, B, C, D,
	output Y
);
	assign Y = !(A | B | C | D);
endmodule

module OR2 (
	input A, B,
	output Y
);
	assign Y = A | B;
endmodule

module OR3 (
	input A, B, C,
	output Y
);
	assign Y = A | B | C;
endmodule

module OR4 (
	input A, B, C, D,
	output Y
);
	assign Y = A | B | C | D;
endmodule

module XOR2 (
	input A, B,
	output Y
);
	assign Y = A ^ B;
endmodule

module XOR3 (
	input A, B, C,
	output Y
);
	assign Y = A ^ B ^ C;
endmodule

module XOR4 (
	input A, B, C, D,
	output Y
);
	assign Y = A ^ B ^ C ^ D;
endmodule

module XOR8 (
	input A, B, C, D, E, F, G, H,
	output Y
);
	assign Y = A ^ B ^ C ^ D ^ E ^ F ^ G ^ H;
endmodule

// module UJTAG

module BIBUF (
	input D,
	input E,
	(* iopad_external_pin *)
	inout PAD,
	output Y
);
	parameter IOSTD = "";
	assign PAD = E ? D : 1'bz;
	assign Y = PAD;
endmodule

(* blackbox *)
module BIBUF_DIFF (
	input D,
	input E,
	(* iopad_external_pin *)
	inout PADP,
	(* iopad_external_pin *)
	inout PADN,
	output Y
);
	parameter IOSTD = "";
endmodule

module CLKBIBUF (
	input D,
	input E,
	(* iopad_external_pin *)
	inout PAD,
	(* clkbuf_driver *)
	output Y
);
	parameter IOSTD = "";
	assign PAD = E ? D : 1'bz;
	assign Y = PAD;
endmodule

module CLKBUF (
	(* iopad_external_pin *)
	input PAD,
	(* clkbuf_driver *)
	output Y
);
	parameter IOSTD = "";
	assign Y = PAD;
endmodule

(* blackbox *)
module CLKBUF_DIFF (
	(* iopad_external_pin *)
	input PADP,
	(* iopad_external_pin *)
	input PADN,
	(* clkbuf_driver *)
	output Y
);
	parameter IOSTD = "";
endmodule

module INBUF (
	(* iopad_external_pin *)
	input PAD,
	output Y
);
	parameter IOSTD = "";
	assign Y = PAD;
endmodule

(* blackbox *)
module INBUF_DIFF (
	(* iopad_external_pin *)
	input PADP,
	(* iopad_external_pin *)
	input PADN,
	output Y
);
	parameter IOSTD = "";
endmodule

module OUTBUF (
	input D,
	(* iopad_external_pin *)
	output PAD
);
	parameter IOSTD = "";
	assign PAD = D;
endmodule

(* blackbox *)
module OUTBUF_DIFF (
	input D,
	(* iopad_external_pin *)
	output PADP,
	(* iopad_external_pin *)
	output PADN
);
	parameter IOSTD = "";
endmodule

module TRIBUFF (
	input D,
	input E,
	(* iopad_external_pin *)
	output PAD
);
	parameter IOSTD = "";
	assign PAD = E ? D : 1'bz;
endmodule

(* blackbox *)
module TRIBUFF_DIFF (
	input D,
	input E,
	(* iopad_external_pin *)
	output PADP,
	(* iopad_external_pin *)
	output PADN
);
	parameter IOSTD = "";
endmodule

// module DDR_IN
// module DDR_OUT
// module RAM1K18
// module RAM64x18
// module MACC

(* blackbox *)
module SYSRESET (
	(* iopad_external_pin *)
	input  DEVRST_N,
	output POWER_ON_RESET_N);
endmodule


(* blackbox *)
module XTLOSC (
	(* iopad_external_pin *)
	input  XTL,
	output CLKOUT);
	parameter [1:0] MODE = 2'h3;
	parameter real FREQUENCY = 20.0;
endmodule

(* blackbox *)
module RAM1K18 (
	input [13:0]  A_ADDR,
	input [2:0]   A_BLK,
	(* clkbuf_sink *)
	input	      A_CLK,
	input [17:0]  A_DIN,
	output [17:0] A_DOUT,
	input [1:0]   A_WEN,
	input [2:0]   A_WIDTH,
	input	      A_WMODE,
	input	      A_ARST_N,
	input	      A_DOUT_LAT,
	input	      A_DOUT_ARST_N,
	(* clkbuf_sink *)
	input	      A_DOUT_CLK,
	input	      A_DOUT_EN,
	input	      A_DOUT_SRST_N,

	input [13:0]  B_ADDR,
	input [2:0]   B_BLK,
	(* clkbuf_sink *)
	input	      B_CLK,
	input [17:0]  B_DIN,
	output [17:0] B_DOUT,
	input [1:0]   B_WEN,
	input [2:0]   B_WIDTH,
	input	      B_WMODE,
	input	      B_ARST_N,
	input	      B_DOUT_LAT,
	input	      B_DOUT_ARST_N,
	(* clkbuf_sink *)
	input	      B_DOUT_CLK,
	input	      B_DOUT_EN,
	input	      B_DOUT_SRST_N,

	input	      A_EN,
	input	      B_EN,
	input	      SII_LOCK,
	output	      BUSY);
endmodule

(* blackbox *)
module RAM64x18 (
	input [9:0]   A_ADDR,
	input [1:0]   A_BLK,
	input [2:0]   A_WIDTH,
	output [17:0] A_DOUT,
	input	      A_DOUT_ARST_N,
	(* clkbuf_sink *)
	input	      A_DOUT_CLK,
	input	      A_DOUT_EN,
	input	      A_DOUT_LAT,
	input	      A_DOUT_SRST_N,
	(* clkbuf_sink *)
	input	      A_ADDR_CLK,
	input	      A_ADDR_EN,
	input	      A_ADDR_LAT,
	input	      A_ADDR_SRST_N,
	input	      A_ADDR_ARST_N,

	input [9:0]   B_ADDR,
	input [1:0]   B_BLK,
	input [2:0]   B_WIDTH,
	output [17:0] B_DOUT,
	input	      B_DOUT_ARST_N,
	(* clkbuf_sink *)
	input	      B_DOUT_CLK,
	input	      B_DOUT_EN,
	input	      B_DOUT_LAT,
	input	      B_DOUT_SRST_N,
	(* clkbuf_sink *)
	input	      B_ADDR_CLK,
	input	      B_ADDR_EN,
	input	      B_ADDR_LAT,
	input	      B_ADDR_SRST_N,
	input	      B_ADDR_ARST_N,

	input [9:0]   C_ADDR,
	(* clkbuf_sink *)
	input	      C_CLK,
	input [17:0]  C_DIN,
	input	      C_WEN,
	input [1:0]   C_BLK,
	input [2:0]   C_WIDTH,

	input	      A_EN,
	input	      B_EN,
	input	      C_EN,
	input	      SII_LOCK,
	output	      BUSY);
endmodule
`},"simcells.v":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 *  ---
 *
 *  The internal logic cell simulation library.
 *
 *  This Verilog library contains simple simulation models for the internal
 *  logic cells ($_NOT_ , $_AND_ , ...) that are generated by the default technology
 *  mapper (see "techmap.v" in this directory) and expected by the "abc" pass.
 *
 */

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_BUF_ (A, Y)
//-
//- A buffer. This cell type is always optimized away by the opt_clean pass.
//-
//- Truth table:    A | Y
//-                ---+---
//-                 0 | 0
//-                 1 | 1
//-
module \\$_BUF_ (A, Y);
input A;
output Y;
assign Y = A;
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_NOT_ (A, Y)
//-
//- An inverter gate.
//-
//- Truth table:    A | Y
//-                ---+---
//-                 0 | 1
//-                 1 | 0
//-
module \\$_NOT_ (A, Y);
input A;
output Y;
assign Y = ~A;
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_AND_ (A, B, Y)
//-
//- A 2-input AND gate.
//-
//- Truth table:    A B | Y
//-                -----+---
//-                 0 0 | 0
//-                 0 1 | 0
//-                 1 0 | 0
//-                 1 1 | 1
//-
module \\$_AND_ (A, B, Y);
input A, B;
output Y;
assign Y = A & B;
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_NAND_ (A, B, Y)
//-
//- A 2-input NAND gate.
//-
//- Truth table:    A B | Y
//-                -----+---
//-                 0 0 | 1
//-                 0 1 | 1
//-                 1 0 | 1
//-                 1 1 | 0
//-
module \\$_NAND_ (A, B, Y);
input A, B;
output Y;
assign Y = ~(A & B);
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_OR_ (A, B, Y)
//-
//- A 2-input OR gate.
//-
//- Truth table:    A B | Y
//-                -----+---
//-                 0 0 | 0
//-                 0 1 | 1
//-                 1 0 | 1
//-                 1 1 | 1
//-
module \\$_OR_ (A, B, Y);
input A, B;
output Y;
assign Y = A | B;
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_NOR_ (A, B, Y)
//-
//- A 2-input NOR gate.
//-
//- Truth table:    A B | Y
//-                -----+---
//-                 0 0 | 1
//-                 0 1 | 0
//-                 1 0 | 0
//-                 1 1 | 0
//-
module \\$_NOR_ (A, B, Y);
input A, B;
output Y;
assign Y = ~(A | B);
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_XOR_ (A, B, Y)
//-
//- A 2-input XOR gate.
//-
//- Truth table:    A B | Y
//-                -----+---
//-                 0 0 | 0
//-                 0 1 | 1
//-                 1 0 | 1
//-                 1 1 | 0
//-
module \\$_XOR_ (A, B, Y);
input A, B;
output Y;
assign Y = A ^ B;
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_XNOR_ (A, B, Y)
//-
//- A 2-input XNOR gate.
//-
//- Truth table:    A B | Y
//-                -----+---
//-                 0 0 | 1
//-                 0 1 | 0
//-                 1 0 | 0
//-                 1 1 | 1
//-
module \\$_XNOR_ (A, B, Y);
input A, B;
output Y;
assign Y = ~(A ^ B);
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_ANDNOT_ (A, B, Y)
//-
//- A 2-input AND-NOT gate.
//-
//- Truth table:    A B | Y
//-                -----+---
//-                 0 0 | 0
//-                 0 1 | 0
//-                 1 0 | 1
//-                 1 1 | 0
//-
module \\$_ANDNOT_ (A, B, Y);
input A, B;
output Y;
assign Y = A & (~B);
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_ORNOT_ (A, B, Y)
//-
//- A 2-input OR-NOT gate.
//-
//- Truth table:    A B | Y
//-                -----+---
//-                 0 0 | 1
//-                 0 1 | 0
//-                 1 0 | 1
//-                 1 1 | 1
//-
module \\$_ORNOT_ (A, B, Y);
input A, B;
output Y;
assign Y = A | (~B);
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_MUX_ (A, B, S, Y)
//-
//- A 2-input MUX gate.
//-
//- Truth table:    A B S | Y
//-                -------+---
//-                 a - 0 | a
//-                 - b 1 | b
//-
module \\$_MUX_ (A, B, S, Y);
input A, B, S;
output Y;
assign Y = S ? B : A;
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_NMUX_ (A, B, S, Y)
//-
//- A 2-input inverting MUX gate.
//-
//- Truth table:    A B S | Y
//-                -------+---
//-                 0 - 0 | 1
//-                 1 - 0 | 0
//-                 - 0 1 | 1
//-                 - 1 1 | 0
//-
module \\$_NMUX_ (A, B, S, Y);
input A, B, S;
output Y;
assign Y = S ? !B : !A;
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_MUX4_ (A, B, C, D, S, T, Y)
//-
//- A 4-input MUX gate.
//-
//- Truth table:    A B C D S T | Y
//-                -------------+---
//-                 a - - - 0 0 | a
//-                 - b - - 1 0 | b
//-                 - - c - 0 1 | c
//-                 - - - d 1 1 | d
//-
module \\$_MUX4_ (A, B, C, D, S, T, Y);
input A, B, C, D, S, T;
output Y;
assign Y = T ? (S ? D : C) :
               (S ? B : A);
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_MUX8_ (A, B, C, D, E, F, G, H, S, T, U, Y)
//-
//- An 8-input MUX gate.
//-
//- Truth table:    A B C D E F G H S T U | Y
//-                -----------------------+---
//-                 a - - - - - - - 0 0 0 | a
//-                 - b - - - - - - 1 0 0 | b
//-                 - - c - - - - - 0 1 0 | c
//-                 - - - d - - - - 1 1 0 | d
//-                 - - - - e - - - 0 0 1 | e
//-                 - - - - - f - - 1 0 1 | f
//-                 - - - - - - g - 0 1 1 | g
//-                 - - - - - - - h 1 1 1 | h
//-
module \\$_MUX8_ (A, B, C, D, E, F, G, H, S, T, U, Y);
input A, B, C, D, E, F, G, H, S, T, U;
output Y;
assign Y = U ? T ? (S ? H : G) :
                   (S ? F : E) :
               T ? (S ? D : C) :
                   (S ? B : A);
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_MUX16_ (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, S, T, U, V, Y)
//-
//- A 16-input MUX gate.
//-
//- Truth table:    A B C D E F G H I J K L M N O P S T U V | Y
//-                -----------------------------------------+---
//-                 a - - - - - - - - - - - - - - - 0 0 0 0 | a
//-                 - b - - - - - - - - - - - - - - 1 0 0 0 | b
//-                 - - c - - - - - - - - - - - - - 0 1 0 0 | c
//-                 - - - d - - - - - - - - - - - - 1 1 0 0 | d
//-                 - - - - e - - - - - - - - - - - 0 0 1 0 | e
//-                 - - - - - f - - - - - - - - - - 1 0 1 0 | f
//-                 - - - - - - g - - - - - - - - - 0 1 1 0 | g
//-                 - - - - - - - h - - - - - - - - 1 1 1 0 | h
//-                 - - - - - - - - i - - - - - - - 0 0 0 1 | i
//-                 - - - - - - - - - j - - - - - - 1 0 0 1 | j
//-                 - - - - - - - - - - k - - - - - 0 1 0 1 | k
//-                 - - - - - - - - - - - l - - - - 1 1 0 1 | l
//-                 - - - - - - - - - - - - m - - - 0 0 1 1 | m
//-                 - - - - - - - - - - - - - n - - 1 0 1 1 | n
//-                 - - - - - - - - - - - - - - o - 0 1 1 1 | o
//-                 - - - - - - - - - - - - - - - p 1 1 1 1 | p
//-
module \\$_MUX16_ (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, S, T, U, V, Y);
input A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, S, T, U, V;
output Y;
assign Y = V ? U ? T ? (S ? P : O) :
                       (S ? N : M) :
                   T ? (S ? L : K) :
                       (S ? J : I) :
               U ? T ? (S ? H : G) :
                       (S ? F : E) :
                   T ? (S ? D : C) :
                       (S ? B : A);
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_AOI3_ (A, B, C, Y)
//-
//- A 3-input And-Or-Invert gate.
//-
//- Truth table:    A B C | Y
//-                -------+---
//-                 0 0 0 | 1
//-                 0 0 1 | 0
//-                 0 1 0 | 1
//-                 0 1 1 | 0
//-                 1 0 0 | 1
//-                 1 0 1 | 0
//-                 1 1 0 | 0
//-                 1 1 1 | 0
//-
module \\$_AOI3_ (A, B, C, Y);
input A, B, C;
output Y;
assign Y = ~((A & B) | C);
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_OAI3_ (A, B, C, Y)
//-
//- A 3-input Or-And-Invert gate.
//-
//- Truth table:    A B C | Y
//-                -------+---
//-                 0 0 0 | 1
//-                 0 0 1 | 1
//-                 0 1 0 | 1
//-                 0 1 1 | 0
//-                 1 0 0 | 1
//-                 1 0 1 | 0
//-                 1 1 0 | 1
//-                 1 1 1 | 0
//-
module \\$_OAI3_ (A, B, C, Y);
input A, B, C;
output Y;
assign Y = ~((A | B) & C);
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_AOI4_ (A, B, C, Y)
//-
//- A 4-input And-Or-Invert gate.
//-
//- Truth table:    A B C D | Y
//-                ---------+---
//-                 0 0 0 0 | 1
//-                 0 0 0 1 | 1
//-                 0 0 1 0 | 1
//-                 0 0 1 1 | 0
//-                 0 1 0 0 | 1
//-                 0 1 0 1 | 1
//-                 0 1 1 0 | 1
//-                 0 1 1 1 | 0
//-                 1 0 0 0 | 1
//-                 1 0 0 1 | 1
//-                 1 0 1 0 | 1
//-                 1 0 1 1 | 0
//-                 1 1 0 0 | 0
//-                 1 1 0 1 | 0
//-                 1 1 1 0 | 0
//-                 1 1 1 1 | 0
//-
module \\$_AOI4_ (A, B, C, D, Y);
input A, B, C, D;
output Y;
assign Y = ~((A & B) | (C & D));
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_OAI4_ (A, B, C, Y)
//-
//- A 4-input Or-And-Invert gate.
//-
//- Truth table:    A B C D | Y
//-                ---------+---
//-                 0 0 0 0 | 1
//-                 0 0 0 1 | 1
//-                 0 0 1 0 | 1
//-                 0 0 1 1 | 1
//-                 0 1 0 0 | 1
//-                 0 1 0 1 | 0
//-                 0 1 1 0 | 0
//-                 0 1 1 1 | 0
//-                 1 0 0 0 | 1
//-                 1 0 0 1 | 0
//-                 1 0 1 0 | 0
//-                 1 0 1 1 | 0
//-                 1 1 0 0 | 1
//-                 1 1 0 1 | 0
//-                 1 1 1 0 | 0
//-                 1 1 1 1 | 0
//-
module \\$_OAI4_ (A, B, C, D, Y);
input A, B, C, D;
output Y;
assign Y = ~((A | B) & (C | D));
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_TBUF_ (A, E, Y)
//-
//- A tri-state buffer.
//-
//- Truth table:    A E | Y
//-                -----+---
//-                 a 1 | a
//-                 - 0 | z
//-
module \\$_TBUF_ (A, E, Y);
input A, E;
output Y;
assign Y = E ? A : 1'bz;
endmodule

// NOTE: the following cell types are autogenerated.  DO NOT EDIT them manually,
// instead edit the templates in gen_ff_types.py and rerun it.

// START AUTOGENERATED CELL TYPES

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SR_NN_ (S, R, Q)
//-
//- A set-reset latch with negative polarity SET and negative polarity RESET.
//-
//- Truth table:    S R | Q
//-                -----+---
//-                 - 0 | 0
//-                 0 - | 1
//-                 - - | q
//-
module \\$_SR_NN_ (S, R, Q);
input S, R;
output reg Q;
always @* begin
	if (R == 0)
		Q <= 0;
	else if (S == 0)
		Q <= 1;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SR_NP_ (S, R, Q)
//-
//- A set-reset latch with negative polarity SET and positive polarity RESET.
//-
//- Truth table:    S R | Q
//-                -----+---
//-                 - 1 | 0
//-                 0 - | 1
//-                 - - | q
//-
module \\$_SR_NP_ (S, R, Q);
input S, R;
output reg Q;
always @* begin
	if (R == 1)
		Q <= 0;
	else if (S == 0)
		Q <= 1;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SR_PN_ (S, R, Q)
//-
//- A set-reset latch with positive polarity SET and negative polarity RESET.
//-
//- Truth table:    S R | Q
//-                -----+---
//-                 - 0 | 0
//-                 1 - | 1
//-                 - - | q
//-
module \\$_SR_PN_ (S, R, Q);
input S, R;
output reg Q;
always @* begin
	if (R == 0)
		Q <= 0;
	else if (S == 1)
		Q <= 1;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SR_PP_ (S, R, Q)
//-
//- A set-reset latch with positive polarity SET and positive polarity RESET.
//-
//- Truth table:    S R | Q
//-                -----+---
//-                 - 1 | 0
//-                 1 - | 1
//-                 - - | q
//-
module \\$_SR_PP_ (S, R, Q);
input S, R;
output reg Q;
always @* begin
	if (R == 1)
		Q <= 0;
	else if (S == 1)
		Q <= 1;
end
endmodule

\`ifdef SIMCELLS_FF
//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_FF_ (D, Q)
//-
//- A D-type flip-flop that is clocked from the implicit global clock. (This cell
//- type is usually only used in netlists for formal verification.)
//-
module \\$_FF_ (D, Q);
input D;
output reg Q;
always @($global_clock) begin
	Q <= D;
end
endmodule
\`endif

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFF_N_ (D, C, Q)
//-
//- A negative edge D-type flip-flop.
//-
//- Truth table:    D C | Q
//-                -----+---
//-                 d \\ | d
//-                 - - | q
//-
module \\$_DFF_N_ (D, C, Q);
input D, C;
output reg Q;
always @(negedge C) begin
	Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFF_P_ (D, C, Q)
//-
//- A positive edge D-type flip-flop.
//-
//- Truth table:    D C | Q
//-                -----+---
//-                 d / | d
//-                 - - | q
//-
module \\$_DFF_P_ (D, C, Q);
input D, C;
output reg Q;
always @(posedge C) begin
	Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFE_NN_ (D, C, E, Q)
//-
//- A negative edge D-type flip-flop with negative polarity enable.
//-
//- Truth table:    D C E | Q
//-                -------+---
//-                 d \\ 0 | d
//-                 - - - | q
//-
module \\$_DFFE_NN_ (D, C, E, Q);
input D, C, E;
output reg Q;
always @(negedge C) begin
	if (!E) Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFE_NP_ (D, C, E, Q)
//-
//- A negative edge D-type flip-flop with positive polarity enable.
//-
//- Truth table:    D C E | Q
//-                -------+---
//-                 d \\ 1 | d
//-                 - - - | q
//-
module \\$_DFFE_NP_ (D, C, E, Q);
input D, C, E;
output reg Q;
always @(negedge C) begin
	if (E) Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFE_PN_ (D, C, E, Q)
//-
//- A positive edge D-type flip-flop with negative polarity enable.
//-
//- Truth table:    D C E | Q
//-                -------+---
//-                 d / 0 | d
//-                 - - - | q
//-
module \\$_DFFE_PN_ (D, C, E, Q);
input D, C, E;
output reg Q;
always @(posedge C) begin
	if (!E) Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFE_PP_ (D, C, E, Q)
//-
//- A positive edge D-type flip-flop with positive polarity enable.
//-
//- Truth table:    D C E | Q
//-                -------+---
//-                 d / 1 | d
//-                 - - - | q
//-
module \\$_DFFE_PP_ (D, C, E, Q);
input D, C, E;
output reg Q;
always @(posedge C) begin
	if (E) Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFF_NN0_ (D, C, R, Q)
//-
//- A negative edge D-type flip-flop with negative polarity reset.
//-
//- Truth table:    D C R | Q
//-                -------+---
//-                 - - 0 | 0
//-                 d \\ - | d
//-                 - - - | q
//-
module \\$_DFF_NN0_ (D, C, R, Q);
input D, C, R;
output reg Q;
always @(negedge C or negedge R) begin
	if (R == 0)
		Q <= 0;
	else
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFF_NN1_ (D, C, R, Q)
//-
//- A negative edge D-type flip-flop with negative polarity set.
//-
//- Truth table:    D C R | Q
//-                -------+---
//-                 - - 0 | 1
//-                 d \\ - | d
//-                 - - - | q
//-
module \\$_DFF_NN1_ (D, C, R, Q);
input D, C, R;
output reg Q;
always @(negedge C or negedge R) begin
	if (R == 0)
		Q <= 1;
	else
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFF_NP0_ (D, C, R, Q)
//-
//- A negative edge D-type flip-flop with positive polarity reset.
//-
//- Truth table:    D C R | Q
//-                -------+---
//-                 - - 1 | 0
//-                 d \\ - | d
//-                 - - - | q
//-
module \\$_DFF_NP0_ (D, C, R, Q);
input D, C, R;
output reg Q;
always @(negedge C or posedge R) begin
	if (R == 1)
		Q <= 0;
	else
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFF_NP1_ (D, C, R, Q)
//-
//- A negative edge D-type flip-flop with positive polarity set.
//-
//- Truth table:    D C R | Q
//-                -------+---
//-                 - - 1 | 1
//-                 d \\ - | d
//-                 - - - | q
//-
module \\$_DFF_NP1_ (D, C, R, Q);
input D, C, R;
output reg Q;
always @(negedge C or posedge R) begin
	if (R == 1)
		Q <= 1;
	else
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFF_PN0_ (D, C, R, Q)
//-
//- A positive edge D-type flip-flop with negative polarity reset.
//-
//- Truth table:    D C R | Q
//-                -------+---
//-                 - - 0 | 0
//-                 d / - | d
//-                 - - - | q
//-
module \\$_DFF_PN0_ (D, C, R, Q);
input D, C, R;
output reg Q;
always @(posedge C or negedge R) begin
	if (R == 0)
		Q <= 0;
	else
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFF_PN1_ (D, C, R, Q)
//-
//- A positive edge D-type flip-flop with negative polarity set.
//-
//- Truth table:    D C R | Q
//-                -------+---
//-                 - - 0 | 1
//-                 d / - | d
//-                 - - - | q
//-
module \\$_DFF_PN1_ (D, C, R, Q);
input D, C, R;
output reg Q;
always @(posedge C or negedge R) begin
	if (R == 0)
		Q <= 1;
	else
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFF_PP0_ (D, C, R, Q)
//-
//- A positive edge D-type flip-flop with positive polarity reset.
//-
//- Truth table:    D C R | Q
//-                -------+---
//-                 - - 1 | 0
//-                 d / - | d
//-                 - - - | q
//-
module \\$_DFF_PP0_ (D, C, R, Q);
input D, C, R;
output reg Q;
always @(posedge C or posedge R) begin
	if (R == 1)
		Q <= 0;
	else
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFF_PP1_ (D, C, R, Q)
//-
//- A positive edge D-type flip-flop with positive polarity set.
//-
//- Truth table:    D C R | Q
//-                -------+---
//-                 - - 1 | 1
//-                 d / - | d
//-                 - - - | q
//-
module \\$_DFF_PP1_ (D, C, R, Q);
input D, C, R;
output reg Q;
always @(posedge C or posedge R) begin
	if (R == 1)
		Q <= 1;
	else
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFE_NN0N_ (D, C, R, E, Q)
//-
//- A negative edge D-type flip-flop with negative polarity reset and negative
//- polarity clock enable.
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - - 0 - | 0
//-                 d \\ - 0 | d
//-                 - - - - | q
//-
module \\$_DFFE_NN0N_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(negedge C or negedge R) begin
	if (R == 0)
		Q <= 0;
	else if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFE_NN0P_ (D, C, R, E, Q)
//-
//- A negative edge D-type flip-flop with negative polarity reset and positive
//- polarity clock enable.
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - - 0 - | 0
//-                 d \\ - 1 | d
//-                 - - - - | q
//-
module \\$_DFFE_NN0P_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(negedge C or negedge R) begin
	if (R == 0)
		Q <= 0;
	else if (E == 1)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFE_NN1N_ (D, C, R, E, Q)
//-
//- A negative edge D-type flip-flop with negative polarity set and negative
//- polarity clock enable.
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - - 0 - | 1
//-                 d \\ - 0 | d
//-                 - - - - | q
//-
module \\$_DFFE_NN1N_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(negedge C or negedge R) begin
	if (R == 0)
		Q <= 1;
	else if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFE_NN1P_ (D, C, R, E, Q)
//-
//- A negative edge D-type flip-flop with negative polarity set and positive
//- polarity clock enable.
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - - 0 - | 1
//-                 d \\ - 1 | d
//-                 - - - - | q
//-
module \\$_DFFE_NN1P_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(negedge C or negedge R) begin
	if (R == 0)
		Q <= 1;
	else if (E == 1)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFE_NP0N_ (D, C, R, E, Q)
//-
//- A negative edge D-type flip-flop with positive polarity reset and negative
//- polarity clock enable.
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - - 1 - | 0
//-                 d \\ - 0 | d
//-                 - - - - | q
//-
module \\$_DFFE_NP0N_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(negedge C or posedge R) begin
	if (R == 1)
		Q <= 0;
	else if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFE_NP0P_ (D, C, R, E, Q)
//-
//- A negative edge D-type flip-flop with positive polarity reset and positive
//- polarity clock enable.
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - - 1 - | 0
//-                 d \\ - 1 | d
//-                 - - - - | q
//-
module \\$_DFFE_NP0P_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(negedge C or posedge R) begin
	if (R == 1)
		Q <= 0;
	else if (E == 1)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFE_NP1N_ (D, C, R, E, Q)
//-
//- A negative edge D-type flip-flop with positive polarity set and negative
//- polarity clock enable.
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - - 1 - | 1
//-                 d \\ - 0 | d
//-                 - - - - | q
//-
module \\$_DFFE_NP1N_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(negedge C or posedge R) begin
	if (R == 1)
		Q <= 1;
	else if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFE_NP1P_ (D, C, R, E, Q)
//-
//- A negative edge D-type flip-flop with positive polarity set and positive
//- polarity clock enable.
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - - 1 - | 1
//-                 d \\ - 1 | d
//-                 - - - - | q
//-
module \\$_DFFE_NP1P_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(negedge C or posedge R) begin
	if (R == 1)
		Q <= 1;
	else if (E == 1)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFE_PN0N_ (D, C, R, E, Q)
//-
//- A positive edge D-type flip-flop with negative polarity reset and negative
//- polarity clock enable.
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - - 0 - | 0
//-                 d / - 0 | d
//-                 - - - - | q
//-
module \\$_DFFE_PN0N_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(posedge C or negedge R) begin
	if (R == 0)
		Q <= 0;
	else if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFE_PN0P_ (D, C, R, E, Q)
//-
//- A positive edge D-type flip-flop with negative polarity reset and positive
//- polarity clock enable.
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - - 0 - | 0
//-                 d / - 1 | d
//-                 - - - - | q
//-
module \\$_DFFE_PN0P_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(posedge C or negedge R) begin
	if (R == 0)
		Q <= 0;
	else if (E == 1)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFE_PN1N_ (D, C, R, E, Q)
//-
//- A positive edge D-type flip-flop with negative polarity set and negative
//- polarity clock enable.
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - - 0 - | 1
//-                 d / - 0 | d
//-                 - - - - | q
//-
module \\$_DFFE_PN1N_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(posedge C or negedge R) begin
	if (R == 0)
		Q <= 1;
	else if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFE_PN1P_ (D, C, R, E, Q)
//-
//- A positive edge D-type flip-flop with negative polarity set and positive
//- polarity clock enable.
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - - 0 - | 1
//-                 d / - 1 | d
//-                 - - - - | q
//-
module \\$_DFFE_PN1P_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(posedge C or negedge R) begin
	if (R == 0)
		Q <= 1;
	else if (E == 1)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFE_PP0N_ (D, C, R, E, Q)
//-
//- A positive edge D-type flip-flop with positive polarity reset and negative
//- polarity clock enable.
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - - 1 - | 0
//-                 d / - 0 | d
//-                 - - - - | q
//-
module \\$_DFFE_PP0N_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(posedge C or posedge R) begin
	if (R == 1)
		Q <= 0;
	else if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFE_PP0P_ (D, C, R, E, Q)
//-
//- A positive edge D-type flip-flop with positive polarity reset and positive
//- polarity clock enable.
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - - 1 - | 0
//-                 d / - 1 | d
//-                 - - - - | q
//-
module \\$_DFFE_PP0P_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(posedge C or posedge R) begin
	if (R == 1)
		Q <= 0;
	else if (E == 1)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFE_PP1N_ (D, C, R, E, Q)
//-
//- A positive edge D-type flip-flop with positive polarity set and negative
//- polarity clock enable.
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - - 1 - | 1
//-                 d / - 0 | d
//-                 - - - - | q
//-
module \\$_DFFE_PP1N_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(posedge C or posedge R) begin
	if (R == 1)
		Q <= 1;
	else if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFE_PP1P_ (D, C, R, E, Q)
//-
//- A positive edge D-type flip-flop with positive polarity set and positive
//- polarity clock enable.
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - - 1 - | 1
//-                 d / - 1 | d
//-                 - - - - | q
//-
module \\$_DFFE_PP1P_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(posedge C or posedge R) begin
	if (R == 1)
		Q <= 1;
	else if (E == 1)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_ALDFF_NN_ (D, C, L, AD, Q)
//-
//- A negative edge D-type flip-flop with negative polarity async load.
//-
//- Truth table:    D C L AD | Q
//-                ----------+---
//-                 - - 0 a  | a
//-                 d \\ - -  | d
//-                 - - - -  | q
//-
module \\$_ALDFF_NN_ (D, C, L, AD, Q);
input D, C, L, AD;
output reg Q;
always @(negedge C or negedge L) begin
	if (L == 0)
		Q <= AD;
	else
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_ALDFF_NP_ (D, C, L, AD, Q)
//-
//- A negative edge D-type flip-flop with positive polarity async load.
//-
//- Truth table:    D C L AD | Q
//-                ----------+---
//-                 - - 1 a  | a
//-                 d \\ - -  | d
//-                 - - - -  | q
//-
module \\$_ALDFF_NP_ (D, C, L, AD, Q);
input D, C, L, AD;
output reg Q;
always @(negedge C or posedge L) begin
	if (L == 1)
		Q <= AD;
	else
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_ALDFF_PN_ (D, C, L, AD, Q)
//-
//- A positive edge D-type flip-flop with negative polarity async load.
//-
//- Truth table:    D C L AD | Q
//-                ----------+---
//-                 - - 0 a  | a
//-                 d / - -  | d
//-                 - - - -  | q
//-
module \\$_ALDFF_PN_ (D, C, L, AD, Q);
input D, C, L, AD;
output reg Q;
always @(posedge C or negedge L) begin
	if (L == 0)
		Q <= AD;
	else
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_ALDFF_PP_ (D, C, L, AD, Q)
//-
//- A positive edge D-type flip-flop with positive polarity async load.
//-
//- Truth table:    D C L AD | Q
//-                ----------+---
//-                 - - 1 a  | a
//-                 d / - -  | d
//-                 - - - -  | q
//-
module \\$_ALDFF_PP_ (D, C, L, AD, Q);
input D, C, L, AD;
output reg Q;
always @(posedge C or posedge L) begin
	if (L == 1)
		Q <= AD;
	else
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_ALDFFE_NNN_ (D, C, L, AD, E, Q)
//-
//- A negative edge D-type flip-flop with negative polarity async load and negative
//- polarity clock enable.
//-
//- Truth table:    D C L AD E | Q
//-                ------------+---
//-                 - - 0 a  - | a
//-                 d \\ - -  0 | d
//-                 - - - -  - | q
//-
module \\$_ALDFFE_NNN_ (D, C, L, AD, E, Q);
input D, C, L, AD, E;
output reg Q;
always @(negedge C or negedge L) begin
	if (L == 0)
		Q <= AD;
	else if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_ALDFFE_NNP_ (D, C, L, AD, E, Q)
//-
//- A negative edge D-type flip-flop with negative polarity async load and positive
//- polarity clock enable.
//-
//- Truth table:    D C L AD E | Q
//-                ------------+---
//-                 - - 0 a  - | a
//-                 d \\ - -  1 | d
//-                 - - - -  - | q
//-
module \\$_ALDFFE_NNP_ (D, C, L, AD, E, Q);
input D, C, L, AD, E;
output reg Q;
always @(negedge C or negedge L) begin
	if (L == 0)
		Q <= AD;
	else if (E == 1)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_ALDFFE_NPN_ (D, C, L, AD, E, Q)
//-
//- A negative edge D-type flip-flop with positive polarity async load and negative
//- polarity clock enable.
//-
//- Truth table:    D C L AD E | Q
//-                ------------+---
//-                 - - 1 a  - | a
//-                 d \\ - -  0 | d
//-                 - - - -  - | q
//-
module \\$_ALDFFE_NPN_ (D, C, L, AD, E, Q);
input D, C, L, AD, E;
output reg Q;
always @(negedge C or posedge L) begin
	if (L == 1)
		Q <= AD;
	else if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_ALDFFE_NPP_ (D, C, L, AD, E, Q)
//-
//- A negative edge D-type flip-flop with positive polarity async load and positive
//- polarity clock enable.
//-
//- Truth table:    D C L AD E | Q
//-                ------------+---
//-                 - - 1 a  - | a
//-                 d \\ - -  1 | d
//-                 - - - -  - | q
//-
module \\$_ALDFFE_NPP_ (D, C, L, AD, E, Q);
input D, C, L, AD, E;
output reg Q;
always @(negedge C or posedge L) begin
	if (L == 1)
		Q <= AD;
	else if (E == 1)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_ALDFFE_PNN_ (D, C, L, AD, E, Q)
//-
//- A positive edge D-type flip-flop with negative polarity async load and negative
//- polarity clock enable.
//-
//- Truth table:    D C L AD E | Q
//-                ------------+---
//-                 - - 0 a  - | a
//-                 d / - -  0 | d
//-                 - - - -  - | q
//-
module \\$_ALDFFE_PNN_ (D, C, L, AD, E, Q);
input D, C, L, AD, E;
output reg Q;
always @(posedge C or negedge L) begin
	if (L == 0)
		Q <= AD;
	else if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_ALDFFE_PNP_ (D, C, L, AD, E, Q)
//-
//- A positive edge D-type flip-flop with negative polarity async load and positive
//- polarity clock enable.
//-
//- Truth table:    D C L AD E | Q
//-                ------------+---
//-                 - - 0 a  - | a
//-                 d / - -  1 | d
//-                 - - - -  - | q
//-
module \\$_ALDFFE_PNP_ (D, C, L, AD, E, Q);
input D, C, L, AD, E;
output reg Q;
always @(posedge C or negedge L) begin
	if (L == 0)
		Q <= AD;
	else if (E == 1)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_ALDFFE_PPN_ (D, C, L, AD, E, Q)
//-
//- A positive edge D-type flip-flop with positive polarity async load and negative
//- polarity clock enable.
//-
//- Truth table:    D C L AD E | Q
//-                ------------+---
//-                 - - 1 a  - | a
//-                 d / - -  0 | d
//-                 - - - -  - | q
//-
module \\$_ALDFFE_PPN_ (D, C, L, AD, E, Q);
input D, C, L, AD, E;
output reg Q;
always @(posedge C or posedge L) begin
	if (L == 1)
		Q <= AD;
	else if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_ALDFFE_PPP_ (D, C, L, AD, E, Q)
//-
//- A positive edge D-type flip-flop with positive polarity async load and positive
//- polarity clock enable.
//-
//- Truth table:    D C L AD E | Q
//-                ------------+---
//-                 - - 1 a  - | a
//-                 d / - -  1 | d
//-                 - - - -  - | q
//-
module \\$_ALDFFE_PPP_ (D, C, L, AD, E, Q);
input D, C, L, AD, E;
output reg Q;
always @(posedge C or posedge L) begin
	if (L == 1)
		Q <= AD;
	else if (E == 1)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFSR_NNN_ (C, S, R, D, Q)
//-
//- A negative edge D-type flip-flop with negative polarity set and negative
//- polarity reset.
//-
//- Truth table:    C S R D | Q
//-                ---------+---
//-                 - - 0 - | 0
//-                 - 0 - - | 1
//-                 \\ - - d | d
//-                 - - - - | q
//-
module \\$_DFFSR_NNN_ (C, S, R, D, Q);
input C, S, R, D;
output reg Q;
always @(negedge C, negedge S, negedge R) begin
	if (R == 0)
		Q <= 0;
	else if (S == 0)
		Q <= 1;
	else
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFSR_NNP_ (C, S, R, D, Q)
//-
//- A negative edge D-type flip-flop with negative polarity set and positive
//- polarity reset.
//-
//- Truth table:    C S R D | Q
//-                ---------+---
//-                 - - 1 - | 0
//-                 - 0 - - | 1
//-                 \\ - - d | d
//-                 - - - - | q
//-
module \\$_DFFSR_NNP_ (C, S, R, D, Q);
input C, S, R, D;
output reg Q;
always @(negedge C, negedge S, posedge R) begin
	if (R == 1)
		Q <= 0;
	else if (S == 0)
		Q <= 1;
	else
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFSR_NPN_ (C, S, R, D, Q)
//-
//- A negative edge D-type flip-flop with positive polarity set and negative
//- polarity reset.
//-
//- Truth table:    C S R D | Q
//-                ---------+---
//-                 - - 0 - | 0
//-                 - 1 - - | 1
//-                 \\ - - d | d
//-                 - - - - | q
//-
module \\$_DFFSR_NPN_ (C, S, R, D, Q);
input C, S, R, D;
output reg Q;
always @(negedge C, posedge S, negedge R) begin
	if (R == 0)
		Q <= 0;
	else if (S == 1)
		Q <= 1;
	else
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFSR_NPP_ (C, S, R, D, Q)
//-
//- A negative edge D-type flip-flop with positive polarity set and positive
//- polarity reset.
//-
//- Truth table:    C S R D | Q
//-                ---------+---
//-                 - - 1 - | 0
//-                 - 1 - - | 1
//-                 \\ - - d | d
//-                 - - - - | q
//-
module \\$_DFFSR_NPP_ (C, S, R, D, Q);
input C, S, R, D;
output reg Q;
always @(negedge C, posedge S, posedge R) begin
	if (R == 1)
		Q <= 0;
	else if (S == 1)
		Q <= 1;
	else
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFSR_PNN_ (C, S, R, D, Q)
//-
//- A positive edge D-type flip-flop with negative polarity set and negative
//- polarity reset.
//-
//- Truth table:    C S R D | Q
//-                ---------+---
//-                 - - 0 - | 0
//-                 - 0 - - | 1
//-                 / - - d | d
//-                 - - - - | q
//-
module \\$_DFFSR_PNN_ (C, S, R, D, Q);
input C, S, R, D;
output reg Q;
always @(posedge C, negedge S, negedge R) begin
	if (R == 0)
		Q <= 0;
	else if (S == 0)
		Q <= 1;
	else
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFSR_PNP_ (C, S, R, D, Q)
//-
//- A positive edge D-type flip-flop with negative polarity set and positive
//- polarity reset.
//-
//- Truth table:    C S R D | Q
//-                ---------+---
//-                 - - 1 - | 0
//-                 - 0 - - | 1
//-                 / - - d | d
//-                 - - - - | q
//-
module \\$_DFFSR_PNP_ (C, S, R, D, Q);
input C, S, R, D;
output reg Q;
always @(posedge C, negedge S, posedge R) begin
	if (R == 1)
		Q <= 0;
	else if (S == 0)
		Q <= 1;
	else
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFSR_PPN_ (C, S, R, D, Q)
//-
//- A positive edge D-type flip-flop with positive polarity set and negative
//- polarity reset.
//-
//- Truth table:    C S R D | Q
//-                ---------+---
//-                 - - 0 - | 0
//-                 - 1 - - | 1
//-                 / - - d | d
//-                 - - - - | q
//-
module \\$_DFFSR_PPN_ (C, S, R, D, Q);
input C, S, R, D;
output reg Q;
always @(posedge C, posedge S, negedge R) begin
	if (R == 0)
		Q <= 0;
	else if (S == 1)
		Q <= 1;
	else
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFSR_PPP_ (C, S, R, D, Q)
//-
//- A positive edge D-type flip-flop with positive polarity set and positive
//- polarity reset.
//-
//- Truth table:    C S R D | Q
//-                ---------+---
//-                 - - 1 - | 0
//-                 - 1 - - | 1
//-                 / - - d | d
//-                 - - - - | q
//-
module \\$_DFFSR_PPP_ (C, S, R, D, Q);
input C, S, R, D;
output reg Q;
always @(posedge C, posedge S, posedge R) begin
	if (R == 1)
		Q <= 0;
	else if (S == 1)
		Q <= 1;
	else
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFSRE_NNNN_ (C, S, R, E, D, Q)
//-
//- A negative edge D-type flip-flop with negative polarity set, negative
//- polarity reset and negative polarity clock enable.
//-
//- Truth table:    C S R E D | Q
//-                -----------+---
//-                 - - 0 - - | 0
//-                 - 0 - - - | 1
//-                 \\ - - 0 d | d
//-                 - - - - - | q
//-
module \\$_DFFSRE_NNNN_ (C, S, R, E, D, Q);
input C, S, R, E, D;
output reg Q;
always @(negedge C, negedge S, negedge R) begin
	if (R == 0)
		Q <= 0;
	else if (S == 0)
		Q <= 1;
        else if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFSRE_NNNP_ (C, S, R, E, D, Q)
//-
//- A negative edge D-type flip-flop with negative polarity set, negative
//- polarity reset and positive polarity clock enable.
//-
//- Truth table:    C S R E D | Q
//-                -----------+---
//-                 - - 0 - - | 0
//-                 - 0 - - - | 1
//-                 \\ - - 1 d | d
//-                 - - - - - | q
//-
module \\$_DFFSRE_NNNP_ (C, S, R, E, D, Q);
input C, S, R, E, D;
output reg Q;
always @(negedge C, negedge S, negedge R) begin
	if (R == 0)
		Q <= 0;
	else if (S == 0)
		Q <= 1;
        else if (E == 1)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFSRE_NNPN_ (C, S, R, E, D, Q)
//-
//- A negative edge D-type flip-flop with negative polarity set, positive
//- polarity reset and negative polarity clock enable.
//-
//- Truth table:    C S R E D | Q
//-                -----------+---
//-                 - - 1 - - | 0
//-                 - 0 - - - | 1
//-                 \\ - - 0 d | d
//-                 - - - - - | q
//-
module \\$_DFFSRE_NNPN_ (C, S, R, E, D, Q);
input C, S, R, E, D;
output reg Q;
always @(negedge C, negedge S, posedge R) begin
	if (R == 1)
		Q <= 0;
	else if (S == 0)
		Q <= 1;
        else if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFSRE_NNPP_ (C, S, R, E, D, Q)
//-
//- A negative edge D-type flip-flop with negative polarity set, positive
//- polarity reset and positive polarity clock enable.
//-
//- Truth table:    C S R E D | Q
//-                -----------+---
//-                 - - 1 - - | 0
//-                 - 0 - - - | 1
//-                 \\ - - 1 d | d
//-                 - - - - - | q
//-
module \\$_DFFSRE_NNPP_ (C, S, R, E, D, Q);
input C, S, R, E, D;
output reg Q;
always @(negedge C, negedge S, posedge R) begin
	if (R == 1)
		Q <= 0;
	else if (S == 0)
		Q <= 1;
        else if (E == 1)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFSRE_NPNN_ (C, S, R, E, D, Q)
//-
//- A negative edge D-type flip-flop with positive polarity set, negative
//- polarity reset and negative polarity clock enable.
//-
//- Truth table:    C S R E D | Q
//-                -----------+---
//-                 - - 0 - - | 0
//-                 - 1 - - - | 1
//-                 \\ - - 0 d | d
//-                 - - - - - | q
//-
module \\$_DFFSRE_NPNN_ (C, S, R, E, D, Q);
input C, S, R, E, D;
output reg Q;
always @(negedge C, posedge S, negedge R) begin
	if (R == 0)
		Q <= 0;
	else if (S == 1)
		Q <= 1;
        else if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFSRE_NPNP_ (C, S, R, E, D, Q)
//-
//- A negative edge D-type flip-flop with positive polarity set, negative
//- polarity reset and positive polarity clock enable.
//-
//- Truth table:    C S R E D | Q
//-                -----------+---
//-                 - - 0 - - | 0
//-                 - 1 - - - | 1
//-                 \\ - - 1 d | d
//-                 - - - - - | q
//-
module \\$_DFFSRE_NPNP_ (C, S, R, E, D, Q);
input C, S, R, E, D;
output reg Q;
always @(negedge C, posedge S, negedge R) begin
	if (R == 0)
		Q <= 0;
	else if (S == 1)
		Q <= 1;
        else if (E == 1)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFSRE_NPPN_ (C, S, R, E, D, Q)
//-
//- A negative edge D-type flip-flop with positive polarity set, positive
//- polarity reset and negative polarity clock enable.
//-
//- Truth table:    C S R E D | Q
//-                -----------+---
//-                 - - 1 - - | 0
//-                 - 1 - - - | 1
//-                 \\ - - 0 d | d
//-                 - - - - - | q
//-
module \\$_DFFSRE_NPPN_ (C, S, R, E, D, Q);
input C, S, R, E, D;
output reg Q;
always @(negedge C, posedge S, posedge R) begin
	if (R == 1)
		Q <= 0;
	else if (S == 1)
		Q <= 1;
        else if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFSRE_NPPP_ (C, S, R, E, D, Q)
//-
//- A negative edge D-type flip-flop with positive polarity set, positive
//- polarity reset and positive polarity clock enable.
//-
//- Truth table:    C S R E D | Q
//-                -----------+---
//-                 - - 1 - - | 0
//-                 - 1 - - - | 1
//-                 \\ - - 1 d | d
//-                 - - - - - | q
//-
module \\$_DFFSRE_NPPP_ (C, S, R, E, D, Q);
input C, S, R, E, D;
output reg Q;
always @(negedge C, posedge S, posedge R) begin
	if (R == 1)
		Q <= 0;
	else if (S == 1)
		Q <= 1;
        else if (E == 1)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFSRE_PNNN_ (C, S, R, E, D, Q)
//-
//- A positive edge D-type flip-flop with negative polarity set, negative
//- polarity reset and negative polarity clock enable.
//-
//- Truth table:    C S R E D | Q
//-                -----------+---
//-                 - - 0 - - | 0
//-                 - 0 - - - | 1
//-                 / - - 0 d | d
//-                 - - - - - | q
//-
module \\$_DFFSRE_PNNN_ (C, S, R, E, D, Q);
input C, S, R, E, D;
output reg Q;
always @(posedge C, negedge S, negedge R) begin
	if (R == 0)
		Q <= 0;
	else if (S == 0)
		Q <= 1;
        else if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFSRE_PNNP_ (C, S, R, E, D, Q)
//-
//- A positive edge D-type flip-flop with negative polarity set, negative
//- polarity reset and positive polarity clock enable.
//-
//- Truth table:    C S R E D | Q
//-                -----------+---
//-                 - - 0 - - | 0
//-                 - 0 - - - | 1
//-                 / - - 1 d | d
//-                 - - - - - | q
//-
module \\$_DFFSRE_PNNP_ (C, S, R, E, D, Q);
input C, S, R, E, D;
output reg Q;
always @(posedge C, negedge S, negedge R) begin
	if (R == 0)
		Q <= 0;
	else if (S == 0)
		Q <= 1;
        else if (E == 1)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFSRE_PNPN_ (C, S, R, E, D, Q)
//-
//- A positive edge D-type flip-flop with negative polarity set, positive
//- polarity reset and negative polarity clock enable.
//-
//- Truth table:    C S R E D | Q
//-                -----------+---
//-                 - - 1 - - | 0
//-                 - 0 - - - | 1
//-                 / - - 0 d | d
//-                 - - - - - | q
//-
module \\$_DFFSRE_PNPN_ (C, S, R, E, D, Q);
input C, S, R, E, D;
output reg Q;
always @(posedge C, negedge S, posedge R) begin
	if (R == 1)
		Q <= 0;
	else if (S == 0)
		Q <= 1;
        else if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFSRE_PNPP_ (C, S, R, E, D, Q)
//-
//- A positive edge D-type flip-flop with negative polarity set, positive
//- polarity reset and positive polarity clock enable.
//-
//- Truth table:    C S R E D | Q
//-                -----------+---
//-                 - - 1 - - | 0
//-                 - 0 - - - | 1
//-                 / - - 1 d | d
//-                 - - - - - | q
//-
module \\$_DFFSRE_PNPP_ (C, S, R, E, D, Q);
input C, S, R, E, D;
output reg Q;
always @(posedge C, negedge S, posedge R) begin
	if (R == 1)
		Q <= 0;
	else if (S == 0)
		Q <= 1;
        else if (E == 1)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFSRE_PPNN_ (C, S, R, E, D, Q)
//-
//- A positive edge D-type flip-flop with positive polarity set, negative
//- polarity reset and negative polarity clock enable.
//-
//- Truth table:    C S R E D | Q
//-                -----------+---
//-                 - - 0 - - | 0
//-                 - 1 - - - | 1
//-                 / - - 0 d | d
//-                 - - - - - | q
//-
module \\$_DFFSRE_PPNN_ (C, S, R, E, D, Q);
input C, S, R, E, D;
output reg Q;
always @(posedge C, posedge S, negedge R) begin
	if (R == 0)
		Q <= 0;
	else if (S == 1)
		Q <= 1;
        else if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFSRE_PPNP_ (C, S, R, E, D, Q)
//-
//- A positive edge D-type flip-flop with positive polarity set, negative
//- polarity reset and positive polarity clock enable.
//-
//- Truth table:    C S R E D | Q
//-                -----------+---
//-                 - - 0 - - | 0
//-                 - 1 - - - | 1
//-                 / - - 1 d | d
//-                 - - - - - | q
//-
module \\$_DFFSRE_PPNP_ (C, S, R, E, D, Q);
input C, S, R, E, D;
output reg Q;
always @(posedge C, posedge S, negedge R) begin
	if (R == 0)
		Q <= 0;
	else if (S == 1)
		Q <= 1;
        else if (E == 1)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFSRE_PPPN_ (C, S, R, E, D, Q)
//-
//- A positive edge D-type flip-flop with positive polarity set, positive
//- polarity reset and negative polarity clock enable.
//-
//- Truth table:    C S R E D | Q
//-                -----------+---
//-                 - - 1 - - | 0
//-                 - 1 - - - | 1
//-                 / - - 0 d | d
//-                 - - - - - | q
//-
module \\$_DFFSRE_PPPN_ (C, S, R, E, D, Q);
input C, S, R, E, D;
output reg Q;
always @(posedge C, posedge S, posedge R) begin
	if (R == 1)
		Q <= 0;
	else if (S == 1)
		Q <= 1;
        else if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DFFSRE_PPPP_ (C, S, R, E, D, Q)
//-
//- A positive edge D-type flip-flop with positive polarity set, positive
//- polarity reset and positive polarity clock enable.
//-
//- Truth table:    C S R E D | Q
//-                -----------+---
//-                 - - 1 - - | 0
//-                 - 1 - - - | 1
//-                 / - - 1 d | d
//-                 - - - - - | q
//-
module \\$_DFFSRE_PPPP_ (C, S, R, E, D, Q);
input C, S, R, E, D;
output reg Q;
always @(posedge C, posedge S, posedge R) begin
	if (R == 1)
		Q <= 0;
	else if (S == 1)
		Q <= 1;
        else if (E == 1)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFF_NN0_ (D, C, R, Q)
//-
//- A negative edge D-type flip-flop with negative polarity synchronous reset.
//-
//- Truth table:    D C R | Q
//-                -------+---
//-                 - \\ 0 | 0
//-                 d \\ - | d
//-                 - - - | q
//-
module \\$_SDFF_NN0_ (D, C, R, Q);
input D, C, R;
output reg Q;
always @(negedge C) begin
	if (R == 0)
		Q <= 0;
	else
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFF_NN1_ (D, C, R, Q)
//-
//- A negative edge D-type flip-flop with negative polarity synchronous set.
//-
//- Truth table:    D C R | Q
//-                -------+---
//-                 - \\ 0 | 1
//-                 d \\ - | d
//-                 - - - | q
//-
module \\$_SDFF_NN1_ (D, C, R, Q);
input D, C, R;
output reg Q;
always @(negedge C) begin
	if (R == 0)
		Q <= 1;
	else
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFF_NP0_ (D, C, R, Q)
//-
//- A negative edge D-type flip-flop with positive polarity synchronous reset.
//-
//- Truth table:    D C R | Q
//-                -------+---
//-                 - \\ 1 | 0
//-                 d \\ - | d
//-                 - - - | q
//-
module \\$_SDFF_NP0_ (D, C, R, Q);
input D, C, R;
output reg Q;
always @(negedge C) begin
	if (R == 1)
		Q <= 0;
	else
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFF_NP1_ (D, C, R, Q)
//-
//- A negative edge D-type flip-flop with positive polarity synchronous set.
//-
//- Truth table:    D C R | Q
//-                -------+---
//-                 - \\ 1 | 1
//-                 d \\ - | d
//-                 - - - | q
//-
module \\$_SDFF_NP1_ (D, C, R, Q);
input D, C, R;
output reg Q;
always @(negedge C) begin
	if (R == 1)
		Q <= 1;
	else
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFF_PN0_ (D, C, R, Q)
//-
//- A positive edge D-type flip-flop with negative polarity synchronous reset.
//-
//- Truth table:    D C R | Q
//-                -------+---
//-                 - / 0 | 0
//-                 d / - | d
//-                 - - - | q
//-
module \\$_SDFF_PN0_ (D, C, R, Q);
input D, C, R;
output reg Q;
always @(posedge C) begin
	if (R == 0)
		Q <= 0;
	else
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFF_PN1_ (D, C, R, Q)
//-
//- A positive edge D-type flip-flop with negative polarity synchronous set.
//-
//- Truth table:    D C R | Q
//-                -------+---
//-                 - / 0 | 1
//-                 d / - | d
//-                 - - - | q
//-
module \\$_SDFF_PN1_ (D, C, R, Q);
input D, C, R;
output reg Q;
always @(posedge C) begin
	if (R == 0)
		Q <= 1;
	else
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFF_PP0_ (D, C, R, Q)
//-
//- A positive edge D-type flip-flop with positive polarity synchronous reset.
//-
//- Truth table:    D C R | Q
//-                -------+---
//-                 - / 1 | 0
//-                 d / - | d
//-                 - - - | q
//-
module \\$_SDFF_PP0_ (D, C, R, Q);
input D, C, R;
output reg Q;
always @(posedge C) begin
	if (R == 1)
		Q <= 0;
	else
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFF_PP1_ (D, C, R, Q)
//-
//- A positive edge D-type flip-flop with positive polarity synchronous set.
//-
//- Truth table:    D C R | Q
//-                -------+---
//-                 - / 1 | 1
//-                 d / - | d
//-                 - - - | q
//-
module \\$_SDFF_PP1_ (D, C, R, Q);
input D, C, R;
output reg Q;
always @(posedge C) begin
	if (R == 1)
		Q <= 1;
	else
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFFE_NN0N_ (D, C, R, E, Q)
//-
//- A negative edge D-type flip-flop with negative polarity synchronous reset and negative
//- polarity clock enable (with reset having priority).
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - \\ 0 - | 0
//-                 d \\ - 0 | d
//-                 - - - - | q
//-
module \\$_SDFFE_NN0N_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(negedge C) begin
	if (R == 0)
		Q <= 0;
	else if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFFE_NN0P_ (D, C, R, E, Q)
//-
//- A negative edge D-type flip-flop with negative polarity synchronous reset and positive
//- polarity clock enable (with reset having priority).
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - \\ 0 - | 0
//-                 d \\ - 1 | d
//-                 - - - - | q
//-
module \\$_SDFFE_NN0P_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(negedge C) begin
	if (R == 0)
		Q <= 0;
	else if (E == 1)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFFE_NN1N_ (D, C, R, E, Q)
//-
//- A negative edge D-type flip-flop with negative polarity synchronous set and negative
//- polarity clock enable (with set having priority).
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - \\ 0 - | 1
//-                 d \\ - 0 | d
//-                 - - - - | q
//-
module \\$_SDFFE_NN1N_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(negedge C) begin
	if (R == 0)
		Q <= 1;
	else if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFFE_NN1P_ (D, C, R, E, Q)
//-
//- A negative edge D-type flip-flop with negative polarity synchronous set and positive
//- polarity clock enable (with set having priority).
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - \\ 0 - | 1
//-                 d \\ - 1 | d
//-                 - - - - | q
//-
module \\$_SDFFE_NN1P_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(negedge C) begin
	if (R == 0)
		Q <= 1;
	else if (E == 1)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFFE_NP0N_ (D, C, R, E, Q)
//-
//- A negative edge D-type flip-flop with positive polarity synchronous reset and negative
//- polarity clock enable (with reset having priority).
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - \\ 1 - | 0
//-                 d \\ - 0 | d
//-                 - - - - | q
//-
module \\$_SDFFE_NP0N_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(negedge C) begin
	if (R == 1)
		Q <= 0;
	else if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFFE_NP0P_ (D, C, R, E, Q)
//-
//- A negative edge D-type flip-flop with positive polarity synchronous reset and positive
//- polarity clock enable (with reset having priority).
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - \\ 1 - | 0
//-                 d \\ - 1 | d
//-                 - - - - | q
//-
module \\$_SDFFE_NP0P_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(negedge C) begin
	if (R == 1)
		Q <= 0;
	else if (E == 1)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFFE_NP1N_ (D, C, R, E, Q)
//-
//- A negative edge D-type flip-flop with positive polarity synchronous set and negative
//- polarity clock enable (with set having priority).
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - \\ 1 - | 1
//-                 d \\ - 0 | d
//-                 - - - - | q
//-
module \\$_SDFFE_NP1N_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(negedge C) begin
	if (R == 1)
		Q <= 1;
	else if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFFE_NP1P_ (D, C, R, E, Q)
//-
//- A negative edge D-type flip-flop with positive polarity synchronous set and positive
//- polarity clock enable (with set having priority).
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - \\ 1 - | 1
//-                 d \\ - 1 | d
//-                 - - - - | q
//-
module \\$_SDFFE_NP1P_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(negedge C) begin
	if (R == 1)
		Q <= 1;
	else if (E == 1)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFFE_PN0N_ (D, C, R, E, Q)
//-
//- A positive edge D-type flip-flop with negative polarity synchronous reset and negative
//- polarity clock enable (with reset having priority).
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - / 0 - | 0
//-                 d / - 0 | d
//-                 - - - - | q
//-
module \\$_SDFFE_PN0N_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(posedge C) begin
	if (R == 0)
		Q <= 0;
	else if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFFE_PN0P_ (D, C, R, E, Q)
//-
//- A positive edge D-type flip-flop with negative polarity synchronous reset and positive
//- polarity clock enable (with reset having priority).
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - / 0 - | 0
//-                 d / - 1 | d
//-                 - - - - | q
//-
module \\$_SDFFE_PN0P_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(posedge C) begin
	if (R == 0)
		Q <= 0;
	else if (E == 1)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFFE_PN1N_ (D, C, R, E, Q)
//-
//- A positive edge D-type flip-flop with negative polarity synchronous set and negative
//- polarity clock enable (with set having priority).
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - / 0 - | 1
//-                 d / - 0 | d
//-                 - - - - | q
//-
module \\$_SDFFE_PN1N_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(posedge C) begin
	if (R == 0)
		Q <= 1;
	else if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFFE_PN1P_ (D, C, R, E, Q)
//-
//- A positive edge D-type flip-flop with negative polarity synchronous set and positive
//- polarity clock enable (with set having priority).
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - / 0 - | 1
//-                 d / - 1 | d
//-                 - - - - | q
//-
module \\$_SDFFE_PN1P_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(posedge C) begin
	if (R == 0)
		Q <= 1;
	else if (E == 1)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFFE_PP0N_ (D, C, R, E, Q)
//-
//- A positive edge D-type flip-flop with positive polarity synchronous reset and negative
//- polarity clock enable (with reset having priority).
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - / 1 - | 0
//-                 d / - 0 | d
//-                 - - - - | q
//-
module \\$_SDFFE_PP0N_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(posedge C) begin
	if (R == 1)
		Q <= 0;
	else if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFFE_PP0P_ (D, C, R, E, Q)
//-
//- A positive edge D-type flip-flop with positive polarity synchronous reset and positive
//- polarity clock enable (with reset having priority).
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - / 1 - | 0
//-                 d / - 1 | d
//-                 - - - - | q
//-
module \\$_SDFFE_PP0P_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(posedge C) begin
	if (R == 1)
		Q <= 0;
	else if (E == 1)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFFE_PP1N_ (D, C, R, E, Q)
//-
//- A positive edge D-type flip-flop with positive polarity synchronous set and negative
//- polarity clock enable (with set having priority).
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - / 1 - | 1
//-                 d / - 0 | d
//-                 - - - - | q
//-
module \\$_SDFFE_PP1N_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(posedge C) begin
	if (R == 1)
		Q <= 1;
	else if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFFE_PP1P_ (D, C, R, E, Q)
//-
//- A positive edge D-type flip-flop with positive polarity synchronous set and positive
//- polarity clock enable (with set having priority).
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - / 1 - | 1
//-                 d / - 1 | d
//-                 - - - - | q
//-
module \\$_SDFFE_PP1P_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(posedge C) begin
	if (R == 1)
		Q <= 1;
	else if (E == 1)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFFCE_NN0N_ (D, C, R, E, Q)
//-
//- A negative edge D-type flip-flop with negative polarity synchronous reset and negative
//- polarity clock enable (with clock enable having priority).
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - \\ 0 0 | 0
//-                 d \\ - 0 | d
//-                 - - - - | q
//-
module \\$_SDFFCE_NN0N_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(negedge C) begin
	if (E == 0) begin
		if (R == 0)
			Q <= 0;
		else
			Q <= D;
	end
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFFCE_NN0P_ (D, C, R, E, Q)
//-
//- A negative edge D-type flip-flop with negative polarity synchronous reset and positive
//- polarity clock enable (with clock enable having priority).
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - \\ 0 1 | 0
//-                 d \\ - 1 | d
//-                 - - - - | q
//-
module \\$_SDFFCE_NN0P_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(negedge C) begin
	if (E == 1) begin
		if (R == 0)
			Q <= 0;
		else
			Q <= D;
	end
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFFCE_NN1N_ (D, C, R, E, Q)
//-
//- A negative edge D-type flip-flop with negative polarity synchronous set and negative
//- polarity clock enable (with clock enable having priority).
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - \\ 0 0 | 1
//-                 d \\ - 0 | d
//-                 - - - - | q
//-
module \\$_SDFFCE_NN1N_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(negedge C) begin
	if (E == 0) begin
		if (R == 0)
			Q <= 1;
		else
			Q <= D;
	end
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFFCE_NN1P_ (D, C, R, E, Q)
//-
//- A negative edge D-type flip-flop with negative polarity synchronous set and positive
//- polarity clock enable (with clock enable having priority).
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - \\ 0 1 | 1
//-                 d \\ - 1 | d
//-                 - - - - | q
//-
module \\$_SDFFCE_NN1P_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(negedge C) begin
	if (E == 1) begin
		if (R == 0)
			Q <= 1;
		else
			Q <= D;
	end
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFFCE_NP0N_ (D, C, R, E, Q)
//-
//- A negative edge D-type flip-flop with positive polarity synchronous reset and negative
//- polarity clock enable (with clock enable having priority).
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - \\ 1 0 | 0
//-                 d \\ - 0 | d
//-                 - - - - | q
//-
module \\$_SDFFCE_NP0N_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(negedge C) begin
	if (E == 0) begin
		if (R == 1)
			Q <= 0;
		else
			Q <= D;
	end
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFFCE_NP0P_ (D, C, R, E, Q)
//-
//- A negative edge D-type flip-flop with positive polarity synchronous reset and positive
//- polarity clock enable (with clock enable having priority).
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - \\ 1 1 | 0
//-                 d \\ - 1 | d
//-                 - - - - | q
//-
module \\$_SDFFCE_NP0P_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(negedge C) begin
	if (E == 1) begin
		if (R == 1)
			Q <= 0;
		else
			Q <= D;
	end
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFFCE_NP1N_ (D, C, R, E, Q)
//-
//- A negative edge D-type flip-flop with positive polarity synchronous set and negative
//- polarity clock enable (with clock enable having priority).
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - \\ 1 0 | 1
//-                 d \\ - 0 | d
//-                 - - - - | q
//-
module \\$_SDFFCE_NP1N_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(negedge C) begin
	if (E == 0) begin
		if (R == 1)
			Q <= 1;
		else
			Q <= D;
	end
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFFCE_NP1P_ (D, C, R, E, Q)
//-
//- A negative edge D-type flip-flop with positive polarity synchronous set and positive
//- polarity clock enable (with clock enable having priority).
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - \\ 1 1 | 1
//-                 d \\ - 1 | d
//-                 - - - - | q
//-
module \\$_SDFFCE_NP1P_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(negedge C) begin
	if (E == 1) begin
		if (R == 1)
			Q <= 1;
		else
			Q <= D;
	end
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFFCE_PN0N_ (D, C, R, E, Q)
//-
//- A positive edge D-type flip-flop with negative polarity synchronous reset and negative
//- polarity clock enable (with clock enable having priority).
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - / 0 0 | 0
//-                 d / - 0 | d
//-                 - - - - | q
//-
module \\$_SDFFCE_PN0N_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(posedge C) begin
	if (E == 0) begin
		if (R == 0)
			Q <= 0;
		else
			Q <= D;
	end
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFFCE_PN0P_ (D, C, R, E, Q)
//-
//- A positive edge D-type flip-flop with negative polarity synchronous reset and positive
//- polarity clock enable (with clock enable having priority).
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - / 0 1 | 0
//-                 d / - 1 | d
//-                 - - - - | q
//-
module \\$_SDFFCE_PN0P_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(posedge C) begin
	if (E == 1) begin
		if (R == 0)
			Q <= 0;
		else
			Q <= D;
	end
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFFCE_PN1N_ (D, C, R, E, Q)
//-
//- A positive edge D-type flip-flop with negative polarity synchronous set and negative
//- polarity clock enable (with clock enable having priority).
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - / 0 0 | 1
//-                 d / - 0 | d
//-                 - - - - | q
//-
module \\$_SDFFCE_PN1N_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(posedge C) begin
	if (E == 0) begin
		if (R == 0)
			Q <= 1;
		else
			Q <= D;
	end
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFFCE_PN1P_ (D, C, R, E, Q)
//-
//- A positive edge D-type flip-flop with negative polarity synchronous set and positive
//- polarity clock enable (with clock enable having priority).
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - / 0 1 | 1
//-                 d / - 1 | d
//-                 - - - - | q
//-
module \\$_SDFFCE_PN1P_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(posedge C) begin
	if (E == 1) begin
		if (R == 0)
			Q <= 1;
		else
			Q <= D;
	end
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFFCE_PP0N_ (D, C, R, E, Q)
//-
//- A positive edge D-type flip-flop with positive polarity synchronous reset and negative
//- polarity clock enable (with clock enable having priority).
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - / 1 0 | 0
//-                 d / - 0 | d
//-                 - - - - | q
//-
module \\$_SDFFCE_PP0N_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(posedge C) begin
	if (E == 0) begin
		if (R == 1)
			Q <= 0;
		else
			Q <= D;
	end
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFFCE_PP0P_ (D, C, R, E, Q)
//-
//- A positive edge D-type flip-flop with positive polarity synchronous reset and positive
//- polarity clock enable (with clock enable having priority).
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - / 1 1 | 0
//-                 d / - 1 | d
//-                 - - - - | q
//-
module \\$_SDFFCE_PP0P_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(posedge C) begin
	if (E == 1) begin
		if (R == 1)
			Q <= 0;
		else
			Q <= D;
	end
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFFCE_PP1N_ (D, C, R, E, Q)
//-
//- A positive edge D-type flip-flop with positive polarity synchronous set and negative
//- polarity clock enable (with clock enable having priority).
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - / 1 0 | 1
//-                 d / - 0 | d
//-                 - - - - | q
//-
module \\$_SDFFCE_PP1N_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(posedge C) begin
	if (E == 0) begin
		if (R == 1)
			Q <= 1;
		else
			Q <= D;
	end
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_SDFFCE_PP1P_ (D, C, R, E, Q)
//-
//- A positive edge D-type flip-flop with positive polarity synchronous set and positive
//- polarity clock enable (with clock enable having priority).
//-
//- Truth table:    D C R E | Q
//-                ---------+---
//-                 - / 1 1 | 1
//-                 d / - 1 | d
//-                 - - - - | q
//-
module \\$_SDFFCE_PP1P_ (D, C, R, E, Q);
input D, C, R, E;
output reg Q;
always @(posedge C) begin
	if (E == 1) begin
		if (R == 1)
			Q <= 1;
		else
			Q <= D;
	end
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DLATCH_N_ (E, D, Q)
//-
//- A negative enable D-type latch.
//-
//- Truth table:    E D | Q
//-                -----+---
//-                 0 d | d
//-                 - - | q
//-
module \\$_DLATCH_N_ (E, D, Q);
input E, D;
output reg Q;
always @* begin
	if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DLATCH_P_ (E, D, Q)
//-
//- A positive enable D-type latch.
//-
//- Truth table:    E D | Q
//-                -----+---
//-                 1 d | d
//-                 - - | q
//-
module \\$_DLATCH_P_ (E, D, Q);
input E, D;
output reg Q;
always @* begin
	if (E == 1)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DLATCH_NN0_ (E, R, D, Q)
//-
//- A negative enable D-type latch with negative polarity reset.
//-
//- Truth table:    E R D | Q
//-                -------+---
//-                 - 0 - | 0
//-                 0 - d | d
//-                 - - - | q
//-
module \\$_DLATCH_NN0_ (E, R, D, Q);
input E, R, D;
output reg Q;
always @* begin
	if (R == 0)
                Q <= 0;
	else if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DLATCH_NN1_ (E, R, D, Q)
//-
//- A negative enable D-type latch with negative polarity set.
//-
//- Truth table:    E R D | Q
//-                -------+---
//-                 - 0 - | 1
//-                 0 - d | d
//-                 - - - | q
//-
module \\$_DLATCH_NN1_ (E, R, D, Q);
input E, R, D;
output reg Q;
always @* begin
	if (R == 0)
                Q <= 1;
	else if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DLATCH_NP0_ (E, R, D, Q)
//-
//- A negative enable D-type latch with positive polarity reset.
//-
//- Truth table:    E R D | Q
//-                -------+---
//-                 - 1 - | 0
//-                 0 - d | d
//-                 - - - | q
//-
module \\$_DLATCH_NP0_ (E, R, D, Q);
input E, R, D;
output reg Q;
always @* begin
	if (R == 1)
                Q <= 0;
	else if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DLATCH_NP1_ (E, R, D, Q)
//-
//- A negative enable D-type latch with positive polarity set.
//-
//- Truth table:    E R D | Q
//-                -------+---
//-                 - 1 - | 1
//-                 0 - d | d
//-                 - - - | q
//-
module \\$_DLATCH_NP1_ (E, R, D, Q);
input E, R, D;
output reg Q;
always @* begin
	if (R == 1)
                Q <= 1;
	else if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DLATCH_PN0_ (E, R, D, Q)
//-
//- A positive enable D-type latch with negative polarity reset.
//-
//- Truth table:    E R D | Q
//-                -------+---
//-                 - 0 - | 0
//-                 1 - d | d
//-                 - - - | q
//-
module \\$_DLATCH_PN0_ (E, R, D, Q);
input E, R, D;
output reg Q;
always @* begin
	if (R == 0)
                Q <= 0;
	else if (E == 1)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DLATCH_PN1_ (E, R, D, Q)
//-
//- A positive enable D-type latch with negative polarity set.
//-
//- Truth table:    E R D | Q
//-                -------+---
//-                 - 0 - | 1
//-                 1 - d | d
//-                 - - - | q
//-
module \\$_DLATCH_PN1_ (E, R, D, Q);
input E, R, D;
output reg Q;
always @* begin
	if (R == 0)
                Q <= 1;
	else if (E == 1)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DLATCH_PP0_ (E, R, D, Q)
//-
//- A positive enable D-type latch with positive polarity reset.
//-
//- Truth table:    E R D | Q
//-                -------+---
//-                 - 1 - | 0
//-                 1 - d | d
//-                 - - - | q
//-
module \\$_DLATCH_PP0_ (E, R, D, Q);
input E, R, D;
output reg Q;
always @* begin
	if (R == 1)
                Q <= 0;
	else if (E == 1)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DLATCH_PP1_ (E, R, D, Q)
//-
//- A positive enable D-type latch with positive polarity set.
//-
//- Truth table:    E R D | Q
//-                -------+---
//-                 - 1 - | 1
//-                 1 - d | d
//-                 - - - | q
//-
module \\$_DLATCH_PP1_ (E, R, D, Q);
input E, R, D;
output reg Q;
always @* begin
	if (R == 1)
                Q <= 1;
	else if (E == 1)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DLATCHSR_NNN_ (E, S, R, D, Q)
//-
//- A negative enable D-type latch with negative polarity set and negative
//- polarity reset.
//-
//- Truth table:    E S R D | Q
//-                ---------+---
//-                 - - 0 - | 0
//-                 - 0 - - | 1
//-                 0 - - d | d
//-                 - - - - | q
//-
module \\$_DLATCHSR_NNN_ (E, S, R, D, Q);
input E, S, R, D;
output reg Q;
always @* begin
	if (R == 0)
		Q <= 0;
	else if (S == 0)
		Q <= 1;
	else if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DLATCHSR_NNP_ (E, S, R, D, Q)
//-
//- A negative enable D-type latch with negative polarity set and positive
//- polarity reset.
//-
//- Truth table:    E S R D | Q
//-                ---------+---
//-                 - - 1 - | 0
//-                 - 0 - - | 1
//-                 0 - - d | d
//-                 - - - - | q
//-
module \\$_DLATCHSR_NNP_ (E, S, R, D, Q);
input E, S, R, D;
output reg Q;
always @* begin
	if (R == 1)
		Q <= 0;
	else if (S == 0)
		Q <= 1;
	else if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DLATCHSR_NPN_ (E, S, R, D, Q)
//-
//- A negative enable D-type latch with positive polarity set and negative
//- polarity reset.
//-
//- Truth table:    E S R D | Q
//-                ---------+---
//-                 - - 0 - | 0
//-                 - 1 - - | 1
//-                 0 - - d | d
//-                 - - - - | q
//-
module \\$_DLATCHSR_NPN_ (E, S, R, D, Q);
input E, S, R, D;
output reg Q;
always @* begin
	if (R == 0)
		Q <= 0;
	else if (S == 1)
		Q <= 1;
	else if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DLATCHSR_NPP_ (E, S, R, D, Q)
//-
//- A negative enable D-type latch with positive polarity set and positive
//- polarity reset.
//-
//- Truth table:    E S R D | Q
//-                ---------+---
//-                 - - 1 - | 0
//-                 - 1 - - | 1
//-                 0 - - d | d
//-                 - - - - | q
//-
module \\$_DLATCHSR_NPP_ (E, S, R, D, Q);
input E, S, R, D;
output reg Q;
always @* begin
	if (R == 1)
		Q <= 0;
	else if (S == 1)
		Q <= 1;
	else if (E == 0)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DLATCHSR_PNN_ (E, S, R, D, Q)
//-
//- A positive enable D-type latch with negative polarity set and negative
//- polarity reset.
//-
//- Truth table:    E S R D | Q
//-                ---------+---
//-                 - - 0 - | 0
//-                 - 0 - - | 1
//-                 1 - - d | d
//-                 - - - - | q
//-
module \\$_DLATCHSR_PNN_ (E, S, R, D, Q);
input E, S, R, D;
output reg Q;
always @* begin
	if (R == 0)
		Q <= 0;
	else if (S == 0)
		Q <= 1;
	else if (E == 1)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DLATCHSR_PNP_ (E, S, R, D, Q)
//-
//- A positive enable D-type latch with negative polarity set and positive
//- polarity reset.
//-
//- Truth table:    E S R D | Q
//-                ---------+---
//-                 - - 1 - | 0
//-                 - 0 - - | 1
//-                 1 - - d | d
//-                 - - - - | q
//-
module \\$_DLATCHSR_PNP_ (E, S, R, D, Q);
input E, S, R, D;
output reg Q;
always @* begin
	if (R == 1)
		Q <= 0;
	else if (S == 0)
		Q <= 1;
	else if (E == 1)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DLATCHSR_PPN_ (E, S, R, D, Q)
//-
//- A positive enable D-type latch with positive polarity set and negative
//- polarity reset.
//-
//- Truth table:    E S R D | Q
//-                ---------+---
//-                 - - 0 - | 0
//-                 - 1 - - | 1
//-                 1 - - d | d
//-                 - - - - | q
//-
module \\$_DLATCHSR_PPN_ (E, S, R, D, Q);
input E, S, R, D;
output reg Q;
always @* begin
	if (R == 0)
		Q <= 0;
	else if (S == 1)
		Q <= 1;
	else if (E == 1)
		Q <= D;
end
endmodule

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $_DLATCHSR_PPP_ (E, S, R, D, Q)
//-
//- A positive enable D-type latch with positive polarity set and positive
//- polarity reset.
//-
//- Truth table:    E S R D | Q
//-                ---------+---
//-                 - - 1 - | 0
//-                 - 1 - - | 1
//-                 1 - - d | d
//-                 - - - - | q
//-
module \\$_DLATCHSR_PPP_ (E, S, R, D, Q);
input E, S, R, D;
output reg Q;
always @* begin
	if (R == 1)
		Q <= 0;
	else if (S == 1)
		Q <= 1;
	else if (E == 1)
		Q <= D;
end
endmodule
`,"simlib.v":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 *  ---
 *
 *  The Simulation Library.
 *
 *  This Verilog library contains simple simulation models for the internal
 *  cells ($not, ...) generated by the frontends and used in most passes.
 *
 *  This library can be used to verify the internal netlists as generated
 *  by the different frontends and passes.
 *
 *  Note that memory can only be simulated when all $memrd and $memwr cells
 *  have been merged to stand-alone $mem cells (this is what the "memory_collect"
 *  pass is doing).
 *
 */

// --------------------------------------------------------

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $not (A, Y)
//-
//- A bit-wise inverter. This corresponds to the Verilog unary prefix '~' operator.
//-
module \\$not (A, Y);

parameter A_SIGNED = 0;
parameter A_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
output [Y_WIDTH-1:0] Y;

generate
	if (A_SIGNED) begin:BLOCK1
		assign Y = ~$signed(A);
	end else begin:BLOCK2
		assign Y = ~A;
	end
endgenerate

endmodule


// --------------------------------------------------------

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $pos (A, Y)
//-
//- A buffer. This corresponds to the Verilog unary prefix '+' operator.
//-
module \\$pos (A, Y);

parameter A_SIGNED = 0;
parameter A_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
output [Y_WIDTH-1:0] Y;

generate
	if (A_SIGNED) begin:BLOCK1
		assign Y = $signed(A);
	end else begin:BLOCK2
		assign Y = A;
	end
endgenerate

endmodule

// --------------------------------------------------------

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $neg (A, Y)
//-
//- An arithmetic inverter. This corresponds to the Verilog unary prefix '-' operator.
//-
module \\$neg (A, Y);

parameter A_SIGNED = 0;
parameter A_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
output [Y_WIDTH-1:0] Y;

generate
	if (A_SIGNED) begin:BLOCK1
		assign Y = -$signed(A);
	end else begin:BLOCK2
		assign Y = -A;
	end
endgenerate

endmodule

// --------------------------------------------------------

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $and (A, B, Y)
//-
//- A bit-wise AND. This corresponds to the Verilog '&' operator.
//-
module \\$and (A, B, Y);

parameter A_SIGNED = 0;
parameter B_SIGNED = 0;
parameter A_WIDTH = 0;
parameter B_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
input [B_WIDTH-1:0] B;
output [Y_WIDTH-1:0] Y;

generate
	if (A_SIGNED && B_SIGNED) begin:BLOCK1
		assign Y = $signed(A) & $signed(B);
	end else begin:BLOCK2
		assign Y = A & B;
	end
endgenerate

endmodule

// --------------------------------------------------------

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $or (A, B, Y)
//-
//- A bit-wise OR. This corresponds to the Verilog '|' operator.
//-
module \\$or (A, B, Y);

parameter A_SIGNED = 0;
parameter B_SIGNED = 0;
parameter A_WIDTH = 0;
parameter B_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
input [B_WIDTH-1:0] B;
output [Y_WIDTH-1:0] Y;

generate
	if (A_SIGNED && B_SIGNED) begin:BLOCK1
		assign Y = $signed(A) | $signed(B);
	end else begin:BLOCK2
		assign Y = A | B;
	end
endgenerate

endmodule

// --------------------------------------------------------

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $xor (A, B, Y)
//-
//- A bit-wise XOR. This corresponds to the Verilog '^' operator.
//-
module \\$xor (A, B, Y);

parameter A_SIGNED = 0;
parameter B_SIGNED = 0;
parameter A_WIDTH = 0;
parameter B_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
input [B_WIDTH-1:0] B;
output [Y_WIDTH-1:0] Y;

generate
	if (A_SIGNED && B_SIGNED) begin:BLOCK1
		assign Y = $signed(A) ^ $signed(B);
	end else begin:BLOCK2
		assign Y = A ^ B;
	end
endgenerate

endmodule

// --------------------------------------------------------

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $xnor (A, B, Y)
//-
//- A bit-wise XNOR. This corresponds to the Verilog '~^' operator.
//-
module \\$xnor (A, B, Y);

parameter A_SIGNED = 0;
parameter B_SIGNED = 0;
parameter A_WIDTH = 0;
parameter B_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
input [B_WIDTH-1:0] B;
output [Y_WIDTH-1:0] Y;

generate
	if (A_SIGNED && B_SIGNED) begin:BLOCK1
		assign Y = $signed(A) ~^ $signed(B);
	end else begin:BLOCK2
		assign Y = A ~^ B;
	end
endgenerate

endmodule

// --------------------------------------------------------

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $reduce_and (A, Y)
//-
//- An AND reduction. This corresponds to the Verilog unary prefix '&' operator.
//-
module \\$reduce_and (A, Y);

parameter A_SIGNED = 0;
parameter A_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
output [Y_WIDTH-1:0] Y;

generate
	if (A_SIGNED) begin:BLOCK1
		assign Y = &$signed(A);
	end else begin:BLOCK2
		assign Y = &A;
	end
endgenerate

endmodule

// --------------------------------------------------------

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $reduce_or (A, Y)
//-
//- An OR reduction. This corresponds to the Verilog unary prefix '|' operator.
//-
module \\$reduce_or (A, Y);

parameter A_SIGNED = 0;
parameter A_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
output [Y_WIDTH-1:0] Y;

generate
	if (A_SIGNED) begin:BLOCK1
		assign Y = |$signed(A);
	end else begin:BLOCK2
		assign Y = |A;
	end
endgenerate

endmodule

// --------------------------------------------------------

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $reduce_xor (A, Y)
//-
//- A XOR reduction. This corresponds to the Verilog unary prefix '^' operator.
//-
module \\$reduce_xor (A, Y);

parameter A_SIGNED = 0;
parameter A_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
output [Y_WIDTH-1:0] Y;

generate
	if (A_SIGNED) begin:BLOCK1
		assign Y = ^$signed(A);
	end else begin:BLOCK2
		assign Y = ^A;
	end
endgenerate

endmodule

// --------------------------------------------------------

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $reduce_xnor (A, Y)
//-
//- A XNOR reduction. This corresponds to the Verilog unary prefix '~^' operator.
//-
module \\$reduce_xnor (A, Y);

parameter A_SIGNED = 0;
parameter A_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
output [Y_WIDTH-1:0] Y;

generate
	if (A_SIGNED) begin:BLOCK1
		assign Y = ~^$signed(A);
	end else begin:BLOCK2
		assign Y = ~^A;
	end
endgenerate

endmodule

// --------------------------------------------------------

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $reduce_bool (A, Y)
//-
//- An OR reduction. This cell type is used instead of $reduce_or when a signal is
//- implicitly converted to a boolean signal, e.g. for operands of '&&' and '||'.
//-
module \\$reduce_bool (A, Y);

parameter A_SIGNED = 0;
parameter A_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
output [Y_WIDTH-1:0] Y;

generate
	if (A_SIGNED) begin:BLOCK1
		assign Y = !(!$signed(A));
	end else begin:BLOCK2
		assign Y = !(!A);
	end
endgenerate

endmodule

// --------------------------------------------------------

module \\$shl (A, B, Y);

parameter A_SIGNED = 0;
parameter B_SIGNED = 0;
parameter A_WIDTH = 0;
parameter B_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
input [B_WIDTH-1:0] B;
output [Y_WIDTH-1:0] Y;

generate
	if (A_SIGNED) begin:BLOCK1
		assign Y = $signed(A) << B;
	end else begin:BLOCK2
		assign Y = A << B;
	end
endgenerate

endmodule

// --------------------------------------------------------

module \\$shr (A, B, Y);

parameter A_SIGNED = 0;
parameter B_SIGNED = 0;
parameter A_WIDTH = 0;
parameter B_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
input [B_WIDTH-1:0] B;
output [Y_WIDTH-1:0] Y;

generate
	if (A_SIGNED) begin:BLOCK1
		assign Y = $signed(A) >> B;
	end else begin:BLOCK2
		assign Y = A >> B;
	end
endgenerate

endmodule

// --------------------------------------------------------

module \\$sshl (A, B, Y);

parameter A_SIGNED = 0;
parameter B_SIGNED = 0;
parameter A_WIDTH = 0;
parameter B_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
input [B_WIDTH-1:0] B;
output [Y_WIDTH-1:0] Y;

generate
	if (A_SIGNED) begin:BLOCK1
		assign Y = $signed(A) <<< B;
	end else begin:BLOCK2
		assign Y = A <<< B;
	end
endgenerate

endmodule

// --------------------------------------------------------

module \\$sshr (A, B, Y);

parameter A_SIGNED = 0;
parameter B_SIGNED = 0;
parameter A_WIDTH = 0;
parameter B_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
input [B_WIDTH-1:0] B;
output [Y_WIDTH-1:0] Y;

generate
	if (A_SIGNED) begin:BLOCK1
		assign Y = $signed(A) >>> B;
	end else begin:BLOCK2
		assign Y = A >>> B;
	end
endgenerate

endmodule

// --------------------------------------------------------

module \\$shift (A, B, Y);

parameter A_SIGNED = 0;
parameter B_SIGNED = 0;
parameter A_WIDTH = 0;
parameter B_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
input [B_WIDTH-1:0] B;
output [Y_WIDTH-1:0] Y;

generate
	if (A_SIGNED) begin:BLOCK1
		if (B_SIGNED) begin:BLOCK2
			assign Y = $signed(B) < 0 ? $signed(A) << -B : $signed(A) >> B;
		end else begin:BLOCK3
			assign Y = $signed(A) >> B;
		end
	end else begin:BLOCK4
		if (B_SIGNED) begin:BLOCK5
			assign Y = $signed(B) < 0 ? A << -B : A >> B;
		end else begin:BLOCK6
			assign Y = A >> B;
		end
	end
endgenerate

endmodule

// --------------------------------------------------------

module \\$shiftx (A, B, Y);

parameter A_SIGNED = 0;
parameter B_SIGNED = 0;
parameter A_WIDTH = 0;
parameter B_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
input [B_WIDTH-1:0] B;
output [Y_WIDTH-1:0] Y;

generate
	if (Y_WIDTH > 0)
		if (B_SIGNED) begin:BLOCK1
			assign Y = A[$signed(B) +: Y_WIDTH];
		end else begin:BLOCK2
			assign Y = A[B +: Y_WIDTH];
		end
endgenerate

endmodule

// --------------------------------------------------------

module \\$fa (A, B, C, X, Y);

parameter WIDTH = 1;

input [WIDTH-1:0] A, B, C;
output [WIDTH-1:0] X, Y;

wire [WIDTH-1:0] t1, t2, t3;

assign t1 = A ^ B, t2 = A & B, t3 = C & t1;
assign Y = t1 ^ C, X = (t2 | t3) ^ (Y ^ Y);

endmodule

// --------------------------------------------------------

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $lcu (P, G, CI, CO)
//-
//- Lookahead carry unit
//- A building block dedicated to fast computation of carry-bits used in binary
//- arithmetic operations. By replacing the ripple carry structure used in full-adder
//- blocks, the more significant  bits of the sum can be expected to be computed more
//- quickly.
//- Typically created during \`techmap\` of $alu cells (see the "_90_alu" rule in
//- +/techmap.v).
module \\$lcu (P, G, CI, CO);

parameter WIDTH = 1;

input [WIDTH-1:0] P;    // Propagate
input [WIDTH-1:0] G;    // Generate
input CI;               // Carry-in

output reg [WIDTH-1:0] CO; // Carry-out

integer i;
always @* begin
	CO = 'bx;
	if (^{P, G, CI} !== 1'bx) begin
		CO[0] = G[0] || (P[0] && CI);
		for (i = 1; i < WIDTH; i = i+1)
			CO[i] = G[i] || (P[i] && CO[i-1]);
	end
end

endmodule

// --------------------------------------------------------

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $alu (A, B, CI, BI, X, Y, CO)
//-
//- Arithmetic logic unit.
//- A building block supporting both binary addition/subtraction operations, and
//- indirectly, comparison operations.
//- Typically created by the \`alumacc\` pass, which transforms:
//-   $add, $sub, $lt, $le, $ge, $gt, $eq, $eqx, $ne, $nex
//- cells into this $alu cell.
//-
module \\$alu (A, B, CI, BI, X, Y, CO);

parameter A_SIGNED = 0;
parameter B_SIGNED = 0;
parameter A_WIDTH = 1;
parameter B_WIDTH = 1;
parameter Y_WIDTH = 1;

input [A_WIDTH-1:0] A;      // Input operand
input [B_WIDTH-1:0] B;      // Input operand
output [Y_WIDTH-1:0] X;     // A xor B (sign-extended, optional B inversion,
                            //          used in combination with
                            //          reduction-AND for $eq/$ne ops)
output [Y_WIDTH-1:0] Y;     // Sum

input CI;                   // Carry-in (set for $sub)
input BI;                   // Invert-B (set for $sub)
output [Y_WIDTH-1:0] CO;    // Carry-out

wire [Y_WIDTH-1:0] AA, BB;

generate
	if (A_SIGNED && B_SIGNED) begin:BLOCK1
		assign AA = $signed(A), BB = BI ? ~$signed(B) : $signed(B);
	end else begin:BLOCK2
		assign AA = $unsigned(A), BB = BI ? ~$unsigned(B) : $unsigned(B);
	end
endgenerate

// this is 'x' if Y and CO should be all 'x', and '0' otherwise
wire y_co_undef = ^{A, A, B, B, CI, CI, BI, BI};

assign X = AA ^ BB;
// Full adder
assign Y = (AA + BB + CI) ^ {Y_WIDTH{y_co_undef}};

function get_carry;
	input a, b, c;
	get_carry = (a&b) | (a&c) | (b&c);
endfunction

genvar i;
generate
	assign CO[0] = get_carry(AA[0], BB[0], CI) ^ y_co_undef;
	for (i = 1; i < Y_WIDTH; i = i+1) begin:BLOCK3
		assign CO[i] = get_carry(AA[i], BB[i], CO[i-1]) ^ y_co_undef;
	end
endgenerate

endmodule

// --------------------------------------------------------

module \\$lt (A, B, Y);

parameter A_SIGNED = 0;
parameter B_SIGNED = 0;
parameter A_WIDTH = 0;
parameter B_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
input [B_WIDTH-1:0] B;
output [Y_WIDTH-1:0] Y;

generate
	if (A_SIGNED && B_SIGNED) begin:BLOCK1
		assign Y = $signed(A) < $signed(B);
	end else begin:BLOCK2
		assign Y = A < B;
	end
endgenerate

endmodule

// --------------------------------------------------------

module \\$le (A, B, Y);

parameter A_SIGNED = 0;
parameter B_SIGNED = 0;
parameter A_WIDTH = 0;
parameter B_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
input [B_WIDTH-1:0] B;
output [Y_WIDTH-1:0] Y;

generate
	if (A_SIGNED && B_SIGNED) begin:BLOCK1
		assign Y = $signed(A) <= $signed(B);
	end else begin:BLOCK2
		assign Y = A <= B;
	end
endgenerate

endmodule

// --------------------------------------------------------

module \\$eq (A, B, Y);

parameter A_SIGNED = 0;
parameter B_SIGNED = 0;
parameter A_WIDTH = 0;
parameter B_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
input [B_WIDTH-1:0] B;
output [Y_WIDTH-1:0] Y;

generate
	if (A_SIGNED && B_SIGNED) begin:BLOCK1
		assign Y = $signed(A) == $signed(B);
	end else begin:BLOCK2
		assign Y = A == B;
	end
endgenerate

endmodule

// --------------------------------------------------------

module \\$ne (A, B, Y);

parameter A_SIGNED = 0;
parameter B_SIGNED = 0;
parameter A_WIDTH = 0;
parameter B_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
input [B_WIDTH-1:0] B;
output [Y_WIDTH-1:0] Y;

generate
	if (A_SIGNED && B_SIGNED) begin:BLOCK1
		assign Y = $signed(A) != $signed(B);
	end else begin:BLOCK2
		assign Y = A != B;
	end
endgenerate

endmodule

// --------------------------------------------------------

module \\$eqx (A, B, Y);

parameter A_SIGNED = 0;
parameter B_SIGNED = 0;
parameter A_WIDTH = 0;
parameter B_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
input [B_WIDTH-1:0] B;
output [Y_WIDTH-1:0] Y;

generate
	if (A_SIGNED && B_SIGNED) begin:BLOCK1
		assign Y = $signed(A) === $signed(B);
	end else begin:BLOCK2
		assign Y = A === B;
	end
endgenerate

endmodule

// --------------------------------------------------------

module \\$nex (A, B, Y);

parameter A_SIGNED = 0;
parameter B_SIGNED = 0;
parameter A_WIDTH = 0;
parameter B_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
input [B_WIDTH-1:0] B;
output [Y_WIDTH-1:0] Y;

generate
	if (A_SIGNED && B_SIGNED) begin:BLOCK1
		assign Y = $signed(A) !== $signed(B);
	end else begin:BLOCK2
		assign Y = A !== B;
	end
endgenerate

endmodule

// --------------------------------------------------------

module \\$ge (A, B, Y);

parameter A_SIGNED = 0;
parameter B_SIGNED = 0;
parameter A_WIDTH = 0;
parameter B_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
input [B_WIDTH-1:0] B;
output [Y_WIDTH-1:0] Y;

generate
	if (A_SIGNED && B_SIGNED) begin:BLOCK1
		assign Y = $signed(A) >= $signed(B);
	end else begin:BLOCK2
		assign Y = A >= B;
	end
endgenerate

endmodule

// --------------------------------------------------------

module \\$gt (A, B, Y);

parameter A_SIGNED = 0;
parameter B_SIGNED = 0;
parameter A_WIDTH = 0;
parameter B_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
input [B_WIDTH-1:0] B;
output [Y_WIDTH-1:0] Y;

generate
	if (A_SIGNED && B_SIGNED) begin:BLOCK1
		assign Y = $signed(A) > $signed(B);
	end else begin:BLOCK2
		assign Y = A > B;
	end
endgenerate

endmodule

// --------------------------------------------------------

module \\$add (A, B, Y);

parameter A_SIGNED = 0;
parameter B_SIGNED = 0;
parameter A_WIDTH = 0;
parameter B_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
input [B_WIDTH-1:0] B;
output [Y_WIDTH-1:0] Y;

generate
	if (A_SIGNED && B_SIGNED) begin:BLOCK1
		assign Y = $signed(A) + $signed(B);
	end else begin:BLOCK2
		assign Y = A + B;
	end
endgenerate

endmodule

// --------------------------------------------------------

module \\$sub (A, B, Y);

parameter A_SIGNED = 0;
parameter B_SIGNED = 0;
parameter A_WIDTH = 0;
parameter B_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
input [B_WIDTH-1:0] B;
output [Y_WIDTH-1:0] Y;

generate
	if (A_SIGNED && B_SIGNED) begin:BLOCK1
		assign Y = $signed(A) - $signed(B);
	end else begin:BLOCK2
		assign Y = A - B;
	end
endgenerate

endmodule

// --------------------------------------------------------

module \\$mul (A, B, Y);

parameter A_SIGNED = 0;
parameter B_SIGNED = 0;
parameter A_WIDTH = 0;
parameter B_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
input [B_WIDTH-1:0] B;
output [Y_WIDTH-1:0] Y;

generate
	if (A_SIGNED && B_SIGNED) begin:BLOCK1
		assign Y = $signed(A) * $signed(B);
	end else begin:BLOCK2
		assign Y = A * B;
	end
endgenerate

endmodule

// --------------------------------------------------------
//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $macc (A, B, Y)
//-
//- Multiply and accumulate.
//- A building block for summing any number of negated and unnegated signals
//- and arithmetic products of pairs of signals. Cell port A concatenates pairs
//- of signals to be multiplied together. When the second signal in a pair is zero
//- length, a constant 1 is used instead as the second factor. Cell port B
//- concatenates 1-bit-wide signals to also be summed, such as "carry in" in adders.
//- Typically created by the \`alumacc\` pass, which transforms $add and $mul
//- into $macc cells.
module \\$macc (A, B, Y);

parameter A_WIDTH = 0;
parameter B_WIDTH = 0;
parameter Y_WIDTH = 0;
// CONFIG determines the layout of A, as explained below
parameter CONFIG = 4'b0000;
parameter CONFIG_WIDTH = 4;

// In the terms used for this cell, there's mixed meanings for the term "port". To disambiguate:
// A cell port is for example the A input (it is constructed in C++ as cell->setPort(ID::A, ...))
// Multiplier ports are pairs of multiplier inputs ("factors").
// If the second signal in such a pair is zero length, no multiplication is necessary, and the first signal is just added to the sum.
input [A_WIDTH-1:0] A; // Cell port A is the concatenation of all arithmetic ports
input [B_WIDTH-1:0] B; // Cell port B is the concatenation of single-bit unsigned signals to be also added to the sum
output reg [Y_WIDTH-1:0] Y; // Output sum

// Xilinx XSIM does not like $clog2() below..
function integer my_clog2;
	input integer v;
	begin
		if (v > 0)
			v = v - 1;
		my_clog2 = 0;
		while (v) begin
			v = v >> 1;
			my_clog2 = my_clog2 + 1;
		end
	end
endfunction

// Bits that a factor's length field in CONFIG per factor in cell port A
localparam integer num_bits = CONFIG[3:0] > 0 ? CONFIG[3:0] : 1;
// Number of multiplier ports
localparam integer num_ports = (CONFIG_WIDTH-4) / (2 + 2*num_bits);
// Minium bit width of an induction variable to iterate over all bits of cell port A
localparam integer num_abits = my_clog2(A_WIDTH) > 0 ? my_clog2(A_WIDTH) : 1;

// In this pseudocode, u(foo) means an unsigned int that's foo bits long.
// The CONFIG parameter carries the following information:
//	struct CONFIG {
//		u4 num_bits;
//		struct port_field {
//			bool is_signed;
//			bool is_subtract;
//			u(num_bits) factor1_len;
//			u(num_bits) factor2_len;
//		}[num_ports];
//	};

// The A cell port carries the following information:
//	struct A {
//		u(CONFIG.port_field[0].factor1_len) port0factor1;
//		u(CONFIG.port_field[0].factor2_len) port0factor2;
//		u(CONFIG.port_field[1].factor1_len) port1factor1;
//		u(CONFIG.port_field[1].factor2_len) port1factor2;
//		...
//	};
// and log(sizeof(A)) is num_abits.
// No factor1 may have a zero length.
// A factor2 having a zero length implies factor2 is replaced with a constant 1.

// Additionally, B is an array of 1-bit-wide unsigned integers to also be summed up.
// Finally, we have:
// Y = port0factor1 * port0factor2 + port1factor1 * port1factor2 + ...
//     * B[0] + B[1] + ...

function [2*num_ports*num_abits-1:0] get_port_offsets;
	input [CONFIG_WIDTH-1:0] cfg;
	integer i, cursor;
	begin
		cursor = 0;
		get_port_offsets = 0;
		for (i = 0; i < num_ports; i = i+1) begin
			get_port_offsets[(2*i + 0)*num_abits +: num_abits] = cursor;
			cursor = cursor + cfg[4 + i*(2 + 2*num_bits) + 2 +: num_bits];
			get_port_offsets[(2*i + 1)*num_abits +: num_abits] = cursor;
			cursor = cursor + cfg[4 + i*(2 + 2*num_bits) + 2 + num_bits +: num_bits];
		end
	end
endfunction

localparam [2*num_ports*num_abits-1:0] port_offsets = get_port_offsets(CONFIG);

\`define PORT_IS_SIGNED   (0 + CONFIG[4 + i*(2 + 2*num_bits)])
\`define PORT_DO_SUBTRACT (0 + CONFIG[4 + i*(2 + 2*num_bits) + 1])
\`define PORT_SIZE_A      (0 + CONFIG[4 + i*(2 + 2*num_bits) + 2 +: num_bits])
\`define PORT_SIZE_B      (0 + CONFIG[4 + i*(2 + 2*num_bits) + 2 + num_bits +: num_bits])
\`define PORT_OFFSET_A    (0 + port_offsets[2*i*num_abits +: num_abits])
\`define PORT_OFFSET_B    (0 + port_offsets[2*i*num_abits + num_abits +: num_abits])

integer i, j;
reg [Y_WIDTH-1:0] tmp_a, tmp_b;

always @* begin
	Y = 0;
	for (i = 0; i < num_ports; i = i+1)
	begin
		tmp_a = 0;
		tmp_b = 0;

		for (j = 0; j < \`PORT_SIZE_A; j = j+1)
			tmp_a[j] = A[\`PORT_OFFSET_A + j];

		if (\`PORT_IS_SIGNED && \`PORT_SIZE_A > 0)
			for (j = \`PORT_SIZE_A; j < Y_WIDTH; j = j+1)
				tmp_a[j] = tmp_a[\`PORT_SIZE_A-1];

		for (j = 0; j < \`PORT_SIZE_B; j = j+1)
			tmp_b[j] = A[\`PORT_OFFSET_B + j];

		if (\`PORT_IS_SIGNED && \`PORT_SIZE_B > 0)
			for (j = \`PORT_SIZE_B; j < Y_WIDTH; j = j+1)
				tmp_b[j] = tmp_b[\`PORT_SIZE_B-1];

		if (\`PORT_SIZE_B > 0)
			tmp_a = tmp_a * tmp_b;

		if (\`PORT_DO_SUBTRACT)
			Y = Y - tmp_a;
		else
			Y = Y + tmp_a;
	end
	for (i = 0; i < B_WIDTH; i = i+1) begin
		Y = Y + B[i];
	end
end

\`undef PORT_IS_SIGNED
\`undef PORT_DO_SUBTRACT
\`undef PORT_SIZE_A
\`undef PORT_SIZE_B
\`undef PORT_OFFSET_A
\`undef PORT_OFFSET_B

endmodule

// --------------------------------------------------------

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $div (A, B, Y)
//-
//- Division with truncated result (rounded towards 0).
//-
module \\$div (A, B, Y);

parameter A_SIGNED = 0;
parameter B_SIGNED = 0;
parameter A_WIDTH = 0;
parameter B_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
input [B_WIDTH-1:0] B;
output [Y_WIDTH-1:0] Y;

generate
	if (A_SIGNED && B_SIGNED) begin:BLOCK1
		assign Y = $signed(A) / $signed(B);
	end else begin:BLOCK2
		assign Y = A / B;
	end
endgenerate

endmodule

// --------------------------------------------------------

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $mod (A, B, Y)
//-
//- Modulo/remainder of division with truncated result (rounded towards 0).
//-
//- Invariant: $div(A, B) * B + $mod(A, B) == A
//-
module \\$mod (A, B, Y);

parameter A_SIGNED = 0;
parameter B_SIGNED = 0;
parameter A_WIDTH = 0;
parameter B_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
input [B_WIDTH-1:0] B;
output [Y_WIDTH-1:0] Y;

generate
	if (A_SIGNED && B_SIGNED) begin:BLOCK1
		assign Y = $signed(A) % $signed(B);
	end else begin:BLOCK2
		assign Y = A % B;
	end
endgenerate

endmodule

// --------------------------------------------------------

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $divfloor (A, B, Y)
//-
//- Division with floored result (rounded towards negative infinity).
//-
module \\$divfloor (A, B, Y);

parameter A_SIGNED = 0;
parameter B_SIGNED = 0;
parameter A_WIDTH = 0;
parameter B_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
input [B_WIDTH-1:0] B;
output [Y_WIDTH-1:0] Y;

generate
	if (A_SIGNED && B_SIGNED) begin:BLOCK1
		localparam WIDTH =
				A_WIDTH >= B_WIDTH && A_WIDTH >= Y_WIDTH ? A_WIDTH :
				B_WIDTH >= A_WIDTH && B_WIDTH >= Y_WIDTH ? B_WIDTH : Y_WIDTH;
		wire [WIDTH:0] A_buf, B_buf, N_buf;
		assign A_buf = $signed(A);
		assign B_buf = $signed(B);
		assign N_buf = (A[A_WIDTH-1] == B[B_WIDTH-1]) || A == 0 ? A_buf : $signed(A_buf - (B[B_WIDTH-1] ? B_buf+1 : B_buf-1));
		assign Y = $signed(N_buf) / $signed(B_buf);
	end else begin:BLOCK2
		assign Y = A / B;
	end
endgenerate

endmodule

// --------------------------------------------------------

//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
//-
//-     $modfloor (A, B, Y)
//-
//- Modulo/remainder of division with floored result (rounded towards negative infinity).
//-
//- Invariant: $divfloor(A, B) * B + $modfloor(A, B) == A
//-
module \\$modfloor (A, B, Y);

parameter A_SIGNED = 0;
parameter B_SIGNED = 0;
parameter A_WIDTH = 0;
parameter B_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
input [B_WIDTH-1:0] B;
output [Y_WIDTH-1:0] Y;

generate
	if (A_SIGNED && B_SIGNED) begin:BLOCK1
		localparam WIDTH = B_WIDTH >= Y_WIDTH ? B_WIDTH : Y_WIDTH;
		wire [WIDTH-1:0] B_buf, Y_trunc;
		assign B_buf = $signed(B);
		assign Y_trunc = $signed(A) % $signed(B);
		// flooring mod is the same as truncating mod for positive division results (A and B have
		// the same sign), as well as when there's no remainder.
		// For all other cases, they behave as \`floor - trunc = B\`
		assign Y = (A[A_WIDTH-1] == B[B_WIDTH-1]) || Y_trunc == 0 ? Y_trunc : $signed(B_buf) + $signed(Y_trunc);
	end else begin:BLOCK2
		// no difference between truncating and flooring for unsigned
		assign Y = A % B;
	end
endgenerate

endmodule

// --------------------------------------------------------
\`ifndef SIMLIB_NOPOW

module \\$pow (A, B, Y);

parameter A_SIGNED = 0;
parameter B_SIGNED = 0;
parameter A_WIDTH = 0;
parameter B_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
input [B_WIDTH-1:0] B;
output [Y_WIDTH-1:0] Y;

generate
	if (A_SIGNED && B_SIGNED) begin:BLOCK1
		assign Y = $signed(A) ** $signed(B);
	end else if (A_SIGNED) begin:BLOCK2
		assign Y = $signed(A) ** B;
	end else if (B_SIGNED) begin:BLOCK3
		assign Y = A ** $signed(B);
	end else begin:BLOCK4
		assign Y = A ** B;
	end
endgenerate

endmodule

\`endif
// --------------------------------------------------------

module \\$logic_not (A, Y);

parameter A_SIGNED = 0;
parameter A_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
output [Y_WIDTH-1:0] Y;

generate
	if (A_SIGNED) begin:BLOCK1
		assign Y = !$signed(A);
	end else begin:BLOCK2
		assign Y = !A;
	end
endgenerate

endmodule

// --------------------------------------------------------

module \\$logic_and (A, B, Y);

parameter A_SIGNED = 0;
parameter B_SIGNED = 0;
parameter A_WIDTH = 0;
parameter B_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
input [B_WIDTH-1:0] B;
output [Y_WIDTH-1:0] Y;

generate
	if (A_SIGNED && B_SIGNED) begin:BLOCK1
		assign Y = $signed(A) && $signed(B);
	end else begin:BLOCK2
		assign Y = A && B;
	end
endgenerate

endmodule

// --------------------------------------------------------

module \\$logic_or (A, B, Y);

parameter A_SIGNED = 0;
parameter B_SIGNED = 0;
parameter A_WIDTH = 0;
parameter B_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
input [B_WIDTH-1:0] B;
output [Y_WIDTH-1:0] Y;

generate
	if (A_SIGNED && B_SIGNED) begin:BLOCK1
		assign Y = $signed(A) || $signed(B);
	end else begin:BLOCK2
		assign Y = A || B;
	end
endgenerate

endmodule

// --------------------------------------------------------

module \\$slice (A, Y);

parameter OFFSET = 0;
parameter A_WIDTH = 0;
parameter Y_WIDTH = 0;

input [A_WIDTH-1:0] A;
output [Y_WIDTH-1:0] Y;

assign Y = A >> OFFSET;

endmodule

// --------------------------------------------------------

module \\$concat (A, B, Y);

parameter A_WIDTH = 0;
parameter B_WIDTH = 0;

input [A_WIDTH-1:0] A;
input [B_WIDTH-1:0] B;
output [A_WIDTH+B_WIDTH-1:0] Y;

assign Y = {B, A};

endmodule

// --------------------------------------------------------

module \\$mux (A, B, S, Y);

parameter WIDTH = 0;

input [WIDTH-1:0] A, B;
input S;
output [WIDTH-1:0] Y;

assign Y = S ? B : A;

endmodule

// --------------------------------------------------------

module \\$bmux (A, S, Y);

parameter WIDTH = 0;
parameter S_WIDTH = 0;

input [(WIDTH << S_WIDTH)-1:0] A;
input [S_WIDTH-1:0] S;
output [WIDTH-1:0] Y;

wire [WIDTH-1:0] bm0_out, bm1_out;

generate
	if (S_WIDTH > 1) begin:muxlogic
		\\$bmux #(.WIDTH(WIDTH), .S_WIDTH(S_WIDTH-1)) bm0 (.A(A[(WIDTH << (S_WIDTH - 1))-1:0]), .S(S[S_WIDTH-2:0]), .Y(bm0_out));
		\\$bmux #(.WIDTH(WIDTH), .S_WIDTH(S_WIDTH-1)) bm1 (.A(A[(WIDTH << S_WIDTH)-1:WIDTH << (S_WIDTH - 1)]), .S(S[S_WIDTH-2:0]), .Y(bm1_out));
		assign Y = S[S_WIDTH-1] ? bm1_out : bm0_out;
	end else if (S_WIDTH == 1) begin:simple
		assign Y = S ? A[2*WIDTH-1:WIDTH] : A[WIDTH-1:0];
	end else begin:passthru
		assign Y = A;
	end
endgenerate

endmodule

// --------------------------------------------------------

module \\$pmux (A, B, S, Y);

parameter WIDTH = 0;
parameter S_WIDTH = 0;

input [WIDTH-1:0] A;
input [WIDTH*S_WIDTH-1:0] B;
input [S_WIDTH-1:0] S;
output reg [WIDTH-1:0] Y;

integer i;
reg found_active_sel_bit;

always @* begin
	Y = A;
	found_active_sel_bit = 0;
	for (i = 0; i < S_WIDTH; i = i+1)
		case (S[i])
			1'b1: begin
				Y = found_active_sel_bit ? 'bx : B >> (WIDTH*i);
				found_active_sel_bit = 1;
			end
			1'b0: ;
			1'bx: begin
				Y = 'bx;
				found_active_sel_bit = 'bx;
			end
		endcase
end

endmodule

// --------------------------------------------------------

module \\$demux (A, S, Y);

parameter WIDTH = 1;
parameter S_WIDTH = 1;

input [WIDTH-1:0] A;
input [S_WIDTH-1:0] S;
output [(WIDTH << S_WIDTH)-1:0] Y;

genvar i;
generate
	for (i = 0; i < (1 << S_WIDTH); i = i + 1) begin:slices
		assign Y[i*WIDTH+:WIDTH] = (S == i) ? A : 0;
	end
endgenerate

endmodule

// --------------------------------------------------------
\`ifndef SIMLIB_NOLUT

module \\$lut (A, Y);

parameter WIDTH = 0;
parameter LUT = 0;

input [WIDTH-1:0] A;
output Y;

\\$bmux #(.WIDTH(1), .S_WIDTH(WIDTH)) mux(.A(LUT[(1<<WIDTH)-1:0]), .S(A), .Y(Y));

endmodule

\`endif
// --------------------------------------------------------

module \\$sop (A, Y);

parameter WIDTH = 0;
parameter DEPTH = 0;
parameter TABLE = 0;

input [WIDTH-1:0] A;
output reg Y;

integer i, j;
reg match;

always @* begin
	Y = 0;
	for (i = 0; i < DEPTH; i=i+1) begin
		match = 1;
		for (j = 0; j < WIDTH; j=j+1) begin
			if (TABLE[2*WIDTH*i + 2*j + 0] && A[j]) match = 0;
			if (TABLE[2*WIDTH*i + 2*j + 1] && !A[j]) match = 0;
		end
		if (match) Y = 1;
	end
end

endmodule

// --------------------------------------------------------

module \\$tribuf (A, EN, Y);

parameter WIDTH = 0;

input [WIDTH-1:0] A;
input EN;
output [WIDTH-1:0] Y;

assign Y = EN ? A : 'bz;

endmodule

// --------------------------------------------------------

module \\$specify2 (EN, SRC, DST);

parameter FULL = 0;
parameter SRC_WIDTH = 1;
parameter DST_WIDTH = 1;

parameter SRC_DST_PEN = 0;
parameter SRC_DST_POL = 0;

parameter T_RISE_MIN = 0;
parameter T_RISE_TYP = 0;
parameter T_RISE_MAX = 0;

parameter T_FALL_MIN = 0;
parameter T_FALL_TYP = 0;
parameter T_FALL_MAX = 0;

input EN;
input [SRC_WIDTH-1:0] SRC;
input [DST_WIDTH-1:0] DST;

localparam SD = SRC_DST_PEN ? (SRC_DST_POL ? 1 : 2) : 0;

\`ifdef SIMLIB_SPECIFY
specify
	if (EN && SD==0 && !FULL) (SRC  => DST) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && SD==0 &&  FULL) (SRC  *> DST) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && SD==1 && !FULL) (SRC +=> DST) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && SD==1 &&  FULL) (SRC +*> DST) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && SD==2 && !FULL) (SRC -=> DST) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && SD==2 &&  FULL) (SRC -*> DST) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
endspecify
\`endif

endmodule

// --------------------------------------------------------

module \\$specify3 (EN, SRC, DST, DAT);

parameter FULL = 0;
parameter SRC_WIDTH = 1;
parameter DST_WIDTH = 1;

parameter EDGE_EN = 0;
parameter EDGE_POL = 0;

parameter SRC_DST_PEN = 0;
parameter SRC_DST_POL = 0;

parameter DAT_DST_PEN = 0;
parameter DAT_DST_POL = 0;

parameter T_RISE_MIN = 0;
parameter T_RISE_TYP = 0;
parameter T_RISE_MAX = 0;

parameter T_FALL_MIN = 0;
parameter T_FALL_TYP = 0;
parameter T_FALL_MAX = 0;

input EN;
input [SRC_WIDTH-1:0] SRC;
input [DST_WIDTH-1:0] DST, DAT;

localparam ED = EDGE_EN     ? (EDGE_POL    ? 1 : 2) : 0;
localparam SD = SRC_DST_PEN ? (SRC_DST_POL ? 1 : 2) : 0;
localparam DD = DAT_DST_PEN ? (DAT_DST_POL ? 1 : 2) : 0;

\`ifdef SIMLIB_SPECIFY
specify
	// DD=0

	if (EN && DD==0 && SD==0 && ED==0 && !FULL) (        SRC  => (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==0 && SD==0 && ED==0 &&  FULL) (        SRC  *> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==0 && SD==0 && ED==1 && !FULL) (posedge SRC  => (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==0 && SD==0 && ED==1 &&  FULL) (posedge SRC  *> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==0 && SD==0 && ED==2 && !FULL) (negedge SRC  => (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==0 && SD==0 && ED==2 &&  FULL) (negedge SRC  *> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);

	if (EN && DD==0 && SD==1 && ED==0 && !FULL) (        SRC +=> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==0 && SD==1 && ED==0 &&  FULL) (        SRC +*> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==0 && SD==1 && ED==1 && !FULL) (posedge SRC +=> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==0 && SD==1 && ED==1 &&  FULL) (posedge SRC +*> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==0 && SD==1 && ED==2 && !FULL) (negedge SRC +=> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==0 && SD==1 && ED==2 &&  FULL) (negedge SRC +*> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);

	if (EN && DD==0 && SD==2 && ED==0 && !FULL) (        SRC -=> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==0 && SD==2 && ED==0 &&  FULL) (        SRC -*> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==0 && SD==2 && ED==1 && !FULL) (posedge SRC -=> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==0 && SD==2 && ED==1 &&  FULL) (posedge SRC -*> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==0 && SD==2 && ED==2 && !FULL) (negedge SRC -=> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==0 && SD==2 && ED==2 &&  FULL) (negedge SRC -*> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);

	// DD=1

	if (EN && DD==1 && SD==0 && ED==0 && !FULL) (        SRC  => (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==1 && SD==0 && ED==0 &&  FULL) (        SRC  *> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==1 && SD==0 && ED==1 && !FULL) (posedge SRC  => (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==1 && SD==0 && ED==1 &&  FULL) (posedge SRC  *> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==1 && SD==0 && ED==2 && !FULL) (negedge SRC  => (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==1 && SD==0 && ED==2 &&  FULL) (negedge SRC  *> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);

	if (EN && DD==1 && SD==1 && ED==0 && !FULL) (        SRC +=> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==1 && SD==1 && ED==0 &&  FULL) (        SRC +*> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==1 && SD==1 && ED==1 && !FULL) (posedge SRC +=> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==1 && SD==1 && ED==1 &&  FULL) (posedge SRC +*> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==1 && SD==1 && ED==2 && !FULL) (negedge SRC +=> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==1 && SD==1 && ED==2 &&  FULL) (negedge SRC +*> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);

	if (EN && DD==1 && SD==2 && ED==0 && !FULL) (        SRC -=> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==1 && SD==2 && ED==0 &&  FULL) (        SRC -*> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==1 && SD==2 && ED==1 && !FULL) (posedge SRC -=> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==1 && SD==2 && ED==1 &&  FULL) (posedge SRC -*> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==1 && SD==2 && ED==2 && !FULL) (negedge SRC -=> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==1 && SD==2 && ED==2 &&  FULL) (negedge SRC -*> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);

	// DD=2

	if (EN && DD==2 && SD==0 && ED==0 && !FULL) (        SRC  => (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==2 && SD==0 && ED==0 &&  FULL) (        SRC  *> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==2 && SD==0 && ED==1 && !FULL) (posedge SRC  => (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==2 && SD==0 && ED==1 &&  FULL) (posedge SRC  *> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==2 && SD==0 && ED==2 && !FULL) (negedge SRC  => (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==2 && SD==0 && ED==2 &&  FULL) (negedge SRC  *> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);

	if (EN && DD==2 && SD==1 && ED==0 && !FULL) (        SRC +=> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==2 && SD==1 && ED==0 &&  FULL) (        SRC +*> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==2 && SD==1 && ED==1 && !FULL) (posedge SRC +=> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==2 && SD==1 && ED==1 &&  FULL) (posedge SRC +*> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==2 && SD==1 && ED==2 && !FULL) (negedge SRC +=> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==2 && SD==1 && ED==2 &&  FULL) (negedge SRC +*> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);

	if (EN && DD==2 && SD==2 && ED==0 && !FULL) (        SRC -=> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==2 && SD==2 && ED==0 &&  FULL) (        SRC -*> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==2 && SD==2 && ED==1 && !FULL) (posedge SRC -=> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==2 && SD==2 && ED==1 &&  FULL) (posedge SRC -*> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==2 && SD==2 && ED==2 && !FULL) (negedge SRC -=> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
	if (EN && DD==2 && SD==2 && ED==2 &&  FULL) (negedge SRC -*> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);
endspecify
\`endif

endmodule

// --------------------------------------------------------

module \\$specrule (EN_SRC, EN_DST, SRC, DST);

parameter TYPE = "";
parameter T_LIMIT = 0;
parameter T_LIMIT2 = 0;

parameter SRC_WIDTH = 1;
parameter DST_WIDTH = 1;

parameter SRC_PEN = 0;
parameter SRC_POL = 0;

parameter DST_PEN = 0;
parameter DST_POL = 0;

input EN_SRC, EN_DST;
input [SRC_WIDTH-1:0] SRC;
input [DST_WIDTH-1:0] DST;

\`ifdef SIMLIB_SPECIFY
specify
	// TBD
endspecify
\`endif

endmodule

// --------------------------------------------------------

module \\$bweqx (A, B, Y);

parameter WIDTH = 0;

input [WIDTH-1:0] A, B;
output [WIDTH-1:0] Y;

genvar i;
generate
	for (i = 0; i < WIDTH; i = i + 1) begin:slices
		assign Y[i] = A[i] === B[i];
	end
endgenerate

endmodule

// --------------------------------------------------------

module \\$bwmux (A, B, S, Y);

parameter WIDTH = 0;

input [WIDTH-1:0] A, B;
input [WIDTH-1:0] S;
output [WIDTH-1:0] Y;

genvar i;
generate
	for (i = 0; i < WIDTH; i = i + 1) begin:slices
		assign Y[i] = S[i] ? B[i] : A[i];
	end
endgenerate

endmodule

// --------------------------------------------------------

module \\$assert (A, EN);

input A, EN;

\`ifndef SIMLIB_NOCHECKS
always @* begin
	if (A !== 1'b1 && EN === 1'b1) begin
		$display("Assertion %m failed!");
		$stop;
	end
end
\`endif

endmodule

// --------------------------------------------------------

module \\$assume (A, EN);

input A, EN;

\`ifndef SIMLIB_NOCHECKS
always @* begin
	if (A !== 1'b1 && EN === 1'b1) begin
		$display("Assumption %m failed!");
		$stop;
	end
end
\`endif

endmodule

// --------------------------------------------------------

module \\$live (A, EN);

input A, EN;

endmodule

// --------------------------------------------------------

module \\$fair (A, EN);

input A, EN;

endmodule

// --------------------------------------------------------

module \\$cover (A, EN);

input A, EN;

endmodule

// --------------------------------------------------------

module \\$initstate (Y);

output reg Y = 1;
reg [3:0] cnt = 1;
reg trig = 0;

initial trig <= 1;

always @(cnt, trig) begin
	Y <= |cnt;
	cnt <= cnt + |cnt;
end

endmodule

// --------------------------------------------------------

module \\$anyconst (Y);

parameter WIDTH = 0;

output [WIDTH-1:0] Y;

assign Y = 'bx;

endmodule

// --------------------------------------------------------

module \\$anyseq (Y);

parameter WIDTH = 0;

output [WIDTH-1:0] Y;

assign Y = 'bx;

endmodule

// --------------------------------------------------------
\`ifdef SIMLIB_FF
\`ifndef SIMLIB_GLOBAL_CLOCK
\`define SIMLIB_GLOBAL_CLOCK $global_clk
\`endif
module \\$anyinit (D, Q);

parameter WIDTH = 0;

input [WIDTH-1:0] D;
output reg [WIDTH-1:0] Q;

initial Q <= 'bx;

always @(\`SIMLIB_GLOBAL_CLOCK) begin
	Q <= D;
end

endmodule
\`endif
// --------------------------------------------------------

module \\$allconst (Y);

parameter WIDTH = 0;

output [WIDTH-1:0] Y;

assign Y = 'bx;

endmodule

// --------------------------------------------------------

module \\$allseq (Y);

parameter WIDTH = 0;

output [WIDTH-1:0] Y;

assign Y = 'bx;

endmodule

// --------------------------------------------------------

module \\$equiv (A, B, Y);

input A, B;
output Y;

assign Y = (A !== 1'bx && A !== B) ? 1'bx : A;

\`ifndef SIMLIB_NOCHECKS
always @* begin
	if (A !== 1'bx && A !== B) begin
		$display("Equivalence failed!");
		$stop;
	end
end
\`endif

endmodule

// --------------------------------------------------------

module \\$print (EN, TRG, ARGS);

parameter PRIORITY = 0;

parameter FORMAT = "";
parameter ARGS_WIDTH = 0;

parameter TRG_ENABLE = 1;
parameter TRG_WIDTH = 0;
parameter TRG_POLARITY = 0;

input EN;
input [TRG_WIDTH-1:0] TRG;
input [ARGS_WIDTH-1:0] ARGS;

endmodule

// --------------------------------------------------------

module \\$check (A, EN, TRG, ARGS);

parameter FLAVOR = "";
parameter PRIORITY = 0;

parameter FORMAT = "";
parameter ARGS_WIDTH = 0;

parameter TRG_ENABLE = 1;
parameter TRG_WIDTH = 0;
parameter TRG_POLARITY = 0;

input A;
input EN;
input [TRG_WIDTH-1:0] TRG;
input [ARGS_WIDTH-1:0] ARGS;

endmodule

// --------------------------------------------------------
\`ifndef SIMLIB_NOSR

module \\$sr (SET, CLR, Q);

parameter WIDTH = 0;
parameter SET_POLARITY = 1'b1;
parameter CLR_POLARITY = 1'b1;

input [WIDTH-1:0] SET, CLR;
output reg [WIDTH-1:0] Q;

wire [WIDTH-1:0] pos_set = SET_POLARITY ? SET : ~SET;
wire [WIDTH-1:0] pos_clr = CLR_POLARITY ? CLR : ~CLR;

genvar i;
generate
	for (i = 0; i < WIDTH; i = i+1) begin:bitslices
		always @*
			if (pos_clr[i])
				Q[i] <= 0;
			else if (pos_set[i])
				Q[i] <= 1;
	end
endgenerate

endmodule

\`endif
// --------------------------------------------------------
\`ifdef SIMLIB_FF
\`ifndef SIMLIB_GLOBAL_CLOCK
\`define SIMLIB_GLOBAL_CLOCK $global_clk
\`endif

module \\$ff (D, Q);

parameter WIDTH = 0;

input [WIDTH-1:0] D;
output reg [WIDTH-1:0] Q;

always @(\`SIMLIB_GLOBAL_CLOCK) begin
	Q <= D;
end

endmodule

\`endif
// --------------------------------------------------------

module \\$dff (CLK, D, Q);

parameter WIDTH = 0;
parameter CLK_POLARITY = 1'b1;

input CLK;
input [WIDTH-1:0] D;
output reg [WIDTH-1:0] Q;
wire pos_clk = CLK == CLK_POLARITY;

always @(posedge pos_clk) begin
	Q <= D;
end

endmodule

// --------------------------------------------------------

module \\$dffe (CLK, EN, D, Q);

parameter WIDTH = 0;
parameter CLK_POLARITY = 1'b1;
parameter EN_POLARITY = 1'b1;

input CLK, EN;
input [WIDTH-1:0] D;
output reg [WIDTH-1:0] Q;
wire pos_clk = CLK == CLK_POLARITY;

always @(posedge pos_clk) begin
	if (EN == EN_POLARITY) Q <= D;
end

endmodule

// --------------------------------------------------------
\`ifndef SIMLIB_NOSR

module \\$dffsr (CLK, SET, CLR, D, Q);

parameter WIDTH = 0;
parameter CLK_POLARITY = 1'b1;
parameter SET_POLARITY = 1'b1;
parameter CLR_POLARITY = 1'b1;

input CLK;
input [WIDTH-1:0] SET, CLR, D;
output reg [WIDTH-1:0] Q;

wire pos_clk = CLK == CLK_POLARITY;
wire [WIDTH-1:0] pos_set = SET_POLARITY ? SET : ~SET;
wire [WIDTH-1:0] pos_clr = CLR_POLARITY ? CLR : ~CLR;

genvar i;
generate
	for (i = 0; i < WIDTH; i = i+1) begin:bitslices
		always @(posedge pos_set[i], posedge pos_clr[i], posedge pos_clk)
			if (pos_clr[i])
				Q[i] <= 0;
			else if (pos_set[i])
				Q[i] <= 1;
			else
				Q[i] <= D[i];
	end
endgenerate

endmodule

// --------------------------------------------------------

module \\$dffsre (CLK, SET, CLR, EN, D, Q);

parameter WIDTH = 0;
parameter CLK_POLARITY = 1'b1;
parameter SET_POLARITY = 1'b1;
parameter CLR_POLARITY = 1'b1;
parameter EN_POLARITY = 1'b1;

input CLK, EN;
input [WIDTH-1:0] SET, CLR, D;
output reg [WIDTH-1:0] Q;

wire pos_clk = CLK == CLK_POLARITY;
wire [WIDTH-1:0] pos_set = SET_POLARITY ? SET : ~SET;
wire [WIDTH-1:0] pos_clr = CLR_POLARITY ? CLR : ~CLR;

genvar i;
generate
	for (i = 0; i < WIDTH; i = i+1) begin:bitslices
		always @(posedge pos_set[i], posedge pos_clr[i], posedge pos_clk)
			if (pos_clr[i])
				Q[i] <= 0;
			else if (pos_set[i])
				Q[i] <= 1;
			else if (EN == EN_POLARITY)
				Q[i] <= D[i];
	end
endgenerate

endmodule

\`endif
// --------------------------------------------------------

module \\$adff (CLK, ARST, D, Q);

parameter WIDTH = 0;
parameter CLK_POLARITY = 1'b1;
parameter ARST_POLARITY = 1'b1;
parameter ARST_VALUE = 0;

input CLK, ARST;
input [WIDTH-1:0] D;
output reg [WIDTH-1:0] Q;
wire pos_clk = CLK == CLK_POLARITY;
wire pos_arst = ARST == ARST_POLARITY;

always @(posedge pos_clk, posedge pos_arst) begin
	if (pos_arst)
		Q <= ARST_VALUE;
	else
		Q <= D;
end

endmodule

// --------------------------------------------------------

module \\$aldff (CLK, ALOAD, AD, D, Q);

parameter WIDTH = 0;
parameter CLK_POLARITY = 1'b1;
parameter ALOAD_POLARITY = 1'b1;

input CLK, ALOAD;
input [WIDTH-1:0] AD;
input [WIDTH-1:0] D;
output reg [WIDTH-1:0] Q;
wire pos_clk = CLK == CLK_POLARITY;
wire pos_aload = ALOAD == ALOAD_POLARITY;

always @(posedge pos_clk, posedge pos_aload) begin
	if (pos_aload)
		Q <= AD;
	else
		Q <= D;
end

endmodule

// --------------------------------------------------------

module \\$sdff (CLK, SRST, D, Q);

parameter WIDTH = 0;
parameter CLK_POLARITY = 1'b1;
parameter SRST_POLARITY = 1'b1;
parameter SRST_VALUE = 0;

input CLK, SRST;
input [WIDTH-1:0] D;
output reg [WIDTH-1:0] Q;
wire pos_clk = CLK == CLK_POLARITY;
wire pos_srst = SRST == SRST_POLARITY;

always @(posedge pos_clk) begin
	if (pos_srst)
		Q <= SRST_VALUE;
	else
		Q <= D;
end

endmodule

// --------------------------------------------------------

module \\$adffe (CLK, ARST, EN, D, Q);

parameter WIDTH = 0;
parameter CLK_POLARITY = 1'b1;
parameter EN_POLARITY = 1'b1;
parameter ARST_POLARITY = 1'b1;
parameter ARST_VALUE = 0;

input CLK, ARST, EN;
input [WIDTH-1:0] D;
output reg [WIDTH-1:0] Q;
wire pos_clk = CLK == CLK_POLARITY;
wire pos_arst = ARST == ARST_POLARITY;

always @(posedge pos_clk, posedge pos_arst) begin
	if (pos_arst)
		Q <= ARST_VALUE;
	else if (EN == EN_POLARITY)
		Q <= D;
end

endmodule

// --------------------------------------------------------

module \\$aldffe (CLK, ALOAD, AD, EN, D, Q);

parameter WIDTH = 0;
parameter CLK_POLARITY = 1'b1;
parameter EN_POLARITY = 1'b1;
parameter ALOAD_POLARITY = 1'b1;

input CLK, ALOAD, EN;
input [WIDTH-1:0] D;
input [WIDTH-1:0] AD;
output reg [WIDTH-1:0] Q;
wire pos_clk = CLK == CLK_POLARITY;
wire pos_aload = ALOAD == ALOAD_POLARITY;

always @(posedge pos_clk, posedge pos_aload) begin
	if (pos_aload)
		Q <= AD;
	else if (EN == EN_POLARITY)
		Q <= D;
end

endmodule

// --------------------------------------------------------

module \\$sdffe (CLK, SRST, EN, D, Q);

parameter WIDTH = 0;
parameter CLK_POLARITY = 1'b1;
parameter EN_POLARITY = 1'b1;
parameter SRST_POLARITY = 1'b1;
parameter SRST_VALUE = 0;

input CLK, SRST, EN;
input [WIDTH-1:0] D;
output reg [WIDTH-1:0] Q;
wire pos_clk = CLK == CLK_POLARITY;
wire pos_srst = SRST == SRST_POLARITY;

always @(posedge pos_clk) begin
	if (pos_srst)
		Q <= SRST_VALUE;
	else if (EN == EN_POLARITY)
		Q <= D;
end

endmodule

// --------------------------------------------------------

module \\$sdffce (CLK, SRST, EN, D, Q);

parameter WIDTH = 0;
parameter CLK_POLARITY = 1'b1;
parameter EN_POLARITY = 1'b1;
parameter SRST_POLARITY = 1'b1;
parameter SRST_VALUE = 0;

input CLK, SRST, EN;
input [WIDTH-1:0] D;
output reg [WIDTH-1:0] Q;
wire pos_clk = CLK == CLK_POLARITY;
wire pos_srst = SRST == SRST_POLARITY;

always @(posedge pos_clk) begin
	if (EN == EN_POLARITY) begin
		if (pos_srst)
			Q <= SRST_VALUE;
		else
			Q <= D;
	end
end

endmodule

// --------------------------------------------------------

module \\$dlatch (EN, D, Q);

parameter WIDTH = 0;
parameter EN_POLARITY = 1'b1;

input EN;
input [WIDTH-1:0] D;
output reg [WIDTH-1:0] Q;

always @* begin
	if (EN == EN_POLARITY)
		Q = D;
end

endmodule

// --------------------------------------------------------

module \\$adlatch (EN, ARST, D, Q);

parameter WIDTH = 0;
parameter EN_POLARITY = 1'b1;
parameter ARST_POLARITY = 1'b1;
parameter ARST_VALUE = 0;

input EN, ARST;
input [WIDTH-1:0] D;
output reg [WIDTH-1:0] Q;

always @* begin
	if (ARST == ARST_POLARITY)
		Q = ARST_VALUE;
	else if (EN == EN_POLARITY)
		Q = D;
end

endmodule

// --------------------------------------------------------
\`ifndef SIMLIB_NOSR

module \\$dlatchsr (EN, SET, CLR, D, Q);

parameter WIDTH = 0;
parameter EN_POLARITY = 1'b1;
parameter SET_POLARITY = 1'b1;
parameter CLR_POLARITY = 1'b1;

input EN;
input [WIDTH-1:0] SET, CLR, D;
output reg [WIDTH-1:0] Q;

wire pos_en = EN == EN_POLARITY;
wire [WIDTH-1:0] pos_set = SET_POLARITY ? SET : ~SET;
wire [WIDTH-1:0] pos_clr = CLR_POLARITY ? CLR : ~CLR;

genvar i;
generate
	for (i = 0; i < WIDTH; i = i+1) begin:bitslices
		always @*
			if (pos_clr[i])
				Q[i] = 0;
			else if (pos_set[i])
				Q[i] = 1;
			else if (pos_en)
				Q[i] = D[i];
	end
endgenerate

endmodule

\`endif
// --------------------------------------------------------

module \\$fsm (CLK, ARST, CTRL_IN, CTRL_OUT);

parameter NAME = "";

parameter CLK_POLARITY = 1'b1;
parameter ARST_POLARITY = 1'b1;

parameter CTRL_IN_WIDTH = 1;
parameter CTRL_OUT_WIDTH = 1;

parameter STATE_BITS = 1;
parameter STATE_NUM = 1;
parameter STATE_NUM_LOG2 = 1;
parameter STATE_RST = 0;
parameter STATE_TABLE = 1'b0;

parameter TRANS_NUM = 1;
parameter TRANS_TABLE = 4'b0x0x;

input CLK, ARST;
input [CTRL_IN_WIDTH-1:0] CTRL_IN;
output reg [CTRL_OUT_WIDTH-1:0] CTRL_OUT;

wire pos_clk = CLK == CLK_POLARITY;
wire pos_arst = ARST == ARST_POLARITY;

reg [STATE_BITS-1:0] state;
reg [STATE_BITS-1:0] state_tmp;
reg [STATE_BITS-1:0] next_state;

reg [STATE_BITS-1:0] tr_state_in;
reg [STATE_BITS-1:0] tr_state_out;
reg [CTRL_IN_WIDTH-1:0] tr_ctrl_in;
reg [CTRL_OUT_WIDTH-1:0] tr_ctrl_out;

integer i;

task tr_fetch;
	input [31:0] tr_num;
	reg [31:0] tr_pos;
	reg [STATE_NUM_LOG2-1:0] state_num;
	begin
		tr_pos = (2*STATE_NUM_LOG2+CTRL_IN_WIDTH+CTRL_OUT_WIDTH)*tr_num;
		tr_ctrl_out = TRANS_TABLE >> tr_pos;
		tr_pos = tr_pos + CTRL_OUT_WIDTH;
		state_num = TRANS_TABLE >> tr_pos;
		tr_state_out = STATE_TABLE >> (STATE_BITS*state_num);
		tr_pos = tr_pos + STATE_NUM_LOG2;
		tr_ctrl_in = TRANS_TABLE >> tr_pos;
		tr_pos = tr_pos + CTRL_IN_WIDTH;
		state_num = TRANS_TABLE >> tr_pos;
		tr_state_in = STATE_TABLE >> (STATE_BITS*state_num);
		tr_pos = tr_pos + STATE_NUM_LOG2;
	end
endtask

always @(posedge pos_clk, posedge pos_arst) begin
	if (pos_arst) begin
		state_tmp = STATE_TABLE[STATE_BITS*(STATE_RST+1)-1:STATE_BITS*STATE_RST];
		for (i = 0; i < STATE_BITS; i = i+1)
			if (state_tmp[i] === 1'bz)
				state_tmp[i] = 0;
		state <= state_tmp;
	end else begin
		state_tmp = next_state;
		for (i = 0; i < STATE_BITS; i = i+1)
			if (state_tmp[i] === 1'bz)
				state_tmp[i] = 0;
		state <= state_tmp;
	end
end

always @(state, CTRL_IN) begin
	next_state <= STATE_TABLE[STATE_BITS*(STATE_RST+1)-1:STATE_BITS*STATE_RST];
	CTRL_OUT <= 'bx;
	// $display("---");
	// $display("Q: %b %b", state, CTRL_IN);
	for (i = 0; i < TRANS_NUM; i = i+1) begin
		tr_fetch(i);
		// $display("T: %b %b -> %b %b [%d]", tr_state_in, tr_ctrl_in, tr_state_out, tr_ctrl_out, i);
		casez ({state, CTRL_IN})
			{tr_state_in, tr_ctrl_in}: begin
				// $display("-> %b %b <-   MATCH", state, CTRL_IN);
				{next_state, CTRL_OUT} <= {tr_state_out, tr_ctrl_out};
			end
		endcase
	end
end

endmodule

// --------------------------------------------------------
\`ifndef SIMLIB_NOMEM

module \\$memrd (CLK, EN, ADDR, DATA);

parameter MEMID = "";
parameter ABITS = 8;
parameter WIDTH = 8;

parameter CLK_ENABLE = 0;
parameter CLK_POLARITY = 0;
parameter TRANSPARENT = 0;

input CLK, EN;
input [ABITS-1:0] ADDR;
output [WIDTH-1:0] DATA;

initial begin
	if (MEMID != "") begin
		$display("ERROR: Found non-simulatable instance of $memrd!");
		$finish;
	end
end

endmodule

module \\$memrd_v2 (CLK, EN, ARST, SRST, ADDR, DATA);

parameter MEMID = "";
parameter ABITS = 8;
parameter WIDTH = 8;

parameter CLK_ENABLE = 0;
parameter CLK_POLARITY = 0;
parameter TRANSPARENCY_MASK = 0;
parameter COLLISION_X_MASK = 0;
parameter ARST_VALUE = 0;
parameter SRST_VALUE = 0;
parameter INIT_VALUE = 0;
parameter CE_OVER_SRST = 0;

input CLK, EN, ARST, SRST;
input [ABITS-1:0] ADDR;
output [WIDTH-1:0] DATA;

initial begin
	if (MEMID != "") begin
		$display("ERROR: Found non-simulatable instance of $memrd_v2!");
		$finish;
	end
end

endmodule

// --------------------------------------------------------

module \\$memwr (CLK, EN, ADDR, DATA);

parameter MEMID = "";
parameter ABITS = 8;
parameter WIDTH = 8;

parameter CLK_ENABLE = 0;
parameter CLK_POLARITY = 0;
parameter PRIORITY = 0;

input CLK;
input [WIDTH-1:0] EN;
input [ABITS-1:0] ADDR;
input [WIDTH-1:0] DATA;

initial begin
	if (MEMID != "") begin
		$display("ERROR: Found non-simulatable instance of $memwr!");
		$finish;
	end
end

endmodule

module \\$memwr_v2 (CLK, EN, ADDR, DATA);

parameter MEMID = "";
parameter ABITS = 8;
parameter WIDTH = 8;

parameter CLK_ENABLE = 0;
parameter CLK_POLARITY = 0;
parameter PORTID = 0;
parameter PRIORITY_MASK = 0;

input CLK;
input [WIDTH-1:0] EN;
input [ABITS-1:0] ADDR;
input [WIDTH-1:0] DATA;

initial begin
	if (MEMID != "") begin
		$display("ERROR: Found non-simulatable instance of $memwr_v2!");
		$finish;
	end
end

endmodule

// --------------------------------------------------------

module \\$meminit (ADDR, DATA);

parameter MEMID = "";
parameter ABITS = 8;
parameter WIDTH = 8;
parameter WORDS = 1;

parameter PRIORITY = 0;

input [ABITS-1:0] ADDR;
input [WORDS*WIDTH-1:0] DATA;

initial begin
	if (MEMID != "") begin
		$display("ERROR: Found non-simulatable instance of $meminit!");
		$finish;
	end
end

endmodule

// --------------------------------------------------------

module \\$meminit_v2 (ADDR, DATA, EN);

parameter MEMID = "";
parameter ABITS = 8;
parameter WIDTH = 8;
parameter WORDS = 1;

parameter PRIORITY = 0;

input [ABITS-1:0] ADDR;
input [WORDS*WIDTH-1:0] DATA;
input [WIDTH-1:0] EN;

initial begin
	if (MEMID != "") begin
		$display("ERROR: Found non-simulatable instance of $meminit_v2!");
		$finish;
	end
end

endmodule

// --------------------------------------------------------

module \\$mem (RD_CLK, RD_EN, RD_ADDR, RD_DATA, WR_CLK, WR_EN, WR_ADDR, WR_DATA);

parameter MEMID = "";
parameter signed SIZE = 4;
parameter signed OFFSET = 0;
parameter signed ABITS = 2;
parameter signed WIDTH = 8;
parameter signed INIT = 1'bx;

parameter signed RD_PORTS = 1;
parameter RD_CLK_ENABLE = 1'b1;
parameter RD_CLK_POLARITY = 1'b1;
parameter RD_TRANSPARENT = 1'b1;

parameter signed WR_PORTS = 1;
parameter WR_CLK_ENABLE = 1'b1;
parameter WR_CLK_POLARITY = 1'b1;

input [RD_PORTS-1:0] RD_CLK;
input [RD_PORTS-1:0] RD_EN;
input [RD_PORTS*ABITS-1:0] RD_ADDR;
output reg [RD_PORTS*WIDTH-1:0] RD_DATA;

input [WR_PORTS-1:0] WR_CLK;
input [WR_PORTS*WIDTH-1:0] WR_EN;
input [WR_PORTS*ABITS-1:0] WR_ADDR;
input [WR_PORTS*WIDTH-1:0] WR_DATA;

reg [WIDTH-1:0] memory [SIZE-1:0];

integer i, j;
reg [WR_PORTS-1:0] LAST_WR_CLK;
reg [RD_PORTS-1:0] LAST_RD_CLK;

function port_active;
	input clk_enable;
	input clk_polarity;
	input last_clk;
	input this_clk;
	begin
		casez ({clk_enable, clk_polarity, last_clk, this_clk})
			4'b0???: port_active = 1;
			4'b1101: port_active = 1;
			4'b1010: port_active = 1;
			default: port_active = 0;
		endcase
	end
endfunction

initial begin
	for (i = 0; i < SIZE; i = i+1)
		memory[i] = INIT >>> (i*WIDTH);
end

always @(RD_CLK, RD_ADDR, RD_DATA, WR_CLK, WR_EN, WR_ADDR, WR_DATA) begin
\`ifdef SIMLIB_MEMDELAY
	#\`SIMLIB_MEMDELAY;
\`endif
	for (i = 0; i < RD_PORTS; i = i+1) begin
		if (!RD_TRANSPARENT[i] && RD_CLK_ENABLE[i] && RD_EN[i] && port_active(RD_CLK_ENABLE[i], RD_CLK_POLARITY[i], LAST_RD_CLK[i], RD_CLK[i])) begin
			// $display("Read from %s: addr=%b data=%b", MEMID, RD_ADDR[i*ABITS +: ABITS],  memory[RD_ADDR[i*ABITS +: ABITS] - OFFSET]);
			RD_DATA[i*WIDTH +: WIDTH] <= memory[RD_ADDR[i*ABITS +: ABITS] - OFFSET];
		end
	end

	for (i = 0; i < WR_PORTS; i = i+1) begin
		if (port_active(WR_CLK_ENABLE[i], WR_CLK_POLARITY[i], LAST_WR_CLK[i], WR_CLK[i]))
			for (j = 0; j < WIDTH; j = j+1)
				if (WR_EN[i*WIDTH+j]) begin
					// $display("Write to %s: addr=%b data=%b", MEMID, WR_ADDR[i*ABITS +: ABITS], WR_DATA[i*WIDTH+j]);
					memory[WR_ADDR[i*ABITS +: ABITS] - OFFSET][j] = WR_DATA[i*WIDTH+j];
				end
	end

	for (i = 0; i < RD_PORTS; i = i+1) begin
		if ((RD_TRANSPARENT[i] || !RD_CLK_ENABLE[i]) && port_active(RD_CLK_ENABLE[i], RD_CLK_POLARITY[i], LAST_RD_CLK[i], RD_CLK[i])) begin
			// $display("Transparent read from %s: addr=%b data=%b", MEMID, RD_ADDR[i*ABITS +: ABITS],  memory[RD_ADDR[i*ABITS +: ABITS] - OFFSET]);
			RD_DATA[i*WIDTH +: WIDTH] <= memory[RD_ADDR[i*ABITS +: ABITS] - OFFSET];
		end
	end

	LAST_RD_CLK <= RD_CLK;
	LAST_WR_CLK <= WR_CLK;
end

endmodule

module \\$mem_v2 (RD_CLK, RD_EN, RD_ARST, RD_SRST, RD_ADDR, RD_DATA, WR_CLK, WR_EN, WR_ADDR, WR_DATA);

parameter MEMID = "";
parameter signed SIZE = 4;
parameter signed OFFSET = 0;
parameter signed ABITS = 2;
parameter signed WIDTH = 8;
parameter signed INIT = 1'bx;

parameter signed RD_PORTS = 1;
parameter RD_CLK_ENABLE = 1'b1;
parameter RD_CLK_POLARITY = 1'b1;
parameter RD_TRANSPARENCY_MASK = 1'b0;
parameter RD_COLLISION_X_MASK = 1'b0;
parameter RD_WIDE_CONTINUATION = 1'b0;
parameter RD_CE_OVER_SRST = 1'b0;
parameter RD_ARST_VALUE = 1'b0;
parameter RD_SRST_VALUE = 1'b0;
parameter RD_INIT_VALUE = 1'b0;

parameter signed WR_PORTS = 1;
parameter WR_CLK_ENABLE = 1'b1;
parameter WR_CLK_POLARITY = 1'b1;
parameter WR_PRIORITY_MASK = 1'b0;
parameter WR_WIDE_CONTINUATION = 1'b0;

input [RD_PORTS-1:0] RD_CLK;
input [RD_PORTS-1:0] RD_EN;
input [RD_PORTS-1:0] RD_ARST;
input [RD_PORTS-1:0] RD_SRST;
input [RD_PORTS*ABITS-1:0] RD_ADDR;
output reg [RD_PORTS*WIDTH-1:0] RD_DATA;

input [WR_PORTS-1:0] WR_CLK;
input [WR_PORTS*WIDTH-1:0] WR_EN;
input [WR_PORTS*ABITS-1:0] WR_ADDR;
input [WR_PORTS*WIDTH-1:0] WR_DATA;

reg [WIDTH-1:0] memory [SIZE-1:0];

integer i, j, k;
reg [WR_PORTS-1:0] LAST_WR_CLK;
reg [RD_PORTS-1:0] LAST_RD_CLK;

function port_active;
	input clk_enable;
	input clk_polarity;
	input last_clk;
	input this_clk;
	begin
		casez ({clk_enable, clk_polarity, last_clk, this_clk})
			4'b0???: port_active = 1;
			4'b1101: port_active = 1;
			4'b1010: port_active = 1;
			default: port_active = 0;
		endcase
	end
endfunction

initial begin
	for (i = 0; i < SIZE; i = i+1)
		memory[i] = INIT >>> (i*WIDTH);
	RD_DATA = RD_INIT_VALUE;
end

always @(RD_CLK, RD_ARST, RD_ADDR, RD_DATA, WR_CLK, WR_EN, WR_ADDR, WR_DATA) begin
\`ifdef SIMLIB_MEMDELAY
	#\`SIMLIB_MEMDELAY;
\`endif
	for (i = 0; i < RD_PORTS; i = i+1) begin
		if (RD_CLK_ENABLE[i] && RD_EN[i] && port_active(RD_CLK_ENABLE[i], RD_CLK_POLARITY[i], LAST_RD_CLK[i], RD_CLK[i])) begin
			// $display("Read from %s: addr=%b data=%b", MEMID, RD_ADDR[i*ABITS +: ABITS],  memory[RD_ADDR[i*ABITS +: ABITS] - OFFSET]);
			RD_DATA[i*WIDTH +: WIDTH] <= memory[RD_ADDR[i*ABITS +: ABITS] - OFFSET];

			for (j = 0; j < WR_PORTS; j = j+1) begin
				if (RD_TRANSPARENCY_MASK[i*WR_PORTS + j] && port_active(WR_CLK_ENABLE[j], WR_CLK_POLARITY[j], LAST_WR_CLK[j], WR_CLK[j]) && RD_ADDR[i*ABITS +: ABITS] == WR_ADDR[j*ABITS +: ABITS])
					for (k = 0; k < WIDTH; k = k+1)
						if (WR_EN[j*WIDTH+k])
							RD_DATA[i*WIDTH+k] <= WR_DATA[j*WIDTH+k];
				if (RD_COLLISION_X_MASK[i*WR_PORTS + j] && port_active(WR_CLK_ENABLE[j], WR_CLK_POLARITY[j], LAST_WR_CLK[j], WR_CLK[j]) && RD_ADDR[i*ABITS +: ABITS] == WR_ADDR[j*ABITS +: ABITS])
					for (k = 0; k < WIDTH; k = k+1)
						if (WR_EN[j*WIDTH+k])
							RD_DATA[i*WIDTH+k] <= 1'bx;
			end
		end
	end

	for (i = 0; i < WR_PORTS; i = i+1) begin
		if (port_active(WR_CLK_ENABLE[i], WR_CLK_POLARITY[i], LAST_WR_CLK[i], WR_CLK[i]))
			for (j = 0; j < WIDTH; j = j+1)
				if (WR_EN[i*WIDTH+j]) begin
					// $display("Write to %s: addr=%b data=%b", MEMID, WR_ADDR[i*ABITS +: ABITS], WR_DATA[i*WIDTH+j]);
					memory[WR_ADDR[i*ABITS +: ABITS] - OFFSET][j] = WR_DATA[i*WIDTH+j];
				end
	end

	for (i = 0; i < RD_PORTS; i = i+1) begin
		if (!RD_CLK_ENABLE[i]) begin
			// $display("Combinatorial read from %s: addr=%b data=%b", MEMID, RD_ADDR[i*ABITS +: ABITS],  memory[RD_ADDR[i*ABITS +: ABITS] - OFFSET]);
			RD_DATA[i*WIDTH +: WIDTH] <= memory[RD_ADDR[i*ABITS +: ABITS] - OFFSET];
		end
	end

	for (i = 0; i < RD_PORTS; i = i+1) begin
		if (RD_SRST[i] && port_active(RD_CLK_ENABLE[i], RD_CLK_POLARITY[i], LAST_RD_CLK[i], RD_CLK[i]) && (RD_EN[i] || !RD_CE_OVER_SRST[i]))
			RD_DATA[i*WIDTH +: WIDTH] <= RD_SRST_VALUE[i*WIDTH +: WIDTH];
		if (RD_ARST[i])
			RD_DATA[i*WIDTH +: WIDTH] <= RD_ARST_VALUE[i*WIDTH +: WIDTH];
	end

	LAST_RD_CLK <= RD_CLK;
	LAST_WR_CLK <= WR_CLK;
end

endmodule

\`endif

// --------------------------------------------------------

module \\$set_tag (A, SET, CLR, Y);

parameter TAG = "";
parameter WIDTH = 0;

input [WIDTH-1:0] A;
input [WIDTH-1:0] SET;
input [WIDTH-1:0] CLR;
output [WIDTH-1:0] Y;

assign Y = A;

endmodule

// --------------------------------------------------------

module \\$get_tag (A, Y);

parameter TAG = "";
parameter WIDTH = 0;

input [WIDTH-1:0] A;
output [WIDTH-1:0] Y;

assign Y = A;

endmodule

// --------------------------------------------------------

module \\$overwrite_tag (A, SET, CLR);

parameter TAG = "";
parameter WIDTH = 0;

input [WIDTH-1:0] A;
input [WIDTH-1:0] SET;
input [WIDTH-1:0] CLR;

endmodule

// --------------------------------------------------------

module \\$original_tag (A, Y);

parameter TAG = "";
parameter WIDTH = 0;

input [WIDTH-1:0] A;
output [WIDTH-1:0] Y;

assign Y = A;

endmodule

// --------------------------------------------------------

module \\$future_ff (A, Y);

parameter WIDTH = 0;

input [WIDTH-1:0] A;
output [WIDTH-1:0] Y;

assign Y = A;

endmodule

// --------------------------------------------------------

(* noblackbox *)
module \\$scopeinfo ();

parameter TYPE = "";

endmodule
`,"smtmap.v":`(* techmap_celltype = "$pmux" *)
module smt_pmux (A, B, S, Y);
	parameter WIDTH = 1;
	parameter S_WIDTH = 1;

	(* force_downto *)
	input [WIDTH-1:0] A;
	(* force_downto *)
	input [WIDTH*S_WIDTH-1:0] B;
	(* force_downto *)
	input [S_WIDTH-1:0] S;
	(* force_downto *)
	output [WIDTH-1:0] Y;

	(* force_downto *)
	wire [WIDTH-1:0] Y_B;

	genvar i, j;
	generate
		(* force_downto *)
		wire [WIDTH*(S_WIDTH+1)-1:0] C;

		assign C[WIDTH-1:0] = A;
		for (i = 0; i < S_WIDTH; i = i + 1)
			assign C[WIDTH*(i+2)-1:WIDTH*(i+1)] = S[i] ? B[WIDTH*(i+1)-1:WIDTH*i] : C[WIDTH*(i+1)-1:WIDTH*i];
		assign Y = C[WIDTH*(S_WIDTH+1)-1:WIDTH*S_WIDTH];
	endgenerate
endmodule
`,"techmap.v":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 *  ---
 *
 *  The internal logic cell technology mapper.
 *
 *  This Verilog library contains the mapping of internal cells (e.g. $not with
 *  variable bit width) to the internal logic cells (such as the single bit $_NOT_
 *  gate). Usually this logic network is then mapped to the actual technology
 *  using e.g. the "abc" pass.
 *
 *  Note that this library does not map $mem cells. They must be mapped to logic
 *  and $dff cells using the "memory_map" pass first. (Or map it to custom cells,
 *  which is of course highly recommended for larger memories.)
 *
 */

\`define MIN(_a, _b) ((_a) < (_b) ? (_a) : (_b))
\`define MAX(_a, _b) ((_a) > (_b) ? (_a) : (_b))


// --------------------------------------------------------
// Use simplemap for trivial cell types
// --------------------------------------------------------

(* techmap_simplemap *)
(* techmap_celltype = "$not $and $or $xor $xnor" *)
module _90_simplemap_bool_ops;
endmodule

(* techmap_simplemap *)
(* techmap_celltype = "$reduce_and $reduce_or $reduce_xor $reduce_xnor $reduce_bool" *)
module _90_simplemap_reduce_ops;
endmodule

(* techmap_simplemap *)
(* techmap_celltype = "$logic_not $logic_and $logic_or" *)
module _90_simplemap_logic_ops;
endmodule

(* techmap_simplemap *)
(* techmap_celltype = "$eq $eqx $ne $nex" *)
module _90_simplemap_compare_ops;
endmodule

(* techmap_simplemap *)
(* techmap_celltype = "$pos $slice $concat $mux $tribuf $bmux $bwmux $bweqx" *)
module _90_simplemap_various;
endmodule

(* techmap_simplemap *)
(* techmap_celltype = "$sr $ff $dff $dffe $adff $adffe $aldff $aldffe $sdff $sdffe $sdffce $dffsr $dffsre $dlatch $adlatch $dlatchsr" *)
module _90_simplemap_registers;
endmodule


// --------------------------------------------------------
// Shift operators
// --------------------------------------------------------

(* techmap_celltype = "$shr $shl $sshl $sshr" *)
module _90_shift_ops_shr_shl_sshl_sshr (A, B, Y);
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;
	parameter A_WIDTH = 1;
	parameter B_WIDTH = 1;
	parameter Y_WIDTH = 1;

	parameter _TECHMAP_CELLTYPE_ = "";
	localparam shift_left = _TECHMAP_CELLTYPE_ == "$shl" || _TECHMAP_CELLTYPE_ == "$sshl";
	localparam sign_extend = A_SIGNED && _TECHMAP_CELLTYPE_ == "$sshr";

	(* force_downto *)
	input [A_WIDTH-1:0] A;
	(* force_downto *)
	input [B_WIDTH-1:0] B;
	(* force_downto *)
	output [Y_WIDTH-1:0] Y;

	localparam WIDTH = \`MAX(A_WIDTH, Y_WIDTH);
	localparam BB_WIDTH = \`MIN($clog2(shift_left ? Y_WIDTH : A_SIGNED ? WIDTH : A_WIDTH) + 1, B_WIDTH);

	wire [1023:0] _TECHMAP_DO_00_ = "proc;;";
	wire [1023:0] _TECHMAP_DO_01_ = "RECURSION; CONSTMAP; opt_muxtree; opt_expr -mux_undef -mux_bool -fine;;;";

	integer i;
	(* force_downto *)
	reg [WIDTH-1:0] buffer;
	reg overflow;

	always @* begin
		overflow = B_WIDTH > BB_WIDTH ? |B[B_WIDTH-1:BB_WIDTH] : 1'b0;
		buffer = overflow ? {WIDTH{sign_extend ? A[A_WIDTH-1] : 1'b0}} : {{WIDTH-A_WIDTH{A_SIGNED ? A[A_WIDTH-1] : 1'b0}}, A};

		for (i = 0; i < BB_WIDTH; i = i+1)
			if (B[i]) begin
				if (shift_left)
					buffer = {buffer, (2**i)'b0};
				else if (2**i < WIDTH)
					buffer = {{2**i{sign_extend ? buffer[WIDTH-1] : 1'b0}}, buffer[WIDTH-1 : 2**i]};
				else
					buffer = {WIDTH{sign_extend ? buffer[WIDTH-1] : 1'b0}};
			end
	end

	assign Y = buffer;
endmodule

(* techmap_celltype = "$shift $shiftx" *)
module _90_shift_shiftx (A, B, Y);
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;
	parameter A_WIDTH = 1;
	parameter B_WIDTH = 1;
	parameter Y_WIDTH = 1;

	(* force_downto *)
	input [A_WIDTH-1:0] A;
	(* force_downto *)
	input [B_WIDTH-1:0] B;
	(* force_downto *)
	output [Y_WIDTH-1:0] Y;

	parameter _TECHMAP_CELLTYPE_ = "";
	parameter [B_WIDTH-1:0] _TECHMAP_CONSTMSK_B_ = 0;
	parameter [B_WIDTH-1:0] _TECHMAP_CONSTVAL_B_ = 0;

	localparam extbit = _TECHMAP_CELLTYPE_ == "$shift" ? 1'b0 : 1'bx;
	wire a_padding = _TECHMAP_CELLTYPE_ == "$shiftx" ? extbit : (A_SIGNED ? A[A_WIDTH-1] : 1'b0);

	localparam BB_WIDTH = \`MIN($clog2(\`MAX(A_WIDTH, Y_WIDTH)) + (B_SIGNED ? 2 : 1), B_WIDTH);
	localparam WIDTH = \`MAX(A_WIDTH, Y_WIDTH) + (B_SIGNED ? 2**(BB_WIDTH-1) : 0);

	wire [1023:0] _TECHMAP_DO_00_ = "proc;;";
	wire [1023:0] _TECHMAP_DO_01_ = "CONSTMAP; opt_muxtree; opt_expr -mux_undef -mux_bool -fine;;;";

	integer i;
	(* force_downto *)
	reg [WIDTH-1:0] buffer;
	reg overflow;

	always @* begin
		overflow = 0;
		buffer = {WIDTH{extbit}};
		buffer[Y_WIDTH-1:0] = {Y_WIDTH{a_padding}};
		buffer[A_WIDTH-1:0] = A;

		if (B_WIDTH > BB_WIDTH) begin
			if (B_SIGNED) begin
				for (i = BB_WIDTH; i < B_WIDTH; i = i+1)
					if (B[i] != B[BB_WIDTH-1])
						overflow = 1;
			end else
				overflow = |B[B_WIDTH-1:BB_WIDTH];
			if (overflow)
				buffer = {WIDTH{extbit}};
		end

		if (B_SIGNED && B[BB_WIDTH-1])
			buffer = {buffer, {2**(BB_WIDTH-1){extbit}}};

		for (i = 0; i < (B_SIGNED ? BB_WIDTH-1 : BB_WIDTH); i = i+1)
			if (B[i]) begin
				if (2**i < WIDTH)
					buffer = {{2**i{extbit}}, buffer[WIDTH-1 : 2**i]};
				else
					buffer = {WIDTH{extbit}};
			end
	end
	assign Y = buffer;
endmodule


// --------------------------------------------------------
// Arithmetic operators
// --------------------------------------------------------

(* techmap_celltype = "$fa" *)
module _90_fa (A, B, C, X, Y);
	parameter WIDTH = 1;

	(* force_downto *)
	input [WIDTH-1:0] A, B, C;
	(* force_downto *)
	output [WIDTH-1:0] X, Y;

	(* force_downto *)
	wire [WIDTH-1:0] t1, t2, t3;

	assign t1 = A ^ B, t2 = A & B, t3 = C & t1;
	assign Y = t1 ^ C, X = t2 | t3;
endmodule

(* techmap_celltype = "$lcu" *)
module _90_lcu_brent_kung (P, G, CI, CO);
	parameter WIDTH = 2;

	(* force_downto *)
	input [WIDTH-1:0] P, G;
	input CI;

	(* force_downto *)
	output [WIDTH-1:0] CO;

	integer i, j;
	(* force_downto *)
	reg [WIDTH-1:0] p, g;

	wire [1023:0] _TECHMAP_DO_ = "proc; opt -fast";

	always @* begin
		p = P;
		g = G;

		// in almost all cases CI will be constant zero
		g[0] = g[0] | (p[0] & CI);

		// [[CITE]] Brent Kung Adder
		// R. P. Brent and H. T. Kung, "A Regular Layout for Parallel Adders",
		// IEEE Transaction on Computers, Vol. C-31, No. 3, p. 260-264, March, 1982

		// Main tree
		for (i = 1; i <= $clog2(WIDTH); i = i+1) begin
			for (j = 2**i - 1; j < WIDTH; j = j + 2**i) begin
				g[j] = g[j] | p[j] & g[j - 2**(i-1)];
				p[j] = p[j] & p[j - 2**(i-1)];
			end
		end

		// Inverse tree
		for (i = $clog2(WIDTH); i > 0; i = i-1) begin
			for (j = 2**i + 2**(i-1) - 1; j < WIDTH; j = j + 2**i) begin
				g[j] = g[j] | p[j] & g[j - 2**(i-1)];
				p[j] = p[j] & p[j - 2**(i-1)];
			end
		end
	end

	assign CO = g;
endmodule

(* techmap_celltype = "$alu" *)
module _90_alu (A, B, CI, BI, X, Y, CO);
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;
	parameter A_WIDTH = 1;
	parameter B_WIDTH = 1;
	parameter Y_WIDTH = 1;

	(* force_downto *)
	input [A_WIDTH-1:0] A;
	(* force_downto *)
	input [B_WIDTH-1:0] B;
	(* force_downto *)
	output [Y_WIDTH-1:0] X, Y;

	input CI, BI;
	(* force_downto *)
	output [Y_WIDTH-1:0] CO;

	(* force_downto *)
	wire [Y_WIDTH-1:0] AA = A_buf;
	(* force_downto *)
	wire [Y_WIDTH-1:0] BB = BI ? ~B_buf : B_buf;

	(* force_downto *)
	wire [Y_WIDTH-1:0] A_buf, B_buf;
	\\$pos #(.A_SIGNED(A_SIGNED), .A_WIDTH(A_WIDTH), .Y_WIDTH(Y_WIDTH)) A_conv (.A(A), .Y(A_buf));
	\\$pos #(.A_SIGNED(B_SIGNED), .A_WIDTH(B_WIDTH), .Y_WIDTH(Y_WIDTH)) B_conv (.A(B), .Y(B_buf));

	\\$lcu #(.WIDTH(Y_WIDTH)) lcu (.P(X), .G(AA & BB), .CI(CI), .CO(CO));

	assign X = AA ^ BB;
	assign Y = X ^ {CO, CI};
endmodule

(* techmap_maccmap *)
(* techmap_celltype = "$macc" *)
module _90_macc;
endmodule

(* techmap_wrap = "alumacc" *)
(* techmap_celltype = "$lt $le $ge $gt $add $sub $neg $mul" *)
module _90_alumacc;
endmodule


// --------------------------------------------------------
// Divide and Modulo
// --------------------------------------------------------

module \\$__div_mod_u (A, B, Y, R);
	parameter WIDTH = 1;

	(* force_downto *)
	input [WIDTH-1:0] A, B;
	(* force_downto *)
	output [WIDTH-1:0] Y, R;

	(* force_downto *)
	wire [WIDTH*WIDTH-1:0] chaindata;
	assign R = chaindata[WIDTH*WIDTH-1:WIDTH*(WIDTH-1)];

	genvar i;
	generate begin
		for (i = 0; i < WIDTH; i=i+1) begin:stage
			(* force_downto *)
			wire [WIDTH-1:0] stage_in;

			if (i == 0) begin:cp
				assign stage_in = A;
			end else begin:cp
				assign stage_in = chaindata[i*WIDTH-1:(i-1)*WIDTH];
			end

			assign Y[WIDTH-(i+1)] = stage_in >= {B, {WIDTH-(i+1){1'b0}}};
			assign chaindata[(i+1)*WIDTH-1:i*WIDTH] = Y[WIDTH-(i+1)] ? stage_in - {B, {WIDTH-(i+1){1'b0}}} : stage_in;
		end
	end endgenerate
endmodule

// truncating signed division/modulo
module \\$__div_mod_trunc (A, B, Y, R);
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;
	parameter A_WIDTH = 1;
	parameter B_WIDTH = 1;
	parameter Y_WIDTH = 1;

	localparam WIDTH =
			A_WIDTH >= B_WIDTH && A_WIDTH >= Y_WIDTH ? A_WIDTH :
			B_WIDTH >= A_WIDTH && B_WIDTH >= Y_WIDTH ? B_WIDTH : Y_WIDTH;

	(* force_downto *)
	input [A_WIDTH-1:0] A;
	(* force_downto *)
	input [B_WIDTH-1:0] B;
	(* force_downto *)
	output [Y_WIDTH-1:0] Y, R;

	(* force_downto *)
	wire [WIDTH-1:0] A_buf, B_buf;
	\\$pos #(.A_SIGNED(A_SIGNED), .A_WIDTH(A_WIDTH), .Y_WIDTH(WIDTH)) A_conv (.A(A), .Y(A_buf));
	\\$pos #(.A_SIGNED(B_SIGNED), .A_WIDTH(B_WIDTH), .Y_WIDTH(WIDTH)) B_conv (.A(B), .Y(B_buf));

	(* force_downto *)
	wire [WIDTH-1:0] A_buf_u, B_buf_u, Y_u, R_u;
	assign A_buf_u = A_SIGNED && A_buf[WIDTH-1] ? -A_buf : A_buf;
	assign B_buf_u = B_SIGNED && B_buf[WIDTH-1] ? -B_buf : B_buf;

	\\$__div_mod_u #(
		.WIDTH(WIDTH)
	) div_mod_u (
		.A(A_buf_u),
		.B(B_buf_u),
		.Y(Y_u),
		.R(R_u)
	);

	assign Y = A_SIGNED && B_SIGNED && (A_buf[WIDTH-1] != B_buf[WIDTH-1]) ? -Y_u : Y_u;
	assign R = A_SIGNED && B_SIGNED && A_buf[WIDTH-1] ? -R_u : R_u;
endmodule

(* techmap_celltype = "$div" *)
module _90_div (A, B, Y);
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;
	parameter A_WIDTH = 1;
	parameter B_WIDTH = 1;
	parameter Y_WIDTH = 1;

	(* force_downto *)
	input [A_WIDTH-1:0] A;
	(* force_downto *)
	input [B_WIDTH-1:0] B;
	(* force_downto *)
	output [Y_WIDTH-1:0] Y;

	\\$__div_mod_trunc #(
		.A_SIGNED(A_SIGNED),
		.B_SIGNED(B_SIGNED),
		.A_WIDTH(A_WIDTH),
		.B_WIDTH(B_WIDTH),
		.Y_WIDTH(Y_WIDTH)
	) div_mod (
		.A(A),
		.B(B),
		.Y(Y)
	);
endmodule

(* techmap_celltype = "$mod" *)
module _90_mod (A, B, Y);
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;
	parameter A_WIDTH = 1;
	parameter B_WIDTH = 1;
	parameter Y_WIDTH = 1;

	(* force_downto *)
	input [A_WIDTH-1:0] A;
	(* force_downto *)
	input [B_WIDTH-1:0] B;
	(* force_downto *)
	output [Y_WIDTH-1:0] Y;

	\\$__div_mod_trunc #(
		.A_SIGNED(A_SIGNED),
		.B_SIGNED(B_SIGNED),
		.A_WIDTH(A_WIDTH),
		.B_WIDTH(B_WIDTH),
		.Y_WIDTH(Y_WIDTH)
	) div_mod (
		.A(A),
		.B(B),
		.R(Y)
	);
endmodule

// flooring signed division/modulo
module \\$__div_mod_floor (A, B, Y, R);
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;
	parameter A_WIDTH = 1;
	parameter B_WIDTH = 1;
	parameter Y_WIDTH = 1;

	localparam WIDTH =
			A_WIDTH >= B_WIDTH && A_WIDTH >= Y_WIDTH ? A_WIDTH :
			B_WIDTH >= A_WIDTH && B_WIDTH >= Y_WIDTH ? B_WIDTH : Y_WIDTH;

	input [A_WIDTH-1:0] A;
	input [B_WIDTH-1:0] B;
	output [Y_WIDTH-1:0] Y, R;

	wire [WIDTH-1:0] A_buf, B_buf;
	\\$pos #(.A_SIGNED(A_SIGNED), .A_WIDTH(A_WIDTH), .Y_WIDTH(WIDTH)) A_conv (.A(A), .Y(A_buf));
	\\$pos #(.A_SIGNED(B_SIGNED), .A_WIDTH(B_WIDTH), .Y_WIDTH(WIDTH)) B_conv (.A(B), .Y(B_buf));

	wire [WIDTH-1:0] A_buf_u, B_buf_u, Y_u, R_u, R_s;
	assign A_buf_u = A_SIGNED && A_buf[WIDTH-1] ? -A_buf : A_buf;
	assign B_buf_u = B_SIGNED && B_buf[WIDTH-1] ? -B_buf : B_buf;

	\\$__div_mod_u #(
		.WIDTH(WIDTH)
	) div_mod_u (
		.A(A_buf_u),
		.B(B_buf_u),
		.Y(Y_u),
		.R(R_u)
	);

	// For negative results, if there was a remainder, subtract one to turn
	// the round towards 0 into a round towards -inf
	assign Y = A_SIGNED && B_SIGNED && (A_buf[WIDTH-1] != B_buf[WIDTH-1]) ? (R_u == 0 ? -Y_u : -Y_u-1) : Y_u;

	// truncating modulo
	assign R_s = A_SIGNED && B_SIGNED && A_buf[WIDTH-1] ? -R_u : R_u;
	// Flooring modulo differs from truncating modulo only if it is nonzero and
	// A and B have different signs - then \`floor - trunc = B\`
	assign R = (R_s != 0) && A_SIGNED && B_SIGNED && (A_buf[WIDTH-1] != B_buf[WIDTH-1]) ? $signed(B_buf) + $signed(R_s) : R_s;
endmodule

(* techmap_celltype = "$divfloor" *)
module _90_divfloor (A, B, Y);
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;
	parameter A_WIDTH = 1;
	parameter B_WIDTH = 1;
	parameter Y_WIDTH = 1;

	(* force_downto *)
	input [A_WIDTH-1:0] A;
	(* force_downto *)
	input [B_WIDTH-1:0] B;
	(* force_downto *)
	output [Y_WIDTH-1:0] Y;

	\\$__div_mod_floor #(
		.A_SIGNED(A_SIGNED),
		.B_SIGNED(B_SIGNED),
		.A_WIDTH(A_WIDTH),
		.B_WIDTH(B_WIDTH),
		.Y_WIDTH(Y_WIDTH)
	) div_mod (
		.A(A),
		.B(B),
		.Y(Y)
	);
endmodule

(* techmap_celltype = "$modfloor" *)
module _90_modfloor (A, B, Y);
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;
	parameter A_WIDTH = 1;
	parameter B_WIDTH = 1;
	parameter Y_WIDTH = 1;

	(* force_downto *)
	input [A_WIDTH-1:0] A;
	(* force_downto *)
	input [B_WIDTH-1:0] B;
	(* force_downto *)
	output [Y_WIDTH-1:0] Y;

	\\$__div_mod_floor #(
		.A_SIGNED(A_SIGNED),
		.B_SIGNED(B_SIGNED),
		.A_WIDTH(A_WIDTH),
		.B_WIDTH(B_WIDTH),
		.Y_WIDTH(Y_WIDTH)
	) div_mod (
		.A(A),
		.B(B),
		.R(Y)
	);
endmodule


// --------------------------------------------------------
// Power
// --------------------------------------------------------

(* techmap_celltype = "$pow" *)
module _90_pow (A, B, Y);
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;
	parameter A_WIDTH = 1;
	parameter B_WIDTH = 1;
	parameter Y_WIDTH = 1;

	(* force_downto *)
	input [A_WIDTH-1:0] A;
	(* force_downto *)
	input [B_WIDTH-1:0] B;
	(* force_downto *)
	output [Y_WIDTH-1:0] Y;

	wire _TECHMAP_FAIL_ = 1;
endmodule


// --------------------------------------------------------
// Parallel Multiplexers
// --------------------------------------------------------

(* techmap_celltype = "$pmux" *)
module _90_pmux (A, B, S, Y);
	parameter WIDTH = 1;
	parameter S_WIDTH = 1;

	(* force_downto *)
	input [WIDTH-1:0] A;
	(* force_downto *)
	input [WIDTH*S_WIDTH-1:0] B;
	(* force_downto *)
	input [S_WIDTH-1:0] S;
	(* force_downto *)
	output [WIDTH-1:0] Y;

	(* force_downto *)
	wire [WIDTH-1:0] Y_B;

	genvar i, j;
	generate
		(* force_downto *)
		wire [WIDTH*S_WIDTH-1:0] B_AND_S;
		for (i = 0; i < S_WIDTH; i = i + 1) begin:B_AND
			assign B_AND_S[WIDTH*(i+1)-1:WIDTH*i] = B[WIDTH*(i+1)-1:WIDTH*i] & {WIDTH{S[i]}};
		end:B_AND
		for (i = 0; i < WIDTH; i = i + 1) begin:B_OR
			(* force_downto *)
			wire [S_WIDTH-1:0] B_AND_BITS;
			for (j = 0; j < S_WIDTH; j = j + 1) begin:B_AND_BITS_COLLECT
				assign B_AND_BITS[j] = B_AND_S[WIDTH*j+i];
			end:B_AND_BITS_COLLECT
			assign Y_B[i] = |B_AND_BITS;
		end:B_OR
	endgenerate

	assign Y = |S ? Y_B : A;
endmodule

// --------------------------------------------------------
// Demultiplexers
// --------------------------------------------------------

(* techmap_celltype = "$demux" *)
module _90_demux (A, S, Y);
	parameter WIDTH = 1;
	parameter S_WIDTH = 1;

	(* force_downto *)
	input [WIDTH-1:0] A;
	(* force_downto *)
	input [S_WIDTH-1:0] S;
	(* force_downto *)
	output [(WIDTH << S_WIDTH)-1:0] Y;

	generate
		if (S_WIDTH == 0) begin
			assign Y = A;
		end else if (S_WIDTH == 1) begin
			assign Y[0+:WIDTH] = S ? 0 : A;
			assign Y[WIDTH+:WIDTH] = S ? A : 0;
		end else begin
			localparam SPLIT = S_WIDTH / 2;
			wire [(1 << (S_WIDTH-SPLIT))-1:0] YH;
			wire [(1 << SPLIT)-1:0] YL;
			$demux #(.WIDTH(1), .S_WIDTH(SPLIT)) lo (.A(1'b1), .S(S[SPLIT-1:0]), .Y(YL));
			$demux #(.WIDTH(1), .S_WIDTH(S_WIDTH-SPLIT)) hi (.A(1'b1), .S(S[S_WIDTH-1:SPLIT]), .Y(YH));
			genvar i;
			for (i = 0; i < (1 << S_WIDTH); i = i + 1) begin
				localparam [S_WIDTH-1:0] IDX = i;
				assign Y[i*WIDTH+:WIDTH] = (YL[IDX[SPLIT-1:0]] & YH[IDX[S_WIDTH-1:SPLIT]]) ? A : 0;
			end
		end
	endgenerate
endmodule


// --------------------------------------------------------
// LUTs
// --------------------------------------------------------

\`ifndef NOLUT
(* techmap_simplemap *)
(* techmap_celltype = "$lut $sop" *)
module _90_lut;
endmodule
\`endif

`,xilinx:{"abc9_model.v":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *                2019  Eddie Hung    <eddie@fpgeh.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

// ============================================================================

// Box containing MUXF7.[AB] + MUXF8,
//   Necessary to make these an atomic unit so that
//   ABC cannot optimise just one of the MUXF7 away
//   and expect to save on its delay
(* abc9_box, lib_whitebox *)
module \\$__XILINX_MUXF78 (output O, input I0, I1, I2, I3, S0, S1);
  assign O = S1 ? (S0 ? I3 : I2)
                : (S0 ? I1 : I0);
  specify
    (I0 => O) = 294;
    (I1 => O) = 297;
    (I2 => O) = 311;
    (I3 => O) = 317;
    (S0 => O) = 390;
    (S1 => O) = 273;
  endspecify
endmodule
`,"arith_map.v":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

// ============================================================================
// LCU

(* techmap_celltype = "$lcu" *)
module _80_xilinx_lcu (P, G, CI, CO);
	parameter WIDTH = 2;

	(* force_downto *)
	input [WIDTH-1:0] P, G;
	input CI;

	(* force_downto *)
	output [WIDTH-1:0] CO;

	wire _TECHMAP_FAIL_ = WIDTH <= 2;

	genvar i;

generate if (\`LUT_SIZE == 4) begin

	(* force_downto *)
	wire [WIDTH-1:0] C = {CO, CI};
	(* force_downto *)
	wire [WIDTH-1:0] S = P & ~G;

	generate for (i = 0; i < WIDTH; i = i + 1) begin:slice
		MUXCY muxcy (
			.CI(C[i]),
			.DI(G[i]),
			.S(S[i]),
			.O(CO[i])
		);
	end endgenerate

end else begin

	localparam CARRY4_COUNT = (WIDTH + 3) / 4;
	localparam MAX_WIDTH    = CARRY4_COUNT * 4;
	localparam PAD_WIDTH    = MAX_WIDTH - WIDTH;

	(* force_downto *)
	wire [MAX_WIDTH-1:0] S =  {{PAD_WIDTH{1'b0}}, P & ~G};
	(* force_downto *)
	wire [MAX_WIDTH-1:0] GG = {{PAD_WIDTH{1'b0}}, G};
	(* force_downto *)
	wire [MAX_WIDTH-1:0] C;
	assign CO = C;

	generate for (i = 0; i < CARRY4_COUNT; i = i + 1) begin:slice
		if (i == 0) begin
			CARRY4 carry4
			(
			.CYINIT(CI),
			.CI    (1'd0),
			.DI    (GG[i*4 +: 4]),
			.S     (S [i*4 +: 4]),
			.CO    (C [i*4 +: 4]),
			);
		end else begin
			CARRY4 carry4
			(
			.CYINIT(1'd0),
			.CI    (C [i*4 - 1]),
			.DI    (GG[i*4 +: 4]),
			.S     (S [i*4 +: 4]),
			.CO    (C [i*4 +: 4]),
			);
		end
	end endgenerate
end endgenerate

endmodule


// ============================================================================
// ALU

(* techmap_celltype = "$alu" *)
module _80_xilinx_alu (A, B, CI, BI, X, Y, CO);
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;
	parameter A_WIDTH = 1;
	parameter B_WIDTH = 1;
	parameter Y_WIDTH = 1;
	parameter _TECHMAP_CONSTVAL_CI_ = 0;
	parameter _TECHMAP_CONSTMSK_CI_ = 0;

	(* force_downto *)
	input [A_WIDTH-1:0] A;
	(* force_downto *)
	input [B_WIDTH-1:0] B;
	(* force_downto *)
	output [Y_WIDTH-1:0] X, Y;

	input CI, BI;
	(* force_downto *)
	output [Y_WIDTH-1:0] CO;

	wire _TECHMAP_FAIL_ = Y_WIDTH <= 2;

	(* force_downto *)
	wire [Y_WIDTH-1:0] A_buf, B_buf;
	\\$pos #(.A_SIGNED(A_SIGNED), .A_WIDTH(A_WIDTH), .Y_WIDTH(Y_WIDTH)) A_conv (.A(A), .Y(A_buf));
	\\$pos #(.A_SIGNED(B_SIGNED), .A_WIDTH(B_WIDTH), .Y_WIDTH(Y_WIDTH)) B_conv (.A(B), .Y(B_buf));

	(* force_downto *)
	wire [Y_WIDTH-1:0] AA = A_buf;
	(* force_downto *)
	wire [Y_WIDTH-1:0] BB = BI ? ~B_buf : B_buf;

	genvar i;

generate if (\`LUT_SIZE == 4) begin

	(* force_downto *)
	wire [Y_WIDTH-1:0] C = {CO, CI};
	(* force_downto *)
	wire [Y_WIDTH-1:0] S  = {AA ^ BB};

	genvar i;
	generate for (i = 0; i < Y_WIDTH; i = i + 1) begin:slice
		MUXCY muxcy (
			.CI(C[i]),
			.DI(AA[i]),
			.S(S[i]),
			.O(CO[i])
		);
		XORCY xorcy (
			.CI(C[i]),
			.LI(S[i]),
			.O(Y[i])
		);
	end endgenerate

	assign X = S;

end else begin

	localparam CARRY4_COUNT = (Y_WIDTH + 3) / 4;
	localparam MAX_WIDTH    = CARRY4_COUNT * 4;
	localparam PAD_WIDTH    = MAX_WIDTH - Y_WIDTH;

	(* force_downto *)
	wire [MAX_WIDTH-1:0] S  = {{PAD_WIDTH{1'b0}}, AA ^ BB};
	(* force_downto *)
	wire [MAX_WIDTH-1:0] DI = {{PAD_WIDTH{1'b0}}, AA};

	(* force_downto *)
	wire [MAX_WIDTH-1:0] O;
	(* force_downto *)
	wire [MAX_WIDTH-1:0] C;
	assign Y = O, CO = C;

	genvar i;
	generate for (i = 0; i < CARRY4_COUNT; i = i + 1) begin:slice
		if (i == 0) begin
			CARRY4 carry4
			(
			.CYINIT(CI),
			.CI    (1'd0),
			.DI    (DI[i*4 +: 4]),
			.S     (S [i*4 +: 4]),
			.O     (O [i*4 +: 4]),
			.CO    (C [i*4 +: 4])
			);
		end else begin
		    CARRY4 carry4
		    (
			.CYINIT(1'd0),
			.CI    (C [i*4 - 1]),
			.DI    (DI[i*4 +: 4]),
			.S     (S [i*4 +: 4]),
			.O     (O [i*4 +: 4]),
			.CO    (C [i*4 +: 4])
		    );
		end
	end endgenerate

	assign X = S;

end endgenerate
endmodule

`,"brams_defs.vh":`\`define PARAMS_INIT_9 \\
	.INIT_00(slice_init('h00)), \\
	.INIT_01(slice_init('h01)), \\
	.INIT_02(slice_init('h02)), \\
	.INIT_03(slice_init('h03)), \\
	.INIT_04(slice_init('h04)), \\
	.INIT_05(slice_init('h05)), \\
	.INIT_06(slice_init('h06)), \\
	.INIT_07(slice_init('h07)), \\
	.INIT_08(slice_init('h08)), \\
	.INIT_09(slice_init('h09)), \\
	.INIT_0A(slice_init('h0a)), \\
	.INIT_0B(slice_init('h0b)), \\
	.INIT_0C(slice_init('h0c)), \\
	.INIT_0D(slice_init('h0d)), \\
	.INIT_0E(slice_init('h0e)), \\
	.INIT_0F(slice_init('h0f)), \\
	.INIT_10(slice_init('h10)), \\
	.INIT_11(slice_init('h11)), \\
	.INIT_12(slice_init('h12)), \\
	.INIT_13(slice_init('h13)), \\
	.INIT_14(slice_init('h14)), \\
	.INIT_15(slice_init('h15)), \\
	.INIT_16(slice_init('h16)), \\
	.INIT_17(slice_init('h17)), \\
	.INIT_18(slice_init('h18)), \\
	.INIT_19(slice_init('h19)), \\
	.INIT_1A(slice_init('h1a)), \\
	.INIT_1B(slice_init('h1b)), \\
	.INIT_1C(slice_init('h1c)), \\
	.INIT_1D(slice_init('h1d)), \\
	.INIT_1E(slice_init('h1e)), \\
	.INIT_1F(slice_init('h1f)),

\`define PARAMS_INITP_9 \\
	.INITP_00(slice_initp('h00)), \\
	.INITP_01(slice_initp('h01)), \\
	.INITP_02(slice_initp('h02)), \\
	.INITP_03(slice_initp('h03)),

\`define PARAMS_INIT_18 \\
	.INIT_00(slice_init('h00)), \\
	.INIT_01(slice_init('h01)), \\
	.INIT_02(slice_init('h02)), \\
	.INIT_03(slice_init('h03)), \\
	.INIT_04(slice_init('h04)), \\
	.INIT_05(slice_init('h05)), \\
	.INIT_06(slice_init('h06)), \\
	.INIT_07(slice_init('h07)), \\
	.INIT_08(slice_init('h08)), \\
	.INIT_09(slice_init('h09)), \\
	.INIT_0A(slice_init('h0a)), \\
	.INIT_0B(slice_init('h0b)), \\
	.INIT_0C(slice_init('h0c)), \\
	.INIT_0D(slice_init('h0d)), \\
	.INIT_0E(slice_init('h0e)), \\
	.INIT_0F(slice_init('h0f)), \\
	.INIT_10(slice_init('h10)), \\
	.INIT_11(slice_init('h11)), \\
	.INIT_12(slice_init('h12)), \\
	.INIT_13(slice_init('h13)), \\
	.INIT_14(slice_init('h14)), \\
	.INIT_15(slice_init('h15)), \\
	.INIT_16(slice_init('h16)), \\
	.INIT_17(slice_init('h17)), \\
	.INIT_18(slice_init('h18)), \\
	.INIT_19(slice_init('h19)), \\
	.INIT_1A(slice_init('h1a)), \\
	.INIT_1B(slice_init('h1b)), \\
	.INIT_1C(slice_init('h1c)), \\
	.INIT_1D(slice_init('h1d)), \\
	.INIT_1E(slice_init('h1e)), \\
	.INIT_1F(slice_init('h1f)), \\
	.INIT_20(slice_init('h20)), \\
	.INIT_21(slice_init('h21)), \\
	.INIT_22(slice_init('h22)), \\
	.INIT_23(slice_init('h23)), \\
	.INIT_24(slice_init('h24)), \\
	.INIT_25(slice_init('h25)), \\
	.INIT_26(slice_init('h26)), \\
	.INIT_27(slice_init('h27)), \\
	.INIT_28(slice_init('h28)), \\
	.INIT_29(slice_init('h29)), \\
	.INIT_2A(slice_init('h2a)), \\
	.INIT_2B(slice_init('h2b)), \\
	.INIT_2C(slice_init('h2c)), \\
	.INIT_2D(slice_init('h2d)), \\
	.INIT_2E(slice_init('h2e)), \\
	.INIT_2F(slice_init('h2f)), \\
	.INIT_30(slice_init('h30)), \\
	.INIT_31(slice_init('h31)), \\
	.INIT_32(slice_init('h32)), \\
	.INIT_33(slice_init('h33)), \\
	.INIT_34(slice_init('h34)), \\
	.INIT_35(slice_init('h35)), \\
	.INIT_36(slice_init('h36)), \\
	.INIT_37(slice_init('h37)), \\
	.INIT_38(slice_init('h38)), \\
	.INIT_39(slice_init('h39)), \\
	.INIT_3A(slice_init('h3a)), \\
	.INIT_3B(slice_init('h3b)), \\
	.INIT_3C(slice_init('h3c)), \\
	.INIT_3D(slice_init('h3d)), \\
	.INIT_3E(slice_init('h3e)), \\
	.INIT_3F(slice_init('h3f)),

\`define PARAMS_INIT_18_U \\
	.INIT_00(slice_init('h40)), \\
	.INIT_01(slice_init('h41)), \\
	.INIT_02(slice_init('h42)), \\
	.INIT_03(slice_init('h43)), \\
	.INIT_04(slice_init('h44)), \\
	.INIT_05(slice_init('h45)), \\
	.INIT_06(slice_init('h46)), \\
	.INIT_07(slice_init('h47)), \\
	.INIT_08(slice_init('h48)), \\
	.INIT_09(slice_init('h49)), \\
	.INIT_0A(slice_init('h4a)), \\
	.INIT_0B(slice_init('h4b)), \\
	.INIT_0C(slice_init('h4c)), \\
	.INIT_0D(slice_init('h4d)), \\
	.INIT_0E(slice_init('h4e)), \\
	.INIT_0F(slice_init('h4f)), \\
	.INIT_10(slice_init('h50)), \\
	.INIT_11(slice_init('h51)), \\
	.INIT_12(slice_init('h52)), \\
	.INIT_13(slice_init('h53)), \\
	.INIT_14(slice_init('h54)), \\
	.INIT_15(slice_init('h55)), \\
	.INIT_16(slice_init('h56)), \\
	.INIT_17(slice_init('h57)), \\
	.INIT_18(slice_init('h58)), \\
	.INIT_19(slice_init('h59)), \\
	.INIT_1A(slice_init('h5a)), \\
	.INIT_1B(slice_init('h5b)), \\
	.INIT_1C(slice_init('h5c)), \\
	.INIT_1D(slice_init('h5d)), \\
	.INIT_1E(slice_init('h5e)), \\
	.INIT_1F(slice_init('h5f)), \\
	.INIT_20(slice_init('h60)), \\
	.INIT_21(slice_init('h61)), \\
	.INIT_22(slice_init('h62)), \\
	.INIT_23(slice_init('h63)), \\
	.INIT_24(slice_init('h64)), \\
	.INIT_25(slice_init('h65)), \\
	.INIT_26(slice_init('h66)), \\
	.INIT_27(slice_init('h67)), \\
	.INIT_28(slice_init('h68)), \\
	.INIT_29(slice_init('h69)), \\
	.INIT_2A(slice_init('h6a)), \\
	.INIT_2B(slice_init('h6b)), \\
	.INIT_2C(slice_init('h6c)), \\
	.INIT_2D(slice_init('h6d)), \\
	.INIT_2E(slice_init('h6e)), \\
	.INIT_2F(slice_init('h6f)), \\
	.INIT_30(slice_init('h70)), \\
	.INIT_31(slice_init('h71)), \\
	.INIT_32(slice_init('h72)), \\
	.INIT_33(slice_init('h73)), \\
	.INIT_34(slice_init('h74)), \\
	.INIT_35(slice_init('h75)), \\
	.INIT_36(slice_init('h76)), \\
	.INIT_37(slice_init('h77)), \\
	.INIT_38(slice_init('h78)), \\
	.INIT_39(slice_init('h79)), \\
	.INIT_3A(slice_init('h7a)), \\
	.INIT_3B(slice_init('h7b)), \\
	.INIT_3C(slice_init('h7c)), \\
	.INIT_3D(slice_init('h7d)), \\
	.INIT_3E(slice_init('h7e)), \\
	.INIT_3F(slice_init('h7f)),

\`define PARAMS_INITP_18 \\
	.INITP_00(slice_initp('h00)), \\
	.INITP_01(slice_initp('h01)), \\
	.INITP_02(slice_initp('h02)), \\
	.INITP_03(slice_initp('h03)), \\
	.INITP_04(slice_initp('h04)), \\
	.INITP_05(slice_initp('h05)), \\
	.INITP_06(slice_initp('h06)), \\
	.INITP_07(slice_initp('h07)),

\`define PARAMS_INIT_36 \\
	.INIT_00(slice_init('h00)), \\
	.INIT_01(slice_init('h01)), \\
	.INIT_02(slice_init('h02)), \\
	.INIT_03(slice_init('h03)), \\
	.INIT_04(slice_init('h04)), \\
	.INIT_05(slice_init('h05)), \\
	.INIT_06(slice_init('h06)), \\
	.INIT_07(slice_init('h07)), \\
	.INIT_08(slice_init('h08)), \\
	.INIT_09(slice_init('h09)), \\
	.INIT_0A(slice_init('h0a)), \\
	.INIT_0B(slice_init('h0b)), \\
	.INIT_0C(slice_init('h0c)), \\
	.INIT_0D(slice_init('h0d)), \\
	.INIT_0E(slice_init('h0e)), \\
	.INIT_0F(slice_init('h0f)), \\
	.INIT_10(slice_init('h10)), \\
	.INIT_11(slice_init('h11)), \\
	.INIT_12(slice_init('h12)), \\
	.INIT_13(slice_init('h13)), \\
	.INIT_14(slice_init('h14)), \\
	.INIT_15(slice_init('h15)), \\
	.INIT_16(slice_init('h16)), \\
	.INIT_17(slice_init('h17)), \\
	.INIT_18(slice_init('h18)), \\
	.INIT_19(slice_init('h19)), \\
	.INIT_1A(slice_init('h1a)), \\
	.INIT_1B(slice_init('h1b)), \\
	.INIT_1C(slice_init('h1c)), \\
	.INIT_1D(slice_init('h1d)), \\
	.INIT_1E(slice_init('h1e)), \\
	.INIT_1F(slice_init('h1f)), \\
	.INIT_20(slice_init('h20)), \\
	.INIT_21(slice_init('h21)), \\
	.INIT_22(slice_init('h22)), \\
	.INIT_23(slice_init('h23)), \\
	.INIT_24(slice_init('h24)), \\
	.INIT_25(slice_init('h25)), \\
	.INIT_26(slice_init('h26)), \\
	.INIT_27(slice_init('h27)), \\
	.INIT_28(slice_init('h28)), \\
	.INIT_29(slice_init('h29)), \\
	.INIT_2A(slice_init('h2a)), \\
	.INIT_2B(slice_init('h2b)), \\
	.INIT_2C(slice_init('h2c)), \\
	.INIT_2D(slice_init('h2d)), \\
	.INIT_2E(slice_init('h2e)), \\
	.INIT_2F(slice_init('h2f)), \\
	.INIT_30(slice_init('h30)), \\
	.INIT_31(slice_init('h31)), \\
	.INIT_32(slice_init('h32)), \\
	.INIT_33(slice_init('h33)), \\
	.INIT_34(slice_init('h34)), \\
	.INIT_35(slice_init('h35)), \\
	.INIT_36(slice_init('h36)), \\
	.INIT_37(slice_init('h37)), \\
	.INIT_38(slice_init('h38)), \\
	.INIT_39(slice_init('h39)), \\
	.INIT_3A(slice_init('h3a)), \\
	.INIT_3B(slice_init('h3b)), \\
	.INIT_3C(slice_init('h3c)), \\
	.INIT_3D(slice_init('h3d)), \\
	.INIT_3E(slice_init('h3e)), \\
	.INIT_3F(slice_init('h3f)), \\
	.INIT_40(slice_init('h40)), \\
	.INIT_41(slice_init('h41)), \\
	.INIT_42(slice_init('h42)), \\
	.INIT_43(slice_init('h43)), \\
	.INIT_44(slice_init('h44)), \\
	.INIT_45(slice_init('h45)), \\
	.INIT_46(slice_init('h46)), \\
	.INIT_47(slice_init('h47)), \\
	.INIT_48(slice_init('h48)), \\
	.INIT_49(slice_init('h49)), \\
	.INIT_4A(slice_init('h4a)), \\
	.INIT_4B(slice_init('h4b)), \\
	.INIT_4C(slice_init('h4c)), \\
	.INIT_4D(slice_init('h4d)), \\
	.INIT_4E(slice_init('h4e)), \\
	.INIT_4F(slice_init('h4f)), \\
	.INIT_50(slice_init('h50)), \\
	.INIT_51(slice_init('h51)), \\
	.INIT_52(slice_init('h52)), \\
	.INIT_53(slice_init('h53)), \\
	.INIT_54(slice_init('h54)), \\
	.INIT_55(slice_init('h55)), \\
	.INIT_56(slice_init('h56)), \\
	.INIT_57(slice_init('h57)), \\
	.INIT_58(slice_init('h58)), \\
	.INIT_59(slice_init('h59)), \\
	.INIT_5A(slice_init('h5a)), \\
	.INIT_5B(slice_init('h5b)), \\
	.INIT_5C(slice_init('h5c)), \\
	.INIT_5D(slice_init('h5d)), \\
	.INIT_5E(slice_init('h5e)), \\
	.INIT_5F(slice_init('h5f)), \\
	.INIT_60(slice_init('h60)), \\
	.INIT_61(slice_init('h61)), \\
	.INIT_62(slice_init('h62)), \\
	.INIT_63(slice_init('h63)), \\
	.INIT_64(slice_init('h64)), \\
	.INIT_65(slice_init('h65)), \\
	.INIT_66(slice_init('h66)), \\
	.INIT_67(slice_init('h67)), \\
	.INIT_68(slice_init('h68)), \\
	.INIT_69(slice_init('h69)), \\
	.INIT_6A(slice_init('h6a)), \\
	.INIT_6B(slice_init('h6b)), \\
	.INIT_6C(slice_init('h6c)), \\
	.INIT_6D(slice_init('h6d)), \\
	.INIT_6E(slice_init('h6e)), \\
	.INIT_6F(slice_init('h6f)), \\
	.INIT_70(slice_init('h70)), \\
	.INIT_71(slice_init('h71)), \\
	.INIT_72(slice_init('h72)), \\
	.INIT_73(slice_init('h73)), \\
	.INIT_74(slice_init('h74)), \\
	.INIT_75(slice_init('h75)), \\
	.INIT_76(slice_init('h76)), \\
	.INIT_77(slice_init('h77)), \\
	.INIT_78(slice_init('h78)), \\
	.INIT_79(slice_init('h79)), \\
	.INIT_7A(slice_init('h7a)), \\
	.INIT_7B(slice_init('h7b)), \\
	.INIT_7C(slice_init('h7c)), \\
	.INIT_7D(slice_init('h7d)), \\
	.INIT_7E(slice_init('h7e)), \\
	.INIT_7F(slice_init('h7f)),

\`define PARAMS_INIT_36_U \\
	.INIT_00(slice_init('h80)), \\
	.INIT_01(slice_init('h81)), \\
	.INIT_02(slice_init('h82)), \\
	.INIT_03(slice_init('h83)), \\
	.INIT_04(slice_init('h84)), \\
	.INIT_05(slice_init('h85)), \\
	.INIT_06(slice_init('h86)), \\
	.INIT_07(slice_init('h87)), \\
	.INIT_08(slice_init('h88)), \\
	.INIT_09(slice_init('h89)), \\
	.INIT_0A(slice_init('h8a)), \\
	.INIT_0B(slice_init('h8b)), \\
	.INIT_0C(slice_init('h8c)), \\
	.INIT_0D(slice_init('h8d)), \\
	.INIT_0E(slice_init('h8e)), \\
	.INIT_0F(slice_init('h8f)), \\
	.INIT_10(slice_init('h90)), \\
	.INIT_11(slice_init('h91)), \\
	.INIT_12(slice_init('h92)), \\
	.INIT_13(slice_init('h93)), \\
	.INIT_14(slice_init('h94)), \\
	.INIT_15(slice_init('h95)), \\
	.INIT_16(slice_init('h96)), \\
	.INIT_17(slice_init('h97)), \\
	.INIT_18(slice_init('h98)), \\
	.INIT_19(slice_init('h99)), \\
	.INIT_1A(slice_init('h9a)), \\
	.INIT_1B(slice_init('h9b)), \\
	.INIT_1C(slice_init('h9c)), \\
	.INIT_1D(slice_init('h9d)), \\
	.INIT_1E(slice_init('h9e)), \\
	.INIT_1F(slice_init('h9f)), \\
	.INIT_20(slice_init('ha0)), \\
	.INIT_21(slice_init('ha1)), \\
	.INIT_22(slice_init('ha2)), \\
	.INIT_23(slice_init('ha3)), \\
	.INIT_24(slice_init('ha4)), \\
	.INIT_25(slice_init('ha5)), \\
	.INIT_26(slice_init('ha6)), \\
	.INIT_27(slice_init('ha7)), \\
	.INIT_28(slice_init('ha8)), \\
	.INIT_29(slice_init('ha9)), \\
	.INIT_2A(slice_init('haa)), \\
	.INIT_2B(slice_init('hab)), \\
	.INIT_2C(slice_init('hac)), \\
	.INIT_2D(slice_init('had)), \\
	.INIT_2E(slice_init('hae)), \\
	.INIT_2F(slice_init('haf)), \\
	.INIT_30(slice_init('hb0)), \\
	.INIT_31(slice_init('hb1)), \\
	.INIT_32(slice_init('hb2)), \\
	.INIT_33(slice_init('hb3)), \\
	.INIT_34(slice_init('hb4)), \\
	.INIT_35(slice_init('hb5)), \\
	.INIT_36(slice_init('hb6)), \\
	.INIT_37(slice_init('hb7)), \\
	.INIT_38(slice_init('hb8)), \\
	.INIT_39(slice_init('hb9)), \\
	.INIT_3A(slice_init('hba)), \\
	.INIT_3B(slice_init('hbb)), \\
	.INIT_3C(slice_init('hbc)), \\
	.INIT_3D(slice_init('hbd)), \\
	.INIT_3E(slice_init('hbe)), \\
	.INIT_3F(slice_init('hbf)), \\
	.INIT_40(slice_init('hc0)), \\
	.INIT_41(slice_init('hc1)), \\
	.INIT_42(slice_init('hc2)), \\
	.INIT_43(slice_init('hc3)), \\
	.INIT_44(slice_init('hc4)), \\
	.INIT_45(slice_init('hc5)), \\
	.INIT_46(slice_init('hc6)), \\
	.INIT_47(slice_init('hc7)), \\
	.INIT_48(slice_init('hc8)), \\
	.INIT_49(slice_init('hc9)), \\
	.INIT_4A(slice_init('hca)), \\
	.INIT_4B(slice_init('hcb)), \\
	.INIT_4C(slice_init('hcc)), \\
	.INIT_4D(slice_init('hcd)), \\
	.INIT_4E(slice_init('hce)), \\
	.INIT_4F(slice_init('hcf)), \\
	.INIT_50(slice_init('hd0)), \\
	.INIT_51(slice_init('hd1)), \\
	.INIT_52(slice_init('hd2)), \\
	.INIT_53(slice_init('hd3)), \\
	.INIT_54(slice_init('hd4)), \\
	.INIT_55(slice_init('hd5)), \\
	.INIT_56(slice_init('hd6)), \\
	.INIT_57(slice_init('hd7)), \\
	.INIT_58(slice_init('hd8)), \\
	.INIT_59(slice_init('hd9)), \\
	.INIT_5A(slice_init('hda)), \\
	.INIT_5B(slice_init('hdb)), \\
	.INIT_5C(slice_init('hdc)), \\
	.INIT_5D(slice_init('hdd)), \\
	.INIT_5E(slice_init('hde)), \\
	.INIT_5F(slice_init('hdf)), \\
	.INIT_60(slice_init('he0)), \\
	.INIT_61(slice_init('he1)), \\
	.INIT_62(slice_init('he2)), \\
	.INIT_63(slice_init('he3)), \\
	.INIT_64(slice_init('he4)), \\
	.INIT_65(slice_init('he5)), \\
	.INIT_66(slice_init('he6)), \\
	.INIT_67(slice_init('he7)), \\
	.INIT_68(slice_init('he8)), \\
	.INIT_69(slice_init('he9)), \\
	.INIT_6A(slice_init('hea)), \\
	.INIT_6B(slice_init('heb)), \\
	.INIT_6C(slice_init('hec)), \\
	.INIT_6D(slice_init('hed)), \\
	.INIT_6E(slice_init('hee)), \\
	.INIT_6F(slice_init('hef)), \\
	.INIT_70(slice_init('hf0)), \\
	.INIT_71(slice_init('hf1)), \\
	.INIT_72(slice_init('hf2)), \\
	.INIT_73(slice_init('hf3)), \\
	.INIT_74(slice_init('hf4)), \\
	.INIT_75(slice_init('hf5)), \\
	.INIT_76(slice_init('hf6)), \\
	.INIT_77(slice_init('hf7)), \\
	.INIT_78(slice_init('hf8)), \\
	.INIT_79(slice_init('hf9)), \\
	.INIT_7A(slice_init('hfa)), \\
	.INIT_7B(slice_init('hfb)), \\
	.INIT_7C(slice_init('hfc)), \\
	.INIT_7D(slice_init('hfd)), \\
	.INIT_7E(slice_init('hfe)), \\
	.INIT_7F(slice_init('hff)),

\`define PARAMS_INITP_36 \\
	.INITP_00(slice_initp('h00)), \\
	.INITP_01(slice_initp('h01)), \\
	.INITP_02(slice_initp('h02)), \\
	.INITP_03(slice_initp('h03)), \\
	.INITP_04(slice_initp('h04)), \\
	.INITP_05(slice_initp('h05)), \\
	.INITP_06(slice_initp('h06)), \\
	.INITP_07(slice_initp('h07)), \\
	.INITP_08(slice_initp('h08)), \\
	.INITP_09(slice_initp('h09)), \\
	.INITP_0A(slice_initp('h0a)), \\
	.INITP_0B(slice_initp('h0b)), \\
	.INITP_0C(slice_initp('h0c)), \\
	.INITP_0D(slice_initp('h0d)), \\
	.INITP_0E(slice_initp('h0e)), \\
	.INITP_0F(slice_initp('h0f)),

\`define MAKE_DO(do, dop, rdata) \\
	wire [63:0] do; \\
	wire [7:0] dop; \\
	assign rdata = { \\
		dop[7], \\
		do[63:56], \\
		dop[6], \\
		do[55:48], \\
		dop[5], \\
		do[47:40], \\
		dop[4], \\
		do[39:32], \\
		dop[3], \\
		do[31:24], \\
		dop[2], \\
		do[23:16], \\
		dop[1], \\
		do[15:8], \\
		dop[0], \\
		do[7:0] \\
	};

\`define MAKE_DI(di, dip, wdata) \\
	wire [63:0] di; \\
	wire [7:0] dip; \\
	assign { \\
		dip[7], \\
		di[63:56], \\
		dip[6], \\
		di[55:48], \\
		dip[5], \\
		di[47:40], \\
		dip[4], \\
		di[39:32], \\
		dip[3], \\
		di[31:24], \\
		dip[2], \\
		di[23:16], \\
		dip[1], \\
		di[15:8], \\
		dip[0], \\
		di[7:0] \\
	} = wdata;

function [71:0] ival;
	input integer width;
	input [71:0] val;
	if (width == 72)
		ival = {
			val[71],
			val[62],
			val[53],
			val[44],
			val[35],
			val[26],
			val[17],
			val[8],
			val[70:63],
			val[61:54],
			val[52:45],
			val[43:36],
			val[34:27],
			val[25:18],
			val[16:9],
			val[7:0]
		};
	else if (width == 36)
		ival = {
			val[35],
			val[26],
			val[17],
			val[8],
			val[34:27],
			val[25:18],
			val[16:9],
			val[7:0]
		};
	else if (width == 18)
		ival = {
			val[17],
			val[8],
			val[16:9],
			val[7:0]
		};
	else
		ival = val;
endfunction

function [255:0] slice_init;
	input integer idx;
	integer i;
	for (i = 0; i < 32; i = i + 1)
		slice_init[i*8+:8] = INIT[(idx * 32 + i)*9+:8];
endfunction

function [255:0] slice_initp;
	input integer idx;
	integer i;
	for (i = 0; i < 256; i = i + 1)
		slice_initp[i] = INIT[(idx * 256 + i)*9+8];
endfunction
`,"brams_xc2v.txt":`# Block RAMs for Virtex 2, Spartan 3, Spartan 3E, Spartan 3A(N)
# The corresponding mapping file is brams_xc2v_map.v

ram block $__XILINX_BLOCKRAM_ {
	abits 14;
	widths 1 2 4 9 18 36 per_port;
	ifdef HAS_BE {
		option "USE_BE" 1 byte 9;
	}
	cost 129;
	init any;
	port srsw "A" "B" {
		option "USE_BE" 0 width tied;
		ifdef HAS_BE {
			option "USE_BE" 1 width tied 9 18 36;
		}
		clock posedge;
		clken;
		rdsrst any gated_clken;
		rdinit any;
		portoption "WRITE_MODE" "NO_CHANGE" {
			rdwr no_change;
		}
		portoption "WRITE_MODE" "WRITE_FIRST" {
			rdwr new_only;
		}
		portoption "WRITE_MODE" "READ_FIRST" {
			rdwr old;
			wrtrans all old;
		}
		optional;
	}
}
`,"brams_xc2v_map.v":`module $__XILINX_BLOCKRAM_ (...);

parameter INIT = 0;
parameter OPTION_USE_BE = 0;

parameter PORT_A_WIDTH = 1;
parameter PORT_A_WR_EN_WIDTH = 1;
parameter PORT_A_USED = 1;
parameter PORT_A_OPTION_WRITE_MODE = "NO_CHANGE";
parameter PORT_A_RD_INIT_VALUE = 0;
parameter PORT_A_RD_SRST_VALUE = 0;

parameter PORT_B_WIDTH = 1;
parameter PORT_B_WR_EN_WIDTH = 1;
parameter PORT_B_USED = 0;
parameter PORT_B_OPTION_WRITE_MODE = "NO_CHANGE";
parameter PORT_B_RD_INIT_VALUE = 0;
parameter PORT_B_RD_SRST_VALUE = 0;

input PORT_A_CLK;
input PORT_A_CLK_EN;
input [13:0] PORT_A_ADDR;
input [PORT_A_WIDTH-1:0] PORT_A_WR_DATA;
input [PORT_A_WR_EN_WIDTH-1:0] PORT_A_WR_EN;
output [PORT_A_WIDTH-1:0] PORT_A_RD_DATA;
input PORT_A_RD_SRST;

input PORT_B_CLK;
input PORT_B_CLK_EN;
input [13:0] PORT_B_ADDR;
input [PORT_B_WIDTH-1:0] PORT_B_WR_DATA;
input [PORT_B_WR_EN_WIDTH-1:0] PORT_B_WR_EN;
output [PORT_B_WIDTH-1:0] PORT_B_RD_DATA;
input PORT_B_RD_SRST;

\`include "brams_defs.vh"

\`define PARAMS_DP \\
	\`PARAMS_INIT_18 \\
	.WRITE_MODE_A(PORT_A_OPTION_WRITE_MODE), \\
	.WRITE_MODE_B(PORT_B_OPTION_WRITE_MODE), \\
	.SRVAL_A(SRVAL_A), \\
	.SRVAL_B(SRVAL_B), \\
	.INIT_A(INIT_A), \\
	.INIT_B(INIT_B),

\`define PARAMS_DP_SWAP \\
	\`PARAMS_INIT_18 \\
	.WRITE_MODE_A(PORT_B_OPTION_WRITE_MODE), \\
	.WRITE_MODE_B(PORT_A_OPTION_WRITE_MODE), \\
	.SRVAL_A(SRVAL_B), \\
	.SRVAL_B(SRVAL_A), \\
	.INIT_A(INIT_B), \\
	.INIT_B(INIT_A),

\`define PARAMS_SP \\
	\`PARAMS_INIT_18 \\
	.WRITE_MODE(PORT_A_OPTION_WRITE_MODE), \\
	.SRVAL(SRVAL_A), \\
	.INIT(INIT_A),

\`define PORTS_DP(addr_slice_a, addr_slice_b) \\
	.CLKA(PORT_A_CLK), \\
	.ENA(PORT_A_CLK_EN), \\
	.WEA(PORT_A_WR_EN), \\
	.SSRA(PORT_A_RD_SRST), \\
	.ADDRA(PORT_A_ADDR addr_slice_a), \\
	.DOA(DO_A), \\
	.DIA(DI_A), \\
	.CLKB(PORT_B_CLK), \\
	.ENB(PORT_B_CLK_EN), \\
	.WEB(PORT_B_WR_EN), \\
	.SSRB(PORT_B_RD_SRST), \\
	.ADDRB(PORT_B_ADDR addr_slice_b), \\
	.DOB(DO_B), \\
	.DIB(DI_B),

\`define PORTS_DP_SWAP(addr_slice_a, addr_slice_b) \\
	.CLKB(PORT_A_CLK), \\
	.ENB(PORT_A_CLK_EN), \\
	.WEB(PORT_A_WR_EN), \\
	.SSRB(PORT_A_RD_SRST), \\
	.ADDRB(PORT_A_ADDR addr_slice_a), \\
	.DOB(DO_A), \\
	.DIB(DI_A), \\
	.CLKA(PORT_B_CLK), \\
	.ENA(PORT_B_CLK_EN), \\
	.WEA(PORT_B_WR_EN), \\
	.SSRA(PORT_B_RD_SRST), \\
	.ADDRA(PORT_B_ADDR addr_slice_b), \\
	.DOA(DO_B), \\
	.DIA(DI_B),

\`define PORTS_SP(addr_slice) \\
	.CLK(PORT_A_CLK), \\
	.EN(PORT_A_CLK_EN), \\
	.WE(PORT_A_WR_EN), \\
	.SSR(PORT_A_RD_SRST), \\
	.ADDR(PORT_A_ADDR addr_slice), \\
	.DO(DO_A), \\
	.DI(DI_A),

localparam [PORT_A_WIDTH-1:0] SRVAL_A = ival(PORT_A_WIDTH, PORT_A_RD_SRST_VALUE);
localparam [PORT_B_WIDTH-1:0] SRVAL_B = ival(PORT_B_WIDTH, PORT_B_RD_SRST_VALUE);
localparam [PORT_A_WIDTH-1:0] INIT_A = ival(PORT_A_WIDTH, PORT_A_RD_INIT_VALUE);
localparam [PORT_B_WIDTH-1:0] INIT_B = ival(PORT_B_WIDTH, PORT_B_RD_INIT_VALUE);

\`MAKE_DI(DI_A, DIP_A, PORT_A_WR_DATA)
\`MAKE_DI(DI_B, DIP_B, PORT_B_WR_DATA)
\`MAKE_DO(DO_A, DOP_A, PORT_A_RD_DATA)
\`MAKE_DO(DO_B, DOP_B, PORT_B_RD_DATA)

generate

if (OPTION_USE_BE) begin
	if (!PORT_B_USED) begin
		case (PORT_A_WIDTH)
		9: RAMB16_S9 #(
			\`PARAMS_SP
			\`PARAMS_INITP_18
		) _TECHMAP_REPLACE_ (
			\`PORTS_SP([13:3])
			.DIP(DIP_A),
			.DOP(DOP_A),
		);
		18: RAMB16BWE_S18 #(
			\`PARAMS_SP
			\`PARAMS_INITP_18
		) _TECHMAP_REPLACE_ (
			\`PORTS_SP([13:4])
			.DIP(DIP_A),
			.DOP(DOP_A),
		);
		36: RAMB16BWE_S36 #(
			\`PARAMS_SP
			\`PARAMS_INITP_18
		) _TECHMAP_REPLACE_ (
			\`PORTS_SP([13:5])
			.DIP(DIP_A),
			.DOP(DOP_A),
		);
		endcase
	end else begin
		case (PORT_A_WIDTH)
		9:	case(PORT_B_WIDTH)
			9: RAMB16_S9_S9 #(
				\`PARAMS_DP
				\`PARAMS_INITP_18
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP([13:3], [13:3])
				.DIPA(DIP_A), .DOPA(DOP_A),
				.DIPB(DIP_B), .DOPB(DOP_B),
			);
			18: RAMB16BWE_S9_S18 #(
				\`PARAMS_DP
				\`PARAMS_INITP_18
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP([13:3], [13:4])
				.DIPA(DIP_A), .DOPA(DOP_A),
				.DIPB(DIP_B), .DOPB(DOP_B),
			);
			36: RAMB16BWE_S9_S36 #(
				\`PARAMS_DP
				\`PARAMS_INITP_18
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP([13:3], [13:5])
				.DIPA(DIP_A), .DOPA(DOP_A),
				.DIPB(DIP_B), .DOPB(DOP_B),
			);
			endcase
		18:	case(PORT_B_WIDTH)
			9: RAMB16BWE_S9_S18 #(
				\`PARAMS_DP_SWAP
				\`PARAMS_INITP_18
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP_SWAP([13:4], [13:3])
				.DIPA(DIP_B), .DOPA(DOP_B),
				.DIPB(DIP_A), .DOPB(DOP_A),
			);
			18: RAMB16BWE_S18_S18 #(
				\`PARAMS_DP
				\`PARAMS_INITP_18
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP([13:4], [13:4])
				.DIPA(DIP_A), .DOPA(DOP_A),
				.DIPB(DIP_B), .DOPB(DOP_B),
			);
			36: RAMB16BWE_S18_S36 #(
				\`PARAMS_DP
				\`PARAMS_INITP_18
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP([13:4], [13:5])
				.DIPA(DIP_A), .DOPA(DOP_A),
				.DIPB(DIP_B), .DOPB(DOP_B),
			);
			endcase
		36:	case(PORT_B_WIDTH)
			9: RAMB16BWE_S9_S36 #(
				\`PARAMS_DP_SWAP
				\`PARAMS_INITP_18
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP_SWAP([13:5], [13:3])
				.DIPA(DIP_B), .DOPA(DOP_B),
				.DIPB(DIP_A), .DOPB(DOP_A),
			);
			18: RAMB16BWE_S18_S36 #(
				\`PARAMS_DP_SWAP
				\`PARAMS_INITP_18
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP_SWAP([13:5], [13:4])
				.DIPA(DIP_B), .DOPA(DOP_B),
				.DIPB(DIP_A), .DOPB(DOP_A),
			);
			36: RAMB16BWE_S36_S36 #(
				\`PARAMS_DP
				\`PARAMS_INITP_18
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP([13:5], [13:5])
				.DIPA(DIP_A), .DOPA(DOP_A),
				.DIPB(DIP_B), .DOPB(DOP_B),
			);
			endcase
		endcase
	end
end else begin
	if (!PORT_B_USED) begin
		case (PORT_A_WIDTH)
		1: RAMB16_S1 #(
			\`PARAMS_SP
		) _TECHMAP_REPLACE_ (
			\`PORTS_SP([13:0])
		);
		2: RAMB16_S2 #(
			\`PARAMS_SP
		) _TECHMAP_REPLACE_ (
			\`PORTS_SP([13:1])
		);
		4: RAMB16_S4 #(
			\`PARAMS_SP
		) _TECHMAP_REPLACE_ (
			\`PORTS_SP([13:2])
		);
		9: RAMB16_S9 #(
			\`PARAMS_SP
			\`PARAMS_INITP_18
		) _TECHMAP_REPLACE_ (
			\`PORTS_SP([13:3])
			.DIP(DIP_A),
			.DOP(DOP_A),
		);
		18: RAMB16_S18 #(
			\`PARAMS_SP
			\`PARAMS_INITP_18
		) _TECHMAP_REPLACE_ (
			\`PORTS_SP([13:4])
			.DIP(DIP_A),
			.DOP(DOP_A),
		);
		36: RAMB16_S36 #(
			\`PARAMS_SP
			\`PARAMS_INITP_18
		) _TECHMAP_REPLACE_ (
			\`PORTS_SP([13:5])
			.DIP(DIP_A),
			.DOP(DOP_A),
		);
		endcase
	end else begin
		case (PORT_A_WIDTH)
		1:	case(PORT_B_WIDTH)
			1: RAMB16_S1_S1 #(
				\`PARAMS_DP
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP([13:0], [13:0])
			);
			2: RAMB16_S1_S2 #(
				\`PARAMS_DP
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP([13:0], [13:1])
			);
			4: RAMB16_S1_S4 #(
				\`PARAMS_DP
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP([13:0], [13:2])
			);
			9: RAMB16_S1_S9 #(
				\`PARAMS_DP
				\`PARAMS_INITP_18
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP([13:0], [13:3])
				.DIPB(DIP_B), .DOPB(DOP_B),
			);
			18: RAMB16_S1_S18 #(
				\`PARAMS_DP
				\`PARAMS_INITP_18
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP([13:0], [13:4])
				.DIPB(DIP_B), .DOPB(DOP_B),
			);
			36: RAMB16_S1_S36 #(
				\`PARAMS_DP
				\`PARAMS_INITP_18
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP([13:0], [13:5])
				.DIPB(DIP_B), .DOPB(DOP_B),
			);
			endcase
		2:	case(PORT_B_WIDTH)
			1: RAMB16_S1_S2 #(
				\`PARAMS_DP_SWAP
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP_SWAP([13:1], [13:0])
			);
			2: RAMB16_S2_S2 #(
				\`PARAMS_DP
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP([13:1], [13:1])
			);
			4: RAMB16_S2_S4 #(
				\`PARAMS_DP
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP([13:1], [13:2])
			);
			9: RAMB16_S2_S9 #(
				\`PARAMS_DP
				\`PARAMS_INITP_18
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP([13:1], [13:3])
				.DIPB(DIP_B), .DOPB(DOP_B),
			);
			18: RAMB16_S2_S18 #(
				\`PARAMS_DP
				\`PARAMS_INITP_18
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP([13:1], [13:4])
				.DIPB(DIP_B), .DOPB(DOP_B),
			);
			36: RAMB16_S2_S36 #(
				\`PARAMS_DP
				\`PARAMS_INITP_18
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP([13:1], [13:5])
				.DIPB(DIP_B), .DOPB(DOP_B),
			);
			endcase
		4:	case(PORT_B_WIDTH)
			1: RAMB16_S1_S4 #(
				\`PARAMS_DP_SWAP
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP_SWAP([13:2], [13:0])
			);
			2: RAMB16_S2_S4 #(
				\`PARAMS_DP_SWAP
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP_SWAP([13:2], [13:1])
			);
			4: RAMB16_S4_S4 #(
				\`PARAMS_DP
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP([13:2], [13:2])
			);
			9: RAMB16_S4_S9 #(
				\`PARAMS_DP
				\`PARAMS_INITP_18
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP([13:2], [13:3])
				.DIPB(DIP_B), .DOPB(DOP_B),
			);
			18: RAMB16_S4_S18 #(
				\`PARAMS_DP
				\`PARAMS_INITP_18
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP([13:2], [13:4])
				.DIPB(DIP_B), .DOPB(DOP_B),
			);
			36: RAMB16_S4_S36 #(
				\`PARAMS_DP
				\`PARAMS_INITP_18
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP([13:2], [13:5])
				.DIPB(DIP_B), .DOPB(DOP_B),
			);
			endcase
		9:	case(PORT_B_WIDTH)
			1: RAMB16_S1_S9 #(
				\`PARAMS_DP_SWAP
				\`PARAMS_INITP_18
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP_SWAP([13:3], [13:0])
				.DIPB(DIP_A), .DOPB(DOP_A),
			);
			2: RAMB16_S2_S9 #(
				\`PARAMS_DP_SWAP
				\`PARAMS_INITP_18
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP_SWAP([13:3], [13:1])
				.DIPB(DIP_A), .DOPB(DOP_A),
			);
			4: RAMB16_S4_S9 #(
				\`PARAMS_DP_SWAP
				\`PARAMS_INITP_18
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP_SWAP([13:3], [13:2])
				.DIPB(DIP_A), .DOPB(DOP_A),
			);
			9: RAMB16_S9_S9 #(
				\`PARAMS_DP
				\`PARAMS_INITP_18
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP([13:3], [13:3])
				.DIPA(DIP_A), .DOPA(DOP_A),
				.DIPB(DIP_B), .DOPB(DOP_B),
			);
			18: RAMB16_S9_S18 #(
				\`PARAMS_DP
				\`PARAMS_INITP_18
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP([13:3], [13:4])
				.DIPA(DIP_A), .DOPA(DOP_A),
				.DIPB(DIP_B), .DOPB(DOP_B),
			);
			36: RAMB16_S9_S36 #(
				\`PARAMS_DP
				\`PARAMS_INITP_18
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP([13:3], [13:5])
				.DIPA(DIP_A), .DOPA(DOP_A),
				.DIPB(DIP_B), .DOPB(DOP_B),
			);
			endcase
		18:	case(PORT_B_WIDTH)
			1: RAMB16_S1_S18 #(
				\`PARAMS_DP_SWAP
				\`PARAMS_INITP_18
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP_SWAP([13:4], [13:0])
				.DIPB(DIP_A), .DOPB(DOP_A),
			);
			2: RAMB16_S2_S18 #(
				\`PARAMS_DP_SWAP
				\`PARAMS_INITP_18
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP_SWAP([13:4], [13:1])
				.DIPB(DIP_A), .DOPB(DOP_A),
			);
			4: RAMB16_S4_S18 #(
				\`PARAMS_DP_SWAP
				\`PARAMS_INITP_18
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP_SWAP([13:4], [13:2])
				.DIPB(DIP_A), .DOPB(DOP_A),
			);
			9: RAMB16_S9_S18 #(
				\`PARAMS_DP_SWAP
				\`PARAMS_INITP_18
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP_SWAP([13:4], [13:3])
				.DIPA(DIP_B), .DOPA(DOP_B),
				.DIPB(DIP_A), .DOPB(DOP_A),
			);
			18: RAMB16_S18_S18 #(
				\`PARAMS_DP
				\`PARAMS_INITP_18
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP([13:4], [13:4])
				.DIPA(DIP_A), .DOPA(DOP_A),
				.DIPB(DIP_B), .DOPB(DOP_B),
			);
			36: RAMB16_S18_S36 #(
				\`PARAMS_DP
				\`PARAMS_INITP_18
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP([13:4], [13:5])
				.DIPA(DIP_A), .DOPA(DOP_A),
				.DIPB(DIP_B), .DOPB(DOP_B),
			);
			endcase
		36:	case(PORT_B_WIDTH)
			1: RAMB16_S1_S36 #(
				\`PARAMS_DP_SWAP
				\`PARAMS_INITP_18
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP_SWAP([13:5], [13:0])
				.DIPB(DIP_A), .DOPB(DOP_A),
			);
			2: RAMB16_S2_S36 #(
				\`PARAMS_DP_SWAP
				\`PARAMS_INITP_18
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP_SWAP([13:5], [13:1])
				.DIPB(DIP_A), .DOPB(DOP_A),
			);
			4: RAMB16_S4_S36 #(
				\`PARAMS_DP_SWAP
				\`PARAMS_INITP_18
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP_SWAP([13:5], [13:2])
				.DIPB(DIP_A), .DOPB(DOP_A),
			);
			9: RAMB16_S9_S36 #(
				\`PARAMS_DP_SWAP
				\`PARAMS_INITP_18
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP_SWAP([13:5], [13:3])
				.DIPA(DIP_B), .DOPA(DOP_B),
				.DIPB(DIP_A), .DOPB(DOP_A),
			);
			18: RAMB16_S18_S36 #(
				\`PARAMS_DP_SWAP
				\`PARAMS_INITP_18
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP_SWAP([13:5], [13:4])
				.DIPA(DIP_B), .DOPA(DOP_B),
				.DIPB(DIP_A), .DOPB(DOP_A),
			);
			36: RAMB16_S36_S36 #(
				\`PARAMS_DP
				\`PARAMS_INITP_18
			) _TECHMAP_REPLACE_ (
				\`PORTS_DP([13:5], [13:5])
				.DIPA(DIP_A), .DOPA(DOP_A),
				.DIPB(DIP_B), .DOPB(DOP_B),
			);
			endcase
		endcase
	end
end

endgenerate


endmodule
`,"brams_xc3sda.txt":`# Block RAMs for Spartan 3A DSP and Spartan 6.
# The corresponding mapping file is brams_xc3sda_map.v

ram block $__XILINX_BLOCKRAM_TDP_ {
	byte 9;
	ifdef IS_SPARTAN6 {
		option "MODE" "HALF" {
			abits 13;
			widths 1 2 4 9 18 per_port;
			cost 65;
		}
	}
	option "MODE" "FULL" {
		abits 14;
		widths 1 2 4 9 18 36 per_port;
		cost 129;
	}
	init any;
	port srsw "A" "B" {
		# Spartan 6 and Virtex 6 have a bug where READ_FIRST is not usable with asynchronous clocks.
		ifdef IS_SPARTAN6 {
			option "HAS_RDFIRST" 1 {
				clock posedge "C";
			}
			option "HAS_RDFIRST" 0 {
				clock posedge;
			}
		} else {
			clock posedge;
		}
		clken;
		option "RSTTYPE" "SYNC" {
			portoption "RST_PRIORITY" "CE" {
				rdsrst any gated_clken;
			}
			ifdef IS_SPARTAN6 {
				portoption "RST_PRIORITY" "SR" {
					rdsrst any ungated;
				}
			}
		}
		ifdef IS_SPARTAN6 {
			option "RSTTYPE" "ASYNC" {
				portoption "RST_PRIORITY" "SR" {
					rdarst any;
				}
			}
		}
		rdinit any;
		portoption "WRITE_MODE" "NO_CHANGE" {
			rdwr no_change;
		}
		portoption "WRITE_MODE" "WRITE_FIRST" {
			rdwr new;
		}
		ifdef IS_SPARTAN6 {
			option "HAS_RDFIRST" 1 {
				portoption "WRITE_MODE" "READ_FIRST" {
					rdwr old;
					wrtrans all old;
				}
			}
		} else {
			portoption "WRITE_MODE" "READ_FIRST" {
				rdwr old;
				wrtrans all old;
			}
		}
		optional;
	}
}

ifdef IS_SPARTAN6 {
	ram block $__XILINX_BLOCKRAM_SDP_ {
		byte 9;
		abits 13;
		widths 1 2 4 9 18 36 per_port;
		cost 65;
		init any;
		port sw "W" {
			width 36;
			# Spartan 6 and Virtex 6 have a bug where READ_FIRST is not usable with asynchronous clocks.
			option "WRITE_MODE" "READ_FIRST" {
				clock posedge "C";
				wrtrans all old;
			}
			option "WRITE_MODE" "WRITE_FIRST" {
				clock posedge;
			}
			clken;
			optional;
		}
		port sr "R" {
			width 36;
			# Spartan 6 and Virtex 6 have a bug where READ_FIRST is not usable with asynchronous clocks.
			option "WRITE_MODE" "READ_FIRST" {
				clock posedge "C";
			}
			option "WRITE_MODE" "WRITE_FIRST" {
				clock posedge;
			}
			clken;
			option "RSTTYPE" "SYNC" {
				portoption "RST_PRIORITY" "CE" {
					rdsrst any gated_clken;
				}
				portoption "RST_PRIORITY" "SR" {
					rdsrst any ungated;
				}
			}
			option "RSTTYPE" "ASYNC" {
				portoption "RST_PRIORITY" "SR" {
					rdarst any;
				}
			}
			rdinit any;
			optional;
		}
	}
}
`,"brams_xc3sda_map.v":`module $__XILINX_BLOCKRAM_TDP_ (...);

parameter INIT = 0;
parameter OPTION_MODE = "FULL";
parameter OPTION_RSTTYPE = "SYNC";
parameter OPTION_HAS_RDFIRST = 0;

parameter PORT_A_WIDTH = 1;
parameter PORT_A_WR_EN_WIDTH = 1;
parameter PORT_A_USED = 1;
parameter PORT_A_OPTION_WRITE_MODE = "NO_CHANGE";
parameter PORT_A_RD_INIT_VALUE = 0;
parameter PORT_A_RD_SRST_VALUE = 0;
parameter PORT_A_RD_ARST_VALUE = 0;
parameter PORT_A_OPTION_RST_PRIORITY = "CE";

parameter PORT_B_WIDTH = 1;
parameter PORT_B_WR_EN_WIDTH = 1;
parameter PORT_B_USED = 0;
parameter PORT_B_OPTION_WRITE_MODE = "NO_CHANGE";
parameter PORT_B_RD_INIT_VALUE = 0;
parameter PORT_B_RD_SRST_VALUE = 0;
parameter PORT_B_RD_ARST_VALUE = 0;
parameter PORT_B_OPTION_RST_PRIORITY = "CE";

input CLK_C;

input PORT_A_CLK;
input PORT_A_CLK_EN;
input [13:0] PORT_A_ADDR;
input [PORT_A_WIDTH-1:0] PORT_A_WR_DATA;
input [PORT_A_WR_EN_WIDTH-1:0] PORT_A_WR_EN;
output [PORT_A_WIDTH-1:0] PORT_A_RD_DATA;
input PORT_A_RD_SRST;
input PORT_A_RD_ARST;

input PORT_B_CLK;
input PORT_B_CLK_EN;
input [13:0] PORT_B_ADDR;
input [PORT_B_WIDTH-1:0] PORT_B_WR_DATA;
input [PORT_B_WR_EN_WIDTH-1:0] PORT_B_WR_EN;
output [PORT_B_WIDTH-1:0] PORT_B_RD_DATA;
input PORT_B_RD_SRST;
input PORT_B_RD_ARST;

\`include "brams_defs.vh"

\`define PARAMS_COMMON \\
	.WRITE_MODE_A(PORT_A_OPTION_WRITE_MODE), \\
	.WRITE_MODE_B(PORT_B_OPTION_WRITE_MODE), \\
	.DATA_WIDTH_A(PORT_A_USED ? PORT_A_WIDTH : 0), \\
	.DATA_WIDTH_B(PORT_B_USED ? PORT_B_WIDTH : 0), \\
	.EN_RSTRAM_A("TRUE"), \\
	.EN_RSTRAM_B("TRUE"), \\
	.DOA_REG(0), \\
	.DOB_REG(0), \\
	.RST_PRIORITY_A(PORT_A_OPTION_RST_PRIORITY), \\
	.RST_PRIORITY_B(PORT_B_OPTION_RST_PRIORITY), \\
	.RSTTYPE(OPTION_RSTTYPE), \\
	.INIT_A(ival(PORT_A_WIDTH, PORT_A_RD_INIT_VALUE)), \\
	.INIT_B(ival(PORT_B_WIDTH, PORT_B_RD_INIT_VALUE)), \\
	.SRVAL_A(ival(PORT_A_WIDTH, OPTION_RSTTYPE == "SYNC" ? PORT_A_RD_SRST_VALUE : PORT_A_RD_ARST_VALUE)), \\
	.SRVAL_B(ival(PORT_B_WIDTH, OPTION_RSTTYPE == "SYNC" ? PORT_B_RD_SRST_VALUE : PORT_B_RD_ARST_VALUE)),

wire RST_A = OPTION_RSTTYPE == "SYNC" ? PORT_A_RD_SRST : PORT_A_RD_ARST;
wire RST_B = OPTION_RSTTYPE == "SYNC" ? PORT_B_RD_SRST : PORT_B_RD_ARST;

\`MAKE_DI(DI_A, DIP_A, PORT_A_WR_DATA)
\`MAKE_DI(DI_B, DIP_B, PORT_B_WR_DATA)
\`MAKE_DO(DO_A, DOP_A, PORT_A_RD_DATA)
\`MAKE_DO(DO_B, DOP_B, PORT_B_RD_DATA)

generate

if (OPTION_MODE == "FULL") begin
	wire [3:0] WE_A = {4{PORT_A_WR_EN}};
	wire [3:0] WE_B = {4{PORT_B_WR_EN}};
	RAMB16BWER #(
		\`PARAMS_INIT_18
		\`PARAMS_INITP_18
		\`PARAMS_COMMON
	) _TECHMAP_REPLACE_ (
		.DOA(DO_A),
		.DOPA(DOP_A),
		.DIA(DI_A),
		.DIPA(DIP_A),
		.DOB(DO_B),
		.DOPB(DOP_B),
		.DIB(DI_B),
		.DIPB(DIP_B),
		.ADDRA(PORT_A_ADDR),
		.ADDRB(PORT_B_ADDR),
		.CLKA(PORT_A_CLK),
		.CLKB(PORT_B_CLK),
		.ENA(PORT_A_CLK_EN),
		.ENB(PORT_B_CLK_EN),
		.REGCEA(1'b0),
		.REGCEB(1'b0),
		.RSTA(RST_A),
		.RSTB(RST_B),
		.WEA(WE_A),
		.WEB(WE_B),
	);
end else begin
	wire [1:0] WE_A = {2{PORT_A_WR_EN}};
	wire [1:0] WE_B = {2{PORT_B_WR_EN}};
	RAMB8BWER #(
		\`PARAMS_INIT_9
		\`PARAMS_INITP_9
		\`PARAMS_COMMON
		.RAM_MODE("TDP"),
	) _TECHMAP_REPLACE_ (
		.DOADO(DO_A),
		.DOPADOP(DOP_A),
		.DIADI(DI_A),
		.DIPADIP(DIP_A),
		.DOBDO(DO_B),
		.DOPBDOP(DOP_B),
		.DIBDI(DI_B),
		.DIPBDIP(DIP_B),
		.ADDRAWRADDR(PORT_A_ADDR),
		.ADDRBRDADDR(PORT_B_ADDR),
		.CLKAWRCLK(PORT_A_CLK),
		.CLKBRDCLK(PORT_B_CLK),
		.ENAWREN(PORT_A_CLK_EN),
		.ENBRDEN(PORT_B_CLK_EN),
		.REGCEA(1'b0),
		.REGCEBREGCE(1'b0),
		.RSTA(RST_A),
		.RSTBRST(RST_B),
		.WEAWEL(WE_A),
		.WEBWEU(WE_B),
	);
end

endgenerate

endmodule


module $__XILINX_BLOCKRAM_SDP_ (...);

parameter INIT = 0;
parameter OPTION_RSTTYPE = "SYNC";
parameter OPTION_WRITE_MODE = "READ_FIRST";

parameter PORT_W_WIDTH = 1;
parameter PORT_W_WR_EN_WIDTH = 1;
parameter PORT_W_USED = 1;

parameter PORT_R_WIDTH = 1;
parameter PORT_R_USED = 0;
parameter PORT_R_RD_INIT_VALUE = 0;
parameter PORT_R_RD_SRST_VALUE = 0;
parameter PORT_R_RD_ARST_VALUE = 0;
parameter PORT_R_OPTION_RST_PRIORITY = "CE";

input CLK_C;

input PORT_W_CLK;
input PORT_W_CLK_EN;
input [13:0] PORT_W_ADDR;
input [PORT_W_WIDTH-1:0] PORT_W_WR_DATA;
input [PORT_W_WR_EN_WIDTH-1:0] PORT_W_WR_EN;

input PORT_R_CLK;
input PORT_R_CLK_EN;
input [13:0] PORT_R_ADDR;
output [PORT_R_WIDTH-1:0] PORT_R_RD_DATA;
input PORT_R_RD_SRST;
input PORT_R_RD_ARST;

\`include "brams_defs.vh"

wire RST = OPTION_RSTTYPE == "SYNC" ? PORT_R_RD_SRST : PORT_R_RD_ARST;

\`MAKE_DI(DI, DIP, PORT_W_WR_DATA)
\`MAKE_DO(DO, DOP, PORT_R_RD_DATA)

localparam [35:0] RST_VALUE = OPTION_RSTTYPE == "SYNC" ? PORT_R_RD_SRST_VALUE : PORT_R_RD_ARST_VALUE;

RAMB8BWER #(
	\`PARAMS_INIT_9
	\`PARAMS_INITP_9
	.WRITE_MODE_A(OPTION_WRITE_MODE),
	.WRITE_MODE_B(OPTION_WRITE_MODE),
	.DATA_WIDTH_A(PORT_W_USED ? PORT_W_WIDTH : 0),
	.DATA_WIDTH_B(PORT_R_USED ? PORT_R_WIDTH : 0),
	.EN_RSTRAM_A("TRUE"),
	.EN_RSTRAM_B("TRUE"),
	.DOA_REG(0),
	.DOB_REG(0),
	.RST_PRIORITY_A("CE"),
	.RST_PRIORITY_B(PORT_R_OPTION_RST_PRIORITY),
	.RSTTYPE(OPTION_RSTTYPE),
	.INIT_A(ival(18, PORT_R_RD_INIT_VALUE[17:0])),
	.INIT_B(ival(18, PORT_R_RD_INIT_VALUE[35:18])),
	.SRVAL_A(ival(18, RST_VALUE[17:0])),
	.SRVAL_B(ival(18, RST_VALUE[35:18])),
	.RAM_MODE("SDP"),
) _TECHMAP_REPLACE_ (
	.DOADO(DO[15:0]),
	.DOPADOP(DOP[1:0]),
	.DIADI(DI[15:0]),
	.DIPADIP(DIP[1:0]),
	.DOBDO(DO[31:16]),
	.DOPBDOP(DOP[3:2]),
	.DIBDI(DI[31:16]),
	.DIPBDIP(DIP[3:2]),
	.ADDRAWRADDR(PORT_W_ADDR),
	.ADDRBRDADDR(PORT_R_ADDR),
	.CLKAWRCLK(PORT_W_CLK),
	.CLKBRDCLK(PORT_R_CLK),
	.ENAWREN(PORT_W_CLK_EN),
	.ENBRDEN(PORT_R_CLK_EN),
	.REGCEA(1'b0),
	.REGCEBREGCE(1'b0),
	.RSTA(1'b0),
	.RSTBRST(RST),
	.WEAWEL(PORT_W_WR_EN[1:0]),
	.WEBWEU(PORT_W_WR_EN[3:2]),
);

endmodule
`,"brams_xc4v.txt":`# Block RAMs for Virtex 4+.
# The corresponding mapping files are:
# - brams_xc3sda_map.v: Spartan 3A DSP, Spartan 6
# - brams_xc4v_map.v: Virtex 4
# - brams_xc5v_map.v: Virtex 5
# - brams_xc6v_map.v: Virtex 6, Series 7
# - brams_xcu_map.v: Ultrascale

ram block $__XILINX_BLOCKRAM_TDP_ {
	byte 9;
	ifdef HAS_SIZE_36 {
		option "MODE" "HALF" {
			abits 14;
			widths 1 2 4 9 18 per_port;
			cost 129;
		}
		option "MODE" "FULL" {
			abits 15;
			widths 1 2 4 9 18 36 per_port;
			cost 257;
		}
		ifdef HAS_CASCADE {
			option "MODE" "CASCADE" {
				abits 16;
				# hack to enforce same INIT layout as in the other modes
				widths 1 2 4 9 per_port;
				cost 513;
			}
		}
	} else {
		option "MODE" "FULL" {
			abits 14;
			widths 1 2 4 9 18 36 per_port;
			cost 129;
		}
		ifdef HAS_CASCADE {
			option "MODE" "CASCADE" {
				abits 15;
				widths 1 2 4 9 per_port;
				cost 257;
			}
		}
	}
	init any;
	port srsw "A" "B" {
		option "MODE" "HALF" {
			width mix;
		}
		option "MODE" "FULL" {
			width mix;
		}
		option "MODE" "CASCADE" {
			width mix 1;
		}
		ifdef HAS_ADDRCE {
			# TODO
			# addrce;
		}
		# Spartan 6 and Virtex 6 have a bug where READ_FIRST is not usable with asynchronous clocks.
		ifdef HAS_CONFLICT_BUG {
			option "HAS_RDFIRST" 1 {
				clock posedge "C";
			}
			option "HAS_RDFIRST" 0 {
				clock posedge;
			}
		} else {
			clock posedge;
		}
		clken;
		rdsrst any gated_clken;
		rdinit any;
		portoption "WRITE_MODE" "NO_CHANGE" {
			rdwr no_change;
			option "MODE" "CASCADE" {
				forbid;
			}
		}
		portoption "WRITE_MODE" "WRITE_FIRST" {
			ifdef HAS_SIZE_36 {
				rdwr new;
			} else {
				rdwr new_only;
			}
		}
		ifdef HAS_CONFLICT_BUG {
			option "HAS_RDFIRST" 1 {
				portoption "WRITE_MODE" "READ_FIRST" {
					rdwr old;
					wrtrans all old;
				}
			}
		} else {
			portoption "WRITE_MODE" "READ_FIRST" {
				rdwr old;
				wrtrans all old;
			}
		}
		optional_rw;
	}
}

ifdef HAS_SIZE_36 {
	ram block $__XILINX_BLOCKRAM_SDP_ {
		byte 9;
		option "MODE" "HALF" {
			abits 14;
			widths 1 2 4 9 18 36 per_port;
			cost 129;
		}
		option "MODE" "FULL" {
			abits 15;
			widths 1 2 4 9 18 36 72 per_port;
			cost 257;
		}
		init any;
		port sw "W" {
			ifndef HAS_MIXWIDTH_SDP {
				option "MODE" "HALF" width 36;
				option "MODE" "FULL" width 72;
			}
			ifdef HAS_ADDRCE {
				# TODO
				# addrce;
			}
			# Spartan 6 and Virtex 6 have a bug where READ_FIRST is not usable with asynchronous clocks.
			ifdef HAS_CONFLICT_BUG {
				option "WRITE_MODE" "READ_FIRST" {
					clock posedge "C";
				}
				option "WRITE_MODE" "WRITE_FIRST" {
					clock posedge;
				}
			} else {
				clock posedge;
			}
			clken;
			option "WRITE_MODE" "READ_FIRST" {
				wrtrans all old;
			}
			optional;
		}
		port sr "R" {
			ifndef HAS_MIXWIDTH_SDP {
				option "MODE" "HALF" width 36;
				option "MODE" "FULL" width 72;
			}
			ifdef HAS_ADDRCE {
				# TODO
				# addrce;
			}
			# Spartan 6 and Virtex 6 have a bug where READ_FIRST is not usable with asynchronous clocks.
			ifdef HAS_CONFLICT_BUG {
				option "WRITE_MODE" "READ_FIRST" {
					clock posedge "C";
				}
				option "WRITE_MODE" "WRITE_FIRST" {
					clock posedge;
				}
			} else {
				clock posedge;
			}
			clken;
			rdsrst any gated_clken;
			rdinit any;
			optional;
		}
	}
}
`,"brams_xc4v_map.v":`module $__XILINX_BLOCKRAM_TDP_ (...);

parameter INIT = 0;
parameter OPTION_MODE = "FULL";

parameter PORT_A_RD_WIDTH = 1;
parameter PORT_A_WR_WIDTH = 1;
parameter PORT_A_WR_EN_WIDTH = 1;
parameter PORT_A_RD_USED = 1;
parameter PORT_A_WR_USED = 1;
parameter PORT_A_OPTION_WRITE_MODE = "NO_CHANGE";
parameter PORT_A_RD_INIT_VALUE = 0;
parameter PORT_A_RD_SRST_VALUE = 0;

parameter PORT_B_RD_WIDTH = 1;
parameter PORT_B_WR_WIDTH = 1;
parameter PORT_B_WR_EN_WIDTH = 1;
parameter PORT_B_RD_USED = 0;
parameter PORT_B_WR_USED = 0;
parameter PORT_B_OPTION_WRITE_MODE = "NO_CHANGE";
parameter PORT_B_RD_INIT_VALUE = 0;
parameter PORT_B_RD_SRST_VALUE = 0;

input PORT_A_CLK;
input PORT_A_CLK_EN;
input [14:0] PORT_A_ADDR;
input [PORT_A_WR_WIDTH-1:0] PORT_A_WR_DATA;
input [PORT_A_WR_EN_WIDTH-1:0] PORT_A_WR_EN;
output [PORT_A_RD_WIDTH-1:0] PORT_A_RD_DATA;
input PORT_A_RD_SRST;

input PORT_B_CLK;
input PORT_B_CLK_EN;
input [14:0] PORT_B_ADDR;
input [PORT_B_WR_WIDTH-1:0] PORT_B_WR_DATA;
input [PORT_B_WR_EN_WIDTH-1:0] PORT_B_WR_EN;
output [PORT_B_RD_WIDTH-1:0] PORT_B_RD_DATA;
input PORT_B_RD_SRST;

\`include "brams_defs.vh"

\`define PARAMS_COMMON \\
	.WRITE_MODE_A(PORT_A_OPTION_WRITE_MODE), \\
	.WRITE_MODE_B(PORT_B_OPTION_WRITE_MODE), \\
	.READ_WIDTH_A(PORT_A_RD_USED ? PORT_A_RD_WIDTH : 0), \\
	.READ_WIDTH_B(PORT_B_RD_USED ? PORT_B_RD_WIDTH : 0), \\
	.WRITE_WIDTH_A(PORT_A_WR_USED ? PORT_A_WR_WIDTH : 0), \\
	.WRITE_WIDTH_B(PORT_B_WR_USED ? PORT_B_WR_WIDTH : 0), \\
	.DOA_REG(0), \\
	.DOB_REG(0), \\
	.INIT_A(ival(PORT_A_RD_WIDTH, PORT_A_RD_INIT_VALUE)), \\
	.INIT_B(ival(PORT_B_RD_WIDTH, PORT_B_RD_INIT_VALUE)), \\
	.SRVAL_A(ival(PORT_A_RD_WIDTH, PORT_A_RD_SRST_VALUE)), \\
	.SRVAL_B(ival(PORT_B_RD_WIDTH, PORT_B_RD_SRST_VALUE)),

\`MAKE_DI(DI_A, DIP_A, PORT_A_WR_DATA)
\`MAKE_DI(DI_B, DIP_B, PORT_B_WR_DATA)
\`MAKE_DO(DO_A, DOP_A, PORT_A_RD_DATA)
\`MAKE_DO(DO_B, DOP_B, PORT_B_RD_DATA)

wire [3:0] WE_A = {4{PORT_A_WR_EN}};
wire [3:0] WE_B = {4{PORT_B_WR_EN}};

generate

if (OPTION_MODE == "FULL") begin
	RAMB16 #(
		\`PARAMS_INIT_18
		\`PARAMS_INITP_18
		\`PARAMS_COMMON
		.RAM_EXTENSION_A("NONE"),
		.RAM_EXTENSION_B("NONE"),
	) _TECHMAP_REPLACE_ (
		.DOA(DO_A),
		.DOPA(DOP_A),
		.DIA(DI_A),
		.DIPA(DIP_A),
		.DOB(DO_B),
		.DOPB(DOP_B),
		.DIB(DI_B),
		.DIPB(DIP_B),
		.ADDRA({1'b1, PORT_A_ADDR[13:0]}),
		.ADDRB({1'b1, PORT_B_ADDR[13:0]}),
		.CLKA(PORT_A_CLK),
		.CLKB(PORT_B_CLK),
		.ENA(PORT_A_CLK_EN),
		.ENB(PORT_B_CLK_EN),
		.REGCEA(1'b0),
		.REGCEB(1'b0),
		.SSRA(PORT_A_RD_SRST),
		.SSRB(PORT_B_RD_SRST),
		.WEA(WE_A),
		.WEB(WE_B),
	);
end else begin
	wire CAS_A, CAS_B;
	RAMB16 #(
		\`PARAMS_INIT_18
		\`PARAMS_COMMON
		.RAM_EXTENSION_A("LOWER"),
		.RAM_EXTENSION_B("LOWER"),
	) lower (
		.DIA(DI_A),
		.DIB(DI_B),
		.ADDRA(PORT_A_ADDR),
		.ADDRB(PORT_B_ADDR),
		.CLKA(PORT_A_CLK),
		.CLKB(PORT_B_CLK),
		.ENA(PORT_A_CLK_EN),
		.ENB(PORT_B_CLK_EN),
		.REGCEA(1'b0),
		.REGCEB(1'b0),
		.SSRA(PORT_A_RD_SRST),
		.SSRB(PORT_B_RD_SRST),
		.WEA(WE_A),
		.WEB(WE_B),
		.CASCADEOUTA(CAS_A),
		.CASCADEOUTB(CAS_B),
	);
	RAMB16 #(
		\`PARAMS_INIT_18_U
		\`PARAMS_COMMON
		.RAM_EXTENSION_A("UPPER"),
		.RAM_EXTENSION_B("UPPER"),
	) upper (
		.DOA(DO_A),
		.DIA(DI_A),
		.DOB(DO_B),
		.DIB(DI_B),
		.ADDRA(PORT_A_ADDR),
		.ADDRB(PORT_B_ADDR),
		.CLKA(PORT_A_CLK),
		.CLKB(PORT_B_CLK),
		.ENA(PORT_A_CLK_EN),
		.ENB(PORT_B_CLK_EN),
		.REGCEA(1'b0),
		.REGCEB(1'b0),
		.SSRA(PORT_A_RD_SRST),
		.SSRB(PORT_B_RD_SRST),
		.WEA(WE_A),
		.WEB(WE_B),
		.CASCADEINA(CAS_A),
		.CASCADEINB(CAS_B),
	);
end

endgenerate

endmodule
`,"brams_xc5v_map.v":`module $__XILINX_BLOCKRAM_TDP_ (...);

parameter INIT = 0;
parameter OPTION_MODE = "FULL";

parameter PORT_A_RD_WIDTH = 1;
parameter PORT_A_WR_WIDTH = 1;
parameter PORT_A_WR_EN_WIDTH = 1;
parameter PORT_A_RD_USED = 1;
parameter PORT_A_WR_USED = 1;
parameter PORT_A_OPTION_WRITE_MODE = "NO_CHANGE";
parameter PORT_A_RD_INIT_VALUE = 0;
parameter PORT_A_RD_SRST_VALUE = 0;

parameter PORT_B_RD_WIDTH = 1;
parameter PORT_B_WR_WIDTH = 1;
parameter PORT_B_WR_EN_WIDTH = 1;
parameter PORT_B_RD_USED = 0;
parameter PORT_B_WR_USED = 0;
parameter PORT_B_OPTION_WRITE_MODE = "NO_CHANGE";
parameter PORT_B_RD_INIT_VALUE = 0;
parameter PORT_B_RD_SRST_VALUE = 0;

input PORT_A_CLK;
input PORT_A_CLK_EN;
input [15:0] PORT_A_ADDR;
input [PORT_A_WR_WIDTH-1:0] PORT_A_WR_DATA;
input [PORT_A_WR_EN_WIDTH-1:0] PORT_A_WR_EN;
output [PORT_A_RD_WIDTH-1:0] PORT_A_RD_DATA;
input PORT_A_RD_SRST;

input PORT_B_CLK;
input PORT_B_CLK_EN;
input [15:0] PORT_B_ADDR;
input [PORT_B_WR_WIDTH-1:0] PORT_B_WR_DATA;
input [PORT_B_WR_EN_WIDTH-1:0] PORT_B_WR_EN;
output [PORT_B_RD_WIDTH-1:0] PORT_B_RD_DATA;
input PORT_B_RD_SRST;

\`include "brams_defs.vh"

\`define PARAMS_COMMON \\
	.WRITE_MODE_A(PORT_A_OPTION_WRITE_MODE), \\
	.WRITE_MODE_B(PORT_B_OPTION_WRITE_MODE), \\
	.READ_WIDTH_A(PORT_A_RD_USED ? PORT_A_RD_WIDTH : 0), \\
	.READ_WIDTH_B(PORT_B_RD_USED ? PORT_B_RD_WIDTH : 0), \\
	.WRITE_WIDTH_A(PORT_A_WR_USED ? PORT_A_WR_WIDTH : 0), \\
	.WRITE_WIDTH_B(PORT_B_WR_USED ? PORT_B_WR_WIDTH : 0), \\
	.DOA_REG(0), \\
	.DOB_REG(0), \\
	.INIT_A(ival(PORT_A_RD_WIDTH, PORT_A_RD_INIT_VALUE)), \\
	.INIT_B(ival(PORT_B_RD_WIDTH, PORT_B_RD_INIT_VALUE)), \\
	.SRVAL_A(ival(PORT_A_RD_WIDTH, PORT_A_RD_SRST_VALUE)), \\
	.SRVAL_B(ival(PORT_B_RD_WIDTH, PORT_B_RD_SRST_VALUE)),

\`MAKE_DI(DI_A, DIP_A, PORT_A_WR_DATA)
\`MAKE_DI(DI_B, DIP_B, PORT_B_WR_DATA)
\`MAKE_DO(DO_A, DOP_A, PORT_A_RD_DATA)
\`MAKE_DO(DO_B, DOP_B, PORT_B_RD_DATA)

wire [3:0] WE_A = {4{PORT_A_WR_EN}};
wire [3:0] WE_B = {4{PORT_B_WR_EN}};

generate

if (OPTION_MODE == "HALF") begin
	RAMB18 #(
		\`PARAMS_INIT_18
		\`PARAMS_INITP_18
		\`PARAMS_COMMON
	) _TECHMAP_REPLACE_ (
		.DOA(DO_A),
		.DOPA(DOP_A),
		.DIA(DI_A),
		.DIPA(DIP_A),
		.DOB(DO_B),
		.DOPB(DOP_B),
		.DIB(DI_B),
		.DIPB(DIP_B),
		.ADDRA(PORT_A_ADDR[13:0]),
		.ADDRB(PORT_B_ADDR[13:0]),
		.CLKA(PORT_A_CLK),
		.CLKB(PORT_B_CLK),
		.ENA(PORT_A_CLK_EN),
		.ENB(PORT_B_CLK_EN),
		.REGCEA(1'b0),
		.REGCEB(1'b0),
		.SSRA(PORT_A_RD_SRST),
		.SSRB(PORT_B_RD_SRST),
		.WEA(WE_A),
		.WEB(WE_B),
	);
end else if (OPTION_MODE == "FULL") begin
	RAMB36 #(
		\`PARAMS_INIT_36
		\`PARAMS_INITP_36
		\`PARAMS_COMMON
		.RAM_EXTENSION_A("NONE"),
		.RAM_EXTENSION_B("NONE"),
	) _TECHMAP_REPLACE_ (
		.DOA(DO_A),
		.DOPA(DOP_A),
		.DIA(DI_A),
		.DIPA(DIP_A),
		.DOB(DO_B),
		.DOPB(DOP_B),
		.DIB(DI_B),
		.DIPB(DIP_B),
		.ADDRA({1'b1, PORT_A_ADDR[14:0]}),
		.ADDRB({1'b1, PORT_B_ADDR[14:0]}),
		.CLKA(PORT_A_CLK),
		.CLKB(PORT_B_CLK),
		.ENA(PORT_A_CLK_EN),
		.ENB(PORT_B_CLK_EN),
		.REGCEA(1'b0),
		.REGCEB(1'b0),
		.SSRA(PORT_A_RD_SRST),
		.SSRB(PORT_B_RD_SRST),
		.WEA(WE_A),
		.WEB(WE_B),
	);
end else begin
	wire CAS_A, CAS_B;
	RAMB36 #(
		\`PARAMS_INIT_36
		\`PARAMS_COMMON
		.RAM_EXTENSION_A("LOWER"),
		.RAM_EXTENSION_B("LOWER"),
	) lower (
		.DIA(DI_A),
		.DIB(DI_B),
		.ADDRA(PORT_A_ADDR),
		.ADDRB(PORT_B_ADDR),
		.CLKA(PORT_A_CLK),
		.CLKB(PORT_B_CLK),
		.ENA(PORT_A_CLK_EN),
		.ENB(PORT_B_CLK_EN),
		.REGCEA(1'b0),
		.REGCEB(1'b0),
		.SSRA(PORT_A_RD_SRST),
		.SSRB(PORT_B_RD_SRST),
		.WEA(WE_A),
		.WEB(WE_B),
		.CASCADEOUTLATA(CAS_A),
		.CASCADEOUTLATB(CAS_B),
	);
	RAMB36 #(
		\`PARAMS_INIT_36_U
		\`PARAMS_COMMON
		.RAM_EXTENSION_A("UPPER"),
		.RAM_EXTENSION_B("UPPER"),
	) upper (
		.DOA(DO_A),
		.DIA(DI_A),
		.DOB(DO_B),
		.DIB(DI_B),
		.ADDRA(PORT_A_ADDR),
		.ADDRB(PORT_B_ADDR),
		.CLKA(PORT_A_CLK),
		.CLKB(PORT_B_CLK),
		.ENA(PORT_A_CLK_EN),
		.ENB(PORT_B_CLK_EN),
		.REGCEA(1'b0),
		.REGCEB(1'b0),
		.SSRA(PORT_A_RD_SRST),
		.SSRB(PORT_B_RD_SRST),
		.WEA(WE_A),
		.WEB(WE_B),
		.CASCADEINLATA(CAS_A),
		.CASCADEINLATB(CAS_B),
	);
end

endgenerate

endmodule


module $__XILINX_BLOCKRAM_SDP_ (...);

parameter INIT = 0;
parameter OPTION_MODE = "FULL";
parameter OPTION_WRITE_MODE = "READ_FIRST";

parameter PORT_W_WIDTH = 1;
parameter PORT_W_WR_EN_WIDTH = 1;
parameter PORT_W_USED = 1;

parameter PORT_R_WIDTH = 1;
parameter PORT_R_USED = 0;
parameter PORT_R_RD_INIT_VALUE = 0;
parameter PORT_R_RD_SRST_VALUE = 0;

input PORT_W_CLK;
input PORT_W_CLK_EN;
input [15:0] PORT_W_ADDR;
input [PORT_W_WIDTH-1:0] PORT_W_WR_DATA;
input [PORT_W_WR_EN_WIDTH-1:0] PORT_W_WR_EN;

input PORT_R_CLK;
input PORT_R_CLK_EN;
input [15:0] PORT_R_ADDR;
output [PORT_R_WIDTH-1:0] PORT_R_RD_DATA;
input PORT_R_RD_SRST;

\`include "brams_defs.vh"

\`define PARAMS_COMMON \\
	.DO_REG(0), \\
	.INIT(ival(PORT_R_WIDTH, PORT_R_RD_INIT_VALUE)), \\
	.SRVAL(ival(PORT_R_WIDTH, PORT_R_RD_SRST_VALUE)),

\`define PORTS_COMMON \\
	.DO(DO), \\
	.DOP(DOP), \\
	.DI(DI), \\
	.DIP(DIP), \\
	.WRCLK(PORT_W_CLK), \\
	.RDCLK(PORT_R_CLK), \\
	.WREN(PORT_W_CLK_EN), \\
	.RDEN(PORT_R_CLK_EN), \\
	.REGCE(1'b0), \\
	.SSR(PORT_R_RD_SRST), \\
	.WE(PORT_W_WR_EN),

\`MAKE_DI(DI, DIP, PORT_W_WR_DATA)
\`MAKE_DO(DO, DOP, PORT_R_RD_DATA)

generate

if (OPTION_MODE == "HALF") begin
	RAMB18SDP #(
		\`PARAMS_INIT_18
		\`PARAMS_INITP_18
		\`PARAMS_COMMON
	) _TECHMAP_REPLACE_ (
		\`PORTS_COMMON
		.WRADDR(PORT_W_ADDR[13:5]),
		.RDADDR(PORT_R_ADDR[13:5]),
	);
end else if (OPTION_MODE == "FULL") begin
	RAMB36SDP #(
		\`PARAMS_INIT_36
		\`PARAMS_INITP_36
		\`PARAMS_COMMON
	) _TECHMAP_REPLACE_ (
		\`PORTS_COMMON
		.WRADDR(PORT_W_ADDR[14:6]),
		.RDADDR(PORT_R_ADDR[14:6]),
	);
end

endgenerate

endmodule
`,"brams_xc6v_map.v":`module $__XILINX_BLOCKRAM_TDP_ (...);

parameter INIT = 0;
parameter OPTION_MODE = "FULL";
parameter OPTION_HAS_RDFIRST = 0;

parameter PORT_A_RD_WIDTH = 1;
parameter PORT_A_WR_WIDTH = 1;
parameter PORT_A_WR_EN_WIDTH = 1;
parameter PORT_A_RD_USED = 1;
parameter PORT_A_WR_USED = 1;
parameter PORT_A_OPTION_WRITE_MODE = "NO_CHANGE";
parameter PORT_A_RD_INIT_VALUE = 0;
parameter PORT_A_RD_SRST_VALUE = 1;

parameter PORT_B_RD_WIDTH = 1;
parameter PORT_B_WR_WIDTH = 1;
parameter PORT_B_WR_EN_WIDTH = 1;
parameter PORT_B_RD_USED = 0;
parameter PORT_B_WR_USED = 0;
parameter PORT_B_OPTION_WRITE_MODE = "NO_CHANGE";
parameter PORT_B_RD_INIT_VALUE = 0;
parameter PORT_B_RD_SRST_VALUE = 0;

input CLK_C;

input PORT_A_CLK;
input PORT_A_CLK_EN;
input [15:0] PORT_A_ADDR;
input [PORT_A_WR_WIDTH-1:0] PORT_A_WR_DATA;
input [PORT_A_WR_EN_WIDTH-1:0] PORT_A_WR_EN;
output [PORT_A_RD_WIDTH-1:0] PORT_A_RD_DATA;
input PORT_A_RD_SRST;

input PORT_B_CLK;
input PORT_B_CLK_EN;
input [15:0] PORT_B_ADDR;
input [PORT_B_WR_WIDTH-1:0] PORT_B_WR_DATA;
input [PORT_B_WR_EN_WIDTH-1:0] PORT_B_WR_EN;
output [PORT_B_RD_WIDTH-1:0] PORT_B_RD_DATA;
input PORT_B_RD_SRST;

\`include "brams_defs.vh"

\`define PARAMS_COMMON \\
	.WRITE_MODE_A(PORT_A_OPTION_WRITE_MODE), \\
	.WRITE_MODE_B(PORT_B_OPTION_WRITE_MODE), \\
	.READ_WIDTH_A(PORT_A_RD_USED ? PORT_A_RD_WIDTH : 0), \\
	.READ_WIDTH_B(PORT_B_RD_USED ? PORT_B_RD_WIDTH : 0), \\
	.WRITE_WIDTH_A(PORT_A_WR_USED ? PORT_A_WR_WIDTH : 0), \\
	.WRITE_WIDTH_B(PORT_B_WR_USED ? PORT_B_WR_WIDTH : 0), \\
	.DOA_REG(0), \\
	.DOB_REG(0), \\
	.INIT_A(ival(PORT_A_RD_WIDTH, PORT_A_RD_INIT_VALUE)), \\
	.INIT_B(ival(PORT_B_RD_WIDTH, PORT_B_RD_INIT_VALUE)), \\
	.SRVAL_A(ival(PORT_A_RD_WIDTH, PORT_A_RD_SRST_VALUE)), \\
	.SRVAL_B(ival(PORT_B_RD_WIDTH, PORT_B_RD_SRST_VALUE)), \\
	.RAM_MODE("TDP"),

\`define PORTS_COMMON \\
	.DOADO(DO_A), \\
	.DOPADOP(DOP_A), \\
	.DIADI(DI_A), \\
	.DIPADIP(DIP_A), \\
	.DOBDO(DO_B), \\
	.DOPBDOP(DOP_B), \\
	.DIBDI(DI_B), \\
	.DIPBDIP(DIP_B), \\
	.CLKARDCLK(PORT_A_CLK), \\
	.CLKBWRCLK(PORT_B_CLK), \\
	.ENARDEN(PORT_A_CLK_EN), \\
	.ENBWREN(PORT_B_CLK_EN), \\
	.REGCEAREGCE(1'b0), \\
	.REGCEB(1'b0), \\
	.RSTRAMARSTRAM(PORT_A_RD_SRST), \\
	.RSTRAMB(PORT_B_RD_SRST), \\
	.RSTREGARSTREG(1'b0), \\
	.RSTREGB(1'b0), \\
	.WEA(WE_A), \\
	.WEBWE(WE_B),

\`MAKE_DI(DI_A, DIP_A, PORT_A_WR_DATA)
\`MAKE_DI(DI_B, DIP_B, PORT_B_WR_DATA)
\`MAKE_DO(DO_A, DOP_A, PORT_A_RD_DATA)
\`MAKE_DO(DO_B, DOP_B, PORT_B_RD_DATA)

wire [3:0] WE_A = {4{PORT_A_WR_EN}};
wire [3:0] WE_B = {4{PORT_B_WR_EN}};

generate

if (OPTION_MODE == "HALF") begin
	RAMB18E1 #(
		\`PARAMS_INIT_18
		\`PARAMS_INITP_18
		\`PARAMS_COMMON
	) _TECHMAP_REPLACE_ (
		\`PORTS_COMMON
		.ADDRARDADDR(PORT_A_ADDR[13:0]),
		.ADDRBWRADDR(PORT_B_ADDR[13:0]),
	);
end else if (OPTION_MODE == "FULL") begin
	RAMB36E1 #(
		\`PARAMS_INIT_36
		\`PARAMS_INITP_36
		\`PARAMS_COMMON
		.RAM_EXTENSION_A("NONE"),
		.RAM_EXTENSION_B("NONE"),
	) _TECHMAP_REPLACE_ (
		\`PORTS_COMMON
		.ADDRARDADDR({1'b1, PORT_A_ADDR[14:0]}),
		.ADDRBWRADDR({1'b1, PORT_B_ADDR[14:0]}),
	);
end else begin
	wire CAS_A, CAS_B;
	RAMB36E1 #(
		\`PARAMS_INIT_36
		\`PARAMS_COMMON
		.RAM_EXTENSION_A("LOWER"),
		.RAM_EXTENSION_B("LOWER"),
	) lower (
		.DIADI(DI_A),
		.DIBDI(DI_B),
		.CLKARDCLK(PORT_A_CLK),
		.CLKBWRCLK(PORT_B_CLK),
		.ENARDEN(PORT_A_CLK_EN),
		.ENBWREN(PORT_B_CLK_EN),
		.REGCEAREGCE(1'b0),
		.REGCEB(1'b0),
		.RSTRAMARSTRAM(PORT_A_RD_SRST),
		.RSTRAMB(PORT_B_RD_SRST),
		.RSTREGARSTREG(1'b0),
		.RSTREGB(1'b0),
		.WEA(WE_A),
		.WEBWE(WE_B),
		.ADDRARDADDR(PORT_A_ADDR),
		.ADDRBWRADDR(PORT_B_ADDR),
		.CASCADEOUTA(CAS_A),
		.CASCADEOUTB(CAS_B),
	);
	RAMB36E1 #(
		\`PARAMS_INIT_36_U
		\`PARAMS_COMMON
		.RAM_EXTENSION_A("UPPER"),
		.RAM_EXTENSION_B("UPPER"),
	) upper (
		.DOADO(DO_A),
		.DIADI(DI_A),
		.DOBDO(DO_B),
		.DIBDI(DI_B),
		.CLKARDCLK(PORT_A_CLK),
		.CLKBWRCLK(PORT_B_CLK),
		.ENARDEN(PORT_A_CLK_EN),
		.ENBWREN(PORT_B_CLK_EN),
		.REGCEAREGCE(1'b0),
		.REGCEB(1'b0),
		.RSTRAMARSTRAM(PORT_A_RD_SRST),
		.RSTRAMB(PORT_B_RD_SRST),
		.RSTREGARSTREG(1'b0),
		.RSTREGB(1'b0),
		.WEA(WE_A),
		.WEBWE(WE_B),
		.ADDRARDADDR(PORT_A_ADDR),
		.ADDRBWRADDR(PORT_B_ADDR),
		.CASCADEINA(CAS_A),
		.CASCADEINB(CAS_B),
	);
end

endgenerate

endmodule


module $__XILINX_BLOCKRAM_SDP_ (...);

parameter INIT = 0;
parameter OPTION_MODE = "FULL";
parameter OPTION_WRITE_MODE = "READ_FIRST";

parameter PORT_W_WIDTH = 1;
parameter PORT_W_WR_EN_WIDTH = 1;
parameter PORT_W_USED = 1;

parameter PORT_R_WIDTH = 1;
parameter PORT_R_USED = 0;
parameter PORT_R_RD_INIT_VALUE = 0;
parameter PORT_R_RD_SRST_VALUE = 0;

input CLK_C;

input PORT_W_CLK;
input PORT_W_CLK_EN;
input [15:0] PORT_W_ADDR;
input [PORT_W_WIDTH-1:0] PORT_W_WR_DATA;
input [PORT_W_WR_EN_WIDTH-1:0] PORT_W_WR_EN;

input PORT_R_CLK;
input PORT_R_CLK_EN;
input [15:0] PORT_R_ADDR;
output [PORT_R_WIDTH-1:0] PORT_R_RD_DATA;
input PORT_R_RD_SRST;

\`include "brams_defs.vh"

\`define PARAMS_COMMON \\
	.WRITE_MODE_A(OPTION_WRITE_MODE), \\
	.WRITE_MODE_B(OPTION_WRITE_MODE), \\
	.READ_WIDTH_A(PORT_R_USED ? PORT_R_WIDTH : 0), \\
	.READ_WIDTH_B(0), \\
	.WRITE_WIDTH_A(0), \\
	.WRITE_WIDTH_B(PORT_W_USED ? PORT_W_WIDTH : 0), \\
	.DOA_REG(0), \\
	.DOB_REG(0), \\
	.RAM_MODE("SDP"),

\`define PORTS_COMMON \\
	.CLKBWRCLK(PORT_W_CLK), \\
	.CLKARDCLK(PORT_R_CLK), \\
	.ENBWREN(PORT_W_CLK_EN), \\
	.ENARDEN(PORT_R_CLK_EN), \\
	.REGCEAREGCE(1'b0), \\
	.REGCEB(1'b0), \\
	.RSTRAMARSTRAM(PORT_R_RD_SRST), \\
	.RSTRAMB(1'b0), \\
	.RSTREGARSTREG(1'b0), \\
	.RSTREGB(1'b0), \\
	.WEA(0), \\
	.WEBWE(PORT_W_WR_EN),

\`MAKE_DI(DI, DIP, PORT_W_WR_DATA)
\`MAKE_DO(DO, DOP, PORT_R_RD_DATA)

generate

if (OPTION_MODE == "HALF") begin
	RAMB18E1 #(
		\`PARAMS_INIT_18
		\`PARAMS_INITP_18
		\`PARAMS_COMMON
		.INIT_A(PORT_R_WIDTH == 36 ? ival(18, PORT_R_RD_INIT_VALUE[17:0]) : ival(PORT_R_WIDTH, PORT_R_RD_INIT_VALUE)),
		.INIT_B(PORT_R_WIDTH == 36 ? ival(18, PORT_R_RD_INIT_VALUE[35:18]) : 0),
		.SRVAL_A(PORT_R_WIDTH == 36 ? ival(18, PORT_R_RD_SRST_VALUE[17:0]) : ival(PORT_R_WIDTH, PORT_R_RD_SRST_VALUE)),
		.SRVAL_B(PORT_R_WIDTH == 36 ? ival(18, PORT_R_RD_SRST_VALUE[35:18]) : 0),
	) _TECHMAP_REPLACE_ (
		\`PORTS_COMMON
		.ADDRARDADDR(PORT_R_ADDR[13:0]),
		.ADDRBWRADDR(PORT_W_ADDR[13:0]),
		.DOADO(DO[15:0]),
		.DOBDO(DO[31:16]),
		.DOPADOP(DOP[1:0]),
		.DOPBDOP(DOP[3:2]),
		.DIADI(DI[15:0]),
		.DIBDI(PORT_W_WIDTH == 36 ? DI[31:16] : DI[15:0]),
		.DIPADIP(DIP[1:0]),
		.DIPBDIP(PORT_W_WIDTH == 36 ? DIP[3:2] : DIP[1:0]),
	);
end else if (OPTION_MODE == "FULL") begin
	RAMB36E1 #(
		\`PARAMS_INIT_36
		\`PARAMS_INITP_36
		\`PARAMS_COMMON
		.INIT_A(PORT_R_WIDTH == 72 ? ival(36, PORT_R_RD_INIT_VALUE[35:0]) : ival(PORT_R_WIDTH, PORT_R_RD_INIT_VALUE)),
		.INIT_B(PORT_R_WIDTH == 72 ? ival(36, PORT_R_RD_INIT_VALUE[71:36]) : 0),
		.SRVAL_A(PORT_R_WIDTH == 72 ? ival(36, PORT_R_RD_SRST_VALUE[35:0]) : ival(PORT_R_WIDTH, PORT_R_RD_SRST_VALUE)),
		.SRVAL_B(PORT_R_WIDTH == 72 ? ival(36, PORT_R_RD_SRST_VALUE[71:36]) : 0),
	) _TECHMAP_REPLACE_ (
		\`PORTS_COMMON
		.ADDRARDADDR({1'b1, PORT_R_ADDR}),
		.ADDRBWRADDR({1'b1, PORT_W_ADDR}),
		.DOADO(DO[31:0]),
		.DOBDO(DO[63:32]),
		.DOPADOP(DOP[3:0]),
		.DOPBDOP(DOP[7:4]),
		.DIADI(DI[31:0]),
		.DIBDI(PORT_W_WIDTH == 72 ? DI[63:32] : DI[31:0]),
		.DIPADIP(DIP[3:0]),
		.DIPBDIP(PORT_W_WIDTH == 71 ? DIP[7:4] : DIP[3:0]),
	);
end

endgenerate

endmodule
`,"brams_xcu_map.v":`module $__XILINX_BLOCKRAM_TDP_ (...);

parameter INIT = 0;
parameter OPTION_MODE = "FULL";
parameter OPTION_HAS_RDFIRST = 0;

parameter PORT_A_RD_WIDTH = 1;
parameter PORT_A_WR_WIDTH = 1;
parameter PORT_A_WR_EN_WIDTH = 1;
parameter PORT_A_RD_USED = 1;
parameter PORT_A_WR_USED = 1;
parameter PORT_A_OPTION_WRITE_MODE = "NO_CHANGE";
parameter PORT_A_RD_INIT_VALUE = 0;
parameter PORT_A_RD_SRST_VALUE = 1;

parameter PORT_B_RD_WIDTH = 1;
parameter PORT_B_WR_WIDTH = 1;
parameter PORT_B_WR_EN_WIDTH = 1;
parameter PORT_B_RD_USED = 0;
parameter PORT_B_WR_USED = 0;
parameter PORT_B_OPTION_WRITE_MODE = "NO_CHANGE";
parameter PORT_B_RD_INIT_VALUE = 0;
parameter PORT_B_RD_SRST_VALUE = 0;

input PORT_A_CLK;
input PORT_A_CLK_EN;
input [15:0] PORT_A_ADDR;
input [PORT_A_WR_WIDTH-1:0] PORT_A_WR_DATA;
input [PORT_A_WR_EN_WIDTH-1:0] PORT_A_WR_EN;
output [PORT_A_RD_WIDTH-1:0] PORT_A_RD_DATA;
input PORT_A_RD_SRST;

input PORT_B_CLK;
input PORT_B_CLK_EN;
input [15:0] PORT_B_ADDR;
input [PORT_B_WR_WIDTH-1:0] PORT_B_WR_DATA;
input [PORT_B_WR_EN_WIDTH-1:0] PORT_B_WR_EN;
output [PORT_B_RD_WIDTH-1:0] PORT_B_RD_DATA;
input PORT_B_RD_SRST;

\`include "brams_defs.vh"

\`define PARAMS_COMMON \\
	.WRITE_MODE_A(PORT_A_OPTION_WRITE_MODE), \\
	.WRITE_MODE_B(PORT_B_OPTION_WRITE_MODE), \\
	.READ_WIDTH_A(PORT_A_RD_USED ? PORT_A_RD_WIDTH : 0), \\
	.READ_WIDTH_B(PORT_B_RD_USED ? PORT_B_RD_WIDTH : 0), \\
	.WRITE_WIDTH_A(PORT_A_WR_USED ? PORT_A_WR_WIDTH : 0), \\
	.WRITE_WIDTH_B(PORT_B_WR_USED ? PORT_B_WR_WIDTH : 0), \\
	.DOA_REG(0), \\
	.DOB_REG(0), \\
	.INIT_A(ival(PORT_A_RD_WIDTH, PORT_A_RD_INIT_VALUE)), \\
	.INIT_B(ival(PORT_B_RD_WIDTH, PORT_B_RD_INIT_VALUE)), \\
	.SRVAL_A(ival(PORT_A_RD_WIDTH, PORT_A_RD_SRST_VALUE)), \\
	.SRVAL_B(ival(PORT_B_RD_WIDTH, PORT_B_RD_SRST_VALUE)),

\`define PORTS_COMMON \\
	.DOUTADOUT(DO_A), \\
	.DOUTPADOUTP(DOP_A), \\
	.DINADIN(DI_A), \\
	.DINPADINP(DIP_A), \\
	.DOUTBDOUT(DO_B), \\
	.DOUTPBDOUTP(DOP_B), \\
	.DINBDIN(DI_B), \\
	.DINPBDINP(DIP_B), \\
	.CLKARDCLK(PORT_A_CLK), \\
	.CLKBWRCLK(PORT_B_CLK), \\
	.ENARDEN(PORT_A_CLK_EN), \\
	.ENBWREN(PORT_B_CLK_EN), \\
	.REGCEAREGCE(1'b0), \\
	.REGCEB(1'b0), \\
	.ADDRENA(1'b1), \\
	.ADDRENB(1'b1), \\
	.RSTRAMARSTRAM(PORT_A_RD_SRST), \\
	.RSTRAMB(PORT_B_RD_SRST), \\
	.RSTREGARSTREG(1'b0), \\
	.RSTREGB(1'b0), \\
	.WEA(WE_A), \\
	.WEBWE(WE_B), \\
	.ADDRARDADDR(PORT_A_ADDR), \\
	.ADDRBWRADDR(PORT_B_ADDR), \\
	.SLEEP(1'b0),

\`MAKE_DI(DI_A, DIP_A, PORT_A_WR_DATA)
\`MAKE_DI(DI_B, DIP_B, PORT_B_WR_DATA)
\`MAKE_DO(DO_A, DOP_A, PORT_A_RD_DATA)
\`MAKE_DO(DO_B, DOP_B, PORT_B_RD_DATA)

wire [3:0] WE_A = {4{PORT_A_WR_EN}};
wire [3:0] WE_B = {4{PORT_B_WR_EN}};

generate

if (OPTION_MODE == "HALF") begin
	RAMB18E2 #(
		\`PARAMS_INIT_18
		\`PARAMS_INITP_18
		\`PARAMS_COMMON
	) _TECHMAP_REPLACE_ (
		\`PORTS_COMMON
	);
end else if (OPTION_MODE == "FULL") begin
	RAMB36E2 #(
		\`PARAMS_INIT_36
		\`PARAMS_INITP_36
		\`PARAMS_COMMON
	) _TECHMAP_REPLACE_ (
		\`PORTS_COMMON
	);
end

endgenerate

endmodule


module $__XILINX_BLOCKRAM_SDP_ (...);

parameter INIT = 0;
parameter OPTION_MODE = "FULL";
parameter OPTION_WRITE_MODE = "READ_FIRST";

parameter PORT_W_WIDTH = 1;
parameter PORT_W_WR_EN_WIDTH = 1;
parameter PORT_W_USED = 1;

parameter PORT_R_WIDTH = 1;
parameter PORT_R_USED = 0;
parameter PORT_R_RD_INIT_VALUE = 0;
parameter PORT_R_RD_SRST_VALUE = 0;

input PORT_W_CLK;
input PORT_W_CLK_EN;
input [15:0] PORT_W_ADDR;
input [PORT_W_WIDTH-1:0] PORT_W_WR_DATA;
input [PORT_W_WR_EN_WIDTH-1:0] PORT_W_WR_EN;

input PORT_R_CLK;
input PORT_R_CLK_EN;
input [15:0] PORT_R_ADDR;
output [PORT_R_WIDTH-1:0] PORT_R_RD_DATA;
input PORT_R_RD_SRST;

\`include "brams_defs.vh"

\`define PARAMS_COMMON \\
	.WRITE_MODE_A(OPTION_WRITE_MODE), \\
	.WRITE_MODE_B(OPTION_WRITE_MODE), \\
	.READ_WIDTH_A(PORT_R_USED ? PORT_R_WIDTH : 0), \\
	.READ_WIDTH_B(0), \\
	.WRITE_WIDTH_A(0), \\
	.WRITE_WIDTH_B(PORT_W_USED ? PORT_W_WIDTH : 0), \\
	.DOA_REG(0), \\
	.DOB_REG(0),

\`define PORTS_COMMON \\
	.CLKBWRCLK(PORT_W_CLK), \\
	.CLKARDCLK(PORT_R_CLK), \\
	.ENBWREN(PORT_W_CLK_EN), \\
	.ENARDEN(PORT_R_CLK_EN), \\
	.REGCEAREGCE(1'b0), \\
	.REGCEB(1'b0), \\
	.ADDRENA(1'b1), \\
	.ADDRENB(1'b1), \\
	.RSTRAMARSTRAM(PORT_R_RD_SRST), \\
	.RSTRAMB(1'b0), \\
	.RSTREGARSTREG(1'b0), \\
	.RSTREGB(1'b0), \\
	.WEA(0), \\
	.WEBWE(PORT_W_WR_EN), \\
	.ADDRARDADDR(PORT_R_ADDR), \\
	.ADDRBWRADDR(PORT_W_ADDR), \\
	.SLEEP(1'b0),

\`MAKE_DI(DI, DIP, PORT_W_WR_DATA)
\`MAKE_DO(DO, DOP, PORT_R_RD_DATA)

generate

if (OPTION_MODE == "HALF") begin
	RAMB18E2 #(
		\`PARAMS_INIT_18
		\`PARAMS_INITP_18
		\`PARAMS_COMMON
		.INIT_A(PORT_R_WIDTH == 36 ? ival(18, PORT_R_RD_INIT_VALUE[17:0]) : ival(PORT_R_WIDTH, PORT_R_RD_INIT_VALUE)),
		.INIT_B(PORT_R_WIDTH == 36 ? ival(18, PORT_R_RD_INIT_VALUE[35:18]) : 0),
		.SRVAL_A(PORT_R_WIDTH == 36 ? ival(18, PORT_R_RD_SRST_VALUE[17:0]) : ival(PORT_R_WIDTH, PORT_R_RD_SRST_VALUE)),
		.SRVAL_B(PORT_R_WIDTH == 36 ? ival(18, PORT_R_RD_SRST_VALUE[35:18]) : 0),
	) _TECHMAP_REPLACE_ (
		\`PORTS_COMMON
		.DOUTADOUT(DO[15:0]),
		.DOUTBDOUT(DO[31:16]),
		.DOUTPADOUTP(DOP[1:0]),
		.DOUTPBDOUTP(DOP[3:2]),
		.DINADIN(DI[15:0]),
		.DINBDIN(PORT_W_WIDTH == 36 ? DI[31:16] : DI[15:0]),
		.DINPADINP(DIP[1:0]),
		.DINPBDINP(PORT_W_WIDTH == 36 ? DIP[3:2] : DIP[1:0]),
	);
end else if (OPTION_MODE == "FULL") begin
	RAMB36E2 #(
		\`PARAMS_INIT_36
		\`PARAMS_INITP_36
		\`PARAMS_COMMON
		.INIT_A(PORT_R_WIDTH == 72 ? ival(36, PORT_R_RD_INIT_VALUE[35:0]) : ival(PORT_R_WIDTH, PORT_R_RD_INIT_VALUE)),
		.INIT_B(PORT_R_WIDTH == 72 ? ival(36, PORT_R_RD_INIT_VALUE[71:36]) : 0),
		.SRVAL_A(PORT_R_WIDTH == 72 ? ival(36, PORT_R_RD_SRST_VALUE[35:0]) : ival(PORT_R_WIDTH, PORT_R_RD_SRST_VALUE)),
		.SRVAL_B(PORT_R_WIDTH == 72 ? ival(36, PORT_R_RD_SRST_VALUE[71:36]) : 0),
	) _TECHMAP_REPLACE_ (
		\`PORTS_COMMON
		.DOUTADOUT(DO[31:0]),
		.DOUTBDOUT(DO[63:32]),
		.DOUTPADOUTP(DOP[3:0]),
		.DOUTPBDOUTP(DOP[7:4]),
		.DINADIN(DI[31:0]),
		.DINBDIN(PORT_W_WIDTH == 72 ? DI[63:32] : DI[31:0]),
		.DINPADINP(DIP[3:0]),
		.DINPBDINP(PORT_W_WIDTH == 71 ? DIP[7:4] : DIP[3:0]),
	);
end

endgenerate

endmodule

`,"brams_xcv.txt":`# Block RAMs for the original Virtex.
# The corresponding mapping file is brams_xcv_map.v

ram block $__XILINX_BLOCKRAM_ {
	abits 12;
	widths 1 2 4 8 16 per_port;
	cost 32;
	init any;
	port srsw "A" "B" {
		clock posedge;
		clken;
		rdwr new;
		rdinit zero;
		rdsrst zero gated_clken;
		optional;
	}
}
`,"brams_xcv_map.v":`module $__XILINX_BLOCKRAM_ (...);

parameter INIT = 0;

parameter PORT_A_WIDTH = 1;
parameter PORT_B_WIDTH = 1;
parameter PORT_A_USED = 1;
parameter PORT_B_USED = 0;

input PORT_A_CLK;
input PORT_A_CLK_EN;
input [11:0] PORT_A_ADDR;
input [PORT_A_WIDTH-1:0] PORT_A_WR_DATA;
input PORT_A_WR_EN;
output [PORT_A_WIDTH-1:0] PORT_A_RD_DATA;
input PORT_A_RD_SRST;

input PORT_B_CLK;
input PORT_B_CLK_EN;
input [11:0] PORT_B_ADDR;
input [PORT_B_WIDTH-1:0] PORT_B_WR_DATA;
input PORT_B_WR_EN;
output [PORT_B_WIDTH-1:0] PORT_B_RD_DATA;
input PORT_B_RD_SRST;

\`define PARAMS_INIT \\
	.INIT_00(INIT[0*256+:256]), \\
	.INIT_01(INIT[1*256+:256]), \\
	.INIT_02(INIT[2*256+:256]), \\
	.INIT_03(INIT[3*256+:256]), \\
	.INIT_04(INIT[4*256+:256]), \\
	.INIT_05(INIT[5*256+:256]), \\
	.INIT_06(INIT[6*256+:256]), \\
	.INIT_07(INIT[7*256+:256]), \\
	.INIT_08(INIT[8*256+:256]), \\
	.INIT_09(INIT[9*256+:256]), \\
	.INIT_0A(INIT[10*256+:256]), \\
	.INIT_0B(INIT[11*256+:256]), \\
	.INIT_0C(INIT[12*256+:256]), \\
	.INIT_0D(INIT[13*256+:256]), \\
	.INIT_0E(INIT[14*256+:256]), \\
	.INIT_0F(INIT[15*256+:256]),

\`define PORTS_DP(addr_slice_a, addr_slice_b) \\
	.CLKA(PORT_A_CLK), \\
	.ENA(PORT_A_CLK_EN), \\
	.WEA(PORT_A_WR_EN), \\
	.RSTA(PORT_A_RD_SRST), \\
	.ADDRA(PORT_A_ADDR addr_slice_a), \\
	.DOA(PORT_A_RD_DATA), \\
	.DIA(PORT_A_WR_DATA), \\
	.CLKB(PORT_B_CLK), \\
	.ENB(PORT_B_CLK_EN), \\
	.WEB(PORT_B_WR_EN), \\
	.RSTB(PORT_B_RD_SRST), \\
	.ADDRB(PORT_B_ADDR addr_slice_b), \\
	.DOB(PORT_B_RD_DATA), \\
	.DIB(PORT_B_WR_DATA),

\`define PORTS_DP_SWAP(addr_slice_a, addr_slice_b) \\
	.CLKB(PORT_A_CLK), \\
	.ENB(PORT_A_CLK_EN), \\
	.WEB(PORT_A_WR_EN), \\
	.RSTB(PORT_A_RD_SRST), \\
	.ADDRB(PORT_A_ADDR addr_slice_a), \\
	.DOB(PORT_A_RD_DATA), \\
	.DIB(PORT_A_WR_DATA), \\
	.CLKA(PORT_B_CLK), \\
	.ENA(PORT_B_CLK_EN), \\
	.WEA(PORT_B_WR_EN), \\
	.RSTA(PORT_B_RD_SRST), \\
	.ADDRA(PORT_B_ADDR addr_slice_b), \\
	.DOA(PORT_B_RD_DATA), \\
	.DIA(PORT_B_WR_DATA),

\`define PORTS_SP(addr_slice) \\
	.CLK(PORT_A_CLK), \\
	.EN(PORT_A_CLK_EN), \\
	.WE(PORT_A_WR_EN), \\
	.RST(PORT_A_RD_SRST), \\
	.ADDR(PORT_A_ADDR addr_slice), \\
	.DO(PORT_A_RD_DATA), \\
	.DI(PORT_A_WR_DATA),

generate

if (!PORT_B_USED) begin
	case (PORT_A_WIDTH)
	1: RAMB4_S1 #(
		\`PARAMS_INIT
	) _TECHMAP_REPLACE_ (
		\`PORTS_SP([11:0])
	);
	2: RAMB4_S2 #(
		\`PARAMS_INIT
	) _TECHMAP_REPLACE_ (
		\`PORTS_SP([11:1])
	);
	4: RAMB4_S4 #(
		\`PARAMS_INIT
	) _TECHMAP_REPLACE_ (
		\`PORTS_SP([11:2])
	);
	8: RAMB4_S8 #(
		\`PARAMS_INIT
	) _TECHMAP_REPLACE_ (
		\`PORTS_SP([11:3])
	);
	16: RAMB4_S16 #(
		\`PARAMS_INIT
	) _TECHMAP_REPLACE_ (
		\`PORTS_SP([11:4])
	);
	endcase
end else begin
	case (PORT_A_WIDTH)
	1:	case(PORT_B_WIDTH)
		1: RAMB4_S1_S1 #(
			\`PARAMS_INIT
		) _TECHMAP_REPLACE_ (
			\`PORTS_DP([11:0], [11:0])
		);
		2: RAMB4_S1_S2 #(
			\`PARAMS_INIT
		) _TECHMAP_REPLACE_ (
			\`PORTS_DP([11:0], [11:1])
		);
		4: RAMB4_S1_S4 #(
			\`PARAMS_INIT
		) _TECHMAP_REPLACE_ (
			\`PORTS_DP([11:0], [11:2])
		);
		8: RAMB4_S1_S8 #(
			\`PARAMS_INIT
		) _TECHMAP_REPLACE_ (
			\`PORTS_DP([11:0], [11:3])
		);
		16: RAMB4_S1_S16 #(
			\`PARAMS_INIT
		) _TECHMAP_REPLACE_ (
			\`PORTS_DP([11:0], [11:4])
		);
		endcase
	2:	case(PORT_B_WIDTH)
		1: RAMB4_S1_S2 #(
			\`PARAMS_INIT
		) _TECHMAP_REPLACE_ (
			\`PORTS_DP_SWAP([11:1], [11:0])
		);
		2: RAMB4_S2_S2 #(
			\`PARAMS_INIT
		) _TECHMAP_REPLACE_ (
			\`PORTS_DP([11:1], [11:1])
		);
		4: RAMB4_S2_S4 #(
			\`PARAMS_INIT
		) _TECHMAP_REPLACE_ (
			\`PORTS_DP([11:1], [11:2])
		);
		8: RAMB4_S2_S8 #(
			\`PARAMS_INIT
		) _TECHMAP_REPLACE_ (
			\`PORTS_DP([11:1], [11:3])
		);
		16: RAMB4_S2_S16 #(
			\`PARAMS_INIT
		) _TECHMAP_REPLACE_ (
			\`PORTS_DP([11:1], [11:4])
		);
		endcase
	4:	case(PORT_B_WIDTH)
		1: RAMB4_S1_S4 #(
			\`PARAMS_INIT
		) _TECHMAP_REPLACE_ (
			\`PORTS_DP_SWAP([11:2], [11:0])
		);
		2: RAMB4_S2_S4 #(
			\`PARAMS_INIT
		) _TECHMAP_REPLACE_ (
			\`PORTS_DP_SWAP([11:2], [11:1])
		);
		4: RAMB4_S4_S4 #(
			\`PARAMS_INIT
		) _TECHMAP_REPLACE_ (
			\`PORTS_DP([11:2], [11:2])
		);
		8: RAMB4_S4_S8 #(
			\`PARAMS_INIT
		) _TECHMAP_REPLACE_ (
			\`PORTS_DP([11:2], [11:3])
		);
		16: RAMB4_S4_S16 #(
			\`PARAMS_INIT
		) _TECHMAP_REPLACE_ (
			\`PORTS_DP([11:2], [11:4])
		);
		endcase
	8:	case(PORT_B_WIDTH)
		1: RAMB4_S1_S8 #(
			\`PARAMS_INIT
		) _TECHMAP_REPLACE_ (
			\`PORTS_DP_SWAP([11:3], [11:0])
		);
		2: RAMB4_S2_S8 #(
			\`PARAMS_INIT
		) _TECHMAP_REPLACE_ (
			\`PORTS_DP_SWAP([11:3], [11:1])
		);
		4: RAMB4_S4_S8 #(
			\`PARAMS_INIT
		) _TECHMAP_REPLACE_ (
			\`PORTS_DP_SWAP([11:3], [11:2])
		);
		8: RAMB4_S8_S8 #(
			\`PARAMS_INIT
		) _TECHMAP_REPLACE_ (
			\`PORTS_DP([11:3], [11:3])
		);
		16: RAMB4_S8_S16 #(
			\`PARAMS_INIT
		) _TECHMAP_REPLACE_ (
			\`PORTS_DP([11:3], [11:4])
		);
		endcase
	16:	case(PORT_B_WIDTH)
		1: RAMB4_S1_S16 #(
			\`PARAMS_INIT
		) _TECHMAP_REPLACE_ (
			\`PORTS_DP_SWAP([11:4], [11:0])
		);
		2: RAMB4_S2_S16 #(
			\`PARAMS_INIT
		) _TECHMAP_REPLACE_ (
			\`PORTS_DP_SWAP([11:4], [11:1])
		);
		4: RAMB4_S4_S16 #(
			\`PARAMS_INIT
		) _TECHMAP_REPLACE_ (
			\`PORTS_DP_SWAP([11:4], [11:2])
		);
		8: RAMB4_S8_S16 #(
			\`PARAMS_INIT
		) _TECHMAP_REPLACE_ (
			\`PORTS_DP_SWAP([11:4], [11:3])
		);
		16: RAMB4_S16_S16 #(
			\`PARAMS_INIT
		) _TECHMAP_REPLACE_ (
			\`PORTS_DP([11:4], [11:4])
		);
		endcase
	endcase
end

endgenerate

endmodule
`,"cells_map.v":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *                2019  Eddie Hung    <eddie@fpgeh.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

module \\$__SHREG_ (input C, input D, input E, output Q);
  parameter DEPTH = 0;
  parameter [DEPTH-1:0] INIT = 0;
  parameter CLKPOL = 1;
  parameter ENPOL = 2;

  \\$__XILINX_SHREG_ #(.DEPTH(DEPTH), .INIT(INIT), .CLKPOL(CLKPOL), .ENPOL(ENPOL)) _TECHMAP_REPLACE_ (.C(C), .D(D), .L(DEPTH-1), .E(E), .Q(Q));
endmodule

module \\$__XILINX_SHREG_ (input C, input D, input [31:0] L, input E, output Q, output SO);
  parameter DEPTH = 0;
  parameter [DEPTH-1:0] INIT = 0;
  parameter CLKPOL = 1;
  parameter ENPOL = 2;

  // shregmap's INIT parameter shifts out LSB first;
  // however Xilinx expects MSB first
  function [DEPTH-1:0] brev;
    input [DEPTH-1:0] din;
    integer i;
    begin
      for (i = 0; i < DEPTH; i=i+1)
        brev[i] = din[DEPTH-1-i];
    end
  endfunction
  localparam [DEPTH-1:0] INIT_R = brev(INIT);

  parameter _TECHMAP_CONSTMSK_L_ = 0;

  wire CE;
  generate
    if (ENPOL == 0)
      assign CE = ~E;
    else if (ENPOL == 1)
      assign CE = E;
    else
      assign CE = 1'b1;
    if (DEPTH == 1) begin
      if (CLKPOL)
          FDRE #(.INIT(INIT_R)) _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .CE(CE), .R(1'b0));
      else
          FDRE_1 #(.INIT(INIT_R)) _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .CE(CE), .R(1'b0));
    end else
    if (DEPTH <= 16) begin
      SRL16E #(.INIT(INIT_R), .IS_CLK_INVERTED(~CLKPOL[0])) _TECHMAP_REPLACE_ (.A0(L[0]), .A1(L[1]), .A2(L[2]), .A3(L[3]), .CE(CE), .CLK(C), .D(D), .Q(Q));
    end else
    if (DEPTH > 17 && DEPTH <= 32) begin
      SRLC32E #(.INIT(INIT_R), .IS_CLK_INVERTED(~CLKPOL[0])) _TECHMAP_REPLACE_ (.A(L[4:0]), .CE(CE), .CLK(C), .D(D), .Q(Q));
    end else
    if (DEPTH > 33 && DEPTH <= 64) begin
      wire T0, T1, T2;
      SRLC32E #(.INIT(INIT_R[32-1:0]), .IS_CLK_INVERTED(~CLKPOL[0])) fpga_srl_0 (.A(L[4:0]), .CE(CE), .CLK(C), .D(D), .Q(T0), .Q31(T1));
      \\$__XILINX_SHREG_ #(.DEPTH(DEPTH-32), .INIT(INIT[DEPTH-32-1:0]), .CLKPOL(CLKPOL), .ENPOL(ENPOL)) fpga_srl_1 (.C(C), .D(T1), .L(L), .E(E), .Q(T2));
      if (&_TECHMAP_CONSTMSK_L_)
        assign Q = T2;
      else
        MUXF7 fpga_mux_0 (.O(Q), .I0(T0), .I1(T2), .S(L[5]));
    end else
    if (DEPTH > 65 && DEPTH <= 96) begin
      wire T0, T1, T2, T3, T4, T5, T6;
      SRLC32E #(.INIT(INIT_R[32-1: 0]), .IS_CLK_INVERTED(~CLKPOL[0])) fpga_srl_0 (.A(L[4:0]), .CE(CE), .CLK(C), .D( D), .Q(T0), .Q31(T1));
      SRLC32E #(.INIT(INIT_R[64-1:32]), .IS_CLK_INVERTED(~CLKPOL[0])) fpga_srl_1 (.A(L[4:0]), .CE(CE), .CLK(C), .D(T1), .Q(T2), .Q31(T3));
      \\$__XILINX_SHREG_ #(.DEPTH(DEPTH-64), .INIT(INIT[DEPTH-64-1:0]), .CLKPOL(CLKPOL), .ENPOL(ENPOL)) fpga_srl_2 (.C(C), .D(T3), .L(L[4:0]), .E(E), .Q(T4));
      if (&_TECHMAP_CONSTMSK_L_)
        assign Q = T4;
      else
        \\$__XILINX_MUXF78 fpga_hard_mux (.I0(T0), .I1(T2), .I2(T4), .I3(1'bx), .S0(L[5]), .S1(L[6]), .O(Q));
    end else
    if (DEPTH > 97 && DEPTH < 128) begin
      wire T0, T1, T2, T3, T4, T5, T6, T7, T8;
      SRLC32E #(.INIT(INIT_R[32-1: 0]), .IS_CLK_INVERTED(~CLKPOL[0])) fpga_srl_0 (.A(L[4:0]), .CE(CE), .CLK(C), .D( D), .Q(T0), .Q31(T1));
      SRLC32E #(.INIT(INIT_R[64-1:32]), .IS_CLK_INVERTED(~CLKPOL[0])) fpga_srl_1 (.A(L[4:0]), .CE(CE), .CLK(C), .D(T1), .Q(T2), .Q31(T3));
      SRLC32E #(.INIT(INIT_R[96-1:64]), .IS_CLK_INVERTED(~CLKPOL[0])) fpga_srl_2 (.A(L[4:0]), .CE(CE), .CLK(C), .D(T3), .Q(T4), .Q31(T5));
      \\$__XILINX_SHREG_ #(.DEPTH(DEPTH-96), .INIT(INIT[DEPTH-96-1:0]), .CLKPOL(CLKPOL), .ENPOL(ENPOL)) fpga_srl_3 (.C(C), .D(T5), .L(L[4:0]), .E(E), .Q(T6));
      if (&_TECHMAP_CONSTMSK_L_)
        assign Q = T6;
      else
        \\$__XILINX_MUXF78 fpga_hard_mux (.I0(T0), .I1(T2), .I2(T4), .I3(T6), .S0(L[5]), .S1(L[6]), .O(Q));
    end
    else if (DEPTH == 128) begin
      wire T0, T1, T2, T3, T4, T5, T6;
      SRLC32E #(.INIT(INIT_R[ 32-1: 0]), .IS_CLK_INVERTED(~CLKPOL[0])) fpga_srl_0 (.A(L[4:0]), .CE(CE), .CLK(C), .D( D), .Q(T0), .Q31(T1));
      SRLC32E #(.INIT(INIT_R[ 64-1:32]), .IS_CLK_INVERTED(~CLKPOL[0])) fpga_srl_1 (.A(L[4:0]), .CE(CE), .CLK(C), .D(T1), .Q(T2), .Q31(T3));
      SRLC32E #(.INIT(INIT_R[ 96-1:64]), .IS_CLK_INVERTED(~CLKPOL[0])) fpga_srl_2 (.A(L[4:0]), .CE(CE), .CLK(C), .D(T3), .Q(T4), .Q31(T5));
      SRLC32E #(.INIT(INIT_R[128-1:96]), .IS_CLK_INVERTED(~CLKPOL[0])) fpga_srl_3 (.A(L[4:0]), .CE(CE), .CLK(C), .D(T5), .Q(T6), .Q31(SO));
      if (&_TECHMAP_CONSTMSK_L_)
        assign Q = T6;
      else
        \\$__XILINX_MUXF78 fpga_hard_mux (.I0(T0), .I1(T2), .I2(T4), .I3(T6), .S0(L[5]), .S1(L[6]), .O(Q));
    end
    // For fixed length, if just 1 over a convenient value, decompose
    else if (DEPTH <= 129 && &_TECHMAP_CONSTMSK_L_) begin
      wire T;
      \\$__XILINX_SHREG_ #(.DEPTH(DEPTH-1), .INIT(INIT[DEPTH-1:1]), .CLKPOL(CLKPOL), .ENPOL(ENPOL)) fpga_srl      (.C(C), .D(D), .L({32{1'b1}}), .E(E), .Q(T));
      \\$__XILINX_SHREG_ #(.DEPTH(1),       .INIT(INIT[0]),         .CLKPOL(CLKPOL), .ENPOL(ENPOL)) fpga_srl_last (.C(C), .D(T), .L(L), .E(E), .Q(Q));
    end
    // For variable length, if just 1 over a convenient value, then bump up one more
    else if (DEPTH < 129 && ~&_TECHMAP_CONSTMSK_L_)
      \\$__XILINX_SHREG_ #(.DEPTH(DEPTH+1), .INIT({INIT,1'b0}), .CLKPOL(CLKPOL), .ENPOL(ENPOL)) _TECHMAP_REPLACE_ (.C(C), .D(D), .L(L), .E(E), .Q(Q));
    else begin
      localparam depth0 = 128;
      localparam num_srl128 = DEPTH / depth0;
      localparam depthN = DEPTH % depth0;
      wire [num_srl128 + (depthN > 0 ? 1 : 0) - 1:0] T;
      wire [num_srl128 + (depthN > 0 ? 1 : 0) :0] S;
      assign S[0] = D;
      genvar i;
      for (i = 0; i < num_srl128; i++)
        \\$__XILINX_SHREG_ #(.DEPTH(depth0), .INIT(INIT[DEPTH-1-i*depth0-:depth0]), .CLKPOL(CLKPOL), .ENPOL(ENPOL)) fpga_srl      (.C(C), .D(S[i]),          .L(L[$clog2(depth0)-1:0]), .E(E), .Q(T[i]), .SO(S[i+1]));

      if (depthN > 0)
        \\$__XILINX_SHREG_ #(.DEPTH(depthN), .INIT(INIT[depthN-1:0]),               .CLKPOL(CLKPOL), .ENPOL(ENPOL)) fpga_srl_last (.C(C), .D(S[num_srl128]), .L(L[$clog2(depth0)-1:0]), .E(E), .Q(T[num_srl128]));

      if (&_TECHMAP_CONSTMSK_L_)
        assign Q = T[num_srl128 + (depthN > 0 ? 1 : 0) - 1];
      else
        assign Q = T[L[DEPTH-1:$clog2(depth0)]];
    end
  endgenerate
endmodule

\`ifdef MIN_MUX_INPUTS
module \\$__XILINX_SHIFTX (A, B, Y);
  parameter A_SIGNED = 0;
  parameter B_SIGNED = 0;
  parameter A_WIDTH = 1;
  parameter B_WIDTH = 1;
  parameter Y_WIDTH = 1;

  (* force_downto *)
  input [A_WIDTH-1:0] A;
  (* force_downto *)
  input [B_WIDTH-1:0] B;
  (* force_downto *)
  output [Y_WIDTH-1:0] Y;

  parameter [A_WIDTH-1:0] _TECHMAP_CONSTMSK_A_ = 0;
  parameter [A_WIDTH-1:0] _TECHMAP_CONSTVAL_A_ = 0;
  parameter [B_WIDTH-1:0] _TECHMAP_CONSTMSK_B_ = 0;
  parameter [B_WIDTH-1:0] _TECHMAP_CONSTVAL_B_ = 0;

  function integer A_WIDTH_trimmed;
    input integer start;
  begin
    A_WIDTH_trimmed = start;
    while (A_WIDTH_trimmed > 0 && _TECHMAP_CONSTMSK_A_[A_WIDTH_trimmed-1] && _TECHMAP_CONSTVAL_A_[A_WIDTH_trimmed-1] === 1'bx)
      A_WIDTH_trimmed = A_WIDTH_trimmed - 1;
  end
  endfunction

  generate
    genvar i, j;
    // Bit-blast
    if (Y_WIDTH > 1) begin
      for (i = 0; i < Y_WIDTH; i++)
        \\$__XILINX_SHIFTX  #(.A_SIGNED(A_SIGNED), .B_SIGNED(B_SIGNED), .A_WIDTH(A_WIDTH-Y_WIDTH+1), .B_WIDTH(B_WIDTH), .Y_WIDTH(1'd1)) bitblast (.A(A[A_WIDTH-Y_WIDTH+i:i]), .B(B), .Y(Y[i]));
    end
    // If the LSB of B is constant zero (and Y_WIDTH is 1) then
    //   we can optimise by removing every other entry from A
    //   and popping the constant zero from B
    else if (_TECHMAP_CONSTMSK_B_[0] && !_TECHMAP_CONSTVAL_B_[0]) begin
      wire [(A_WIDTH+1)/2-1:0] A_i;
      for (i = 0; i < (A_WIDTH+1)/2; i++)
        assign A_i[i] = A[i*2];
      \\$__XILINX_SHIFTX  #(.A_SIGNED(A_SIGNED), .B_SIGNED(B_SIGNED), .A_WIDTH((A_WIDTH+1'd1)/2'd2), .B_WIDTH(B_WIDTH-1'd1), .Y_WIDTH(Y_WIDTH)) _TECHMAP_REPLACE_ (.A(A_i), .B(B[B_WIDTH-1:1]), .Y(Y));
    end
    // Trim off any leading 1'bx -es in A
    else if (_TECHMAP_CONSTMSK_A_[A_WIDTH-1] && _TECHMAP_CONSTVAL_A_[A_WIDTH-1] === 1'bx) begin
      localparam A_WIDTH_new = A_WIDTH_trimmed(A_WIDTH-1);
      \\$__XILINX_SHIFTX  #(.A_SIGNED(A_SIGNED), .B_SIGNED(B_SIGNED), .A_WIDTH(A_WIDTH_new), .B_WIDTH(B_WIDTH), .Y_WIDTH(Y_WIDTH)) _TECHMAP_REPLACE_ (.A(A[A_WIDTH_new-1:0]), .B(B), .Y(Y));
    end
    else if (A_WIDTH < \`MIN_MUX_INPUTS) begin
      wire _TECHMAP_FAIL_ = 1;
    end
    else if (A_WIDTH == 2) begin
      MUXF7 fpga_hard_mux (.I0(A[0]), .I1(A[1]), .S(B[0]), .O(Y));
    end
    else if (A_WIDTH <= 4) begin
      wire [4-1:0] Ax;
      if (A_WIDTH == 4)
        assign Ax = A;
      else
        // Rather than extend with 1'bx which gets flattened to 1'b0
        // causing the "don't care" status to get lost, extend with
        // the same driver of F7B.I0 so that we can optimise F7B away
        // later
        assign Ax = {A[1], A};
      \\$__XILINX_MUXF78 fpga_hard_mux (.I0(Ax[0]), .I1(Ax[2]), .I2(Ax[1]), .I3(Ax[3]), .S0(B[1]), .S1(B[0]), .O(Y));
    end
    // Note that the following decompositions are 'backwards' in that
    // the LSBs are placed on the hard resources, and the soft resources
    // are used for MSBs.
    // This has the effect of more effectively utilising the hard mux;
    // take for example a 5:1 multiplexer, currently this would map as:
    //
    //     A[0] \\___  __                             A[0] \\__  __
    //     A[4] /   \\|  \\       whereas the more     A[1] /  \\|  \\
    //     A[1] _____|   |      obvious mapping      A[2] \\___|   |
    //     A[2] _____|   |--    of MSBs to hard      A[3] /   |   |__
    //     A[3]______|   |      resources would      A[4] ____|   |
    //               |__/       lead to:             1'bx ____|   |
    //                ||                                      |__/
    //                ||                                       ||
    //              B[1:0]                                   B[1:2]
    //
    // Expectation would be that the 'forward' mapping (right) is more
    // area efficient (consider a 9:1 multiplexer using 2x4:1 multiplexers
    // on its I0 and I1 inputs, and A[8] and 1'bx on its I2 and I3 inputs)
    // but that the 'backwards' mapping (left) is more delay efficient
    // since smaller LUTs are faster than wider ones.
    else if (A_WIDTH <= 8) begin
      wire [8-1:0] Ax = {{{8-A_WIDTH}{1'bx}}, A};
      wire T0 = B[2] ? Ax[4] : Ax[0];
      wire T1 = B[2] ? Ax[5] : Ax[1];
      wire T2 = B[2] ? Ax[6] : Ax[2];
      wire T3 = B[2] ? Ax[7] : Ax[3];
      \\$__XILINX_MUXF78 fpga_hard_mux (.I0(T0), .I1(T2), .I2(T1), .I3(T3), .S0(B[1]), .S1(B[0]), .O(Y));
    end
    else if (A_WIDTH <= 16) begin
      wire [16-1:0] Ax = {{{16-A_WIDTH}{1'bx}}, A};
      wire T0 = B[2] ? B[3] ? Ax[12] : Ax[4]
                     : B[3] ? Ax[ 8] : Ax[0];
      wire T1 = B[2] ? B[3] ? Ax[13] : Ax[5]
                     : B[3] ? Ax[ 9] : Ax[1];
      wire T2 = B[2] ? B[3] ? Ax[14] : Ax[6]
                     : B[3] ? Ax[10] : Ax[2];
      wire T3 = B[2] ? B[3] ? Ax[15] : Ax[7]
                     : B[3] ? Ax[11] : Ax[3];
      \\$__XILINX_MUXF78 fpga_hard_mux (.I0(T0), .I1(T2), .I2(T1), .I3(T3), .S0(B[1]), .S1(B[0]), .O(Y));
    end
    else begin
      localparam num_mux16 = (A_WIDTH+15) / 16;
      localparam clog2_num_mux16 = $clog2(num_mux16);
      wire [num_mux16-1:0] T;
      wire [num_mux16*16-1:0] Ax = {{(num_mux16*16-A_WIDTH){1'bx}}, A};
      for (i = 0; i < num_mux16; i++)
        \\$__XILINX_SHIFTX  #(
          .A_SIGNED(A_SIGNED),
          .B_SIGNED(B_SIGNED),
          .A_WIDTH(16),
          .B_WIDTH(4),
          .Y_WIDTH(Y_WIDTH)
        ) fpga_mux (
          .A(Ax[i*16+:16]),
          .B(B[3:0]),
          .Y(T[i])
        );
      \\$__XILINX_SHIFTX  #(
          .A_SIGNED(A_SIGNED),
          .B_SIGNED(B_SIGNED),
          .A_WIDTH(num_mux16),
          .B_WIDTH(clog2_num_mux16),
          .Y_WIDTH(Y_WIDTH)
      ) _TECHMAP_REPLACE_ (
          .A(T),
          .B(B[B_WIDTH-1-:clog2_num_mux16]),
          .Y(Y));
    end
  endgenerate
endmodule

(* techmap_celltype = "$__XILINX_SHIFTX" *)
module _90__XILINX_SHIFTX (A, B, Y);
  parameter A_SIGNED = 0;
  parameter B_SIGNED = 0;
  parameter A_WIDTH = 1;
  parameter B_WIDTH = 1;
  parameter Y_WIDTH = 1;

  (* force_downto *)
  input [A_WIDTH-1:0] A;
  (* force_downto *)
  input [B_WIDTH-1:0] B;
  (* force_downto *)
  output [Y_WIDTH-1:0] Y;

  \\$shiftx  #(.A_SIGNED(A_SIGNED), .B_SIGNED(B_SIGNED), .A_WIDTH(A_WIDTH), .B_WIDTH(B_WIDTH), .Y_WIDTH(Y_WIDTH)) _TECHMAP_REPLACE_ (.A(A), .B(B), .Y(Y));
endmodule

module \\$_MUX_ (A, B, S, Y);
  input A, B, S;
  output Y;
  generate
    if (\`MIN_MUX_INPUTS == 2)
      \\$__XILINX_SHIFTX  #(.A_SIGNED(0), .B_SIGNED(0), .A_WIDTH(2), .B_WIDTH(1), .Y_WIDTH(1)) _TECHMAP_REPLACE_ (.A({B,A}), .B(S), .Y(Y));
    else
      wire _TECHMAP_FAIL_ = 1;
  endgenerate
endmodule

module \\$_MUX4_ (A, B, C, D, S, T, Y);
  input A, B, C, D, S, T;
  output Y;
  \\$__XILINX_SHIFTX  #(.A_SIGNED(0), .B_SIGNED(0), .A_WIDTH(4), .B_WIDTH(2), .Y_WIDTH(1)) _TECHMAP_REPLACE_ (.A({D,C,B,A}), .B({T,S}), .Y(Y));
endmodule

module \\$_MUX8_ (A, B, C, D, E, F, G, H, S, T, U, Y);
  input A, B, C, D, E, F, G, H, S, T, U;
  output Y;
  \\$__XILINX_SHIFTX  #(.A_SIGNED(0), .B_SIGNED(0), .A_WIDTH(8), .B_WIDTH(3), .Y_WIDTH(1)) _TECHMAP_REPLACE_ (.A({H,G,F,E,D,C,B,A}), .B({U,T,S}), .Y(Y));
endmodule

module \\$_MUX16_ (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, S, T, U, V, Y);
  input A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, S, T, U, V;
  output Y;
  \\$__XILINX_SHIFTX  #(.A_SIGNED(0), .B_SIGNED(0), .A_WIDTH(16), .B_WIDTH(4), .Y_WIDTH(1)) _TECHMAP_REPLACE_ (.A({P,O,N,M,L,K,J,I,H,G,F,E,D,C,B,A}), .B({V,U,T,S}), .Y(Y));
endmodule
\`endif

module \\$__XILINX_MUXF78 (O, I0, I1, I2, I3, S0, S1);
  output O;
  input I0, I1, I2, I3, S0, S1;
  wire T0, T1;
  parameter _TECHMAP_BITS_CONNMAP_ = 0;
  parameter [_TECHMAP_BITS_CONNMAP_-1:0] _TECHMAP_CONNMAP_I0_ = 0;
  parameter [_TECHMAP_BITS_CONNMAP_-1:0] _TECHMAP_CONNMAP_I1_ = 0;
  parameter [_TECHMAP_BITS_CONNMAP_-1:0] _TECHMAP_CONNMAP_I2_ = 0;
  parameter [_TECHMAP_BITS_CONNMAP_-1:0] _TECHMAP_CONNMAP_I3_ = 0;
  parameter _TECHMAP_CONSTMSK_S0_ = 0;
  parameter _TECHMAP_CONSTVAL_S0_ = 0;
  parameter _TECHMAP_CONSTMSK_S1_ = 0;
  parameter _TECHMAP_CONSTVAL_S1_ = 0;
  if (_TECHMAP_CONSTMSK_S0_ && _TECHMAP_CONSTVAL_S0_ === 1'b1)
    assign T0 = I1;
  else if (_TECHMAP_CONSTMSK_S0_ || _TECHMAP_CONNMAP_I0_ === _TECHMAP_CONNMAP_I1_)
    assign T0 = I0;
  else
    MUXF7 mux7a (.I0(I0), .I1(I1), .S(S0), .O(T0));
  if (_TECHMAP_CONSTMSK_S0_ && _TECHMAP_CONSTVAL_S0_ === 1'b1)
    assign T1 = I3;
  else if (_TECHMAP_CONSTMSK_S0_ || _TECHMAP_CONNMAP_I2_ === _TECHMAP_CONNMAP_I3_)
    assign T1 = I2;
  else
    MUXF7 mux7b (.I0(I2), .I1(I3), .S(S0), .O(T1));
  if (_TECHMAP_CONSTMSK_S1_ && _TECHMAP_CONSTVAL_S1_ === 1'b1)
    assign O = T1;
  else if (_TECHMAP_CONSTMSK_S1_ || (_TECHMAP_CONNMAP_I0_ === _TECHMAP_CONNMAP_I1_ && _TECHMAP_CONNMAP_I1_ === _TECHMAP_CONNMAP_I2_ && _TECHMAP_CONNMAP_I2_ === _TECHMAP_CONNMAP_I3_))
    assign O = T0;
  else
    MUXF8 mux8 (.I0(T0), .I1(T1), .S(S1), .O(O));
endmodule
`,"cells_sim.v":new URL("./cells_sim-7704155f.v?hash=7704155f",import.meta.url),"cells_xtra.v":new URL("./cells_xtra-04bc1ce3.v?hash=04bc1ce3",import.meta.url),"ff_map.v":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

\`ifndef _NO_FFS

// Async reset, enable.

module  \\$_DFFE_NP0P_ (input D, C, E, R, output Q);
  parameter _TECHMAP_WIREINIT_Q_ = 1'bx;
  FDCE_1 #(.INIT(_TECHMAP_WIREINIT_Q_)) _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .CE(E), .CLR(R));
  wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule
module  \\$_DFFE_PP0P_ (input D, C, E, R, output Q);
  parameter _TECHMAP_WIREINIT_Q_ = 1'bx;
  FDCE   #(.INIT(_TECHMAP_WIREINIT_Q_)) _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .CE(E), .CLR(R));
  wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule

module  \\$_DFFE_NP1P_ (input D, C, E, R, output Q);
  parameter _TECHMAP_WIREINIT_Q_ = 1'bx;
  FDPE_1 #(.INIT(_TECHMAP_WIREINIT_Q_)) _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .CE(E), .PRE(R));
  wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule
module  \\$_DFFE_PP1P_ (input D, C, E, R, output Q);
  parameter _TECHMAP_WIREINIT_Q_ = 1'bx;
  FDPE   #(.INIT(_TECHMAP_WIREINIT_Q_)) _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .CE(E), .PRE(R));
  wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule

// Async set and reset, enable.

module  \\$_DFFSRE_NPPP_ (input D, C, E, S, R, output Q);
  parameter _TECHMAP_WIREINIT_Q_ = 1'bx;
  FDCPE #(.INIT(_TECHMAP_WIREINIT_Q_), .IS_C_INVERTED(1'b1)) _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .CE(E), .CLR(R), .PRE(S));
  wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule
module  \\$_DFFSRE_PPPP_ (input D, C, E, S, R, output Q);
  parameter _TECHMAP_WIREINIT_Q_ = 1'bx;
  FDCPE   #(.INIT(_TECHMAP_WIREINIT_Q_)) _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .CE(E), .CLR(R), .PRE(S));
  wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule

// Sync reset, enable.

module  \\$_SDFFE_NP0P_ (input D, C, E, R, output Q);
  parameter _TECHMAP_WIREINIT_Q_ = 1'bx;
  FDRE_1 #(.INIT(_TECHMAP_WIREINIT_Q_)) _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .CE(E), .R(R));
  wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule
module  \\$_SDFFE_PP0P_ (input D, C, E, R, output Q);
  parameter _TECHMAP_WIREINIT_Q_ = 1'bx;
  FDRE   #(.INIT(_TECHMAP_WIREINIT_Q_)) _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .CE(E), .R(R));
  wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule

module  \\$_SDFFE_NP1P_ (input D, C, E, R, output Q);
  parameter _TECHMAP_WIREINIT_Q_ = 1'bx;
  FDSE_1 #(.INIT(_TECHMAP_WIREINIT_Q_)) _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .CE(E), .S(R));
  wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule
module  \\$_SDFFE_PP1P_ (input D, C, E, R, output Q);
  parameter _TECHMAP_WIREINIT_Q_ = 1'bx;
  FDSE   #(.INIT(_TECHMAP_WIREINIT_Q_)) _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .CE(E), .S(R));
  wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule

// Latches with reset.

module  \\$_DLATCH_NP0_ (input E, R, D, output Q);
  parameter _TECHMAP_WIREINIT_Q_ = 1'bx;
  LDCE #(.INIT(_TECHMAP_WIREINIT_Q_), .IS_G_INVERTED(1'b1)) _TECHMAP_REPLACE_ (.D(D), .Q(Q), .G(E), .GE(1'b1), .CLR(R));
  wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule
module  \\$_DLATCH_PP0_ (input E, R, D, output Q);
  parameter _TECHMAP_WIREINIT_Q_ = 1'bx;
  LDCE   #(.INIT(_TECHMAP_WIREINIT_Q_)) _TECHMAP_REPLACE_ (.D(D), .Q(Q), .G(E), .GE(1'b1), .CLR(R));
  wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule
module  \\$_DLATCH_NP1_ (input E, R, D, output Q);
  parameter _TECHMAP_WIREINIT_Q_ = 1'bx;
  LDPE #(.INIT(_TECHMAP_WIREINIT_Q_), .IS_G_INVERTED(1'b1)) _TECHMAP_REPLACE_ (.D(D), .Q(Q), .G(E), .GE(1'b1), .PRE(R));
  wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule
module  \\$_DLATCH_PP1_ (input E, R, D, output Q);
  parameter _TECHMAP_WIREINIT_Q_ = 1'bx;
  LDPE   #(.INIT(_TECHMAP_WIREINIT_Q_)) _TECHMAP_REPLACE_ (.D(D), .Q(Q), .G(E), .GE(1'b1), .PRE(R));
  wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule

// Latches with set and reset.

module  \\$_DLATCH_NPP_ (input E, S, R, D, output Q);
  parameter _TECHMAP_WIREINIT_Q_ = 1'bx;
  LDCPE #(.INIT(_TECHMAP_WIREINIT_Q_), .IS_G_INVERTED(1'b1)) _TECHMAP_REPLACE_ (.D(D), .Q(Q), .G(E), .GE(1'b1), .CLR(R), .PRE(S));
  wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule
module  \\$_DLATCH_PPP_ (input E, S, R, D, output Q);
  parameter _TECHMAP_WIREINIT_Q_ = 1'bx;
  LDCPE   #(.INIT(_TECHMAP_WIREINIT_Q_)) _TECHMAP_REPLACE_ (.D(D), .Q(Q), .G(E), .GE(1'b1), .CLR(R), .PRE(S));
  wire _TECHMAP_REMOVEINIT_Q_ = 1;
endmodule

\`endif

`,"lut_map.v":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

// ============================================================================
// LUT mapping

\`ifndef _NO_LUTS

module \\$lut (A, Y);
  parameter WIDTH = 0;
  parameter LUT = 0;

  (* force_downto *)
  input [WIDTH-1:0] A;
  output Y;

  generate
    if (WIDTH == 1) begin
      if (LUT == 2'b01) begin
        INV _TECHMAP_REPLACE_ (.O(Y), .I(A[0]));
      end else begin
        LUT1 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.O(Y),
          .I0(A[0]));
      end
    end else
    if (WIDTH == 2) begin
      LUT2 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.O(Y),
        .I0(A[0]), .I1(A[1]));
    end else
    if (WIDTH == 3) begin
      LUT3 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.O(Y),
        .I0(A[0]), .I1(A[1]), .I2(A[2]));
    end else
    if (WIDTH == 4) begin
      LUT4 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.O(Y),
        .I0(A[0]), .I1(A[1]), .I2(A[2]),
        .I3(A[3]));
    end else
    if (WIDTH == 5 && WIDTH <= \`LUT_WIDTH) begin
      LUT5 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.O(Y),
        .I0(A[0]), .I1(A[1]), .I2(A[2]),
        .I3(A[3]), .I4(A[4]));
    end else
    if (WIDTH == 6 && WIDTH <= \`LUT_WIDTH) begin
      LUT6 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.O(Y),
        .I0(A[0]), .I1(A[1]), .I2(A[2]),
        .I3(A[3]), .I4(A[4]), .I5(A[5]));
    end else
    if (WIDTH == 5 && WIDTH > \`LUT_WIDTH) begin
      wire f0, f1;
      \\$lut #(.LUT(LUT[15: 0]), .WIDTH(4)) lut0 (.A(A[3:0]), .Y(f0));
      \\$lut #(.LUT(LUT[31:16]), .WIDTH(4)) lut1 (.A(A[3:0]), .Y(f1));
      MUXF5 mux5(.I0(f0), .I1(f1), .S(A[4]), .O(Y));
    end else
    if (WIDTH == 6 && WIDTH > \`LUT_WIDTH) begin
      wire f0, f1;
      \\$lut #(.LUT(LUT[31: 0]), .WIDTH(5)) lut0 (.A(A[4:0]), .Y(f0));
      \\$lut #(.LUT(LUT[63:32]), .WIDTH(5)) lut1 (.A(A[4:0]), .Y(f1));
      MUXF6 mux6(.I0(f0), .I1(f1), .S(A[5]), .O(Y));
    end else
    if (WIDTH == 7) begin
      wire f0, f1;
      \\$lut #(.LUT(LUT[ 63: 0]), .WIDTH(6)) lut0 (.A(A[5:0]), .Y(f0));
      \\$lut #(.LUT(LUT[127:64]), .WIDTH(6)) lut1 (.A(A[5:0]), .Y(f1));
      MUXF7 mux7(.I0(f0), .I1(f1), .S(A[6]), .O(Y));
    end else
    if (WIDTH == 8) begin
      wire f0, f1;
      \\$lut #(.LUT(LUT[127:  0]), .WIDTH(7)) lut0 (.A(A[6:0]), .Y(f0));
      \\$lut #(.LUT(LUT[255:128]), .WIDTH(7)) lut1 (.A(A[6:0]), .Y(f1));
      MUXF8 mux8(.I0(f0), .I1(f1), .S(A[7]), .O(Y));
    end else
    if (WIDTH == 9) begin
      wire f0, f1;
      \\$lut #(.LUT(LUT[255:  0]), .WIDTH(8)) lut0 (.A(A[7:0]), .Y(f0));
      \\$lut #(.LUT(LUT[511:256]), .WIDTH(8)) lut1 (.A(A[7:0]), .Y(f1));
      MUXF9 mux9(.I0(f0), .I1(f1), .S(A[8]), .O(Y));
    end else begin
      wire _TECHMAP_FAIL_ = 1;
    end
  endgenerate
endmodule

\`endif

`,"lutrams_xc5v.txt":`# LUT RAMs for Virtex 5, Virtex 6, Spartan 6, Series 7.
# The corresponding mapping file is lutrams_xc5v_map.v

# Single-port RAMs.

ram distributed $__XILINX_LUTRAM_SP_ {
	cost 8;
	widthscale;
	option "ABITS" 5 {
		abits 5;
		widths 8 global;
	}
	option "ABITS" 6 {
		abits 6;
		widths 4 global;
	}
	option "ABITS" 7 {
		abits 7;
		widths 2 global;
	}
	option "ABITS" 8 {
		abits 8;
		widths 1 global;
	}
	init no_undef;
	prune_rom;
	port arsw "RW" {
		clock posedge;
	}
}

# Dual-port RAMs.

ram distributed $__XILINX_LUTRAM_DP_ {
	cost 8;
	widthscale;
	option "ABITS" 5 {
		abits 5;
		widths 4 global;
	}
	option "ABITS" 6 {
		abits 6;
		widths 2 global;
	}
	option "ABITS" 7 {
		abits 7;
		widths 1 global;
	}
	init no_undef;
	prune_rom;
	port arsw "RW" {
		clock posedge;
	}
	port ar "R" {
	}
}

# Quad-port RAMs.

ram distributed $__XILINX_LUTRAM_QP_ {
	cost 7;
	widthscale;
	option "ABITS" 5 {
		abits 5;
		widths 2 global;
	}
	option "ABITS" 6 {
		abits 6;
		widths 1 global;
	}
	init no_undef;
	prune_rom;
	port arsw "RW" {
		clock posedge;
	}
	port ar "R0" "R1" "R2" {
	}
}

# Simple dual port RAMs.

ram distributed $__XILINX_LUTRAM_SDP_ {
	cost 8;
	widthscale 7;
	option "ABITS" 5 {
		abits 5;
		widths 6 global;
	}
	option "ABITS" 6 {
		abits 6;
		widths 3 global;
	}
	init no_undef;
	prune_rom;
	port sw "W" {
		clock posedge;
	}
	port ar "R" {
	}
}
`,"lutrams_xc5v_map.v":`// LUT RAMs for Virtex 5, Virtex 6, Spartan 6, Series 7, Ultrascale.
// The definitions are in lutrams_xc5v.txt (everything but Ultrascale)
// and lutrams_xcu.txt (Ultrascale).


module $__XILINX_LUTRAM_SP_ (...);

parameter INIT = 0;
parameter OPTION_ABITS = 5;
parameter WIDTH = 8;
parameter BITS_USED = 0;

output [WIDTH-1:0] PORT_RW_RD_DATA;
input [WIDTH-1:0] PORT_RW_WR_DATA;
input [OPTION_ABITS-1:0] PORT_RW_ADDR;
input PORT_RW_WR_EN;
input PORT_RW_CLK;

function [(1 << OPTION_ABITS)-1:0] init_slice;
	input integer idx;
	integer i;
	for (i = 0; i < (1 << OPTION_ABITS); i = i + 1)
		init_slice[i] = INIT[i * WIDTH + idx];
endfunction

function [(2 << OPTION_ABITS)-1:0] init_slice2;
	input integer idx;
	integer i;
	for (i = 0; i < (1 << OPTION_ABITS); i = i + 1)
		init_slice2[2 * i +: 2] = INIT[i * WIDTH + idx * 2 +: 2];
endfunction

generate
case(OPTION_ABITS)
5: if (WIDTH == 8)
	RAM32M
	#(
		.INIT_D(init_slice2(0)),
		.INIT_C(init_slice2(1)),
		.INIT_B(init_slice2(2)),
		.INIT_A(init_slice2(3)),
	)
	_TECHMAP_REPLACE_
	(
		.DOA(PORT_RW_RD_DATA[7:6]),
		.DOB(PORT_RW_RD_DATA[5:4]),
		.DOC(PORT_RW_RD_DATA[3:2]),
		.DOD(PORT_RW_RD_DATA[1:0]),
		.DIA(PORT_RW_WR_DATA[7:6]),
		.DIB(PORT_RW_WR_DATA[5:4]),
		.DIC(PORT_RW_WR_DATA[3:2]),
		.DID(PORT_RW_WR_DATA[1:0]),
		.ADDRA(PORT_RW_ADDR),
		.ADDRB(PORT_RW_ADDR),
		.ADDRC(PORT_RW_ADDR),
		.ADDRD(PORT_RW_ADDR),
		.WE(PORT_RW_WR_EN),
		.WCLK(PORT_RW_CLK),
	);
else
	RAM32M16
	#(
		.INIT_H(init_slice2(0)),
		.INIT_G(init_slice2(1)),
		.INIT_F(init_slice2(2)),
		.INIT_E(init_slice2(3)),
		.INIT_D(init_slice2(4)),
		.INIT_C(init_slice2(5)),
		.INIT_B(init_slice2(6)),
		.INIT_A(init_slice2(7)),
	)
	_TECHMAP_REPLACE_
	(
		.DOA(PORT_RW_RD_DATA[15:14]),
		.DOB(PORT_RW_RD_DATA[13:12]),
		.DOC(PORT_RW_RD_DATA[11:10]),
		.DOD(PORT_RW_RD_DATA[9:8]),
		.DOE(PORT_RW_RD_DATA[7:6]),
		.DOF(PORT_RW_RD_DATA[5:4]),
		.DOG(PORT_RW_RD_DATA[3:2]),
		.DOH(PORT_RW_RD_DATA[1:0]),
		.DIA(PORT_RW_WR_DATA[15:14]),
		.DIB(PORT_RW_WR_DATA[13:12]),
		.DIC(PORT_RW_WR_DATA[11:10]),
		.DID(PORT_RW_WR_DATA[9:8]),
		.DIE(PORT_RW_WR_DATA[7:6]),
		.DIF(PORT_RW_WR_DATA[5:4]),
		.DIG(PORT_RW_WR_DATA[3:2]),
		.DIH(PORT_RW_WR_DATA[1:0]),
		.ADDRA(PORT_RW_ADDR),
		.ADDRB(PORT_RW_ADDR),
		.ADDRC(PORT_RW_ADDR),
		.ADDRD(PORT_RW_ADDR),
		.ADDRE(PORT_RW_ADDR),
		.ADDRF(PORT_RW_ADDR),
		.ADDRG(PORT_RW_ADDR),
		.ADDRH(PORT_RW_ADDR),
		.WE(PORT_RW_WR_EN),
		.WCLK(PORT_RW_CLK),
	);
6: begin
	genvar i;
	for (i = 0; i < WIDTH; i = i + 1)
		if (BITS_USED[i])
			RAM64X1S
			#(
				.INIT(init_slice(i)),
			)
			slice
			(
				.A0(PORT_RW_ADDR[0]),
				.A1(PORT_RW_ADDR[1]),
				.A2(PORT_RW_ADDR[2]),
				.A3(PORT_RW_ADDR[3]),
				.A4(PORT_RW_ADDR[4]),
				.A5(PORT_RW_ADDR[5]),
				.D(PORT_RW_WR_DATA[i]),
				.O(PORT_RW_RD_DATA[i]),
				.WE(PORT_RW_WR_EN),
				.WCLK(PORT_RW_CLK),
			);
end
7: begin
	genvar i;
	for (i = 0; i < WIDTH; i = i + 1)
		if (BITS_USED[i])
			RAM128X1S
			#(
				.INIT(init_slice(i)),
			)
			slice
			(
				.A0(PORT_RW_ADDR[0]),
				.A1(PORT_RW_ADDR[1]),
				.A2(PORT_RW_ADDR[2]),
				.A3(PORT_RW_ADDR[3]),
				.A4(PORT_RW_ADDR[4]),
				.A5(PORT_RW_ADDR[5]),
				.A6(PORT_RW_ADDR[6]),
				.D(PORT_RW_WR_DATA[i]),
				.O(PORT_RW_RD_DATA[i]),
				.WE(PORT_RW_WR_EN),
				.WCLK(PORT_RW_CLK),
			);
end
8: begin
	genvar i;
	for (i = 0; i < WIDTH; i = i + 1)
		if (BITS_USED[i])
			RAM256X1S
			#(
				.INIT(init_slice(i)),
			)
			slice
			(
				.A(PORT_RW_ADDR),
				.D(PORT_RW_WR_DATA[i]),
				.O(PORT_RW_RD_DATA[i]),
				.WE(PORT_RW_WR_EN),
				.WCLK(PORT_RW_CLK),
			);
end
9: begin
	genvar i;
	for (i = 0; i < WIDTH; i = i + 1)
		if (BITS_USED[i])
			RAM512X1S
			#(
				.INIT(init_slice(i)),
			)
			slice
			(
				.A(PORT_RW_ADDR),
				.D(PORT_RW_WR_DATA[i]),
				.O(PORT_RW_RD_DATA[i]),
				.WE(PORT_RW_WR_EN),
				.WCLK(PORT_RW_CLK),
			);
end
default:
	$error("invalid OPTION_ABITS/WIDTH combination");
endcase
endgenerate

endmodule


module $__XILINX_LUTRAM_DP_ (...);

parameter INIT = 0;
parameter OPTION_ABITS = 5;
parameter WIDTH = 4;
parameter BITS_USED = 0;

output [WIDTH-1:0] PORT_RW_RD_DATA;
input [WIDTH-1:0] PORT_RW_WR_DATA;
input [OPTION_ABITS-1:0] PORT_RW_ADDR;
input PORT_RW_WR_EN;
input PORT_RW_CLK;

output [WIDTH-1:0] PORT_R_RD_DATA;
input [OPTION_ABITS-1:0] PORT_R_ADDR;

function [(1 << OPTION_ABITS)-1:0] init_slice;
	input integer idx;
	integer i;
	for (i = 0; i < (1 << OPTION_ABITS); i = i + 1)
		init_slice[i] = INIT[i * WIDTH + idx];
endfunction

function [(2 << OPTION_ABITS)-1:0] init_slice2;
	input integer idx;
	integer i;
	for (i = 0; i < (1 << OPTION_ABITS); i = i + 1)
		init_slice2[2 * i +: 2] = INIT[i * WIDTH + idx * 2 +: 2];
endfunction

generate
case (OPTION_ABITS)
5: if (WIDTH == 4)
	RAM32M
	#(
		.INIT_D(init_slice2(0)),
		.INIT_C(init_slice2(0)),
		.INIT_B(init_slice2(1)),
		.INIT_A(init_slice2(1)),
	)
	_TECHMAP_REPLACE_
	(
		.DOA(PORT_R_RD_DATA[3:2]),
		.DOB(PORT_RW_RD_DATA[3:2]),
		.DOC(PORT_R_RD_DATA[1:0]),
		.DOD(PORT_RW_RD_DATA[1:0]),
		.DIA(PORT_RW_WR_DATA[3:2]),
		.DIB(PORT_RW_WR_DATA[3:2]),
		.DIC(PORT_RW_WR_DATA[1:0]),
		.DID(PORT_RW_WR_DATA[1:0]),
		.ADDRA(PORT_R_ADDR),
		.ADDRB(PORT_RW_ADDR),
		.ADDRC(PORT_R_ADDR),
		.ADDRD(PORT_RW_ADDR),
		.WE(PORT_RW_WR_EN),
		.WCLK(PORT_RW_CLK),
	);
else
	RAM32M16
	#(
		.INIT_H(init_slice2(0)),
		.INIT_G(init_slice2(0)),
		.INIT_F(init_slice2(1)),
		.INIT_E(init_slice2(1)),
		.INIT_D(init_slice2(2)),
		.INIT_C(init_slice2(2)),
		.INIT_B(init_slice2(3)),
		.INIT_A(init_slice2(3)),
	)
	_TECHMAP_REPLACE_
	(
		.DOA(PORT_R_RD_DATA[7:6]),
		.DOB(PORT_RW_RD_DATA[7:6]),
		.DOC(PORT_R_RD_DATA[5:4]),
		.DOD(PORT_RW_RD_DATA[5:4]),
		.DOE(PORT_R_RD_DATA[3:2]),
		.DOF(PORT_RW_RD_DATA[3:2]),
		.DOG(PORT_R_RD_DATA[1:0]),
		.DOH(PORT_RW_RD_DATA[1:0]),
		.DIA(PORT_RW_WR_DATA[7:6]),
		.DIB(PORT_RW_WR_DATA[7:6]),
		.DIC(PORT_RW_WR_DATA[5:4]),
		.DID(PORT_RW_WR_DATA[5:4]),
		.DIE(PORT_RW_WR_DATA[3:2]),
		.DIF(PORT_RW_WR_DATA[3:2]),
		.DIG(PORT_RW_WR_DATA[1:0]),
		.DIH(PORT_RW_WR_DATA[1:0]),
		.ADDRA(PORT_R_ADDR),
		.ADDRB(PORT_RW_ADDR),
		.ADDRC(PORT_R_ADDR),
		.ADDRD(PORT_RW_ADDR),
		.ADDRE(PORT_R_ADDR),
		.ADDRF(PORT_RW_ADDR),
		.ADDRG(PORT_R_ADDR),
		.ADDRH(PORT_RW_ADDR),
		.WE(PORT_RW_WR_EN),
		.WCLK(PORT_RW_CLK),
	);
6: begin
	genvar i;
	for (i = 0; i < WIDTH; i = i + 1)
		if (BITS_USED[i])
			RAM64X1D
			#(
				.INIT(init_slice(i)),
			)
			slice
			(
				.A0(PORT_RW_ADDR[0]),
				.A1(PORT_RW_ADDR[1]),
				.A2(PORT_RW_ADDR[2]),
				.A3(PORT_RW_ADDR[3]),
				.A4(PORT_RW_ADDR[4]),
				.A5(PORT_RW_ADDR[5]),
				.D(PORT_RW_WR_DATA[i]),
				.SPO(PORT_RW_RD_DATA[i]),
				.WE(PORT_RW_WR_EN),
				.WCLK(PORT_RW_CLK),
				.DPRA0(PORT_R_ADDR[0]),
				.DPRA1(PORT_R_ADDR[1]),
				.DPRA2(PORT_R_ADDR[2]),
				.DPRA3(PORT_R_ADDR[3]),
				.DPRA4(PORT_R_ADDR[4]),
				.DPRA5(PORT_R_ADDR[5]),
				.DPO(PORT_R_RD_DATA[i]),
			);
end
7: begin
	genvar i;
	for (i = 0; i < WIDTH; i = i + 1)
		if (BITS_USED[i])
			RAM128X1D
			#(
				.INIT(init_slice(i)),
			)
			slice
			(
				.A(PORT_RW_ADDR),
				.D(PORT_RW_WR_DATA[i]),
				.SPO(PORT_RW_RD_DATA[i]),
				.WE(PORT_RW_WR_EN),
				.WCLK(PORT_RW_CLK),
				.DPRA(PORT_R_ADDR),
				.DPO(PORT_R_RD_DATA[i]),
			);
end
8: begin
	genvar i;
	for (i = 0; i < WIDTH; i = i + 1)
		if (BITS_USED[i])
			RAM256X1D
			#(
				.INIT(init_slice(i)),
			)
			slice
			(
				.A(PORT_RW_ADDR),
				.D(PORT_RW_WR_DATA[i]),
				.SPO(PORT_RW_RD_DATA[i]),
				.WE(PORT_RW_WR_EN),
				.WCLK(PORT_RW_CLK),
				.DPRA(PORT_R_ADDR),
				.DPO(PORT_R_RD_DATA[i]),
			);
end
default:
	$error("invalid OPTION_ABITS/WIDTH combination");
endcase
endgenerate

endmodule


module $__XILINX_LUTRAM_QP_ (...);

parameter INIT = 0;
parameter OPTION_ABITS = 5;
parameter WIDTH = 2;
parameter BITS_USED = 0;

output [WIDTH-1:0] PORT_RW_RD_DATA;
input [WIDTH-1:0] PORT_RW_WR_DATA;
input [OPTION_ABITS-1:0] PORT_RW_ADDR;
input PORT_RW_WR_EN;
input PORT_RW_CLK;

output [WIDTH-1:0] PORT_R0_RD_DATA;
input [OPTION_ABITS-1:0] PORT_R0_ADDR;
output [WIDTH-1:0] PORT_R1_RD_DATA;
input [OPTION_ABITS-1:0] PORT_R1_ADDR;
output [WIDTH-1:0] PORT_R2_RD_DATA;
input [OPTION_ABITS-1:0] PORT_R2_ADDR;

function [(1 << OPTION_ABITS)-1:0] init_slice;
	input integer idx;
	integer i;
	for (i = 0; i < (1 << OPTION_ABITS); i = i + 1)
		init_slice[i] = INIT[i * WIDTH + idx];
endfunction

function [(2 << OPTION_ABITS)-1:0] init_slice2;
	input integer idx;
	integer i;
	for (i = 0; i < (1 << OPTION_ABITS); i = i + 1)
		init_slice2[2 * i +: 2] = INIT[i * WIDTH + idx * 2 +: 2];
endfunction

generate
case (OPTION_ABITS)
5: if (WIDTH == 2)
	RAM32M
	#(
		.INIT_D(init_slice2(0)),
		.INIT_C(init_slice2(0)),
		.INIT_B(init_slice2(0)),
		.INIT_A(init_slice2(0)),
	)
	_TECHMAP_REPLACE_
	(
		.DOA(PORT_R2_RD_DATA[1:0]),
		.DOB(PORT_R1_RD_DATA[1:0]),
		.DOC(PORT_R0_RD_DATA[1:0]),
		.DOD(PORT_RW_RD_DATA[1:0]),
		.DIA(PORT_RW_WR_DATA[1:0]),
		.DIB(PORT_RW_WR_DATA[1:0]),
		.DIC(PORT_RW_WR_DATA[1:0]),
		.DID(PORT_RW_WR_DATA[1:0]),
		.ADDRA(PORT_R2_ADDR),
		.ADDRB(PORT_R1_ADDR),
		.ADDRC(PORT_R0_ADDR),
		.ADDRD(PORT_RW_ADDR),
		.WE(PORT_RW_WR_EN),
		.WCLK(PORT_RW_CLK),
	);
else
	RAM32M16
	#(
		.INIT_H(init_slice2(0)),
		.INIT_G(init_slice2(0)),
		.INIT_F(init_slice2(0)),
		.INIT_E(init_slice2(0)),
		.INIT_D(init_slice2(1)),
		.INIT_C(init_slice2(1)),
		.INIT_B(init_slice2(1)),
		.INIT_A(init_slice2(1)),
	)
	_TECHMAP_REPLACE_
	(
		.DOA(PORT_R2_RD_DATA[3:2]),
		.DOB(PORT_R1_RD_DATA[3:2]),
		.DOC(PORT_R0_RD_DATA[3:2]),
		.DOD(PORT_RW_RD_DATA[3:2]),
		.DOE(PORT_R2_RD_DATA[1:0]),
		.DOF(PORT_R1_RD_DATA[1:0]),
		.DOG(PORT_R0_RD_DATA[1:0]),
		.DOH(PORT_RW_RD_DATA[1:0]),
		.DIA(PORT_RW_WR_DATA[3:2]),
		.DIB(PORT_RW_WR_DATA[3:2]),
		.DIC(PORT_RW_WR_DATA[3:2]),
		.DID(PORT_RW_WR_DATA[3:2]),
		.DIE(PORT_RW_WR_DATA[1:0]),
		.DIF(PORT_RW_WR_DATA[1:0]),
		.DIG(PORT_RW_WR_DATA[1:0]),
		.DIH(PORT_RW_WR_DATA[1:0]),
		.ADDRA(PORT_R2_ADDR),
		.ADDRB(PORT_R1_ADDR),
		.ADDRC(PORT_R0_ADDR),
		.ADDRD(PORT_RW_ADDR),
		.ADDRE(PORT_R2_ADDR),
		.ADDRF(PORT_R1_ADDR),
		.ADDRG(PORT_R0_ADDR),
		.ADDRH(PORT_RW_ADDR),
		.WE(PORT_RW_WR_EN),
		.WCLK(PORT_RW_CLK),
	);
6: if (WIDTH == 1)
	RAM64M
	#(
		.INIT_D(init_slice(0)),
		.INIT_C(init_slice(0)),
		.INIT_B(init_slice(0)),
		.INIT_A(init_slice(0)),
	)
	_TECHMAP_REPLACE_
	(
		.DOA(PORT_R2_RD_DATA[0]),
		.DOB(PORT_R1_RD_DATA[0]),
		.DOC(PORT_R0_RD_DATA[0]),
		.DOD(PORT_RW_RD_DATA[0]),
		.DIA(PORT_RW_WR_DATA[0]),
		.DIB(PORT_RW_WR_DATA[0]),
		.DIC(PORT_RW_WR_DATA[0]),
		.DID(PORT_RW_WR_DATA[0]),
		.ADDRA(PORT_R2_ADDR),
		.ADDRB(PORT_R1_ADDR),
		.ADDRC(PORT_R0_ADDR),
		.ADDRD(PORT_RW_ADDR),
		.WE(PORT_RW_WR_EN),
		.WCLK(PORT_RW_CLK),
	);
else
	RAM64M8
	#(
		.INIT_H(init_slice(0)),
		.INIT_G(init_slice(0)),
		.INIT_F(init_slice(0)),
		.INIT_E(init_slice(0)),
		.INIT_D(init_slice(1)),
		.INIT_C(init_slice(1)),
		.INIT_B(init_slice(1)),
		.INIT_A(init_slice(1)),
	)
	_TECHMAP_REPLACE_
	(
		.DOA(PORT_R2_RD_DATA[1]),
		.DOB(PORT_R1_RD_DATA[1]),
		.DOC(PORT_R0_RD_DATA[1]),
		.DOD(PORT_RW_RD_DATA[1]),
		.DOE(PORT_R2_RD_DATA[0]),
		.DOF(PORT_R1_RD_DATA[0]),
		.DOG(PORT_R0_RD_DATA[0]),
		.DOH(PORT_RW_RD_DATA[0]),
		.DIA(PORT_RW_WR_DATA[1]),
		.DIB(PORT_RW_WR_DATA[1]),
		.DIC(PORT_RW_WR_DATA[1]),
		.DID(PORT_RW_WR_DATA[1]),
		.DIE(PORT_RW_WR_DATA[0]),
		.DIF(PORT_RW_WR_DATA[0]),
		.DIG(PORT_RW_WR_DATA[0]),
		.DIH(PORT_RW_WR_DATA[0]),
		.ADDRA(PORT_R2_ADDR),
		.ADDRB(PORT_R1_ADDR),
		.ADDRC(PORT_R0_ADDR),
		.ADDRD(PORT_RW_ADDR),
		.ADDRE(PORT_R2_ADDR),
		.ADDRF(PORT_R1_ADDR),
		.ADDRG(PORT_R0_ADDR),
		.ADDRH(PORT_RW_ADDR),
		.WE(PORT_RW_WR_EN),
		.WCLK(PORT_RW_CLK),
	);
default:
	$error("invalid OPTION_ABITS/WIDTH combination");
endcase
endgenerate

endmodule


module $__XILINX_LUTRAM_OP_ (...);

parameter INIT = 0;
parameter OPTION_ABITS = 5;
parameter WIDTH = 2;
parameter BITS_USED = 0;

output [WIDTH-1:0] PORT_RW_RD_DATA;
input [WIDTH-1:0] PORT_RW_WR_DATA;
input [OPTION_ABITS-1:0] PORT_RW_ADDR;
input PORT_RW_WR_EN;
input PORT_RW_CLK;

output [WIDTH-1:0] PORT_R0_RD_DATA;
input [OPTION_ABITS-1:0] PORT_R0_ADDR;
output [WIDTH-1:0] PORT_R1_RD_DATA;
input [OPTION_ABITS-1:0] PORT_R1_ADDR;
output [WIDTH-1:0] PORT_R2_RD_DATA;
input [OPTION_ABITS-1:0] PORT_R2_ADDR;
output [WIDTH-1:0] PORT_R3_RD_DATA;
input [OPTION_ABITS-1:0] PORT_R3_ADDR;
output [WIDTH-1:0] PORT_R4_RD_DATA;
input [OPTION_ABITS-1:0] PORT_R4_ADDR;
output [WIDTH-1:0] PORT_R5_RD_DATA;
input [OPTION_ABITS-1:0] PORT_R5_ADDR;
output [WIDTH-1:0] PORT_R6_RD_DATA;
input [OPTION_ABITS-1:0] PORT_R6_ADDR;

generate
case (OPTION_ABITS)
5:	RAM32M16
	#(
		.INIT_H(INIT),
		.INIT_G(INIT),
		.INIT_F(INIT),
		.INIT_E(INIT),
		.INIT_D(INIT),
		.INIT_C(INIT),
		.INIT_B(INIT),
		.INIT_A(INIT),
	)
	_TECHMAP_REPLACE_
	(
		.DOA(PORT_R6_RD_DATA),
		.DOB(PORT_R5_RD_DATA),
		.DOC(PORT_R4_RD_DATA),
		.DOD(PORT_R3_RD_DATA),
		.DOE(PORT_R2_RD_DATA),
		.DOF(PORT_R1_RD_DATA),
		.DOG(PORT_R0_RD_DATA),
		.DOH(PORT_RW_RD_DATA),
		.DIA(PORT_RW_WR_DATA),
		.DIB(PORT_RW_WR_DATA),
		.DIC(PORT_RW_WR_DATA),
		.DID(PORT_RW_WR_DATA),
		.DIE(PORT_RW_WR_DATA),
		.DIF(PORT_RW_WR_DATA),
		.DIG(PORT_RW_WR_DATA),
		.DIH(PORT_RW_WR_DATA),
		.ADDRA(PORT_R6_ADDR),
		.ADDRB(PORT_R5_ADDR),
		.ADDRC(PORT_R4_ADDR),
		.ADDRD(PORT_R3_ADDR),
		.ADDRE(PORT_R2_ADDR),
		.ADDRF(PORT_R1_ADDR),
		.ADDRG(PORT_R0_ADDR),
		.ADDRH(PORT_RW_ADDR),
		.WE(PORT_RW_WR_EN),
		.WCLK(PORT_RW_CLK),
	);
6:	RAM64M8
	#(
		.INIT_H(INIT),
		.INIT_G(INIT),
		.INIT_F(INIT),
		.INIT_E(INIT),
		.INIT_D(INIT),
		.INIT_C(INIT),
		.INIT_B(INIT),
		.INIT_A(INIT),
	)
	_TECHMAP_REPLACE_
	(
		.DOA(PORT_R6_RD_DATA),
		.DOB(PORT_R5_RD_DATA),
		.DOC(PORT_R4_RD_DATA),
		.DOD(PORT_R3_RD_DATA),
		.DOE(PORT_R2_RD_DATA),
		.DOF(PORT_R1_RD_DATA),
		.DOG(PORT_R0_RD_DATA),
		.DOH(PORT_RW_RD_DATA),
		.DIA(PORT_RW_WR_DATA),
		.DIB(PORT_RW_WR_DATA),
		.DIC(PORT_RW_WR_DATA),
		.DID(PORT_RW_WR_DATA),
		.DIE(PORT_RW_WR_DATA),
		.DIF(PORT_RW_WR_DATA),
		.DIG(PORT_RW_WR_DATA),
		.DIH(PORT_RW_WR_DATA),
		.ADDRA(PORT_R6_ADDR),
		.ADDRB(PORT_R5_ADDR),
		.ADDRC(PORT_R4_ADDR),
		.ADDRD(PORT_R3_ADDR),
		.ADDRE(PORT_R2_ADDR),
		.ADDRF(PORT_R1_ADDR),
		.ADDRG(PORT_R0_ADDR),
		.ADDRH(PORT_RW_ADDR),
		.WE(PORT_RW_WR_EN),
		.WCLK(PORT_RW_CLK),
	);
default:
	$error("invalid OPTION_ABITS/WIDTH combination");
endcase
endgenerate

endmodule


module $__XILINX_LUTRAM_SDP_ (...);

parameter INIT = 0;
parameter OPTION_ABITS = 5;
parameter WIDTH = 6;
parameter BITS_USED = 0;

input [WIDTH-1:0] PORT_W_WR_DATA;
input [OPTION_ABITS-1:0] PORT_W_ADDR;
input PORT_W_WR_EN;
input PORT_W_CLK;

output [WIDTH-1:0] PORT_R_RD_DATA;
input [OPTION_ABITS-1:0] PORT_R_ADDR;

function [(1 << OPTION_ABITS)-1:0] init_slice;
	input integer idx;
	integer i;
	for (i = 0; i < (1 << OPTION_ABITS); i = i + 1)
		init_slice[i] = INIT[i * WIDTH + idx];
endfunction

function [(2 << OPTION_ABITS)-1:0] init_slice2;
	input integer idx;
	integer i;
	for (i = 0; i < (1 << OPTION_ABITS); i = i + 1)
		init_slice2[2 * i +: 2] = INIT[i * WIDTH + idx * 2 +: 2];
endfunction

generate
case (OPTION_ABITS)
5: if (WIDTH == 6)
	RAM32M
	#(
		.INIT_C(init_slice2(0)),
		.INIT_B(init_slice2(1)),
		.INIT_A(init_slice2(2)),
	)
	_TECHMAP_REPLACE_
	(
		.DOA(PORT_R_RD_DATA[5:4]),
		.DOB(PORT_R_RD_DATA[3:2]),
		.DOC(PORT_R_RD_DATA[1:0]),
		.DIA(PORT_W_WR_DATA[5:4]),
		.DIB(PORT_W_WR_DATA[3:2]),
		.DIC(PORT_W_WR_DATA[1:0]),
		.ADDRA(PORT_R_ADDR),
		.ADDRB(PORT_R_ADDR),
		.ADDRC(PORT_R_ADDR),
		.ADDRD(PORT_W_ADDR),
		.WE(PORT_W_WR_EN),
		.WCLK(PORT_W_CLK),
	);
else
	RAM32M16
	#(
		.INIT_G(init_slice2(0)),
		.INIT_F(init_slice2(1)),
		.INIT_E(init_slice2(2)),
		.INIT_D(init_slice2(3)),
		.INIT_C(init_slice2(4)),
		.INIT_B(init_slice2(5)),
		.INIT_A(init_slice2(6)),
	)
	_TECHMAP_REPLACE_
	(
		.DOA(PORT_R_RD_DATA[13:12]),
		.DOB(PORT_R_RD_DATA[11:10]),
		.DOC(PORT_R_RD_DATA[9:8]),
		.DOD(PORT_R_RD_DATA[7:6]),
		.DOE(PORT_R_RD_DATA[5:4]),
		.DOF(PORT_R_RD_DATA[3:2]),
		.DOG(PORT_R_RD_DATA[1:0]),
		.DIA(PORT_W_WR_DATA[13:12]),
		.DIB(PORT_W_WR_DATA[11:10]),
		.DIC(PORT_W_WR_DATA[9:8]),
		.DID(PORT_W_WR_DATA[7:6]),
		.DIE(PORT_W_WR_DATA[5:4]),
		.DIF(PORT_W_WR_DATA[3:2]),
		.DIG(PORT_W_WR_DATA[1:0]),
		.ADDRA(PORT_R_ADDR),
		.ADDRB(PORT_R_ADDR),
		.ADDRC(PORT_R_ADDR),
		.ADDRD(PORT_R_ADDR),
		.ADDRE(PORT_R_ADDR),
		.ADDRF(PORT_R_ADDR),
		.ADDRG(PORT_R_ADDR),
		.ADDRH(PORT_W_ADDR),
		.WE(PORT_W_WR_EN),
		.WCLK(PORT_W_CLK),
	);
6: if (WIDTH == 3)
	RAM64M
	#(
		.INIT_C(init_slice(0)),
		.INIT_B(init_slice(1)),
		.INIT_A(init_slice(2)),
	)
	_TECHMAP_REPLACE_
	(
		.DOA(PORT_R_RD_DATA[2]),
		.DOB(PORT_R_RD_DATA[1]),
		.DOC(PORT_R_RD_DATA[0]),
		.DIA(PORT_W_WR_DATA[2]),
		.DIB(PORT_W_WR_DATA[1]),
		.DIC(PORT_W_WR_DATA[0]),
		.ADDRA(PORT_R_ADDR),
		.ADDRB(PORT_R_ADDR),
		.ADDRC(PORT_R_ADDR),
		.ADDRD(PORT_W_ADDR),
		.WE(PORT_W_WR_EN),
		.WCLK(PORT_W_CLK),
	);
else
	RAM64M8
	#(
		.INIT_G(init_slice(0)),
		.INIT_F(init_slice(1)),
		.INIT_E(init_slice(2)),
		.INIT_D(init_slice(3)),
		.INIT_C(init_slice(4)),
		.INIT_B(init_slice(5)),
		.INIT_A(init_slice(6)),
	)
	_TECHMAP_REPLACE_
	(
		.DOA(PORT_R_RD_DATA[6]),
		.DOB(PORT_R_RD_DATA[5]),
		.DOC(PORT_R_RD_DATA[4]),
		.DOD(PORT_R_RD_DATA[3]),
		.DOE(PORT_R_RD_DATA[2]),
		.DOF(PORT_R_RD_DATA[1]),
		.DOG(PORT_R_RD_DATA[0]),
		.DIA(PORT_W_WR_DATA[6]),
		.DIB(PORT_W_WR_DATA[5]),
		.DIC(PORT_W_WR_DATA[4]),
		.DID(PORT_W_WR_DATA[3]),
		.DIE(PORT_W_WR_DATA[2]),
		.DIF(PORT_W_WR_DATA[1]),
		.DIG(PORT_W_WR_DATA[0]),
		.ADDRA(PORT_R_ADDR),
		.ADDRB(PORT_R_ADDR),
		.ADDRC(PORT_R_ADDR),
		.ADDRD(PORT_R_ADDR),
		.ADDRE(PORT_R_ADDR),
		.ADDRF(PORT_R_ADDR),
		.ADDRG(PORT_R_ADDR),
		.ADDRH(PORT_W_ADDR),
		.WE(PORT_W_WR_EN),
		.WCLK(PORT_W_CLK),
	);
default:
	$error("invalid OPTION_ABITS/WIDTH combination");
endcase
endgenerate

endmodule


module $__XILINX_LUTRAM_64X8SW_ (...);

parameter INIT = 0;
parameter OPTION_ABITS = 9;
parameter PORT_RW_WR_WIDTH = 1;
parameter PORT_RW_RD_WIDTH = 8;

output [PORT_RW_RD_WIDTH-1:0] PORT_RW_RD_DATA;
input [PORT_RW_WR_WIDTH-1:0] PORT_RW_WR_DATA;
input [OPTION_ABITS-1:0] PORT_RW_ADDR;
input PORT_RW_WR_EN;
input PORT_RW_CLK;

function [63:0] init_slice;
	input integer idx;
	integer i;
	for (i = 0; i < 64; i = i + 1)
		init_slice[i] = INIT[i * 8 + idx];
endfunction

RAM64X8SW
#(
	.INIT_A(init_slice(7)),
	.INIT_B(init_slice(6)),
	.INIT_C(init_slice(5)),
	.INIT_D(init_slice(4)),
	.INIT_E(init_slice(3)),
	.INIT_F(init_slice(2)),
	.INIT_G(init_slice(1)),
	.INIT_H(init_slice(0)),
)
_TECHMAP_REPLACE_
(
	.A(PORT_RW_ADDR[8:3]),
	.WSEL(PORT_RW_ADDR[2:0]),
	.D(PORT_RW_WR_DATA),
	.O(PORT_RW_RD_DATA),
	.WE(PORT_RW_WR_EN),
	.WCLK(PORT_RW_CLK),
);

endmodule


module $__XILINX_LUTRAM_32X16DR8_ (...);

parameter OPTION_ABITS = 6;
parameter BITS_USED = 0;
parameter PORT_W_WIDTH = 14;
parameter PORT_R_WIDTH = 7;

input [PORT_W_WIDTH-1:0] PORT_W_WR_DATA;
input [OPTION_ABITS-1:0] PORT_W_ADDR;
input PORT_W_WR_EN;
input PORT_W_CLK;

output [PORT_R_WIDTH-1:0] PORT_R_RD_DATA;
input [OPTION_ABITS-1:0] PORT_R_ADDR;

RAM32X16DR8 _TECHMAP_REPLACE_
(
	.DOA(PORT_R_RD_DATA[6]),
	.DOB(PORT_R_RD_DATA[5]),
	.DOC(PORT_R_RD_DATA[4]),
	.DOD(PORT_R_RD_DATA[3]),
	.DOE(PORT_R_RD_DATA[2]),
	.DOF(PORT_R_RD_DATA[1]),
	.DOG(PORT_R_RD_DATA[0]),
	.DIA({PORT_W_WR_DATA[13], PORT_W_WR_DATA[6]}),
	.DIB({PORT_W_WR_DATA[12], PORT_W_WR_DATA[5]}),
	.DIC({PORT_W_WR_DATA[11], PORT_W_WR_DATA[4]}),
	.DID({PORT_W_WR_DATA[10], PORT_W_WR_DATA[3]}),
	.DIE({PORT_W_WR_DATA[9], PORT_W_WR_DATA[2]}),
	.DIF({PORT_W_WR_DATA[8], PORT_W_WR_DATA[1]}),
	.DIG({PORT_W_WR_DATA[7], PORT_W_WR_DATA[0]}),
	.ADDRA(PORT_R_ADDR),
	.ADDRB(PORT_R_ADDR),
	.ADDRC(PORT_R_ADDR),
	.ADDRD(PORT_R_ADDR),
	.ADDRE(PORT_R_ADDR),
	.ADDRF(PORT_R_ADDR),
	.ADDRG(PORT_R_ADDR),
	.ADDRH(PORT_W_ADDR[5:1]),
	.WE(PORT_W_WR_EN),
	.WCLK(PORT_W_CLK),
);

endmodule
`,"lutrams_xcu.txt":`# LUT RAMs for Ultrascale.
# The corresponding mapping file is lutrams_xc5v_map.v

# Single-port RAMs.

ram distributed $__XILINX_LUTRAM_SP_ {
	cost 16;
	widthscale;
	option "ABITS" 5 {
		abits 5;
		widths 16 global;
	}
	option "ABITS" 6 {
		abits 6;
		widths 8 global;
	}
	option "ABITS" 7 {
		abits 7;
		widths 4 global;
	}
	option "ABITS" 8 {
		abits 8;
		widths 2 global;
	}
	option "ABITS" 16 {
		abits 16;
		widths 1 global;
	}
	init any;
	prune_rom;
	port arsw "RW" {
		clock posedge;
	}
}

# Dual-port RAMs.

ram distributed $__XILINX_LUTRAM_DP_ {
	cost 16;
	widthscale;
	option "ABITS" 5 {
		abits 5;
		widths 8 global;
	}
	option "ABITS" 6 {
		abits 6;
		widths 4 global;
	}
	option "ABITS" 7 {
		abits 7;
		widths 2 global;
	}
	option "ABITS" 8 {
		abits 8;
		widths 1 global;
	}
	init any;
	prune_rom;
	port arsw "RW" {
		clock posedge;
	}
	port ar "R" {
	}
}

# Quad-port RAMs.

ram distributed $__XILINX_LUTRAM_QP_ {
	cost 16;
	widthscale;
	option "ABITS" 5 {
		abits 5;
		widths 4 global;
	}
	option "ABITS" 6 {
		abits 6;
		widths 2 global;
	}
	init any;
	prune_rom;
	port arsw "RW" {
		clock posedge;
	}
	port ar "R0" "R1" "R2" {
	}
}

# Octal-port RAMs.

ram distributed $__XILINX_LUTRAM_OP_ {
	cost 16;
	widthscale;
	option "ABITS" 5 {
		abits 5;
		widths 2 global;
	}
	option "ABITS" 6 {
		abits 6;
		widths 1 global;
	}
	init any;
	prune_rom;
	port arsw "RW" {
		clock posedge;
	}
	port ar "R0" "R1" "R2" "R3" "R4" "R5" "R6" {
	}
}

# Simple dual port RAMs.

ram distributed $__XILINX_LUTRAM_SDP_ {
	cost 16;
	widthscale;
	option "ABITS" 5 {
		abits 5;
		widths 14 global;
	}
	option "ABITS" 6 {
		abits 6;
		widths 7 global;
	}
	init any;
	prune_rom;
	port sw "W" {
		clock posedge;
	}
	port ar "R" {
	}
}

# Wide-read RAM.

ram distributed $__XILINX_LUTRAM_64X8SW_ {
	cost 16;
	abits 9;
	widths 1 2 4 8 per_port;
	init any;
	prune_rom;
	port arsw "RW" {
		width rd 8 wr 1;
		clock posedge;
	}
}

# Wide-write RAM.

ram distributed $__XILINX_LUTRAM_32X16DR8_ {
	cost 16;
	widthscale;
	abits 6;
	widths 7 14 per_port;
	# Yes, no initialization capability.
	prune_rom;
	port sw "W" {
		width 14;
		clock posedge;
	}
	port ar "R" {
		width 7;
	}
}
`,"lutrams_xcv.txt":`# LUT RAMs for Virtex, Virtex 2, Spartan 3, Virtex 4.
# The corresponding mapping file is lutrams_xcv_map.v

ram distributed $__XILINX_LUTRAM_SP_ {
	width 1;
	option "ABITS" 4 {
		abits 4;
		cost 3;
	}
	option "ABITS" 5 {
		abits 5;
		cost 5;
	}
	ifndef IS_VIRTEX {
		option "ABITS" 6 {
			abits 6;
			cost 9;
		}
	}
	ifdef IS_VIRTEX2 {
		# RAM128X1S
		option "ABITS" 7 {
			abits 7;
			cost 17;
		}
	}
	init no_undef;
	prune_rom;
	port arsw "RW" {
		clock posedge;
	}
}

ram distributed $__XILINX_LUTRAM_DP_ {
	width 1;
	option "ABITS" 4 {
		abits 4;
		cost 5;
	}
	ifdef IS_VIRTEX2 {
		# RAM32X1D
		option "ABITS" 5 {
			abits 5;
			cost 9;
		}
		# RAM64X1D
		option "ABITS" 6 {
			abits 6;
			cost 17;
		}
	}
	init no_undef;
	prune_rom;
	port arsw "RW" {
		clock posedge;
	}
	port ar "R" {
	}
}
`,"lutrams_xcv_map.v":`// LUT RAMs for Virtex, Virtex 2, Spartan 3, Virtex 4.
// The corresponding definition file is lutrams_xcv.txt

module $__XILINX_LUTRAM_SP_ (...);

parameter INIT = 0;
parameter OPTION_ABITS = 4;

output PORT_RW_RD_DATA;
input PORT_RW_WR_DATA;
input [OPTION_ABITS-1:0] PORT_RW_ADDR;
input PORT_RW_WR_EN;
input PORT_RW_CLK;

generate
case(OPTION_ABITS)
4: RAM16X1S
	#(
		.INIT(INIT),
	)
	_TECHMAP_REPLACE_
	(
		.A0(PORT_RW_ADDR[0]),
		.A1(PORT_RW_ADDR[1]),
		.A2(PORT_RW_ADDR[2]),
		.A3(PORT_RW_ADDR[3]),
		.D(PORT_RW_WR_DATA),
		.O(PORT_RW_RD_DATA),
		.WE(PORT_RW_WR_EN),
		.WCLK(PORT_RW_CLK),
	);
5: RAM32X1S
	#(
		.INIT(INIT),
	)
	_TECHMAP_REPLACE_
	(
		.A0(PORT_RW_ADDR[0]),
		.A1(PORT_RW_ADDR[1]),
		.A2(PORT_RW_ADDR[2]),
		.A3(PORT_RW_ADDR[3]),
		.A4(PORT_RW_ADDR[4]),
		.D(PORT_RW_WR_DATA),
		.O(PORT_RW_RD_DATA),
		.WE(PORT_RW_WR_EN),
		.WCLK(PORT_RW_CLK),
	);
6: RAM64X1S
	#(
		.INIT(INIT),
	)
	_TECHMAP_REPLACE_
	(
		.A0(PORT_RW_ADDR[0]),
		.A1(PORT_RW_ADDR[1]),
		.A2(PORT_RW_ADDR[2]),
		.A3(PORT_RW_ADDR[3]),
		.A4(PORT_RW_ADDR[4]),
		.A5(PORT_RW_ADDR[5]),
		.D(PORT_RW_WR_DATA),
		.O(PORT_RW_RD_DATA),
		.WE(PORT_RW_WR_EN),
		.WCLK(PORT_RW_CLK),
	);
7: RAM128X1S
	#(
		.INIT(INIT),
	)
	_TECHMAP_REPLACE_
	(
		.A0(PORT_RW_ADDR[0]),
		.A1(PORT_RW_ADDR[1]),
		.A2(PORT_RW_ADDR[2]),
		.A3(PORT_RW_ADDR[3]),
		.A4(PORT_RW_ADDR[4]),
		.A5(PORT_RW_ADDR[5]),
		.A6(PORT_RW_ADDR[6]),
		.D(PORT_RW_WR_DATA),
		.O(PORT_RW_RD_DATA),
		.WE(PORT_RW_WR_EN),
		.WCLK(PORT_RW_CLK),
	);
default:
	$error("invalid OPTION_ABITS");
endcase
endgenerate

endmodule

module $__XILINX_LUTRAM_DP_ (...);

parameter INIT = 0;
parameter OPTION_ABITS = 4;

output PORT_RW_RD_DATA;
input PORT_RW_WR_DATA;
input [OPTION_ABITS-1:0] PORT_RW_ADDR;
input PORT_RW_WR_EN;
input PORT_RW_CLK;

output PORT_R_RD_DATA;
input [OPTION_ABITS-1:0] PORT_R_ADDR;

generate
case (OPTION_ABITS)
4: RAM16X1D
	#(
		.INIT(INIT),
	)
	_TECHMAP_REPLACE_
	(
		.A0(PORT_RW_ADDR[0]),
		.A1(PORT_RW_ADDR[1]),
		.A2(PORT_RW_ADDR[2]),
		.A3(PORT_RW_ADDR[3]),
		.D(PORT_RW_WR_DATA),
		.SPO(PORT_RW_RD_DATA),
		.WE(PORT_RW_WR_EN),
		.WCLK(PORT_RW_CLK),
		.DPRA0(PORT_R_ADDR[0]),
		.DPRA1(PORT_R_ADDR[1]),
		.DPRA2(PORT_R_ADDR[2]),
		.DPRA3(PORT_R_ADDR[3]),
		.DPO(PORT_R_RD_DATA),
	);
5: RAM32X1D
	#(
		.INIT(INIT),
	)
	_TECHMAP_REPLACE_
	(
		.A0(PORT_RW_ADDR[0]),
		.A1(PORT_RW_ADDR[1]),
		.A2(PORT_RW_ADDR[2]),
		.A3(PORT_RW_ADDR[3]),
		.A4(PORT_RW_ADDR[4]),
		.D(PORT_RW_WR_DATA),
		.SPO(PORT_RW_RD_DATA),
		.WE(PORT_RW_WR_EN),
		.WCLK(PORT_RW_CLK),
		.DPRA0(PORT_R_ADDR[0]),
		.DPRA1(PORT_R_ADDR[1]),
		.DPRA2(PORT_R_ADDR[2]),
		.DPRA3(PORT_R_ADDR[3]),
		.DPRA4(PORT_R_ADDR[4]),
		.DPO(PORT_R_RD_DATA),
	);
6: RAM64X1D
	#(
		.INIT(INIT),
	)
	_TECHMAP_REPLACE_
	(
		.A0(PORT_RW_ADDR[0]),
		.A1(PORT_RW_ADDR[1]),
		.A2(PORT_RW_ADDR[2]),
		.A3(PORT_RW_ADDR[3]),
		.A4(PORT_RW_ADDR[4]),
		.A5(PORT_RW_ADDR[5]),
		.D(PORT_RW_WR_DATA),
		.SPO(PORT_RW_RD_DATA),
		.WE(PORT_RW_WR_EN),
		.WCLK(PORT_RW_CLK),
		.DPRA0(PORT_R_ADDR[0]),
		.DPRA1(PORT_R_ADDR[1]),
		.DPRA2(PORT_R_ADDR[2]),
		.DPRA3(PORT_R_ADDR[3]),
		.DPRA4(PORT_R_ADDR[4]),
		.DPRA5(PORT_R_ADDR[5]),
		.DPO(PORT_R_RD_DATA),
	);
default:
	$error("invalid OPTION_ABITS");
endcase
endgenerate

endmodule
`,"mux_map.v":`/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>
 *                2019  Eddie Hung    <eddie@fpgeh.com>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

// The purpose of these mapping rules is to allow preserve all (sufficiently
// wide) $shiftx cells during 'techmap' so that they can be mapped to hard
// resources, rather than being bit-blasted to gates during 'techmap'
// execution

module \\$shiftx (A, B, Y);
  parameter A_SIGNED = 0;
  parameter B_SIGNED = 0;
  parameter A_WIDTH = 1;
  parameter B_WIDTH = 1;
  parameter Y_WIDTH = 1;

  (* force_downto *)
  input [A_WIDTH-1:0] A;
  (* force_downto *)
  input [B_WIDTH-1:0] B;
  (* force_downto *)
  output [Y_WIDTH-1:0] Y;

  parameter [B_WIDTH-1:0] _TECHMAP_CONSTMSK_B_ = 0;
  parameter [B_WIDTH-1:0] _TECHMAP_CONSTVAL_B_ = 0;

  generate
    if (B_SIGNED) begin
      if (_TECHMAP_CONSTMSK_B_[B_WIDTH-1] && (_TECHMAP_CONSTVAL_B_[B_WIDTH-1] == 1'b0 || _TECHMAP_CONSTVAL_B_[B_WIDTH-1] === 1'bx))
        // Optimisation to remove B_SIGNED if sign bit of B is constant-0
        \\$shiftx #(
          .A_SIGNED(A_SIGNED),
          .B_SIGNED(0),
          .A_WIDTH(A_WIDTH),
          .B_WIDTH(B_WIDTH-1'd1),
          .Y_WIDTH(Y_WIDTH)
        ) _TECHMAP_REPLACE_ (
          .A(A), .B(B[B_WIDTH-2:0]), .Y(Y)
        );
      else
        wire _TECHMAP_FAIL_ = 1;
    end
    else begin
      if (((A_WIDTH + Y_WIDTH - 1) / Y_WIDTH) < \`MIN_MUX_INPUTS)
        wire _TECHMAP_FAIL_ = 1;
      else
        \\$__XILINX_SHIFTX #(
          .A_SIGNED(A_SIGNED),
          .B_SIGNED(B_SIGNED),
          .A_WIDTH(A_WIDTH),
          .B_WIDTH(B_WIDTH),
          .Y_WIDTH(Y_WIDTH)
        ) _TECHMAP_REPLACE_ (
          .A(A), .B(B), .Y(Y)
        );
    end
  endgenerate
endmodule
`,"urams.txt":`ram huge $__XILINX_URAM_ {
	abits 12;
	width 72;
	cost 1024;
	option "BYTEWIDTH" 8 byte 8;
	option "BYTEWIDTH" 9 byte 9;
	init zero;
	port srsw "A" {
		clock anyedge "C";
		clken;
		rdwr no_change;
		rdinit zero;
		portoption "RST_MODE" "SYNC" {
			rdsrst zero ungated;
		}
		portoption "RST_MODE" "ASYNC" {
			rdarst zero;
		}
		wrtrans all new;
		wrbe_separate;
	}
	port srsw "B" {
		clock anyedge "C";
		clken;
		rdwr no_change;
		rdinit zero;
		portoption "RST_MODE" "SYNC" {
			rdsrst zero ungated;
		}
		portoption "RST_MODE" "ASYNC" {
			rdarst zero;
		}
		wrtrans all old;
		wrprio "A";
		wrbe_separate;
	}
}
`,"urams_map.v":`module $__XILINX_URAM_ (...);
	parameter OPTION_BYTEWIDTH = 8;
	localparam WR_BE_WIDTH = 72 / OPTION_BYTEWIDTH;

	parameter CLK_C_POL = 1;
	parameter PORT_A_CLK_POL = 1;
	parameter PORT_A_OPTION_RST_MODE = "SYNC";
	parameter PORT_B_CLK_POL = 1;
	parameter PORT_B_OPTION_RST_MODE = "SYNC";

	input CLK_C;

	input PORT_A_CLK;
	input PORT_A_CLK_EN;
	input PORT_A_RD_SRST;
	input PORT_A_RD_ARST;
	input PORT_A_WR_EN;
	input [WR_BE_WIDTH-1:0] PORT_A_WR_BE;
	input [11:0] PORT_A_ADDR;
	input [71:0] PORT_A_WR_DATA;
	output [71:0] PORT_A_RD_DATA;

	input PORT_B_CLK;
	input PORT_B_CLK_EN;
	input PORT_B_RD_SRST;
	input PORT_B_RD_ARST;
	input PORT_B_WR_EN;
	input [WR_BE_WIDTH-1:0] PORT_B_WR_BE;
	input [11:0] PORT_B_ADDR;
	input [71:0] PORT_B_WR_DATA;
	output [71:0] PORT_B_RD_DATA;

	wire [71:0] DIN_A, DIN_B, DOUT_A, DOUT_B;

	generate
		if (OPTION_BYTEWIDTH == 8) begin
			assign DIN_A = PORT_A_WR_DATA;
			assign DIN_B = PORT_B_WR_DATA;
			assign PORT_A_RD_DATA = DOUT_A;
			assign PORT_B_RD_DATA = DOUT_B;
		end else begin
			assign DIN_A = {
				PORT_A_WR_DATA[71],
				PORT_A_WR_DATA[62],
				PORT_A_WR_DATA[53],
				PORT_A_WR_DATA[44],
				PORT_A_WR_DATA[35],
				PORT_A_WR_DATA[26],
				PORT_A_WR_DATA[17],
				PORT_A_WR_DATA[8],
				PORT_A_WR_DATA[70:63],
				PORT_A_WR_DATA[61:54],
				PORT_A_WR_DATA[52:45],
				PORT_A_WR_DATA[43:36],
				PORT_A_WR_DATA[34:27],
				PORT_A_WR_DATA[25:18],
				PORT_A_WR_DATA[16:9],
				PORT_A_WR_DATA[7:0]
			};
			assign DIN_B = {
				PORT_B_WR_DATA[71],
				PORT_B_WR_DATA[62],
				PORT_B_WR_DATA[53],
				PORT_B_WR_DATA[44],
				PORT_B_WR_DATA[35],
				PORT_B_WR_DATA[26],
				PORT_B_WR_DATA[17],
				PORT_B_WR_DATA[8],
				PORT_B_WR_DATA[70:63],
				PORT_B_WR_DATA[61:54],
				PORT_B_WR_DATA[52:45],
				PORT_B_WR_DATA[43:36],
				PORT_B_WR_DATA[34:27],
				PORT_B_WR_DATA[25:18],
				PORT_B_WR_DATA[16:9],
				PORT_B_WR_DATA[7:0]
			};
			assign PORT_A_RD_DATA = {
				DOUT_A[71],
				DOUT_A[63:56],
				DOUT_A[70],
				DOUT_A[55:48],
				DOUT_A[69],
				DOUT_A[47:40],
				DOUT_A[68],
				DOUT_A[39:32],
				DOUT_A[67],
				DOUT_A[31:24],
				DOUT_A[66],
				DOUT_A[23:16],
				DOUT_A[65],
				DOUT_A[15:8],
				DOUT_A[64],
				DOUT_A[7:0]
			};
			assign PORT_B_RD_DATA = {
				DOUT_B[71],
				DOUT_B[63:56],
				DOUT_B[70],
				DOUT_B[55:48],
				DOUT_B[69],
				DOUT_B[47:40],
				DOUT_B[68],
				DOUT_B[39:32],
				DOUT_B[67],
				DOUT_B[31:24],
				DOUT_B[66],
				DOUT_B[23:16],
				DOUT_B[65],
				DOUT_B[15:8],
				DOUT_B[64],
				DOUT_B[7:0]
			};
		end
	endgenerate

	URAM288 #(
		.BWE_MODE_A(OPTION_BYTEWIDTH == 8 ? "PARITY_INDEPENDENT" : "PARITY_INTERLEAVED"),
		.BWE_MODE_B(OPTION_BYTEWIDTH == 8 ? "PARITY_INDEPENDENT" : "PARITY_INTERLEAVED"),
		.EN_AUTO_SLEEP_MODE("FALSE"),
		.IREG_PRE_A("FALSE"),
		.IREG_PRE_B("FALSE"),
		.IS_CLK_INVERTED(!CLK_C_POL),
		.OREG_A("FALSE"),
		.OREG_B("FALSE"),
		.RST_MODE_A(PORT_A_OPTION_RST_MODE),
		.RST_MODE_B(PORT_B_OPTION_RST_MODE),
	) _TECHMAP_REPLACE_ (
		.ADDR_A({11'b0, PORT_A_ADDR}),
		.BWE_A(PORT_A_WR_BE),
		.EN_A(PORT_A_CLK_EN),
		.RDB_WR_A(PORT_A_WR_EN),
		.INJECT_DBITERR_A(1'b0),
		.INJECT_SBITERR_A(1'b0),
		.RST_A(PORT_A_OPTION_RST_MODE == "SYNC" ? PORT_A_RD_SRST : PORT_A_RD_ARST),
		.DIN_A(DIN_A),
		.DOUT_A(DOUT_A),

		.ADDR_B({11'b0, PORT_B_ADDR}),
		.BWE_B(PORT_B_WR_BE),
		.EN_B(PORT_B_CLK_EN),
		.RDB_WR_B(PORT_B_WR_EN),
		.INJECT_DBITERR_B(1'b0),
		.INJECT_SBITERR_B(1'b0),
		.RST_B(PORT_B_OPTION_RST_MODE == "SYNC" ? PORT_B_RD_SRST : PORT_B_RD_ARST),
		.DIN_B(DIN_B),
		.DOUT_B(DOUT_B),

		.CLK(CLK_C),
		.SLEEP(1'b0)
	);
endmodule
`,"xc3s_mult_map.v":`module \\$__MUL18X18 (input [17:0] A, input [17:0] B, output [35:0] Y);
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;
	parameter A_WIDTH = 0;
	parameter B_WIDTH = 0;
	parameter Y_WIDTH = 0;

	MULT18X18 _TECHMAP_REPLACE_ (
		.A(A),
		.B(B),
		.P(Y)
	);
endmodule

`,"xc3sda_dsp_map.v":`module \\$__MUL18X18 (input [17:0] A, input [17:0] B, output [35:0] Y);
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;
	parameter A_WIDTH = 0;
	parameter B_WIDTH = 0;
	parameter Y_WIDTH = 0;

	wire [47:0] P_48;
	DSP48A #(
		// Disable all registers
		.A0REG(0),
		.A1REG(0),
		.B0REG(0),
		.B1REG(0),
		.CARRYINREG(0),
		.CARRYINSEL("OPMODE5"),
		.CREG(0),
		.DREG(0),
		.MREG(0),
		.OPMODEREG(0),
		.PREG(0)
	) _TECHMAP_REPLACE_ (
		//Data path
		.A(A),
		.B(B),
		.C(48'b0),
		.D(18'b0),
		.P(P_48),

		.OPMODE(8'b0000001)
	);
	assign Y = P_48;
endmodule

`,"xc4v_dsp_map.v":`module \\$__MUL18X18 (input [17:0] A, input [17:0] B, output [35:0] Y);
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;
	parameter A_WIDTH = 0;
	parameter B_WIDTH = 0;
	parameter Y_WIDTH = 0;

	wire [47:0] P_48;
	DSP48 #(
		// Disable all registers
		.AREG(0),
		.BREG(0),
		.B_INPUT("DIRECT"),
		.CARRYINREG(0),
		.CARRYINSELREG(0),
		.CREG(0),
		.MREG(0),
		.OPMODEREG(0),
		.PREG(0),
		.SUBTRACTREG(0),
		.LEGACY_MODE("MULT18X18")
	) _TECHMAP_REPLACE_ (
		//Data path
		.A(A),
		.B(B),
		.C(48'b0),
		.P(P_48),

		.SUBTRACT(1'b0),
		.OPMODE(7'b000101),
		.CARRYINSEL(2'b00),

		.BCIN(18'b0),
		.PCIN(48'b0),
		.CARRYIN(1'b0)
	);
	assign Y = P_48;
endmodule
`,"xc5v_dsp_map.v":`module \\$__MUL25X18 (input [24:0] A, input [17:0] B, output [42:0] Y);
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;
	parameter A_WIDTH = 0;
	parameter B_WIDTH = 0;
	parameter Y_WIDTH = 0;

	wire [47:0] P_48;
	DSP48E #(
		// Disable all registers
		.ACASCREG(0),
		.A_INPUT("DIRECT"),
		.ALUMODEREG(0),
		.AREG(0),
		.BCASCREG(0),
		.B_INPUT("DIRECT"),
		.BREG(0),
		.MULTCARRYINREG(0),
		.CARRYINREG(0),
		.CARRYINSELREG(0),
		.CREG(0),
		.MREG(0),
		.OPMODEREG(0),
		.PREG(0),
		.USE_MULT("MULT"),
		.USE_SIMD("ONE48")
	) _TECHMAP_REPLACE_ (
		//Data path
		.A({{5{A[24]}}, A}),
		.B(B),
		.C(48'b0),
		.P(P_48),

		.ALUMODE(4'b0000),
		.OPMODE(7'b000101),
		.CARRYINSEL(3'b000),

		.ACIN(30'b0),
		.BCIN(18'b0),
		.PCIN(48'b0),
		.CARRYIN(1'b0)
	);
	assign Y = P_48;
endmodule

`,"xc6s_dsp_map.v":`module \\$__MUL18X18 (input [17:0] A, input [17:0] B, output [35:0] Y);
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;
	parameter A_WIDTH = 0;
	parameter B_WIDTH = 0;
	parameter Y_WIDTH = 0;

	wire [47:0] P_48;
	DSP48A1 #(
		// Disable all registers
		.A0REG(0),
		.A1REG(0),
		.B0REG(0),
		.B1REG(0),
		.CARRYINREG(0),
		.CARRYINSEL("OPMODE5"),
		.CREG(0),
		.DREG(0),
		.MREG(0),
		.OPMODEREG(0),
		.PREG(0)
	) _TECHMAP_REPLACE_ (
		//Data path
		.A(A),
		.B(B),
		.C(48'b0),
		.D(18'b0),
		.P(P_48),

		.OPMODE(8'b0000001)
	);
	assign Y = P_48;
endmodule


`,"xc7_dsp_map.v":`module \\$__MUL25X18 (input [24:0] A, input [17:0] B, output [42:0] Y);
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;
	parameter A_WIDTH = 0;
	parameter B_WIDTH = 0;
	parameter Y_WIDTH = 0;

	wire [47:0] P_48;
	DSP48E1 #(
		// Disable all registers
		.ACASCREG(0),
		.ADREG(0),
		.A_INPUT("DIRECT"),
		.ALUMODEREG(0),
		.AREG(0),
		.BCASCREG(0),
		.B_INPUT("DIRECT"),
		.BREG(0),
		.CARRYINREG(0),
		.CARRYINSELREG(0),
		.CREG(0),
		.DREG(0),
		.INMODEREG(0),
		.MREG(0),
		.OPMODEREG(0),
		.PREG(0),
		.USE_MULT("MULTIPLY"),
		.USE_SIMD("ONE48"),
		.USE_DPORT("FALSE")
	) _TECHMAP_REPLACE_ (
		//Data path
		.A({{5{A[24]}}, A}),
		.B(B),
		.C(48'b0),
		.D(25'b0),
		.CARRYIN(1'b0),
		.P(P_48),

		.INMODE(5'b00000),
		.ALUMODE(4'b0000),
		.OPMODE(7'b000101),
		.CARRYINSEL(3'b000),

		.ACIN(30'b0),
		.BCIN(18'b0),
		.PCIN(48'b0),
		.CARRYIN(1'b0)
	);
	assign Y = P_48;
endmodule
`,"xcu_dsp_map.v":`module \\$__MUL27X18 (input [26:0] A, input [17:0] B, output [44:0] Y);
	parameter A_SIGNED = 0;
	parameter B_SIGNED = 0;
	parameter A_WIDTH = 0;
	parameter B_WIDTH = 0;
	parameter Y_WIDTH = 0;

	wire [47:0] P_48;
	DSP48E2 #(
		// Disable all registers
		.ACASCREG(0),
		.ADREG(0),
		.A_INPUT("DIRECT"),
		.ALUMODEREG(0),
		.AREG(0),
		.BCASCREG(0),
		.B_INPUT("DIRECT"),
		.BREG(0),
		.CARRYINREG(0),
		.CARRYINSELREG(0),
		.CREG(0),
		.DREG(0),
		.INMODEREG(0),
		.MREG(0),
		.OPMODEREG(0),
		.PREG(0),
		.USE_MULT("MULTIPLY"),
		.USE_SIMD("ONE48"),
		.AMULTSEL("A"),
		.BMULTSEL("B")
	) _TECHMAP_REPLACE_ (
		//Data path
		.A({{3{A[26]}}, A}),
		.B(B),
		.C(48'b0),
		.D(27'b0),
		.P(P_48),

		.INMODE(5'b00000),
		.ALUMODE(4'b0000),
		.OPMODE(9'b00000101),
		.CARRYINSEL(3'b000),

		.ACIN(30'b0),
		.BCIN(18'b0),
		.PCIN(48'b0),
		.CARRYIN(1'b0)
	);
	assign Y = P_48;
endmodule

`}}}});var Ya=Gt(k0());var U0="./python_stdlib-EAYX7QUE.zip";var G0="./pyodide-lock-3HBDEL2U.json";var V_=Object.create,jn=Object.defineProperty,Q_=Object.getOwnPropertyDescriptor,j_=Object.getOwnPropertyNames,$_=Object.getPrototypeOf,q_=Object.prototype.hasOwnProperty,Rt=(t,e)=>jn(t,"name",{value:e,configurable:!0}),z0=(t=>typeof Vt<"u"?Vt:typeof Proxy<"u"?new Proxy(t,{get:(e,n)=>(typeof Vt<"u"?Vt:e)[n]}):t)(function(t){if(typeof Vt<"u")return Vt.apply(this,arguments);throw new Error('Dynamic require of "'+t+'" is not supported')}),K0=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),Z_=(t,e,n,_)=>{if(e&&typeof e=="object"||typeof e=="function")for(let r of j_(e))!q_.call(t,r)&&r!==n&&jn(t,r,{get:()=>e[r],enumerable:!(_=Q_(e,r))||_.enumerable});return t},J_=(t,e,n)=>(n=t!=null?V_($_(t)):{},Z_(e||!t||!t.__esModule?jn(n,"default",{value:t,enumerable:!0}):n,t)),tr=K0((t,e)=>{(function(n,_){"use strict";typeof define=="function"&&define.amd?define("stackframe",[],_):typeof t=="object"?e.exports=_():n.StackFrame=_()})(t,function(){"use strict";function n(R){return!isNaN(parseFloat(R))&&isFinite(R)}Rt(n,"_isNumber");function _(R){return R.charAt(0).toUpperCase()+R.substring(1)}Rt(_,"_capitalize");function r(R){return function(){return this[R]}}Rt(r,"_getter");var a=["isConstructor","isEval","isNative","isToplevel"],o=["columnNumber","lineNumber"],l=["fileName","functionName","source"],p=["args"],c=["evalOrigin"],I=a.concat(o,l,p,c);function A(R){if(R)for(var h=0;h<I.length;h++)R[I[h]]!==void 0&&this["set"+_(I[h])](R[I[h]])}Rt(A,"StackFrame"),A.prototype={getArgs:function(){return this.args},setArgs:function(R){if(Object.prototype.toString.call(R)!=="[object Array]")throw new TypeError("Args must be an Array");this.args=R},getEvalOrigin:function(){return this.evalOrigin},setEvalOrigin:function(R){if(R instanceof A)this.evalOrigin=R;else if(R instanceof Object)this.evalOrigin=new A(R);else throw new TypeError("Eval Origin must be an Object or StackFrame")},toString:function(){var R=this.getFileName()||"",h=this.getLineNumber()||"",w=this.getColumnNumber()||"",g=this.getFunctionName()||"";return this.getIsEval()?R?"[eval] ("+R+":"+h+":"+w+")":"[eval]:"+h+":"+w:g?g+" ("+R+":"+h+":"+w+")":R+":"+h+":"+w}},A.fromString=Rt(function(R){var h=R.indexOf("("),w=R.lastIndexOf(")"),g=R.substring(0,h),O=R.substring(h+1,w).split(","),W=R.substring(w+1);if(W.indexOf("@")===0)var k=/@(.+?)(?::(\d+))?(?::(\d+))?$/.exec(W,""),Z=k[1],v=k[2],tt=k[3];return new A({functionName:g,args:O||void 0,fileName:Z,lineNumber:v||void 0,columnNumber:tt||void 0})},"StackFrame$$fromString");for(var m=0;m<a.length;m++)A.prototype["get"+_(a[m])]=r(a[m]),A.prototype["set"+_(a[m])]=function(R){return function(h){this[R]=!!h}}(a[m]);for(var E=0;E<o.length;E++)A.prototype["get"+_(o[E])]=r(o[E]),A.prototype["set"+_(o[E])]=function(R){return function(h){if(!n(h))throw new TypeError(R+" must be a Number");this[R]=Number(h)}}(o[E]);for(var f=0;f<l.length;f++)A.prototype["get"+_(l[f])]=r(l[f]),A.prototype["set"+_(l[f])]=function(R){return function(h){this[R]=String(h)}}(l[f]);return A})}),er=K0((t,e)=>{(function(n,_){"use strict";typeof define=="function"&&define.amd?define("error-stack-parser",["stackframe"],_):typeof t=="object"?e.exports=_(tr()):n.ErrorStackParser=_(n.StackFrame)})(t,Rt(function(n){"use strict";var _=/(^|@)\S+:\d+/,r=/^\s*at .*(\S+:\d+|\(native\))/m,a=/^(eval@)?(\[native code])?$/;return{parse:Rt(function(o){if(typeof o.stacktrace<"u"||typeof o["opera#sourceloc"]<"u")return this.parseOpera(o);if(o.stack&&o.stack.match(r))return this.parseV8OrIE(o);if(o.stack)return this.parseFFOrSafari(o);throw new Error("Cannot parse given Error object")},"ErrorStackParser$$parse"),extractLocation:Rt(function(o){if(o.indexOf(":")===-1)return[o];var l=/(.+?)(?::(\d+))?(?::(\d+))?$/,p=l.exec(o.replace(/[()]/g,""));return[p[1],p[2]||void 0,p[3]||void 0]},"ErrorStackParser$$extractLocation"),parseV8OrIE:Rt(function(o){var l=o.stack.split(`
`).filter(function(p){return!!p.match(r)},this);return l.map(function(p){p.indexOf("(eval ")>-1&&(p=p.replace(/eval code/g,"eval").replace(/(\(eval at [^()]*)|(,.*$)/g,""));var c=p.replace(/^\s+/,"").replace(/\(eval code/g,"(").replace(/^.*?\s+/,""),I=c.match(/ (\(.+\)$)/);c=I?c.replace(I[0],""):c;var A=this.extractLocation(I?I[1]:c),m=I&&c||void 0,E=["eval","<anonymous>"].indexOf(A[0])>-1?void 0:A[0];return new n({functionName:m,fileName:E,lineNumber:A[1],columnNumber:A[2],source:p})},this)},"ErrorStackParser$$parseV8OrIE"),parseFFOrSafari:Rt(function(o){var l=o.stack.split(`
`).filter(function(p){return!p.match(a)},this);return l.map(function(p){if(p.indexOf(" > eval")>-1&&(p=p.replace(/ line (\d+)(?: > eval line \d+)* > eval:\d+:\d+/g,":$1")),p.indexOf("@")===-1&&p.indexOf(":")===-1)return new n({functionName:p});var c=/((.*".+"[^@]*)?[^@]*)(?:@)/,I=p.match(c),A=I&&I[1]?I[1]:void 0,m=this.extractLocation(p.replace(c,""));return new n({functionName:A,fileName:m[0],lineNumber:m[1],columnNumber:m[2],source:p})},this)},"ErrorStackParser$$parseFFOrSafari"),parseOpera:Rt(function(o){return!o.stacktrace||o.message.indexOf(`
`)>-1&&o.message.split(`
`).length>o.stacktrace.split(`
`).length?this.parseOpera9(o):o.stack?this.parseOpera11(o):this.parseOpera10(o)},"ErrorStackParser$$parseOpera"),parseOpera9:Rt(function(o){for(var l=/Line (\d+).*script (?:in )?(\S+)/i,p=o.message.split(`
`),c=[],I=2,A=p.length;I<A;I+=2){var m=l.exec(p[I]);m&&c.push(new n({fileName:m[2],lineNumber:m[1],source:p[I]}))}return c},"ErrorStackParser$$parseOpera9"),parseOpera10:Rt(function(o){for(var l=/Line (\d+).*script (?:in )?(\S+)(?:: In function (\S+))?$/i,p=o.stacktrace.split(`
`),c=[],I=0,A=p.length;I<A;I+=2){var m=l.exec(p[I]);m&&c.push(new n({functionName:m[3]||void 0,fileName:m[2],lineNumber:m[1],source:p[I]}))}return c},"ErrorStackParser$$parseOpera10"),parseOpera11:Rt(function(o){var l=o.stack.split(`
`).filter(function(p){return!!p.match(_)&&!p.match(/^Error created at/)},this);return l.map(function(p){var c=p.split("@"),I=this.extractLocation(c.pop()),A=c.shift()||"",m=A.replace(/<anonymous function(: (\w+))?>/,"$2").replace(/\([^)]*\)/g,"")||void 0,E;A.match(/\(([^)]*)\)/)&&(E=A.replace(/^[^(]+\(([^)]*)\)$/,"$1"));var f=E===void 0||E==="[arguments not available]"?void 0:E.split(",");return new n({functionName:m,args:f,fileName:I[0],lineNumber:I[1],columnNumber:I[2],source:p})},this)},"ErrorStackParser$$parseOpera11")}},"ErrorStackParser"))}),nr=J_(er()),de=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string"&&typeof process.browser>"u",Y0=de&&typeof module<"u"&&typeof module.exports<"u"&&typeof z0<"u"&&typeof __dirname<"u",_r=de&&!Y0,rr=typeof Deno<"u",X0=!de&&!rr,ar=X0&&typeof window<"u"&&typeof document<"u"&&typeof document.createElement<"u"&&typeof sessionStorage<"u",ir=X0&&typeof importScripts<"u"&&typeof self<"u",V0,bn,Vn,Q0,$n,sr=`"fetch" is not defined, maybe you're using node < 18? From Pyodide >= 0.25.0, node >= 18 is required. Older versions of Node.js may work, but it is not guaranteed or supported. Falling back to "node-fetch".`;async function qn(){if(!de||(V0=(await Promise.resolve().then(()=>Gt(Pn(),1))).default,$n=await import("fs/promises"),globalThis.fetch?bn=fetch:(console.warn(sr),bn=(await import("node-fetch")).default),Q0=(await Promise.resolve().then(()=>Gt(Yn(),1))).default,Vn=await Promise.resolve().then(()=>Gt(Ke(),1)),Zn=Vn.sep,typeof z0<"u"))return;let t=await Promise.resolve().then(()=>Gt(gn(),1)),e=await Promise.resolve().then(()=>Gt(yn(),1)),n=await Promise.resolve().then(()=>Gt(Ye(),1)),_=await Promise.resolve().then(()=>Gt(Sn(),1)),r={fs:t,crypto:e,ws:n,child_process:_};globalThis.require=function(a){return r[a]}}Rt(qn,"initNodeModules");function j0(t,e){return Vn.resolve(e||".",t)}Rt(j0,"node_resolvePath");function $0(t,e){return e===void 0&&(e=location),new URL(t,e).toString()}Rt($0,"browser_resolvePath");var Qn;de?Qn=j0:Qn=$0;var Zn;de||(Zn="/");function q0(t,e){return t.startsWith("file://")&&(t=t.slice(7)),t.includes("://")?{response:bn(t)}:{binary:$n.readFile(t).then(n=>new Uint8Array(n.buffer,n.byteOffset,n.byteLength))}}Rt(q0,"node_getBinaryResponse");function Z0(t,e){let n=new URL(t,location);return{response:fetch(n,e?{integrity:e}:{})}}Rt(Z0,"browser_getBinaryResponse");var Nn;de?Nn=q0:Nn=Z0;async function J0(t,e){let{response:n,binary:_}=Nn(t,e);if(_)return _;let r=await n;if(!r.ok)throw new Error(`Failed to load '${t}': request failed.`);return new Uint8Array(await r.arrayBuffer())}Rt(J0,"loadBinaryFile");var hn;if(ar)hn=Rt(async t=>await import(t),"loadScript");else if(ir)hn=Rt(async t=>{try{globalThis.importScripts(t)}catch(e){if(e instanceof TypeError)await import(t);else throw e}},"loadScript");else if(de)hn=t_;else throw new Error("Cannot determine runtime environment");async function t_(t){t.startsWith("file://")&&(t=t.slice(7)),t.includes("://")?Q0.runInThisContext(await(await bn(t)).text()):await import(V0.pathToFileURL(t).href)}Rt(t_,"nodeLoadScript");async function e_(t){if(de){await qn();let e=await $n.readFile(t);return JSON.parse(e)}else return await(await fetch(t)).json()}Rt(e_,"loadLockFile");async function n_(){if(Y0)return __dirname;let t;try{throw new Error}catch(_){t=_}let e=nr.default.parse(t)[0].fileName;if(_r){let _=await Promise.resolve().then(()=>Gt(Ke(),1));return(await Promise.resolve().then(()=>Gt(Pn(),1))).fileURLToPath(_.dirname(e))}let n=e.lastIndexOf(Zn);if(n===-1)throw new Error("Could not extract indexURL path from pyodide module location");return e.slice(0,n)}Rt(n_,"calculateDirname");function __(t){let e=t.FS,n=t.FS.filesystems.MEMFS,_=t.PATH,r={DIR_MODE:16895,FILE_MODE:33279,mount:function(a){if(!a.opts.fileSystemHandle)throw new Error("opts.fileSystemHandle is required");return n.mount.apply(null,arguments)},syncfs:async(a,o,l)=>{try{let p=r.getLocalSet(a),c=await r.getRemoteSet(a),I=o?c:p,A=o?p:c;await r.reconcile(a,I,A),l(null)}catch(p){l(p)}},getLocalSet:a=>{let o=Object.create(null);function l(I){return I!=="."&&I!==".."}Rt(l,"isRealDir");function p(I){return A=>_.join2(I,A)}Rt(p,"toAbsolute");let c=e.readdir(a.mountpoint).filter(l).map(p(a.mountpoint));for(;c.length;){let I=c.pop(),A=e.stat(I);e.isDir(A.mode)&&c.push.apply(c,e.readdir(I).filter(l).map(p(I))),o[I]={timestamp:A.mtime,mode:A.mode}}return{type:"local",entries:o}},getRemoteSet:async a=>{let o=Object.create(null),l=await or(a.opts.fileSystemHandle);for(let[p,c]of l)p!=="."&&(o[_.join2(a.mountpoint,p)]={timestamp:c.kind==="file"?(await c.getFile()).lastModifiedDate:new Date,mode:c.kind==="file"?r.FILE_MODE:r.DIR_MODE});return{type:"remote",entries:o,handles:l}},loadLocalEntry:a=>{let o=e.lookupPath(a).node,l=e.stat(a);if(e.isDir(l.mode))return{timestamp:l.mtime,mode:l.mode};if(e.isFile(l.mode))return o.contents=n.getFileDataAsTypedArray(o),{timestamp:l.mtime,mode:l.mode,contents:o.contents};throw new Error("node type not supported")},storeLocalEntry:(a,o)=>{if(e.isDir(o.mode))e.mkdirTree(a,o.mode);else if(e.isFile(o.mode))e.writeFile(a,o.contents,{canOwn:!0});else throw new Error("node type not supported");e.chmod(a,o.mode),e.utime(a,o.timestamp,o.timestamp)},removeLocalEntry:a=>{var o=e.stat(a);e.isDir(o.mode)?e.rmdir(a):e.isFile(o.mode)&&e.unlink(a)},loadRemoteEntry:async a=>{if(a.kind==="file"){let o=await a.getFile();return{contents:new Uint8Array(await o.arrayBuffer()),mode:r.FILE_MODE,timestamp:o.lastModifiedDate}}else{if(a.kind==="directory")return{mode:r.DIR_MODE,timestamp:new Date};throw new Error("unknown kind: "+a.kind)}},storeRemoteEntry:async(a,o,l)=>{let p=a.get(_.dirname(o)),c=e.isFile(l.mode)?await p.getFileHandle(_.basename(o),{create:!0}):await p.getDirectoryHandle(_.basename(o),{create:!0});if(c.kind==="file"){let I=await c.createWritable();await I.write(l.contents),await I.close()}a.set(o,c)},removeRemoteEntry:async(a,o)=>{await a.get(_.dirname(o)).removeEntry(_.basename(o)),a.delete(o)},reconcile:async(a,o,l)=>{let p=0,c=[];Object.keys(o.entries).forEach(function(m){let E=o.entries[m],f=l.entries[m];(!f||e.isFile(E.mode)&&E.timestamp.getTime()>f.timestamp.getTime())&&(c.push(m),p++)}),c.sort();let I=[];if(Object.keys(l.entries).forEach(function(m){o.entries[m]||(I.push(m),p++)}),I.sort().reverse(),!p)return;let A=o.type==="remote"?o.handles:l.handles;for(let m of c){let E=_.normalize(m.replace(a.mountpoint,"/")).substring(1);if(l.type==="local"){let f=A.get(E),R=await r.loadRemoteEntry(f);r.storeLocalEntry(m,R)}else{let f=r.loadLocalEntry(m);await r.storeRemoteEntry(A,E,f)}}for(let m of I)if(l.type==="local")r.removeLocalEntry(m);else{let E=_.normalize(m.replace(a.mountpoint,"/")).substring(1);await r.removeRemoteEntry(A,E)}}};t.FS.filesystems.NATIVEFS_ASYNC=r}Rt(__,"initializeNativeFS");var or=Rt(async t=>{let e=[];async function n(r){for await(let a of r.values())e.push(a),a.kind==="directory"&&await n(a)}Rt(n,"collect"),await n(t);let _=new Map;_.set(".",t);for(let r of e){let a=(await t.resolve(r)).join("/");_.set(a,r)}return _},"getFsHandles");function r_(){let t={};return t.noImageDecoding=!0,t.noAudioDecoding=!0,t.noWasmDecoding=!1,t.preRun=[],t.quit=(e,n)=>{throw t.exited={status:e,toThrow:n},n},t}Rt(r_,"createModule");function a_(t,e){t.preRun.push(function(){let n="/";try{t.FS.mkdirTree(e)}catch(_){console.error(`Error occurred while making a home directory '${e}':`),console.error(_),console.error(`Using '${n}' for a home directory instead`),e=n}t.FS.chdir(e)})}Rt(a_,"createHomeDirectory");function i_(t,e){t.preRun.push(function(){Object.assign(t.ENV,e)})}Rt(i_,"setEnvironment");function s_(t,e){t.preRun.push(()=>{for(let n of e)t.FS.mkdirTree(n),t.FS.mount(t.FS.filesystems.NODEFS,{root:n},n)})}Rt(s_,"mountLocalDirectories");function o_(t,e){let n=J0(e);t.preRun.push(()=>{let _=t._py_version_major(),r=t._py_version_minor();t.FS.mkdirTree("/lib"),t.FS.mkdirTree(`/lib/python${_}.${r}/site-packages`),t.addRunDependency("install-stdlib"),n.then(a=>{t.FS.writeFile(`/lib/python${_}${r}.zip`,a)}).catch(a=>{console.error("Error occurred while installing the standard library:"),console.error(a)}).finally(()=>{t.removeRunDependency("install-stdlib")})})}Rt(o_,"installStdlib");function l_(t,e){let n;e.stdLibURL!=null?n=e.stdLibURL:n=e.indexURL+"python_stdlib.zip",o_(t,n),a_(t,e.env.HOME),i_(t,e.env),s_(t,e._node_mounts),t.preRun.push(()=>__(t))}Rt(l_,"initializeFileSystem");function d_(t,e){let{binary:n,response:_}=Nn(e+"pyodide.asm.wasm");t.instantiateWasm=function(r,a){return async function(){try{let o;_?o=await WebAssembly.instantiateStreaming(_,r):o=await WebAssembly.instantiate(await n,r);let{instance:l,module:p}=o;typeof WasmOffsetConverter<"u"&&(wasmOffsetConverter=new WasmOffsetConverter(wasmBinary,p)),a(l,p)}catch(o){console.warn("wasm instantiation failed!"),console.warn(o)}}(),{}}}Rt(d_,"preloadWasm");var Xn="0.25.0";async function Jn(t={}){await qn();let e=t.indexURL||await n_();e=Qn(e),e.endsWith("/")||(e+="/"),t.indexURL=e;let n={fullStdLib:!1,jsglobals:globalThis,stdin:globalThis.prompt?globalThis.prompt:void 0,lockFileURL:e+"pyodide-lock.json",args:[],_node_mounts:[],env:{},packageCacheDir:e,packages:[]},_=Object.assign(n,t);_.env.HOME||(_.env.HOME="/home/pyodide");let r=r_();r.print=_.stdout,r.printErr=_.stderr,r.arguments=_.args;let a={config:_};r.API=a,a.lockFilePromise=e_(_.lockFileURL),d_(r,e),l_(r,_);let o=new Promise(p=>r.postRun=p);if(r.locateFile=p=>_.indexURL+p,typeof _createPyodideModule!="function"){let p=`${_.indexURL}pyodide.asm.js`;await hn(p)}if(await _createPyodideModule(r),await o,r.exited)throw r.exited.toThrow;if(t.pyproxyToStringRepr&&a.setPyProxyToStringMethod(!0),a.version!==Xn)throw new Error(`Pyodide version does not match: '${Xn}' <==> '${a.version}'. If you updated the Pyodide version, make sure you also updated the 'indexURL' parameter passed to loadPyodide.`);r.locateFile=p=>{throw new Error("Didn't expect to load any more file_packager files!")};let l=a.finalizeBootstrap();if(l.version.includes("dev")||a.setCdnUrl(`https://cdn.jsdelivr.net/pyodide/v${l.version}/full/`),await a.packageIndexReady,a._pyodide._importhook.register_module_not_found_hook(a._import_name_to_package_name,a.lockfile_unvendored_stdlibs_and_test),a.lockfile_info.version!==Xn)throw new Error("Lock file version doesn't match Pyodide version");return a.package_loader.init_loaded_packages(),_.fullStdLib&&await l.loadPackage(a.lockfile_unvendored_stdlibs),a.initializeStreams(_.stdin,_.stdout,_.stderr),l}Rt(Jn,"loadPyodide");var p_=function(t){return Jn({indexURL:".",stdLibURL:U0,lockFileURL:G0,...t})};var e0;typeof process=="object"&&process.release?.name==="node"?e0=async function(t,e){if(t.protocol==="file:"){let{readFile:n}=await import("fs/promises"),_="application/octet-stream";return t.pathname.endsWith(".wasm")&&(_="application/wasm"),new Response(await n(t),{headers:{"Content-Type":_}})}else return globalThis.fetch(t,e)}:e0=globalThis.fetch;var D_=e0,Ve=class extends Error{constructor(t=0){super(`Exited with status ${t}`),this.code=t}};function pr(){return BigInt(Math.floor(performance.now()*1e6))}function ur(){let t=Date.now(),e=BigInt(Math.floor(t/1e3)),n=t%1e3*1e6;return{seconds:e,nanoseconds:n}}var cr=class{constructor(t){if(BigInt(t)===0n)throw new Error("xoroshiro128** must be seeded with a non-zero state");this.s=[BigInt(t)&0xffffffffffffffffn,BigInt(t)>>64n&0xffffffffffffffffn]}next(){function t(a){return a&0xffffffffffffffffn}function e(a,o){return a<<o|a>>64n-o}let[n,_]=this.s,r=t(e(n*5n,7n)*9n);return _^=n,n=t(e(n,24n)^_^_<<16n),_=t(e(_,37n)),this.s=[n,_],r}getBytes(t){return Uint8Array.from({length:t},()=>Number(BigInt.asUintN(8,this.next()>>32n)))}},mr=class extends Error{},r0=class{read(t){throw{tag:"closed"}}blockingRead(t){return this.read(t)}},a0=class{checkWrite(){throw{tag:"closed"}}write(t){this.checkWrite()}flush(){}blockingFlush(){this.flush()}blockingWriteAndFlush(t){this.write(t),this.blockingFlush()}},Ir=class extends r0{constructor(t=null){super(),this.callback=t}read(t){if(this.callback===null)throw{tag:"closed"};let e=this.callback(Number(t));if(e===null)throw{tag:"closed"};return e}},m_=class extends a0{constructor(t=null){super(),this.callback=t}checkWrite(){return 4096}write(t){this.callback!==null&&this.callback(t)}flush(){this.callback!==null&&this.callback(null)}},I_=class{},T_=class{},he=class{constructor(t=""){if(t instanceof Uint8Array)this.data=t;else if(typeof t=="string")this.data=new TextEncoder().encode(t);else throw new Error(`Cannot construct a file from ${typeof t}`)}get size(){return this.data.length}},Tr=class extends r0{constructor(t,e){super(),this.file=t,this.offset=e}read(t){let e=this.file.data.subarray(Number(this.offset),Number(this.offset+t));return this.offset+=t,e}},Ar=class extends a0{constructor(t,e){super(),this.file=t,this.offset=e}write(t){let e=new Uint8Array(this.file.data.length+t.length);e.set(this.file.data),e.subarray(Number(this.offset)).set(t),this.file.data=e,this.offset+=BigInt(t.length)}},Xt=class f_{constructor(e={}){this.files=e}get size(){return Object.keys(this.files).length}traverse(e,n={create:!1,remove:!1}){let _=this,r=-1;do{if(_ instanceof he)throw"not-directory";let a=_.files;r=e.indexOf("/");let o=r===-1?e:e.substring(0,r);if(r===-1&&n.remove)delete a[o];else if(!(o===""||o===".")){if(o!=="..")if(Object.hasOwn(a,o))_=a[o];else if(n.create==="directory"||n.create==="file"&&r!==-1)_=a[o]=new f_({});else if(n.create==="file")_=a[o]=new he(new Uint8Array);else throw"no-entry"}e=e.substring(r+1)}while(r!==-1);return _}},A_=class Cn{constructor(e){this.entry=e}getType(){if(this.entry instanceof Xt)return"directory";if(this.entry instanceof he)return"regular-file"}getFlags(){return{}}metadataHash(){return{upper:0,lower:0}}metadataHashAt(e,n){if(!(this.entry instanceof Xt))throw"invalid";let _=this.entry.traverse(n);return new Cn(_).metadataHash()}stat(){let e;return this.entry instanceof Xt&&(e="directory"),this.entry instanceof he&&(e="regular-file"),{type:e,linkCount:1,size:this.entry.size,dataAccessTimestamp:null,dataModificationTimestamp:null,statusChangeTimestamp:null}}statAt(e,n){if(!(this.entry instanceof Xt))throw"invalid";let _=this.entry.traverse(n);return new Cn(_).stat()}openAt(e,n,_,r){if(!(this.entry instanceof Xt))throw"invalid";let a=this.entry.traverse(n,{create:_.create?"file":!1});if(_.directory){if(!(a instanceof Xt))throw"not-directory"}else{if(a instanceof Xt)throw"is-directory";_.truncate&&(a.data=new Uint8Array)}return new Cn(a)}read(e,n){if(this.entry instanceof Xt)throw"is-directory";return[e,n]=[Number(e),Number(n)],[this.entry.data.subarray(n,n+e),n+e>=this.entry.data.byteLength]}readViaStream(e){return new Tr(this.entry,e)}write(e,n){throw this.entry instanceof Xt?"is-directory":(console.error("Descriptor.write not implemented"),"unsupported")}writeViaStream(e){return new Ar(this.entry,e)}readDirectory(){return new R_(this.entry)}createDirectoryAt(e){this.entry.traverse(e,{create:"directory"})}unlinkFileAt(e){if(this.entry.traverse(e)instanceof Xt)return"is-directory";this.entry.traverse(e,{remove:!0})}removeDirectoryAt(e){if(!(this.entry.traverse(e)instanceof Xt))return"not-directory";this.entry.traverse(e,{remove:!0})}},R_=class{constructor(t){this.entries=Object.entries(t.files),this.index=0}readDirectoryEntry(){if(this.index===this.entries.length)return null;let[t,e]=this.entries[this.index++],n;return e instanceof Xt&&(n="directory"),e instanceof he&&(n="regular-file"),{name:t,type:n}}};function n0(t){let e={};for(let[n,_]of Object.entries(t))typeof _=="string"||_ instanceof Uint8Array?e[n]=new he(t[n]):e[n]=n0(t[n]);return new Xt(e)}function g_(t,{decodeASCII:e=!0}={}){function n(r){for(let a of r)if(a<32&&a!==9&&a!==10&&a!==13||a>=127)return!1;return!0}let _={};for(let[r,a]of Object.entries(t.files))a instanceof he&&(_[r]=e&&n(a.data)?new TextDecoder().decode(a.data):a.data),a instanceof Xt&&(_[r]=g_(a,{decodeASCII:e}));return _}var Er=class{constructor(){Rn(this,"vars",{});Rn(this,"args",[]);Rn(this,"root",new Xt({}));this.prng=new cr(1n),this.standardInputStream=new Ir,this.standardOutputStream=new m_,this.standardErrorStream=new m_,this.terminalInput=new I_,this.terminalOutput=new T_;let t=this;this.exports={monotonicClock:{now:pr},wallClock:{now:ur},random:{getRandomBytes(e){return t.prng.getBytes(Number(e))}},io:{Error:mr,InputStream:r0,OutputStream:a0},cli:{exit(e){throw new Ve(e.tag==="ok"?0:1)},getEnvironment(){return t.vars},getArguments(){return t.args},getStdin(){return t.standardInputStream},getStdout(){return t.standardOutputStream},getStderr(){return t.standardErrorStream},getTerminalStdin(){return t.terminalInput},getTerminalStdout(){return t.terminalOutput},getTerminalStderr(){return t.terminalOutput},TerminalInput:I_,TerminalOutput:T_},fs:{Descriptor:A_,DirectoryEntryStream:R_,filesystemErrorCode(){},getDirectories(){return t.root===null?[]:[[new A_(t.root),"/"]]}}}}get stdin(){return this.standardInputStream.callback}set stdin(t){this.standardInputStream.callback=t}get stdout(){return this.standardOutputStream.callback}set stdout(t){this.standardOutputStream.callback=t}get stderr(){return this.standardErrorStream.callback}set stderr(t){this.standardErrorStream.callback=t}};function Dr(t){let e=new Uint8Array;return n=>{if(n===null)return;let _=new Uint8Array(e.length+n.length);_.set(e),_.set(n,e.length),e=_;let r=-1;for(;;){let a=e.indexOf(10,r+1);if(a===-1)break;t(new TextDecoder().decode(e.subarray(r+1,a))),r=a}e=e.subarray(r+1)}}async function _0(t,e){let n=[];for(let[_,r]of Object.entries(t))typeof r=="string"||r instanceof Uint8Array?n.push(Promise.resolve([_,r])):r instanceof URL?n.push(e(r).then(a=>[_,a])):n.push(_0(r,e).then(a=>[_,a]));for(let[_,r]of await Promise.all(n))t[_]=r;return t}function fr(t){return D_(t).then(WebAssembly.compileStreaming)}function Rr(t){return D_(t).then(e=>e.arrayBuffer()).then(e=>new Uint8Array(e))}function gr({modules:t,filesystem:e}){return Promise.all([_0(t,fr),_0(e,Rr)]).then(([n,_])=>({modules:n,filesystem:_}))}var Pr=class{constructor(t,e,n){this.resources=t,this.resourceData=null,this.instantiate=e,this.argv0=n}async preload(){this.resourceData===null&&(this.resourceData=await this.resources().then(gr))}execute(t,e={},{stdin:n,stdout:_,stderr:r,decodeASCII:a=!0,printLine:o}={}){let l=new Er;l.args=[this.argv0].concat(t),l.root=n0(e);for(let[A,m]of Object.entries(this.resourceData.filesystem))l.root.files[A]=n0(m);let p=Dr(o??console.log);l.stdin=n===void 0?null:n,l.stdout=_===void 0?p:_,l.stderr=r===void 0?p:r;let c=this.instantiate(A=>this.resourceData.modules[A],{runtime:l.exports},(A,m)=>new WebAssembly.Instance(A,m)),I=null;try{c.run.run()}catch(A){if(!(A instanceof Ve))throw A;A instanceof Ve&&A.code!==0&&(I=A)}for(let A of Object.keys(this.resourceData.filesystem))delete l.root.files[A];if(e=g_(l.root,{decodeASCII:a}),I!==null)throw I.files=e,I;return e}run(t=null,e={},n={}){if(this.resourceData===null)return this.preload().then(_=>this.run(t,e,n));if(t!==null)return this.execute(t,e,n)}},yr=class extends Error{constructor(t){let e=typeof t!="string";super(e?`${String(t)} (see error.payload)`:t),Object.defineProperty(this,"payload",{value:t,enumerable:e})}},t0=new DataView(new ArrayBuffer),M=t=>t0.buffer===t.buffer?t0:t0=new DataView(t.buffer);function wt(t){return t&&Sr.call(t,"payload")?t.payload:t}var Sr=Object.prototype.hasOwnProperty,$a=Symbol("resource"),Qt=Symbol.dispose||Symbol.for("dispose"),zt=t=>BigInt.asUintN(64,BigInt(t));function ye(t){return t>>>0}var Fe=new TextDecoder,hr=new TextEncoder,Se=0;function Xe(t,e,n){if(typeof t!="string")throw new TypeError("expected a string");if(t.length===0)return Se=0,1;let _=0,r=0,a=0;for(;t.length>0;){r=e(r,_,1,_+=t.length*2);let{read:o,written:l}=hr.encodeInto(t,new Uint8Array(n.buffer,r+a,_-a));a+=l,t=t.slice(o)}return Se=a,r}function br(t,e,n=WebAssembly.Instance){let _=t("yosys.core.wasm"),r=t("yosys.core2.wasm"),a=t("yosys.core3.wasm"),o=t("yosys.core4.wasm"),{cli:l,fs:p,io:c,monotonicClock:I,wallClock:A}=e.runtime,{TerminalInput:m,TerminalOutput:E,exit:f,getArguments:R,getEnvironment:h,getStderr:w,getStdin:g,getStdout:O,getTerminalStderr:W,getTerminalStdin:k,getTerminalStdout:Z}=l,{Descriptor:v,DirectoryEntryStream:tt,filesystemErrorCode:z,getDirectories:et}=p,{Error:At,InputStream:rt,OutputStream:J}=c,{now:it}=I,{now:ot}=A,G,ht;function Pt(){let H=it();return zt(H)}function Lt(){let H=w();if(!(H instanceof J))throw new Error('Resource error: Not a valid "OutputStream" resource.');var b=Ee++;return qt.set(b,{rep:H,own:!0}),b}function vt(H){let b;switch(H){case 0:{b={tag:"ok",val:void 0};break}case 1:{b={tag:"err",val:void 0};break}default:throw new TypeError("invalid variant discriminant for expected")}f(b)}function Ct(){let H=g();if(!(H instanceof rt))throw new Error('Resource error: Not a valid "InputStream" resource.');var b=He++;return oe.set(b,{rep:H,own:!0}),b}function te(){let H=O();if(!(H instanceof J))throw new Error('Resource error: Not a valid "OutputStream" resource.');var b=Ee++;return qt.set(b,{rep:H,own:!0}),b}let gt;function jt(H){var Y=et(),q=Y.length,U=B(0,0,4,q*12);for(let L=0;L<Y.length;L++){let lt=Y[L],at=U+L*12;var[Q,$]=lt;if(!(Q instanceof v))throw new Error('Resource error: Not a valid "Descriptor" resource.');var V=Ue++;Mt.set(V,{rep:Q,own:!0}),M(y).setInt32(at+0,V,!0);var N=Xe($,B,y),P=Se;M(y).setInt32(at+8,P,!0),M(y).setInt32(at+4,N,!0)}M(y).setInt32(H+4,q,!0),M(y).setInt32(H+0,U,!0)}let y,B;function X(H){let b=ot();var{seconds:Y,nanoseconds:q}=b;M(y).setBigInt64(H+0,zt(Y),!0),M(y).setInt32(H+8,ye(q),!0)}function _t(H,b,Y){var q=H,U=Mt.get(q).rep;let Q;try{Q={tag:"ok",val:v.prototype.readViaStream.call(U,BigInt.asUintN(64,b))}}catch(P){Q={tag:"err",val:wt(P)}}var $=Q;switch($.tag){case"ok":{let P=$.val;if(M(y).setInt8(Y+0,0,!0),!(P instanceof rt))throw new Error('Resource error: Not a valid "InputStream" resource.');var V=He++;oe.set(V,{rep:P,own:!0}),M(y).setInt32(Y+4,V,!0);break}case"err":{let P=$.val;M(y).setInt8(Y+0,1,!0);var N=P;let L;switch(N){case"access":{L=0;break}case"would-block":{L=1;break}case"already":{L=2;break}case"bad-descriptor":{L=3;break}case"busy":{L=4;break}case"deadlock":{L=5;break}case"quota":{L=6;break}case"exist":{L=7;break}case"file-too-large":{L=8;break}case"illegal-byte-sequence":{L=9;break}case"in-progress":{L=10;break}case"interrupted":{L=11;break}case"invalid":{L=12;break}case"io":{L=13;break}case"is-directory":{L=14;break}case"loop":{L=15;break}case"too-many-links":{L=16;break}case"message-size":{L=17;break}case"name-too-long":{L=18;break}case"no-device":{L=19;break}case"no-entry":{L=20;break}case"no-lock":{L=21;break}case"insufficient-memory":{L=22;break}case"insufficient-space":{L=23;break}case"not-directory":{L=24;break}case"not-empty":{L=25;break}case"not-recoverable":{L=26;break}case"unsupported":{L=27;break}case"no-tty":{L=28;break}case"no-such-device":{L=29;break}case"overflow":{L=30;break}case"not-permitted":{L=31;break}case"pipe":{L=32;break}case"read-only":{L=33;break}case"invalid-seek":{L=34;break}case"text-file-busy":{L=35;break}case"cross-device":{L=36;break}default:throw P instanceof Error&&console.error(P),new TypeError(`"${N}" is not one of the cases of error-code`)}M(y).setInt8(Y+4,L,!0);break}default:throw new TypeError("invalid variant specified for result")}}function yt(H,b,Y){var q=H,U=Mt.get(q).rep;let Q;try{Q={tag:"ok",val:v.prototype.writeViaStream.call(U,BigInt.asUintN(64,b))}}catch(P){Q={tag:"err",val:wt(P)}}var $=Q;switch($.tag){case"ok":{let P=$.val;if(M(y).setInt8(Y+0,0,!0),!(P instanceof J))throw new Error('Resource error: Not a valid "OutputStream" resource.');var V=Ee++;qt.set(V,{rep:P,own:!0}),M(y).setInt32(Y+4,V,!0);break}case"err":{let P=$.val;M(y).setInt8(Y+0,1,!0);var N=P;let L;switch(N){case"access":{L=0;break}case"would-block":{L=1;break}case"already":{L=2;break}case"bad-descriptor":{L=3;break}case"busy":{L=4;break}case"deadlock":{L=5;break}case"quota":{L=6;break}case"exist":{L=7;break}case"file-too-large":{L=8;break}case"illegal-byte-sequence":{L=9;break}case"in-progress":{L=10;break}case"interrupted":{L=11;break}case"invalid":{L=12;break}case"io":{L=13;break}case"is-directory":{L=14;break}case"loop":{L=15;break}case"too-many-links":{L=16;break}case"message-size":{L=17;break}case"name-too-long":{L=18;break}case"no-device":{L=19;break}case"no-entry":{L=20;break}case"no-lock":{L=21;break}case"insufficient-memory":{L=22;break}case"insufficient-space":{L=23;break}case"not-directory":{L=24;break}case"not-empty":{L=25;break}case"not-recoverable":{L=26;break}case"unsupported":{L=27;break}case"no-tty":{L=28;break}case"no-such-device":{L=29;break}case"overflow":{L=30;break}case"not-permitted":{L=31;break}case"pipe":{L=32;break}case"read-only":{L=33;break}case"invalid-seek":{L=34;break}case"text-file-busy":{L=35;break}case"cross-device":{L=36;break}default:throw P instanceof Error&&console.error(P),new TypeError(`"${N}" is not one of the cases of error-code`)}M(y).setInt8(Y+4,L,!0);break}default:throw new TypeError("invalid variant specified for result")}}function Et(H,b){var Y=H,q=Mt.get(Y).rep;let U;try{U={tag:"ok",val:v.prototype.appendViaStream.call(q)}}catch(N){U={tag:"err",val:wt(N)}}var Q=U;switch(Q.tag){case"ok":{let N=Q.val;if(M(y).setInt8(b+0,0,!0),!(N instanceof J))throw new Error('Resource error: Not a valid "OutputStream" resource.');var $=Ee++;qt.set($,{rep:N,own:!0}),M(y).setInt32(b+4,$,!0);break}case"err":{let N=Q.val;M(y).setInt8(b+0,1,!0);var V=N;let P;switch(V){case"access":{P=0;break}case"would-block":{P=1;break}case"already":{P=2;break}case"bad-descriptor":{P=3;break}case"busy":{P=4;break}case"deadlock":{P=5;break}case"quota":{P=6;break}case"exist":{P=7;break}case"file-too-large":{P=8;break}case"illegal-byte-sequence":{P=9;break}case"in-progress":{P=10;break}case"interrupted":{P=11;break}case"invalid":{P=12;break}case"io":{P=13;break}case"is-directory":{P=14;break}case"loop":{P=15;break}case"too-many-links":{P=16;break}case"message-size":{P=17;break}case"name-too-long":{P=18;break}case"no-device":{P=19;break}case"no-entry":{P=20;break}case"no-lock":{P=21;break}case"insufficient-memory":{P=22;break}case"insufficient-space":{P=23;break}case"not-directory":{P=24;break}case"not-empty":{P=25;break}case"not-recoverable":{P=26;break}case"unsupported":{P=27;break}case"no-tty":{P=28;break}case"no-such-device":{P=29;break}case"overflow":{P=30;break}case"not-permitted":{P=31;break}case"pipe":{P=32;break}case"read-only":{P=33;break}case"invalid-seek":{P=34;break}case"text-file-busy":{P=35;break}case"cross-device":{P=36;break}default:throw N instanceof Error&&console.error(N),new TypeError(`"${V}" is not one of the cases of error-code`)}M(y).setInt8(b+4,P,!0);break}default:throw new TypeError("invalid variant specified for result")}}function Wt(H,b){var Y=H,q=Mt.get(Y).rep;let U;try{U={tag:"ok",val:v.prototype.getFlags.call(q)}}catch(V){U={tag:"err",val:wt(V)}}var Q=U;switch(Q.tag){case"ok":{let V=Q.val;M(y).setInt8(b+0,0,!0);let N=0;if(typeof V=="object"&&V!==null)N=!!V.read<<0|!!V.write<<1|!!V.fileIntegritySync<<2|!!V.dataIntegritySync<<3|!!V.requestedWriteSync<<4|!!V.mutateDirectory<<5;else if(V!=null)throw new TypeError("only an object, undefined or null can be converted to flags");M(y).setInt8(b+1,N,!0);break}case"err":{let V=Q.val;M(y).setInt8(b+0,1,!0);var $=V;let N;switch($){case"access":{N=0;break}case"would-block":{N=1;break}case"already":{N=2;break}case"bad-descriptor":{N=3;break}case"busy":{N=4;break}case"deadlock":{N=5;break}case"quota":{N=6;break}case"exist":{N=7;break}case"file-too-large":{N=8;break}case"illegal-byte-sequence":{N=9;break}case"in-progress":{N=10;break}case"interrupted":{N=11;break}case"invalid":{N=12;break}case"io":{N=13;break}case"is-directory":{N=14;break}case"loop":{N=15;break}case"too-many-links":{N=16;break}case"message-size":{N=17;break}case"name-too-long":{N=18;break}case"no-device":{N=19;break}case"no-entry":{N=20;break}case"no-lock":{N=21;break}case"insufficient-memory":{N=22;break}case"insufficient-space":{N=23;break}case"not-directory":{N=24;break}case"not-empty":{N=25;break}case"not-recoverable":{N=26;break}case"unsupported":{N=27;break}case"no-tty":{N=28;break}case"no-such-device":{N=29;break}case"overflow":{N=30;break}case"not-permitted":{N=31;break}case"pipe":{N=32;break}case"read-only":{N=33;break}case"invalid-seek":{N=34;break}case"text-file-busy":{N=35;break}case"cross-device":{N=36;break}default:throw V instanceof Error&&console.error(V),new TypeError(`"${$}" is not one of the cases of error-code`)}M(y).setInt8(b+1,N,!0);break}default:throw new TypeError("invalid variant specified for result")}}function Ht(H,b){var Y=H,q=Mt.get(Y).rep;let U;try{U={tag:"ok",val:v.prototype.getType.call(q)}}catch(N){U={tag:"err",val:wt(N)}}var Q=U;switch(Q.tag){case"ok":{let N=Q.val;M(y).setInt8(b+0,0,!0);var $=N;let P;switch($){case"unknown":{P=0;break}case"block-device":{P=1;break}case"character-device":{P=2;break}case"directory":{P=3;break}case"fifo":{P=4;break}case"symbolic-link":{P=5;break}case"regular-file":{P=6;break}case"socket":{P=7;break}default:throw N instanceof Error&&console.error(N),new TypeError(`"${$}" is not one of the cases of descriptor-type`)}M(y).setInt8(b+1,P,!0);break}case"err":{let N=Q.val;M(y).setInt8(b+0,1,!0);var V=N;let P;switch(V){case"access":{P=0;break}case"would-block":{P=1;break}case"already":{P=2;break}case"bad-descriptor":{P=3;break}case"busy":{P=4;break}case"deadlock":{P=5;break}case"quota":{P=6;break}case"exist":{P=7;break}case"file-too-large":{P=8;break}case"illegal-byte-sequence":{P=9;break}case"in-progress":{P=10;break}case"interrupted":{P=11;break}case"invalid":{P=12;break}case"io":{P=13;break}case"is-directory":{P=14;break}case"loop":{P=15;break}case"too-many-links":{P=16;break}case"message-size":{P=17;break}case"name-too-long":{P=18;break}case"no-device":{P=19;break}case"no-entry":{P=20;break}case"no-lock":{P=21;break}case"insufficient-memory":{P=22;break}case"insufficient-space":{P=23;break}case"not-directory":{P=24;break}case"not-empty":{P=25;break}case"not-recoverable":{P=26;break}case"unsupported":{P=27;break}case"no-tty":{P=28;break}case"no-such-device":{P=29;break}case"overflow":{P=30;break}case"not-permitted":{P=31;break}case"pipe":{P=32;break}case"read-only":{P=33;break}case"invalid-seek":{P=34;break}case"text-file-busy":{P=35;break}case"cross-device":{P=36;break}default:throw N instanceof Error&&console.error(N),new TypeError(`"${V}" is not one of the cases of error-code`)}M(y).setInt8(b+1,P,!0);break}default:throw new TypeError("invalid variant specified for result")}}function kt(H,b){var Y=H,q=Mt.get(Y).rep;let U;try{U={tag:"ok",val:v.prototype.readDirectory.call(q)}}catch(N){U={tag:"err",val:wt(N)}}var Q=U;switch(Q.tag){case"ok":{let N=Q.val;if(M(y).setInt8(b+0,0,!0),!(N instanceof tt))throw new Error('Resource error: Not a valid "DirectoryEntryStream" resource.');var $=un++;fe.set($,{rep:N,own:!0}),M(y).setInt32(b+4,$,!0);break}case"err":{let N=Q.val;M(y).setInt8(b+0,1,!0);var V=N;let P;switch(V){case"access":{P=0;break}case"would-block":{P=1;break}case"already":{P=2;break}case"bad-descriptor":{P=3;break}case"busy":{P=4;break}case"deadlock":{P=5;break}case"quota":{P=6;break}case"exist":{P=7;break}case"file-too-large":{P=8;break}case"illegal-byte-sequence":{P=9;break}case"in-progress":{P=10;break}case"interrupted":{P=11;break}case"invalid":{P=12;break}case"io":{P=13;break}case"is-directory":{P=14;break}case"loop":{P=15;break}case"too-many-links":{P=16;break}case"message-size":{P=17;break}case"name-too-long":{P=18;break}case"no-device":{P=19;break}case"no-entry":{P=20;break}case"no-lock":{P=21;break}case"insufficient-memory":{P=22;break}case"insufficient-space":{P=23;break}case"not-directory":{P=24;break}case"not-empty":{P=25;break}case"not-recoverable":{P=26;break}case"unsupported":{P=27;break}case"no-tty":{P=28;break}case"no-such-device":{P=29;break}case"overflow":{P=30;break}case"not-permitted":{P=31;break}case"pipe":{P=32;break}case"read-only":{P=33;break}case"invalid-seek":{P=34;break}case"text-file-busy":{P=35;break}case"cross-device":{P=36;break}default:throw N instanceof Error&&console.error(N),new TypeError(`"${V}" is not one of the cases of error-code`)}M(y).setInt8(b+4,P,!0);break}default:throw new TypeError("invalid variant specified for result")}}function It(H,b,Y,q){var U=H,Q=Mt.get(U).rep,$=b,V=Y,N=Fe.decode(new Uint8Array(y.buffer,$,V));let P;try{P={tag:"ok",val:v.prototype.createDirectoryAt.call(Q,N)}}catch(at){P={tag:"err",val:wt(at)}}var L=P;switch(L.tag){case"ok":{let at=L.val;M(y).setInt8(q+0,0,!0);break}case"err":{let at=L.val;M(y).setInt8(q+0,1,!0);var lt=at;let C;switch(lt){case"access":{C=0;break}case"would-block":{C=1;break}case"already":{C=2;break}case"bad-descriptor":{C=3;break}case"busy":{C=4;break}case"deadlock":{C=5;break}case"quota":{C=6;break}case"exist":{C=7;break}case"file-too-large":{C=8;break}case"illegal-byte-sequence":{C=9;break}case"in-progress":{C=10;break}case"interrupted":{C=11;break}case"invalid":{C=12;break}case"io":{C=13;break}case"is-directory":{C=14;break}case"loop":{C=15;break}case"too-many-links":{C=16;break}case"message-size":{C=17;break}case"name-too-long":{C=18;break}case"no-device":{C=19;break}case"no-entry":{C=20;break}case"no-lock":{C=21;break}case"insufficient-memory":{C=22;break}case"insufficient-space":{C=23;break}case"not-directory":{C=24;break}case"not-empty":{C=25;break}case"not-recoverable":{C=26;break}case"unsupported":{C=27;break}case"no-tty":{C=28;break}case"no-such-device":{C=29;break}case"overflow":{C=30;break}case"not-permitted":{C=31;break}case"pipe":{C=32;break}case"read-only":{C=33;break}case"invalid-seek":{C=34;break}case"text-file-busy":{C=35;break}case"cross-device":{C=36;break}default:throw at instanceof Error&&console.error(at),new TypeError(`"${lt}" is not one of the cases of error-code`)}M(y).setInt8(q+1,C,!0);break}default:throw new TypeError("invalid variant specified for result")}}function Nt(H,b){var Y=H,q=Mt.get(Y).rep;let U;try{U={tag:"ok",val:v.prototype.stat.call(q)}}catch(Ut){U={tag:"err",val:wt(Ut)}}var Q=U;switch(Q.tag){case"ok":{let Ut=Q.val;M(y).setInt8(b+0,0,!0);var{type:$,linkCount:V,size:N,dataAccessTimestamp:P,dataModificationTimestamp:L,statusChangeTimestamp:lt}=Ut,at=$;let st;switch(at){case"unknown":{st=0;break}case"block-device":{st=1;break}case"character-device":{st=2;break}case"directory":{st=3;break}case"fifo":{st=4;break}case"symbolic-link":{st=5;break}case"regular-file":{st=6;break}case"socket":{st=7;break}default:throw $ instanceof Error&&console.error($),new TypeError(`"${at}" is not one of the cases of descriptor-type`)}M(y).setInt8(b+8,st,!0),M(y).setBigInt64(b+16,zt(V),!0),M(y).setBigInt64(b+24,zt(N),!0);var C=P;if(C==null)M(y).setInt8(b+32,0,!0);else{let _e=C;M(y).setInt8(b+32,1,!0);var{seconds:nt,nanoseconds:Ot}=_e;M(y).setBigInt64(b+40,zt(nt),!0),M(y).setInt32(b+48,ye(Ot),!0)}var Bt=L;if(Bt==null)M(y).setInt8(b+56,0,!0);else{let _e=Bt;M(y).setInt8(b+56,1,!0);var{seconds:ut,nanoseconds:ne}=_e;M(y).setBigInt64(b+64,zt(ut),!0),M(y).setInt32(b+72,ye(ne),!0)}var Ft=lt;if(Ft==null)M(y).setInt8(b+80,0,!0);else{let _e=Ft;M(y).setInt8(b+80,1,!0);var{seconds:ct,nanoseconds:pe}=_e;M(y).setBigInt64(b+88,zt(ct),!0),M(y).setInt32(b+96,ye(pe),!0)}break}case"err":{let Ut=Q.val;M(y).setInt8(b+0,1,!0);var ue=Ut;let st;switch(ue){case"access":{st=0;break}case"would-block":{st=1;break}case"already":{st=2;break}case"bad-descriptor":{st=3;break}case"busy":{st=4;break}case"deadlock":{st=5;break}case"quota":{st=6;break}case"exist":{st=7;break}case"file-too-large":{st=8;break}case"illegal-byte-sequence":{st=9;break}case"in-progress":{st=10;break}case"interrupted":{st=11;break}case"invalid":{st=12;break}case"io":{st=13;break}case"is-directory":{st=14;break}case"loop":{st=15;break}case"too-many-links":{st=16;break}case"message-size":{st=17;break}case"name-too-long":{st=18;break}case"no-device":{st=19;break}case"no-entry":{st=20;break}case"no-lock":{st=21;break}case"insufficient-memory":{st=22;break}case"insufficient-space":{st=23;break}case"not-directory":{st=24;break}case"not-empty":{st=25;break}case"not-recoverable":{st=26;break}case"unsupported":{st=27;break}case"no-tty":{st=28;break}case"no-such-device":{st=29;break}case"overflow":{st=30;break}case"not-permitted":{st=31;break}case"pipe":{st=32;break}case"read-only":{st=33;break}case"invalid-seek":{st=34;break}case"text-file-busy":{st=35;break}case"cross-device":{st=36;break}default:throw Ut instanceof Error&&console.error(Ut),new TypeError(`"${ue}" is not one of the cases of error-code`)}M(y).setInt8(b+8,st,!0);break}default:throw new TypeError("invalid variant specified for result")}}function ie(H,b,Y,q,U){var Q=H,$=Mt.get(Q).rep;if(b&4294967294)throw new TypeError("flags have extraneous bits set");var V={symlinkFollow:!!(b&1)},N=Y,P=q,L=Fe.decode(new Uint8Array(y.buffer,N,P));let lt;try{lt={tag:"ok",val:v.prototype.statAt.call($,V,L)}}catch(re){lt={tag:"err",val:wt(re)}}var at=lt;switch(at.tag){case"ok":{let re=at.val;M(y).setInt8(U+0,0,!0);var{type:C,linkCount:nt,size:Ot,dataAccessTimestamp:Bt,dataModificationTimestamp:ut,statusChangeTimestamp:ne}=re,Ft=C;let dt;switch(Ft){case"unknown":{dt=0;break}case"block-device":{dt=1;break}case"character-device":{dt=2;break}case"directory":{dt=3;break}case"fifo":{dt=4;break}case"symbolic-link":{dt=5;break}case"regular-file":{dt=6;break}case"socket":{dt=7;break}default:throw C instanceof Error&&console.error(C),new TypeError(`"${Ft}" is not one of the cases of descriptor-type`)}M(y).setInt8(U+8,dt,!0),M(y).setBigInt64(U+16,zt(nt),!0),M(y).setBigInt64(U+24,zt(Ot),!0);var ct=Bt;if(ct==null)M(y).setInt8(U+32,0,!0);else{let ge=ct;M(y).setInt8(U+32,1,!0);var{seconds:pe,nanoseconds:ue}=ge;M(y).setBigInt64(U+40,zt(pe),!0),M(y).setInt32(U+48,ye(ue),!0)}var Ut=ut;if(Ut==null)M(y).setInt8(U+56,0,!0);else{let ge=Ut;M(y).setInt8(U+56,1,!0);var{seconds:st,nanoseconds:_e}=ge;M(y).setBigInt64(U+64,zt(st),!0),M(y).setInt32(U+72,ye(_e),!0)}var Re=ne;if(Re==null)M(y).setInt8(U+80,0,!0);else{let ge=Re;M(y).setInt8(U+80,1,!0);var{seconds:we,nanoseconds:xe}=ge;M(y).setBigInt64(U+88,zt(we),!0),M(y).setInt32(U+96,ye(xe),!0)}break}case"err":{let re=at.val;M(y).setInt8(U+0,1,!0);var cn=re;let dt;switch(cn){case"access":{dt=0;break}case"would-block":{dt=1;break}case"already":{dt=2;break}case"bad-descriptor":{dt=3;break}case"busy":{dt=4;break}case"deadlock":{dt=5;break}case"quota":{dt=6;break}case"exist":{dt=7;break}case"file-too-large":{dt=8;break}case"illegal-byte-sequence":{dt=9;break}case"in-progress":{dt=10;break}case"interrupted":{dt=11;break}case"invalid":{dt=12;break}case"io":{dt=13;break}case"is-directory":{dt=14;break}case"loop":{dt=15;break}case"too-many-links":{dt=16;break}case"message-size":{dt=17;break}case"name-too-long":{dt=18;break}case"no-device":{dt=19;break}case"no-entry":{dt=20;break}case"no-lock":{dt=21;break}case"insufficient-memory":{dt=22;break}case"insufficient-space":{dt=23;break}case"not-directory":{dt=24;break}case"not-empty":{dt=25;break}case"not-recoverable":{dt=26;break}case"unsupported":{dt=27;break}case"no-tty":{dt=28;break}case"no-such-device":{dt=29;break}case"overflow":{dt=30;break}case"not-permitted":{dt=31;break}case"pipe":{dt=32;break}case"read-only":{dt=33;break}case"invalid-seek":{dt=34;break}case"text-file-busy":{dt=35;break}case"cross-device":{dt=36;break}default:throw re instanceof Error&&console.error(re),new TypeError(`"${cn}" is not one of the cases of error-code`)}M(y).setInt8(U+8,dt,!0);break}default:throw new TypeError("invalid variant specified for result")}}function Ne(H,b,Y,q,U,Q,$){var V=H,N=Mt.get(V).rep;if(b&4294967294)throw new TypeError("flags have extraneous bits set");var P={symlinkFollow:!!(b&1)},L=Y,lt=q,at=Fe.decode(new Uint8Array(y.buffer,L,lt));if(U&4294967280)throw new TypeError("flags have extraneous bits set");var C={create:!!(U&1),directory:!!(U&2),exclusive:!!(U&4),truncate:!!(U&8)};if(Q&4294967232)throw new TypeError("flags have extraneous bits set");var nt={read:!!(Q&1),write:!!(Q&2),fileIntegritySync:!!(Q&4),dataIntegritySync:!!(Q&8),requestedWriteSync:!!(Q&16),mutateDirectory:!!(Q&32)};let Ot;try{Ot={tag:"ok",val:v.prototype.openAt.call(N,P,at,C,nt)}}catch(Ft){Ot={tag:"err",val:wt(Ft)}}var Bt=Ot;switch(Bt.tag){case"ok":{let Ft=Bt.val;if(M(y).setInt8($+0,0,!0),!(Ft instanceof v))throw new Error('Resource error: Not a valid "Descriptor" resource.');var ut=Ue++;Mt.set(ut,{rep:Ft,own:!0}),M(y).setInt32($+4,ut,!0);break}case"err":{let Ft=Bt.val;M(y).setInt8($+0,1,!0);var ne=Ft;let ct;switch(ne){case"access":{ct=0;break}case"would-block":{ct=1;break}case"already":{ct=2;break}case"bad-descriptor":{ct=3;break}case"busy":{ct=4;break}case"deadlock":{ct=5;break}case"quota":{ct=6;break}case"exist":{ct=7;break}case"file-too-large":{ct=8;break}case"illegal-byte-sequence":{ct=9;break}case"in-progress":{ct=10;break}case"interrupted":{ct=11;break}case"invalid":{ct=12;break}case"io":{ct=13;break}case"is-directory":{ct=14;break}case"loop":{ct=15;break}case"too-many-links":{ct=16;break}case"message-size":{ct=17;break}case"name-too-long":{ct=18;break}case"no-device":{ct=19;break}case"no-entry":{ct=20;break}case"no-lock":{ct=21;break}case"insufficient-memory":{ct=22;break}case"insufficient-space":{ct=23;break}case"not-directory":{ct=24;break}case"not-empty":{ct=25;break}case"not-recoverable":{ct=26;break}case"unsupported":{ct=27;break}case"no-tty":{ct=28;break}case"no-such-device":{ct=29;break}case"overflow":{ct=30;break}case"not-permitted":{ct=31;break}case"pipe":{ct=32;break}case"read-only":{ct=33;break}case"invalid-seek":{ct=34;break}case"text-file-busy":{ct=35;break}case"cross-device":{ct=36;break}default:throw Ft instanceof Error&&console.error(Ft),new TypeError(`"${ne}" is not one of the cases of error-code`)}M(y).setInt8($+4,ct,!0);break}default:throw new TypeError("invalid variant specified for result")}}function ee(H,b,Y,q){var U=H,Q=Mt.get(U).rep,$=b,V=Y,N=Fe.decode(new Uint8Array(y.buffer,$,V));let P;try{P={tag:"ok",val:v.prototype.removeDirectoryAt.call(Q,N)}}catch(at){P={tag:"err",val:wt(at)}}var L=P;switch(L.tag){case"ok":{let at=L.val;M(y).setInt8(q+0,0,!0);break}case"err":{let at=L.val;M(y).setInt8(q+0,1,!0);var lt=at;let C;switch(lt){case"access":{C=0;break}case"would-block":{C=1;break}case"already":{C=2;break}case"bad-descriptor":{C=3;break}case"busy":{C=4;break}case"deadlock":{C=5;break}case"quota":{C=6;break}case"exist":{C=7;break}case"file-too-large":{C=8;break}case"illegal-byte-sequence":{C=9;break}case"in-progress":{C=10;break}case"interrupted":{C=11;break}case"invalid":{C=12;break}case"io":{C=13;break}case"is-directory":{C=14;break}case"loop":{C=15;break}case"too-many-links":{C=16;break}case"message-size":{C=17;break}case"name-too-long":{C=18;break}case"no-device":{C=19;break}case"no-entry":{C=20;break}case"no-lock":{C=21;break}case"insufficient-memory":{C=22;break}case"insufficient-space":{C=23;break}case"not-directory":{C=24;break}case"not-empty":{C=25;break}case"not-recoverable":{C=26;break}case"unsupported":{C=27;break}case"no-tty":{C=28;break}case"no-such-device":{C=29;break}case"overflow":{C=30;break}case"not-permitted":{C=31;break}case"pipe":{C=32;break}case"read-only":{C=33;break}case"invalid-seek":{C=34;break}case"text-file-busy":{C=35;break}case"cross-device":{C=36;break}default:throw at instanceof Error&&console.error(at),new TypeError(`"${lt}" is not one of the cases of error-code`)}M(y).setInt8(q+1,C,!0);break}default:throw new TypeError("invalid variant specified for result")}}function Ie(H,b,Y,q){var U=H,Q=Mt.get(U).rep,$=b,V=Y,N=Fe.decode(new Uint8Array(y.buffer,$,V));let P;try{P={tag:"ok",val:v.prototype.unlinkFileAt.call(Q,N)}}catch(at){P={tag:"err",val:wt(at)}}var L=P;switch(L.tag){case"ok":{let at=L.val;M(y).setInt8(q+0,0,!0);break}case"err":{let at=L.val;M(y).setInt8(q+0,1,!0);var lt=at;let C;switch(lt){case"access":{C=0;break}case"would-block":{C=1;break}case"already":{C=2;break}case"bad-descriptor":{C=3;break}case"busy":{C=4;break}case"deadlock":{C=5;break}case"quota":{C=6;break}case"exist":{C=7;break}case"file-too-large":{C=8;break}case"illegal-byte-sequence":{C=9;break}case"in-progress":{C=10;break}case"interrupted":{C=11;break}case"invalid":{C=12;break}case"io":{C=13;break}case"is-directory":{C=14;break}case"loop":{C=15;break}case"too-many-links":{C=16;break}case"message-size":{C=17;break}case"name-too-long":{C=18;break}case"no-device":{C=19;break}case"no-entry":{C=20;break}case"no-lock":{C=21;break}case"insufficient-memory":{C=22;break}case"insufficient-space":{C=23;break}case"not-directory":{C=24;break}case"not-empty":{C=25;break}case"not-recoverable":{C=26;break}case"unsupported":{C=27;break}case"no-tty":{C=28;break}case"no-such-device":{C=29;break}case"overflow":{C=30;break}case"not-permitted":{C=31;break}case"pipe":{C=32;break}case"read-only":{C=33;break}case"invalid-seek":{C=34;break}case"text-file-busy":{C=35;break}case"cross-device":{C=36;break}default:throw at instanceof Error&&console.error(at),new TypeError(`"${lt}" is not one of the cases of error-code`)}M(y).setInt8(q+1,C,!0);break}default:throw new TypeError("invalid variant specified for result")}}function Ce(H,b){var Y=H,q=Mt.get(Y).rep;let U;try{U={tag:"ok",val:v.prototype.metadataHash.call(q)}}catch(P){U={tag:"err",val:wt(P)}}var Q=U;switch(Q.tag){case"ok":{let P=Q.val;M(y).setInt8(b+0,0,!0);var{lower:$,upper:V}=P;M(y).setBigInt64(b+8,zt($),!0),M(y).setBigInt64(b+16,zt(V),!0);break}case"err":{let P=Q.val;M(y).setInt8(b+0,1,!0);var N=P;let L;switch(N){case"access":{L=0;break}case"would-block":{L=1;break}case"already":{L=2;break}case"bad-descriptor":{L=3;break}case"busy":{L=4;break}case"deadlock":{L=5;break}case"quota":{L=6;break}case"exist":{L=7;break}case"file-too-large":{L=8;break}case"illegal-byte-sequence":{L=9;break}case"in-progress":{L=10;break}case"interrupted":{L=11;break}case"invalid":{L=12;break}case"io":{L=13;break}case"is-directory":{L=14;break}case"loop":{L=15;break}case"too-many-links":{L=16;break}case"message-size":{L=17;break}case"name-too-long":{L=18;break}case"no-device":{L=19;break}case"no-entry":{L=20;break}case"no-lock":{L=21;break}case"insufficient-memory":{L=22;break}case"insufficient-space":{L=23;break}case"not-directory":{L=24;break}case"not-empty":{L=25;break}case"not-recoverable":{L=26;break}case"unsupported":{L=27;break}case"no-tty":{L=28;break}case"no-such-device":{L=29;break}case"overflow":{L=30;break}case"not-permitted":{L=31;break}case"pipe":{L=32;break}case"read-only":{L=33;break}case"invalid-seek":{L=34;break}case"text-file-busy":{L=35;break}case"cross-device":{L=36;break}default:throw P instanceof Error&&console.error(P),new TypeError(`"${N}" is not one of the cases of error-code`)}M(y).setInt8(b+8,L,!0);break}default:throw new TypeError("invalid variant specified for result")}}function Te(H,b,Y,q,U){var Q=H,$=Mt.get(Q).rep;if(b&4294967294)throw new TypeError("flags have extraneous bits set");var V={symlinkFollow:!!(b&1)},N=Y,P=q,L=Fe.decode(new Uint8Array(y.buffer,N,P));let lt;try{lt={tag:"ok",val:v.prototype.metadataHashAt.call($,V,L)}}catch(Bt){lt={tag:"err",val:wt(Bt)}}var at=lt;switch(at.tag){case"ok":{let Bt=at.val;M(y).setInt8(U+0,0,!0);var{lower:C,upper:nt}=Bt;M(y).setBigInt64(U+8,zt(C),!0),M(y).setBigInt64(U+16,zt(nt),!0);break}case"err":{let Bt=at.val;M(y).setInt8(U+0,1,!0);var Ot=Bt;let ut;switch(Ot){case"access":{ut=0;break}case"would-block":{ut=1;break}case"already":{ut=2;break}case"bad-descriptor":{ut=3;break}case"busy":{ut=4;break}case"deadlock":{ut=5;break}case"quota":{ut=6;break}case"exist":{ut=7;break}case"file-too-large":{ut=8;break}case"illegal-byte-sequence":{ut=9;break}case"in-progress":{ut=10;break}case"interrupted":{ut=11;break}case"invalid":{ut=12;break}case"io":{ut=13;break}case"is-directory":{ut=14;break}case"loop":{ut=15;break}case"too-many-links":{ut=16;break}case"message-size":{ut=17;break}case"name-too-long":{ut=18;break}case"no-device":{ut=19;break}case"no-entry":{ut=20;break}case"no-lock":{ut=21;break}case"insufficient-memory":{ut=22;break}case"insufficient-space":{ut=23;break}case"not-directory":{ut=24;break}case"not-empty":{ut=25;break}case"not-recoverable":{ut=26;break}case"unsupported":{ut=27;break}case"no-tty":{ut=28;break}case"no-such-device":{ut=29;break}case"overflow":{ut=30;break}case"not-permitted":{ut=31;break}case"pipe":{ut=32;break}case"read-only":{ut=33;break}case"invalid-seek":{ut=34;break}case"text-file-busy":{ut=35;break}case"cross-device":{ut=36;break}default:throw Bt instanceof Error&&console.error(Bt),new TypeError(`"${Ot}" is not one of the cases of error-code`)}M(y).setInt8(U+8,ut,!0);break}default:throw new TypeError("invalid variant specified for result")}}function Tt(H,b){var Y=H,q=fe.get(Y).rep;let U;try{U={tag:"ok",val:tt.prototype.readDirectoryEntry.call(q)}}catch(C){U={tag:"err",val:wt(C)}}var Q=U;switch(Q.tag){case"ok":{let C=Q.val;M(y).setInt8(b+0,0,!0);var $=C;if($==null)M(y).setInt8(b+4,0,!0);else{let nt=$;M(y).setInt8(b+4,1,!0);var{type:V,name:N}=nt,P=V;let Ot;switch(P){case"unknown":{Ot=0;break}case"block-device":{Ot=1;break}case"character-device":{Ot=2;break}case"directory":{Ot=3;break}case"fifo":{Ot=4;break}case"symbolic-link":{Ot=5;break}case"regular-file":{Ot=6;break}case"socket":{Ot=7;break}default:throw V instanceof Error&&console.error(V),new TypeError(`"${P}" is not one of the cases of descriptor-type`)}M(y).setInt8(b+8,Ot,!0);var L=Xe(N,B,y),lt=Se;M(y).setInt32(b+16,lt,!0),M(y).setInt32(b+12,L,!0)}break}case"err":{let C=Q.val;M(y).setInt8(b+0,1,!0);var at=C;let nt;switch(at){case"access":{nt=0;break}case"would-block":{nt=1;break}case"already":{nt=2;break}case"bad-descriptor":{nt=3;break}case"busy":{nt=4;break}case"deadlock":{nt=5;break}case"quota":{nt=6;break}case"exist":{nt=7;break}case"file-too-large":{nt=8;break}case"illegal-byte-sequence":{nt=9;break}case"in-progress":{nt=10;break}case"interrupted":{nt=11;break}case"invalid":{nt=12;break}case"io":{nt=13;break}case"is-directory":{nt=14;break}case"loop":{nt=15;break}case"too-many-links":{nt=16;break}case"message-size":{nt=17;break}case"name-too-long":{nt=18;break}case"no-device":{nt=19;break}case"no-entry":{nt=20;break}case"no-lock":{nt=21;break}case"insufficient-memory":{nt=22;break}case"insufficient-space":{nt=23;break}case"not-directory":{nt=24;break}case"not-empty":{nt=25;break}case"not-recoverable":{nt=26;break}case"unsupported":{nt=27;break}case"no-tty":{nt=28;break}case"no-such-device":{nt=29;break}case"overflow":{nt=30;break}case"not-permitted":{nt=31;break}case"pipe":{nt=32;break}case"read-only":{nt=33;break}case"invalid-seek":{nt=34;break}case"text-file-busy":{nt=35;break}case"cross-device":{nt=36;break}default:throw C instanceof Error&&console.error(C),new TypeError(`"${at}" is not one of the cases of error-code`)}M(y).setInt8(b+4,nt,!0);break}default:throw new TypeError("invalid variant specified for result")}}function Ae(H,b){var Y=H,q=Zt.get(Y).rep,Q=z(q);if(Q==null)M(y).setInt8(b+0,0,!0);else{let V=Q;M(y).setInt8(b+0,1,!0);var $=V;let N;switch($){case"access":{N=0;break}case"would-block":{N=1;break}case"already":{N=2;break}case"bad-descriptor":{N=3;break}case"busy":{N=4;break}case"deadlock":{N=5;break}case"quota":{N=6;break}case"exist":{N=7;break}case"file-too-large":{N=8;break}case"illegal-byte-sequence":{N=9;break}case"in-progress":{N=10;break}case"interrupted":{N=11;break}case"invalid":{N=12;break}case"io":{N=13;break}case"is-directory":{N=14;break}case"loop":{N=15;break}case"too-many-links":{N=16;break}case"message-size":{N=17;break}case"name-too-long":{N=18;break}case"no-device":{N=19;break}case"no-entry":{N=20;break}case"no-lock":{N=21;break}case"insufficient-memory":{N=22;break}case"insufficient-space":{N=23;break}case"not-directory":{N=24;break}case"not-empty":{N=25;break}case"not-recoverable":{N=26;break}case"unsupported":{N=27;break}case"no-tty":{N=28;break}case"no-such-device":{N=29;break}case"overflow":{N=30;break}case"not-permitted":{N=31;break}case"pipe":{N=32;break}case"read-only":{N=33;break}case"invalid-seek":{N=34;break}case"text-file-busy":{N=35;break}case"cross-device":{N=36;break}default:throw V instanceof Error&&console.error(V),new TypeError(`"${$}" is not one of the cases of error-code`)}M(y).setInt8(b+1,N,!0)}}function Le(H,b,Y){var q=H,U=oe.get(q).rep;let Q;try{Q={tag:"ok",val:rt.prototype.read.call(U,BigInt.asUintN(64,b))}}catch(C){Q={tag:"err",val:wt(C)}}var $=Q;switch($.tag){case"ok":{let C=$.val;M(y).setInt8(Y+0,0,!0);var V=C,N=V.byteLength,P=B(0,0,1,N*1),L=new Uint8Array(V.buffer||V,V.byteOffset,N*1);new Uint8Array(y.buffer,P,N*1).set(L),M(y).setInt32(Y+8,N,!0),M(y).setInt32(Y+4,P,!0);break}case"err":{let C=$.val;M(y).setInt8(Y+0,1,!0);var lt=C;switch(lt.tag){case"last-operation-failed":{let nt=lt.val;if(M(y).setInt8(Y+4,0,!0),!(nt instanceof At))throw new Error('Resource error: Not a valid "Error" resource.');var at=se++;Zt.set(at,{rep:nt,own:!0}),M(y).setInt32(Y+8,at,!0);break}case"closed":{M(y).setInt8(Y+4,1,!0);break}default:throw new TypeError(`invalid variant tag value \`${JSON.stringify(lt.tag)}\` (received \`${lt}\`) specified for \`StreamError\``)}break}default:throw new TypeError("invalid variant specified for result")}}function $t(H,b,Y){var q=H,U=oe.get(q).rep;let Q;try{Q={tag:"ok",val:rt.prototype.blockingRead.call(U,BigInt.asUintN(64,b))}}catch(C){Q={tag:"err",val:wt(C)}}var $=Q;switch($.tag){case"ok":{let C=$.val;M(y).setInt8(Y+0,0,!0);var V=C,N=V.byteLength,P=B(0,0,1,N*1),L=new Uint8Array(V.buffer||V,V.byteOffset,N*1);new Uint8Array(y.buffer,P,N*1).set(L),M(y).setInt32(Y+8,N,!0),M(y).setInt32(Y+4,P,!0);break}case"err":{let C=$.val;M(y).setInt8(Y+0,1,!0);var lt=C;switch(lt.tag){case"last-operation-failed":{let nt=lt.val;if(M(y).setInt8(Y+4,0,!0),!(nt instanceof At))throw new Error('Resource error: Not a valid "Error" resource.');var at=se++;Zt.set(at,{rep:nt,own:!0}),M(y).setInt32(Y+8,at,!0);break}case"closed":{M(y).setInt8(Y+4,1,!0);break}default:throw new TypeError(`invalid variant tag value \`${JSON.stringify(lt.tag)}\` (received \`${lt}\`) specified for \`StreamError\``)}break}default:throw new TypeError("invalid variant specified for result")}}function Qe(H,b){var Y=H,q=qt.get(Y).rep;let U;try{U={tag:"ok",val:J.prototype.checkWrite.call(q)}}catch(N){U={tag:"err",val:wt(N)}}var Q=U;switch(Q.tag){case"ok":{let N=Q.val;M(y).setInt8(b+0,0,!0),M(y).setBigInt64(b+8,zt(N),!0);break}case"err":{let N=Q.val;M(y).setInt8(b+0,1,!0);var $=N;switch($.tag){case"last-operation-failed":{let P=$.val;if(M(y).setInt8(b+8,0,!0),!(P instanceof At))throw new Error('Resource error: Not a valid "Error" resource.');var V=se++;Zt.set(V,{rep:P,own:!0}),M(y).setInt32(b+12,V,!0);break}case"closed":{M(y).setInt8(b+8,1,!0);break}default:throw new TypeError(`invalid variant tag value \`${JSON.stringify($.tag)}\` (received \`${$}\`) specified for \`StreamError\``)}break}default:throw new TypeError("invalid variant specified for result")}}function je(H,b,Y,q){var U=H,Q=qt.get(U).rep,$=b,V=Y,N=new Uint8Array(y.buffer.slice($,$+V*1));let P;try{P={tag:"ok",val:J.prototype.write.call(Q,N)}}catch(C){P={tag:"err",val:wt(C)}}var L=P;switch(L.tag){case"ok":{let C=L.val;M(y).setInt8(q+0,0,!0);break}case"err":{let C=L.val;M(y).setInt8(q+0,1,!0);var lt=C;switch(lt.tag){case"last-operation-failed":{let nt=lt.val;if(M(y).setInt8(q+4,0,!0),!(nt instanceof At))throw new Error('Resource error: Not a valid "Error" resource.');var at=se++;Zt.set(at,{rep:nt,own:!0}),M(y).setInt32(q+8,at,!0);break}case"closed":{M(y).setInt8(q+4,1,!0);break}default:throw new TypeError(`invalid variant tag value \`${JSON.stringify(lt.tag)}\` (received \`${lt}\`) specified for \`StreamError\``)}break}default:throw new TypeError("invalid variant specified for result")}}function $e(H,b,Y,q){var U=H,Q=qt.get(U).rep,$=b,V=Y,N=new Uint8Array(y.buffer.slice($,$+V*1));let P;try{P={tag:"ok",val:J.prototype.blockingWriteAndFlush.call(Q,N)}}catch(C){P={tag:"err",val:wt(C)}}var L=P;switch(L.tag){case"ok":{let C=L.val;M(y).setInt8(q+0,0,!0);break}case"err":{let C=L.val;M(y).setInt8(q+0,1,!0);var lt=C;switch(lt.tag){case"last-operation-failed":{let nt=lt.val;if(M(y).setInt8(q+4,0,!0),!(nt instanceof At))throw new Error('Resource error: Not a valid "Error" resource.');var at=se++;Zt.set(at,{rep:nt,own:!0}),M(y).setInt32(q+8,at,!0);break}case"closed":{M(y).setInt8(q+4,1,!0);break}default:throw new TypeError(`invalid variant tag value \`${JSON.stringify(lt.tag)}\` (received \`${lt}\`) specified for \`StreamError\``)}break}default:throw new TypeError("invalid variant specified for result")}}function We(H,b){var Y=H,q=qt.get(Y).rep;let U;try{U={tag:"ok",val:J.prototype.blockingFlush.call(q)}}catch(N){U={tag:"err",val:wt(N)}}var Q=U;switch(Q.tag){case"ok":{let N=Q.val;M(y).setInt8(b+0,0,!0);break}case"err":{let N=Q.val;M(y).setInt8(b+0,1,!0);var $=N;switch($.tag){case"last-operation-failed":{let P=$.val;if(M(y).setInt8(b+4,0,!0),!(P instanceof At))throw new Error('Resource error: Not a valid "Error" resource.');var V=se++;Zt.set(V,{rep:P,own:!0}),M(y).setInt32(b+8,V,!0);break}case"closed":{M(y).setInt8(b+4,1,!0);break}default:throw new TypeError(`invalid variant tag value \`${JSON.stringify($.tag)}\` (received \`${$}\`) specified for \`StreamError\``)}break}default:throw new TypeError("invalid variant specified for result")}}function qe(H){var Y=h(),q=Y.length,U=B(0,0,4,q*16);for(let lt=0;lt<Y.length;lt++){let at=Y[lt],C=U+lt*16;var[Q,$]=at,V=Xe(Q,B,y),N=Se;M(y).setInt32(C+4,N,!0),M(y).setInt32(C+0,V,!0);var P=Xe($,B,y),L=Se;M(y).setInt32(C+12,L,!0),M(y).setInt32(C+8,P,!0)}M(y).setInt32(H+4,q,!0),M(y).setInt32(H+0,U,!0)}function Oe(H){var Y=R(),q=Y.length,U=B(0,0,4,q*8);for(let V=0;V<Y.length;V++){let N=Y[V],P=U+V*8;var Q=Xe(N,B,y),$=Se;M(y).setInt32(P+4,$,!0),M(y).setInt32(P+0,Q,!0)}M(y).setInt32(H+4,q,!0),M(y).setInt32(H+0,U,!0)}function Ze(H){var Y=k();if(Y==null)M(y).setInt8(H+0,0,!0);else{let U=Y;if(M(y).setInt8(H+0,1,!0),!(U instanceof m))throw new Error('Resource error: Not a valid "TerminalInput" resource.');var q=pn++;ve.set(q,{rep:U,own:!0}),M(y).setInt32(H+4,q,!0)}}function Je(H){var Y=Z();if(Y==null)M(y).setInt8(H+0,0,!0);else{let U=Y;if(M(y).setInt8(H+0,1,!0),!(U instanceof E))throw new Error('Resource error: Not a valid "TerminalOutput" resource.');var q=ke++;De.set(q,{rep:U,own:!0}),M(y).setInt32(H+4,q,!0)}}function tn(H){var Y=W();if(Y==null)M(y).setInt8(H+0,0,!0);else{let U=Y;if(M(y).setInt8(H+0,1,!0),!(U instanceof E))throw new Error('Resource error: Not a valid "TerminalOutput" resource.');var q=ke++;De.set(q,{rep:U,own:!0}),M(y).setInt32(H+4,q,!0)}}let en;function nn(H){let b=fe.get(H);if(!b)throw new Error(`Resource error: Invalid handle ${H}`);fe.delete(H),b.own&&b.rep[Qt]&&b.rep[Qt]()}function _n(H){let b=Zt.get(H);if(!b)throw new Error(`Resource error: Invalid handle ${H}`);Zt.delete(H),b.own&&b.rep[Qt]&&b.rep[Qt]()}function rn(H){let b=oe.get(H);if(!b)throw new Error(`Resource error: Invalid handle ${H}`);oe.delete(H),b.own&&b.rep[Qt]&&b.rep[Qt]()}function an(H){let b=qt.get(H);if(!b)throw new Error(`Resource error: Invalid handle ${H}`);qt.delete(H),b.own&&b.rep[Qt]&&b.rep[Qt]()}function sn(H){let b=Mt.get(H);if(!b)throw new Error(`Resource error: Invalid handle ${H}`);Mt.delete(H),b.own&&b.rep[Qt]&&b.rep[Qt]()}function on(H){let b=De.get(H);if(!b)throw new Error(`Resource error: Invalid handle ${H}`);De.delete(H),b.own&&b.rep[Qt]&&b.rep[Qt]()}function ln(H){let b=ve.get(H);if(!b)throw new Error(`Resource error: Invalid handle ${H}`);ve.delete(H),b.own&&b.rep[Qt]&&b.rep[Qt]()}({exports:G}=n(a)),{exports:ht}=n(_,{wasi_snapshot_preview1:{args_get:G[29],args_sizes_get:G[30],clock_time_get:G[33],environ_get:G[31],environ_sizes_get:G[32],fd_close:G[34],fd_fdstat_get:G[35],fd_fdstat_set_flags:G[36],fd_prestat_dir_name:G[38],fd_prestat_get:G[37],fd_read:G[39],fd_readdir:G[40],fd_renumber:G[41],fd_seek:G[42],fd_write:G[43],path_create_directory:G[44],path_filestat_get:G[45],path_open:G[46],path_remove_directory:G[47],path_unlink_file:G[48],proc_exit:G[49]}}),{exports:gt}=n(r,{__main_module__:{_start:ht._start},env:{memory:ht.memory},"wasi:cli/environment@0.2.0":{"get-arguments":G[25],"get-environment":G[24]},"wasi:cli/exit@0.2.0":{exit:vt},"wasi:cli/stderr@0.2.0":{"get-stderr":Lt},"wasi:cli/stdin@0.2.0":{"get-stdin":Ct},"wasi:cli/stdout@0.2.0":{"get-stdout":te},"wasi:cli/terminal-input@0.2.0":{"[resource-drop]terminal-input":ln},"wasi:cli/terminal-output@0.2.0":{"[resource-drop]terminal-output":on},"wasi:cli/terminal-stderr@0.2.0":{"get-terminal-stderr":G[28]},"wasi:cli/terminal-stdin@0.2.0":{"get-terminal-stdin":G[26]},"wasi:cli/terminal-stdout@0.2.0":{"get-terminal-stdout":G[27]},"wasi:clocks/monotonic-clock@0.2.0":{now:Pt},"wasi:clocks/wall-clock@0.2.0":{now:G[1]},"wasi:filesystem/preopens@0.2.0":{"get-directories":G[0]},"wasi:filesystem/types@0.2.0":{"[method]descriptor.append-via-stream":G[4],"[method]descriptor.create-directory-at":G[8],"[method]descriptor.get-flags":G[5],"[method]descriptor.get-type":G[6],"[method]descriptor.metadata-hash":G[14],"[method]descriptor.metadata-hash-at":G[15],"[method]descriptor.open-at":G[11],"[method]descriptor.read-directory":G[7],"[method]descriptor.read-via-stream":G[2],"[method]descriptor.remove-directory-at":G[12],"[method]descriptor.stat":G[9],"[method]descriptor.stat-at":G[10],"[method]descriptor.unlink-file-at":G[13],"[method]descriptor.write-via-stream":G[3],"[method]directory-entry-stream.read-directory-entry":G[16],"[resource-drop]descriptor":sn,"[resource-drop]directory-entry-stream":nn,"filesystem-error-code":G[17]},"wasi:io/error@0.2.0":{"[resource-drop]error":_n},"wasi:io/streams@0.2.0":{"[method]input-stream.blocking-read":G[19],"[method]input-stream.read":G[18],"[method]output-stream.blocking-flush":G[23],"[method]output-stream.blocking-write-and-flush":G[22],"[method]output-stream.check-write":G[20],"[method]output-stream.write":G[21],"[resource-drop]input-stream":rn,"[resource-drop]output-stream":an}}),y=ht.memory,B=gt.cabi_import_realloc,{exports:en}=n(o,{"":{$imports:G.$imports,0:jt,1:X,10:ie,11:Ne,12:ee,13:Ie,14:Ce,15:Te,16:Tt,17:Ae,18:Le,19:$t,2:_t,20:Qe,21:je,22:$e,23:We,24:qe,25:Oe,26:Ze,27:Je,28:tn,29:gt.args_get,3:yt,30:gt.args_sizes_get,31:gt.environ_get,32:gt.environ_sizes_get,33:gt.clock_time_get,34:gt.fd_close,35:gt.fd_fdstat_get,36:gt.fd_fdstat_set_flags,37:gt.fd_prestat_get,38:gt.fd_prestat_dir_name,39:gt.fd_read,4:Et,40:gt.fd_readdir,41:gt.fd_renumber,42:gt.fd_seek,43:gt.fd_write,44:gt.path_create_directory,45:gt.path_filestat_get,46:gt.path_open,47:gt.path_remove_directory,48:gt.path_unlink_file,49:gt.proc_exit,5:Wt,6:Ht,7:kt,8:It,9:Nt}});function dn(){let H=gt["wasi:cli/run@0.2.0#run"](),b;switch(H){case 0:{b={tag:"ok",val:void 0};break}case 1:{b={tag:"err",val:void 0};break}default:throw new TypeError("invalid variant discriminant for expected")}if(b.tag==="err")throw new yr(b.val);return b.val}let Zt=new Map,se=0,oe=new Map,He=0,qt=new Map,Ee=0,ve=new Map,pn=0,De=new Map,ke=0,Mt=new Map,Ue=0,fe=new Map,un=0,Me={run:dn};return{run:Me,"wasi:cli/run@0.2.0":Me}}var E_=new Pr(()=>Promise.resolve().then(()=>(c_(),u_)),br,"yowasp-yosys"),i0=E_.run.bind(E_);function be(t,e){console.log("[Worker] Sending",t),self.postMessage(t,{transfer:e})}function P_(t,e){let n=t.globals.get("dict"),_=n();try{return t.runPython(e,{globals:_,locals:_})}finally{_.destroy(),n.destroy()}}var Nr=i0().then(()=>{console.log("[Worker] Preloaded Yosys")}),s0=p_({env:{HOME:"/",AMARANTH_USE_YOSYS:"javascript"},stdout:t=>be({type:"stdoutWrite",text:`${t}
`}),stderr:t=>be({type:"stderrWrite",text:`${t}
`}),jsglobals:{Object,fetch:fetch.bind(globalThis),setTimeout:setTimeout.bind(globalThis),clearTimeout:clearTimeout.bind(globalThis),runAmaranthYosys:(t,e)=>{let n=new TextEncoder().encode(e),_=[],r=[];try{return i0(t.toJs(),{},{stdin:a=>{if(n.length===0)return null;let o=n.subarray(0,a);return n=n.subarray(a),o},stdout:a=>a?_.push(new TextDecoder().decode(a)):null,stderr:a=>a?r.push(new TextDecoder().decode(a)):null}),[0,_.join(""),r.join("")]}catch(a){if(a instanceof Ve)return[a.code,_.join(""),r.join("")];throw a}finally{t.destroy()}}}}).then(t=>{let e=P_(t,`import contextlib

def vcd_to_d3wave(vcd_file):
    from vcd.reader import TokenKind, tokenize

    root = {"name": "design", "type": {"name": "struct"}, "children": []}
    scope = [root]
    by_id = {}
    time = 0
    for token in tokenize(open(vcd_file, "rb")):
        if token.kind == TokenKind.SCOPE:
            new_child = {
                "name": token.data.ident,
                "type": {"name": "struct"},
                "children": []
            }
            scope[-1]["children"].append(new_child)
            scope.append(new_child)
        elif token.kind == TokenKind.UPSCOPE:
            scope.pop()
        elif token.kind == TokenKind.VAR:
            new_child = {
                "name": token.data.reference,
                "type": {"name": token.data.type_.value, "width": token.data.size},
                "data": []
            }
            scope[-1]["children"].append(new_child)
            by_id[token.data.id_code] = new_child
        elif token.kind == TokenKind.CHANGE_TIME:
            time = token.data
        elif token.kind in (TokenKind.CHANGE_SCALAR, TokenKind.CHANGE_VECTOR):
            signal = by_id[token.data.id_code]
            value = token.data.value
            if isinstance(value, int):
                value = f"{value:0{signal['type']['width']}d}"
            signal["data"].append([time, value])

    return (root if len(root["children"]) > 1 else root["children"][-1])


@contextlib.contextmanager
def show_waveforms(sim):
    import amaranth_playground

    vcd_file = "/tmp/waveforms.vcd"
    with sim.write_vcd(vcd_file=vcd_file):
        yield

    amaranth_playground._show_waveforms(vcd_to_d3wave(vcd_file=vcd_file))

show_waveforms
`);return t.registerJsModule("amaranth_playground",{show_rtlil:n=>be({type:"showRtlil",code:n}),show_verilog:n=>be({type:"showVerilog",code:n}),_show_waveforms:n=>be({type:"showWaveforms",data:n.toJs({dict_converter:Object.fromEntries})}),show_waveforms:e}),console.log("[Worker] Pyodide loaded"),t});self.onmessage=async t=>{if(console.log("[Worker] Received",t.data),t.data.type==="loadPackages"){let e=await s0;s0=e.loadPackage(t.data.pkgs).then(()=>e)}else if(t.data.type==="runPython"){await Nr;let e=await s0;try{P_(e,t.data.code),be({type:"pythonDone",error:null})}catch(n){be({type:"pythonDone",error:n.message})}}else throw new Error(`[Worker] Unexpected message ${t.data.type}`)};self.onerror=t=>{console.error("[Worker] Failure",t)};
//# sourceMappingURL=app.worker.js.map
