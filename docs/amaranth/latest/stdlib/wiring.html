<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Interfaces and connections &mdash; Amaranth language &amp; toolchain 0.6.0.dev10 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../_static/platformpicker.css" />
      <link rel="stylesheet" type="text/css" href="../_static/custom.css?v=d131d90a" />

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js?v=5d32c60e"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js?v=4a5a9f97"></script>
        <script src="../_static/doctools.js?v=888ff710"></script>
        <script src="../_static/sphinx_highlight.js?v=4825356b"></script>
        <script src="../_static/platformpicker.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Interface metadata" href="meta.html" />
    <link rel="prev" title="Data structures" href="data.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../cover.html" class="icon icon-home">
            Amaranth language & toolchain
              <img src="../_static/logo.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                0.6.0.dev10
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Language &amp; toolchain</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../intro.html">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../install.html">Installation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../start.html">Getting started</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial.html">Tutorial</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide.html">Language guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference.html">Language reference</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../stdlib.html">Standard library</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="enum.html">Enumerations</a></li>
<li class="toctree-l3"><a class="reference internal" href="data.html">Data structures</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Interfaces and connections</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="#signatures">Signatures</a></li>
<li class="toctree-l4"><a class="reference internal" href="#interfaces">Interfaces</a></li>
<li class="toctree-l4"><a class="reference internal" href="#making-connections">Making connections</a></li>
<li class="toctree-l4"><a class="reference internal" href="#components">Components</a></li>
<li class="toctree-l4"><a class="reference internal" href="#component-metadata">Component metadata</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="meta.html">Interface metadata</a></li>
<li class="toctree-l3"><a class="reference internal" href="stream.html">Data streams</a></li>
<li class="toctree-l3"><a class="reference internal" href="memory.html">Memory arrays</a></li>
<li class="toctree-l3"><a class="reference internal" href="io.html">Input/output buffers</a></li>
<li class="toctree-l3"><a class="reference internal" href="cdc.html">Clock domain crossing</a></li>
<li class="toctree-l3"><a class="reference internal" href="fifo.html">First-in first-out queues</a></li>
<li class="toctree-l3"><a class="reference internal" href="crc.html">Cyclic redundancy checks</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../simulator.html">Simulator</a></li>
<li class="toctree-l2"><a class="reference internal" href="../platform.html">Platform integration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html">Changelog</a></li>
<li class="toctree-l2"><a class="reference internal" href="../contrib.html">Contributing</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference external" href="https://amaranth-lang.org/docs/amaranth-stdio/latest/">Standard I/O components</a></li>
<li class="toctree-l1"><a class="reference external" href="https://amaranth-lang.org/docs/amaranth-soc/latest/">System on Chip toolkit</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../cover.html">Amaranth language & toolchain</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../cover.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Language &amp; toolchain</a></li>
          <li class="breadcrumb-item"><a href="../stdlib.html">Standard library</a></li>
      <li class="breadcrumb-item active">Interfaces and connections</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/stdlib/wiring.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-amaranth.lib.wiring">
<span id="interfaces-and-connections"></span><span id="wiring"></span><h1>Interfaces and connections<a class="headerlink" href="#module-amaranth.lib.wiring" title="Permalink to this heading"></a></h1>
<p>The <a class="reference internal" href="#module-amaranth.lib.wiring" title="amaranth.lib.wiring"><code class="xref py py-mod docutils literal notranslate"><span class="pre">amaranth.lib.wiring</span></code></a> module provides a way to declare the interfaces between design components and connect them to each other in a reliable and convenient way.</p>
<section id="introduction">
<span id="wiring-introduction"></span><h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this heading"></a></h2>
<section id="overview">
<h3>Overview<a class="headerlink" href="#overview" title="Permalink to this heading"></a></h3>
<p>This module provides four related facilities:</p>
<ol class="arabic simple">
<li><p>Description and construction of interface objects via <a class="reference internal" href="#amaranth.lib.wiring.Flow" title="amaranth.lib.wiring.Flow"><code class="xref py py-class docutils literal notranslate"><span class="pre">Flow</span></code></a> (<a class="reference internal" href="#amaranth.lib.wiring.In" title="amaranth.lib.wiring.In"><code class="xref py py-data docutils literal notranslate"><span class="pre">In</span></code></a> and <a class="reference internal" href="#amaranth.lib.wiring.Out" title="amaranth.lib.wiring.Out"><code class="xref py py-data docutils literal notranslate"><span class="pre">Out</span></code></a>), <a class="reference internal" href="#amaranth.lib.wiring.Member" title="amaranth.lib.wiring.Member"><code class="xref py py-class docutils literal notranslate"><span class="pre">Member</span></code></a>, and <a class="reference internal" href="#amaranth.lib.wiring.Signature" title="amaranth.lib.wiring.Signature"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signature</span></code></a>, as well as the associated container class <a class="reference internal" href="#amaranth.lib.wiring.SignatureMembers" title="amaranth.lib.wiring.SignatureMembers"><code class="xref py py-class docutils literal notranslate"><span class="pre">SignatureMembers</span></code></a>. These classes provide the syntax used in defining components, and are also useful for introspection.</p></li>
<li><p>Flipping of signatures and interface objects via <a class="reference internal" href="#amaranth.lib.wiring.FlippedSignature" title="amaranth.lib.wiring.FlippedSignature"><code class="xref py py-class docutils literal notranslate"><span class="pre">FlippedSignature</span></code></a> and <a class="reference internal" href="#amaranth.lib.wiring.FlippedInterface" title="amaranth.lib.wiring.FlippedInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">FlippedInterface</span></code></a>, as well as the associated container class <a class="reference internal" href="#amaranth.lib.wiring.FlippedSignatureMembers" title="amaranth.lib.wiring.FlippedSignatureMembers"><code class="xref py py-class docutils literal notranslate"><span class="pre">FlippedSignatureMembers</span></code></a>. This facility reduces boilerplate by adapting existing signatures and interface objects: the flip operation changes the <a class="reference internal" href="#amaranth.lib.wiring.In" title="amaranth.lib.wiring.In"><code class="xref py py-data docutils literal notranslate"><span class="pre">In</span></code></a> data flow of a member to <a class="reference internal" href="#amaranth.lib.wiring.Out" title="amaranth.lib.wiring.Out"><code class="xref py py-data docutils literal notranslate"><span class="pre">Out</span></code></a> and vice versa.</p></li>
<li><p>Connecting interface objects together via <a class="reference internal" href="#amaranth.lib.wiring.connect" title="amaranth.lib.wiring.connect"><code class="xref py py-func docutils literal notranslate"><span class="pre">connect()</span></code></a>. The <a class="reference internal" href="#amaranth.lib.wiring.connect" title="amaranth.lib.wiring.connect"><code class="xref py py-func docutils literal notranslate"><span class="pre">connect()</span></code></a> function ensures that the provided interface objects can be connected to each other, and adds the necessary <code class="code highlight py python docutils literal highlight-python"><span class="o">.</span><span class="n">eq</span><span class="p">()</span></code> statements to a <code class="xref py py-class docutils literal notranslate"><span class="pre">Module</span></code>.</p></li>
<li><p>Defining reusable, self-contained components via <a class="reference internal" href="#amaranth.lib.wiring.Component" title="amaranth.lib.wiring.Component"><code class="xref py py-class docutils literal notranslate"><span class="pre">Component</span></code></a>. Components are <code class="xref py py-class docutils literal notranslate"><span class="pre">Elaboratable</span></code> objects that interact with the rest of the design through an interface specified by their signature.</p></li>
</ol>
<p>To use this module, add the following imports to the beginning of the file:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">amaranth.lib</span> <span class="kn">import</span> <span class="n">wiring</span>
<span class="kn">from</span> <span class="nn">amaranth.lib.wiring</span> <span class="kn">import</span> <span class="n">In</span><span class="p">,</span> <span class="n">Out</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="#wiring-intro1"><span class="std std-ref">“Motivation”</span></a> and <a class="reference internal" href="#wiring-intro2"><span class="std std-ref">“Reusable interfaces”</span></a> sections describe concepts that are essential for using this module and writing idiomatic Amaranth code. The sections after describe advanced use cases that are only relevant for more complex code.</p>
</section>
<section id="motivation">
<span id="wiring-intro1"></span><h3>Motivation<a class="headerlink" href="#motivation" title="Permalink to this heading"></a></h3>
<p>Consider a reusable counter with an enable input, configurable limit, and an overflow flag. Using only the core Amaranth language, it could be implemented as:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">BasicCounter</span><span class="p">(</span><span class="n">Elaboratable</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">en</span>  <span class="o">=</span> <span class="n">Signal</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">limit</span> <span class="o">=</span> <span class="n">Signal</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">count</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">overflow</span>  <span class="o">=</span> <span class="n">Signal</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">elaborate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">platform</span><span class="p">):</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">Module</span><span class="p">()</span>

        <span class="k">with</span> <span class="n">m</span><span class="o">.</span><span class="n">If</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">en</span><span class="p">):</span>
            <span class="n">m</span><span class="o">.</span><span class="n">d</span><span class="o">.</span><span class="n">sync</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">overflow</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">with</span> <span class="n">m</span><span class="o">.</span><span class="n">If</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">limit</span><span class="p">):</span>
                <span class="n">m</span><span class="o">.</span><span class="n">d</span><span class="o">.</span><span class="n">sync</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">overflow</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">m</span><span class="o">.</span><span class="n">d</span><span class="o">.</span><span class="n">sync</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">with</span> <span class="n">m</span><span class="o">.</span><span class="n">Else</span><span class="p">():</span>
                <span class="n">m</span><span class="o">.</span><span class="n">d</span><span class="o">.</span><span class="n">sync</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">m</span>
</pre></div>
</div>
<p>Nothing in this implementation indicates the directions of its ports (<code class="code highlight py python docutils literal highlight-python"><span class="n">en</span></code>, <code class="code highlight py python docutils literal highlight-python"><span class="n">count</span></code>, <code class="code highlight py python docutils literal highlight-python"><span class="n">limit</span></code>, and <code class="code highlight py python docutils literal highlight-python"><span class="n">overflow</span></code>) in relation to other parts of the design. To understand whether the value of a port is expected to be provided externally or generated internally, it is first necessary to read the body of the <code class="code highlight py python docutils literal highlight-python"><span class="n">elaborate</span></code> method. If the port is not used within that method in a particular elaboratable, it is not possible to determine its direction, or whether it is even meant to be connected.</p>
<p>The <a class="reference internal" href="#module-amaranth.lib.wiring" title="amaranth.lib.wiring"><code class="xref py py-mod docutils literal notranslate"><span class="pre">amaranth.lib.wiring</span></code></a> module provides a solution for this problem: <em>components</em>. A component is an elaboratable that declares the shapes and directions of its ports in its <em>signature</em>. The example above can be rewritten to use the <a class="reference internal" href="#amaranth.lib.wiring.Component" title="amaranth.lib.wiring.Component"><code class="xref py py-class docutils literal notranslate"><span class="pre">Component</span></code></a> base class (which itself inherits from <code class="xref py py-class docutils literal notranslate"><span class="pre">Elaboratable</span></code>) to be:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ComponentCounter</span><span class="p">(</span><span class="n">wiring</span><span class="o">.</span><span class="n">Component</span><span class="p">):</span>
    <span class="n">en</span><span class="p">:</span> <span class="n">In</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">count</span><span class="p">:</span> <span class="n">Out</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
    <span class="n">limit</span><span class="p">:</span> <span class="n">In</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>

    <span class="n">overflow</span><span class="p">:</span> <span class="n">Out</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">elaborate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">platform</span><span class="p">):</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">Module</span><span class="p">()</span>

        <span class="k">with</span> <span class="n">m</span><span class="o">.</span><span class="n">If</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">en</span><span class="p">):</span>
            <span class="n">m</span><span class="o">.</span><span class="n">d</span><span class="o">.</span><span class="n">sync</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">overflow</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">with</span> <span class="n">m</span><span class="o">.</span><span class="n">If</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">limit</span><span class="p">):</span>
                <span class="n">m</span><span class="o">.</span><span class="n">d</span><span class="o">.</span><span class="n">sync</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">overflow</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">m</span><span class="o">.</span><span class="n">d</span><span class="o">.</span><span class="n">sync</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">with</span> <span class="n">m</span><span class="o">.</span><span class="n">Else</span><span class="p">():</span>
                <span class="n">m</span><span class="o">.</span><span class="n">d</span><span class="o">.</span><span class="n">sync</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">m</span>
</pre></div>
</div>
<p>The code in the constructor <em>creating</em> the signals of the counter’s interface one by one is now gone, replaced with the <a class="reference external" href="https://docs.python.org/3/glossary.html#term-variable-annotation" title="(in Python v3.12)"><span class="xref std std-term">variable annotations</span></a> <em>declaring</em> the counter’s interface. The inherited constructor, <code class="xref py py-meth docutils literal notranslate"><span class="pre">Component.__init__()</span></code>, creates the same attributes with the same values as before, and the <code class="code highlight py python docutils literal highlight-python"><span class="n">elaborate</span></code> method is unchanged.</p>
<p>The major difference between the two examples is that the <code class="code highlight py python docutils literal highlight-python"><span class="n">ComponentCounter</span></code> provides unambiguous answers to two questions that previously required examining the <code class="code highlight py python docutils literal highlight-python"><span class="n">elaborate</span></code> method:</p>
<ol class="arabic simple">
<li><p>Which of the Python object’s attributes are ports that are intended to be connected to the rest of the design.</p></li>
<li><p>What is the direction of the flow of information through the port.</p></li>
</ol>
<p>This information, aside from being clear from the source code, can now be retrieved from the <code class="code highlight py python docutils literal highlight-python"><span class="o">.</span><span class="n">signature</span></code> attribute, which contains an instance of the <a class="reference internal" href="#amaranth.lib.wiring.Signature" title="amaranth.lib.wiring.Signature"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signature</span></code></a> class:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ComponentCounter</span><span class="p">()</span><span class="o">.</span><span class="n">signature</span>
<span class="go">Signature({&#39;en&#39;: In(1), &#39;count&#39;: Out(8), &#39;limit&#39;: In(8), &#39;overflow&#39;: Out(1)})</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="../guide.html#lang-shapes"><span class="std std-ref">shapes</span></a> of the ports need not be static. The <code class="code highlight py python docutils literal highlight-python"><span class="n">ComponentCounter</span></code> can be made generic, with its range specified when it is constructed, by creating the signature explicitly in its constructor:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">GenericCounter</span><span class="p">(</span><span class="n">wiring</span><span class="o">.</span><span class="n">Component</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">width</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">({</span>
            <span class="s2">&quot;en&quot;</span><span class="p">:</span> <span class="n">In</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>

            <span class="s2">&quot;count&quot;</span><span class="p">:</span> <span class="n">Out</span><span class="p">(</span><span class="n">width</span><span class="p">),</span>
            <span class="s2">&quot;limit&quot;</span><span class="p">:</span> <span class="n">In</span><span class="p">(</span><span class="n">width</span><span class="p">),</span>

            <span class="s2">&quot;overflow&quot;</span><span class="p">:</span> <span class="n">Out</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="p">})</span>

    <span class="c1"># The implementation of the `elaborate` method is the same.</span>
    <span class="n">elaborate</span> <span class="o">=</span> <span class="n">ComponentCounter</span><span class="o">.</span><span class="n">elaborate</span>
</pre></div>
</div>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">GenericCounter</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span><span class="o">.</span><span class="n">signature</span>
<span class="go">Signature({&#39;en&#39;: In(1), &#39;count&#39;: Out(16), &#39;limit&#39;: In(16), &#39;overflow&#39;: Out(1)})</span>
</pre></div>
</div>
<p>Instances of the <code class="xref py py-class docutils literal notranslate"><span class="pre">ComponentCounter</span></code> and <code class="xref py py-class docutils literal notranslate"><span class="pre">GenericCounter</span></code> class are two examples of <em>interface objects</em>. An interface object is a Python object of any type whose a <code class="code highlight py python docutils literal highlight-python"><span class="n">signature</span></code> attribute contains a <a class="reference internal" href="#amaranth.lib.wiring.Signature" title="amaranth.lib.wiring.Signature"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signature</span></code></a> with which the interface object is compliant (as determined by the <a class="reference internal" href="#amaranth.lib.wiring.Signature.is_compliant" title="amaranth.lib.wiring.Signature.is_compliant"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_compliant</span></code></a> method of the signature).</p>
<p>The next section introduces the concepts of directionality and connection, and discusses interface objects in more detail.</p>
</section>
<section id="reusable-interfaces">
<span id="wiring-intro2"></span><h3>Reusable interfaces<a class="headerlink" href="#reusable-interfaces" title="Permalink to this heading"></a></h3>
<p>Consider a more complex example where two components are communicating with a <em>stream</em> that is using <em>ready/valid signaling</em>, where the <code class="code highlight py python docutils literal highlight-python"><span class="n">valid</span></code> signal indicates that the value of <code class="code highlight py python docutils literal highlight-python"><span class="n">data</span></code> provided by the source is meaningful, and the <code class="code highlight py python docutils literal highlight-python"><span class="n">ready</span></code> signal indicates that the sink has consumed the data word:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">DataProducer</span><span class="p">(</span><span class="n">wiring</span><span class="o">.</span><span class="n">Component</span><span class="p">):</span>
    <span class="n">en</span><span class="p">:</span> <span class="n">In</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">data</span><span class="p">:</span> <span class="n">Out</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
    <span class="n">valid</span><span class="p">:</span> <span class="n">Out</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">ready</span><span class="p">:</span> <span class="n">In</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">elaborate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">platform</span><span class="p">):</span> <span class="o">...</span>


<span class="k">class</span> <span class="nc">DataConsumer</span><span class="p">(</span><span class="n">wiring</span><span class="o">.</span><span class="n">Component</span><span class="p">):</span>
    <span class="n">data</span><span class="p">:</span> <span class="n">In</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
    <span class="n">valid</span><span class="p">:</span> <span class="n">In</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">ready</span><span class="p">:</span> <span class="n">Out</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># ... other ports...</span>

    <span class="k">def</span> <span class="nf">elaborate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">platform</span><span class="p">):</span> <span class="o">...</span>
</pre></div>
</div>
<p>Data would be transferred between these components by assigning the outputs to the inputs elsewhere in the design:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">m</span> <span class="o">=</span> <span class="n">Module</span><span class="p">()</span>
<span class="n">m</span><span class="o">.</span><span class="n">submodules</span><span class="o">.</span><span class="n">producer</span> <span class="o">=</span> <span class="n">producer</span> <span class="o">=</span> <span class="n">DataProducer</span><span class="p">()</span>
<span class="n">m</span><span class="o">.</span><span class="n">submodules</span><span class="o">.</span><span class="n">consumer</span> <span class="o">=</span> <span class="n">consumer</span> <span class="o">=</span> <span class="n">DataConsumer</span><span class="p">()</span>

<span class="o">...</span>

<span class="n">m</span><span class="o">.</span><span class="n">d</span><span class="o">.</span><span class="n">comb</span> <span class="o">+=</span> <span class="p">[</span>
    <span class="n">consumer</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">producer</span><span class="o">.</span><span class="n">data</span><span class="p">),</span>
    <span class="n">consumer</span><span class="o">.</span><span class="n">valid</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">producer</span><span class="o">.</span><span class="n">valid</span><span class="p">),</span>
    <span class="n">producer</span><span class="o">.</span><span class="n">ready</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">consumer</span><span class="o">.</span><span class="n">ready</span><span class="p">),</span>
<span class="p">]</span>
</pre></div>
</div>
<p>Although this example is short, it is already repetitive and redundant. The ports on the producer and the consumer, which must match each other for the connection to be made correctly, are declared twice; and the connection itself is made in an error-prone manual way even though the signatures include all of the information required to create it.</p>
<p>The signature of a stream could be defined in a generic way:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SimpleStreamSignature</span><span class="p">(</span><span class="n">wiring</span><span class="o">.</span><span class="n">Signature</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_shape</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">({</span>
            <span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="n">Out</span><span class="p">(</span><span class="n">data_shape</span><span class="p">),</span>
            <span class="s2">&quot;valid&quot;</span><span class="p">:</span> <span class="n">Out</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
            <span class="s2">&quot;ready&quot;</span><span class="p">:</span> <span class="n">In</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="p">})</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">members</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">members</span>
</pre></div>
</div>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">SimpleStreamSignature</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="o">.</span><span class="n">members</span>
<span class="go">SignatureMembers({&#39;data&#39;: Out(8), &#39;valid&#39;: Out(1), &#39;ready&#39;: In(1)})</span>
</pre></div>
</div>
<p>A definition like this is usable, depending on the data flow direction of the members, only in the producer (as in the code above) or only in the consumer. To resolve this problem, this module introduces <em>flipping</em>: an operation that reverses the data flow direction of the members of a signature or an interface object while leaving everything else about the object intact. In Amaranth, the (non-flipped) signature definition always declares the data flow directions appropriate for a bus initiator, stream source, controller, and so on. A bus target, stream sink, peripheral, and so on would reuse the source definition by flipping it.</p>
<p>A signature is flipped by calling <a class="reference internal" href="#amaranth.lib.wiring.Signature.flip" title="amaranth.lib.wiring.Signature.flip"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sig.flip()</span></code></a>, and an interface object is flipped by calling <a class="reference internal" href="#amaranth.lib.wiring.flipped" title="amaranth.lib.wiring.flipped"><code class="xref py py-func docutils literal notranslate"><span class="pre">flipped(intf)</span></code></a>. These calls return instances of the <a class="reference internal" href="#amaranth.lib.wiring.FlippedSignature" title="amaranth.lib.wiring.FlippedSignature"><code class="xref py py-class docutils literal notranslate"><span class="pre">FlippedSignature</span></code></a> and <a class="reference internal" href="#amaranth.lib.wiring.FlippedInterface" title="amaranth.lib.wiring.FlippedInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">FlippedInterface</span></code></a> classes, respectively, which use metaprogramming to wrap another object, changing only the data flow directions of its members and forwarding all other method calls and attribute accesses to the wrapped object.</p>
<p>The example above can be rewritten to use this definition of a stream signature as:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">StreamProducer</span><span class="p">(</span><span class="n">wiring</span><span class="o">.</span><span class="n">Component</span><span class="p">):</span>
    <span class="n">en</span><span class="p">:</span> <span class="n">In</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">source</span><span class="p">:</span> <span class="n">Out</span><span class="p">(</span><span class="n">SimpleStreamSignature</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">elaborate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">platform</span><span class="p">):</span> <span class="o">...</span>


<span class="k">class</span> <span class="nc">StreamConsumer</span><span class="p">(</span><span class="n">wiring</span><span class="o">.</span><span class="n">Component</span><span class="p">):</span>
    <span class="n">sink</span><span class="p">:</span> <span class="n">Out</span><span class="p">(</span><span class="n">SimpleStreamSignature</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="o">.</span><span class="n">flip</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">elaborate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">platform</span><span class="p">):</span> <span class="o">...</span>


<span class="n">m</span> <span class="o">=</span> <span class="n">Module</span><span class="p">()</span>
<span class="n">m</span><span class="o">.</span><span class="n">submodules</span><span class="o">.</span><span class="n">producer</span> <span class="o">=</span> <span class="n">producer</span> <span class="o">=</span> <span class="n">StreamProducer</span><span class="p">()</span>
<span class="n">m</span><span class="o">.</span><span class="n">submodules</span><span class="o">.</span><span class="n">consumer</span> <span class="o">=</span> <span class="n">consumer</span> <span class="o">=</span> <span class="n">StreamConsumer</span><span class="p">()</span>
</pre></div>
</div>
<p>The producer and the consumer reuse the same signature, relying on flipping to make the port directions complementary:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">producer</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">signature</span><span class="o">.</span><span class="n">members</span>
<span class="go">SignatureMembers({&#39;data&#39;: Out(8), &#39;valid&#39;: Out(1), &#39;ready&#39;: In(1)})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">producer</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">signature</span><span class="o">.</span><span class="n">members</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span>
<span class="go">Out(8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">consumer</span><span class="o">.</span><span class="n">sink</span><span class="o">.</span><span class="n">signature</span><span class="o">.</span><span class="n">members</span>
<span class="go">SignatureMembers({&#39;data&#39;: Out(8), &#39;valid&#39;: Out(1), &#39;ready&#39;: In(1)}).flip()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">consumer</span><span class="o">.</span><span class="n">sink</span><span class="o">.</span><span class="n">signature</span><span class="o">.</span><span class="n">members</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span>
<span class="go">In(8)</span>
</pre></div>
</div>
<p>In the <code class="code highlight py python docutils literal highlight-python"><span class="n">StreamConsumer</span></code> definition above, the <code class="code highlight py python docutils literal highlight-python"><span class="n">sink</span></code> member has its direction flipped explicitly because the sink is a stream input; this is the case for every interface due to how port directions are defined. Since this operation is so ubiquitous, it is also performed when <code class="code highlight py python docutils literal highlight-python"><span class="n">In</span><span class="p">(</span><span class="o">...</span><span class="p">)</span></code> is used with a signature rather than a shape. The <code class="code highlight py python docutils literal highlight-python"><span class="n">StreamConsumer</span></code> definition above should normally be written as:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">StreamConsumerUsingIn</span><span class="p">(</span><span class="n">wiring</span><span class="o">.</span><span class="n">Component</span><span class="p">):</span>
    <span class="n">sink</span><span class="p">:</span> <span class="n">In</span><span class="p">(</span><span class="n">SimpleStreamSignature</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">elaborate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">platform</span><span class="p">):</span> <span class="o">...</span>
</pre></div>
</div>
<p>The data flow directions of the ports are identical between the two definitions:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">consumer</span><span class="o">.</span><span class="n">sink</span><span class="o">.</span><span class="n">signature</span><span class="o">.</span><span class="n">members</span> <span class="o">==</span> <span class="n">StreamConsumerUsingIn</span><span class="p">()</span><span class="o">.</span><span class="n">sink</span><span class="o">.</span><span class="n">signature</span><span class="o">.</span><span class="n">members</span>
<span class="go">True</span>
</pre></div>
</div>
<p>If signatures are nested within each other multiple levels deep, the final port direction is determined by how many nested <code class="code highlight py python docutils literal highlight-python"><span class="n">In</span><span class="p">(</span><span class="o">...</span><span class="p">)</span></code> members there are. For each <code class="code highlight py python docutils literal highlight-python"><span class="n">In</span><span class="p">(</span><span class="o">...</span><span class="p">)</span></code> signature wrapping a port, the data flow direction of the port is flipped once:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sig</span> <span class="o">=</span> <span class="n">wiring</span><span class="o">.</span><span class="n">Signature</span><span class="p">({</span><span class="s2">&quot;port&quot;</span><span class="p">:</span> <span class="n">Out</span><span class="p">(</span><span class="mi">1</span><span class="p">)})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sig</span><span class="o">.</span><span class="n">members</span><span class="p">[</span><span class="s2">&quot;port&quot;</span><span class="p">]</span>
<span class="go">Out(1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">in1</span> <span class="o">=</span> <span class="n">wiring</span><span class="o">.</span><span class="n">Signature</span><span class="p">({</span><span class="s2">&quot;sig&quot;</span><span class="p">:</span> <span class="n">In</span><span class="p">(</span><span class="n">sig</span><span class="p">)})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">in1</span><span class="o">.</span><span class="n">members</span><span class="p">[</span><span class="s2">&quot;sig&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">signature</span><span class="o">.</span><span class="n">members</span><span class="p">[</span><span class="s2">&quot;port&quot;</span><span class="p">]</span>
<span class="go">In(1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">in2</span> <span class="o">=</span> <span class="n">wiring</span><span class="o">.</span><span class="n">Signature</span><span class="p">({</span><span class="s2">&quot;sig&quot;</span><span class="p">:</span> <span class="n">In</span><span class="p">(</span><span class="n">in1</span><span class="p">)})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">in2</span><span class="o">.</span><span class="n">members</span><span class="p">[</span><span class="s2">&quot;sig&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">signature</span><span class="o">.</span><span class="n">members</span><span class="p">[</span><span class="s2">&quot;sig&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">signature</span><span class="o">.</span><span class="n">members</span><span class="p">[</span><span class="s2">&quot;port&quot;</span><span class="p">]</span>
<span class="go">Out(1)</span>
</pre></div>
</div>
<p>Going back to the stream example, the producer and the consumer now communicate with one another using the same set of ports with identical shapes and complementary directions (the auxiliary <code class="code highlight py python docutils literal highlight-python"><span class="n">en</span></code> port being outside of the stream signature), and can be <em>connected</em> using the <a class="reference internal" href="#amaranth.lib.wiring.connect" title="amaranth.lib.wiring.connect"><code class="xref py py-func docutils literal notranslate"><span class="pre">connect()</span></code></a> function:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">wiring</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">producer</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">consumer</span><span class="o">.</span><span class="n">sink</span><span class="p">)</span>
</pre></div>
</div>
<p>This function examines the signatures of the two provided interface objects, ensuring that they are exactly complementary, and then adds combinational <code class="code highlight py python docutils literal highlight-python"><span class="o">.</span><span class="n">eq</span><span class="p">()</span></code> statements to the module for each of the port pairs to form the connection. Aside from the <em>connectability</em> check, the single line above is equivalent to:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">m</span><span class="o">.</span><span class="n">d</span><span class="o">.</span><span class="n">comb</span> <span class="o">+=</span> <span class="p">[</span>
    <span class="n">consumer</span><span class="o">.</span><span class="n">sink</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">producer</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">data</span><span class="p">),</span>
    <span class="n">consumer</span><span class="o">.</span><span class="n">sink</span><span class="o">.</span><span class="n">valid</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">producer</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">valid</span><span class="p">),</span>
    <span class="n">producer</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">ready</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">consumer</span><span class="o">.</span><span class="n">sink</span><span class="o">.</span><span class="n">ready</span><span class="p">),</span>
<span class="p">]</span>
</pre></div>
</div>
<p>Even on the simple example of a stream signature it is clear how using the <a class="reference internal" href="#amaranth.lib.wiring.connect" title="amaranth.lib.wiring.connect"><code class="xref py py-func docutils literal notranslate"><span class="pre">connect()</span></code></a> function results in more concise, readable, and robust code. The difference is proportionally more pronounced with more complex signatures. When a signature is being refactored, no changes to the code that uses <a class="reference internal" href="#amaranth.lib.wiring.connect" title="amaranth.lib.wiring.connect"><code class="xref py py-func docutils literal notranslate"><span class="pre">connect()</span></code></a> is required.</p>
<p>This explanation concludes the essential knowledge necessary for using this module and writing idiomatic Amaranth code.</p>
</section>
<section id="forwarding-interior-interfaces">
<span id="wiring-forwarding"></span><h3>Forwarding interior interfaces<a class="headerlink" href="#forwarding-interior-interfaces" title="Permalink to this heading"></a></h3>
<p>Consider a case where a component includes another component as a part of its implementation, and where it is necessary to <em>forward</em> the ports of the inner component, that is, expose them within the outer component’s signature. To use the <code class="code highlight py python docutils literal highlight-python"><span class="n">SimpleStreamSignature</span></code> definition above in an example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">DataProcessorImplementation</span><span class="p">(</span><span class="n">wiring</span><span class="o">.</span><span class="n">Component</span><span class="p">):</span>
    <span class="n">source</span><span class="p">:</span> <span class="n">Out</span><span class="p">(</span><span class="n">SimpleStreamSignature</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">elaborate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">platform</span><span class="p">):</span> <span class="o">...</span>


<span class="k">class</span> <span class="nc">DataProcessorWrapper</span><span class="p">(</span><span class="n">wiring</span><span class="o">.</span><span class="n">Component</span><span class="p">):</span>
    <span class="n">source</span><span class="p">:</span> <span class="n">Out</span><span class="p">(</span><span class="n">SimpleStreamSignature</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">elaborate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">platform</span><span class="p">):</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">Module</span><span class="p">()</span>
        <span class="n">m</span><span class="o">.</span><span class="n">submodules</span><span class="o">.</span><span class="n">impl</span> <span class="o">=</span> <span class="n">impl</span> <span class="o">=</span> <span class="n">DataProcessorImplementation</span><span class="p">()</span>
        <span class="n">m</span><span class="o">.</span><span class="n">d</span><span class="o">.</span><span class="n">comb</span> <span class="o">+=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">impl</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">data</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">valid</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">impl</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">valid</span><span class="p">),</span>
            <span class="n">impl</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">ready</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">ready</span><span class="p">),</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="n">m</span>
</pre></div>
</div>
<p>Because forwarding the ports requires assigning an output to an output and an input to an input, the <a class="reference internal" href="#amaranth.lib.wiring.connect" title="amaranth.lib.wiring.connect"><code class="xref py py-func docutils literal notranslate"><span class="pre">connect()</span></code></a> function, which connects outputs to inputs and vice versa, cannot be used—at least not directly. The <a class="reference internal" href="#amaranth.lib.wiring.connect" title="amaranth.lib.wiring.connect"><code class="xref py py-func docutils literal notranslate"><span class="pre">connect()</span></code></a> function is designed to cover the usual case of connecting the interfaces of modules <em>from outside</em> those modules. In order to connect an interface <em>from inside</em> a module, it is necessary to flip that interface first using the <a class="reference internal" href="#amaranth.lib.wiring.flipped" title="amaranth.lib.wiring.flipped"><code class="xref py py-func docutils literal notranslate"><span class="pre">flipped()</span></code></a> function. The <code class="code highlight py python docutils literal highlight-python"><span class="n">DataProcessorWrapper</span></code> should instead be implemented as:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">DataProcessorWrapper</span><span class="p">(</span><span class="n">wiring</span><span class="o">.</span><span class="n">Component</span><span class="p">):</span>
    <span class="n">source</span><span class="p">:</span> <span class="n">Out</span><span class="p">(</span><span class="n">SimpleStreamSignature</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">elaborate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">platform</span><span class="p">):</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">Module</span><span class="p">()</span>
        <span class="n">m</span><span class="o">.</span><span class="n">submodules</span><span class="o">.</span><span class="n">impl</span> <span class="o">=</span> <span class="n">impl</span> <span class="o">=</span> <span class="n">DataProcessorImplementation</span><span class="p">()</span>
        <span class="n">wiring</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">wiring</span><span class="o">.</span><span class="n">flipped</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">),</span> <span class="n">impl</span><span class="o">.</span><span class="n">source</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">m</span>
</pre></div>
</div>
<p>In some cases, <em>both</em> of the two interfaces provided to <a class="reference internal" href="#amaranth.lib.wiring.connect" title="amaranth.lib.wiring.connect"><code class="xref py py-func docutils literal notranslate"><span class="pre">connect()</span></code></a> must be flipped. For example, the correct way to implement a component that forwards an input interface to an output interface with no processing is:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">DataForwarder</span><span class="p">(</span><span class="n">wiring</span><span class="o">.</span><span class="n">Component</span><span class="p">):</span>
    <span class="n">sink</span><span class="p">:</span> <span class="n">In</span><span class="p">(</span><span class="n">SimpleStreamSignature</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span>
    <span class="n">source</span><span class="p">:</span> <span class="n">Out</span><span class="p">(</span><span class="n">SimpleStreamSignature</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">elaborate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">platform</span><span class="p">):</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">Module</span><span class="p">()</span>
        <span class="n">wiring</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">wiring</span><span class="o">.</span><span class="n">flipped</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sink</span><span class="p">),</span> <span class="n">wiring</span><span class="o">.</span><span class="n">flipped</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">m</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>It is important to wrap an interface with the <a class="reference internal" href="#amaranth.lib.wiring.flipped" title="amaranth.lib.wiring.flipped"><code class="xref py py-func docutils literal notranslate"><span class="pre">flipped()</span></code></a> function whenever it is being connected from inside the module. If the <code class="code highlight py python docutils literal highlight-python"><span class="n">elaborate</span></code> function above had made a connection using <code class="code highlight py python docutils literal highlight-python"><span class="n">wiring</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sink</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span></code>, it would not work correctly. No diagnostic is emitted in this case.</p>
</div>
</section>
<section id="constant-inputs">
<span id="wiring-constant-inputs"></span><h3>Constant inputs<a class="headerlink" href="#constant-inputs" title="Permalink to this heading"></a></h3>
<p>Sometimes, a component must conform to a particular signature, but some of the input ports required by the signature must have a fixed value at all times. This module addresses this case by allowing both <code class="xref py py-class docutils literal notranslate"><span class="pre">Signal</span></code> and <code class="xref py py-class docutils literal notranslate"><span class="pre">Const</span></code> objects to be used to implement port members:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ProducerRequiringReady</span><span class="p">(</span><span class="n">wiring</span><span class="o">.</span><span class="n">Component</span><span class="p">):</span>
    <span class="n">source</span><span class="p">:</span> <span class="n">Out</span><span class="p">(</span><span class="n">SimpleStreamSignature</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">ready</span> <span class="o">=</span> <span class="n">Const</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">elaborate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">platform</span><span class="p">):</span> <span class="o">...</span>


<span class="k">class</span> <span class="nc">ConsumerAlwaysReady</span><span class="p">(</span><span class="n">wiring</span><span class="o">.</span><span class="n">Component</span><span class="p">):</span>
    <span class="n">sink</span><span class="p">:</span> <span class="n">In</span><span class="p">(</span><span class="n">SimpleStreamSignature</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sink</span><span class="o">.</span><span class="n">ready</span> <span class="o">=</span> <span class="n">Const</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">elaborate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">platform</span><span class="p">):</span> <span class="o">...</span>


<span class="k">class</span> <span class="nc">ConsumerPossiblyUnready</span><span class="p">(</span><span class="n">wiring</span><span class="o">.</span><span class="n">Component</span><span class="p">):</span>
    <span class="n">sink</span><span class="p">:</span> <span class="n">In</span><span class="p">(</span><span class="n">SimpleStreamSignature</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">elaborate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">platform</span><span class="p">):</span> <span class="o">...</span>
</pre></div>
</div>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">SimpleStreamSignature</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="o">.</span><span class="n">is_compliant</span><span class="p">(</span><span class="n">ProducerRequiringReady</span><span class="p">()</span><span class="o">.</span><span class="n">source</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">SimpleStreamSignature</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="o">.</span><span class="n">flip</span><span class="p">()</span><span class="o">.</span><span class="n">is_compliant</span><span class="p">(</span><span class="n">ConsumerAlwaysReady</span><span class="p">()</span><span class="o">.</span><span class="n">sink</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>However, the <a class="reference internal" href="#amaranth.lib.wiring.connect" title="amaranth.lib.wiring.connect"><code class="xref py py-func docutils literal notranslate"><span class="pre">connect()</span></code></a> function considers a constant input to be connectable only to a constant output with the same value:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">wiring</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">ProducerRequiringReady</span><span class="p">()</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">ConsumerAlwaysReady</span><span class="p">()</span><span class="o">.</span><span class="n">sink</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wiring</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">ProducerRequiringReady</span><span class="p">()</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">ConsumerPossiblyUnready</span><span class="p">()</span><span class="o">.</span><span class="n">sink</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="w">  </span><span class="c">...</span>
<span class="gr">amaranth.lib.wiring.ConnectionError</span>: <span class="n">Cannot connect to the input member &#39;arg0.ready&#39; that has a constant value 1</span>
</pre></div>
</div>
<p>This feature reduces the proliferation of similar but subtly incompatible interfaces that are semantically similar, only differing in the presence or absence of optional control or status signals.</p>
</section>
<section id="adapting-interfaces">
<span id="wiring-adapting-interfaces"></span><h3>Adapting interfaces<a class="headerlink" href="#adapting-interfaces" title="Permalink to this heading"></a></h3>
<p>Sometimes, a design requires an interface with a particular signature to be used, but the only implementation available is either a component with an incompatible signature or an elaboratable with no signature at all. If this problem cannot be resolved by other means, <em>interface adaptation</em> can be used, where the existing signals are placed into a new interface with the appropriate signature. For example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">LegacyAXIDataProducer</span><span class="p">(</span><span class="n">Elaboratable</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adata</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">avalid</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">aready</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">elaborate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">platform</span><span class="p">):</span> <span class="o">...</span>


<span class="k">class</span> <span class="nc">ModernDataConsumer</span><span class="p">(</span><span class="n">wiring</span><span class="o">.</span><span class="n">Component</span><span class="p">):</span>
    <span class="n">sink</span><span class="p">:</span> <span class="n">In</span><span class="p">(</span><span class="n">SimpleStreamSignature</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span>


<span class="n">data_producer</span> <span class="o">=</span> <span class="n">LegacyAXIDataProducer</span><span class="p">()</span>
<span class="n">data_consumer</span> <span class="o">=</span> <span class="n">ModernDataConsumer</span><span class="p">()</span>

<span class="n">adapted_data_source</span> <span class="o">=</span> <span class="n">SimpleStreamSignature</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="o">.</span><span class="n">create</span><span class="p">()</span>
<span class="n">adapted_data_source</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data_producer</span><span class="o">.</span><span class="n">adata</span>
<span class="n">adapted_data_source</span><span class="o">.</span><span class="n">valid</span> <span class="o">=</span> <span class="n">data_producer</span><span class="o">.</span><span class="n">avalid</span>
<span class="n">adapted_data_source</span><span class="o">.</span><span class="n">ready</span> <span class="o">=</span> <span class="n">data_producer</span><span class="o">.</span><span class="n">aready</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">Module</span><span class="p">()</span>
<span class="n">wiring</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">adapted_data_source</span><span class="p">,</span> <span class="n">data_consumer</span><span class="o">.</span><span class="n">sink</span><span class="p">)</span>
</pre></div>
</div>
<p>When creating an adapted interface, use the <a class="reference internal" href="#amaranth.lib.wiring.Signature.create" title="amaranth.lib.wiring.Signature.create"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create</span></code></a> method of the signature that is required elsewhere in the design.</p>
</section>
<section id="customizing-signatures-and-interfaces">
<span id="wiring-customizing"></span><h3>Customizing signatures and interfaces<a class="headerlink" href="#customizing-signatures-and-interfaces" title="Permalink to this heading"></a></h3>
<p>The <a class="reference internal" href="#module-amaranth.lib.wiring" title="amaranth.lib.wiring"><code class="xref py py-mod docutils literal notranslate"><span class="pre">amaranth.lib.wiring</span></code></a> module encourages creation of reusable building blocks. In the examples above, a custom signature, <code class="code highlight py python docutils literal highlight-python"><span class="n">SimpleStreamSignature</span></code>, was introduced to illustrate the essential concepts necessary to use this module. While sufficient for that goal, it does not demonstrate the full capabilities provided by the module.</p>
<p>Consider a simple System-on-Chip memory bus with a configurable address width. In an application like that, additional properties and methods could be usefully defined both on the signature (for example, properties to retrieve the parameters of the interface) and on the created interface object (for example, methods to examine the control and status signals). These can be defined as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">amaranth.lib</span> <span class="kn">import</span> <span class="n">enum</span>


<span class="k">class</span> <span class="nc">TransferType</span><span class="p">(</span><span class="n">enum</span><span class="o">.</span><span class="n">Enum</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">Write</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">Read</span>  <span class="o">=</span> <span class="mi">1</span>


<span class="k">class</span> <span class="nc">SimpleBusSignature</span><span class="p">(</span><span class="n">wiring</span><span class="o">.</span><span class="n">Signature</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">addr_width</span><span class="o">=</span><span class="mi">32</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_addr_width</span> <span class="o">=</span> <span class="n">addr_width</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">({</span>
            <span class="s2">&quot;en&quot;</span><span class="p">:</span>     <span class="n">Out</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
            <span class="s2">&quot;rw&quot;</span><span class="p">:</span>     <span class="n">Out</span><span class="p">(</span><span class="n">TransferType</span><span class="p">),</span>
            <span class="s2">&quot;addr&quot;</span><span class="p">:</span>   <span class="n">Out</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_addr_width</span><span class="p">),</span>
            <span class="s2">&quot;r_data&quot;</span><span class="p">:</span> <span class="n">In</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span>
            <span class="s2">&quot;w_data&quot;</span><span class="p">:</span> <span class="n">Out</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span>
        <span class="p">})</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">addr_width</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_addr_width</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">SimpleBusSignature</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">addr_width</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">addr_width</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;SimpleBusSignature(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">addr_width</span><span class="si">}</span><span class="s2">)&quot;</span>

    <span class="k">def</span> <span class="nf">create</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">src_loc_at</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">SimpleBusInterface</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="n">path</span><span class="p">,</span> <span class="n">src_loc_at</span><span class="o">=</span><span class="mi">1</span> <span class="o">+</span> <span class="n">src_loc_at</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">SimpleBusInterface</span><span class="p">(</span><span class="n">wiring</span><span class="o">.</span><span class="n">PureInterface</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">is_read_xfer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">en</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rw</span> <span class="o">==</span> <span class="n">TransferType</span><span class="o">.</span><span class="n">Read</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_write_xfer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">en</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rw</span> <span class="o">==</span> <span class="n">TransferType</span><span class="o">.</span><span class="n">Write</span><span class="p">)</span>
</pre></div>
</div>
<p>This example demonstrates several important principles of use:</p>
<ul class="simple">
<li><p>Defining additional properties for a custom signature. The <a class="reference internal" href="#amaranth.lib.wiring.Signature" title="amaranth.lib.wiring.Signature"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signature</span></code></a> objects are mutable in a restricted way, and can be frozen with the <code class="xref py py-meth docutils literal notranslate"><span class="pre">freeze</span></code> method. In almost all cases, the newly defined properties must be immutable, as shown above.</p></li>
<li><p>Defining a signature-specific <code class="code highlight py python docutils literal highlight-python"><span class="fm">__eq__</span></code> method. While anonymous (created from a dictionary of members) instances of <a class="reference internal" href="#amaranth.lib.wiring.Signature" title="amaranth.lib.wiring.Signature"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signature</span></code></a> compare structurally, instances of <a class="reference internal" href="#amaranth.lib.wiring.Signature" title="amaranth.lib.wiring.Signature"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signature</span></code></a>-derived classes compare by identity unless the equality operator is overridden. In almost all cases, the equality operator should compare the parameters of the signatures rather than their structures.</p></li>
<li><p>Defining a signature-specific <code class="code highlight py python docutils literal highlight-python"><span class="fm">__repr__</span></code> method. Similarly to <code class="code highlight py python docutils literal highlight-python"><span class="fm">__eq__</span></code>, the default implementation for <a class="reference internal" href="#amaranth.lib.wiring.Signature" title="amaranth.lib.wiring.Signature"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signature</span></code></a>-derived classes uses the signature’s identity. In almost all cases, the representation conversion operator should return an expression that constructs an equivalent signature.</p></li>
<li><p>Defining a signature-specific <code class="code highlight py python docutils literal highlight-python"><span class="n">create</span></code> method. The default implementation used in anonymous signatures, <a class="reference internal" href="#amaranth.lib.wiring.Signature.create" title="amaranth.lib.wiring.Signature.create"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Signature.create()</span></code></a>, returns a new instance of <a class="reference internal" href="#amaranth.lib.wiring.PureInterface" title="amaranth.lib.wiring.PureInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">PureInterface</span></code></a>. Whenever the custom signature has a corresponding custom interface object class, this method should return a new instance of that class. It should not have any required arguments beyond the ones that <a class="reference internal" href="#amaranth.lib.wiring.Signature.create" title="amaranth.lib.wiring.Signature.create"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Signature.create()</span></code></a> has (required parameters should be provided when creating the signature and not the interface), but may take additional optional arguments, forwarding them to the interface object constructor.</p></li>
</ul>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sig32</span> <span class="o">=</span> <span class="n">SimpleBusSignature</span><span class="p">();</span> <span class="n">sig32</span>
<span class="go">SimpleBusSignature(32)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sig24</span> <span class="o">=</span> <span class="n">SimpleBusSignature</span><span class="p">(</span><span class="mi">24</span><span class="p">);</span> <span class="n">sig24</span>
<span class="go">SimpleBusSignature(24)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sig24</span><span class="o">.</span><span class="n">addr_width</span>
<span class="go">24</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sig24</span> <span class="o">==</span> <span class="n">SimpleBusSignature</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bus</span> <span class="o">=</span> <span class="n">sig24</span><span class="o">.</span><span class="n">create</span><span class="p">();</span> <span class="n">bus</span>
<span class="go">&lt;SimpleBusInterface: SimpleBusSignature(24), en=(sig bus__en), rw=EnumView(TransferType, (sig bus__rw)), addr=(sig bus__addr), r_data=(sig bus__r_data), w_data=(sig bus__w_data)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bus</span><span class="o">.</span><span class="n">is_read_xfer</span><span class="p">()</span>
<span class="go">(&amp; (sig bus__en) (== (sig bus__rw) (const 1&#39;d1)))</span>
</pre></div>
</div>
<p>The custom properties defined for both the signature and the interface object can be used on the flipped signature and the flipped interface in the usual way:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sig32</span><span class="o">.</span><span class="n">flip</span><span class="p">()</span><span class="o">.</span><span class="n">addr_width</span>
<span class="go">32</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wiring</span><span class="o">.</span><span class="n">flipped</span><span class="p">(</span><span class="n">bus</span><span class="p">)</span><span class="o">.</span><span class="n">is_read_xfer</span><span class="p">()</span>
<span class="go">(&amp; (sig bus__en) (== (sig bus__rw) (const 1&#39;d1)))</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Unusually for Python, when the implementation of a property or method is invoked through a flipped object, the <code class="code highlight py python docutils literal highlight-python"><span class="bp">self</span></code> argument receives the flipped object that has the type <a class="reference internal" href="#amaranth.lib.wiring.FlippedSignature" title="amaranth.lib.wiring.FlippedSignature"><code class="xref py py-class docutils literal notranslate"><span class="pre">FlippedSignature</span></code></a> or <a class="reference internal" href="#amaranth.lib.wiring.FlippedInterface" title="amaranth.lib.wiring.FlippedInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">FlippedInterface</span></code></a>. This wrapper object proxies all attribute accesses and method calls to the original signature or interface, the only change being that of the data flow directions. See the documentation for these classes for a more detailed explanation.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>While the wrapper object forwards attribute accesses and method calls, it does not currently proxy special methods such as <code class="code highlight py python docutils literal highlight-python"><span class="fm">__getitem__</span></code> or <code class="code highlight py python docutils literal highlight-python"><span class="fm">__add__</span></code> that are rarely, if ever, used with interface objects. This limitation may be lifted in the future.</p>
</div>
</section>
<section id="paths">
<span id="wiring-path"></span><h3>Paths<a class="headerlink" href="#paths" title="Permalink to this heading"></a></h3>
<p>Whenever an operation in this module needs to refer to the interior of an object, it accepts or produces a <em>path</em>: a tuple of strings and integers denoting the attribute names and indexes through which an interior value can be extracted. For example, the path <code class="code highlight py python docutils literal highlight-python"><span class="p">(</span><span class="s2">&quot;buses&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;cyc&quot;</span><span class="p">)</span></code> into the object <code class="code highlight py python docutils literal highlight-python"><span class="n">obj</span></code> corresponds to the Python expression <code class="code highlight py python docutils literal highlight-python"><span class="n">obj</span><span class="o">.</span><span class="n">buses</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">cyc</span></code>.</p>
<p>When they appear in diagnostics, paths are printed as the corresponding Python expression.</p>
</section>
</section>
<section id="signatures">
<h2>Signatures<a class="headerlink" href="#signatures" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="amaranth.lib.wiring.Flow">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">amaranth.lib.wiring.</span></span><span class="sig-name descname"><span class="pre">Flow</span></span><a class="headerlink" href="#amaranth.lib.wiring.Flow" title="Permalink to this definition"></a></dt>
<dd><p>Direction of data flow. This enumeration has two values, <a class="reference internal" href="#amaranth.lib.wiring.Out" title="amaranth.lib.wiring.Out"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Out</span></code></a> and <a class="reference internal" href="#amaranth.lib.wiring.In" title="amaranth.lib.wiring.In"><code class="xref py py-attr docutils literal notranslate"><span class="pre">In</span></code></a>,
the meaning of which depends on the context in which they are used.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="amaranth.lib.wiring.Flow.Out">
<span class="sig-name descname"><span class="pre">Out</span></span><a class="headerlink" href="#amaranth.lib.wiring.Flow.Out" title="Permalink to this definition"></a></dt>
<dd><p><cite>Outgoing</cite> data flow.</p>
<p>When included in a standalone <a class="reference internal" href="#amaranth.lib.wiring.Signature" title="amaranth.lib.wiring.Signature"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signature</span></code></a>, a port <a class="reference internal" href="#amaranth.lib.wiring.Member" title="amaranth.lib.wiring.Member"><code class="xref py py-class docutils literal notranslate"><span class="pre">Member</span></code></a> with an <a class="reference internal" href="#amaranth.lib.wiring.Out" title="amaranth.lib.wiring.Out"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Out</span></code></a>
data flow carries data from an <cite>initiator</cite> to a <cite>responder</cite>. That is, the signature
describes the initiator <cite>driving</cite> the signal and the responder <cite>sampling</cite> the signal.</p>
<p>When used as the flow of a signature <a class="reference internal" href="#amaranth.lib.wiring.Member" title="amaranth.lib.wiring.Member"><code class="xref py py-class docutils literal notranslate"><span class="pre">Member</span></code></a>, indicates that the data flow of
the port members of the inner signature <cite>remains the same</cite>.</p>
<p>When included in the <code class="code highlight py python docutils literal highlight-python"><span class="n">signature</span></code> property of an <code class="xref py py-class docutils literal notranslate"><span class="pre">Elaboratable</span></code>, the signature
describes the elaboratable <cite>driving</cite> the corresponding signal. That is, the elaboratable is
treated as the <cite>initiator</cite>.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="amaranth.lib.wiring.Flow.In">
<span class="sig-name descname"><span class="pre">In</span></span><a class="headerlink" href="#amaranth.lib.wiring.Flow.In" title="Permalink to this definition"></a></dt>
<dd><p><cite>Incoming</cite> data flow.</p>
<p>When included in a standalone <a class="reference internal" href="#amaranth.lib.wiring.Signature" title="amaranth.lib.wiring.Signature"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signature</span></code></a>, a port <a class="reference internal" href="#amaranth.lib.wiring.Member" title="amaranth.lib.wiring.Member"><code class="xref py py-class docutils literal notranslate"><span class="pre">Member</span></code></a> with an <a class="reference internal" href="#amaranth.lib.wiring.In" title="amaranth.lib.wiring.In"><code class="xref py py-attr docutils literal notranslate"><span class="pre">In</span></code></a>
data flow carries data from an <cite>responder</cite> to a <cite>initiator</cite>. That is, the signature
describes the initiator <cite>sampling</cite> the signal and the responder <cite>driving</cite> the signal.</p>
<p>When used as the flow of a signature <a class="reference internal" href="#amaranth.lib.wiring.Member" title="amaranth.lib.wiring.Member"><code class="xref py py-class docutils literal notranslate"><span class="pre">Member</span></code></a>, indicates that the data flow of
the port members of the inner signature <cite>is flipped</cite>.</p>
<p>When included in the <code class="code highlight py python docutils literal highlight-python"><span class="n">signature</span></code> property of an <code class="xref py py-class docutils literal notranslate"><span class="pre">Elaboratable</span></code>, the signature
describes the elaboratable <cite>sampling</cite> the corresponding signal. That is, the elaboratable is
treated as the <cite>initiator</cite>, the same as in the <a class="reference internal" href="#amaranth.lib.wiring.Out" title="amaranth.lib.wiring.Out"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Out</span></code></a> case.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="amaranth.lib.wiring.Flow.flip">
<span class="sig-name descname"><span class="pre">flip</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#amaranth.lib.wiring.Flow.flip" title="Permalink to this definition"></a></dt>
<dd><p>Flip the direction of data flow.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#amaranth.lib.wiring.In" title="amaranth.lib.wiring.In"><code class="xref py py-attr docutils literal notranslate"><span class="pre">In</span></code></a> if called as <code class="code highlight py python docutils literal highlight-python"><span class="n">Out</span><span class="o">.</span><span class="n">flip</span><span class="p">()</span></code>; <a class="reference internal" href="#amaranth.lib.wiring.Out" title="amaranth.lib.wiring.Out"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Out</span></code></a> if called as <code class="code highlight py python docutils literal highlight-python"><span class="n">In</span><span class="o">.</span><span class="n">flip</span><span class="p">()</span></code>.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#amaranth.lib.wiring.Flow" title="amaranth.lib.wiring.Flow"><code class="xref py py-class docutils literal notranslate"><span class="pre">Flow</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="amaranth.lib.wiring.Flow.__call__">
<span class="sig-name descname"><span class="pre">__call__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">description</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">src_loc_at</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amaranth.lib.wiring.Flow.__call__" title="Permalink to this definition"></a></dt>
<dd><p>Create a <a class="reference internal" href="#amaranth.lib.wiring.Member" title="amaranth.lib.wiring.Member"><code class="xref py py-class docutils literal notranslate"><span class="pre">Member</span></code></a> with this data flow and the provided description and
initial value.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="code highlight py python docutils literal highlight-python"><span class="n">Member</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">description</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="n">init</span><span class="p">)</span></code></p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#amaranth.lib.wiring.Member" title="amaranth.lib.wiring.Member"><code class="xref py py-class docutils literal notranslate"><span class="pre">Member</span></code></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="amaranth.lib.wiring.Out">
<span class="sig-prename descclassname"><span class="pre">amaranth.lib.wiring.</span></span><span class="sig-name descname"><span class="pre">Out</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">Flow.Out</span></em><a class="headerlink" href="#amaranth.lib.wiring.Out" title="Permalink to this definition"></a></dt>
<dd><p>A shortcut for importing <a class="reference internal" href="#amaranth.lib.wiring.Flow.Out" title="amaranth.lib.wiring.Flow.Out"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Flow.Out</span></code></a> as <a class="reference internal" href="#amaranth.lib.wiring.Out" title="amaranth.lib.wiring.Out"><code class="xref py py-data docutils literal notranslate"><span class="pre">amaranth.lib.wiring.Out</span></code></a>.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="amaranth.lib.wiring.In">
<span class="sig-prename descclassname"><span class="pre">amaranth.lib.wiring.</span></span><span class="sig-name descname"><span class="pre">In</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">Flow.In</span></em><a class="headerlink" href="#amaranth.lib.wiring.In" title="Permalink to this definition"></a></dt>
<dd><p>A shortcut for importing <a class="reference internal" href="#amaranth.lib.wiring.Flow.In" title="amaranth.lib.wiring.Flow.In"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Flow.In</span></code></a> as <a class="reference internal" href="#amaranth.lib.wiring.In" title="amaranth.lib.wiring.In"><code class="xref py py-data docutils literal notranslate"><span class="pre">amaranth.lib.wiring.In</span></code></a>.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="amaranth.lib.wiring.Member">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">amaranth.lib.wiring.</span></span><span class="sig-name descname"><span class="pre">Member</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">flow</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">description</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amaranth.lib.wiring.Member" title="Permalink to this definition"></a></dt>
<dd><p>Description of a signature member.</p>
<p>This class is a discriminated union: its instances describe either a <cite>port member</cite> or
a <cite>signature member</cite>, and accessing properties for the wrong kind of member raises
an <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#AttributeError" title="(in Python v3.12)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a>.</p>
<p>The class is created from a <cite>description</cite>: a <a class="reference internal" href="#amaranth.lib.wiring.Signature" title="amaranth.lib.wiring.Signature"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signature</span></code></a> instance (in which case
the <a class="reference internal" href="#amaranth.lib.wiring.Member" title="amaranth.lib.wiring.Member"><code class="xref py py-class docutils literal notranslate"><span class="pre">Member</span></code></a> is created as a signature member), or a <a class="reference internal" href="../guide.html#lang-shapelike"><span class="std std-ref">shape-like</span></a>
object (in which case it is created as a port member). After creation the <a class="reference internal" href="#amaranth.lib.wiring.Member" title="amaranth.lib.wiring.Member"><code class="xref py py-class docutils literal notranslate"><span class="pre">Member</span></code></a>
instance cannot be modified.</p>
<p>When a <code class="xref py py-class docutils literal notranslate"><span class="pre">Signal</span></code> is created from a description of a port member, the signal’s initial value
is taken from the member description. If this signal is never explicitly assigned a value, it
will equal <code class="code highlight py python docutils literal highlight-python"><span class="n">init</span></code>.</p>
<p>Although instances can be created directly, most often they will be created through
<a class="reference internal" href="#amaranth.lib.wiring.In" title="amaranth.lib.wiring.In"><code class="xref py py-data docutils literal notranslate"><span class="pre">In</span></code></a> and <a class="reference internal" href="#amaranth.lib.wiring.Out" title="amaranth.lib.wiring.Out"><code class="xref py py-data docutils literal notranslate"><span class="pre">Out</span></code></a>, e.g. <code class="code highlight py python docutils literal highlight-python"><span class="n">In</span><span class="p">(</span><span class="n">unsigned</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span></code> or <code class="code highlight py python docutils literal highlight-python"><span class="n">Out</span><span class="p">(</span><span class="n">stream</span><span class="o">.</span><span class="n">Signature</span><span class="p">(</span><span class="n">RGBPixel</span><span class="p">))</span></code>.</p>
<dl class="py method">
<dt class="sig sig-object py" id="amaranth.lib.wiring.Member.flip">
<span class="sig-name descname"><span class="pre">flip</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#amaranth.lib.wiring.Member.flip" title="Permalink to this definition"></a></dt>
<dd><p>Flip the data flow of this member.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A new <code class="code highlight py python docutils literal highlight-python"><span class="n">member</span></code> with <code class="code highlight py python docutils literal highlight-python"><span class="n">member</span><span class="o">.</span><span class="n">flow</span></code> equal to <code class="code highlight py python docutils literal highlight-python"><span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="o">.</span><span class="n">flip</span><span class="p">()</span></code>, and identical
to <code class="code highlight py python docutils literal highlight-python"><span class="bp">self</span></code> other than that.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#amaranth.lib.wiring.Member" title="amaranth.lib.wiring.Member"><code class="xref py py-class docutils literal notranslate"><span class="pre">Member</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="amaranth.lib.wiring.Member.array">
<span class="sig-name descname"><span class="pre">array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">dimensions</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amaranth.lib.wiring.Member.array" title="Permalink to this definition"></a></dt>
<dd><p>Add array dimensions to this member.</p>
<p>The dimensions passed to this method are <cite>prepended</cite> to the existing dimensions.
For example, <code class="code highlight py python docutils literal highlight-python"><span class="n">Out</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span></code> describes an array of 2 elements, whereas both
<code class="code highlight py python docutils literal highlight-python"><span class="n">Out</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span></code> and <code class="code highlight py python docutils literal highlight-python"><span class="n">Out</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span></code> both describe a two dimensional
array of 2 by 3 elements.</p>
<p>Dimensions are passed to <a class="reference internal" href="#amaranth.lib.wiring.Member.array" title="amaranth.lib.wiring.Member.array"><code class="xref py py-meth docutils literal notranslate"><span class="pre">array()</span></code></a> in the order in which they would be indexed.
That is, <code class="code highlight py python docutils literal highlight-python"><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></code> creates a member that can be indexed up to <code class="code highlight py python docutils literal highlight-python"><span class="p">[</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">y</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></code>.</p>
<p>The <a class="reference internal" href="#amaranth.lib.wiring.Member.array" title="amaranth.lib.wiring.Member.array"><code class="xref py py-meth docutils literal notranslate"><span class="pre">array()</span></code></a> method is composable: calling <code class="code highlight py python docutils literal highlight-python"><span class="n">member</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code> describes an array of
<code class="code highlight py python docutils literal highlight-python"><span class="n">x</span></code> members even if <code class="code highlight py python docutils literal highlight-python"><span class="n">member</span></code> was already an array.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A new <code class="code highlight py python docutils literal highlight-python"><span class="n">member</span></code> with <code class="code highlight py python docutils literal highlight-python"><span class="n">member</span><span class="o">.</span><span class="n">dimensions</span></code> extended by <code class="code highlight py python docutils literal highlight-python"><span class="n">dimensions</span></code>, and
identical to <code class="code highlight py python docutils literal highlight-python"><span class="bp">self</span></code> other than that.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#amaranth.lib.wiring.Member" title="amaranth.lib.wiring.Member"><code class="xref py py-class docutils literal notranslate"><span class="pre">Member</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="amaranth.lib.wiring.Member.flow">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">flow</span></span><a class="headerlink" href="#amaranth.lib.wiring.Member.flow" title="Permalink to this definition"></a></dt>
<dd><p>Data flow of this member.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#amaranth.lib.wiring.Flow" title="amaranth.lib.wiring.Flow"><code class="xref py py-class docutils literal notranslate"><span class="pre">Flow</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="amaranth.lib.wiring.Member.is_port">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_port</span></span><a class="headerlink" href="#amaranth.lib.wiring.Member.is_port" title="Permalink to this definition"></a></dt>
<dd><p>Whether this is a description of a port member.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="code highlight py python docutils literal highlight-python"><span class="kc">True</span></code> if this is a description of a port member,
<code class="code highlight py python docutils literal highlight-python"><span class="kc">False</span></code> if this is a description of a signature member.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="amaranth.lib.wiring.Member.is_signature">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_signature</span></span><a class="headerlink" href="#amaranth.lib.wiring.Member.is_signature" title="Permalink to this definition"></a></dt>
<dd><p>Whether this is a description of a signature member.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="code highlight py python docutils literal highlight-python"><span class="kc">True</span></code> if this is a description of a signature member,
<code class="code highlight py python docutils literal highlight-python"><span class="kc">False</span></code> if this is a description of a port member.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="amaranth.lib.wiring.Member.shape">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">shape</span></span><a class="headerlink" href="#amaranth.lib.wiring.Member.shape" title="Permalink to this definition"></a></dt>
<dd><p>Shape of a port member.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The shape that was provided when constructing this <a class="reference internal" href="#amaranth.lib.wiring.Member" title="amaranth.lib.wiring.Member"><code class="xref py py-class docutils literal notranslate"><span class="pre">Member</span></code></a>.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../guide.html#lang-shapelike"><span class="std std-ref">shape-like object</span></a></p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#AttributeError" title="(in Python v3.12)"><strong>AttributeError</strong></a> – If <code class="code highlight py python docutils literal highlight-python"><span class="bp">self</span></code> describes a signature member.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="amaranth.lib.wiring.Member.init">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">init</span></span><a class="headerlink" href="#amaranth.lib.wiring.Member.init" title="Permalink to this definition"></a></dt>
<dd><p>Initial value of a port member.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The initial value that was provided when constructing this <a class="reference internal" href="#amaranth.lib.wiring.Member" title="amaranth.lib.wiring.Member"><code class="xref py py-class docutils literal notranslate"><span class="pre">Member</span></code></a>.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../guide.html#lang-constcasting"><span class="std std-ref">const-castable object</span></a></p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#AttributeError" title="(in Python v3.12)"><strong>AttributeError</strong></a> – If <code class="code highlight py python docutils literal highlight-python"><span class="bp">self</span></code> describes a signature member.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="amaranth.lib.wiring.Member.signature">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">signature</span></span><a class="headerlink" href="#amaranth.lib.wiring.Member.signature" title="Permalink to this definition"></a></dt>
<dd><p>Signature of a signature member.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The signature that was provided when constructing this <a class="reference internal" href="#amaranth.lib.wiring.Member" title="amaranth.lib.wiring.Member"><code class="xref py py-class docutils literal notranslate"><span class="pre">Member</span></code></a>.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#amaranth.lib.wiring.Signature" title="amaranth.lib.wiring.Signature"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signature</span></code></a></p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#AttributeError" title="(in Python v3.12)"><strong>AttributeError</strong></a> – If <code class="code highlight py python docutils literal highlight-python"><span class="bp">self</span></code> describes a port member.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="amaranth.lib.wiring.Member.dimensions">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dimensions</span></span><a class="headerlink" href="#amaranth.lib.wiring.Member.dimensions" title="Permalink to this definition"></a></dt>
<dd><p>Array dimensions.</p>
<p>A member will usually have no dimensions; in this case it does not describe an array.
A single dimension describes one-dimensional array, and so on.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Dimensions, if any, of this member, from most to least major.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="amaranth.lib.wiring.SignatureError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">amaranth.lib.wiring.</span></span><span class="sig-name descname"><span class="pre">SignatureError</span></span><a class="headerlink" href="#amaranth.lib.wiring.SignatureError" title="Permalink to this definition"></a></dt>
<dd><p>This exception is raised when an invalid operation specific to signature manipulation is
performed with <a class="reference internal" href="#amaranth.lib.wiring.SignatureMembers" title="amaranth.lib.wiring.SignatureMembers"><code class="xref py py-class docutils literal notranslate"><span class="pre">SignatureMembers</span></code></a>. Other exceptions, such as <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#TypeError" title="(in Python v3.12)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> or
<a class="reference external" href="https://docs.python.org/3/library/exceptions.html#NameError" title="(in Python v3.12)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NameError</span></code></a>, will still be raised where appropriate.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="amaranth.lib.wiring.SignatureMembers">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">amaranth.lib.wiring.</span></span><span class="sig-name descname"><span class="pre">SignatureMembers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">members</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amaranth.lib.wiring.SignatureMembers" title="Permalink to this definition"></a></dt>
<dd><p>Mapping of signature member names to their descriptions.</p>
<p>This container, a <a class="reference external" href="https://docs.python.org/3/library/collections.abc.html#collections.abc.Mapping" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Mapping</span></code></a>, is used to implement the <code class="code highlight py python docutils literal highlight-python"><span class="n">members</span></code>
attribute of signature objects.</p>
<p>The keys in this container must be valid Python attribute names that are public (do not begin
with an underscore. The values must be instances of <a class="reference internal" href="#amaranth.lib.wiring.Member" title="amaranth.lib.wiring.Member"><code class="xref py py-class docutils literal notranslate"><span class="pre">Member</span></code></a>. The container is immutable.</p>
<p>The <a class="reference internal" href="#amaranth.lib.wiring.SignatureMembers.create" title="amaranth.lib.wiring.SignatureMembers.create"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create()</span></code></a> method converts this mapping into a mapping of names to signature members
(signals and interface objects) by creating them from their descriptions. The created mapping
can be used to populate an interface object.</p>
<dl class="py method">
<dt class="sig sig-object py" id="amaranth.lib.wiring.SignatureMembers.flip">
<span class="sig-name descname"><span class="pre">flip</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#amaranth.lib.wiring.SignatureMembers.flip" title="Permalink to this definition"></a></dt>
<dd><p>Flip the data flow of the members in this mapping.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Proxy collection <code class="code highlight py python docutils literal highlight-python"><span class="n">FlippedSignatureMembers</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></code> that flips the data flow of
the members that are accessed using it.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#amaranth.lib.wiring.FlippedSignatureMembers" title="amaranth.lib.wiring.FlippedSignatureMembers"><code class="xref py py-class docutils literal notranslate"><span class="pre">FlippedSignatureMembers</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="amaranth.lib.wiring.SignatureMembers.__eq__">
<span class="sig-name descname"><span class="pre">__eq__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amaranth.lib.wiring.SignatureMembers.__eq__" title="Permalink to this definition"></a></dt>
<dd><p>Compare the members in this and another mapping.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="code highlight py python docutils literal highlight-python"><span class="kc">True</span></code> if the mappings contain the same key-value pairs, <code class="code highlight py python docutils literal highlight-python"><span class="kc">False</span></code> otherwise.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="amaranth.lib.wiring.SignatureMembers.__contains__">
<span class="sig-name descname"><span class="pre">__contains__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amaranth.lib.wiring.SignatureMembers.__contains__" title="Permalink to this definition"></a></dt>
<dd><p>Check whether a member with a given name exists.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="amaranth.lib.wiring.SignatureMembers.__getitem__">
<span class="sig-name descname"><span class="pre">__getitem__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amaranth.lib.wiring.SignatureMembers.__getitem__" title="Permalink to this definition"></a></dt>
<dd><p>Retrieves the description of a member with a given name.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#amaranth.lib.wiring.Member" title="amaranth.lib.wiring.Member"><code class="xref py py-class docutils literal notranslate"><span class="pre">Member</span></code></a></p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#TypeError" title="(in Python v3.12)"><strong>TypeError</strong></a> – If <code class="code highlight py python docutils literal highlight-python"><span class="n">name</span></code> is not a string.</p></li>
<li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#NameError" title="(in Python v3.12)"><strong>NameError</strong></a> – If <code class="code highlight py python docutils literal highlight-python"><span class="n">name</span></code> is not a valid, public Python attribute name.</p></li>
<li><p><a class="reference internal" href="#amaranth.lib.wiring.SignatureError" title="amaranth.lib.wiring.SignatureError"><strong>SignatureError</strong></a> – If a member called <code class="code highlight py python docutils literal highlight-python"><span class="n">name</span></code> does not exist in the collection.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="amaranth.lib.wiring.SignatureMembers.__setitem__">
<span class="sig-name descname"><span class="pre">__setitem__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">member</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amaranth.lib.wiring.SignatureMembers.__setitem__" title="Permalink to this definition"></a></dt>
<dd><p>Stub that forbids addition of members to the collection.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#amaranth.lib.wiring.SignatureError" title="amaranth.lib.wiring.SignatureError"><strong>SignatureError</strong></a> – Always.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="amaranth.lib.wiring.SignatureMembers.__delitem__">
<span class="sig-name descname"><span class="pre">__delitem__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amaranth.lib.wiring.SignatureMembers.__delitem__" title="Permalink to this definition"></a></dt>
<dd><p>Stub that forbids removal of members from the collection.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#amaranth.lib.wiring.SignatureError" title="amaranth.lib.wiring.SignatureError"><strong>SignatureError</strong></a> – Always.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="amaranth.lib.wiring.SignatureMembers.__iter__">
<span class="sig-name descname"><span class="pre">__iter__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#amaranth.lib.wiring.SignatureMembers.__iter__" title="Permalink to this definition"></a></dt>
<dd><p>Iterate through the names of members in the collection.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Names of members, in the order of insertion.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>iterator of <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="amaranth.lib.wiring.SignatureMembers.flatten">
<span class="sig-name descname"><span class="pre">flatten</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amaranth.lib.wiring.SignatureMembers.flatten" title="Permalink to this definition"></a></dt>
<dd><p>Recursively iterate through this collection.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <a class="reference internal" href="#wiring-path"><span class="std std-ref">paths</span></a> returned by this method and by <a class="reference internal" href="#amaranth.lib.wiring.Signature.flatten" title="amaranth.lib.wiring.Signature.flatten"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Signature.flatten()</span></code></a>
differ. This method yields a single result for each <a class="reference internal" href="#amaranth.lib.wiring.Member" title="amaranth.lib.wiring.Member"><code class="xref py py-class docutils literal notranslate"><span class="pre">Member</span></code></a> in the collection,
disregarding their dimensions:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sig</span> <span class="o">=</span> <span class="n">wiring</span><span class="o">.</span><span class="n">Signature</span><span class="p">({</span>
<span class="gp">... </span>    <span class="s2">&quot;items&quot;</span><span class="p">:</span> <span class="n">In</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">... </span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">sig</span><span class="o">.</span><span class="n">members</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
<span class="go">[((&#39;items&#39;,), In(1).array(2))]</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="#amaranth.lib.wiring.Signature.flatten" title="amaranth.lib.wiring.Signature.flatten"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Signature.flatten()</span></code></a> method yields multiple results for such a member; see
the documentation for that method for an example.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Pairs of <a class="reference internal" href="#wiring-path"><span class="std std-ref">paths</span></a> and the corresponding members. A path yielded by
this method is a tuple of strings where each item is a key through which the item may
be reached.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>iterator of (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>, <a class="reference internal" href="#amaranth.lib.wiring.Member" title="amaranth.lib.wiring.Member"><code class="xref py py-class docutils literal notranslate"><span class="pre">Member</span></code></a>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="amaranth.lib.wiring.SignatureMembers.create">
<span class="sig-name descname"><span class="pre">create</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">src_loc_at</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amaranth.lib.wiring.SignatureMembers.create" title="Permalink to this definition"></a></dt>
<dd><p>Create members from their descriptions.</p>
<p>For each port member, this function creates a <code class="xref py py-class docutils literal notranslate"><span class="pre">Signal</span></code> with the shape and initial
value taken from the member description, and the name constructed from
the <a class="reference internal" href="#wiring-path"><span class="std std-ref">paths</span></a> to the member (by concatenating path items with a double
underscore, <code class="docutils literal notranslate"><span class="pre">__</span></code>).</p>
<p>For each signature member, this function calls <a class="reference internal" href="#amaranth.lib.wiring.Signature.create" title="amaranth.lib.wiring.Signature.create"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Signature.create()</span></code></a> for that signature.
The resulting object can have any type if a <a class="reference internal" href="#amaranth.lib.wiring.Signature" title="amaranth.lib.wiring.Signature"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signature</span></code></a> subclass overrides
the <a class="reference internal" href="#amaranth.lib.wiring.SignatureMembers.create" title="amaranth.lib.wiring.SignatureMembers.create"><code class="xref py py-class docutils literal notranslate"><span class="pre">create</span></code></a> method.</p>
<p>If the member description includes dimensions, in each case, instead of a single member,
a <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> of members is created for each dimension. (That is, for a single dimension
a list of members is returned, for two dimensions a list of lists is returned, and so on.)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Mapping of names to actual signature members.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>dict of <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> to <a class="reference internal" href="../guide.html#lang-valuelike"><span class="std std-ref">value-like</span></a> or interface object or a potentially nested list of these</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="amaranth.lib.wiring.FlippedSignatureMembers">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">amaranth.lib.wiring.</span></span><span class="sig-name descname"><span class="pre">FlippedSignatureMembers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">unflipped</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amaranth.lib.wiring.FlippedSignatureMembers" title="Permalink to this definition"></a></dt>
<dd><p>Mapping of signature member names to their descriptions, with the directions flipped.</p>
<p>Although an instance of <a class="reference internal" href="#amaranth.lib.wiring.FlippedSignatureMembers" title="amaranth.lib.wiring.FlippedSignatureMembers"><code class="xref py py-class docutils literal notranslate"><span class="pre">FlippedSignatureMembers</span></code></a> could be created directly, it will
be usually created by a call to <a class="reference internal" href="#amaranth.lib.wiring.SignatureMembers.flip" title="amaranth.lib.wiring.SignatureMembers.flip"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SignatureMembers.flip()</span></code></a>.</p>
<p>This container is a wrapper around <a class="reference internal" href="#amaranth.lib.wiring.SignatureMembers" title="amaranth.lib.wiring.SignatureMembers"><code class="xref py py-class docutils literal notranslate"><span class="pre">SignatureMembers</span></code></a> that contains the same members
as the inner mapping, but flips their data flow when they are accessed. For example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">members</span> <span class="o">=</span> <span class="n">wiring</span><span class="o">.</span><span class="n">SignatureMembers</span><span class="p">({</span><span class="s2">&quot;foo&quot;</span><span class="p">:</span> <span class="n">Out</span><span class="p">(</span><span class="mi">1</span><span class="p">)})</span>

<span class="n">flipped_members</span> <span class="o">=</span> <span class="n">members</span><span class="o">.</span><span class="n">flip</span><span class="p">()</span>
<span class="k">assert</span> <span class="n">flipped_members</span><span class="p">[</span><span class="s2">&quot;foo&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">flow</span> <span class="o">==</span> <span class="n">In</span>
</pre></div>
</div>
<p>This class implements the same methods, with the same functionality (other than the flipping of
the data flow), as the <a class="reference internal" href="#amaranth.lib.wiring.SignatureMembers" title="amaranth.lib.wiring.SignatureMembers"><code class="xref py py-class docutils literal notranslate"><span class="pre">SignatureMembers</span></code></a> class; see the documentation for that class
for details.</p>
<dl class="py method">
<dt class="sig sig-object py" id="amaranth.lib.wiring.FlippedSignatureMembers.flip">
<span class="sig-name descname"><span class="pre">flip</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#amaranth.lib.wiring.FlippedSignatureMembers.flip" title="Permalink to this definition"></a></dt>
<dd><p>Flips this mapping back to the original one.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="code highlight py python docutils literal highlight-python"><span class="n">unflipped</span></code></p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#amaranth.lib.wiring.SignatureMembers" title="amaranth.lib.wiring.SignatureMembers"><code class="xref py py-class docutils literal notranslate"><span class="pre">SignatureMembers</span></code></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="amaranth.lib.wiring.Signature">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">amaranth.lib.wiring.</span></span><span class="sig-name descname"><span class="pre">Signature</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">members</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amaranth.lib.wiring.Signature" title="Permalink to this definition"></a></dt>
<dd><p>Description of an interface object.</p>
<p>An interface object is a Python object that has a <code class="code highlight py python docutils literal highlight-python"><span class="n">signature</span></code> attribute containing
a <a class="reference internal" href="#amaranth.lib.wiring.Signature" title="amaranth.lib.wiring.Signature"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signature</span></code></a> object, as well as an attribute for every member of its signature.
Signatures and interface objects are tightly linked: an interface object can be created out
of a signature, and the signature is used when <a class="reference internal" href="#amaranth.lib.wiring.connect" title="amaranth.lib.wiring.connect"><code class="xref py py-func docutils literal notranslate"><span class="pre">connect()</span></code></a>ing two interface objects
together. See the <a class="reference internal" href="#wiring-intro1"><span class="std std-ref">introduction to interfaces</span></a> for a more detailed
explanation of why this is useful.</p>
<p><a class="reference internal" href="#amaranth.lib.wiring.Signature" title="amaranth.lib.wiring.Signature"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signature</span></code></a> can be used as a base class to define <a class="reference internal" href="#wiring-customizing"><span class="std std-ref">customized</span></a>
signatures and interface objects.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><a class="reference internal" href="#amaranth.lib.wiring.Signature" title="amaranth.lib.wiring.Signature"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signature</span></code></a> objects are immutable. Classes inheriting from <a class="reference internal" href="#amaranth.lib.wiring.Signature" title="amaranth.lib.wiring.Signature"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signature</span></code></a> must
ensure this remains the case when additional functionality is added.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="amaranth.lib.wiring.Signature.flip">
<span class="sig-name descname"><span class="pre">flip</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#amaranth.lib.wiring.Signature.flip" title="Permalink to this definition"></a></dt>
<dd><p>Flip the data flow of the members in this signature.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><p>Proxy object <code class="code highlight py python docutils literal highlight-python"><span class="n">FlippedSignature</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></code> that flips the data flow of the attributes
corresponding to the members that are accessed using it.</p>
<p>See the documentation for the <a class="reference internal" href="#amaranth.lib.wiring.FlippedSignature" title="amaranth.lib.wiring.FlippedSignature"><code class="xref py py-class docutils literal notranslate"><span class="pre">FlippedSignature</span></code></a> class for a detailed discussion
of how this proxy object works.</p>
</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#amaranth.lib.wiring.FlippedSignature" title="amaranth.lib.wiring.FlippedSignature"><code class="xref py py-class docutils literal notranslate"><span class="pre">FlippedSignature</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="amaranth.lib.wiring.Signature.members">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">members</span></span><a class="headerlink" href="#amaranth.lib.wiring.Signature.members" title="Permalink to this definition"></a></dt>
<dd><p>Members in this signature.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#amaranth.lib.wiring.SignatureMembers" title="amaranth.lib.wiring.SignatureMembers"><code class="xref py py-class docutils literal notranslate"><span class="pre">SignatureMembers</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="amaranth.lib.wiring.Signature.__eq__">
<span class="sig-name descname"><span class="pre">__eq__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amaranth.lib.wiring.Signature.__eq__" title="Permalink to this definition"></a></dt>
<dd><p>Compare this signature with another.</p>
<p>The behavior of this operator depends on the types of the arguments. If both <code class="code highlight py python docutils literal highlight-python"><span class="bp">self</span></code>
and <code class="code highlight py python docutils literal highlight-python"><span class="n">other</span></code> are instances of the base <a class="reference internal" href="#amaranth.lib.wiring.Signature" title="amaranth.lib.wiring.Signature"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signature</span></code></a> class, they are compared
structurally (the result is <code class="code highlight py python docutils literal highlight-python"><span class="bp">self</span><span class="o">.</span><span class="n">members</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">members</span></code>); otherwise they are
compared by identity (the result is <code class="code highlight py python docutils literal highlight-python"><span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span></code>).</p>
<p>Subclasses of <a class="reference internal" href="#amaranth.lib.wiring.Signature" title="amaranth.lib.wiring.Signature"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signature</span></code></a> are expected to override this method to take into account
the specifics of the domain. If the subclass has additional properties that do not influence
the <a class="reference internal" href="#amaranth.lib.wiring.Signature.members" title="amaranth.lib.wiring.Signature.members"><code class="xref py py-attr docutils literal notranslate"><span class="pre">members</span></code></a> dictionary but nevertheless make its instance incompatible with other
instances (for example, whether the feedback is combinational or registered),
the overridden method must take that into account.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="amaranth.lib.wiring.Signature.flatten">
<span class="sig-name descname"><span class="pre">flatten</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amaranth.lib.wiring.Signature.flatten" title="Permalink to this definition"></a></dt>
<dd><p>Recursively iterate through this signature, retrieving member values from an interface
object.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <a class="reference internal" href="#wiring-path"><span class="std std-ref">paths</span></a> returned by this method and by
<a class="reference internal" href="#amaranth.lib.wiring.SignatureMembers.flatten" title="amaranth.lib.wiring.SignatureMembers.flatten"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SignatureMembers.flatten()</span></code></a> differ. This method yield several results for each
<a class="reference internal" href="#amaranth.lib.wiring.Member" title="amaranth.lib.wiring.Member"><code class="xref py py-class docutils literal notranslate"><span class="pre">Member</span></code></a> in the collection that has a dimension:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sig</span> <span class="o">=</span> <span class="n">wiring</span><span class="o">.</span><span class="n">Signature</span><span class="p">({</span>
<span class="gp">... </span>    <span class="s2">&quot;items&quot;</span><span class="p">:</span> <span class="n">In</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">... </span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">create</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">sig</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>
<span class="go">[((&#39;items&#39;, 0), In(1), (sig obj__items__0)),</span>
<span class="go"> ((&#39;items&#39;, 1), In(1), (sig obj__items__1))]</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="#amaranth.lib.wiring.SignatureMembers.flatten" title="amaranth.lib.wiring.SignatureMembers.flatten"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SignatureMembers.flatten()</span></code></a> method yields one result for such a member; see
the documentation for that method for an example.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Tuples of <a class="reference internal" href="#wiring-path"><span class="std std-ref">paths</span></a>, flow, and the corresponding member values. A path
yielded by this method is a tuple of strings or integers where each item is an attribute
name or index (correspondingly) using which the member value was retrieved.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>iterator of (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> or <a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>, <a class="reference internal" href="#amaranth.lib.wiring.Flow" title="amaranth.lib.wiring.Flow"><code class="xref py py-class docutils literal notranslate"><span class="pre">Flow</span></code></a>, <a class="reference internal" href="../guide.html#lang-valuelike"><span class="std std-ref">value-like</span></a>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="amaranth.lib.wiring.Signature.is_compliant">
<span class="sig-name descname"><span class="pre">is_compliant</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reasons</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">('obj',)</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amaranth.lib.wiring.Signature.is_compliant" title="Permalink to this definition"></a></dt>
<dd><p>Check whether an object matches the description in this signature.</p>
<p>This module places few restrictions on what an interface object may be; it does not
prescribe a specific base class or a specific way of constructing the object, only
the values that its attributes should have. This method ensures consistency between
the signature and the interface object, checking every aspect of the provided interface
object for compliance with the signature.</p>
<p>It verifies that:</p>
<ul class="simple">
<li><p><code class="code highlight py python docutils literal highlight-python"><span class="n">obj</span></code> has a <code class="code highlight py python docutils literal highlight-python"><span class="n">signature</span></code> attribute whose value a <a class="reference internal" href="#amaranth.lib.wiring.Signature" title="amaranth.lib.wiring.Signature"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signature</span></code></a> instance
such that <code class="code highlight py python docutils literal highlight-python"><span class="bp">self</span> <span class="o">==</span> <span class="n">obj</span><span class="o">.</span><span class="n">signature</span></code>;</p></li>
<li><p>for each member, <code class="code highlight py python docutils literal highlight-python"><span class="n">obj</span></code> has an attribute with the same name, whose value:</p>
<ul>
<li><p>for members with <a class="reference internal" href="#amaranth.lib.wiring.Member.dimensions" title="amaranth.lib.wiring.Member.dimensions"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dimensions</span></code></a> specified, contains a list or
a tuple (or several levels of nested lists or tuples, for multiple dimensions)
satisfying the requirements below;</p></li>
<li><p>for port members, is a <a class="reference internal" href="../guide.html#lang-valuelike"><span class="std std-ref">value-like</span></a> object casting to
a <code class="xref py py-class docutils literal notranslate"><span class="pre">Signal</span></code> or a <code class="xref py py-class docutils literal notranslate"><span class="pre">Const</span></code> whose width and signedness is the same as that
of the member, and (in case of a <code class="xref py py-class docutils literal notranslate"><span class="pre">Signal</span></code>) which is not reset-less and whose
initial value is that of the member;</p></li>
<li><p>for signature members, matches the description in the signature as verified by
<a class="reference internal" href="#amaranth.lib.wiring.Signature.is_compliant" title="amaranth.lib.wiring.Signature.is_compliant"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Signature.is_compliant()</span></code></a>.</p></li>
</ul>
</li>
</ul>
<p>If the verification fails, this method reports the reason(s) by filling the <code class="code highlight py python docutils literal highlight-python"><span class="n">reasons</span></code>
container. These reasons are intended to be human-readable: more than one reason may be
reported but only in cases where this is helpful (e.g. the same error message will not
repeat 10 times for each of the 10 ports in a list).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reasons</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> or <code class="code highlight py python docutils literal highlight-python"><span class="kc">None</span></code>) – If provided, a container that receives diagnostic messages.</p></li>
<li><p><strong>path</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>) – The <a class="reference internal" href="#wiring-path"><span class="std std-ref">path</span></a> to <code class="code highlight py python docutils literal highlight-python"><span class="n">obj</span></code>. Could be set to improve diagnostic
messages if <code class="code highlight py python docutils literal highlight-python"><span class="n">obj</span></code> is nested within another object, or for clarity.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="code highlight py python docutils literal highlight-python"><span class="kc">True</span></code> if <code class="code highlight py python docutils literal highlight-python"><span class="n">obj</span></code> matches the description in this signature, <code class="code highlight py python docutils literal highlight-python"><span class="kc">False</span></code>
otherwise. If <code class="code highlight py python docutils literal highlight-python"><span class="kc">False</span></code> and <code class="code highlight py python docutils literal highlight-python"><span class="n">reasons</span></code> was not <code class="code highlight py python docutils literal highlight-python"><span class="kc">None</span></code>, it will contain
a detailed explanation why.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="amaranth.lib.wiring.Signature.create">
<span class="sig-name descname"><span class="pre">create</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">src_loc_at</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amaranth.lib.wiring.Signature.create" title="Permalink to this definition"></a></dt>
<dd><p>Create an interface object from this signature.</p>
<p>The default <a class="reference internal" href="#amaranth.lib.wiring.Signature.create" title="amaranth.lib.wiring.Signature.create"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Signature.create()</span></code></a> implementation consists of one line:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">create</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">src_loc_at</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">PureInterface</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="n">path</span><span class="p">,</span> <span class="n">src_loc_at</span><span class="o">=</span><span class="mi">1</span> <span class="o">+</span> <span class="n">src_loc_at</span><span class="p">)</span>
</pre></div>
</div>
<p>This implementation creates an interface object from this signature that serves purely
as a container for the attributes corresponding to the signature members, and implements
no behavior. Such an implementation is sufficient for signatures created ad-hoc using
the <code class="code highlight py python docutils literal highlight-python"><span class="n">Signature</span><span class="p">({</span> <span class="o">...</span> <span class="p">})</span></code> constructor as well as simple signature subclasses.</p>
<p>When defining a <a class="reference internal" href="#amaranth.lib.wiring.Signature" title="amaranth.lib.wiring.Signature"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signature</span></code></a> subclass that needs to customize the behavior of
the created interface objects, override this method with a similar implementation
that references the class of your custom interface object:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">CustomSignature</span><span class="p">(</span><span class="n">wiring</span><span class="o">.</span><span class="n">Signature</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">create</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">src_loc_at</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">CustomInterface</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="n">path</span><span class="p">,</span> <span class="n">src_loc_at</span><span class="o">=</span><span class="mi">1</span> <span class="o">+</span> <span class="n">src_loc_at</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">CustomInterface</span><span class="p">(</span><span class="n">wiring</span><span class="o">.</span><span class="n">PureInterface</span><span class="p">):</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">my_property</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="o">...</span>
</pre></div>
</div>
<p>The <code class="code highlight py python docutils literal highlight-python"><span class="n">path</span></code> and <code class="code highlight py python docutils literal highlight-python"><span class="n">src_loc_at</span></code> arguments are necessary to ensure the generated signals
have informative names and accurate source location information.</p>
<p>The custom <a class="reference internal" href="#amaranth.lib.wiring.Signature.create" title="amaranth.lib.wiring.Signature.create"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create()</span></code></a> method may take positional or keyword arguments in addition to
the two listed above. Such arguments must have a default value, because
the <a class="reference internal" href="#amaranth.lib.wiring.SignatureMembers.create" title="amaranth.lib.wiring.SignatureMembers.create"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SignatureMembers.create()</span></code></a> method will call the <a class="reference internal" href="#amaranth.lib.wiring.Signature.create" title="amaranth.lib.wiring.Signature.create"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Signature.create()</span></code></a> member
without these additional arguments when this signature is a member of another signature.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="amaranth.lib.wiring.Signature.annotations">
<span class="sig-name descname"><span class="pre">annotations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amaranth.lib.wiring.Signature.annotations" title="Permalink to this definition"></a></dt>
<dd><p>Annotate an interface object.</p>
<p>Subclasses of <a class="reference internal" href="#amaranth.lib.wiring.Signature" title="amaranth.lib.wiring.Signature"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signature</span></code></a> may override this method to provide annotations for
a corresponding interface object. The default implementation provides none.</p>
<p>See <a class="reference internal" href="meta.html#module-amaranth.lib.meta" title="amaranth.lib.meta"><code class="xref py py-mod docutils literal notranslate"><span class="pre">amaranth.lib.meta</span></code></a> for details.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="code highlight py python docutils literal highlight-python"><span class="nb">tuple</span><span class="p">()</span></code></p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>iterable of <a class="reference internal" href="meta.html#amaranth.lib.meta.Annotation" title="amaranth.lib.meta.Annotation"><code class="xref py py-class docutils literal notranslate"><span class="pre">Annotation</span></code></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="amaranth.lib.wiring.FlippedSignature">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">amaranth.lib.wiring.</span></span><span class="sig-name descname"><span class="pre">FlippedSignature</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">unflipped</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amaranth.lib.wiring.FlippedSignature" title="Permalink to this definition"></a></dt>
<dd><p>Description of an interface object, with the members’ directions flipped.</p>
<p>Although an instance of <a class="reference internal" href="#amaranth.lib.wiring.FlippedSignature" title="amaranth.lib.wiring.FlippedSignature"><code class="xref py py-class docutils literal notranslate"><span class="pre">FlippedSignature</span></code></a> could be created directly, it will be usually
created by a call to <a class="reference internal" href="#amaranth.lib.wiring.Signature.flip" title="amaranth.lib.wiring.Signature.flip"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Signature.flip()</span></code></a>.</p>
<p>This proxy is a wrapper around <a class="reference internal" href="#amaranth.lib.wiring.Signature" title="amaranth.lib.wiring.Signature"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signature</span></code></a> that contains the same description as
the inner mapping, but flips the members’ data flow when they are accessed. It is useful
because <a class="reference internal" href="#amaranth.lib.wiring.Signature" title="amaranth.lib.wiring.Signature"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signature</span></code></a> objects are mutable and may include custom behavior, and if one was
copied (rather than wrapped) by <a class="reference internal" href="#amaranth.lib.wiring.Signature.flip" title="amaranth.lib.wiring.Signature.flip"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Signature.flip()</span></code></a>, the wrong object would be mutated, and
custom behavior would be unavailable.</p>
<p>For example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">sig</span> <span class="o">=</span> <span class="n">wiring</span><span class="o">.</span><span class="n">Signature</span><span class="p">({</span><span class="s2">&quot;foo&quot;</span><span class="p">:</span> <span class="n">Out</span><span class="p">(</span><span class="mi">1</span><span class="p">)})</span>

<span class="n">flipped_sig</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">flip</span><span class="p">()</span>
<span class="k">assert</span> <span class="n">flipped_sig</span><span class="o">.</span><span class="n">members</span><span class="p">[</span><span class="s2">&quot;foo&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">flow</span> <span class="o">==</span> <span class="n">In</span>

<span class="n">sig</span><span class="o">.</span><span class="n">attr</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">assert</span> <span class="n">flipped_sig</span><span class="o">.</span><span class="n">attr</span> <span class="o">==</span> <span class="mi">1</span>
<span class="n">flipped_sig</span><span class="o">.</span><span class="n">attr</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="k">assert</span> <span class="n">sig</span><span class="o">.</span><span class="n">attr</span> <span class="o">==</span> <span class="n">flipped_sig</span><span class="o">.</span><span class="n">attr</span> <span class="o">==</span> <span class="mi">2</span>
</pre></div>
</div>
<p>This class implements the same methods, with the same functionality (other than the flipping of
the members’ data flow), as the <a class="reference internal" href="#amaranth.lib.wiring.Signature" title="amaranth.lib.wiring.Signature"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signature</span></code></a> class; see the documentation for that class
for details.</p>
<p>It is not possible to inherit from <a class="reference internal" href="#amaranth.lib.wiring.FlippedSignature" title="amaranth.lib.wiring.FlippedSignature"><code class="xref py py-class docutils literal notranslate"><span class="pre">FlippedSignature</span></code></a> and <a class="reference internal" href="#amaranth.lib.wiring.Signature.flip" title="amaranth.lib.wiring.Signature.flip"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Signature.flip()</span></code></a> must not
be overridden. If a <a class="reference internal" href="#amaranth.lib.wiring.Signature" title="amaranth.lib.wiring.Signature"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signature</span></code></a> subclass defines a method and this method is called on
a flipped instance of the subclass, it receives the flipped instance as its <code class="code highlight py python docutils literal highlight-python"><span class="bp">self</span></code> argument.
To distinguish being called on the flipped instance from being called on the unflipped one, use
<code class="code highlight py python docutils literal highlight-python"><span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">FlippedSignature</span><span class="p">)</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SignatureKnowsWhenFlipped</span><span class="p">(</span><span class="n">wiring</span><span class="o">.</span><span class="n">Signature</span><span class="p">):</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_flipped</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wiring</span><span class="o">.</span><span class="n">FlippedSignature</span><span class="p">)</span>

<span class="n">sig</span> <span class="o">=</span> <span class="n">SignatureKnowsWhenFlipped</span><span class="p">({})</span>
<span class="k">assert</span> <span class="n">sig</span><span class="o">.</span><span class="n">is_flipped</span> <span class="o">==</span> <span class="kc">False</span>
<span class="k">assert</span> <span class="n">sig</span><span class="o">.</span><span class="n">flip</span><span class="p">()</span><span class="o">.</span><span class="n">is_flipped</span> <span class="o">==</span> <span class="kc">True</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="amaranth.lib.wiring.FlippedSignature.flip">
<span class="sig-name descname"><span class="pre">flip</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#amaranth.lib.wiring.FlippedSignature.flip" title="Permalink to this definition"></a></dt>
<dd><p>Flips this signature back to the original one.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="code highlight py python docutils literal highlight-python"><span class="n">unflipped</span></code></p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#amaranth.lib.wiring.Signature" title="amaranth.lib.wiring.Signature"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signature</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="amaranth.lib.wiring.FlippedSignature.__getattr__">
<span class="sig-name descname"><span class="pre">__getattr__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amaranth.lib.wiring.FlippedSignature.__getattr__" title="Permalink to this definition"></a></dt>
<dd><p>Retrieves attribute or method <code class="code highlight py python docutils literal highlight-python"><span class="n">name</span></code> of the unflipped signature.</p>
<p>Performs <code class="code highlight py python docutils literal highlight-python"><span class="nb">getattr</span><span class="p">(</span><span class="n">unflipped</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span></code>, ensuring that, if <code class="code highlight py python docutils literal highlight-python"><span class="n">name</span></code> refers to a property
getter or a method, its <code class="code highlight py python docutils literal highlight-python"><span class="bp">self</span></code> argument receives the <em>flipped</em> signature. A class
method’s <code class="code highlight py python docutils literal highlight-python"><span class="bp">cls</span></code> argument receives the class of the <em>unflipped</em> signature, as usual.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="amaranth.lib.wiring.FlippedSignature.__setattr__">
<span class="sig-name descname"><span class="pre">__setattr__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amaranth.lib.wiring.FlippedSignature.__setattr__" title="Permalink to this definition"></a></dt>
<dd><p>Assigns attribute <code class="code highlight py python docutils literal highlight-python"><span class="n">name</span></code> of the unflipped signature to <code class="code highlight py python docutils literal highlight-python"><span class="n">value</span></code>.</p>
<p>Performs <code class="code highlight py python docutils literal highlight-python"><span class="nb">setattr</span><span class="p">(</span><span class="n">unflipped</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span></code>, ensuring that, if <code class="code highlight py python docutils literal highlight-python"><span class="n">name</span></code> refers to
a property setter, its <code class="code highlight py python docutils literal highlight-python"><span class="bp">self</span></code> argument receives the flipped signature.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="amaranth.lib.wiring.FlippedSignature.__delattr__">
<span class="sig-name descname"><span class="pre">__delattr__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amaranth.lib.wiring.FlippedSignature.__delattr__" title="Permalink to this definition"></a></dt>
<dd><p>Removes attribute <code class="code highlight py python docutils literal highlight-python"><span class="n">name</span></code> of the unflipped signature.</p>
<p>Performs <code class="code highlight py python docutils literal highlight-python"><span class="nb">delattr</span><span class="p">(</span><span class="n">unflipped</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span></code>, ensuring that, if <code class="code highlight py python docutils literal highlight-python"><span class="n">name</span></code> refers to a property
deleter, its <code class="code highlight py python docutils literal highlight-python"><span class="bp">self</span></code> argument receives the flipped signature.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="amaranth.lib.wiring.SignatureMeta">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">amaranth.lib.wiring.</span></span><span class="sig-name descname"><span class="pre">SignatureMeta</span></span><a class="headerlink" href="#amaranth.lib.wiring.SignatureMeta" title="Permalink to this definition"></a></dt>
<dd><p>Metaclass for <a class="reference internal" href="#amaranth.lib.wiring.Signature" title="amaranth.lib.wiring.Signature"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signature</span></code></a> that makes <a class="reference internal" href="#amaranth.lib.wiring.FlippedSignature" title="amaranth.lib.wiring.FlippedSignature"><code class="xref py py-class docutils literal notranslate"><span class="pre">FlippedSignature</span></code></a> its
‘virtual subclass’.</p>
<p>The object returned by <a class="reference internal" href="#amaranth.lib.wiring.Signature.flip" title="amaranth.lib.wiring.Signature.flip"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Signature.flip()</span></code></a> is an instance of <a class="reference internal" href="#amaranth.lib.wiring.FlippedSignature" title="amaranth.lib.wiring.FlippedSignature"><code class="xref py py-class docutils literal notranslate"><span class="pre">FlippedSignature</span></code></a>.
It implements all of the methods <a class="reference internal" href="#amaranth.lib.wiring.Signature" title="amaranth.lib.wiring.Signature"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signature</span></code></a> has, and for subclasses of
<a class="reference internal" href="#amaranth.lib.wiring.Signature" title="amaranth.lib.wiring.Signature"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signature</span></code></a>, it implements all of the methods defined on the subclass as well.
This makes it effectively a subtype of <a class="reference internal" href="#amaranth.lib.wiring.Signature" title="amaranth.lib.wiring.Signature"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signature</span></code></a> (or a derived class of it), but this
relationship is not captured by the Python type system: <a class="reference internal" href="#amaranth.lib.wiring.FlippedSignature" title="amaranth.lib.wiring.FlippedSignature"><code class="xref py py-class docutils literal notranslate"><span class="pre">FlippedSignature</span></code></a> only has
<a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> as its base class.</p>
<p>This metaclass extends <a class="reference external" href="https://docs.python.org/3/library/functions.html#issubclass" title="(in Python v3.12)"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a> and <a class="reference external" href="https://docs.python.org/3/library/functions.html#isinstance" title="(in Python v3.12)"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> so that they take into
account the subtyping relationship between <a class="reference internal" href="#amaranth.lib.wiring.Signature" title="amaranth.lib.wiring.Signature"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signature</span></code></a> and <a class="reference internal" href="#amaranth.lib.wiring.FlippedSignature" title="amaranth.lib.wiring.FlippedSignature"><code class="xref py py-class docutils literal notranslate"><span class="pre">FlippedSignature</span></code></a>,
described below.</p>
<dl class="py method">
<dt class="sig sig-object py" id="amaranth.lib.wiring.SignatureMeta.__subclasscheck__">
<span class="sig-name descname"><span class="pre">__subclasscheck__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">subclass</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amaranth.lib.wiring.SignatureMeta.__subclasscheck__" title="Permalink to this definition"></a></dt>
<dd><p>Override of <code class="code highlight py python docutils literal highlight-python"><span class="nb">issubclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">Signature</span><span class="p">)</span></code>.</p>
<p>In addition to the standard behavior of <a class="reference external" href="https://docs.python.org/3/library/functions.html#issubclass" title="(in Python v3.12)"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a>, this override makes
<a class="reference internal" href="#amaranth.lib.wiring.FlippedSignature" title="amaranth.lib.wiring.FlippedSignature"><code class="xref py py-class docutils literal notranslate"><span class="pre">FlippedSignature</span></code></a> a subclass of <a class="reference internal" href="#amaranth.lib.wiring.Signature" title="amaranth.lib.wiring.Signature"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signature</span></code></a> or any of its subclasses.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="amaranth.lib.wiring.SignatureMeta.__instancecheck__">
<span class="sig-name descname"><span class="pre">__instancecheck__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">instance</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amaranth.lib.wiring.SignatureMeta.__instancecheck__" title="Permalink to this definition"></a></dt>
<dd><p>Override of <code class="code highlight py python docutils literal highlight-python"><span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Signature</span><span class="p">)</span></code>.</p>
<p>In addition to the standard behavior of <a class="reference external" href="https://docs.python.org/3/library/functions.html#isinstance" title="(in Python v3.12)"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a>, this override makes
<code class="code highlight py python docutils literal highlight-python"><span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span></code> act as <code class="code highlight py python docutils literal highlight-python"><span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">flip</span><span class="p">(),</span> <span class="bp">cls</span><span class="p">)</span></code> where
<code class="code highlight py python docutils literal highlight-python"><span class="n">obj</span></code> is an instance of <a class="reference internal" href="#amaranth.lib.wiring.FlippedSignature" title="amaranth.lib.wiring.FlippedSignature"><code class="xref py py-class docutils literal notranslate"><span class="pre">FlippedSignature</span></code></a>.</p>
</dd></dl>

</dd></dl>

</section>
<section id="interfaces">
<h2>Interfaces<a class="headerlink" href="#interfaces" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="amaranth.lib.wiring.PureInterface">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">amaranth.lib.wiring.</span></span><span class="sig-name descname"><span class="pre">PureInterface</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signature</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">src_loc_at</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amaranth.lib.wiring.PureInterface" title="Permalink to this definition"></a></dt>
<dd><p>A helper for constructing ad-hoc interfaces.</p>
<p>The <a class="reference internal" href="#amaranth.lib.wiring.PureInterface" title="amaranth.lib.wiring.PureInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">PureInterface</span></code></a> helper primarily exists to be used by the default implementation of
<a class="reference internal" href="#amaranth.lib.wiring.Signature.create" title="amaranth.lib.wiring.Signature.create"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Signature.create()</span></code></a>, but it can also be used in any other context where an interface
object needs to be created without the overhead of defining a class for it.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>Any object can be an interface object; it only needs a <code class="code highlight py python docutils literal highlight-python"><span class="n">signature</span></code> property containing
a compliant signature. It is <strong>not</strong> necessary to use <a class="reference internal" href="#amaranth.lib.wiring.PureInterface" title="amaranth.lib.wiring.PureInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">PureInterface</span></code></a> in order to
create an interface object, but it may be used either directly or as a base class whenever
it is convenient to do so.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="amaranth.lib.wiring.PureInterface.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signature</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">src_loc_at</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amaranth.lib.wiring.PureInterface.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Create attributes from a signature.</p>
<p>The sole method defined by this helper is its constructor, which only defines
the <code class="code highlight py python docutils literal highlight-python"><span class="bp">self</span><span class="o">.</span><span class="n">signature</span></code> attribute as well as the attributes created from the signature
members:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">signature</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">({</span>
        <span class="s2">&quot;signature&quot;</span><span class="p">:</span> <span class="n">signature</span><span class="p">,</span>
        <span class="o">**</span><span class="n">signature</span><span class="o">.</span><span class="n">members</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">path</span><span class="o">=</span><span class="n">path</span><span class="p">)</span>
    <span class="p">})</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This implementation can be copied and reused in interface objects that <em>do</em> include
custom behavior, if the signature serves as the source of truth for attributes
corresponding to its members. Although it is less repetitive, this approach can confuse
IDEs and type checkers.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="amaranth.lib.wiring.FlippedInterface">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">amaranth.lib.wiring.</span></span><span class="sig-name descname"><span class="pre">FlippedInterface</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">unflipped</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amaranth.lib.wiring.FlippedInterface" title="Permalink to this definition"></a></dt>
<dd><p>An interface object, with its members’ directions flipped.</p>
<p>An instance of <a class="reference internal" href="#amaranth.lib.wiring.FlippedInterface" title="amaranth.lib.wiring.FlippedInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">FlippedInterface</span></code></a> should only be created by calling <a class="reference internal" href="#amaranth.lib.wiring.flipped" title="amaranth.lib.wiring.flipped"><code class="xref py py-func docutils literal notranslate"><span class="pre">flipped()</span></code></a>,
which ensures that a <code class="code highlight py python docutils literal highlight-python"><span class="n">FlippedInterface</span><span class="p">(</span><span class="n">FlippedInterface</span><span class="p">(</span><span class="o">...</span><span class="p">))</span></code> object is never created.</p>
<p>This proxy wraps any interface object and forwards attribute and method access to the wrapped
interface object while flipping its signature and the values of any attributes corresponding to
interface members. It is useful because interface objects may be mutable or include custom
behavior, and explicitly keeping track of whether the interface object is flipped would be very
burdensome.</p>
<p>For example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">intf</span> <span class="o">=</span> <span class="n">wiring</span><span class="o">.</span><span class="n">PureInterface</span><span class="p">(</span><span class="n">wiring</span><span class="o">.</span><span class="n">Signature</span><span class="p">({</span><span class="s2">&quot;foo&quot;</span><span class="p">:</span> <span class="n">Out</span><span class="p">(</span><span class="mi">1</span><span class="p">)}),</span> <span class="n">path</span><span class="o">=</span><span class="p">())</span>

<span class="n">flipped_intf</span> <span class="o">=</span> <span class="n">wiring</span><span class="o">.</span><span class="n">flipped</span><span class="p">(</span><span class="n">intf</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">flipped_intf</span><span class="o">.</span><span class="n">signature</span><span class="o">.</span><span class="n">members</span><span class="p">[</span><span class="s2">&quot;foo&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">flow</span> <span class="o">==</span> <span class="n">In</span>

<span class="n">intf</span><span class="o">.</span><span class="n">attr</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">assert</span> <span class="n">flipped_intf</span><span class="o">.</span><span class="n">attr</span> <span class="o">==</span> <span class="mi">1</span>
<span class="n">flipped_intf</span><span class="o">.</span><span class="n">attr</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="k">assert</span> <span class="n">intf</span><span class="o">.</span><span class="n">attr</span> <span class="o">==</span> <span class="n">flipped_intf</span><span class="o">.</span><span class="n">attr</span> <span class="o">==</span> <span class="mi">2</span>
</pre></div>
</div>
<p>It is not possible to inherit from <a class="reference internal" href="#amaranth.lib.wiring.FlippedInterface" title="amaranth.lib.wiring.FlippedInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">FlippedInterface</span></code></a>. If an interface object class
defines a method or a property and it is called on the flipped interface object, the method
receives the flipped interface object as its <code class="code highlight py python docutils literal highlight-python"><span class="bp">self</span></code> argument. To distinguish being called
on the flipped interface object from being called on the unflipped one, use
<code class="code highlight py python docutils literal highlight-python"><span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">FlippedInterface</span><span class="p">)</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">InterfaceKnowsWhenFlipped</span><span class="p">:</span>
    <span class="n">signature</span> <span class="o">=</span> <span class="n">wiring</span><span class="o">.</span><span class="n">Signature</span><span class="p">({})</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_flipped</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wiring</span><span class="o">.</span><span class="n">FlippedInterface</span><span class="p">)</span>

<span class="n">intf</span> <span class="o">=</span> <span class="n">InterfaceKnowsWhenFlipped</span><span class="p">()</span>
<span class="k">assert</span> <span class="n">intf</span><span class="o">.</span><span class="n">is_flipped</span> <span class="o">==</span> <span class="kc">False</span>
<span class="k">assert</span> <span class="n">wiring</span><span class="o">.</span><span class="n">flipped</span><span class="p">(</span><span class="n">intf</span><span class="p">)</span><span class="o">.</span><span class="n">is_flipped</span> <span class="o">==</span> <span class="kc">True</span>
</pre></div>
</div>
<dl class="py property">
<dt class="sig sig-object py" id="amaranth.lib.wiring.FlippedInterface.signature">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">signature</span></span><a class="headerlink" href="#amaranth.lib.wiring.FlippedInterface.signature" title="Permalink to this definition"></a></dt>
<dd><p>Signature of the flipped interface.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="code highlight py python docutils literal highlight-python"><span class="n">unflipped</span><span class="o">.</span><span class="n">signature</span><span class="o">.</span><span class="n">flip</span><span class="p">()</span></code></p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#amaranth.lib.wiring.Signature" title="amaranth.lib.wiring.Signature"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signature</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="amaranth.lib.wiring.FlippedInterface.__eq__">
<span class="sig-name descname"><span class="pre">__eq__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amaranth.lib.wiring.FlippedInterface.__eq__" title="Permalink to this definition"></a></dt>
<dd><p>Compare this flipped interface with another.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="code highlight py python docutils literal highlight-python"><span class="kc">True</span></code> if <code class="code highlight py python docutils literal highlight-python"><span class="n">other</span></code> is an instance <code class="code highlight py python docutils literal highlight-python"><span class="n">FlippedInterface</span><span class="p">(</span><span class="n">other_unflipped</span><span class="p">)</span></code> where
<code class="code highlight py python docutils literal highlight-python"><span class="n">unflipped</span> <span class="o">==</span> <span class="n">other_unflipped</span></code>, <code class="code highlight py python docutils literal highlight-python"><span class="kc">False</span></code> otherwise.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="amaranth.lib.wiring.FlippedInterface.__getattr__">
<span class="sig-name descname"><span class="pre">__getattr__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amaranth.lib.wiring.FlippedInterface.__getattr__" title="Permalink to this definition"></a></dt>
<dd><p>Retrieves attribute or method <code class="code highlight py python docutils literal highlight-python"><span class="n">name</span></code> of the unflipped interface.</p>
<p>Performs <code class="code highlight py python docutils literal highlight-python"><span class="nb">getattr</span><span class="p">(</span><span class="n">unflipped</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span></code>, with the following caveats:</p>
<ol class="arabic simple">
<li><p>If <code class="code highlight py python docutils literal highlight-python"><span class="n">name</span></code> refers to a signature member, the returned interface object is flipped.</p></li>
<li><p>If <code class="code highlight py python docutils literal highlight-python"><span class="n">name</span></code> refers to a property getter or a method, its <code class="code highlight py python docutils literal highlight-python"><span class="bp">self</span></code> argument receives
the <em>flipped</em> interface. A class method’s <code class="code highlight py python docutils literal highlight-python"><span class="bp">cls</span></code> argument receives the class of
the <em>unflipped</em> interface, as usual.</p></li>
</ol>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="amaranth.lib.wiring.FlippedInterface.__setattr__">
<span class="sig-name descname"><span class="pre">__setattr__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amaranth.lib.wiring.FlippedInterface.__setattr__" title="Permalink to this definition"></a></dt>
<dd><p>Assigns attribute <code class="code highlight py python docutils literal highlight-python"><span class="n">name</span></code> of the unflipped interface to <code class="code highlight py python docutils literal highlight-python"><span class="n">value</span></code>.</p>
<p>Performs <code class="code highlight py python docutils literal highlight-python"><span class="nb">setattr</span><span class="p">(</span><span class="n">unflipped</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span></code>, with the following caveats:</p>
<ol class="arabic simple">
<li><p>If <code class="code highlight py python docutils literal highlight-python"><span class="n">name</span></code> refers to a signature member, the assigned interface object is flipped.</p></li>
<li><p>If <code class="code highlight py python docutils literal highlight-python"><span class="n">name</span></code> refers to a property setter, its <code class="code highlight py python docutils literal highlight-python"><span class="bp">self</span></code> argument receives the flipped
interface.</p></li>
</ol>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="amaranth.lib.wiring.FlippedInterface.__delattr__">
<span class="sig-name descname"><span class="pre">__delattr__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amaranth.lib.wiring.FlippedInterface.__delattr__" title="Permalink to this definition"></a></dt>
<dd><p>Removes attribute <code class="code highlight py python docutils literal highlight-python"><span class="n">name</span></code> of the unflipped interface.</p>
<p>Performs <code class="code highlight py python docutils literal highlight-python"><span class="nb">delattr</span><span class="p">(</span><span class="n">unflipped</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span></code>, ensuring that, if <code class="code highlight py python docutils literal highlight-python"><span class="n">name</span></code> refers to a property
deleter, its <code class="code highlight py python docutils literal highlight-python"><span class="bp">self</span></code> argument receives the flipped interface.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="amaranth.lib.wiring.flipped">
<span class="sig-prename descclassname"><span class="pre">amaranth.lib.wiring.</span></span><span class="sig-name descname"><span class="pre">flipped</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">interface</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amaranth.lib.wiring.flipped" title="Permalink to this definition"></a></dt>
<dd><p>Flip the data flow of the members of the interface object <code class="code highlight py python docutils literal highlight-python"><span class="n">interface</span></code>.</p>
<p>If an interface object is flipped twice, returns the original object:
<code class="code highlight py python docutils literal highlight-python"><span class="n">flipped</span><span class="p">(</span><span class="n">flipped</span><span class="p">(</span><span class="n">interface</span><span class="p">))</span> <span class="ow">is</span> <span class="n">interface</span></code>. Otherwise, wraps <code class="code highlight py python docutils literal highlight-python"><span class="n">interface</span></code> in
a <a class="reference internal" href="#amaranth.lib.wiring.FlippedInterface" title="amaranth.lib.wiring.FlippedInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">FlippedInterface</span></code></a> proxy object that flips the directions of its members.</p>
<p>See the documentation for the <a class="reference internal" href="#amaranth.lib.wiring.FlippedInterface" title="amaranth.lib.wiring.FlippedInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">FlippedInterface</span></code></a> class for a detailed discussion of how
this proxy object works.</p>
</dd></dl>

</section>
<section id="making-connections">
<h2>Making connections<a class="headerlink" href="#making-connections" title="Permalink to this heading"></a></h2>
<dl class="py exception">
<dt class="sig sig-object py" id="amaranth.lib.wiring.ConnectionError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">amaranth.lib.wiring.</span></span><span class="sig-name descname"><span class="pre">ConnectionError</span></span><a class="headerlink" href="#amaranth.lib.wiring.ConnectionError" title="Permalink to this definition"></a></dt>
<dd><p>Exception raised when the <a class="reference internal" href="#amaranth.lib.wiring.connect" title="amaranth.lib.wiring.connect"><code class="xref py py-func docutils literal notranslate"><span class="pre">connect()</span></code></a> function is requested to perform an impossible,
meaningless, or forbidden connection.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="amaranth.lib.wiring.connect">
<span class="sig-prename descclassname"><span class="pre">amaranth.lib.wiring.</span></span><span class="sig-name descname"><span class="pre">connect</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amaranth.lib.wiring.connect" title="Permalink to this definition"></a></dt>
<dd><p>Connect interface objects to each other.</p>
<p>This function creates connections between ports of several interface objects. (Any number of
interface objects may be provided; in most cases it is two.)</p>
<p>The connections can be made only if all of the objects satisfy a number of requirements:</p>
<ul class="simple">
<li><p>Every interface object must have the same set of port members, and they must have the same
<a class="reference internal" href="#amaranth.lib.wiring.Member.dimensions" title="amaranth.lib.wiring.Member.dimensions"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dimensions</span></code></a>.</p></li>
<li><p>For each path, the port members of every interface object must have the same width and initial
value (for port members corresponding to signals) or constant value (for port members
corresponding to constants). Signedness may differ.</p></li>
<li><p>For each path, at most one interface object must have the corresponding port member be
an output.</p></li>
<li><p>For a given path, if any of the interface objects has an input port member corresponding
to a constant value, then the rest of the interface objects must have output port members
corresponding to the same constant value.</p></li>
<li><p>When connecting multiple interface objects, at least one connection must be made.</p></li>
</ul>
<p>For example, if <code class="code highlight py python docutils literal highlight-python"><span class="n">obj1</span></code> is being connected to <code class="code highlight py python docutils literal highlight-python"><span class="n">obj2</span></code> and <code class="code highlight py python docutils literal highlight-python"><span class="n">obj3</span></code>, and <code class="code highlight py python docutils literal highlight-python"><span class="n">obj1</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">b</span></code>
is an output, then <code class="code highlight py python docutils literal highlight-python"><span class="n">obj2</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">b</span></code> and <code class="code highlight py python docutils literal highlight-python"><span class="n">obj2</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">b</span></code> must exist and be inputs. If <code class="code highlight py python docutils literal highlight-python"><span class="n">obj2</span><span class="o">.</span><span class="n">c</span></code>
is an input and its value is <code class="code highlight py python docutils literal highlight-python"><span class="n">Const</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span></code>, then <code class="code highlight py python docutils literal highlight-python"><span class="n">obj1</span><span class="o">.</span><span class="n">c</span></code> and <code class="code highlight py python docutils literal highlight-python"><span class="n">obj3</span><span class="o">.</span><span class="n">c</span></code> must be outputs
whose value is also <code class="code highlight py python docutils literal highlight-python"><span class="n">Const</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span></code>. If no ports besides <code class="code highlight py python docutils literal highlight-python"><span class="n">obj1</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">b</span></code> and <code class="code highlight py python docutils literal highlight-python"><span class="n">obj1</span><span class="o">.</span><span class="n">c</span></code> exist,
then no ports except for those two must exist on <code class="code highlight py python docutils literal highlight-python"><span class="n">obj2</span></code> and <code class="code highlight py python docutils literal highlight-python"><span class="n">obj3</span></code> either.</p>
<p>Once it is determined that the interface objects can be connected, this function performs
an equivalent of:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">m</span><span class="o">.</span><span class="n">d</span><span class="o">.</span><span class="n">comb</span> <span class="o">+=</span> <span class="p">[</span>
    <span class="n">in1</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">out1</span><span class="p">),</span>
    <span class="n">in2</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">out1</span><span class="p">),</span>
    <span class="o">...</span>
<span class="p">]</span>
</pre></div>
</div>
<p>Where <code class="code highlight py python docutils literal highlight-python"><span class="n">out1</span></code> is an output and <code class="code highlight py python docutils literal highlight-python"><span class="n">in1</span></code>, <code class="code highlight py python docutils literal highlight-python"><span class="n">in2</span></code>, … are the inputs that have the same
path. (If no interface object has an output for a given path, <strong>no connection at all</strong> is made.)</p>
<p>The positions (within <code class="code highlight py python docutils literal highlight-python"><span class="n">args</span></code>) or names (within <code class="code highlight py python docutils literal highlight-python"><span class="n">kwargs</span></code>) of the arguments do not affect
the connections that are made. There is no difference in behavior between <code class="code highlight py python docutils literal highlight-python"><span class="n">connect</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span></code>
and <code class="code highlight py python docutils literal highlight-python"><span class="n">connect</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span></code> or <code class="code highlight py python docutils literal highlight-python"><span class="n">connect</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">arbiter</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">decoder</span><span class="o">=</span><span class="n">b</span><span class="p">)</span></code>. The names of the keyword
arguments serve only a documentation purpose: they clarify the diagnostic messages when
a connection cannot be made.</p>
</dd></dl>

</section>
<section id="components">
<h2>Components<a class="headerlink" href="#components" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="amaranth.lib.wiring.Component">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">amaranth.lib.wiring.</span></span><span class="sig-name descname"><span class="pre">Component</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">src_loc_at</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amaranth.lib.wiring.Component" title="Permalink to this definition"></a></dt>
<dd><p>Base class for elaboratable interface objects.</p>
<p>A component is an <code class="xref py py-class docutils literal notranslate"><span class="pre">Elaboratable</span></code> whose interaction with other parts of the design is
defined by its signature. Most if not all elaboratables in idiomatic Amaranth code should be
components, as the signature clarifies the direction of data flow at their boundary. See
the <a class="reference internal" href="#wiring-intro1"><span class="std std-ref">introduction to interfaces</span></a> section for a practical guide to defining
and using components.</p>
<p>There are two ways to define a component. If all instances of a component have the same
signature, it can be defined using <a class="reference external" href="https://docs.python.org/3/glossary.html#term-variable-annotation" title="(in Python v3.12)"><span class="xref std std-term">variable annotations</span></a>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">FixedComponent</span><span class="p">(</span><span class="n">wiring</span><span class="o">.</span><span class="n">Component</span><span class="p">):</span>
    <span class="n">en</span><span class="p">:</span> <span class="n">In</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">data</span><span class="p">:</span> <span class="n">Out</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
</pre></div>
</div>
<p>The variable annotations are collected by the constructor <code class="xref py py-meth docutils literal notranslate"><span class="pre">Component.__init__()</span></code>. Only
public (not starting with <code class="docutils literal notranslate"><span class="pre">_</span></code>) annotations with <a class="reference internal" href="#amaranth.lib.wiring.Member" title="amaranth.lib.wiring.Member"><code class="xref py py-class docutils literal notranslate"><span class="pre">In</span></code></a> or <a class="reference internal" href="#amaranth.lib.wiring.Member" title="amaranth.lib.wiring.Member"><code class="xref py py-class docutils literal notranslate"><span class="pre">Out</span></code></a>
objects are considered; all other annotations are ignored under the assumption that they are
interpreted by some other tool.</p>
<p>It is possible to use inheritance to extend a component: the component’s signature is composed
from the variable annotations in the class that is being constructed as well as all of its
base classes. It is an error to have more than one variable annotation for the same attribute.</p>
<p>If different instances of a component may need to have different signatures, variable
annotations cannot be used. In this case, the constructor should be overridden, and
the computed signature members should be provided to the superclass constructor:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ParametricComponent</span><span class="p">(</span><span class="n">wiring</span><span class="o">.</span><span class="n">Component</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_width</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">({</span>
            <span class="s2">&quot;en&quot;</span><span class="p">:</span> <span class="n">In</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
            <span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="n">Out</span><span class="p">(</span><span class="n">data_width</span><span class="p">)</span>
        <span class="p">})</span>
</pre></div>
</div>
<p>It is also possible to pass a <a class="reference internal" href="#amaranth.lib.wiring.Signature" title="amaranth.lib.wiring.Signature"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signature</span></code></a> instance to the superclass constructor.</p>
<p>Aside from initializing the <a class="reference internal" href="#amaranth.lib.wiring.Component.signature" title="amaranth.lib.wiring.Component.signature"><code class="xref py py-attr docutils literal notranslate"><span class="pre">signature</span></code></a> attribute, the <code class="xref py py-meth docutils literal notranslate"><span class="pre">Component.__init__()</span></code>
constructor creates attributes corresponding to all of the members defined in the signature.
If an attribute with the same name as that of a member already exists, an error is raied.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#TypeError" title="(in Python v3.12)"><strong>TypeError</strong></a> – If the <code class="code highlight py python docutils literal highlight-python"><span class="n">signature</span></code> object is neither a <a class="reference internal" href="#amaranth.lib.wiring.Signature" title="amaranth.lib.wiring.Signature"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signature</span></code></a> nor a <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>.
    If neither variable annotations nor the <code class="code highlight py python docutils literal highlight-python"><span class="n">signature</span></code> argument are present, or if
    both are present.</p></li>
<li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#NameError" title="(in Python v3.12)"><strong>NameError</strong></a> – If a name conflict is detected between two variable annotations, or between a member
    and an existing attribute.</p></li>
</ul>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="amaranth.lib.wiring.Component.signature">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">signature</span></span><a class="headerlink" href="#amaranth.lib.wiring.Component.signature" title="Permalink to this definition"></a></dt>
<dd><p>Signature of the component.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Do not override this property. Once a component is constructed, its <a class="reference internal" href="#amaranth.lib.wiring.Component.signature" title="amaranth.lib.wiring.Component.signature"><code class="xref py py-attr docutils literal notranslate"><span class="pre">signature</span></code></a>
property must always return the same <a class="reference internal" href="#amaranth.lib.wiring.Signature" title="amaranth.lib.wiring.Signature"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signature</span></code></a> instance. The constructor
can be used to customize a component’s signature.</p>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="amaranth.lib.wiring.Component.metadata">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">metadata</span></span><a class="headerlink" href="#amaranth.lib.wiring.Component.metadata" title="Permalink to this definition"></a></dt>
<dd><p>Metadata attached to the component.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#amaranth.lib.wiring.ComponentMetadata" title="amaranth.lib.wiring.ComponentMetadata"><code class="xref py py-class docutils literal notranslate"><span class="pre">ComponentMetadata</span></code></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="component-metadata">
<h2>Component metadata<a class="headerlink" href="#component-metadata" title="Permalink to this heading"></a></h2>
<dl class="py exception">
<dt class="sig sig-object py" id="amaranth.lib.wiring.InvalidMetadata">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">amaranth.lib.wiring.</span></span><span class="sig-name descname"><span class="pre">InvalidMetadata</span></span><a class="headerlink" href="#amaranth.lib.wiring.InvalidMetadata" title="Permalink to this definition"></a></dt>
<dd><p>Exception raised by <a class="reference internal" href="#amaranth.lib.wiring.ComponentMetadata.validate" title="amaranth.lib.wiring.ComponentMetadata.validate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ComponentMetadata.validate()</span></code></a> when the JSON representation of
a component’s metadata does not conform to its schema.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="amaranth.lib.wiring.ComponentMetadata">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">amaranth.lib.wiring.</span></span><span class="sig-name descname"><span class="pre">ComponentMetadata</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">origin</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amaranth.lib.wiring.ComponentMetadata" title="Permalink to this definition"></a></dt>
<dd><p>Component metadata.</p>
<p>Component <a class="reference internal" href="meta.html#meta"><span class="std std-ref">metadata</span></a> describes the interface of a <a class="reference internal" href="#amaranth.lib.wiring.Component" title="amaranth.lib.wiring.Component"><code class="xref py py-class docutils literal notranslate"><span class="pre">Component</span></code></a> and can be
exported to JSON for interoperability with non-Amaranth tooling.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>origin</strong> (<a class="reference internal" href="#amaranth.lib.wiring.Component" title="amaranth.lib.wiring.Component"><code class="xref py py-class docutils literal notranslate"><span class="pre">Component</span></code></a>) – Component described by this metadata instance.</p>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="amaranth.lib.wiring.ComponentMetadata.schema">
<span class="sig-name descname"><span class="pre">schema</span></span><em class="property"><span class="w"> </span><span class="pre">=</span> <span class="pre">{</span> <span class="pre">&quot;$id&quot;:</span> <span class="pre">&quot;https://amaranth-lang.org/schema/amaranth/0.5/component.json&quot;,</span> <span class="pre">...</span> <span class="pre">}</span></em><a class="headerlink" href="#amaranth.lib.wiring.ComponentMetadata.schema" title="Permalink to this definition"></a></dt>
<dd><p>Schema of component metadata, expressed in the <a class="reference external" href="https://json-schema.org">JSON Schema</a> language.</p>
<p>A copy of this schema can be retrieved <a class="reference external" href="https://amaranth-lang.org/schema/amaranth/0.5/component.json">from amaranth-lang.org</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="amaranth.lib.wiring.ComponentMetadata.origin">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">origin</span></span><a class="headerlink" href="#amaranth.lib.wiring.ComponentMetadata.origin" title="Permalink to this definition"></a></dt>
<dd><p>Component described by this metadata.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#amaranth.lib.wiring.Component" title="amaranth.lib.wiring.Component"><code class="xref py py-class docutils literal notranslate"><span class="pre">Component</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="amaranth.lib.wiring.ComponentMetadata.validate">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">validate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">instance</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amaranth.lib.wiring.ComponentMetadata.validate" title="Permalink to this definition"></a></dt>
<dd><p>Validate a JSON representation of component metadata against <a class="reference internal" href="#amaranth.lib.wiring.ComponentMetadata.schema" title="amaranth.lib.wiring.ComponentMetadata.schema"><code class="xref py py-attr docutils literal notranslate"><span class="pre">schema</span></code></a>.</p>
<p>This method does not validate annotations of the interface members, and consequently does
not make network requests.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>instance</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>) – JSON representation to validate, either previously returned by <a class="reference internal" href="#amaranth.lib.wiring.ComponentMetadata.as_json" title="amaranth.lib.wiring.ComponentMetadata.as_json"><code class="xref py py-meth docutils literal notranslate"><span class="pre">as_json()</span></code></a> or
retrieved from an external source.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#amaranth.lib.wiring.InvalidMetadata" title="amaranth.lib.wiring.InvalidMetadata"><strong>InvalidMetadata</strong></a> – If <code class="code highlight py python docutils literal highlight-python"><span class="n">instance</span></code> doesn’t conform to <a class="reference internal" href="#amaranth.lib.wiring.ComponentMetadata.schema" title="amaranth.lib.wiring.ComponentMetadata.schema"><code class="xref py py-attr docutils literal notranslate"><span class="pre">schema</span></code></a>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="amaranth.lib.wiring.ComponentMetadata.as_json">
<span class="sig-name descname"><span class="pre">as_json</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#amaranth.lib.wiring.ComponentMetadata.as_json" title="Permalink to this definition"></a></dt>
<dd><p>Translate to JSON.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>JSON representation of <a class="reference internal" href="#amaranth.lib.wiring.ComponentMetadata.origin" title="amaranth.lib.wiring.ComponentMetadata.origin"><code class="xref py py-attr docutils literal notranslate"><span class="pre">origin</span></code></a> that describes its interface members and includes
their annotations.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="data.html" class="btn btn-neutral float-left" title="Data structures" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="meta.html" class="btn btn-neutral float-right" title="Interface metadata" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020—2024, Amaranth project contributors.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>